pub fn sub_830EB490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EB490 size=1964
    let mut pc: u32 = 0x830EB490;
    'dispatch: loop {
        match pc {
            0x830EB490 => {
    //   block [0x830EB490..0x830EBC3C)
	// 830EB490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EB494: 480BCC9D  bl 0x831a8130
	ctx.lr = 0x830EB498;
	sub_831A8130(ctx, base);
	// 830EB498: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 830EB49C: 480BD5B9  bl 0x831a8a54
	ctx.lr = 0x830EB4A0;
	sub_831A8A40(ctx, base);
	// 830EB4A0: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EB4A4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830EB4A8: FE800890  fmr f20, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[20].f64 = ctx.f[1].f64;
	// 830EB4AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830EB4B0: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 830EB4B4: 9321028C  stw r25, 0x28c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(652 as u32), ctx.r[25].u32 ) };
	// 830EB4B8: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 830EB4BC: 93810294  stw r28, 0x294(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(660 as u32), ctx.r[28].u32 ) };
	// 830EB4C0: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 830EB4C4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830EB4C8: 93A102AC  stw r29, 0x2ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(684 as u32), ctx.r[29].u32 ) };
	// 830EB4CC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 830EB4D0: 936102BC  stw r27, 0x2bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[27].u32 ) };
	// 830EB4D4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830EB4D8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830EB4DC: 7D324B78  mr r18, r9
	ctx.r[18].u64 = ctx.r[9].u64;
	// 830EB4E0: 4BFFC329  bl 0x830e7808
	ctx.lr = 0x830EB4E4;
	sub_830E7808(ctx, base);
	// 830EB4E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB4E8: 41800744  blt 0x830ebc2c
	if ctx.cr[0].lt {
	pc = 0x830EBC2C; continue 'dispatch;
	}
	// 830EB4EC: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 830EB4F0: 827B0000  lwz r19, 0(r27)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB4F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EB4F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830EB4FC: 4BFF4F55  bl 0x830e0450
	ctx.lr = 0x830EB500;
	sub_830E0450(ctx, base);
	// 830EB500: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830EB504: 80970010  lwz r4, 0x10(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB508: 39F70010  addi r15, r23, 0x10
	ctx.r[15].s64 = ctx.r[23].s64 + 16;
	// 830EB50C: 48024E4D  bl 0x83110358
	ctx.lr = 0x830EB510;
	sub_83110358(ctx, base);
	// 830EB510: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EB514: 4080001C  bge 0x830eb530
	if !ctx.cr[0].lt {
	pc = 0x830EB530; continue 'dispatch;
	}
	// 830EB518: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 830EB51C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EB520: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830EB524: 4BFF4F8D  bl 0x830e04b0
	ctx.lr = 0x830EB528;
	sub_830E04B0(ctx, base);
	// 830EB528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EB52C: 48000700  b 0x830ebc2c
	pc = 0x830EBC2C; continue 'dispatch;
	// 830EB530: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 830EB534: C3210074  lfs f25, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 830EB538: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830EB53C: C3610060  lfs f27, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 830EB540: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830EB544: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 830EB548: D3210088  stfs f25, 0x88(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830EB54C: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 830EB550: D361008C  stfs f27, 0x8c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830EB554: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB558: C3EA94AC  lfs f31, -0x6b54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EB55C: 556A463E  srwi r10, r11, 0x18
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(24);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB560: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830EB564: 5568C63E  rlwinm r8, r11, 0x18, 0x18, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830EB568: D3C10080  stfs f30, 0x80(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830EB56C: 5569863E  rlwinm r9, r11, 0x10, 0x18, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 830EB570: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 830EB574: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830EB578: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830EB57C: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 830EB580: C9810068  lfd f12, 0x68(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830EB584: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 830EB588: C9A100A0  lfd f13, 0xa0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 830EB58C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 830EB590: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830EB594: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830EB598: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830EB59C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830EB5A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830EB5A4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830EB5A8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830EB5AC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830EB5B0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830EB5B4: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830EB5B8: EEA007F2  fmuls f21, f0, f31
	ctx.f[21].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EB5BC: EEEC07F2  fmuls f23, f12, f31
	ctx.f[23].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EB5C0: EF0D07F2  fmuls f24, f13, f31
	ctx.f[24].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EB5C4: EECB07F2  fmuls f22, f11, f31
	ctx.f[22].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EB5C8: 409A0110  bne cr6, 0x830eb6d8
	if !ctx.cr[6].eq {
	pc = 0x830EB6D8; continue 'dispatch;
	}
	// 830EB5CC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EBC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EBC40 size=464
    let mut pc: u32 = 0x830EBC40;
    'dispatch: loop {
        match pc {
            0x830EBC40 => {
    //   block [0x830EBC40..0x830EBE10)
	// 830EBC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EBC44: 480BC515  bl 0x831a8158
	ctx.lr = 0x830EBC48;
	sub_831A8130(ctx, base);
	// 830EBC48: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EBC4C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830EBC50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EBC54: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830EBC58: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830EBC5C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830EBC60: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 830EBC64: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 830EBC68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830EBC6C: 419A0010  beq cr6, 0x830ebc7c
	if ctx.cr[6].eq {
	pc = 0x830EBC7C; continue 'dispatch;
	}
	// 830EBC70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EBC74: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBC78: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EBC7C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830EBC80: 419A000C  beq cr6, 0x830ebc8c
	if ctx.cr[6].eq {
	pc = 0x830EBC8C; continue 'dispatch;
	}
	// 830EBC84: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EBC88: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EBC8C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830EBC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EBC94: 409A0010  bne cr6, 0x830ebca4
	if !ctx.cr[6].eq {
	pc = 0x830EBCA4; continue 'dispatch;
	}
	// 830EBC98: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBC9C: 4BFF9FFD  bl 0x830e5c98
	ctx.lr = 0x830EBCA0;
	sub_830E5C98(ctx, base);
	// 830EBCA0: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 830EBCA4: 83DF0024  lwz r30, 0x24(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830EBCA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EBCAC: 409A0034  bne cr6, 0x830ebce0
	if !ctx.cr[6].eq {
	pc = 0x830EBCE0; continue 'dispatch;
	}
	// 830EBCB0: 4BFE3069  bl 0x830ced18
	ctx.lr = 0x830EBCB4;
	sub_830CED18(ctx, base);
	// 830EBCB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EBCB8: 4182001C  beq 0x830ebcd4
	if ctx.cr[0].eq {
	pc = 0x830EBCD4; continue 'dispatch;
	}
	// 830EBCBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBCC0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EBCC4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBCC8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EBCCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EBCD0: 4E800421  bctrl
	ctx.lr = 0x830EBCD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EBCD4: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBCD8: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EBCDC: 48000128  b 0x830ebe04
	pc = 0x830EBE04; continue 'dispatch;
	// 830EBCE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EBCE4: 80DF0028  lwz r6, 0x28(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830EBCE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EBCEC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EBCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EBCF4: 4BFFB5D5  bl 0x830e72c8
	ctx.lr = 0x830EBCF8;
	sub_830E72C8(ctx, base);
	// 830EBCF8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EBCFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EBD00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EBD04: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 830EBD08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EBD0C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830EBD10: 4BFE9EB9  bl 0x830d5bc8
	ctx.lr = 0x830EBD14;
	sub_830D5BC8(ctx, base);
	// 830EBD14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EBD18: 418000F0  blt 0x830ebe08
	if ctx.cr[0].lt {
	pc = 0x830EBE08; continue 'dispatch;
	}
	// 830EBD1C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830EBD20: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EBD24: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EBD28: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBD2C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EBD30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830EBD34: 409A0010  bne cr6, 0x830ebd44
	if !ctx.cr[6].eq {
	pc = 0x830EBD44; continue 'dispatch;
	}
	// 830EBD38: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBD3C: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EBD40: 48000008  b 0x830ebd48
	pc = 0x830EBD48; continue 'dispatch;
	// 830EBD44: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EBD48: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830EBD4C: 419A000C  beq cr6, 0x830ebd58
	if ctx.cr[6].eq {
	pc = 0x830EBD58; continue 'dispatch;
	}
	// 830EBD50: C0010088  lfs f0, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBD54: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EBD58: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830EBD5C: 419A000C  beq cr6, 0x830ebd68
	if ctx.cr[6].eq {
	pc = 0x830EBD68; continue 'dispatch;
	}
	// 830EBD60: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 830EBD64: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EBD68: 81010090  lwz r8, 0x90(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 830EBD6C: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EBD70: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EBD74: 409A000C  bne cr6, 0x830ebd80
	if !ctx.cr[6].eq {
	pc = 0x830EBD80; continue 'dispatch;
	}
	// 830EBD78: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 830EBD7C: 419A0088  beq cr6, 0x830ebe04
	if ctx.cr[6].eq {
	pc = 0x830EBE04; continue 'dispatch;
	}
	// 830EBD80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EBD84: 409A0010  bne cr6, 0x830ebd94
	if !ctx.cr[6].eq {
	pc = 0x830EBD94; continue 'dispatch;
	}
	// 830EBD88: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830EBD8C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830EBD90: 48000078  b 0x830ebe08
	pc = 0x830EBE08; continue 'dispatch;
	// 830EBD94: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EBD98: 419AFFF0  beq cr6, 0x830ebd88
	if ctx.cr[6].eq {
	pc = 0x830EBD88; continue 'dispatch;
	}
	// 830EBD9C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 830EBDA0: 419AFFE8  beq cr6, 0x830ebd88
	if ctx.cr[6].eq {
	pc = 0x830EBD88; continue 'dispatch;
	}
	// 830EBDA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EBDA8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EBDAC: 40990040  ble cr6, 0x830ebdec
	if !ctx.cr[6].gt {
	pc = 0x830EBDEC; continue 'dispatch;
	}
	// 830EBDB0: 39670004  addi r11, r7, 4
	ctx.r[11].s64 = ctx.r[7].s64 + 4;
	// 830EBDB4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBDB8: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830EBDBC: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830EBDC0: 4198FFC8  blt cr6, 0x830ebd88
	if ctx.cr[6].lt {
	pc = 0x830EBD88; continue 'dispatch;
	}
	// 830EBDC4: 38C8FFFF  addi r6, r8, -1
	ctx.r[6].s64 = ctx.r[8].s64 + -1;
	// 830EBDC8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830EBDCC: 40980010  bge cr6, 0x830ebddc
	if !ctx.cr[6].lt {
	pc = 0x830EBDDC; continue 'dispatch;
	}
	// 830EBDD0: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EBDD4: 7F064800  cmpw cr6, r6, r9
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EBDD8: 4099FFB0  ble cr6, 0x830ebd88
	if !ctx.cr[6].gt {
	pc = 0x830EBD88; continue 'dispatch;
	}
	// 830EBDDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830EBDE0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830EBDE4: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830EBDE8: 4198FFCC  blt cr6, 0x830ebdb4
	if ctx.cr[6].lt {
	pc = 0x830EBDB4; continue 'dispatch;
	}
	// 830EBDEC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 830EBDF0: 419A0008  beq cr6, 0x830ebdf8
	if ctx.cr[6].eq {
	pc = 0x830EBDF8; continue 'dispatch;
	}
	// 830EBDF4: 91190000  stw r8, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830EBDF8: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830EBDFC: 419A0008  beq cr6, 0x830ebe04
	if ctx.cr[6].eq {
	pc = 0x830EBE04; continue 'dispatch;
	}
	// 830EBE00: 90F80000  stw r7, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 830EBE04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EBE08: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830EBE0C: 480BC39C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EBE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EBE10 size=640
    let mut pc: u32 = 0x830EBE10;
    'dispatch: loop {
        match pc {
            0x830EBE10 => {
    //   block [0x830EBE10..0x830EC090)
	// 830EBE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EBE14: 480BC359  bl 0x831a816c
	ctx.lr = 0x830EBE18;
	sub_831A8130(ctx, base);
	// 830EBE18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EBE1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EBE20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EBE24: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EBE28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EBE2C: 419A0138  beq cr6, 0x830ebf64
	if ctx.cr[6].eq {
	pc = 0x830EBF64; continue 'dispatch;
	}
	// 830EBE30: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 830EBE34: 419A0124  beq cr6, 0x830ebf58
	if ctx.cr[6].eq {
	pc = 0x830EBF58; continue 'dispatch;
	}
	// 830EBE38: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830EBE3C: 419A00EC  beq cr6, 0x830ebf28
	if ctx.cr[6].eq {
	pc = 0x830EBF28; continue 'dispatch;
	}
	// 830EBE40: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 830EBE44: 409A00D8  bne cr6, 0x830ebf1c
	if !ctx.cr[6].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EBE48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830EBE4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EBE50: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830EBE54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830EBE58: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830EBE5C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830EBE60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EBE64: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 830EBE68: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EBE6C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBE70: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EBE74: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830EBE78: 4BFFFDC9  bl 0x830ebc40
	ctx.lr = 0x830EBE7C;
	sub_830EBC40(ctx, base);
	// 830EBE7C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EBE80: 418000A0  blt 0x830ebf20
	if ctx.cr[0].lt {
	pc = 0x830EBF20; continue 'dispatch;
	}
	// 830EBE84: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EBE88: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EBE8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EBE90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EBE94: 419A0020  beq cr6, 0x830ebeb4
	if ctx.cr[6].eq {
	pc = 0x830EBEB4; continue 'dispatch;
	}
	// 830EBE98: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBE9C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 830EBEA0: 409A0014  bne cr6, 0x830ebeb4
	if !ctx.cr[6].eq {
	pc = 0x830EBEB4; continue 'dispatch;
	}
	// 830EBEA4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EBEA8: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 830EBEAC: 554A073D  rlwinm. r10, r10, 0, 0x1c, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EBEB0: 4182006C  beq 0x830ebf1c
	if ctx.cr[0].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EBEB4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EBEB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EBEBC: 419A0060  beq cr6, 0x830ebf1c
	if ctx.cr[6].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EBEC0: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBEC4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EBEC8: 41820054  beq 0x830ebf1c
	if ctx.cr[0].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EBECC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EBED0: D03F0020  stfs f1, 0x20(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830EBED4: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 830EBED8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EBEDC: 514B07F6  rlwimi r11, r10, 0, 0x1f, 0x1b
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFFF1) | (ctx.r[11].u64 & 0x000000000000000E);
	// 830EBEE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EBEE4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830EBEE8: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830EBEEC: 4801E84D  bl 0x8310a738
	ctx.lr = 0x830EBEF0;
	sub_8310A738(ctx, base);
	// 830EBEF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EBEF4: 41800020  blt 0x830ebf14
	if ctx.cr[0].lt {
	pc = 0x830EBF14; continue 'dispatch;
	}
	// 830EBEF8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EBEFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EBF00: 419A0008  beq cr6, 0x830ebf08
	if ctx.cr[6].eq {
	pc = 0x830EBF08; continue 'dispatch;
	}
	// 830EBF04: 4801E1CD  bl 0x8310a0d0
	ctx.lr = 0x830EBF08;
	sub_8310A0D0(ctx, base);
	// 830EBF08: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830EBF0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EBF10: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EBF14: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830EBF18: 41980008  blt cr6, 0x830ebf20
	if ctx.cr[6].lt {
	pc = 0x830EBF20; continue 'dispatch;
	}
	// 830EBF1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EBF20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EBF24: 480BC298  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 830EBF28: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EBF2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBF30: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EBF34: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830EBF38: 409AFFE4  bne cr6, 0x830ebf1c
	if !ctx.cr[6].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EBF3C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EBF40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EBF44: 419AFFD8  beq cr6, 0x830ebf1c
	if ctx.cr[6].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EBF48: 4801E189  bl 0x8310a0d0
	ctx.lr = 0x830EBF4C;
	sub_8310A0D0(ctx, base);
	// 830EBF4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EBF50: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EBF54: 4BFFFFC8  b 0x830ebf1c
	pc = 0x830EBF1C; continue 'dispatch;
	// 830EBF58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EBF5C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830EBF60: 4BFFFFBC  b 0x830ebf1c
	pc = 0x830EBF1C; continue 'dispatch;
	// 830EBF64: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830EBF68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EBF6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830EBF70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EBF74: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EBF78: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	// 830EBF7C: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 830EBF80: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830EBF84: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830EBF88: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 830EBF8C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 830EBF90: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 830EBF94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830EBF98: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBF9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EBFA0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830EBFA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EBFA8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830EBFAC: 4BFFFC95  bl 0x830ebc40
	ctx.lr = 0x830EBFB0;
	sub_830EBC40(ctx, base);
	// 830EBFB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EBFB4: 4180FF6C  blt 0x830ebf20
	if ctx.cr[0].lt {
	pc = 0x830EBF20; continue 'dispatch;
	}
	// 830EBFB8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EBFBC: C0210058  lfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EBFC0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EBFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EBFC8: 419A0020  beq cr6, 0x830ebfe8
	if ctx.cr[6].eq {
	pc = 0x830EBFE8; continue 'dispatch;
	}
	// 830EBFCC: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBFD0: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 830EBFD4: 409A0014  bne cr6, 0x830ebfe8
	if !ctx.cr[6].eq {
	pc = 0x830EBFE8; continue 'dispatch;
	}
	// 830EBFD8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EBFDC: 7D6BF278  xor r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[30].u64;
	// 830EBFE0: 556B073D  rlwinm. r11, r11, 0, 0x1c, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EBFE4: 41820064  beq 0x830ec048
	if ctx.cr[0].eq {
	pc = 0x830EC048; continue 'dispatch;
	}
	// 830EBFE8: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EBFEC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830EBFF0: 419A005C  beq cr6, 0x830ec04c
	if ctx.cr[6].eq {
	pc = 0x830EC04C; continue 'dispatch;
	}
	// 830EBFF4: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBFF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EBFFC: 41820050  beq 0x830ec04c
	if ctx.cr[0].eq {
	pc = 0x830EC04C; continue 'dispatch;
	}
	// 830EC000: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EC004: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830EC008: D03F0020  stfs f1, 0x20(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830EC00C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 830EC010: 516A07F6  rlwimi r10, r11, 0, 0x1f, 0x1b
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFFF1) | (ctx.r[10].u64 & 0x000000000000000E);
	// 830EC014: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC018: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EC01C: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 830EC020: 90BF0018  stw r5, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 830EC024: 4801E715  bl 0x8310a738
	ctx.lr = 0x830EC028;
	sub_8310A738(ctx, base);
	// 830EC028: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC02C: 4180001C  blt 0x830ec048
	if ctx.cr[0].lt {
	pc = 0x830EC048; continue 'dispatch;
	}
	// 830EC030: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EC034: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EC038: 419A0008  beq cr6, 0x830ec040
	if ctx.cr[6].eq {
	pc = 0x830EC040; continue 'dispatch;
	}
	// 830EC03C: 4801E095  bl 0x8310a0d0
	ctx.lr = 0x830EC040;
	sub_8310A0D0(ctx, base);
	// 830EC040: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EC044: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EC048: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC04C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EC050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC054: 419AFEC8  beq cr6, 0x830ebf1c
	if ctx.cr[6].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EC058: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830EC05C: 419AFEC0  beq cr6, 0x830ebf1c
	if ctx.cr[6].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EC060: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC064: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EC068: 4182FEB4  beq 0x830ebf1c
	if ctx.cr[0].eq {
	pc = 0x830EBF1C; continue 'dispatch;
	}
	// 830EC06C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830EC070: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC074: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830EC078: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830EC07C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC080: C0210060  lfs f1, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EC084: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830EC088: 4BFFF409  bl 0x830eb490
	ctx.lr = 0x830EC08C;
	sub_830EB490(ctx, base);
	// 830EC08C: 4BFFFE94  b 0x830ebf20
	pc = 0x830EBF20; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EC090 size=492
    let mut pc: u32 = 0x830EC090;
    'dispatch: loop {
        match pc {
            0x830EC090 => {
    //   block [0x830EC090..0x830EC27C)
	// 830EC090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC094: 480BC0D5  bl 0x831a8168
	ctx.lr = 0x830EC098;
	sub_831A8130(ctx, base);
	// 830EC098: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC09C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC0A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EC0A4: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 830EC0A8: 419A0174  beq cr6, 0x830ec21c
	if ctx.cr[6].eq {
	pc = 0x830EC21C; continue 'dispatch;
	}
	// 830EC0AC: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830EC0B0: 419A00A4  beq cr6, 0x830ec154
	if ctx.cr[6].eq {
	pc = 0x830EC154; continue 'dispatch;
	}
	// 830EC0B4: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830EC0B8: 419A005C  beq cr6, 0x830ec114
	if ctx.cr[6].eq {
	pc = 0x830EC114; continue 'dispatch;
	}
	// 830EC0BC: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830EC0C0: 409A01B0  bne cr6, 0x830ec270
	if !ctx.cr[6].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC0C4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EC0C8: 83C40010  lwz r30, 0x10(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC0CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC0D0: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830EC0D4: 4BFE2A9D  bl 0x830ceb70
	ctx.lr = 0x830EC0D8;
	sub_830CEB70(ctx, base);
	// 830EC0D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EC0DC: 41820194  beq 0x830ec270
	if ctx.cr[0].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC0E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EC0E4: 4BFE238D  bl 0x830ce470
	ctx.lr = 0x830EC0E8;
	sub_830CE470(ctx, base);
	// 830EC0E8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC0EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EC0F0: 419A0180  beq cr6, 0x830ec270
	if ctx.cr[6].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC0F4: C05E000C  lfs f2, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830EC0F8: C03E0008  lfs f1, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EC0FC: 4BFF975D  bl 0x830e5858
	ctx.lr = 0x830EC100;
	sub_830E5858(ctx, base);
	// 830EC100: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC104: C05E000C  lfs f2, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830EC108: C03E0008  lfs f1, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EC10C: 4BFFD3BD  bl 0x830e94c8
	ctx.lr = 0x830EC110;
	sub_830E94C8(ctx, base);
	// 830EC110: 48000160  b 0x830ec270
	pc = 0x830EC270; continue 'dispatch;
	// 830EC114: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC118: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC11C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830EC120: 409A0150  bne cr6, 0x830ec270
	if !ctx.cr[6].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC124: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EC128: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC12C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC130: 4BFF3CC1  bl 0x830dfdf0
	ctx.lr = 0x830EC134;
	sub_830DFDF0(ctx, base);
	// 830EC134: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC138: 41820138  beq 0x830ec270
	if ctx.cr[0].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC13C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC140: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC144: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EC148: 419A0128  beq cr6, 0x830ec270
	if ctx.cr[6].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC14C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EC150: 48000120  b 0x830ec270
	pc = 0x830EC270; continue 'dispatch;
	// 830EC154: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EC158: 83C40010  lwz r30, 0x10(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC15C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EC160: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC164: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC168: 4BFE2AA9  bl 0x830cec10
	ctx.lr = 0x830EC16C;
	sub_830CEC10(ctx, base);
	// 830EC16C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EC170: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EC174: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830EC178: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EC17C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EC180: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830EC184: 4BFFAB05  bl 0x830e6c88
	ctx.lr = 0x830EC188;
	sub_830E6C88(ctx, base);
	// 830EC188: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830EC18C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EC190: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830EC194: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC198: 4BFF35C1  bl 0x830df758
	ctx.lr = 0x830EC19C;
	sub_830DF758(ctx, base);
	// 830EC19C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830EC1A0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC1A4: 4BFE9BB5  bl 0x830d5d58
	ctx.lr = 0x830EC1A8;
	sub_830D5D58(ctx, base);
	// 830EC1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC1AC: 4BFF9B65  bl 0x830e5d10
	ctx.lr = 0x830EC1B0;
	sub_830E5D10(ctx, base);
	// 830EC1B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC1B4: 4182001C  beq 0x830ec1d0
	if ctx.cr[0].eq {
	pc = 0x830EC1D0; continue 'dispatch;
	}
	// 830EC1B8: 889E0004  lbz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC1BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC1C0: 4BFF6A61  bl 0x830e2c20
	ctx.lr = 0x830EC1C4;
	sub_830E2C20(ctx, base);
	// 830EC1C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC1C8: 4180000C  blt 0x830ec1d4
	if ctx.cr[0].lt {
	pc = 0x830EC1D4; continue 'dispatch;
	}
	// 830EC1CC: 480000A4  b 0x830ec270
	pc = 0x830EC270; continue 'dispatch;
	// 830EC1D0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830EC1D4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830EC1D8: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC1DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC1E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830EC1E4: 4BFF472D  bl 0x830e0910
	ctx.lr = 0x830EC1E8;
	sub_830E0910(ctx, base);
	// 830EC1E8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830EC1EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC1F0: 4BFE99D9  bl 0x830d5bc8
	ctx.lr = 0x830EC1F4;
	sub_830D5BC8(ctx, base);
	// 830EC1F4: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EC1F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC1FC: 419A0074  beq cr6, 0x830ec270
	if ctx.cr[6].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC200: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830EC204: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC208: 409A0068  bne cr6, 0x830ec270
	if !ctx.cr[6].eq {
	pc = 0x830EC270; continue 'dispatch;
	}
	// 830EC20C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EC210: 889E0004  lbz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC214: 4BFF6A0D  bl 0x830e2c20
	ctx.lr = 0x830EC218;
	sub_830E2C20(ctx, base);
	// 830EC218: 48000058  b 0x830ec270
	pc = 0x830EC270; continue 'dispatch;
	// 830EC21C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830EC220: 83C40010  lwz r30, 0x10(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC224: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830EC228: 93A40008  stw r29, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 830EC22C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC230: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830EC234: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC238: 4BFF46D9  bl 0x830e0910
	ctx.lr = 0x830EC23C;
	sub_830E0910(ctx, base);
	// 830EC23C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830EC240: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC244: 4BFE9985  bl 0x830d5bc8
	ctx.lr = 0x830EC248;
	sub_830D5BC8(ctx, base);
	// 830EC248: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EC24C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC250: 419A0018  beq cr6, 0x830ec268
	if ctx.cr[6].eq {
	pc = 0x830EC268; continue 'dispatch;
	}
	// 830EC254: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830EC258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC25C: 409A000C  bne cr6, 0x830ec268
	if !ctx.cr[6].eq {
	pc = 0x830EC268; continue 'dispatch;
	}
	// 830EC260: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830EC264: 4800000C  b 0x830ec270
	pc = 0x830EC270; continue 'dispatch;
	// 830EC268: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EC26C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EC270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EC274: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830EC278: 480BBF40  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EC280 size=108
    let mut pc: u32 = 0x830EC280;
    'dispatch: loop {
        match pc {
            0x830EC280 => {
    //   block [0x830EC280..0x830EC2EC)
	// 830EC280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC284: 480BBEE9  bl 0x831a816c
	ctx.lr = 0x830EC288;
	sub_831A8130(ctx, base);
	// 830EC288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC28C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830EC290: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EC294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC298: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EC29C: 4BFF17D5  bl 0x830dda70
	ctx.lr = 0x830EC2A0;
	sub_830DDA70(ctx, base);
	// 830EC2A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC2A4: 41820014  beq 0x830ec2b8
	if ctx.cr[0].eq {
	pc = 0x830EC2B8; continue 'dispatch;
	}
	// 830EC2A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC2AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EC2B0: 4BFE29D9  bl 0x830cec88
	ctx.lr = 0x830EC2B4;
	sub_830CEC88(ctx, base);
	// 830EC2B4: 48000030  b 0x830ec2e4
	pc = 0x830EC2E4; continue 'dispatch;
	// 830EC2B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830EC2BC: 409A0010  bne cr6, 0x830ec2cc
	if !ctx.cr[6].eq {
	pc = 0x830EC2CC; continue 'dispatch;
	}
	// 830EC2C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EC2C4: 4BFF6C75  bl 0x830e2f38
	ctx.lr = 0x830EC2C8;
	sub_830E2F38(ctx, base);
	// 830EC2C8: 4800000C  b 0x830ec2d4
	pc = 0x830EC2D4; continue 'dispatch;
	// 830EC2CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EC2D0: 4BFFB4E1  bl 0x830e77b0
	ctx.lr = 0x830EC2D4;
	sub_830E77B0(ctx, base);
	// 830EC2D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EC2D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EC2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EC2E0: 4BFF1841  bl 0x830ddb20
	ctx.lr = 0x830EC2E4;
	sub_830DDB20(ctx, base);
	// 830EC2E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EC2E8: 480BBED4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EC2F0 size=180
    let mut pc: u32 = 0x830EC2F0;
    'dispatch: loop {
        match pc {
            0x830EC2F0 => {
    //   block [0x830EC2F0..0x830EC3A4)
	// 830EC2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EC2F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EC2FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC300: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EC304: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC308: 2B0B0018  cmplwi cr6, r11, 0x18
	ctx.cr[6].compare_u32(ctx.r[11].u32, 24 as u32, &mut ctx.xer);
	// 830EC30C: 419A006C  beq cr6, 0x830ec378
	if ctx.cr[6].eq {
	pc = 0x830EC378; continue 'dispatch;
	}
	// 830EC310: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 830EC314: 419A0040  beq cr6, 0x830ec354
	if ctx.cr[6].eq {
	pc = 0x830EC354; continue 'dispatch;
	}
	// 830EC318: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 830EC31C: 419A0024  beq cr6, 0x830ec340
	if ctx.cr[6].eq {
	pc = 0x830EC340; continue 'dispatch;
	}
	// 830EC320: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 830EC324: 419A0014  beq cr6, 0x830ec338
	if ctx.cr[6].eq {
	pc = 0x830EC338; continue 'dispatch;
	}
	// 830EC328: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 830EC32C: 409A0060  bne cr6, 0x830ec38c
	if !ctx.cr[6].eq {
	pc = 0x830EC38C; continue 'dispatch;
	}
	// 830EC330: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 830EC334: 48000024  b 0x830ec358
	pc = 0x830EC358; continue 'dispatch;
	// 830EC338: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC33C: 48000040  b 0x830ec37c
	pc = 0x830EC37C; continue 'dispatch;
	// 830EC340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EC344: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EC348: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC34C: 4BFFE625  bl 0x830ea970
	ctx.lr = 0x830EC350;
	sub_830EA970(ctx, base);
	// 830EC350: 4800003C  b 0x830ec38c
	pc = 0x830EC38C; continue 'dispatch;
	// 830EC354: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 830EC358: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC35C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC360: 4BFE2929  bl 0x830cec88
	ctx.lr = 0x830EC364;
	sub_830CEC88(ctx, base);
	// 830EC364: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC368: 41800028  blt 0x830ec390
	if ctx.cr[0].lt {
	pc = 0x830EC390; continue 'dispatch;
	}
	// 830EC36C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EC370: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EC374: 48000018  b 0x830ec38c
	pc = 0x830EC38C; continue 'dispatch;
	// 830EC378: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC37C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC380: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EC384: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EC388: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EC38C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EC390: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EC394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EC398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EC39C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EC3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EC3A8 size=556
    let mut pc: u32 = 0x830EC3A8;
    'dispatch: loop {
        match pc {
            0x830EC3A8 => {
    //   block [0x830EC3A8..0x830EC5D4)
	// 830EC3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC3AC: 480BBDB9  bl 0x831a8164
	ctx.lr = 0x830EC3B0;
	sub_831A8130(ctx, base);
	// 830EC3B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC3B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EC3B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EC3BC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830EC3C0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830EC3C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EC3C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC3CC: 4BFF518D  bl 0x830e1558
	ctx.lr = 0x830EC3D0;
	sub_830E1558(ctx, base);
	// 830EC3D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC3D8: 419A01F4  beq cr6, 0x830ec5cc
	if ctx.cr[6].eq {
	pc = 0x830EC5CC; continue 'dispatch;
	}
	// 830EC3DC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC3E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC3E4: 419A000C  beq cr6, 0x830ec3f0
	if ctx.cr[6].eq {
	pc = 0x830EC3F0; continue 'dispatch;
	}
	// 830EC3E8: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC3EC: 48000010  b 0x830ec3fc
	pc = 0x830EC3FC; continue 'dispatch;
	// 830EC3F0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC3F4: 4BFF5015  bl 0x830e1408
	ctx.lr = 0x830EC3F8;
	sub_830E1408(ctx, base);
	// 830EC3F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EC3FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC400: 4BFE2811  bl 0x830cec10
	ctx.lr = 0x830EC404;
	sub_830CEC10(ctx, base);
	// 830EC404: 4BFF479D  bl 0x830e0ba0
	ctx.lr = 0x830EC408;
	sub_830E0BA0(ctx, base);
	// 830EC408: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC40C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EC410: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC414: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EC418: 419A00C0  beq cr6, 0x830ec4d8
	if ctx.cr[6].eq {
	pc = 0x830EC4D8; continue 'dispatch;
	}
	// 830EC41C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC420: 4BFE27F1  bl 0x830cec10
	ctx.lr = 0x830EC424;
	sub_830CEC10(ctx, base);
	// 830EC424: 4BFFB91D  bl 0x830e7d40
	ctx.lr = 0x830EC428;
	sub_830E7D40(ctx, base);
	// 830EC428: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC42C: 418200AC  beq 0x830ec4d8
	if ctx.cr[0].eq {
	pc = 0x830EC4D8; continue 'dispatch;
	}
	// 830EC430: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EC434: 419A0040  beq cr6, 0x830ec474
	if ctx.cr[6].eq {
	pc = 0x830EC474; continue 'dispatch;
	}
	// 830EC438: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC43C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EC440: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EC444: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EC448: 419A0018  beq cr6, 0x830ec460
	if ctx.cr[6].eq {
	pc = 0x830EC460; continue 'dispatch;
	}
	// 830EC44C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC450: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC454: 38AB904C  addi r5, r11, -0x6fb4
	ctx.r[5].s64 = ctx.r[11].s64 + -28596;
	// 830EC458: 388A9060  addi r4, r10, -0x6fa0
	ctx.r[4].s64 = ctx.r[10].s64 + -28576;
	// 830EC45C: 48000074  b 0x830ec4d0
	pc = 0x830EC4D0; continue 'dispatch;
	// 830EC460: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC464: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC468: 38AB9014  addi r5, r11, -0x6fec
	ctx.r[5].s64 = ctx.r[11].s64 + -28652;
	// 830EC46C: 388A9034  addi r4, r10, -0x6fcc
	ctx.r[4].s64 = ctx.r[10].s64 + -28620;
	// 830EC470: 48000060  b 0x830ec4d0
	pc = 0x830EC4D0; continue 'dispatch;
	// 830EC474: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC478: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC47C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EC480: 3BCB8BF4  addi r30, r11, -0x740c
	ctx.r[30].s64 = ctx.r[11].s64 + -29708;
	// 830EC484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EC488: 4BFF3D31  bl 0x830e01b8
	ctx.lr = 0x830EC48C;
	sub_830E01B8(ctx, base);
	// 830EC48C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC490: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830EC494: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC498: 3BAB8BD4  addi r29, r11, -0x742c
	ctx.r[29].s64 = ctx.r[11].s64 + -29740;
	// 830EC49C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EC4A0: 4BFF3D19  bl 0x830e01b8
	ctx.lr = 0x830EC4A4;
	sub_830E01B8(ctx, base);
	// 830EC4A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EC4A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC4AC: 41980120  blt cr6, 0x830ec5cc
	if ctx.cr[6].lt {
	pc = 0x830EC5CC; continue 'dispatch;
	}
	// 830EC4B0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830EC4B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC4B8: 41980114  blt cr6, 0x830ec5cc
	if ctx.cr[6].lt {
	pc = 0x830EC5CC; continue 'dispatch;
	}
	// 830EC4BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC4C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EC4C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EC4C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EC4CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EC4D0: 4BFF5289  bl 0x830e1758
	ctx.lr = 0x830EC4D4;
	sub_830E1758(ctx, base);
	// 830EC4D4: 480000F8  b 0x830ec5cc
	pc = 0x830EC5CC; continue 'dispatch;
	// 830EC4D8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EC4DC: 409A00B8  bne cr6, 0x830ec594
	if !ctx.cr[6].eq {
	pc = 0x830EC594; continue 'dispatch;
	}
	// 830EC4E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC4E4: 4BFF98B5  bl 0x830e5d98
	ctx.lr = 0x830EC4E8;
	sub_830E5D98(ctx, base);
	// 830EC4E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EC4EC: 418200A8  beq 0x830ec594
	if ctx.cr[0].eq {
	pc = 0x830EC594; continue 'dispatch;
	}
	// 830EC4F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EC4F4: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 830EC4F8: 4BFFB469  bl 0x830e7960
	ctx.lr = 0x830EC4FC;
	sub_830E7960(ctx, base);
	// 830EC4FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC500: 4BFE2711  bl 0x830cec10
	ctx.lr = 0x830EC504;
	sub_830CEC10(ctx, base);
	// 830EC504: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EC508: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830EC50C: 409A0088  bne cr6, 0x830ec594
	if !ctx.cr[6].eq {
	pc = 0x830EC594; continue 'dispatch;
	}
	// 830EC510: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC514: 4BFE26FD  bl 0x830cec10
	ctx.lr = 0x830EC518;
	sub_830CEC10(ctx, base);
	// 830EC518: 4BFFB941  bl 0x830e7e58
	ctx.lr = 0x830EC51C;
	sub_830E7E58(ctx, base);
	// 830EC51C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EC520: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EC524: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EC528: 419A0038  beq cr6, 0x830ec560
	if ctx.cr[6].eq {
	pc = 0x830EC560; continue 'dispatch;
	}
	// 830EC52C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830EC530: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC534: 419A0018  beq cr6, 0x830ec54c
	if ctx.cr[6].eq {
	pc = 0x830EC54C; continue 'dispatch;
	}
	// 830EC538: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC53C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC540: 38AB8E90  addi r5, r11, -0x7170
	ctx.r[5].s64 = ctx.r[11].s64 + -29040;
	// 830EC544: 388A8EB4  addi r4, r10, -0x714c
	ctx.r[4].s64 = ctx.r[10].s64 + -29004;
	// 830EC548: 4BFFFF88  b 0x830ec4d0
	pc = 0x830EC4D0; continue 'dispatch;
	// 830EC54C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC550: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC554: 38AB8ED4  addi r5, r11, -0x712c
	ctx.r[5].s64 = ctx.r[11].s64 + -28972;
	// 830EC558: 388A8EF0  addi r4, r10, -0x7110
	ctx.r[4].s64 = ctx.r[10].s64 + -28944;
	// 830EC55C: 4BFFFF74  b 0x830ec4d0
	pc = 0x830EC4D0; continue 'dispatch;
	// 830EC560: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830EC564: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC568: 419A0018  beq cr6, 0x830ec580
	if ctx.cr[6].eq {
	pc = 0x830EC580; continue 'dispatch;
	}
	// 830EC56C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC570: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC574: 38AB8DE4  addi r5, r11, -0x721c
	ctx.r[5].s64 = ctx.r[11].s64 + -29212;
	// 830EC578: 388A8E18  addi r4, r10, -0x71e8
	ctx.r[4].s64 = ctx.r[10].s64 + -29160;
	// 830EC57C: 4BFFFF54  b 0x830ec4d0
	pc = 0x830EC4D0; continue 'dispatch;
	// 830EC580: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC584: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC588: 38AB8E44  addi r5, r11, -0x71bc
	ctx.r[5].s64 = ctx.r[11].s64 + -29116;
	// 830EC58C: 388A8E6C  addi r4, r10, -0x7194
	ctx.r[4].s64 = ctx.r[10].s64 + -29076;
	// 830EC590: 4BFFFF40  b 0x830ec4d0
	pc = 0x830EC4D0; continue 'dispatch;
	// 830EC594: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 830EC598: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EC59C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC5A0: 4BFE1F79  bl 0x830ce518
	ctx.lr = 0x830EC5A4;
	sub_830CE518(ctx, base);
	// 830EC5A4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EC5A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EC5AC: 419A0020  beq cr6, 0x830ec5cc
	if ctx.cr[6].eq {
	pc = 0x830EC5CC; continue 'dispatch;
	}
	// 830EC5B0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC5B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC5B8: 419A0010  beq cr6, 0x830ec5c8
	if ctx.cr[6].eq {
	pc = 0x830EC5C8; continue 'dispatch;
	}
	// 830EC5BC: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC5C0: 4BFFB851  bl 0x830e7e10
	ctx.lr = 0x830EC5C4;
	sub_830E7E10(ctx, base);
	// 830EC5C4: 48000008  b 0x830ec5cc
	pc = 0x830EC5CC; continue 'dispatch;
	// 830EC5C8: 4BFFB809  bl 0x830e7dd0
	ctx.lr = 0x830EC5CC;
	sub_830E7DD0(ctx, base);
	// 830EC5CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EC5D0: 480BBBE4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EC5D8 size=772
    let mut pc: u32 = 0x830EC5D8;
    'dispatch: loop {
        match pc {
            0x830EC5D8 => {
    //   block [0x830EC5D8..0x830EC8DC)
	// 830EC5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC5DC: 480BBB89  bl 0x831a8164
	ctx.lr = 0x830EC5E0;
	sub_831A8130(ctx, base);
	// 830EC5E0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC5E4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EC5E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EC5EC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830EC5F0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC5F4: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC5F8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EC5FC: 419A0024  beq cr6, 0x830ec620
	if ctx.cr[6].eq {
	pc = 0x830EC620; continue 'dispatch;
	}
	// 830EC600: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC604: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830EC608: 419A00D0  beq cr6, 0x830ec6d8
	if ctx.cr[6].eq {
	pc = 0x830EC6D8; continue 'dispatch;
	}
	// 830EC60C: 2B0B07D0  cmplwi cr6, r11, 0x7d0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2000 as u32, &mut ctx.xer);
	// 830EC610: 419A00B4  beq cr6, 0x830ec6c4
	if ctx.cr[6].eq {
	pc = 0x830EC6C4; continue 'dispatch;
	}
	// 830EC614: 2B0B07D1  cmplwi cr6, r11, 0x7d1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2001 as u32, &mut ctx.xer);
	// 830EC618: 409A0008  bne cr6, 0x830ec620
	if !ctx.cr[6].eq {
	pc = 0x830EC620; continue 'dispatch;
	}
	// 830EC61C: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830EC620: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC624: 2B0B0025  cmplwi cr6, r11, 0x25
	ctx.cr[6].compare_u32(ctx.r[11].u32, 37 as u32, &mut ctx.xer);
	// 830EC628: 419A026C  beq cr6, 0x830ec894
	if ctx.cr[6].eq {
	pc = 0x830EC894; continue 'dispatch;
	}
	// 830EC62C: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830EC630: 419A0250  beq cr6, 0x830ec880
	if ctx.cr[6].eq {
	pc = 0x830EC880; continue 'dispatch;
	}
	// 830EC634: 2B0B07DF  cmplwi cr6, r11, 0x7df
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2015 as u32, &mut ctx.xer);
	// 830EC638: 419A019C  beq cr6, 0x830ec7d4
	if ctx.cr[6].eq {
	pc = 0x830EC7D4; continue 'dispatch;
	}
	// 830EC63C: 2B0B07E1  cmplwi cr6, r11, 0x7e1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2017 as u32, &mut ctx.xer);
	// 830EC640: 419A0100  beq cr6, 0x830ec740
	if ctx.cr[6].eq {
	pc = 0x830EC740; continue 'dispatch;
	}
	// 830EC644: 2B0B07E6  cmplwi cr6, r11, 0x7e6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2022 as u32, &mut ctx.xer);
	// 830EC648: 419A00B4  beq cr6, 0x830ec6fc
	if ctx.cr[6].eq {
	pc = 0x830EC6FC; continue 'dispatch;
	}
	// 830EC64C: 2B0B0800  cmplwi cr6, r11, 0x800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2048 as u32, &mut ctx.xer);
	// 830EC650: 409A0280  bne cr6, 0x830ec8d0
	if !ctx.cr[6].eq {
	pc = 0x830EC8D0; continue 'dispatch;
	}
	// 830EC654: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC658: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC65C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC660: 419A000C  beq cr6, 0x830ec66c
	if ctx.cr[6].eq {
	pc = 0x830EC66C; continue 'dispatch;
	}
	// 830EC664: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EC668: 409A0268  bne cr6, 0x830ec8d0
	if !ctx.cr[6].eq {
	pc = 0x830EC8D0; continue 'dispatch;
	}
	// 830EC66C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC670: 4BFF9729  bl 0x830e5d98
	ctx.lr = 0x830EC674;
	sub_830E5D98(ctx, base);
	// 830EC674: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EC678: 41820254  beq 0x830ec8cc
	if ctx.cr[0].eq {
	pc = 0x830EC8CC; continue 'dispatch;
	}
	// 830EC67C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EC680: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC684: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EC688: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830EC68C: 4BFF4285  bl 0x830e0910
	ctx.lr = 0x830EC690;
	sub_830E0910(ctx, base);
	// 830EC690: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EC694: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EC698: 4BFE9531  bl 0x830d5bc8
	ctx.lr = 0x830EC69C;
	sub_830D5BC8(ctx, base);
	// 830EC69C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830EC6A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC6A4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC6A8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC6AC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EC6B0: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830EC6B4: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830EC6B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EC6BC: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EC6C0: 4800020C  b 0x830ec8cc
	pc = 0x830EC8CC; continue 'dispatch;
	// 830EC6C4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC6C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EC6CC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830EC6D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EC6D4: 4BFFFF4C  b 0x830ec620
	pc = 0x830EC620; continue 'dispatch;
	// 830EC6D8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC6DC: 886B000C  lbz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EC6E0: 4BFF24B9  bl 0x830deb98
	ctx.lr = 0x830EC6E4;
	sub_830DEB98(ctx, base);
	// 830EC6E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC6E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC6EC: 419AFF34  beq cr6, 0x830ec620
	if ctx.cr[6].eq {
	pc = 0x830EC620; continue 'dispatch;
	}
	// 830EC6F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EC6F4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EC6F8: 480001D8  b 0x830ec8d0
	pc = 0x830EC8D0; continue 'dispatch;
	// 830EC6FC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC700: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EC704: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830EC708: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC70C: 4BFE2465  bl 0x830ceb70
	ctx.lr = 0x830EC710;
	sub_830CEB70(ctx, base);
	// 830EC710: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC714: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EC718: 409A01B8  bne cr6, 0x830ec8d0
	if !ctx.cr[6].eq {
	pc = 0x830EC8D0; continue 'dispatch;
	}
	// 830EC71C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC720: 4BFF9679  bl 0x830e5d98
	ctx.lr = 0x830EC724;
	sub_830E5D98(ctx, base);
	// 830EC724: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EC728: 418201A8  beq 0x830ec8d0
	if ctx.cr[0].eq {
	pc = 0x830EC8D0; continue 'dispatch;
	}
	// 830EC72C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC730: 4BFE9499  bl 0x830d5bc8
	ctx.lr = 0x830EC734;
	sub_830D5BC8(ctx, base);
	// 830EC734: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC738: 40800198  bge 0x830ec8d0
	if !ctx.cr[0].lt {
	pc = 0x830EC8D0; continue 'dispatch;
	}
	// 830EC73C: 48000198  b 0x830ec8d4
	pc = 0x830EC8D4; continue 'dispatch;
	// 830EC740: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC744: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC748: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC74C: 409A0098  bne cr6, 0x830ec7e4
	if !ctx.cr[6].eq {
	pc = 0x830EC7E4; continue 'dispatch;
	}
	// 830EC750: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC754: 4BFF9645  bl 0x830e5d98
	ctx.lr = 0x830EC758;
	sub_830E5D98(ctx, base);
	// 830EC758: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EC75C: 418200A4  beq 0x830ec800
	if ctx.cr[0].eq {
	pc = 0x830EC800; continue 'dispatch;
	}
	// 830EC760: 837E0004  lwz r27, 4(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC764: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC768: 4BFE24A9  bl 0x830cec10
	ctx.lr = 0x830EC76C;
	sub_830CEC10(ctx, base);
	// 830EC76C: 4BFF2975  bl 0x830df0e0
	ctx.lr = 0x830EC770;
	sub_830DF0E0(ctx, base);
	// 830EC770: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830EC774: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EC778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC77C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830EC780: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830EC784: 4BFFAB9D  bl 0x830e7320
	ctx.lr = 0x830EC788;
	sub_830E7320(ctx, base);
	// 830EC788: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830EC78C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830EC790: 419A0018  beq cr6, 0x830ec7a8
	if ctx.cr[6].eq {
	pc = 0x830EC7A8; continue 'dispatch;
	}
	// 830EC794: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EC798: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EC79C: 4BFE942D  bl 0x830d5bc8
	ctx.lr = 0x830EC7A0;
	sub_830D5BC8(ctx, base);
	// 830EC7A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC7A4: 41800130  blt 0x830ec8d4
	if ctx.cr[0].lt {
	pc = 0x830EC8D4; continue 'dispatch;
	}
	// 830EC7A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EC7AC: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830EC7B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EC7B4: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830EC7B8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EC7BC: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EC7C0: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EC7C4: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830EC7C8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EC7CC: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EC7D0: 48000100  b 0x830ec8d0
	pc = 0x830EC8D0; continue 'dispatch;
	// 830EC7D4: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC7D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC7DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC7E0: 419A0010  beq cr6, 0x830ec7f0
	if ctx.cr[6].eq {
	pc = 0x830EC7F0; continue 'dispatch;
	}
	// 830EC7E4: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EC7E8: 60630021  ori r3, r3, 0x21
	ctx.r[3].u64 = ctx.r[3].u64 | 33;
	// 830EC7EC: 480000E8  b 0x830ec8d4
	pc = 0x830EC8D4; continue 'dispatch;
	// 830EC7F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC7F4: 4BFF95A5  bl 0x830e5d98
	ctx.lr = 0x830EC7F8;
	sub_830E5D98(ctx, base);
	// 830EC7F8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EC7FC: 40820010  bne 0x830ec80c
	if !ctx.cr[0].eq {
	pc = 0x830EC80C; continue 'dispatch;
	}
	// 830EC800: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EC804: 6063000B  ori r3, r3, 0xb
	ctx.r[3].u64 = ctx.r[3].u64 | 11;
	// 830EC808: 480000CC  b 0x830ec8d4
	pc = 0x830EC8D4; continue 'dispatch;
	// 830EC80C: 837E0004  lwz r27, 4(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC810: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC814: 4BFE23FD  bl 0x830cec10
	ctx.lr = 0x830EC818;
	sub_830CEC10(ctx, base);
	// 830EC818: 4BFF28C9  bl 0x830df0e0
	ctx.lr = 0x830EC81C;
	sub_830DF0E0(ctx, base);
	// 830EC81C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830EC820: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EC824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC828: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830EC82C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830EC830: 4BFFAA99  bl 0x830e72c8
	ctx.lr = 0x830EC834;
	sub_830E72C8(ctx, base);
	// 830EC834: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830EC838: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830EC83C: 419A0018  beq cr6, 0x830ec854
	if ctx.cr[6].eq {
	pc = 0x830EC854; continue 'dispatch;
	}
	// 830EC840: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EC844: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EC848: 4BFE9381  bl 0x830d5bc8
	ctx.lr = 0x830EC84C;
	sub_830D5BC8(ctx, base);
	// 830EC84C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EC850: 41800084  blt 0x830ec8d4
	if ctx.cr[0].lt {
	pc = 0x830EC8D4; continue 'dispatch;
	}
	// 830EC854: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EC858: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EC85C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EC860: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830EC864: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EC868: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830EC86C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 830EC870: 917E0020  stw r11, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830EC874: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EC878: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830EC87C: 48000054  b 0x830ec8d0
	pc = 0x830EC8D0; continue 'dispatch;
	// 830EC880: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830EC884: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC888: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC88C: 4BFFFB1D  bl 0x830ec3a8
	ctx.lr = 0x830EC890;
	sub_830EC3A8(ctx, base);
	// 830EC890: 48000040  b 0x830ec8d0
	pc = 0x830EC8D0; continue 'dispatch;
	// 830EC894: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC898: 4BFF9501  bl 0x830e5d98
	ctx.lr = 0x830EC89C;
	sub_830E5D98(ctx, base);
	// 830EC89C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EC8A0: 41820030  beq 0x830ec8d0
	if ctx.cr[0].eq {
	pc = 0x830EC8D0; continue 'dispatch;
	}
	// 830EC8A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EC8A8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC8AC: 4BFF2435  bl 0x830dece0
	ctx.lr = 0x830EC8B0;
	sub_830DECE0(ctx, base);
	// 830EC8B0: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830EC8B4: 419A000C  beq cr6, 0x830ec8c0
	if ctx.cr[6].eq {
	pc = 0x830EC8C0; continue 'dispatch;
	}
	// 830EC8B8: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830EC8BC: 409A0014  bne cr6, 0x830ec8d0
	if !ctx.cr[6].eq {
	pc = 0x830EC8D0; continue 'dispatch;
	}
	// 830EC8C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC8C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EC8C8: 4BFE9301  bl 0x830d5bc8
	ctx.lr = 0x830EC8CC;
	sub_830D5BC8(ctx, base);
	// 830EC8CC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830EC8D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EC8D4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830EC8D8: 480BB8DC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EC8E0 size=228
    let mut pc: u32 = 0x830EC8E0;
    'dispatch: loop {
        match pc {
            0x830EC8E0 => {
    //   block [0x830EC8E0..0x830EC9C4)
	// 830EC8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EC8E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EC8EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EC8F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC8F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EC8F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EC8FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EC900: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EC904: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830EC908: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC90C: 4BFF4C4D  bl 0x830e1558
	ctx.lr = 0x830EC910;
	sub_830E1558(ctx, base);
	// 830EC910: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC918: 419A0094  beq cr6, 0x830ec9ac
	if ctx.cr[6].eq {
	pc = 0x830EC9AC; continue 'dispatch;
	}
	// 830EC91C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC920: 4BFE22F1  bl 0x830cec10
	ctx.lr = 0x830EC924;
	sub_830CEC10(ctx, base);
	// 830EC924: 4BFF427D  bl 0x830e0ba0
	ctx.lr = 0x830EC928;
	sub_830E0BA0(ctx, base);
	// 830EC928: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 830EC92C: 41980078  blt cr6, 0x830ec9a4
	if ctx.cr[6].lt {
	pc = 0x830EC9A4; continue 'dispatch;
	}
	// 830EC930: 419A0034  beq cr6, 0x830ec964
	if ctx.cr[6].eq {
	pc = 0x830EC964; continue 'dispatch;
	}
	// 830EC934: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 830EC938: 40980074  bge cr6, 0x830ec9ac
	if !ctx.cr[6].lt {
	pc = 0x830EC9AC; continue 'dispatch;
	}
	// 830EC93C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830EC940: 419A006C  beq cr6, 0x830ec9ac
	if ctx.cr[6].eq {
	pc = 0x830EC9AC; continue 'dispatch;
	}
	// 830EC944: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC948: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC94C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC950: 38AB8D80  addi r5, r11, -0x7280
	ctx.r[5].s64 = ctx.r[11].s64 + -29312;
	// 830EC954: 388A8D9C  addi r4, r10, -0x7264
	ctx.r[4].s64 = ctx.r[10].s64 + -29284;
	// 830EC958: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EC95C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EC960: 4800003C  b 0x830ec99c
	pc = 0x830EC99C; continue 'dispatch;
	// 830EC964: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830EC968: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC96C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EC970: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EC974: 419A0018  beq cr6, 0x830ec98c
	if ctx.cr[6].eq {
	pc = 0x830EC98C; continue 'dispatch;
	}
	// 830EC978: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC97C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC980: 38AB8DB0  addi r5, r11, -0x7250
	ctx.r[5].s64 = ctx.r[11].s64 + -29264;
	// 830EC984: 388A8DCC  addi r4, r10, -0x7234
	ctx.r[4].s64 = ctx.r[10].s64 + -29236;
	// 830EC988: 48000014  b 0x830ec99c
	pc = 0x830EC99C; continue 'dispatch;
	// 830EC98C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EC990: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EC994: 38AB8D30  addi r5, r11, -0x72d0
	ctx.r[5].s64 = ctx.r[11].s64 + -29392;
	// 830EC998: 388A8D5C  addi r4, r10, -0x72a4
	ctx.r[4].s64 = ctx.r[10].s64 + -29348;
	// 830EC99C: 4BFF4DBD  bl 0x830e1758
	ctx.lr = 0x830EC9A0;
	sub_830E1758(ctx, base);
	// 830EC9A0: 4800000C  b 0x830ec9ac
	pc = 0x830EC9AC; continue 'dispatch;
	// 830EC9A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC9A8: 4BFF2661  bl 0x830df008
	ctx.lr = 0x830EC9AC;
	sub_830DF008(ctx, base);
	// 830EC9AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EC9B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EC9B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EC9B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EC9BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EC9C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EC9C8 size=184
    let mut pc: u32 = 0x830EC9C8;
    'dispatch: loop {
        match pc {
            0x830EC9C8 => {
    //   block [0x830EC9C8..0x830ECA80)
	// 830EC9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EC9D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC9D4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830EC9D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC9DC: 2B0A000F  cmplwi cr6, r10, 0xf
	ctx.cr[6].compare_u32(ctx.r[10].u32, 15 as u32, &mut ctx.xer);
	// 830EC9E0: 419A0074  beq cr6, 0x830eca54
	if ctx.cr[6].eq {
	pc = 0x830ECA54; continue 'dispatch;
	}
	// 830EC9E4: 2B0A07D6  cmplwi cr6, r10, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2006 as u32, &mut ctx.xer);
	// 830EC9E8: 419A0054  beq cr6, 0x830eca3c
	if ctx.cr[6].eq {
	pc = 0x830ECA3C; continue 'dispatch;
	}
	// 830EC9EC: 2B0A07E7  cmplwi cr6, r10, 0x7e7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2023 as u32, &mut ctx.xer);
	// 830EC9F0: 409A007C  bne cr6, 0x830eca6c
	if !ctx.cr[6].eq {
	pc = 0x830ECA6C; continue 'dispatch;
	}
	// 830EC9F4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EC9F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830EC9FC: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830ECA00: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECA04: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 830ECA08: 419A0010  beq cr6, 0x830eca18
	if ctx.cr[6].eq {
	pc = 0x830ECA18; continue 'dispatch;
	}
	// 830ECA0C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECA10: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ECA14: 419A0058  beq cr6, 0x830eca6c
	if ctx.cr[6].eq {
	pc = 0x830ECA6C; continue 'dispatch;
	}
	// 830ECA18: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 830ECA1C: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 830ECA20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ECA24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830ECA28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830ECA2C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830ECA30: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830ECA34: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830ECA38: 48000014  b 0x830eca4c
	pc = 0x830ECA4C; continue 'dispatch;
	// 830ECA3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830ECA40: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830ECA44: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830ECA48: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECA4C: 4BFFFE95  bl 0x830ec8e0
	ctx.lr = 0x830ECA50;
	sub_830EC8E0(ctx, base);
	// 830ECA50: 4800001C  b 0x830eca6c
	pc = 0x830ECA6C; continue 'dispatch;
	// 830ECA54: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECA58: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830ECA5C: 409A0010  bne cr6, 0x830eca6c
	if !ctx.cr[6].eq {
	pc = 0x830ECA6C; continue 'dispatch;
	}
	// 830ECA60: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 830ECA64: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECA68: 4BFFCFB1  bl 0x830e9a18
	ctx.lr = 0x830ECA6C;
	sub_830E9A18(ctx, base);
	// 830ECA6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830ECA70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ECA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830ECA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830ECA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ECA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830ECA80 size=788
    let mut pc: u32 = 0x830ECA80;
    'dispatch: loop {
        match pc {
            0x830ECA80 => {
    //   block [0x830ECA80..0x830ECD94)
	// 830ECA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ECA84: 480BB6DD  bl 0x831a8160
	ctx.lr = 0x830ECA88;
	sub_831A8130(ctx, base);
	// 830ECA88: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 830ECA8C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ECA90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830ECA94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830ECA98: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830ECA9C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830ECAA0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830ECAA4: 807E0028  lwz r3, 0x28(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830ECAA8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830ECAAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ECAB0: 419A0024  beq cr6, 0x830ecad4
	if ctx.cr[6].eq {
	pc = 0x830ECAD4; continue 'dispatch;
	}
	// 830ECAB4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830ECAB8: 4BFF2F99  bl 0x830dfa50
	ctx.lr = 0x830ECABC;
	sub_830DFA50(ctx, base);
	// 830ECABC: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECAC0: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECAC4: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECAC8: D1BD0004  stfs f13, 4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECACC: 807E0028  lwz r3, 0x28(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830ECAD0: 48000010  b 0x830ecae0
	pc = 0x830ECAE0; continue 'dispatch;
	// 830ECAD4: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECAD8: D3FD0004  stfs f31, 4(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECADC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECAE0: 3B9D000C  addi r28, r29, 0xc
	ctx.r[28].s64 = ctx.r[29].s64 + 12;
	// 830ECAE4: 3B7D0008  addi r27, r29, 8
	ctx.r[27].s64 = ctx.r[29].s64 + 8;
	// 830ECAE8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830ECAEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830ECAF0: 4BFFAD19  bl 0x830e7808
	ctx.lr = 0x830ECAF4;
	sub_830E7808(ctx, base);
	// 830ECAF4: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECAF8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECAFC: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECB00: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECB04: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECB08: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ECB0C: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECB10: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830ECB14: D3FA0000  stfs f31, 0(r26)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECB18: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 830ECB1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ECB20: 419A004C  beq cr6, 0x830ecb6c
	if ctx.cr[6].eq {
	pc = 0x830ECB6C; continue 'dispatch;
	}
	// 830ECB24: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830ECB28: 4BFF2F29  bl 0x830dfa50
	ctx.lr = 0x830ECB2C;
	sub_830DFA50(ctx, base);
	// 830ECB2C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830ECB30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830ECB34: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 830ECB38: 4BFFACD1  bl 0x830e7808
	ctx.lr = 0x830ECB3C;
	sub_830E7808(ctx, base);
	// 830ECB3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECB40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ECB44: 409A0018  bne cr6, 0x830ecb5c
	if !ctx.cr[6].eq {
	pc = 0x830ECB5C; continue 'dispatch;
	}
	// 830ECB48: C0010070  lfs f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECB4C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECB50: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECB54: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ECB58: 48000014  b 0x830ecb6c
	pc = 0x830ECB6C; continue 'dispatch;
	// 830ECB5C: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECB60: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECB64: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECB68: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830ECB6C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECB70: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830ECB74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ECB78: 409A0088  bne cr6, 0x830ecc00
	if !ctx.cr[6].eq {
	pc = 0x830ECC00; continue 'dispatch;
	}
	// 830ECB7C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830ECB80: C15C0000  lfs f10, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830ECB84: 813E0024  lwz r9, 0x24(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 830ECB88: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 830ECB8C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830ECB90: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 830ECB94: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830ECB98: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ECB9C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830ECBA0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ECBA4: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830ECBA8: FC006E9C  fcfid f0, f13
	ctx.f[0].f64 = (ctx.f[13].s64 as f64);
	// 830ECBAC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830ECBB0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830ECBB4: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830ECBB8: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830ECBBC: EDAA5824  fdivs f13, f10, f11
	ctx.f[13].f64 = ((ctx.f[10].f64 / ctx.f[11].f64) as f32) as f64;
	// 830ECBC0: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830ECBC4: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 830ECBC8: 4099000C  ble cr6, 0x830ecbd4
	if !ctx.cr[6].gt {
	pc = 0x830ECBD4; continue 'dispatch;
	}
	// 830ECBCC: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	// 830ECBD0: 48000008  b 0x830ecbd8
	pc = 0x830ECBD8; continue 'dispatch;
	// 830ECBD4: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830ECBD8: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 830ECBDC: 4098000C  bge cr6, 0x830ecbe8
	if !ctx.cr[6].lt {
	pc = 0x830ECBE8; continue 'dispatch;
	}
	// 830ECBE0: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 830ECBE4: 48000014  b 0x830ecbf8
	pc = 0x830ECBF8; continue 'dispatch;
	// 830ECBE8: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830ECBEC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 830ECBF0: 41990008  bgt cr6, 0x830ecbf8
	if ctx.cr[6].gt {
	pc = 0x830ECBF8; continue 'dispatch;
	}
	// 830ECBF4: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830ECBF8: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830ECBFC: 48000084  b 0x830ecc80
	pc = 0x830ECC80; continue 'dispatch;
	// 830ECC00: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 830ECC04: C15B0000  lfs f10, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830ECC08: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830ECC0C: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830ECC10: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ECC14: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830ECC18: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830ECC1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 830ECC20: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830ECC24: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 830ECC28: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830ECC2C: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830ECC30: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830ECC34: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830ECC38: FC006018  frsp f0, f12
	ctx.f[0].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830ECC3C: FD805818  frsp f12, f11
	ctx.f[12].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830ECC40: EDAA6824  fdivs f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 / ctx.f[13].f64) as f32) as f64;
	// 830ECC44: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830ECC48: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 830ECC4C: 4099000C  ble cr6, 0x830ecc58
	if !ctx.cr[6].gt {
	pc = 0x830ECC58; continue 'dispatch;
	}
	// 830ECC50: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	// 830ECC54: 48000008  b 0x830ecc5c
	pc = 0x830ECC5C; continue 'dispatch;
	// 830ECC58: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830ECC5C: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 830ECC60: 4098000C  bge cr6, 0x830ecc6c
	if !ctx.cr[6].lt {
	pc = 0x830ECC6C; continue 'dispatch;
	}
	// 830ECC64: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 830ECC68: 48000014  b 0x830ecc7c
	pc = 0x830ECC7C; continue 'dispatch;
	// 830ECC6C: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830ECC70: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 830ECC74: 41990008  bgt cr6, 0x830ecc7c
	if ctx.cr[6].gt {
	pc = 0x830ECC7C; continue 'dispatch;
	}
	// 830ECC78: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830ECC7C: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ECC80: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830ECC84: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830ECC88: 40990100  ble cr6, 0x830ecd88
	if !ctx.cr[6].gt {
	pc = 0x830ECD88; continue 'dispatch;
	}
	// 830ECC8C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830ECC90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830ECC94: 409900F4  ble cr6, 0x830ecd88
	if !ctx.cr[6].gt {
	pc = 0x830ECD88; continue 'dispatch;
	}
	// 830ECC98: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECC9C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830ECCA0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ECCA4: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830ECCA8: 409A0074  bne cr6, 0x830ecd1c
	if !ctx.cr[6].eq {
	pc = 0x830ECD1C; continue 'dispatch;
	}
	// 830ECCAC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830ECCB0: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECCB4: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECCB8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830ECCBC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830ECCC0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830ECCC4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830ECCC8: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830ECCCC: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECCD0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830ECCD4: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ECCD8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830ECCDC: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830ECCE0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830ECCE4: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830ECCE8: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECCEC: EDAB637A  fmadds f13, f11, f13, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 830ECCF0: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECCF4: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830ECCF8: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 830ECCFC: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECD00: ED80602A  fadds f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830ECD04: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 830ECD08: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 830ECD0C: 4099007C  ble cr6, 0x830ecd88
	if !ctx.cr[6].gt {
	pc = 0x830ECD88; continue 'dispatch;
	}
	// 830ECD10: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830ECD14: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECD18: 48000070  b 0x830ecd88
	pc = 0x830ECD88; continue 'dispatch;
	// 830ECD1C: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECD20: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830ECD24: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECD28: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830ECD2C: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830ECD30: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830ECD34: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830ECD38: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830ECD3C: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECD40: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ECD44: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECD48: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830ECD4C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830ECD50: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830ECD54: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830ECD58: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830ECD5C: EDAB637A  fmadds f13, f11, f13, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 830ECD60: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECD64: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECD68: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830ECD6C: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ECD70: ED80602A  fadds f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830ECD74: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 830ECD78: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 830ECD7C: 4099000C  ble cr6, 0x830ecd88
	if !ctx.cr[6].gt {
	pc = 0x830ECD88; continue 'dispatch;
	}
	// 830ECD80: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830ECD84: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECD88: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830ECD8C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 830ECD90: 480BB420  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ECD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830ECD98 size=172
    let mut pc: u32 = 0x830ECD98;
    'dispatch: loop {
        match pc {
            0x830ECD98 => {
    //   block [0x830ECD98..0x830ECE44)
	// 830ECD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ECD9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830ECDA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830ECDA4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ECDA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830ECDAC: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830ECDB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ECDB4: 419A007C  beq cr6, 0x830ece30
	if ctx.cr[6].eq {
	pc = 0x830ECE30; continue 'dispatch;
	}
	// 830ECDB8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830ECDBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ECDC0: 419A0068  beq cr6, 0x830ece28
	if ctx.cr[6].eq {
	pc = 0x830ECE28; continue 'dispatch;
	}
	// 830ECDC4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830ECDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ECDCC: 419A005C  beq cr6, 0x830ece28
	if ctx.cr[6].eq {
	pc = 0x830ECE28; continue 'dispatch;
	}
	// 830ECDD0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830ECDD4: 4BFFAAA5  bl 0x830e7878
	ctx.lr = 0x830ECDD8;
	sub_830E7878(ctx, base);
	// 830ECDD8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830ECDDC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 830ECDE0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830ECDE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ECDE8: 4BFFFC99  bl 0x830eca80
	ctx.lr = 0x830ECDEC;
	sub_830ECA80(ctx, base);
	// 830ECDEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830ECDF0: C1A10074  lfs f13, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ECDF4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830ECDF8: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830ECDFC: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830ECE00: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECE04: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830ECE08: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECE0C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830ECE10: 4BFF2C91  bl 0x830dfaa0
	ctx.lr = 0x830ECE14;
	sub_830DFAA0(ctx, base);
	// 830ECE14: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830ECE18: C041007C  lfs f2, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830ECE1C: C0210078  lfs f1, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830ECE20: 4BFF4BE9  bl 0x830e1a08
	ctx.lr = 0x830ECE24;
	sub_830E1A08(ctx, base);
	// 830ECE24: 4800000C  b 0x830ece30
	pc = 0x830ECE30; continue 'dispatch;
	// 830ECE28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830ECE2C: 4BFFAA4D  bl 0x830e7878
	ctx.lr = 0x830ECE30;
	sub_830E7878(ctx, base);
	// 830ECE30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830ECE34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830ECE38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830ECE3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830ECE40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ECE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830ECE48 size=1400
    let mut pc: u32 = 0x830ECE48;
    'dispatch: loop {
        match pc {
            0x830ECE48 => {
    //   block [0x830ECE48..0x830ED3C0)
	// 830ECE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ECE4C: 480BB321  bl 0x831a816c
	ctx.lr = 0x830ECE50;
	sub_831A8130(ctx, base);
	// 830ECE50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ECE54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830ECE58: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830ECE5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830ECE60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830ECE64: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECE68: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECE6C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ECE70: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECE74: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ECE78: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECE7C: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830ECE80: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830ECE84: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ECE88: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830ECE8C: 409A0010  bne cr6, 0x830ece9c
	if !ctx.cr[6].eq {
	pc = 0x830ECE9C; continue 'dispatch;
	}
	// 830ECE90: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830ECE94: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ECE98: 419A003C  beq cr6, 0x830eced4
	if ctx.cr[6].eq {
	pc = 0x830ECED4; continue 'dispatch;
	}
	// 830ECE9C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830ECEA0: 409A0034  bne cr6, 0x830eced4
	if !ctx.cr[6].eq {
	pc = 0x830ECED4; continue 'dispatch;
	}
	// 830ECEA4: 813F00EC  lwz r9, 0xec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830ECEA8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ECEAC: 41980028  blt cr6, 0x830eced4
	if ctx.cr[6].lt {
	pc = 0x830ECED4; continue 'dispatch;
	}
	// 830ECEB0: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830ECEB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ECEB8: 4198001C  blt cr6, 0x830eced4
	if ctx.cr[6].lt {
	pc = 0x830ECED4; continue 'dispatch;
	}
	// 830ECEBC: 7D4B4851  subf. r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ECEC0: 41800010  blt 0x830eced0
	if ctx.cr[0].lt {
	pc = 0x830ECED0; continue 'dispatch;
	}
	// 830ECEC4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830ECEC8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ECECC: 41980008  blt cr6, 0x830eced4
	if ctx.cr[6].lt {
	pc = 0x830ECED4; continue 'dispatch;
	}
	// 830ECED0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 830ECED4: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830ECED8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830ECEDC: 419803D0  blt cr6, 0x830ed2ac
	if ctx.cr[6].lt {
	pc = 0x830ED2AC; continue 'dispatch;
	}
	// 830ECEE0: 419A02C0  beq cr6, 0x830ed1a0
	if ctx.cr[6].eq {
	pc = 0x830ED1A0; continue 'dispatch;
	}
	// 830ECEE4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830ECEE8: 41980290  blt cr6, 0x830ed178
	if ctx.cr[6].lt {
	pc = 0x830ED178; continue 'dispatch;
	}
	// 830ECEEC: 419A028C  beq cr6, 0x830ed178
	if ctx.cr[6].eq {
	pc = 0x830ED178; continue 'dispatch;
	}
	// 830ECEF0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 830ECEF4: 41980158  blt cr6, 0x830ed04c
	if ctx.cr[6].lt {
	pc = 0x830ED04C; continue 'dispatch;
	}
	// 830ECEF8: 409A04C0  bne cr6, 0x830ed3b8
	if !ctx.cr[6].eq {
	pc = 0x830ED3B8; continue 'dispatch;
	}
	// 830ECEFC: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ECF00: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830ECF04: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 830ECF08: 7D6453D7  divw. r11, r4, r10
	ctx.r[11].s32 = ctx.r[4].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ECF0C: 0CCA0000  twi 6, r10, 0
	// 830ECF10: 7D4A4878  andc r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[9].u64;
	// 830ECF14: 0CAAFFFF  twi 5, r10, -1
	// 830ECF18: 40800008  bge 0x830ecf20
	if !ctx.cr[0].lt {
	pc = 0x830ECF20; continue 'dispatch;
	}
	// 830ECF1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ECF20: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 830ECF24: 813F00E0  lwz r9, 0xe0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830ECF28: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECF2C: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ECF30: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830ECF34: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ECF38: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830ECF3C: 7D444BD6  divw r10, r4, r9
	ctx.r[10].s32 = ctx.r[4].s32 / ctx.r[9].s32;
	// 830ECF40: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 830ECF44: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830ECF48: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ECF4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830ECF50: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 830ECF54: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ECF58: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830ECF5C: C15F0090  lfs f10, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830ECF60: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830ECF64: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830ECF68: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830ECF6C: 548A083E  rotlwi r10, r4, 1
	ctx.r[10].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ECF70: 0CABFFFF  twi 5, r11, -1
	// 830ECF74: 0CC90000  twi 6, r9, 0
	// 830ECF78: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830ECF7C: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830ECF80: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 830ECF84: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ECF88: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830ECF8C: 7D245BD6  divw r9, r4, r11
	ctx.r[9].s32 = ctx.r[4].s32 / ctx.r[11].s32;
	// 830ECF90: 7D2959D6  mullw r9, r9, r11
	ctx.r[9].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830ECF94: 0CCB0000  twi 6, r11, 0
	// 830ECF98: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 830ECF9C: 7D492051  subf. r10, r9, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ECFA0: 0CABFFFF  twi 5, r11, -1
	// 830ECFA4: 4080000C  bge 0x830ecfb0
	if !ctx.cr[0].lt {
	pc = 0x830ECFB0; continue 'dispatch;
	}
	// 830ECFA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ECFAC: 48000028  b 0x830ecfd4
	pc = 0x830ECFD4; continue 'dispatch;
	// 830ECFB0: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ECFB4: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830ECFB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830ECFBC: 7D2453D6  divw r9, r4, r10
	ctx.r[9].s32 = ctx.r[4].s32 / ctx.r[10].s32;
	// 830ECFC0: 7D485878  andc r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 830ECFC4: 7D6951D6  mullw r11, r9, r10
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830ECFC8: 0CCA0000  twi 6, r10, 0
	// 830ECFCC: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 830ECFD0: 0CA8FFFF  twi 5, r8, -1
	// 830ECFD4: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830ECFD8: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 830ECFDC: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ECFE0: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ECFE4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 830ECFE8: 7D0453D6  divw r8, r4, r10
	ctx.r[8].s32 = ctx.r[4].s32 / ctx.r[10].s32;
	// 830ECFEC: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ECFF0: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830ECFF4: 7D2851D6  mullw r9, r8, r10
	ctx.r[9].s64 = (ctx.r[8].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830ECFF8: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830ECFFC: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED000: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830ED004: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 830ED008: 7D292050  subf r9, r9, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 830ED00C: 0CCA0000  twi 6, r10, 0
	// 830ED010: 7D4B5878  andc r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 830ED014: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 830ED018: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830ED01C: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ED020: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830ED024: FD605018  frsp f11, f10
	ctx.f[11].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830ED028: EC0B037A  fmadds f0, f11, f13, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830ED02C: C19F0094  lfs f12, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED030: 0CABFFFF  twi 5, r11, -1
	// 830ED034: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830ED038: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ED03C: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED040: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ED044: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED048: 48000364  b 0x830ed3ac
	pc = 0x830ED3AC; continue 'dispatch;
	// 830ED04C: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830ED050: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ED054: 7D2453D6  divw r9, r4, r10
	ctx.r[9].s32 = ctx.r[4].s32 / ctx.r[10].s32;
	// 830ED058: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830ED05C: 7D2951D6  mullw r9, r9, r10
	ctx.r[9].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830ED060: 0CCA0000  twi 6, r10, 0
	// 830ED064: 7D4A5878  andc r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 830ED068: 7D692051  subf. r11, r9, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED06C: 0CAAFFFF  twi 5, r10, -1
	// 830ED070: 40800008  bge 0x830ed078
	if !ctx.cr[0].lt {
	pc = 0x830ED078; continue 'dispatch;
	}
	// 830ED074: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ED078: 813F00E4  lwz r9, 0xe4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830ED07C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830ED080: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830ED084: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED088: 7D044BD6  divw r8, r4, r9
	ctx.r[8].s32 = ctx.r[4].s32 / ctx.r[9].s32;
	// 830ED08C: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED090: 548A083E  rotlwi r10, r4, 1
	ctx.r[10].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ED094: C19F0090  lfs f12, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED098: 7D0849D6  mullw r8, r8, r9
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830ED09C: 7D082050  subf r8, r8, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 830ED0A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830ED0A4: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 830ED0A8: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ED0AC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 830ED0B0: 7D2A5078  andc r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[10].u64;
	// 830ED0B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830ED0B8: 0CAAFFFF  twi 5, r10, -1
	// 830ED0BC: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ED0C0: 0CC90000  twi 6, r9, 0
	// 830ED0C4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830ED0C8: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830ED0CC: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ED0D0: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830ED0D4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 830ED0D8: FD605018  frsp f11, f10
	ctx.f[11].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830ED0DC: EC0B037A  fmadds f0, f11, f13, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830ED0E0: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830ED0E4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED0E8: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830ED0EC: 7D4B5878  andc r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 830ED0F0: 7D2453D7  divw. r9, r4, r10
	ctx.r[9].s32 = ctx.r[4].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ED0F4: 0CCA0000  twi 6, r10, 0
	// 830ED0F8: 0CABFFFF  twi 5, r11, -1
	// 830ED0FC: 4080000C  bge 0x830ed108
	if !ctx.cr[0].lt {
	pc = 0x830ED108; continue 'dispatch;
	}
	// 830ED100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ED104: 48000020  b 0x830ed124
	pc = 0x830ED124; continue 'dispatch;
	// 830ED108: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ED10C: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830ED110: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 830ED114: 7D6453D6  divw r11, r4, r10
	ctx.r[11].s32 = ctx.r[4].s32 / ctx.r[10].s32;
	// 830ED118: 0CCA0000  twi 6, r10, 0
	// 830ED11C: 7D4A4878  andc r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[9].u64;
	// 830ED120: 0CAAFFFF  twi 5, r10, -1
	// 830ED124: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 830ED128: 813F00E4  lwz r9, 0xe4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830ED12C: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED130: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830ED134: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830ED138: 7D444BD6  divw r10, r4, r9
	ctx.r[10].s32 = ctx.r[4].s32 / ctx.r[9].s32;
	// 830ED13C: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ED140: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830ED144: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830ED148: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830ED14C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830ED150: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED154: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830ED158: 0CC90000  twi 6, r9, 0
	// 830ED15C: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830ED160: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 830ED164: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ED168: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830ED16C: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830ED170: EC0A037A  fmadds f0, f10, f13, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830ED174: 4BFFFEB8  b 0x830ed02c
	pc = 0x830ED02C; continue 'dispatch;
	// 830ED178: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED17C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED180: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED184: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ED188: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED18C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ED190: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED194: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED198: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED19C: 48000218  b 0x830ed3b4
	pc = 0x830ED3B4; continue 'dispatch;
	// 830ED1A0: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED1A4: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830ED1A8: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED1AC: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED1B0: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ED1B4: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED1B8: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ED1BC: 40990060  ble cr6, 0x830ed21c
	if !ctx.cr[6].gt {
	pc = 0x830ED21C; continue 'dispatch;
	}
	// 830ED1C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED1C4: 41980058  blt cr6, 0x830ed21c
	if ctx.cr[6].lt {
	pc = 0x830ED21C; continue 'dispatch;
	}
	// 830ED1C8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED1CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED1D0: 409A0010  bne cr6, 0x830ed1e0
	if !ctx.cr[6].eq {
	pc = 0x830ED1E0; continue 'dispatch;
	}
	// 830ED1D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED1D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED1DC: 419A0040  beq cr6, 0x830ed21c
	if ctx.cr[6].eq {
	pc = 0x830ED21C; continue 'dispatch;
	}
	// 830ED1E0: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 830ED1E4: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED1E8: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED1EC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830ED1F0: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED1F4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED1F8: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830ED1FC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830ED200: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830ED204: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ED208: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830ED20C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830ED210: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 830ED214: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 830ED218: 4800002C  b 0x830ed244
	pc = 0x830ED244; continue 'dispatch;
	// 830ED21C: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 830ED220: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED224: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED228: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830ED22C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830ED230: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED234: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ED238: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830ED23C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830ED240: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 830ED244: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED248: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830ED24C: 409A0058  bne cr6, 0x830ed2a4
	if !ctx.cr[6].eq {
	pc = 0x830ED2A4; continue 'dispatch;
	}
	// 830ED250: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED254: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED258: 409A0010  bne cr6, 0x830ed268
	if !ctx.cr[6].eq {
	pc = 0x830ED268; continue 'dispatch;
	}
	// 830ED25C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED260: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED264: 419A0040  beq cr6, 0x830ed2a4
	if ctx.cr[6].eq {
	pc = 0x830ED2A4; continue 'dispatch;
	}
	// 830ED268: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED26C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830ED270: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED274: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830ED278: C19F0094  lfs f12, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED27C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED280: EDAD603C  fnmsubs f13, f13, f0, f12
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830ED284: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED288: 480BEA81  bl 0x831abd08
	ctx.lr = 0x830ED28C;
	sub_831ABD08(ctx, base);
	// 830ED28C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830ED290: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ED294: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED298: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED29C: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED2A0: 48000114  b 0x830ed3b4
	pc = 0x830ED3B4; continue 'dispatch;
	// 830ED2A4: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED2A8: 4BFFFEEC  b 0x830ed194
	pc = 0x830ED194; continue 'dispatch;
	// 830ED2AC: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED2B0: 397F0090  addi r11, r31, 0x90
	ctx.r[11].s64 = ctx.r[31].s64 + 144;
	// 830ED2B4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED2B8: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830ED2BC: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED2C0: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ED2C4: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED2C8: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830ED2CC: 40990060  ble cr6, 0x830ed32c
	if !ctx.cr[6].gt {
	pc = 0x830ED32C; continue 'dispatch;
	}
	// 830ED2D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED2D4: 41980058  blt cr6, 0x830ed32c
	if ctx.cr[6].lt {
	pc = 0x830ED32C; continue 'dispatch;
	}
	// 830ED2D8: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED2DC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ED2E0: 409A0010  bne cr6, 0x830ed2f0
	if !ctx.cr[6].eq {
	pc = 0x830ED2F0; continue 'dispatch;
	}
	// 830ED2E4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED2E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ED2EC: 419A0040  beq cr6, 0x830ed32c
	if ctx.cr[6].eq {
	pc = 0x830ED32C; continue 'dispatch;
	}
	// 830ED2F0: 3924FFFF  addi r9, r4, -1
	ctx.r[9].s64 = ctx.r[4].s64 + -1;
	// 830ED2F4: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED2F8: C1BF004C  lfs f13, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED2FC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 830ED300: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED304: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED308: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830ED30C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 830ED310: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830ED314: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ED318: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830ED31C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830ED320: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 830ED324: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 830ED328: 4800002C  b 0x830ed354
	pc = 0x830ED354; continue 'dispatch;
	// 830ED32C: 7C8907B4  extsw r9, r4
	ctx.r[9].s64 = ctx.r[4].s32 as i64;
	// 830ED330: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED334: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED338: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 830ED33C: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ED340: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830ED344: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830ED348: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED34C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830ED350: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 830ED354: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ED358: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830ED35C: 409A004C  bne cr6, 0x830ed3a8
	if !ctx.cr[6].eq {
	pc = 0x830ED3A8; continue 'dispatch;
	}
	// 830ED360: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED364: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED368: 409A0010  bne cr6, 0x830ed378
	if !ctx.cr[6].eq {
	pc = 0x830ED378; continue 'dispatch;
	}
	// 830ED36C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED370: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED374: 419A0034  beq cr6, 0x830ed3a8
	if ctx.cr[6].eq {
	pc = 0x830ED3A8; continue 'dispatch;
	}
	// 830ED378: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED37C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830ED380: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED384: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830ED388: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED38C: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED390: EDAD603C  fnmsubs f13, f13, f0, f12
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830ED394: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED398: 480BE971  bl 0x831abd08
	ctx.lr = 0x830ED39C;
	sub_831ABD08(ctx, base);
	// 830ED39C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830ED3A0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED3A4: 4BFFFEF0  b 0x830ed294
	pc = 0x830ED294; continue 'dispatch;
	// 830ED3A8: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED3AC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED3B0: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED3B4: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830ED3B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830ED3BC: 480BAE00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ED3C0 size=168
    let mut pc: u32 = 0x830ED3C0;
    'dispatch: loop {
        match pc {
            0x830ED3C0 => {
    //   block [0x830ED3C0..0x830ED468)
	// 830ED3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED3C4: 480BADA9  bl 0x831a816c
	ctx.lr = 0x830ED3C8;
	sub_831A8130(ctx, base);
	// 830ED3C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED3CC: 3FC08030  lis r30, -0x7fd0
	ctx.r[30].s64 = -2144337920;
	// 830ED3D0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED3D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830ED3D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830ED3DC: 63DE0007  ori r30, r30, 7
	ctx.r[30].u64 = ctx.r[30].u64 | 7;
	// 830ED3E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830ED3E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ED3E8: 419A0008  beq cr6, 0x830ed3f0
	if ctx.cr[6].eq {
	pc = 0x830ED3F0; continue 'dispatch;
	}
	// 830ED3EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED3F0: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ED3F4: 40980068  bge cr6, 0x830ed45c
	if !ctx.cr[6].lt {
	pc = 0x830ED45C; continue 'dispatch;
	}
	// 830ED3F8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED3FC: 7D6B49D6  mullw r11, r11, r9
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830ED400: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830ED404: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 830ED408: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED410: 419A0010  beq cr6, 0x830ed420
	if ctx.cr[6].eq {
	pc = 0x830ED420; continue 'dispatch;
	}
	// 830ED414: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED418: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830ED41C: 419A000C  beq cr6, 0x830ed428
	if ctx.cr[6].eq {
	pc = 0x830ED428; continue 'dispatch;
	}
	// 830ED420: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830ED424: 4BFFFFBC  b 0x830ed3e0
	pc = 0x830ED3E0; continue 'dispatch;
	// 830ED428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830ED42C: 4801508D  bl 0x831024b8
	ctx.lr = 0x830ED430;
	sub_831024B8(ctx, base);
	// 830ED430: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830ED434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ED438: 48019951  bl 0x83106d88
	ctx.lr = 0x830ED43C;
	sub_83106D88(ctx, base);
	// 830ED43C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830ED440: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830ED444: 4801545D  bl 0x831028a0
	ctx.lr = 0x830ED448;
	sub_831028A0(ctx, base);
	// 830ED448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ED44C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830ED450: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830ED454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830ED458: 48015631  bl 0x83102a88
	ctx.lr = 0x830ED45C;
	sub_83102A88(ctx, base);
	// 830ED45C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830ED460: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830ED464: 480BAD58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ED468 size=348
    let mut pc: u32 = 0x830ED468;
    'dispatch: loop {
        match pc {
            0x830ED468 => {
    //   block [0x830ED468..0x830ED5C4)
	// 830ED468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED46C: 480BACF5  bl 0x831a8160
	ctx.lr = 0x830ED470;
	sub_831A8130(ctx, base);
	// 830ED470: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830ED478: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830ED47C: 837F00AC  lwz r27, 0xac(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830ED480: 835F00B4  lwz r26, 0xb4(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 830ED484: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 830ED488: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 830ED48C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED490: 4BFF4021  bl 0x830e14b0
	ctx.lr = 0x830ED494;
	sub_830E14B0(ctx, base);
	// 830ED494: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830ED498: 4182002C  beq 0x830ed4c4
	if ctx.cr[0].eq {
	pc = 0x830ED4C4; continue 'dispatch;
	}
	// 830ED49C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830ED4A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4A4: 4BFF29CD  bl 0x830dfe70
	ctx.lr = 0x830ED4A8;
	sub_830DFE70(ctx, base);
	// 830ED4A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830ED4AC: 41820018  beq 0x830ed4c4
	if ctx.cr[0].eq {
	pc = 0x830ED4C4; continue 'dispatch;
	}
	// 830ED4B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830ED4B4: 4BFF225D  bl 0x830df710
	ctx.lr = 0x830ED4B8;
	sub_830DF710(ctx, base);
	// 830ED4B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830ED4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ED4C0: 4BFF7B11  bl 0x830e4fd0
	ctx.lr = 0x830ED4C4;
	sub_830E4FD0(ctx, base);
	// 830ED4C4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830ED4C8: 40990024  ble cr6, 0x830ed4ec
	if !ctx.cr[6].gt {
	pc = 0x830ED4EC; continue 'dispatch;
	}
	// 830ED4CC: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 830ED4D0: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830ED4D4: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830ED4D8: 7C6BE02E  lwzx r3, r11, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830ED4DC: 4BFEC34D  bl 0x830d9828
	ctx.lr = 0x830ED4E0;
	sub_830D9828(ctx, base);
	// 830ED4E0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830ED4E4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830ED4E8: 4082FFEC  bne 0x830ed4d4
	if !ctx.cr[0].eq {
	pc = 0x830ED4D4; continue 'dispatch;
	}
	// 830ED4EC: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830ED4F0: 4BFEFFE9  bl 0x830dd4d8
	ctx.lr = 0x830ED4F4;
	sub_830DD4D8(ctx, base);
	// 830ED4F4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830ED4F8: 93DF00B0  stw r30, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 830ED4FC: 40990024  ble cr6, 0x830ed520
	if !ctx.cr[6].gt {
	pc = 0x830ED520; continue 'dispatch;
	}
	// 830ED500: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 830ED504: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830ED508: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830ED50C: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830ED510: 4BFEC319  bl 0x830d9828
	ctx.lr = 0x830ED514;
	sub_830D9828(ctx, base);
	// 830ED514: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830ED518: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830ED51C: 4082FFEC  bne 0x830ed508
	if !ctx.cr[0].eq {
	pc = 0x830ED508; continue 'dispatch;
	}
	// 830ED520: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830ED524: 4BFEFFB5  bl 0x830dd4d8
	ctx.lr = 0x830ED528;
	sub_830DD4D8(ctx, base);
	// 830ED528: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830ED52C: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 830ED530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ED534: 419A000C  beq cr6, 0x830ed540
	if ctx.cr[6].eq {
	pc = 0x830ED540; continue 'dispatch;
	}
	// 830ED538: 4BFEC2F1  bl 0x830d9828
	ctx.lr = 0x830ED53C;
	sub_830D9828(ctx, base);
	// 830ED53C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830ED540: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830ED544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ED548: 419A000C  beq cr6, 0x830ed554
	if ctx.cr[6].eq {
	pc = 0x830ED554; continue 'dispatch;
	}
	// 830ED54C: 4BFEC2DD  bl 0x830d9828
	ctx.lr = 0x830ED550;
	sub_830D9828(ctx, base);
	// 830ED550: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830ED554: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830ED558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ED55C: 419A000C  beq cr6, 0x830ed568
	if ctx.cr[6].eq {
	pc = 0x830ED568; continue 'dispatch;
	}
	// 830ED560: 4BFEC2C9  bl 0x830d9828
	ctx.lr = 0x830ED564;
	sub_830D9828(ctx, base);
	// 830ED564: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 830ED568: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830ED56C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ED570: 419A000C  beq cr6, 0x830ed57c
	if ctx.cr[6].eq {
	pc = 0x830ED57C; continue 'dispatch;
	}
	// 830ED574: 4BFEC2B5  bl 0x830d9828
	ctx.lr = 0x830ED578;
	sub_830D9828(ctx, base);
	// 830ED578: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 830ED57C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830ED580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ED584: 419A000C  beq cr6, 0x830ed590
	if ctx.cr[6].eq {
	pc = 0x830ED590; continue 'dispatch;
	}
	// 830ED588: 4BFEC2A1  bl 0x830d9828
	ctx.lr = 0x830ED58C;
	sub_830D9828(ctx, base);
	// 830ED58C: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 830ED590: 807F00BC  lwz r3, 0xbc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 830ED594: 4BFEFF45  bl 0x830dd4d8
	ctx.lr = 0x830ED598;
	sub_830DD4D8(ctx, base);
	// 830ED598: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 830ED59C: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 830ED5A0: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 830ED5A4: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 830ED5A8: 4BFEFF31  bl 0x830dd4d8
	ctx.lr = 0x830ED5AC;
	sub_830DD4D8(ctx, base);
	// 830ED5AC: 93DF00CC  stw r30, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 830ED5B0: 93DF00D8  stw r30, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 830ED5B4: 93DF00D0  stw r30, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 830ED5B8: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 830ED5BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830ED5C0: 480BABF0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830ED5C8 size=116
    let mut pc: u32 = 0x830ED5C8;
    'dispatch: loop {
        match pc {
            0x830ED5C8 => {
    //   block [0x830ED5C8..0x830ED63C)
	// 830ED5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED5CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830ED5D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830ED5D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830ED5D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED5DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830ED5E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830ED5E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830ED5E8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830ED5EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830ED5F0: 806B002C  lwz r3, 0x2c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830ED5F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830ED5F8: 409A0008  bne cr6, 0x830ed600
	if !ctx.cr[6].eq {
	pc = 0x830ED600; continue 'dispatch;
	}
	// 830ED5FC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED600: 4BFFA209  bl 0x830e7808
	ctx.lr = 0x830ED604;
	sub_830E7808(ctx, base);
	// 830ED604: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830ED608: 419A000C  beq cr6, 0x830ed614
	if ctx.cr[6].eq {
	pc = 0x830ED614; continue 'dispatch;
	}
	// 830ED60C: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED610: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED614: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830ED618: 419A000C  beq cr6, 0x830ed624
	if ctx.cr[6].eq {
	pc = 0x830ED624; continue 'dispatch;
	}
	// 830ED61C: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED620: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED624: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ED628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830ED62C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830ED630: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830ED634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830ED638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830ED640 size=568
    let mut pc: u32 = 0x830ED640;
    'dispatch: loop {
        match pc {
            0x830ED640 => {
    //   block [0x830ED640..0x830ED878)
	// 830ED640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830ED648: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830ED64C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED650: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830ED654: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830ED658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830ED65C: 4BFFFF6D  bl 0x830ed5c8
	ctx.lr = 0x830ED660;
	sub_830ED5C8(ctx, base);
	// 830ED660: 813F00C4  lwz r9, 0xc4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 830ED664: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ED668: 409A000C  bne cr6, 0x830ed674
	if !ctx.cr[6].eq {
	pc = 0x830ED674; continue 'dispatch;
	}
	// 830ED66C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830ED670: 480001F4  b 0x830ed864
	pc = 0x830ED864; continue 'dispatch;
	// 830ED674: 80FF00C0  lwz r7, 0xc0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830ED678: 397F00BC  addi r11, r31, 0xbc
	ctx.r[11].s64 = ctx.r[31].s64 + 188;
	// 830ED67C: 811F00C8  lwz r8, 0xc8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830ED680: 80DF00BC  lwz r6, 0xbc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 830ED684: 0CC70000  twi 6, r7, 0
	// 830ED688: 7CA83BD6  divw r5, r8, r7
	ctx.r[5].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830ED68C: 809F00A0  lwz r4, 0xa0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830ED690: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830ED694: 7CA539D6  mullw r5, r5, r7
	ctx.r[5].s64 = (ctx.r[5].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830ED698: 7D054050  subf r8, r5, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 830ED69C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830ED6A0: 1D080014  mulli r8, r8, 0x14
	ctx.r[8].s64 = ctx.r[8].s64 * 20;
	// 830ED6A4: 7C68302E  lwzx r3, r8, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 830ED6A8: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED6AC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED6B0: 7CEA5078  andc r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830ED6B4: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED6B8: 0CC60000  twi 6, r6, 0
	// 830ED6BC: 7CA733D6  divw r5, r7, r6
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[6].s32;
	// 830ED6C0: 0CAAFFFF  twi 5, r10, -1
	// 830ED6C4: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830ED6C8: 7CA531D6  mullw r5, r5, r6
	ctx.r[5].s64 = (ctx.r[5].s32 as i64) * (ctx.r[6].s32 as i64);
	// 830ED6CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830ED6D0: 7CE53850  subf r7, r5, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 830ED6D4: 7CC65078  andc r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 & !ctx.r[10].u64;
	// 830ED6D8: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830ED6DC: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 830ED6E0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830ED6E4: 0CA6FFFF  twi 5, r6, -1
	// 830ED6E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830ED6EC: 409A00C0  bne cr6, 0x830ed7ac
	if !ctx.cr[6].eq {
	pc = 0x830ED7AC; continue 'dispatch;
	}
	// 830ED6F0: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED6F4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 830ED6F8: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED6FC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830ED700: C19F008C  lfs f12, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED704: C1BF0054  lfs f13, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED708: ED806028  fsubs f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830ED70C: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED710: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830ED714: 40990150  ble cr6, 0x830ed864
	if !ctx.cr[6].gt {
	pc = 0x830ED864; continue 'dispatch;
	}
	// 830ED718: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED71C: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED720: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830ED724: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED728: 0CC60000  twi 6, r6, 0
	// 830ED72C: 7C8533D6  divw r4, r5, r6
	ctx.r[4].s32 = ctx.r[5].s32 / ctx.r[6].s32;
	// 830ED730: 54A8083E  rotlwi r8, r5, 1
	ctx.r[8].u64 = ((ctx.r[5].u32).rotate_left(1)) as u64;
	// 830ED734: 7C8431D6  mullw r4, r4, r6
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[6].s32 as i64);
	// 830ED738: 7CA42850  subf r5, r4, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 830ED73C: 3888FFFF  addi r4, r8, -1
	ctx.r[4].s64 = ctx.r[8].s64 + -1;
	// 830ED740: 1D050014  mulli r8, r5, 0x14
	ctx.r[8].s64 = ctx.r[5].s64 * 20;
	// 830ED744: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 830ED748: 7CC72078  andc r7, r6, r4
	ctx.r[7].u64 = ctx.r[6].u64 & !ctx.r[4].u64;
	// 830ED74C: 0CA7FFFF  twi 5, r7, -1
	// 830ED750: C1680008  lfs f11, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830ED754: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED758: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830ED75C: 41990108  bgt cr6, 0x830ed864
	if ctx.cr[6].gt {
	pc = 0x830ED864; continue 'dispatch;
	}
	// 830ED760: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED764: 54C7003E  slwi r7, r6, 0
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830ED768: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED76C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED770: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830ED774: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830ED778: 7C863BD6  divw r4, r6, r7
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[7].s32;
	// 830ED77C: 54C8083E  rotlwi r8, r6, 1
	ctx.r[8].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 830ED780: 7C8439D6  mullw r4, r4, r7
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830ED784: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 830ED788: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 830ED78C: 1CC60014  mulli r6, r6, 0x14
	ctx.r[6].s64 = ctx.r[6].s64 * 20;
	// 830ED790: 7C66282E  lwzx r3, r6, r5
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 830ED794: 7CE84078  andc r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 & !ctx.r[8].u64;
	// 830ED798: 0CC70000  twi 6, r7, 0
	// 830ED79C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830ED7A0: 0CA8FFFF  twi 5, r8, -1
	// 830ED7A4: 4198FF74  blt cr6, 0x830ed718
	if ctx.cr[6].lt {
	pc = 0x830ED718; continue 'dispatch;
	}
	// 830ED7A8: 480000BC  b 0x830ed864
	pc = 0x830ED864; continue 'dispatch;
	// 830ED7AC: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED7B0: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 830ED7B4: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED7B8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830ED7BC: C19F0088  lfs f12, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830ED7C0: C1BF0058  lfs f13, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED7C4: ED806028  fsubs f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830ED7C8: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED7CC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830ED7D0: 40990094  ble cr6, 0x830ed864
	if !ctx.cr[6].gt {
	pc = 0x830ED864; continue 'dispatch;
	}
	// 830ED7D4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED7D8: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED7DC: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830ED7E0: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED7E4: 0CC60000  twi 6, r6, 0
	// 830ED7E8: 7C8533D6  divw r4, r5, r6
	ctx.r[4].s32 = ctx.r[5].s32 / ctx.r[6].s32;
	// 830ED7EC: 54A8083E  rotlwi r8, r5, 1
	ctx.r[8].u64 = ((ctx.r[5].u32).rotate_left(1)) as u64;
	// 830ED7F0: 7C8431D6  mullw r4, r4, r6
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[6].s32 as i64);
	// 830ED7F4: 7CA42850  subf r5, r4, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 830ED7F8: 3888FFFF  addi r4, r8, -1
	ctx.r[4].s64 = ctx.r[8].s64 + -1;
	// 830ED7FC: 1D050014  mulli r8, r5, 0x14
	ctx.r[8].s64 = ctx.r[5].s64 * 20;
	// 830ED800: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 830ED804: 7CC72078  andc r7, r6, r4
	ctx.r[7].u64 = ctx.r[6].u64 & !ctx.r[4].u64;
	// 830ED808: 0CA7FFFF  twi 5, r7, -1
	// 830ED80C: C1680004  lfs f11, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830ED810: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED814: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830ED818: 4199004C  bgt cr6, 0x830ed864
	if ctx.cr[6].gt {
	pc = 0x830ED864; continue 'dispatch;
	}
	// 830ED81C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED820: 54C7003E  slwi r7, r6, 0
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830ED824: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED828: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830ED82C: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830ED830: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830ED834: 7C863BD6  divw r4, r6, r7
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[7].s32;
	// 830ED838: 54C8083E  rotlwi r8, r6, 1
	ctx.r[8].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 830ED83C: 7C8439D6  mullw r4, r4, r7
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830ED840: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 830ED844: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 830ED848: 1CC60014  mulli r6, r6, 0x14
	ctx.r[6].s64 = ctx.r[6].s64 * 20;
	// 830ED84C: 7C66282E  lwzx r3, r6, r5
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 830ED850: 7CE84078  andc r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 & !ctx.r[8].u64;
	// 830ED854: 0CC70000  twi 6, r7, 0
	// 830ED858: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830ED85C: 0CA8FFFF  twi 5, r8, -1
	// 830ED860: 4198FF74  blt cr6, 0x830ed7d4
	if ctx.cr[6].lt {
	pc = 0x830ED7D4; continue 'dispatch;
	}
	// 830ED864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ED868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830ED86C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830ED870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830ED874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830ED878 size=400
    let mut pc: u32 = 0x830ED878;
    'dispatch: loop {
        match pc {
            0x830ED878 => {
    //   block [0x830ED878..0x830EDA08)
	// 830ED878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED87C: 480BA8F1  bl 0x831a816c
	ctx.lr = 0x830ED880;
	sub_831A8130(ctx, base);
	// 830ED880: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 830ED884: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830ED888: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830ED88C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED890: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830ED894: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830ED898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830ED89C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 830ED8A0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830ED8A4: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830ED8A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830ED8AC: 419A0008  beq cr6, 0x830ed8b4
	if ctx.cr[6].eq {
	pc = 0x830ED8B4; continue 'dispatch;
	}
	// 830ED8B0: D3BE0000  stfs f29, 0(r30)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED8B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830ED8B8: 419A0008  beq cr6, 0x830ed8c0
	if ctx.cr[6].eq {
	pc = 0x830ED8C0; continue 'dispatch;
	}
	// 830ED8BC: D3BD0000  stfs f29, 0(r29)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED8C0: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830ED8C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830ED8C8: 41980064  blt cr6, 0x830ed92c
	if ctx.cr[6].lt {
	pc = 0x830ED92C; continue 'dispatch;
	}
	// 830ED8CC: 419A0034  beq cr6, 0x830ed900
	if ctx.cr[6].eq {
	pc = 0x830ED900; continue 'dispatch;
	}
	// 830ED8D0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830ED8D4: 41980020  blt cr6, 0x830ed8f4
	if ctx.cr[6].lt {
	pc = 0x830ED8F4; continue 'dispatch;
	}
	// 830ED8D8: 419A001C  beq cr6, 0x830ed8f4
	if ctx.cr[6].eq {
	pc = 0x830ED8F4; continue 'dispatch;
	}
	// 830ED8DC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 830ED8E0: 41980008  blt cr6, 0x830ed8e8
	if ctx.cr[6].lt {
	pc = 0x830ED8E8; continue 'dispatch;
	}
	// 830ED8E4: 409A0080  bne cr6, 0x830ed964
	if !ctx.cr[6].eq {
	pc = 0x830ED964; continue 'dispatch;
	}
	// 830ED8E8: C3FF0034  lfs f31, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830ED8EC: C3DF0038  lfs f30, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830ED8F0: 4800007C  b 0x830ed96c
	pc = 0x830ED96C; continue 'dispatch;
	// 830ED8F4: C3FF003C  lfs f31, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830ED8F8: C3DF0040  lfs f30, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830ED8FC: 48000070  b 0x830ed96c
	pc = 0x830ED96C; continue 'dispatch;
	// 830ED900: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830ED904: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ED908: 409A001C  bne cr6, 0x830ed924
	if !ctx.cr[6].eq {
	pc = 0x830ED924; continue 'dispatch;
	}
	// 830ED90C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED910: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED914: 409A003C  bne cr6, 0x830ed950
	if !ctx.cr[6].eq {
	pc = 0x830ED950; continue 'dispatch;
	}
	// 830ED918: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED91C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED920: 409A0030  bne cr6, 0x830ed950
	if !ctx.cr[6].eq {
	pc = 0x830ED950; continue 'dispatch;
	}
	// 830ED924: C3FF0034  lfs f31, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830ED928: 4BFFFFD0  b 0x830ed8f8
	pc = 0x830ED8F8; continue 'dispatch;
	// 830ED92C: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830ED930: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ED934: 409A0028  bne cr6, 0x830ed95c
	if !ctx.cr[6].eq {
	pc = 0x830ED95C; continue 'dispatch;
	}
	// 830ED938: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830ED93C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED940: 409A0010  bne cr6, 0x830ed950
	if !ctx.cr[6].eq {
	pc = 0x830ED950; continue 'dispatch;
	}
	// 830ED944: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED94C: 419A0010  beq cr6, 0x830ed95c
	if ctx.cr[6].eq {
	pc = 0x830ED95C; continue 'dispatch;
	}
	// 830ED950: C3FF0050  lfs f31, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830ED954: C3DF004C  lfs f30, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830ED958: 48000014  b 0x830ed96c
	pc = 0x830ED96C; continue 'dispatch;
	// 830ED95C: C3FF003C  lfs f31, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830ED960: 4BFFFF8C  b 0x830ed8ec
	pc = 0x830ED8EC; continue 'dispatch;
	// 830ED964: C3C10054  lfs f30, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830ED968: C3E10050  lfs f31, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830ED96C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830ED970: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED974: 419A0064  beq cr6, 0x830ed9d8
	if ctx.cr[6].eq {
	pc = 0x830ED9D8; continue 'dispatch;
	}
	// 830ED978: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830ED97C: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 830ED980: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830ED984: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830ED988: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830ED98C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830ED990: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830ED994: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830ED998: 5566DFFE  rlwinm r6, r11, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830ED99C: 4BFF9B5D  bl 0x830e74f8
	ctx.lr = 0x830ED9A0;
	sub_830E74F8(ctx, base);
	// 830ED9A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED9A4: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 830ED9A8: 4BFE1269  bl 0x830cec10
	ctx.lr = 0x830ED9AC;
	sub_830CEC10(ctx, base);
	// 830ED9AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830ED9B0: 4BFE8219  bl 0x830d5bc8
	ctx.lr = 0x830ED9B4;
	sub_830D5BC8(ctx, base);
	// 830ED9B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830ED9B8: 4180003C  blt 0x830ed9f4
	if ctx.cr[0].lt {
	pc = 0x830ED9F4; continue 'dispatch;
	}
	// 830ED9BC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830ED9C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED9C4: 419A0014  beq cr6, 0x830ed9d8
	if ctx.cr[6].eq {
	pc = 0x830ED9D8; continue 'dispatch;
	}
	// 830ED9C8: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830ED9CC: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830ED9D0: FFE0E82E  fsel f31, f0, f0, f29
	ctx.f[31].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[29].f64 };
	// 830ED9D4: FFCDEB6E  fsel f30, f13, f13, f29
	ctx.f[30].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[29].f64 };
	// 830ED9D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830ED9DC: 419A0008  beq cr6, 0x830ed9e4
	if ctx.cr[6].eq {
	pc = 0x830ED9E4; continue 'dispatch;
	}
	// 830ED9E0: D3FE0000  stfs f31, 0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED9E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830ED9E8: 419A0008  beq cr6, 0x830ed9f0
	if ctx.cr[6].eq {
	pc = 0x830ED9F0; continue 'dispatch;
	}
	// 830ED9EC: D3DD0000  stfs f30, 0(r29)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830ED9F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830ED9F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830ED9F8: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830ED9FC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830EDA00: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830EDA04: 480BA7B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDA08 size=40
    let mut pc: u32 = 0x830EDA08;
    'dispatch: loop {
        match pc {
            0x830EDA08 => {
    //   block [0x830EDA08..0x830EDA30)
	// 830EDA08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EDA0C: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 830EDA10: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 830EDA14: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EDA18: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EDA1C: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830EDA20: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EDA24: B1230014  sth r9, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 830EDA28: B1630016  sth r11, 0x16(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	// 830EDA2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EDA30 size=176
    let mut pc: u32 = 0x830EDA30;
    'dispatch: loop {
        match pc {
            0x830EDA30 => {
    //   block [0x830EDA30..0x830EDAE0)
	// 830EDA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EDA38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EDA3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDA40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EDA44: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDA48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EDA4C: 419A0080  beq cr6, 0x830edacc
	if ctx.cr[6].eq {
	pc = 0x830EDACC; continue 'dispatch;
	}
	// 830EDA50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EDA54: 4BFF265D  bl 0x830e00b0
	ctx.lr = 0x830EDA58;
	sub_830E00B0(ctx, base);
	// 830EDA58: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDA5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EDA60: 419A006C  beq cr6, 0x830edacc
	if ctx.cr[6].eq {
	pc = 0x830EDACC; continue 'dispatch;
	}
	// 830EDA64: 4B36E745  bl 0x8245c1a8
	ctx.lr = 0x830EDA68;
	sub_8245C1A8(ctx, base);
	// 830EDA68: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EDA6C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EDA70: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830EDA74: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EDA78: 419A003C  beq cr6, 0x830edab4
	if ctx.cr[6].eq {
	pc = 0x830EDAB4; continue 'dispatch;
	}
	// 830EDA7C: 4099000C  ble cr6, 0x830eda88
	if !ctx.cr[6].gt {
	pc = 0x830EDA88; continue 'dispatch;
	}
	// 830EDA80: 7D4A5851  subf. r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EDA84: 41800030  blt 0x830edab4
	if ctx.cr[0].lt {
	pc = 0x830EDAB4; continue 'dispatch;
	}
	// 830EDA88: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EDA8C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EDA90: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830EDA94: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 830EDA98: 0CC80000  twi 6, r8, 0
	// 830EDA9C: 7D4B31D6  mullw r10, r11, r6
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[6].s32 as i64);
	// 830EDAA0: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830EDAA4: 7CCA43D6  divw r6, r10, r8
	ctx.r[6].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 830EDAA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830EDAAC: 7D0B5878  andc r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830EDAB0: 0CABFFFF  twi 5, r11, -1
	// 830EDAB4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830EDAB8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDABC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830EDAC0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830EDAC4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 830EDAC8: 4BFF2691  bl 0x830e0158
	ctx.lr = 0x830EDACC;
	sub_830E0158(ctx, base);
	// 830EDACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EDAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EDAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EDAD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EDADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDAE0 size=76
    let mut pc: u32 = 0x830EDAE0;
    'dispatch: loop {
        match pc {
            0x830EDAE0 => {
    //   block [0x830EDAE0..0x830EDB2C)
	// 830EDAE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EDAE4: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 830EDAE8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830EDAEC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EDAF0: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 830EDAF4: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EDAF8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 830EDAFC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830EDB00: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 830EDB04: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830EDB08: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830EDB0C: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830EDB10: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830EDB14: B1030030  sth r8, 0x30(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[8].u16 ) };
	// 830EDB18: B1630032  sth r11, 0x32(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(50 as u32), ctx.r[11].u16 ) };
	// 830EDB1C: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 830EDB20: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EDB24: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EDB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EDB30 size=120
    let mut pc: u32 = 0x830EDB30;
    'dispatch: loop {
        match pc {
            0x830EDB30 => {
    //   block [0x830EDB30..0x830EDBA8)
	// 830EDB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EDB38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EDB3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDB40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EDB44: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EDB48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EDB4C: 419A0020  beq cr6, 0x830edb6c
	if ctx.cr[6].eq {
	pc = 0x830EDB6C; continue 'dispatch;
	}
	// 830EDB50: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EDB54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EDB58: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EDB5C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EDB60: 41990008  bgt cr6, 0x830edb68
	if ctx.cr[6].gt {
	pc = 0x830EDB68; continue 'dispatch;
	}
	// 830EDB64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EDB68: 4BFFA7E1  bl 0x830e8348
	ctx.lr = 0x830EDB6C;
	sub_830E8348(ctx, base);
	// 830EDB6C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EDB70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EDB74: 419A0020  beq cr6, 0x830edb94
	if ctx.cr[6].eq {
	pc = 0x830EDB94; continue 'dispatch;
	}
	// 830EDB78: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EDB7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EDB80: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EDB84: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EDB88: 41980008  blt cr6, 0x830edb90
	if ctx.cr[6].lt {
	pc = 0x830EDB90; continue 'dispatch;
	}
	// 830EDB8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EDB90: 4BFFA7B9  bl 0x830e8348
	ctx.lr = 0x830EDB94;
	sub_830E8348(ctx, base);
	// 830EDB94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EDB98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EDB9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EDBA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EDBA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EDBA8 size=380
    let mut pc: u32 = 0x830EDBA8;
    'dispatch: loop {
        match pc {
            0x830EDBA8 => {
    //   block [0x830EDBA8..0x830EDD24)
	// 830EDBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDBAC: 480BA5B9  bl 0x831a8164
	ctx.lr = 0x830EDBB0;
	sub_831A8130(ctx, base);
	// 830EDBB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDBB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EDBB8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830EDBBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDBC4: 419A0158  beq cr6, 0x830edd1c
	if ctx.cr[6].eq {
	pc = 0x830EDD1C; continue 'dispatch;
	}
	// 830EDBC8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830EDBCC: 419A000C  beq cr6, 0x830edbd8
	if ctx.cr[6].eq {
	pc = 0x830EDBD8; continue 'dispatch;
	}
	// 830EDBD0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830EDBD4: 48000010  b 0x830edbe4
	pc = 0x830EDBE4; continue 'dispatch;
	// 830EDBD8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDBDC: 4BFF382D  bl 0x830e1408
	ctx.lr = 0x830EDBE0;
	sub_830E1408(ctx, base);
	// 830EDBE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EDBE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDBE8: 4BFF2FB9  bl 0x830e0ba0
	ctx.lr = 0x830EDBEC;
	sub_830E0BA0(ctx, base);
	// 830EDBEC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830EDBF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EDBF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDBF8: 4BFF24B9  bl 0x830e00b0
	ctx.lr = 0x830EDBFC;
	sub_830E00B0(ctx, base);
	// 830EDBFC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830EDC00: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830EDC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDC08: 419A00A4  beq cr6, 0x830edcac
	if ctx.cr[6].eq {
	pc = 0x830EDCAC; continue 'dispatch;
	}
	// 830EDC0C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830EDC10: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 830EDC14: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830EDC18: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830EDC1C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EDC20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDC24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EDC28: 4BFF8451  bl 0x830e6078
	ctx.lr = 0x830EDC2C;
	sub_830E6078(ctx, base);
	// 830EDC2C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDC30: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EDC34: 41980078  blt cr6, 0x830edcac
	if ctx.cr[6].lt {
	pc = 0x830EDCAC; continue 'dispatch;
	}
	// 830EDC38: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EDC3C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830EDC40: 4198006C  blt cr6, 0x830edcac
	if ctx.cr[6].lt {
	pc = 0x830EDCAC; continue 'dispatch;
	}
	// 830EDC44: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EDC48: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EDC4C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EDC50: 419A0044  beq cr6, 0x830edc94
	if ctx.cr[6].eq {
	pc = 0x830EDC94; continue 'dispatch;
	}
	// 830EDC54: 4099000C  ble cr6, 0x830edc60
	if !ctx.cr[6].gt {
	pc = 0x830EDC60; continue 'dispatch;
	}
	// 830EDC58: 7D4A5851  subf. r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EDC5C: 41800038  blt 0x830edc94
	if ctx.cr[0].lt {
	pc = 0x830EDC94; continue 'dispatch;
	}
	// 830EDC60: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EDC64: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 830EDC68: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EDC6C: 7CAA5850  subf r5, r10, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830EDC70: 7D6A3850  subf r11, r10, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 830EDC74: 0CC50000  twi 6, r5, 0
	// 830EDC78: 7D4B41D6  mullw r10, r11, r8
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830EDC7C: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830EDC80: 7D4A2BD6  divw r10, r10, r5
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[5].s32;
	// 830EDC84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830EDC88: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EDC8C: 7CAB5878  andc r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 & !ctx.r[11].u64;
	// 830EDC90: 0CABFFFF  twi 5, r11, -1
	// 830EDC94: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830EDC98: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDC9C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830EDCA0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830EDCA4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 830EDCA8: 4BFF24B1  bl 0x830e0158
	ctx.lr = 0x830EDCAC;
	sub_830E0158(ctx, base);
	// 830EDCAC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830EDCB0: 419A006C  beq cr6, 0x830edd1c
	if ctx.cr[6].eq {
	pc = 0x830EDD1C; continue 'dispatch;
	}
	// 830EDCB4: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EDCB8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDCBC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830EDCC0: 388B9488  addi r4, r11, -0x6b78
	ctx.r[4].s64 = ctx.r[11].s64 + -27512;
	// 830EDCC4: 4BFF201D  bl 0x830dfce0
	ctx.lr = 0x830EDCC8;
	sub_830DFCE0(ctx, base);
	// 830EDCC8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EDCCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EDCD0: 419A004C  beq cr6, 0x830edd1c
	if ctx.cr[6].eq {
	pc = 0x830EDD1C; continue 'dispatch;
	}
	// 830EDCD4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830EDCD8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830EDCDC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830EDCE0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 830EDCE4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EDCE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EDCEC: 4BFF838D  bl 0x830e6078
	ctx.lr = 0x830EDCF0;
	sub_830E6078(ctx, base);
	// 830EDCF0: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EDCF4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830EDCF8: 41980024  blt cr6, 0x830edd1c
	if ctx.cr[6].lt {
	pc = 0x830EDD1C; continue 'dispatch;
	}
	// 830EDCFC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDD00: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830EDD04: 41980018  blt cr6, 0x830edd1c
	if ctx.cr[6].lt {
	pc = 0x830EDD1C; continue 'dispatch;
	}
	// 830EDD08: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830EDD0C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EDD10: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830EDD14: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830EDD18: 4BFF2441  bl 0x830e0158
	ctx.lr = 0x830EDD1C;
	sub_830E0158(ctx, base);
	// 830EDD1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EDD20: 480BA494  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EDD28 size=128
    let mut pc: u32 = 0x830EDD28;
    'dispatch: loop {
        match pc {
            0x830EDD28 => {
    //   block [0x830EDD28..0x830EDDA8)
	// 830EDD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EDD30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDD34: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EDD38: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EDD3C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830EDD40: 409A000C  bne cr6, 0x830edd4c
	if !ctx.cr[6].eq {
	pc = 0x830EDD4C; continue 'dispatch;
	}
	// 830EDD44: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830EDD48: 419A0018  beq cr6, 0x830edd60
	if ctx.cr[6].eq {
	pc = 0x830EDD60; continue 'dispatch;
	}
	// 830EDD4C: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EDD50: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 830EDD54: 409A0018  bne cr6, 0x830edd6c
	if !ctx.cr[6].eq {
	pc = 0x830EDD6C; continue 'dispatch;
	}
	// 830EDD58: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830EDD5C: 409A0018  bne cr6, 0x830edd74
	if !ctx.cr[6].eq {
	pc = 0x830EDD74; continue 'dispatch;
	}
	// 830EDD60: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830EDD64: 60634001  ori r3, r3, 0x4001
	ctx.r[3].u64 = ctx.r[3].u64 | 16385;
	// 830EDD68: 48000030  b 0x830edd98
	pc = 0x830EDD98; continue 'dispatch;
	// 830EDD6C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830EDD70: 419A000C  beq cr6, 0x830edd7c
	if ctx.cr[6].eq {
	pc = 0x830EDD7C; continue 'dispatch;
	}
	// 830EDD74: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830EDD78: 48000008  b 0x830edd80
	pc = 0x830EDD80; continue 'dispatch;
	// 830EDD7C: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EDD80: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830EDD84: 7C8B0034  cntlzw r11, r4
	ctx.r[11].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 830EDD88: 80630054  lwz r3, 0x54(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EDD8C: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830EDD90: 4BFF9AE9  bl 0x830e7878
	ctx.lr = 0x830EDD94;
	sub_830E7878(ctx, base);
	// 830EDD94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EDD98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EDD9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EDDA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EDDA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDDA8 size=16
    let mut pc: u32 = 0x830EDDA8;
    'dispatch: loop {
        match pc {
            0x830EDDA8 => {
    //   block [0x830EDDA8..0x830EDDB8)
	// 830EDDA8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830EDDAC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDDB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EDDB4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDDB8 size=16
    let mut pc: u32 = 0x830EDDB8;
    'dispatch: loop {
        match pc {
            0x830EDDB8 => {
    //   block [0x830EDDB8..0x830EDDC8)
	// 830EDDB8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EDDBC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDDC0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EDDC4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDDC8 size=28
    let mut pc: u32 = 0x830EDDC8;
    'dispatch: loop {
        match pc {
            0x830EDDC8 => {
    //   block [0x830EDDC8..0x830EDDE4)
	// 830EDDC8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 830EDDCC: 409A0018  bne cr6, 0x830edde4
	if !ctx.cr[6].eq {
		sub_830EDDE4(ctx, base);
		return;
	}
	// 830EDDD0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830EDDD4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EDDD8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830EDDDC: 992B000C  stb r9, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 830EDDE0: 4BFFA568  b 0x830e8348
	sub_830E8348(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDDE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDDE4 size=20
    let mut pc: u32 = 0x830EDDE4;
    'dispatch: loop {
        match pc {
            0x830EDDE4 => {
    //   block [0x830EDDE4..0x830EDDF8)
	// 830EDDE4: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830EDDE8: 409A0024  bne cr6, 0x830ede0c
	if !ctx.cr[6].eq {
		sub_830EDE0C(ctx, base);
		return;
	}
	// 830EDDEC: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EDDF0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EDDF4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDDF8 size=20
    let mut pc: u32 = 0x830EDDF8;
    'dispatch: loop {
        match pc {
            0x830EDDF8 => {
    //   block [0x830EDDF8..0x830EDE0C)
	// 830EDDF8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EDDFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EDE00: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EDE04: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 830EDE08: 4BFFA540  b 0x830e8348
	sub_830E8348(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDE0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDE0C size=8
    let mut pc: u32 = 0x830EDE0C;
    'dispatch: loop {
        match pc {
            0x830EDE0C => {
    //   block [0x830EDE0C..0x830EDE14)
	// 830EDE0C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EDE10: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDE14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDE14 size=12
    let mut pc: u32 = 0x830EDE14;
    'dispatch: loop {
        match pc {
            0x830EDE14 => {
    //   block [0x830EDE14..0x830EDE20)
	// 830EDE14: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EDE18: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EDE1C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDE20 size=24
    let mut pc: u32 = 0x830EDE20;
    'dispatch: loop {
        match pc {
            0x830EDE20 => {
    //   block [0x830EDE20..0x830EDE38)
	// 830EDE20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EDE24: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830EDE28: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EDE2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EDE30: 992B000C  stb r9, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 830EDE34: 4BFFA514  b 0x830e8348
	sub_830E8348(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDE38 size=4
    let mut pc: u32 = 0x830EDE38;
    'dispatch: loop {
        match pc {
            0x830EDE38 => {
    //   block [0x830EDE38..0x830EDE3C)
	// 830EDE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EDE40 size=152
    let mut pc: u32 = 0x830EDE40;
    'dispatch: loop {
        match pc {
            0x830EDE40 => {
    //   block [0x830EDE40..0x830EDED8)
	// 830EDE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDE44: 480BA329  bl 0x831a816c
	ctx.lr = 0x830EDE48;
	sub_831A8130(ctx, base);
	// 830EDE48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDE4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EDE50: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EDE54: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830EDE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDE5C: 419A0074  beq cr6, 0x830eded0
	if ctx.cr[6].eq {
	pc = 0x830EDED0; continue 'dispatch;
	}
	// 830EDE60: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EDE64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDE68: 419A0068  beq cr6, 0x830eded0
	if ctx.cr[6].eq {
	pc = 0x830EDED0; continue 'dispatch;
	}
	// 830EDE6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830EDE70: 419A0060  beq cr6, 0x830eded0
	if ctx.cr[6].eq {
	pc = 0x830EDED0; continue 'dispatch;
	}
	// 830EDE74: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EDE78: 3BDF0078  addi r30, r31, 0x78
	ctx.r[30].s64 = ctx.r[31].s64 + 120;
	// 830EDE7C: 4BFEF65D  bl 0x830dd4d8
	ctx.lr = 0x830EDE80;
	sub_830DD4D8(ctx, base);
	// 830EDE80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EDE84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EDE88: C1BF00C4  lfs f13, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EDE8C: 395F007C  addi r10, r31, 0x7c
	ctx.r[10].s64 = ctx.r[31].s64 + 124;
	// 830EDE90: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830EDE94: 90BF0078  stw r5, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 830EDE98: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 830EDE9C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830EDEA0: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EDEA4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EDEA8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830EDEAC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830EDEB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EDEB4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830EDEB8: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830EDEBC: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830EDEC0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830EDEC4: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EDEC8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EDECC: 4801E19D  bl 0x8310c068
	ctx.lr = 0x830EDED0;
	sub_8310C068(ctx, base);
	// 830EDED0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EDED4: 480BA2E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EDED8 size=300
    let mut pc: u32 = 0x830EDED8;
    'dispatch: loop {
        match pc {
            0x830EDED8 => {
    //   block [0x830EDED8..0x830EE004)
	// 830EDED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDEDC: 480BA28D  bl 0x831a8168
	ctx.lr = 0x830EDEE0;
	sub_831A8130(ctx, base);
	// 830EDEE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDEE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EDEE8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EDEEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EDEF0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830EDEF4: 3BBF0054  addi r29, r31, 0x54
	ctx.r[29].s64 = ctx.r[31].s64 + 84;
	// 830EDEF8: 3BDF0058  addi r30, r31, 0x58
	ctx.r[30].s64 = ctx.r[31].s64 + 88;
	// 830EDEFC: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 830EDF00: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 830EDF04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDF08: 4BFF3651  bl 0x830e1558
	ctx.lr = 0x830EDF0C;
	sub_830E1558(ctx, base);
	// 830EDF0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDF10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EDF14: 419A00E8  beq cr6, 0x830edffc
	if ctx.cr[6].eq {
	pc = 0x830EDFFC; continue 'dispatch;
	}
	// 830EDF18: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EDF1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EDF20: 388B94FC  addi r4, r11, -0x6b04
	ctx.r[4].s64 = ctx.r[11].s64 + -27396;
	// 830EDF24: 4BFF1DBD  bl 0x830dfce0
	ctx.lr = 0x830EDF28;
	sub_830DFCE0(ctx, base);
	// 830EDF28: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EDF2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EDF30: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDF34: 388B8430  addi r4, r11, -0x7bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -31696;
	// 830EDF38: 4BFF1DA9  bl 0x830dfce0
	ctx.lr = 0x830EDF3C;
	sub_830DFCE0(ctx, base);
	// 830EDF3C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EDF40: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 830EDF44: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDF48: 388B94E4  addi r4, r11, -0x6b1c
	ctx.r[4].s64 = ctx.r[11].s64 + -27420;
	// 830EDF4C: 4BFF1D95  bl 0x830dfce0
	ctx.lr = 0x830EDF50;
	sub_830DFCE0(ctx, base);
	// 830EDF50: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EDF54: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 830EDF58: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDF5C: 388B94CC  addi r4, r11, -0x6b34
	ctx.r[4].s64 = ctx.r[11].s64 + -27444;
	// 830EDF60: 4BFF1D81  bl 0x830dfce0
	ctx.lr = 0x830EDF64;
	sub_830DFCE0(ctx, base);
	// 830EDF64: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EDF68: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 830EDF6C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDF70: 388B94B8  addi r4, r11, -0x6b48
	ctx.r[4].s64 = ctx.r[11].s64 + -27464;
	// 830EDF74: 4BFF1D6D  bl 0x830dfce0
	ctx.lr = 0x830EDF78;
	sub_830DFCE0(ctx, base);
	// 830EDF78: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EDF7C: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 830EDF80: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDF84: 388B94A0  addi r4, r11, -0x6b60
	ctx.r[4].s64 = ctx.r[11].s64 + -27488;
	// 830EDF88: 4BFF1D59  bl 0x830dfce0
	ctx.lr = 0x830EDF8C;
	sub_830DFCE0(ctx, base);
	// 830EDF8C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDF90: 4BFF12D9  bl 0x830df268
	ctx.lr = 0x830EDF94;
	sub_830DF268(ctx, base);
	// 830EDF94: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EDF98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EDF9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDFA0: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EDFA4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EDFA8: 409A0014  bne cr6, 0x830edfbc
	if !ctx.cr[6].eq {
	pc = 0x830EDFBC; continue 'dispatch;
	}
	// 830EDFAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EDFB0: 51646EB6  rlwimi r4, r11, 0xd, 0x1a, 0x1b
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(13) as u64) & 0x0000000000000030) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFFFCF);
	// 830EDFB4: 51646CA4  rlwimi r4, r11, 0xd, 0x12, 0x12
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(13) as u64) & 0x0000000000002000) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFDFFF);
	// 830EDFB8: 48000010  b 0x830edfc8
	pc = 0x830EDFC8; continue 'dispatch;
	// 830EDFBC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830EDFC0: 516426B6  rlwimi r4, r11, 4, 0x1a, 0x1b
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(4) as u64) & 0x0000000000000030) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFFFCF);
	// 830EDFC4: 516424A4  rlwimi r4, r11, 4, 0x12, 0x12
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(4) as u64) & 0x0000000000002000) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFDFFF);
	// 830EDFC8: 4BFF1249  bl 0x830df210
	ctx.lr = 0x830EDFCC;
	sub_830DF210(ctx, base);
	// 830EDFCC: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EDFD0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EDFD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EDFD8: 419A0018  beq cr6, 0x830edff0
	if ctx.cr[6].eq {
	pc = 0x830EDFF0; continue 'dispatch;
	}
	// 830EDFDC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDFE0: 4BFF2BC1  bl 0x830e0ba0
	ctx.lr = 0x830EDFE4;
	sub_830E0BA0(ctx, base);
	// 830EDFE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EDFE8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EDFEC: 40820008  bne 0x830edff4
	if !ctx.cr[0].eq {
	pc = 0x830EDFF4; continue 'dispatch;
	}
	// 830EDFF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830EDFF4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDFF8: 4BFF9881  bl 0x830e7878
	ctx.lr = 0x830EDFFC;
	sub_830E7878(ctx, base);
	// 830EDFFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EE000: 480BA1B8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE008 size=208
    let mut pc: u32 = 0x830EE008;
    'dispatch: loop {
        match pc {
            0x830EE008 => {
    //   block [0x830EE008..0x830EE0D8)
	// 830EE008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE00C: 480BA161  bl 0x831a816c
	ctx.lr = 0x830EE010;
	sub_831A8130(ctx, base);
	// 830EE010: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE018: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EE01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EE020: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EE024: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830EE028: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830EE02C: 4BFFE255  bl 0x830ec280
	ctx.lr = 0x830EE030;
	sub_830EC280(ctx, base);
	// 830EE030: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EE034: 4080000C  bge 0x830ee040
	if !ctx.cr[0].lt {
	pc = 0x830EE040; continue 'dispatch;
	}
	// 830EE038: 907F007C  stw r3, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 830EE03C: 48000094  b 0x830ee0d0
	pc = 0x830EE0D0; continue 'dispatch;
	// 830EE040: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EE044: 480BB085  bl 0x831a90c8
	ctx.lr = 0x830EE048;
	sub_831A90C8(ctx, base);
	// 830EE048: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830EE04C: 40990058  ble cr6, 0x830ee0a4
	if !ctx.cr[6].gt {
	pc = 0x830EE0A4; continue 'dispatch;
	}
	// 830EE050: 3943FFFC  addi r10, r3, -4
	ctx.r[10].s64 = ctx.r[3].s64 + -4;
	// 830EE054: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EE058: 3D208219  lis r9, -0x7de7
	ctx.r[9].s64 = -2112290816;
	// 830EE05C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EE060: 38899508  addi r4, r9, -0x6af8
	ctx.r[4].s64 = ctx.r[9].s64 + -27384;
	// 830EE064: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830EE068: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830EE06C: 480C3B15  bl 0x831b1b80
	ctx.lr = 0x830EE070;
	sub_831B1B80(ctx, base);
	// 830EE070: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EE074: 40820030  bne 0x830ee0a4
	if !ctx.cr[0].eq {
	pc = 0x830EE0A4; continue 'dispatch;
	}
	// 830EE078: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830EE07C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EE080: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EE084: 4BFEE7DD  bl 0x830dc860
	ctx.lr = 0x830EE088;
	sub_830DC860(ctx, base);
	// 830EE088: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EE08C: 41800034  blt 0x830ee0c0
	if ctx.cr[0].lt {
	pc = 0x830EE0C0; continue 'dispatch;
	}
	// 830EE090: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EE094: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EE098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE09C: 4BFF834D  bl 0x830e63e8
	ctx.lr = 0x830EE0A0;
	sub_830E63E8(ctx, base);
	// 830EE0A0: 48000020  b 0x830ee0c0
	pc = 0x830EE0C0; continue 'dispatch;
	// 830EE0A4: 389F0084  addi r4, r31, 0x84
	ctx.r[4].s64 = ctx.r[31].s64 + 132;
	// 830EE0A8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EE0AC: 48023F4D  bl 0x83111ff8
	ctx.lr = 0x830EE0B0;
	sub_83111FF8(ctx, base);
	// 830EE0B0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EE0B4: 4180000C  blt 0x830ee0c0
	if ctx.cr[0].lt {
	pc = 0x830EE0C0; continue 'dispatch;
	}
	// 830EE0B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EE0BC: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830EE0C0: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 830EE0C4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EE0C8: 4BFEF411  bl 0x830dd4d8
	ctx.lr = 0x830EE0CC;
	sub_830DD4D8(ctx, base);
	// 830EE0CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE0D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EE0D4: 480BA0E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EE0D8 size=1136
    let mut pc: u32 = 0x830EE0D8;
    'dispatch: loop {
        match pc {
            0x830EE0D8 => {
    //   block [0x830EE0D8..0x830EE548)
	// 830EE0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE0DC: 480BA081  bl 0x831a815c
	ctx.lr = 0x830EE0E0;
	sub_831A8130(ctx, base);
	// 830EE0E0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 830EE0E4: 480BA979  bl 0x831a8a5c
	ctx.lr = 0x830EE0E8;
	sub_831A8A40(ctx, base);
	// 830EE0E8: 9421FCB0  stwu r1, -0x350(r1)
	ea = ctx.r[1].u32.wrapping_add(-848 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE0EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EE0F0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830EE0F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EE0F8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EE0FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EE100: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830EE104: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830EE108: 4BFF9701  bl 0x830e7808
	ctx.lr = 0x830EE10C;
	sub_830E7808(ctx, base);
	// 830EE10C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830EE110: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EE114: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EE118: 48022301  bl 0x83110418
	ctx.lr = 0x830EE11C;
	sub_83110418(ctx, base);
	// 830EE11C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EE120: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830EE124: C3C10050  lfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830EE128: C3E10060  lfs f31, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EE12C: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 830EE130: FD80F890  fmr f12, f31
	ctx.f[12].f64 = ctx.f[31].f64;
	// 830EE134: C38B08A4  lfs f28, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830EE138: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 830EE13C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EE140: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830EE144: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830EE148: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830EE14C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830EE150: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830EE154: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830EE158: FF405818  frsp f26, f11
	ctx.f[26].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830EE15C: FFA00018  frsp f29, f0
	ctx.f[29].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830EE160: 419A0330  beq cr6, 0x830ee490
	if ctx.cr[6].eq {
	pc = 0x830EE490; continue 'dispatch;
	}
	// 830EE164: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 830EE168: 419A0328  beq cr6, 0x830ee490
	if ctx.cr[6].eq {
	pc = 0x830EE490; continue 'dispatch;
	}
	// 830EE16C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EE170: FF00E090  fmr f24, f28
	ctx.f[24].f64 = ctx.f[28].f64;
	// 830EE174: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830EE178: FEE0E090  fmr f23, f28
	ctx.f[23].f64 = ctx.f[28].f64;
	// 830EE17C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830EE180: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 830EE184: C32B08A8  lfs f25, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 830EE188: C36A9450  lfs f27, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 830EE18C: FEA0C890  fmr f21, f25
	ctx.f[21].f64 = ctx.f[25].f64;
	// 830EE190: FEC0C890  fmr f22, f25
	ctx.f[22].f64 = ctx.f[25].f64;
	// 830EE194: 409A0028  bne cr6, 0x830ee1bc
	if !ctx.cr[6].eq {
	pc = 0x830EE1BC; continue 'dispatch;
	}
	// 830EE198: D39F0004  stfs f28, 4(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EE19C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EE1A0: D39F0000  stfs f28, 0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EE1A4: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 830EE1A8: D3BF0008  stfs f29, 8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EE1AC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 830EE1B0: D35F000C  stfs f26, 0xc(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EE1B4: 4BFF3855  bl 0x830e1a08
	ctx.lr = 0x830EE1B8;
	sub_830E1A08(ctx, base);
	// 830EE1B8: 480000C8  b 0x830ee280
	pc = 0x830EE280; continue 'dispatch;
	// 830EE1BC: 57CB07BC  rlwinm r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE1C0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EE1C4: 409A0070  bne cr6, 0x830ee234
	if !ctx.cr[6].eq {
	pc = 0x830EE234; continue 'dispatch;
	}
	// 830EE1C8: EC1D06F2  fmuls f0, f29, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE1CC: EDBA06F2  fmuls f13, f26, f27
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE1D0: ED9F06F8  fmsubs f12, f31, f27, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EE1D4: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EE1D8: ED7E6EF8  fmsubs f11, f30, f27, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[27].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EE1DC: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EE1E0: EC0CE82A  fadds f0, f12, f29
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[29].f64) as f32) as f64;
	// 830EE1E4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EE1E8: ED4CE824  fdivs f10, f12, f29
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[29].f64) as f32) as f64;
	// 830EE1EC: ED2BD024  fdivs f9, f11, f26
	ctx.f[9].f64 = ((ctx.f[11].f64 / ctx.f[26].f64) as f32) as f64;
	// 830EE1F0: FD8CE32E  fsel f12, f12, f12, f28
	ctx.f[12].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[28].f64 };
	// 830EE1F4: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EE1F8: EDABD02A  fadds f13, f11, f26
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[26].f64) as f32) as f64;
	// 830EE1FC: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EE200: FD8BE2EE  fsel f12, f11, f11, f28
	ctx.f[12].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[28].f64 };
	// 830EE204: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EE208: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EE20C: FF005050  fneg f24, f10
	ctx.f[24].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 830EE210: FEE04850  fneg f23, f9
	ctx.f[23].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 830EE214: 41980008  blt cr6, 0x830ee21c
	if ctx.cr[6].lt {
	pc = 0x830EE21C; continue 'dispatch;
	}
	// 830EE218: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 830EE21C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EE220: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 830EE224: 41980008  blt cr6, 0x830ee22c
	if ctx.cr[6].lt {
	pc = 0x830EE22C; continue 'dispatch;
	}
	// 830EE228: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 830EE22C: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EE230: 48000050  b 0x830ee280
	pc = 0x830EE280; continue 'dispatch;
	// 830EE234: 57CB077A  rlwinm r11, r30, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE238: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830EE23C: 409A00EC  bne cr6, 0x830ee328
	if !ctx.cr[6].eq {
	pc = 0x830EE328; continue 'dispatch;
	}
	// 830EE240: D39F0004  stfs f28, 4(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EE244: EEBDF824  fdivs f21, f29, f31
	ctx.f[21].f64 = ((ctx.f[29].f64 / ctx.f[31].f64) as f32) as f64;
	// 830EE248: D39F0000  stfs f28, 0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EE24C: EEDAF024  fdivs f22, f26, f30
	ctx.f[22].f64 = ((ctx.f[26].f64 / ctx.f[30].f64) as f32) as f64;
	// 830EE250: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EE254: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EE258: ED9ED028  fsubs f12, f30, f26
	ctx.f[12].f64 = (((ctx.f[30].f64 - ctx.f[26].f64) as f32) as f64);
	// 830EE25C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830EE260: EDBFE828  fsubs f13, f31, f29
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[29].f64) as f32) as f64);
	// 830EE264: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE268: ED60E824  fdivs f11, f0, f29
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[29].f64) as f32) as f64;
	// 830EE26C: EC00D024  fdivs f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[26].f64) as f32) as f64;
	// 830EE270: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE274: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE278: EEEC0032  fmuls f23, f12, f0
	ctx.f[23].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EE27C: EF0D02F2  fmuls f24, f13, f11
	ctx.f[24].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 830EE280: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 830EE284: FC60C890  fmr f3, f25
	ctx.f[3].f64 = ctx.f[25].f64;
	// 830EE288: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 830EE28C: FC20A890  fmr f1, f21
	ctx.f[1].f64 = ctx.f[21].f64;
	// 830EE290: 48029A49  bl 0x83117cd8
	ctx.lr = 0x830EE294;
	sub_83117CD8(ctx, base);
	// 830EE294: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830EE298: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 830EE29C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830EE2A0: C00B9530  lfs f0, -0x6ad0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE2A4: EC5E0032  fmuls f2, f30, f0
	ctx.f[2].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EE2A8: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EE2AC: 48029AA5  bl 0x83117d50
	ctx.lr = 0x830EE2B0;
	sub_83117D50(ctx, base);
	// 830EE2B0: 38A10170  addi r5, r1, 0x170
	ctx.r[5].s64 = ctx.r[1].s64 + 368;
	// 830EE2B4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EE2B8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830EE2BC: 48029B25  bl 0x83117de0
	ctx.lr = 0x830EE2C0;
	sub_83117DE0(ctx, base);
	// 830EE2C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830EE2C4: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 830EE2C8: EC5E06F2  fmuls f2, f30, f27
	ctx.f[2].f64 = (((ctx.f[30].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE2CC: EC3F06F2  fmuls f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE2D0: 48029A81  bl 0x83117d50
	ctx.lr = 0x830EE2D4;
	sub_83117D50(ctx, base);
	// 830EE2D4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 830EE2D8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 830EE2DC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830EE2E0: 48029B01  bl 0x83117de0
	ctx.lr = 0x830EE2E4;
	sub_83117DE0(ctx, base);
	// 830EE2E4: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 830EE2E8: FC60C890  fmr f3, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[25].f64;
	// 830EE2EC: EC59D024  fdivs f2, f25, f26
	ctx.f[2].f64 = ((ctx.f[25].f64 / ctx.f[26].f64) as f32) as f64;
	// 830EE2F0: EC39E824  fdivs f1, f25, f29
	ctx.f[1].f64 = ((ctx.f[25].f64 / ctx.f[29].f64) as f32) as f64;
	// 830EE2F4: 480299E5  bl 0x83117cd8
	ctx.lr = 0x830EE2F8;
	sub_83117CD8(ctx, base);
	// 830EE2F8: 38A101F0  addi r5, r1, 0x1f0
	ctx.r[5].s64 = ctx.r[1].s64 + 496;
	// 830EE2FC: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 830EE300: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 830EE304: 48029ADD  bl 0x83117de0
	ctx.lr = 0x830EE308;
	sub_83117DE0(ctx, base);
	// 830EE308: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830EE30C: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 830EE310: FC40B890  fmr f2, f23
	ctx.f[2].f64 = ctx.f[23].f64;
	// 830EE314: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 830EE318: 48029A39  bl 0x83117d50
	ctx.lr = 0x830EE31C;
	sub_83117D50(ctx, base);
	// 830EE31C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 830EE320: 38810270  addi r4, r1, 0x270
	ctx.r[4].s64 = ctx.r[1].s64 + 624;
	// 830EE324: 48000160  b 0x830ee484
	pc = 0x830EE484; continue 'dispatch;
	// 830EE328: 57CB0738  rlwinm r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE32C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 830EE330: 419A004C  beq cr6, 0x830ee37c
	if ctx.cr[6].eq {
	pc = 0x830EE37C; continue 'dispatch;
	}
	// 830EE334: 57CB06F6  rlwinm r11, r30, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE338: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830EE33C: 419A0040  beq cr6, 0x830ee37c
	if ctx.cr[6].eq {
	pc = 0x830EE37C; continue 'dispatch;
	}
	// 830EE340: D39F0004  stfs f28, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EE344: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 830EE348: D39F0000  stfs f28, 0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EE34C: 4098000C  bge cr6, 0x830ee358
	if !ctx.cr[6].lt {
	pc = 0x830EE358; continue 'dispatch;
	}
	// 830EE350: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 830EE354: 48000008  b 0x830ee35c
	pc = 0x830EE35C; continue 'dispatch;
	// 830EE358: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 830EE35C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EE360: FF1ED000  fcmpu cr6, f30, f26
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[26].f64);
	// 830EE364: 4098000C  bge cr6, 0x830ee370
	if !ctx.cr[6].lt {
	pc = 0x830EE370; continue 'dispatch;
	}
	// 830EE368: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 830EE36C: 48000008  b 0x830ee374
	pc = 0x830EE374; continue 'dispatch;
	// 830EE370: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 830EE374: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EE378: 4BFFFF08  b 0x830ee280
	pc = 0x830EE280; continue 'dispatch;
	// 830EE37C: EF19D024  fdivs f24, f25, f26
	ctx.f[24].f64 = ((ctx.f[25].f64 / ctx.f[26].f64) as f32) as f64;
	// 830EE380: D39F0000  stfs f28, 0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EE384: EC19F024  fdivs f0, f25, f30
	ctx.f[0].f64 = ((ctx.f[25].f64 / ctx.f[30].f64) as f32) as f64;
	// 830EE388: D39F0004  stfs f28, 4(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EE38C: 57CB06F6  rlwinm r11, r30, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE390: ED780772  fmuls f11, f24, f29
	ctx.f[11].f64 = (((ctx.f[24].f64 * ctx.f[29].f64) as f32) as f64);
	// 830EE394: ED4007F2  fmuls f10, f0, f31
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EE398: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 830EE39C: 40990028  ble cr6, 0x830ee3c4
	if !ctx.cr[6].gt {
	pc = 0x830EE3C4; continue 'dispatch;
	}
	// 830EE3A0: EC1FE824  fdivs f0, f31, f29
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[29].f64) as f32) as f64;
	// 830EE3A4: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830EE3A8: EFC006B2  fmuls f30, f0, f26
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 830EE3AC: 409A0010  bne cr6, 0x830ee3bc
	if !ctx.cr[6].eq {
	pc = 0x830EE3BC; continue 'dispatch;
	}
	// 830EE3B0: EC0DF028  fsubs f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 830EE3B4: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE3B8: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EE3BC: EEDDF824  fdivs f22, f29, f31
	ctx.f[22].f64 = ((ctx.f[29].f64 / ctx.f[31].f64) as f32) as f64;
	// 830EE3C0: 48000024  b 0x830ee3e4
	pc = 0x830EE3E4; continue 'dispatch;
	// 830EE3C4: ED7807B2  fmuls f11, f24, f30
	ctx.f[11].f64 = (((ctx.f[24].f64 * ctx.f[30].f64) as f32) as f64);
	// 830EE3C8: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830EE3CC: EFEB0772  fmuls f31, f11, f29
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[29].f64) as f32) as f64);
	// 830EE3D0: 409A0010  bne cr6, 0x830ee3e0
	if !ctx.cr[6].eq {
	pc = 0x830EE3E0; continue 'dispatch;
	}
	// 830EE3D4: ED6CF828  fsubs f11, f12, f31
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[31].f64) as f32) as f64);
	// 830EE3D8: ED6B06F2  fmuls f11, f11, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE3DC: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EE3E0: EEC006B2  fmuls f22, f0, f26
	ctx.f[22].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 830EE3E4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE3E8: FEA0B090  fmr f21, f22
	ctx.f[21].f64 = ctx.f[22].f64;
	// 830EE3EC: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EE3F0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830EE3F4: ED6BF02A  fadds f11, f11, f30
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 830EE3F8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EE3FC: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EE400: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830EE404: 409AFE54  bne cr6, 0x830ee258
	if !ctx.cr[6].eq {
	pc = 0x830EE258; continue 'dispatch;
	}
	// 830EE408: ED8CF828  fsubs f12, f12, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[31].f64) as f32) as f64);
	// 830EE40C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830EE410: EDADF028  fsubs f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 830EE414: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 830EE418: FC60C890  fmr f3, f25
	ctx.f[3].f64 = ctx.f[25].f64;
	// 830EE41C: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 830EE420: FC20B090  fmr f1, f22
	ctx.f[1].f64 = ctx.f[22].f64;
	// 830EE424: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE428: ED60F824  fdivs f11, f0, f31
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 830EE42C: EC00F024  fdivs f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[30].f64) as f32) as f64;
	// 830EE430: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE434: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 830EE438: EFEC02F2  fmuls f31, f12, f11
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 830EE43C: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EE440: 48029899  bl 0x83117cd8
	ctx.lr = 0x830EE444;
	sub_83117CD8(ctx, base);
	// 830EE444: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830EE448: FC60C890  fmr f3, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[25].f64;
	// 830EE44C: FC40C090  fmr f2, f24
	ctx.f[2].f64 = ctx.f[24].f64;
	// 830EE450: EC39E824  fdivs f1, f25, f29
	ctx.f[1].f64 = ((ctx.f[25].f64 / ctx.f[29].f64) as f32) as f64;
	// 830EE454: 48029885  bl 0x83117cd8
	ctx.lr = 0x830EE458;
	sub_83117CD8(ctx, base);
	// 830EE458: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 830EE45C: 38810230  addi r4, r1, 0x230
	ctx.r[4].s64 = ctx.r[1].s64 + 560;
	// 830EE460: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 830EE464: 4802997D  bl 0x83117de0
	ctx.lr = 0x830EE468;
	sub_83117DE0(ctx, base);
	// 830EE468: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 830EE46C: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 830EE470: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830EE474: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EE478: 480298D9  bl 0x83117d50
	ctx.lr = 0x830EE47C;
	sub_83117D50(ctx, base);
	// 830EE47C: 38A101B0  addi r5, r1, 0x1b0
	ctx.r[5].s64 = ctx.r[1].s64 + 432;
	// 830EE480: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 830EE484: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EE488: 48029959  bl 0x83117de0
	ctx.lr = 0x830EE48C;
	sub_83117DE0(ctx, base);
	// 830EE48C: 480000AC  b 0x830ee538
	pc = 0x830EE538; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE548 size=112
    let mut pc: u32 = 0x830EE548;
    'dispatch: loop {
        match pc {
            0x830EE548 => {
    //   block [0x830EE548..0x830EE5B8)
	// 830EE548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EE554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE558: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE55C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE560: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EE564: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE568: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE56C: 41820030  beq 0x830ee59c
	if ctx.cr[0].eq {
	pc = 0x830EE59C; continue 'dispatch;
	}
	// 830EE570: 83DF0084  lwz r30, 0x84(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE574: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830EE578: 38DF000C  addi r6, r31, 0xc
	ctx.r[6].s64 = ctx.r[31].s64 + 12;
	// 830EE57C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE580: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EE584: 4BFFFB55  bl 0x830ee0d8
	ctx.lr = 0x830EE588;
	sub_830EE0D8(ctx, base);
	// 830EE588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EE58C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE590: 48021E41  bl 0x831103d0
	ctx.lr = 0x830EE594;
	sub_831103D0(ctx, base);
	// 830EE594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EE598: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 830EE59C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EE5A0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830EE5A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE5A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE5AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EE5B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE5B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EE5B8 size=432
    let mut pc: u32 = 0x830EE5B8;
    'dispatch: loop {
        match pc {
            0x830EE5B8 => {
    //   block [0x830EE5B8..0x830EE768)
	// 830EE5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE5C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EE5C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE5C8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 830EE5CC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830EE5D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE5D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EE5DC: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE5E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE5E4: 41820160  beq 0x830ee744
	if ctx.cr[0].eq {
	pc = 0x830EE744; continue 'dispatch;
	}
	// 830EE5E8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE5EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE5F0: 419A014C  beq cr6, 0x830ee73c
	if ctx.cr[6].eq {
	pc = 0x830EE73C; continue 'dispatch;
	}
	// 830EE5F4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830EE5F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EE5FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE600: 4BFF9209  bl 0x830e7808
	ctx.lr = 0x830EE604;
	sub_830E7808(ctx, base);
	// 830EE604: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EE608: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EE60C: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE610: 4BFF91F9  bl 0x830e7808
	ctx.lr = 0x830EE614;
	sub_830E7808(ctx, base);
	// 830EE614: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EE618: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830EE61C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE620: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EE624: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE628: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 830EE62C: C1A908A4  lfs f13, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EE630: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 830EE634: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830EE638: FFE06890  fmr f31, f13
	ctx.f[31].f64 = ctx.f[13].f64;
	// 830EE63C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830EE640: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 830EE644: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EE648: 409A0020  bne cr6, 0x830ee668
	if !ctx.cr[6].eq {
	pc = 0x830EE668; continue 'dispatch;
	}
	// 830EE64C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE650: C0410054  lfs f2, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830EE654: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EE658: 4BFF33B1  bl 0x830e1a08
	ctx.lr = 0x830EE65C;
	sub_830E1A08(ctx, base);
	// 830EE65C: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE660: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EE664: 48000080  b 0x830ee6e4
	pc = 0x830EE6E4; continue 'dispatch;
	// 830EE668: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE66C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830EE670: 409A0030  bne cr6, 0x830ee6a0
	if !ctx.cr[6].eq {
	pc = 0x830EE6A0; continue 'dispatch;
	}
	// 830EE674: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EE678: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830EE67C: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EE680: ED6D5828  fsubs f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 830EE684: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EE688: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EE68C: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EE690: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EE694: EFEB0372  fmuls f31, f11, f13
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 830EE698: EFCA0372  fmuls f30, f10, f13
	ctx.f[30].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 830EE69C: 48000048  b 0x830ee6e4
	pc = 0x830EE6E4; continue 'dispatch;
	// 830EE6A0: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE6A4: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 830EE6A8: 409A0020  bne cr6, 0x830ee6c8
	if !ctx.cr[6].eq {
	pc = 0x830EE6C8; continue 'dispatch;
	}
	// 830EE6AC: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE6B0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EE6B4: ED806824  fdivs f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830EE6B8: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EE6BC: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE6C0: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 830EE6C4: 48000020  b 0x830ee6e4
	pc = 0x830EE6E4; continue 'dispatch;
	// 830EE6C8: 556B0738  rlwinm r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE6CC: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 830EE6D0: 409A0014  bne cr6, 0x830ee6e4
	if !ctx.cr[6].eq {
	pc = 0x830EE6E4; continue 'dispatch;
	}
	// 830EE6D4: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EE6D8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EE6DC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830EE6E0: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 830EE6E4: C17F0060  lfs f11, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EE6E8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EE6EC: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EE6F0: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EE6F4: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 830EE6F8: C19F0068  lfs f12, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EE6FC: C17F006C  lfs f11, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EE700: ED8CF82A  fadds f12, f12, f31
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 830EE704: C15F0064  lfs f10, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EE708: ED6BF02A  fadds f11, f11, f30
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 830EE70C: C13F0070  lfs f9, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830EE710: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE714: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830EE718: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830EE71C: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830EE720: D1410068  stfs f10, 0x68(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EE724: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830EE728: D1210078  stfs f9, 0x78(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830EE72C: 4BFF1415  bl 0x830dfb40
	ctx.lr = 0x830EE730;
	sub_830DFB40(ctx, base);
	// 830EE730: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EE734: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE738: 4BFF1369  bl 0x830dfaa0
	ctx.lr = 0x830EE73C;
	sub_830DFAA0(ctx, base);
	// 830EE73C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EE740: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 830EE744: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EE748: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830EE74C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE754: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830EE758: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830EE75C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EE760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EE768 size=420
    let mut pc: u32 = 0x830EE768;
    'dispatch: loop {
        match pc {
            0x830EE768 => {
    //   block [0x830EE768..0x830EE90C)
	// 830EE768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE76C: 480B99FD  bl 0x831a8168
	ctx.lr = 0x830EE770;
	sub_831A8130(ctx, base);
	// 830EE770: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE778: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830EE77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE780: 409A0010  bne cr6, 0x830ee790
	if !ctx.cr[6].eq {
	pc = 0x830EE790; continue 'dispatch;
	}
	// 830EE784: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE788: 4BFF7511  bl 0x830e5c98
	ctx.lr = 0x830EE78C;
	sub_830E5C98(ctx, base);
	// 830EE78C: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 830EE790: 83DF008C  lwz r30, 0x8c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830EE794: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EE798: 419A0168  beq cr6, 0x830ee900
	if ctx.cr[6].eq {
	pc = 0x830EE900; continue 'dispatch;
	}
	// 830EE79C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EE7A0: 80DF0090  lwz r6, 0x90(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830EE7A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EE7A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EE7AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EE7B0: 4BFF8B71  bl 0x830e7320
	ctx.lr = 0x830EE7B4;
	sub_830E7320(ctx, base);
	// 830EE7B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EE7B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE7BC: 4BFE740D  bl 0x830d5bc8
	ctx.lr = 0x830EE7C0;
	sub_830D5BC8(ctx, base);
	// 830EE7C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EE7C4: 41800140  blt 0x830ee904
	if ctx.cr[0].lt {
	pc = 0x830EE904; continue 'dispatch;
	}
	// 830EE7C8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE7CC: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EE7D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EE7D4: 419A000C  beq cr6, 0x830ee7e0
	if ctx.cr[6].eq {
	pc = 0x830EE7E0; continue 'dispatch;
	}
	// 830EE7D8: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 830EE7DC: 48000028  b 0x830ee804
	pc = 0x830EE804; continue 'dispatch;
	// 830EE7E0: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830EE7E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE7E8: 419A000C  beq cr6, 0x830ee7f4
	if ctx.cr[6].eq {
	pc = 0x830EE7F4; continue 'dispatch;
	}
	// 830EE7EC: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 830EE7F0: 48000014  b 0x830ee804
	pc = 0x830EE804; continue 'dispatch;
	// 830EE7F4: 216A0000  subfic r11, r10, 0
	ctx.xer.ca = ctx.r[10].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[10].s64;
	// 830EE7F8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830EE7FC: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EE800: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 830EE804: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EE808: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE80C: 409A0070  bne cr6, 0x830ee87c
	if !ctx.cr[6].eq {
	pc = 0x830EE87C; continue 'dispatch;
	}
	// 830EE810: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EE814: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EE818: 409A0064  bne cr6, 0x830ee87c
	if !ctx.cr[6].eq {
	pc = 0x830EE87C; continue 'dispatch;
	}
	// 830EE81C: 2F1D0003  cmpwi cr6, r29, 3
	ctx.cr[6].compare_i32(ctx.r[29].s32, 3, &mut ctx.xer);
	// 830EE820: 409A0010  bne cr6, 0x830ee830
	if !ctx.cr[6].eq {
	pc = 0x830EE830; continue 'dispatch;
	}
	// 830EE824: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EE828: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EE82C: 409A0050  bne cr6, 0x830ee87c
	if !ctx.cr[6].eq {
	pc = 0x830EE87C; continue 'dispatch;
	}
	// 830EE830: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 830EE834: 409A0024  bne cr6, 0x830ee858
	if !ctx.cr[6].eq {
	pc = 0x830EE858; continue 'dispatch;
	}
	// 830EE838: 48022109  bl 0x83110940
	ctx.lr = 0x830EE83C;
	sub_83110940(ctx, base);
	// 830EE83C: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EE840: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830EE844: 409A0038  bne cr6, 0x830ee87c
	if !ctx.cr[6].eq {
	pc = 0x830EE87C; continue 'dispatch;
	}
	// 830EE848: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EE84C: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE850: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EE854: 409A0028  bne cr6, 0x830ee87c
	if !ctx.cr[6].eq {
	pc = 0x830EE87C; continue 'dispatch;
	}
	// 830EE858: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 830EE85C: 409A00A4  bne cr6, 0x830ee900
	if !ctx.cr[6].eq {
	pc = 0x830EE900; continue 'dispatch;
	}
	// 830EE860: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE864: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EE868: 419A0014  beq cr6, 0x830ee87c
	if ctx.cr[6].eq {
	pc = 0x830EE87C; continue 'dispatch;
	}
	// 830EE86C: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830EE870: 480C35C1  bl 0x831b1e30
	ctx.lr = 0x830EE874;
	sub_831B1E30(ctx, base);
	// 830EE874: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EE878: 41820088  beq 0x830ee900
	if ctx.cr[0].eq {
	pc = 0x830EE900; continue 'dispatch;
	}
	// 830EE87C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 830EE880: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE884: 4BFF7AC5  bl 0x830e6348
	ctx.lr = 0x830EE888;
	sub_830E6348(ctx, base);
	// 830EE888: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 830EE88C: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 830EE890: 409A001C  bne cr6, 0x830ee8ac
	if !ctx.cr[6].eq {
	pc = 0x830EE8AC; continue 'dispatch;
	}
	// 830EE894: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EE898: 907F0088  stw r3, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 830EE89C: 480220A5  bl 0x83110940
	ctx.lr = 0x830EE8A0;
	sub_83110940(ctx, base);
	// 830EE8A0: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 830EE8A4: 939F0078  stw r28, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 830EE8A8: 48000050  b 0x830ee8f8
	pc = 0x830EE8F8; continue 'dispatch;
	// 830EE8AC: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 830EE8B0: 409A0030  bne cr6, 0x830ee8e0
	if !ctx.cr[6].eq {
	pc = 0x830EE8E0; continue 'dispatch;
	}
	// 830EE8B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE8B8: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830EE8BC: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE8C0: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830EE8C4: 4BFFF745  bl 0x830ee008
	ctx.lr = 0x830EE8C8;
	sub_830EE008(ctx, base);
	// 830EE8C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EE8CC: 41800038  blt 0x830ee904
	if ctx.cr[0].lt {
	pc = 0x830EE904; continue 'dispatch;
	}
	// 830EE8D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE8D4: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830EE8D8: 4BFE03B1  bl 0x830cec88
	ctx.lr = 0x830EE8DC;
	sub_830CEC88(ctx, base);
	// 830EE8DC: 4800001C  b 0x830ee8f8
	pc = 0x830EE8F8; continue 'dispatch;
	// 830EE8E0: 2F1D0003  cmpwi cr6, r29, 3
	ctx.cr[6].compare_i32(ctx.r[29].s32, 3, &mut ctx.xer);
	// 830EE8E4: 409A0014  bne cr6, 0x830ee8f8
	if !ctx.cr[6].eq {
	pc = 0x830EE8F8; continue 'dispatch;
	}
	// 830EE8E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE8EC: 80A10088  lwz r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EE8F0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE8F4: 4BFF7AF5  bl 0x830e63e8
	ctx.lr = 0x830EE8F8;
	sub_830E63E8(ctx, base);
	// 830EE8F8: 93BF007C  stw r29, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 830EE8FC: 9B9F000C  stb r28, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 830EE900: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EE904: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EE908: 480B98B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE910 size=112
    let mut pc: u32 = 0x830EE910;
    'dispatch: loop {
        match pc {
            0x830EE910 => {
    //   block [0x830EE910..0x830EE980)
	// 830EE910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EE91C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE928: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EE92C: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE930: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE934: 41820030  beq 0x830ee964
	if ctx.cr[0].eq {
	pc = 0x830EE964; continue 'dispatch;
	}
	// 830EE938: 3BDF0098  addi r30, r31, 0x98
	ctx.r[30].s64 = ctx.r[31].s64 + 152;
	// 830EE93C: 80BF0088  lwz r5, 0x88(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EE940: 38DF0010  addi r6, r31, 0x10
	ctx.r[6].s64 = ctx.r[31].s64 + 16;
	// 830EE944: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE948: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 830EE94C: 4BFFF78D  bl 0x830ee0d8
	ctx.lr = 0x830EE950;
	sub_830EE0D8(ctx, base);
	// 830EE950: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EE954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE958: 480298A1  bl 0x831181f8
	ctx.lr = 0x830EE95C;
	sub_831181F8(ctx, base);
	// 830EE95C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EE960: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 830EE964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EE968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EE96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE974: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EE978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE980 size=132
    let mut pc: u32 = 0x830EE980;
    'dispatch: loop {
        match pc {
            0x830EE980 => {
    //   block [0x830EE980..0x830EEA04)
	// 830EE980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EE98C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE994: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EE998: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 830EE99C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE9A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE9A4: 419A0044  beq cr6, 0x830ee9e8
	if ctx.cr[6].eq {
	pc = 0x830EE9E8; continue 'dispatch;
	}
	// 830EE9A8: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EE9AC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EE9B0: 409A0038  bne cr6, 0x830ee9e8
	if !ctx.cr[6].eq {
	pc = 0x830EE9E8; continue 'dispatch;
	}
	// 830EE9B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE9B8: 4BFF7991  bl 0x830e6348
	ctx.lr = 0x830EE9BC;
	sub_830E6348(ctx, base);
	// 830EE9BC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE9C4: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE9C8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830EE9CC: 4BFFF63D  bl 0x830ee008
	ctx.lr = 0x830EE9D0;
	sub_830EE008(ctx, base);
	// 830EE9D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EE9D4: 41800018  blt 0x830ee9ec
	if ctx.cr[0].lt {
	pc = 0x830EE9EC; continue 'dispatch;
	}
	// 830EE9D8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830EE9DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EE9E0: 917E007C  stw r11, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830EE9E4: 995E000C  stb r10, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 830EE9E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EE9EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EE9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE9F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EE9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EEA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EEA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EEA08 size=240
    let mut pc: u32 = 0x830EEA08;
    'dispatch: loop {
        match pc {
            0x830EEA08 => {
    //   block [0x830EEA08..0x830EEAF8)
	// 830EEA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EEA0C: 480B9759  bl 0x831a8164
	ctx.lr = 0x830EEA10;
	sub_831A8130(ctx, base);
	// 830EEA10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EEA14: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830EEA18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EEA1C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEA20: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830EEA24: 409A00C8  bne cr6, 0x830eeaec
	if !ctx.cr[6].eq {
	pc = 0x830EEAEC; continue 'dispatch;
	}
	// 830EEA28: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EEA2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEA30: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830EEA34: 409A00B8  bne cr6, 0x830eeaec
	if !ctx.cr[6].eq {
	pc = 0x830EEAEC; continue 'dispatch;
	}
	// 830EEA38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EEA3C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEA40: 4BFF1241  bl 0x830dfc80
	ctx.lr = 0x830EEA44;
	sub_830DFC80(ctx, base);
	// 830EEA44: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EEA48: 418000A4  blt 0x830eeaec
	if ctx.cr[0].lt {
	pc = 0x830EEAEC; continue 'dispatch;
	}
	// 830EEA4C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EEA50: 3BEB9510  addi r31, r11, -0x6af0
	ctx.r[31].s64 = ctx.r[11].s64 + -27376;
	// 830EEA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EEA58: 480BA671  bl 0x831a90c8
	ctx.lr = 0x830EEA5C;
	sub_831A90C8(ctx, base);
	// 830EEA5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EEA60: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EEA64: 480BA665  bl 0x831a90c8
	ctx.lr = 0x830EEA68;
	sub_831A90C8(ctx, base);
	// 830EEA68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EEA6C: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 830EEA70: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830EEA74: 409A0078  bne cr6, 0x830eeaec
	if !ctx.cr[6].eq {
	pc = 0x830EEAEC; continue 'dispatch;
	}
	// 830EEA78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EEA7C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EEA80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EEA84: 480C3925  bl 0x831b23a8
	ctx.lr = 0x830EEA88;
	sub_831B23A8(ctx, base);
	// 830EEA88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EEA8C: 40820060  bne 0x830eeaec
	if !ctx.cr[0].eq {
	pc = 0x830EEAEC; continue 'dispatch;
	}
	// 830EEA90: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EEA94: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EEA98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EEA9C: A16BFFFE  lhz r11, -2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 830EEAA0: 37EBFFD0  addic. r31, r11, -0x30
	ctx.xer.ca = (ctx.r[11].u32 > (!(-48 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -48;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830EEAA4: 41800048  blt 0x830eeaec
	if ctx.cr[0].lt {
	pc = 0x830EEAEC; continue 'dispatch;
	}
	// 830EEAA8: 2F1F0009  cmpwi cr6, r31, 9
	ctx.cr[6].compare_i32(ctx.r[31].s32, 9, &mut ctx.xer);
	// 830EEAAC: 41990040  bgt cr6, 0x830eeaec
	if ctx.cr[6].gt {
	pc = 0x830EEAEC; continue 'dispatch;
	}
	// 830EEAB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EEAB4: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EEAB8: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEABC: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEAC0: 4BFEAD69  bl 0x830d9828
	ctx.lr = 0x830EEAC4;
	sub_830D9828(ctx, base);
	// 830EEAC4: 889C000C  lbz r4, 0xc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEAC8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEACC: 4BFF4155  bl 0x830e2c20
	ctx.lr = 0x830EEAD0;
	sub_830E2C20(ctx, base);
	// 830EEAD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EEAD4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EEAD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EEADC: 4BFF8BA5  bl 0x830e7680
	ctx.lr = 0x830EEAE0;
	sub_830E7680(ctx, base);
	// 830EEAE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EEAE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EEAE8: 4BFE70E1  bl 0x830d5bc8
	ctx.lr = 0x830EEAEC;
	sub_830D5BC8(ctx, base);
	// 830EEAEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EEAF0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830EEAF4: 480B96C0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EEAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EEAF8 size=328
    let mut pc: u32 = 0x830EEAF8;
    'dispatch: loop {
        match pc {
            0x830EEAF8 => {
    //   block [0x830EEAF8..0x830EEC40)
	// 830EEAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EEAFC: 480B9671  bl 0x831a816c
	ctx.lr = 0x830EEB00;
	sub_831A8130(ctx, base);
	// 830EEB00: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EEB04: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830EEB08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EEB0C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830EEB10: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 830EEB14: 816BF37C  lwz r11, -0xc84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3204 as u32) ) } as u64;
	// 830EEB18: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 830EEB1C: 419A0040  beq cr6, 0x830eeb5c
	if ctx.cr[6].eq {
	pc = 0x830EEB5C; continue 'dispatch;
	}
	// 830EEB20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEB24: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830EEB28: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830EEB2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEB30: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 830EEB34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830EEB38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EEB3C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830EEB40: 4BFF1619  bl 0x830e0158
	ctx.lr = 0x830EEB44;
	sub_830E0158(ctx, base);
	// 830EEB44: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EEB48: 40800014  bge 0x830eeb5c
	if !ctx.cr[0].lt {
	pc = 0x830EEB5C; continue 'dispatch;
	}
	// 830EEB4C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEB50: 480C3A41  bl 0x831b2590
	ctx.lr = 0x830EEB54;
	sub_831B2590(ctx, base);
	// 830EEB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EEB58: 480000E0  b 0x830eec38
	pc = 0x830EEC38; continue 'dispatch;
	// 830EEB5C: 388007F1  li r4, 0x7f1
	ctx.r[4].s64 = 2033;
	// 830EEB60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EEB64: 4801348D  bl 0x83101ff0
	ctx.lr = 0x830EEB68;
	sub_83101FF0(ctx, base);
	// 830EEB68: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EEB6C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 830EEB70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EEB74: 419A0028  beq cr6, 0x830eeb9c
	if ctx.cr[6].eq {
	pc = 0x830EEB9C; continue 'dispatch;
	}
	// 830EEB78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEB7C: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830EEB80: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EEB84: 4182000C  beq 0x830eeb90
	if ctx.cr[0].eq {
	pc = 0x830EEB90; continue 'dispatch;
	}
	// 830EEB88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EEB8C: 4BFF8CED  bl 0x830e7878
	ctx.lr = 0x830EEB90;
	sub_830E7878(ctx, base);
	// 830EEB90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EEB94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEB98: 4BFE7031  bl 0x830d5bc8
	ctx.lr = 0x830EEB9C;
	sub_830D5BC8(ctx, base);
	// 830EEB9C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEBA0: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EEBA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830EEBA8: 388A9520  addi r4, r10, -0x6ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -27360;
	// 830EEBAC: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 830EEBB0: 481542CD  bl 0x83242e7c
	ctx.lr = 0x830EEBB4;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EEBB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EEBB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EEBBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEBC0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EEBC4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EEBC8: 4BFF1119  bl 0x830dfce0
	ctx.lr = 0x830EEBCC;
	sub_830DFCE0(ctx, base);
	// 830EEBCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEBD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EEBD4: 419A0058  beq cr6, 0x830eec2c
	if ctx.cr[6].eq {
	pc = 0x830EEC2C; continue 'dispatch;
	}
	// 830EEBD8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EEBDC: 4BFF8C9D  bl 0x830e7878
	ctx.lr = 0x830EEBE0;
	sub_830E7878(ctx, base);
	// 830EEBE0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EEBE4: 419A0030  beq cr6, 0x830eec14
	if ctx.cr[6].eq {
	pc = 0x830EEC14; continue 'dispatch;
	}
	// 830EEBE8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEBEC: 4BFF28C5  bl 0x830e14b0
	ctx.lr = 0x830EEBF0;
	sub_830E14B0(ctx, base);
	// 830EEBF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEBF4: 41820010  beq 0x830eec04
	if ctx.cr[0].eq {
	pc = 0x830EEC04; continue 'dispatch;
	}
	// 830EEBF8: 4BFF0309  bl 0x830def00
	ctx.lr = 0x830EEBFC;
	sub_830DEF00(ctx, base);
	// 830EEBFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EEC00: 48000008  b 0x830eec08
	pc = 0x830EEC08; continue 'dispatch;
	// 830EEC04: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 830EEC08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830EEC0C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEC10: 4BFF5051  bl 0x830e3c60
	ctx.lr = 0x830EEC14;
	sub_830E3C60(ctx, base);
	// 830EEC14: 388007F0  li r4, 0x7f0
	ctx.r[4].s64 = 2032;
	// 830EEC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EEC1C: 480133D5  bl 0x83101ff0
	ctx.lr = 0x830EEC20;
	sub_83101FF0(ctx, base);
	// 830EEC20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EEC24: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEC28: 4BFE6FA1  bl 0x830d5bc8
	ctx.lr = 0x830EEC2C;
	sub_830D5BC8(ctx, base);
	// 830EEC2C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEC30: 480C3961  bl 0x831b2590
	ctx.lr = 0x830EEC34;
	sub_831B2590(ctx, base);
	// 830EEC34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EEC38: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830EEC3C: 480B9580  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EEC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EEC40 size=276
    let mut pc: u32 = 0x830EEC40;
    'dispatch: loop {
        match pc {
            0x830EEC40 => {
    //   block [0x830EEC40..0x830EED54)
	// 830EEC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EEC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EEC48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EEC4C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EEC50: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830EEC54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EEC58: 816BF37C  lwz r11, -0xc84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3204 as u32) ) } as u64;
	// 830EEC5C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEC60: 2B050002  cmplwi cr6, r5, 2
	ctx.cr[6].compare_u32(ctx.r[5].u32, 2 as u32, &mut ctx.xer);
	// 830EEC64: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830EEC68: 40980014  bge cr6, 0x830eec7c
	if !ctx.cr[6].lt {
	pc = 0x830EEC7C; continue 'dispatch;
	}
	// 830EEC6C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EEC70: 480C3921  bl 0x831b2590
	ctx.lr = 0x830EEC74;
	sub_831B2590(ctx, base);
	// 830EEC74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EEC78: 480000C8  b 0x830eed40
	pc = 0x830EED40; continue 'dispatch;
	// 830EEC7C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEC80: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 830EEC84: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830EEC88: 4198002C  blt cr6, 0x830eecb4
	if ctx.cr[6].lt {
	pc = 0x830EECB4; continue 'dispatch;
	}
	// 830EEC8C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEC90: 552907FF  clrlwi. r9, r9, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EEC94: 4182FFD8  beq 0x830eec6c
	if ctx.cr[0].eq {
	pc = 0x830EEC6C; continue 'dispatch;
	}
	// 830EEC98: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830EEC9C: 409A0018  bne cr6, 0x830eecb4
	if !ctx.cr[6].eq {
	pc = 0x830EECB4; continue 'dispatch;
	}
	// 830EECA0: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EECA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EECA8: 388B9544  addi r4, r11, -0x6abc
	ctx.r[4].s64 = ctx.r[11].s64 + -27324;
	// 830EECAC: 481541D1  bl 0x83242e7c
	ctx.lr = 0x830EECB0;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EECB0: 4800001C  b 0x830eeccc
	pc = 0x830EECCC; continue 'dispatch;
	// 830EECB4: 3D208219  lis r9, -0x7de7
	ctx.r[9].s64 = -2112290816;
	// 830EECB8: 38CA0002  addi r6, r10, 2
	ctx.r[6].s64 = ctx.r[10].s64 + 2;
	// 830EECBC: 38899534  addi r4, r9, -0x6acc
	ctx.r[4].s64 = ctx.r[9].s64 + -27340;
	// 830EECC0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830EECC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EECC8: 481541B5  bl 0x83242e7c
	ctx.lr = 0x830EECCC;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EECCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EECD0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EECD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EECD8: 4BFF14E1  bl 0x830e01b8
	ctx.lr = 0x830EECDC;
	sub_830E01B8(ctx, base);
	// 830EECDC: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EECE0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 830EECE4: 38AB952C  addi r5, r11, -0x6ad4
	ctx.r[5].s64 = ctx.r[11].s64 + -27348;
	// 830EECE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EECEC: 480C343D  bl 0x831b2128
	ctx.lr = 0x830EECF0;
	sub_831B2128(ctx, base);
	// 830EECF0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EECF4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EECF8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EECFC: 4BFF14BD  bl 0x830e01b8
	ctx.lr = 0x830EED00;
	sub_830E01B8(ctx, base);
	// 830EED00: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EED04: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EED08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EED0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EED10: 409A0008  bne cr6, 0x830eed18
	if !ctx.cr[6].eq {
	pc = 0x830EED18; continue 'dispatch;
	}
	// 830EED14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EED18: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EED1C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830EED20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EED24: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EED28: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EED2C: 4BFFFDCD  bl 0x830eeaf8
	ctx.lr = 0x830EED30;
	sub_830EEAF8(ctx, base);
	// 830EED30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EED34: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EED38: 480C3859  bl 0x831b2590
	ctx.lr = 0x830EED3C;
	sub_831B2590(ctx, base);
	// 830EED3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EED40: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830EED44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EED48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EED4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EED50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EED58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EED58 size=264
    let mut pc: u32 = 0x830EED58;
    'dispatch: loop {
        match pc {
            0x830EED58 => {
    //   block [0x830EED58..0x830EEE60)
	// 830EED58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EED5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EED60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EED64: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EED68: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830EED6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EED70: 816BF37C  lwz r11, -0xc84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3204 as u32) ) } as u64;
	// 830EED74: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EED78: 2B050002  cmplwi cr6, r5, 2
	ctx.cr[6].compare_u32(ctx.r[5].u32, 2 as u32, &mut ctx.xer);
	// 830EED7C: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830EED80: 40980014  bge cr6, 0x830eed94
	if !ctx.cr[6].lt {
	pc = 0x830EED94; continue 'dispatch;
	}
	// 830EED84: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EED88: 480C3809  bl 0x831b2590
	ctx.lr = 0x830EED8C;
	sub_831B2590(ctx, base);
	// 830EED8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EED90: 480000BC  b 0x830eee4c
	pc = 0x830EEE4C; continue 'dispatch;
	// 830EED94: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EED98: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 830EED9C: 409A002C  bne cr6, 0x830eedc8
	if !ctx.cr[6].eq {
	pc = 0x830EEDC8; continue 'dispatch;
	}
	// 830EEDA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEDA4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EEDA8: 4182FFDC  beq 0x830eed84
	if ctx.cr[0].eq {
	pc = 0x830EED84; continue 'dispatch;
	}
	// 830EEDAC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 830EEDB0: 409A0018  bne cr6, 0x830eedc8
	if !ctx.cr[6].eq {
	pc = 0x830EEDC8; continue 'dispatch;
	}
	// 830EEDB4: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EEDB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EEDBC: 388B9550  addi r4, r11, -0x6ab0
	ctx.r[4].s64 = ctx.r[11].s64 + -27312;
	// 830EEDC0: 481540BD  bl 0x83242e7c
	ctx.lr = 0x830EEDC4;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EEDC4: 48000018  b 0x830eeddc
	pc = 0x830EEDDC; continue 'dispatch;
	// 830EEDC8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EEDCC: 38A60001  addi r5, r6, 1
	ctx.r[5].s64 = ctx.r[6].s64 + 1;
	// 830EEDD0: 388B9534  addi r4, r11, -0x6acc
	ctx.r[4].s64 = ctx.r[11].s64 + -27340;
	// 830EEDD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EEDD8: 481540A5  bl 0x83242e7c
	ctx.lr = 0x830EEDDC;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EEDDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EEDE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEDE4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EEDE8: 4BFF13D1  bl 0x830e01b8
	ctx.lr = 0x830EEDEC;
	sub_830E01B8(ctx, base);
	// 830EEDEC: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EEDF0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 830EEDF4: 38AB952C  addi r5, r11, -0x6ad4
	ctx.r[5].s64 = ctx.r[11].s64 + -27348;
	// 830EEDF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EEDFC: 480C332D  bl 0x831b2128
	ctx.lr = 0x830EEE00;
	sub_831B2128(ctx, base);
	// 830EEE00: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EEE04: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EEE08: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEE0C: 4BFF13AD  bl 0x830e01b8
	ctx.lr = 0x830EEE10;
	sub_830E01B8(ctx, base);
	// 830EEE10: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEE14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EEE18: 409A0008  bne cr6, 0x830eee20
	if !ctx.cr[6].eq {
	pc = 0x830EEE20; continue 'dispatch;
	}
	// 830EEE1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEE20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830EEE24: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EEE28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830EEE2C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EEE30: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EEE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EEE38: 4BFFFCC1  bl 0x830eeaf8
	ctx.lr = 0x830EEE3C;
	sub_830EEAF8(ctx, base);
	// 830EEE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EEE40: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EEE44: 480C374D  bl 0x831b2590
	ctx.lr = 0x830EEE48;
	sub_831B2590(ctx, base);
	// 830EEE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EEE4C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830EEE50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EEE54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EEE58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EEE5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EEE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EEE60 size=240
    let mut pc: u32 = 0x830EEE60;
    'dispatch: loop {
        match pc {
            0x830EEE60 => {
    //   block [0x830EEE60..0x830EEF50)
	// 830EEE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EEE64: 480B9309  bl 0x831a816c
	ctx.lr = 0x830EEE68;
	sub_831A8130(ctx, base);
	// 830EEE68: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EEE6C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 830EEE70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EEE74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EEE78: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830EEE7C: 814AF37C  lwz r10, -0xc84(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-3204 as u32) ) } as u64;
	// 830EEE80: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEE84: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EEE88: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 830EEE8C: 41980018  blt cr6, 0x830eeea4
	if ctx.cr[6].lt {
	pc = 0x830EEEA4; continue 'dispatch;
	}
	// 830EEE90: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EEE94: 480C36FD  bl 0x831b2590
	ctx.lr = 0x830EEE98;
	sub_831B2590(ctx, base);
	// 830EEE98: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830EEE9C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830EEEA0: 480000A8  b 0x830eef48
	pc = 0x830EEF48; continue 'dispatch;
	// 830EEEA4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEEA8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EEEAC: 419A0090  beq cr6, 0x830eef3c
	if ctx.cr[6].eq {
	pc = 0x830EEF3C; continue 'dispatch;
	}
	// 830EEEB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830EEEB4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EEEB8: 40990048  ble cr6, 0x830eef00
	if !ctx.cr[6].gt {
	pc = 0x830EEF00; continue 'dispatch;
	}
	// 830EEEBC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EEEC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EEEC4: 409A0014  bne cr6, 0x830eeed8
	if !ctx.cr[6].eq {
	pc = 0x830EEED8; continue 'dispatch;
	}
	// 830EEEC8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EEECC: 388B9570  addi r4, r11, -0x6a90
	ctx.r[4].s64 = ctx.r[11].s64 + -27280;
	// 830EEED0: 48153FAD  bl 0x83242e7c
	ctx.lr = 0x830EEED4;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EEED4: 48000018  b 0x830eeeec
	pc = 0x830EEEEC; continue 'dispatch;
	// 830EEED8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EEEDC: 38DE0001  addi r6, r30, 1
	ctx.r[6].s64 = ctx.r[30].s64 + 1;
	// 830EEEE0: 388B955C  addi r4, r11, -0x6aa4
	ctx.r[4].s64 = ctx.r[11].s64 + -27300;
	// 830EEEE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EEEE8: 48153F95  bl 0x83242e7c
	ctx.lr = 0x830EEEEC;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EEEEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EEEF0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEEF4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EEEF8: 4BFF12C1  bl 0x830e01b8
	ctx.lr = 0x830EEEFC;
	sub_830E01B8(ctx, base);
	// 830EEEFC: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EEF00: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830EEF04: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EEF08: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830EEF0C: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EEF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EEF14: 4BFFFBE5  bl 0x830eeaf8
	ctx.lr = 0x830EEF18;
	sub_830EEAF8(ctx, base);
	// 830EEF18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EEF1C: 419A0020  beq cr6, 0x830eef3c
	if ctx.cr[6].eq {
	pc = 0x830EEF3C; continue 'dispatch;
	}
	// 830EEF20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEF24: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830EEF28: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EEF2C: 41820010  beq 0x830eef3c
	if ctx.cr[0].eq {
	pc = 0x830EEF3C; continue 'dispatch;
	}
	// 830EEF30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EEF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EEF38: 4BFF8941  bl 0x830e7878
	ctx.lr = 0x830EEF3C;
	sub_830E7878(ctx, base);
	// 830EEF3C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EEF40: 480C3651  bl 0x831b2590
	ctx.lr = 0x830EEF44;
	sub_831B2590(ctx, base);
	// 830EEF44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EEF48: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EEF4C: 480B9270  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EEF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EEF50 size=176
    let mut pc: u32 = 0x830EEF50;
    'dispatch: loop {
        match pc {
            0x830EEF50 => {
    //   block [0x830EEF50..0x830EF000)
	// 830EEF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EEF54: 480B9215  bl 0x831a8168
	ctx.lr = 0x830EEF58;
	sub_831A8130(ctx, base);
	// 830EEF58: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EEF5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EEF60: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 830EEF64: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEF68: 816BF37C  lwz r11, -0xc84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3204 as u32) ) } as u64;
	// 830EEF6C: 7D4A50F8  nor r10, r10, r10
	ctx.r[10].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 830EEF70: 554ADFFF  rlwinm. r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EEF74: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830EEF78: 41820078  beq 0x830eeff0
	if ctx.cr[0].eq {
	pc = 0x830EEFF0; continue 'dispatch;
	}
	// 830EEF7C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEF80: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830EEF84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EEF88: 40990068  ble cr6, 0x830eeff0
	if !ctx.cr[6].gt {
	pc = 0x830EEFF0; continue 'dispatch;
	}
	// 830EEF8C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EEF90: 3B8B9520  addi r28, r11, -0x6ae0
	ctx.r[28].s64 = ctx.r[11].s64 + -27360;
	// 830EEF94: 3BFD0001  addi r31, r29, 1
	ctx.r[31].s64 = ctx.r[29].s64 + 1;
	// 830EEF98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830EEF9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EEFA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EEFA4: 48153ED9  bl 0x83242e7c
	ctx.lr = 0x830EEFA8;
	// extern call 0x83242E7C  crate::xboxkrnl::swprintf
	crate::xboxkrnl::swprintf(ctx, base);
	// 830EEFA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EEFAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EEFB0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EEFB4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EEFB8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EEFBC: 4BFF0D25  bl 0x830dfce0
	ctx.lr = 0x830EEFC0;
	sub_830DFCE0(ctx, base);
	// 830EEFC0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EEFC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EEFC8: 419A0018  beq cr6, 0x830eefe0
	if ctx.cr[6].eq {
	pc = 0x830EEFE0; continue 'dispatch;
	}
	// 830EEFCC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEFD0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EEFD4: 419A000C  beq cr6, 0x830eefe0
	if ctx.cr[6].eq {
	pc = 0x830EEFE0; continue 'dispatch;
	}
	// 830EEFD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EEFDC: 4BFF889D  bl 0x830e7878
	ctx.lr = 0x830EEFE0;
	sub_830E7878(ctx, base);
	// 830EEFE0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEFE4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 830EEFE8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EEFEC: 4198FFA8  blt cr6, 0x830eef94
	if ctx.cr[6].lt {
	pc = 0x830EEF94; continue 'dispatch;
	}
	// 830EEFF0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EEFF4: 480C359D  bl 0x831b2590
	ctx.lr = 0x830EEFF8;
	sub_831B2590(ctx, base);
	// 830EEFF8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EEFFC: 480B91BC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EF000 size=48
    let mut pc: u32 = 0x830EF000;
    'dispatch: loop {
        match pc {
            0x830EF000 => {
    //   block [0x830EF000..0x830EF030)
	// 830EF000: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF004: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 830EF008: 409A0028  bne cr6, 0x830ef030
	if !ctx.cr[6].eq {
		sub_830EF030(ctx, base);
		return;
	}
	// 830EF00C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF010: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EF014: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EF018: 41980020  blt cr6, 0x830ef038
	if ctx.cr[6].lt {
		sub_830EF030(ctx, base);
		return;
	}
	// 830EF01C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF020: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF024: 40820014  bne 0x830ef038
	if !ctx.cr[0].eq {
		sub_830EF030(ctx, base);
		return;
	}
	// 830EF028: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EF02C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EF030 size=60
    let mut pc: u32 = 0x830EF030;
    'dispatch: loop {
        match pc {
            0x830EF030 => {
    //   block [0x830EF030..0x830EF06C)
	// 830EF030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF034: 419AFFE8  beq cr6, 0x830ef01c
	if ctx.cr[6].eq {
		sub_830EF000(ctx, base);
		return;
	}
	// 830EF038: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF03C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EF040: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF044: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830EF048: 554AF7FF  rlwinm. r10, r10, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EF04C: 4182FFDC  beq 0x830ef028
	if ctx.cr[0].eq {
		sub_830EF000(ctx, base);
		return;
	}
	// 830EF050: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EF054: 4182000C  beq 0x830ef060
	if ctx.cr[0].eq {
	pc = 0x830EF060; continue 'dispatch;
	}
	// 830EF058: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF05C: 4182FFCC  beq 0x830ef028
	if ctx.cr[0].eq {
		sub_830EF000(ctx, base);
		return;
	}
	// 830EF060: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 830EF064: 409A0008  bne cr6, 0x830ef06c
	if !ctx.cr[6].eq {
		sub_830EF06C(ctx, base);
		return;
	}
	// 830EF068: 4BFFFBD8  b 0x830eec40
	sub_830EEC40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF06C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EF06C size=4
    let mut pc: u32 = 0x830EF06C;
    'dispatch: loop {
        match pc {
            0x830EF06C => {
    //   block [0x830EF06C..0x830EF070)
	// 830EF06C: 4BFFFCEC  b 0x830eed58
	sub_830EED58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF070 size=556
    let mut pc: u32 = 0x830EF070;
    'dispatch: loop {
        match pc {
            0x830EF070 => {
    //   block [0x830EF070..0x830EF29C)
	// 830EF070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF074: 480B90F5  bl 0x831a8168
	ctx.lr = 0x830EF078;
	sub_831A8130(ctx, base);
	// 830EF078: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF07C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EF080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF084: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF088: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830EF08C: 419A01A0  beq cr6, 0x830ef22c
	if ctx.cr[6].eq {
	pc = 0x830EF22C; continue 'dispatch;
	}
	// 830EF090: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 830EF094: 419A0160  beq cr6, 0x830ef1f4
	if ctx.cr[6].eq {
	pc = 0x830EF1F4; continue 'dispatch;
	}
	// 830EF098: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 830EF09C: 419A00F0  beq cr6, 0x830ef18c
	if ctx.cr[6].eq {
	pc = 0x830EF18C; continue 'dispatch;
	}
	// 830EF0A0: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 830EF0A4: 419A00DC  beq cr6, 0x830ef180
	if ctx.cr[6].eq {
	pc = 0x830EF180; continue 'dispatch;
	}
	// 830EF0A8: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830EF0AC: 409A00C8  bne cr6, 0x830ef174
	if !ctx.cr[6].eq {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF0B0: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF0B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EF0B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EF0BC: 4BFEFC25  bl 0x830dece0
	ctx.lr = 0x830EF0C0;
	sub_830DECE0(ctx, base);
	// 830EF0C0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF0C4: 7D4B50F8  nor r11, r10, r10
	ctx.r[11].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 830EF0C8: 556BE7FF  rlwinm. r11, r11, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF0CC: 41820070  beq 0x830ef13c
	if ctx.cr[0].eq {
	pc = 0x830EF13C; continue 'dispatch;
	}
	// 830EF0D0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830EF0D4: 419A0054  beq cr6, 0x830ef128
	if ctx.cr[6].eq {
	pc = 0x830EF128; continue 'dispatch;
	}
	// 830EF0D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF0DC: 2B0B5804  cmplwi cr6, r11, 0x5804
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22532 as u32, &mut ctx.xer);
	// 830EF0E0: 419A0048  beq cr6, 0x830ef128
	if ctx.cr[6].eq {
	pc = 0x830EF128; continue 'dispatch;
	}
	// 830EF0E4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830EF0E8: 419A0078  beq cr6, 0x830ef160
	if ctx.cr[6].eq {
	pc = 0x830EF160; continue 'dispatch;
	}
	// 830EF0EC: 2B0B5805  cmplwi cr6, r11, 0x5805
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22533 as u32, &mut ctx.xer);
	// 830EF0F0: 4800006C  b 0x830ef15c
	pc = 0x830EF15C; continue 'dispatch;
	// 830EF0F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF0F8: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF0FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF100: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830EF104: 554AF7FF  rlwinm. r10, r10, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EF108: 4182006C  beq 0x830ef174
	if ctx.cr[0].eq {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF10C: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EF110: 4182000C  beq 0x830ef11c
	if ctx.cr[0].eq {
	pc = 0x830EF11C; continue 'dispatch;
	}
	// 830EF114: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF118: 4182005C  beq 0x830ef174
	if ctx.cr[0].eq {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF11C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF120: 4BFFFC39  bl 0x830eed58
	ctx.lr = 0x830EF124;
	sub_830EED58(ctx, base);
	// 830EF124: 48000054  b 0x830ef178
	pc = 0x830EF178; continue 'dispatch;
	// 830EF128: 38BD0008  addi r5, r29, 8
	ctx.r[5].s64 = ctx.r[29].s64 + 8;
	// 830EF12C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EF130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF134: 4BFFFECD  bl 0x830ef000
	ctx.lr = 0x830EF138;
	sub_830EF000(ctx, base);
	// 830EF138: 48000040  b 0x830ef178
	pc = 0x830EF178; continue 'dispatch;
	// 830EF13C: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830EF140: 419AFFE8  beq cr6, 0x830ef128
	if ctx.cr[6].eq {
	pc = 0x830EF128; continue 'dispatch;
	}
	// 830EF144: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF148: 2B0B5807  cmplwi cr6, r11, 0x5807
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22535 as u32, &mut ctx.xer);
	// 830EF14C: 419AFFDC  beq cr6, 0x830ef128
	if ctx.cr[6].eq {
	pc = 0x830EF128; continue 'dispatch;
	}
	// 830EF150: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830EF154: 419A000C  beq cr6, 0x830ef160
	if ctx.cr[6].eq {
	pc = 0x830EF160; continue 'dispatch;
	}
	// 830EF158: 2B0B5806  cmplwi cr6, r11, 0x5806
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22534 as u32, &mut ctx.xer);
	// 830EF15C: 409A0018  bne cr6, 0x830ef174
	if !ctx.cr[6].eq {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF160: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF168: 409AFF8C  bne cr6, 0x830ef0f4
	if !ctx.cr[6].eq {
	pc = 0x830EF0F4; continue 'dispatch;
	}
	// 830EF16C: 554B07FF  clrlwi. r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF170: 4082FF84  bne 0x830ef0f4
	if !ctx.cr[0].eq {
	pc = 0x830EF0F4; continue 'dispatch;
	}
	// 830EF174: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EF178: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EF17C: 480B903C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 830EF180: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF184: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF188: 4BFFFFEC  b 0x830ef174
	pc = 0x830EF174; continue 'dispatch;
	// 830EF18C: 38800BB8  li r4, 0xbb8
	ctx.r[4].s64 = 3000;
	// 830EF190: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EF194: 48012E5D  bl 0x83101ff0
	ctx.lr = 0x830EF198;
	sub_83101FF0(ctx, base);
	// 830EF198: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EF19C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF1A0: 4BFE6A29  bl 0x830d5bc8
	ctx.lr = 0x830EF1A4;
	sub_830D5BC8(ctx, base);
	// 830EF1A4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EF1A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF1AC: 409A000C  bne cr6, 0x830ef1b8
	if !ctx.cr[6].eq {
	pc = 0x830EF1B8; continue 'dispatch;
	}
	// 830EF1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF1B4: 4BFFFD9D  bl 0x830eef50
	ctx.lr = 0x830EF1B8;
	sub_830EEF50(ctx, base);
	// 830EF1B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF1BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF1C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EF1C4: 4198FFB0  blt cr6, 0x830ef174
	if ctx.cr[6].lt {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF1C8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EF1CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF1D0: 419A0010  beq cr6, 0x830ef1e0
	if ctx.cr[6].eq {
	pc = 0x830EF1E0; continue 'dispatch;
	}
	// 830EF1D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EF1D8: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 830EF1DC: 40990008  ble cr6, 0x830ef1e4
	if !ctx.cr[6].gt {
	pc = 0x830EF1E4; continue 'dispatch;
	}
	// 830EF1E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EF1E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EF1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF1EC: 4BFFFC75  bl 0x830eee60
	ctx.lr = 0x830EF1F0;
	sub_830EEE60(ctx, base);
	// 830EF1F0: 4BFFFF84  b 0x830ef174
	pc = 0x830EF174; continue 'dispatch;
	// 830EF1F4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF1F8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF1FC: 4BFDFA15  bl 0x830cec10
	ctx.lr = 0x830EF200;
	sub_830CEC10(ctx, base);
	// 830EF200: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EF204: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF208: 4BFDFA09  bl 0x830cec10
	ctx.lr = 0x830EF20C;
	sub_830CEC10(ctx, base);
	// 830EF20C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830EF210: 409AFF64  bne cr6, 0x830ef174
	if !ctx.cr[6].eq {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF214: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF218: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EF21C: 4182FF58  beq 0x830ef174
	if ctx.cr[0].eq {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF220: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EF224: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EF228: 4BFFFF4C  b 0x830ef174
	pc = 0x830EF174; continue 'dispatch;
	// 830EF22C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF234: 419AFF40  beq cr6, 0x830ef174
	if ctx.cr[6].eq {
	pc = 0x830EF174; continue 'dispatch;
	}
	// 830EF238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF23C: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF240: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF244: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF248: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF24C: 4BFDF9C5  bl 0x830cec10
	ctx.lr = 0x830EF250;
	sub_830CEC10(ctx, base);
	// 830EF250: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EF254: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EF258: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830EF25C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EF260: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EF264: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830EF268: 4BFF7A21  bl 0x830e6c88
	ctx.lr = 0x830EF26C;
	sub_830E6C88(ctx, base);
	// 830EF26C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EF270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EF274: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EF278: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EF27C: 4BFF04DD  bl 0x830df758
	ctx.lr = 0x830EF280;
	sub_830DF758(ctx, base);
	// 830EF280: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830EF284: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EF288: 4BFE6AD1  bl 0x830d5d58
	ctx.lr = 0x830EF28C;
	sub_830D5D58(ctx, base);
	// 830EF28C: 889E0004  lbz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF290: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF294: 4BFF398D  bl 0x830e2c20
	ctx.lr = 0x830EF298;
	sub_830E2C20(ctx, base);
	// 830EF298: 4BFFFEE0  b 0x830ef178
	pc = 0x830EF178; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EF2A0 size=992
    let mut pc: u32 = 0x830EF2A0;
    'dispatch: loop {
        match pc {
            0x830EF2A0 => {
    //   block [0x830EF2A0..0x830EF680)
	// 830EF2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EF2A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EF2AC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF2B4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830EF2B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EF2BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF2C0: 4BFF8549  bl 0x830e7808
	ctx.lr = 0x830EF2C4;
	sub_830E7808(ctx, base);
	// 830EF2C4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 830EF2C8: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830EF2CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EF2D0: 48021149  bl 0x83110418
	ctx.lr = 0x830EF2D4;
	sub_83110418(ctx, base);
	// 830EF2D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EF2D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830EF2DC: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF2E0: 397F0024  addi r11, r31, 0x24
	ctx.r[11].s64 = ctx.r[31].s64 + 36;
	// 830EF2E4: C1810050  lfs f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EF2E8: 397F0044  addi r11, r31, 0x44
	ctx.r[11].s64 = ctx.r[31].s64 + 68;
	// 830EF2EC: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EF2F0: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 830EF2F4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF2F8: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF2FC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EF300: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EF304: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EF308: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830EF30C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830EF310: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830EF314: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830EF318: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 830EF31C: C9010050  lfd f8, 0x50(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830EF320: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF324: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830EF328: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830EF32C: C8E10060  lfd f7, 0x60(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830EF330: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830EF334: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EF338: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830EF33C: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830EF340: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 830EF344: C8C10068  lfd f6, 0x68(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830EF348: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830EF34C: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 830EF350: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 830EF354: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 830EF358: C8A10068  lfd f5, 0x68(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830EF35C: FCA02E9C  fcfid f5, f5
	ctx.f[5].f64 = (ctx.f[5].s64 as f64);
	// 830EF360: 397F00C4  addi r11, r31, 0xc4
	ctx.r[11].s64 = ctx.r[31].s64 + 196;
	// 830EF364: FCE03E9C  fcfid f7, f7
	ctx.f[7].f64 = (ctx.f[7].s64 as f64);
	// 830EF368: 397F0084  addi r11, r31, 0x84
	ctx.r[11].s64 = ctx.r[31].s64 + 132;
	// 830EF36C: FCC0369C  fcfid f6, f6
	ctx.f[6].f64 = (ctx.f[6].s64 as f64);
	// 830EF370: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 830EF374: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 830EF378: FCA02818  frsp f5, f5
	ctx.f[5].f64 = (ctx.f[5].f64 as f32) as f64;
	// 830EF37C: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830EF380: FCE03818  frsp f7, f7
	ctx.f[7].f64 = (ctx.f[7].f64 as f32) as f64;
	// 830EF384: D0FF0028  stfs f7, 0x28(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 830EF388: FCC03018  frsp f6, f6
	ctx.f[6].f64 = (ctx.f[6].f64 as f32) as f64;
	// 830EF38C: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830EF390: EC894024  fdivs f4, f9, f8
	ctx.f[4].f64 = ((ctx.f[9].f64 / ctx.f[8].f64) as f32) as f64;
	// 830EF394: ED2C4828  fsubs f9, f12, f9
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 830EF398: ED4A2824  fdivs f10, f10, f5
	ctx.f[10].f64 = ((ctx.f[10].f64 / ctx.f[5].f64) as f32) as f64;
	// 830EF39C: ECA72824  fdivs f5, f7, f5
	ctx.f[5].f64 = ((ctx.f[7].f64 / ctx.f[5].f64) as f32) as f64;
	// 830EF3A0: D0BF0030  stfs f5, 0x30(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830EF3A4: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830EF3A8: ED064024  fdivs f8, f6, f8
	ctx.f[8].f64 = ((ctx.f[6].f64 / ctx.f[8].f64) as f32) as f64;
	// 830EF3AC: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830EF3B0: EC6B3828  fsubs f3, f11, f7
	ctx.f[3].f64 = (((ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 830EF3B4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830EF3B8: EC8D2028  fsubs f4, f13, f4
	ctx.f[4].f64 = (((ctx.f[13].f64 - ctx.f[4].f64) as f32) as f64);
	// 830EF3BC: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830EF3C0: D0DF0044  stfs f6, 0x44(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830EF3C4: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 830EF3C8: D0FF0048  stfs f7, 0x48(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830EF3CC: D11F004C  stfs f8, 0x4c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830EF3D0: D0BF0050  stfs f5, 0x50(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830EF3D4: D0DF0054  stfs f6, 0x54(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830EF3D8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830EF3DC: D11F005C  stfs f8, 0x5c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830EF3E0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830EF3E4: D13F0064  stfs f9, 0x64(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830EF3E8: D0FF0068  stfs f7, 0x68(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EF3EC: D09F006C  stfs f4, 0x6c(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830EF3F0: D0BF0070  stfs f5, 0x70(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830EF3F4: D13F0074  stfs f9, 0x74(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830EF3F8: 397F00A4  addi r11, r31, 0xa4
	ctx.r[11].s64 = ctx.r[31].s64 + 164;
	// 830EF3FC: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830EF400: 397F00B4  addi r11, r31, 0xb4
	ctx.r[11].s64 = ctx.r[31].s64 + 180;
	// 830EF404: D09F007C  stfs f4, 0x7c(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830EF408: 397F00D4  addi r11, r31, 0xd4
	ctx.r[11].s64 = ctx.r[31].s64 + 212;
	// 830EF40C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830EF410: 397F00E4  addi r11, r31, 0xe4
	ctx.r[11].s64 = ctx.r[31].s64 + 228;
	// 830EF414: D19F0084  stfs f12, 0x84(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830EF418: 397F00F4  addi r11, r31, 0xf4
	ctx.r[11].s64 = ctx.r[31].s64 + 244;
	// 830EF41C: D0FF0088  stfs f7, 0x88(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830EF420: 397F0144  addi r11, r31, 0x144
	ctx.r[11].s64 = ctx.r[31].s64 + 324;
	// 830EF424: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830EF428: 397F0104  addi r11, r31, 0x104
	ctx.r[11].s64 = ctx.r[31].s64 + 260;
	// 830EF42C: D0BF0090  stfs f5, 0x90(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830EF430: 397F0114  addi r11, r31, 0x114
	ctx.r[11].s64 = ctx.r[31].s64 + 276;
	// 830EF434: D19F0094  stfs f12, 0x94(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830EF438: 397F0124  addi r11, r31, 0x124
	ctx.r[11].s64 = ctx.r[31].s64 + 292;
	// 830EF43C: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830EF440: 397F0134  addi r11, r31, 0x134
	ctx.r[11].s64 = ctx.r[31].s64 + 308;
	// 830EF444: D1BF009C  stfs f13, 0x9c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830EF448: 397F0154  addi r11, r31, 0x154
	ctx.r[11].s64 = ctx.r[31].s64 + 340;
	// 830EF44C: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830EF450: 397F01A4  addi r11, r31, 0x1a4
	ctx.r[11].s64 = ctx.r[31].s64 + 420;
	// 830EF454: 395F0164  addi r10, r31, 0x164
	ctx.r[10].s64 = ctx.r[31].s64 + 356;
	// 830EF458: 393F0184  addi r9, r31, 0x184
	ctx.r[9].s64 = ctx.r[31].s64 + 388;
	// 830EF45C: 397F01C4  addi r11, r31, 0x1c4
	ctx.r[11].s64 = ctx.r[31].s64 + 452;
	// 830EF460: C0FF0084  lfs f7, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF464: D0FF00A4  stfs f7, 0xa4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830EF468: C0FF0088  lfs f7, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF46C: D0FF00A8  stfs f7, 0xa8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830EF470: C0FF008C  lfs f7, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF474: D0FF00AC  stfs f7, 0xac(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830EF478: C0FF0090  lfs f7, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF47C: D0FF00B0  stfs f7, 0xb0(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830EF480: D19F00B4  stfs f12, 0xb4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830EF484: D07F00B8  stfs f3, 0xb8(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830EF488: D1BF00BC  stfs f13, 0xbc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830EF48C: D15F00C0  stfs f10, 0xc0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830EF490: C0FF0064  lfs f7, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF494: D0FF00C4  stfs f7, 0xc4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830EF498: C0FF0068  lfs f7, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF49C: D0FF00C8  stfs f7, 0xc8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830EF4A0: C0FF006C  lfs f7, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4A4: D0FF00CC  stfs f7, 0xcc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830EF4A8: C0FF0070  lfs f7, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4AC: D0FF00D0  stfs f7, 0xd0(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830EF4B0: D13F00D4  stfs f9, 0xd4(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 830EF4B4: D07F00D8  stfs f3, 0xd8(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 830EF4B8: D09F00DC  stfs f4, 0xdc(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 830EF4BC: D15F00E0  stfs f10, 0xe0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 830EF4C0: C0FF00C4  lfs f7, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4C4: D0FF00E4  stfs f7, 0xe4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 830EF4C8: C0FF00C8  lfs f7, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4CC: D0FF00E8  stfs f7, 0xe8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 830EF4D0: C0FF00CC  lfs f7, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4D4: D0FF00EC  stfs f7, 0xec(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 830EF4D8: C0FF00D0  lfs f7, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4DC: D0FF00F0  stfs f7, 0xf0(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 830EF4E0: C0FF00C4  lfs f7, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4E4: D0FF00F4  stfs f7, 0xf4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 830EF4E8: C0FF00C8  lfs f7, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4EC: D0FF00F8  stfs f7, 0xf8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 830EF4F0: C0FF00CC  lfs f7, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4F4: D0FF00FC  stfs f7, 0xfc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 830EF4F8: C0FF00D0  lfs f7, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF4FC: D0FF0100  stfs f7, 0x100(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 830EF500: C0FF0044  lfs f7, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF504: D0FF0104  stfs f7, 0x104(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 830EF508: C0FF0048  lfs f7, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF50C: D0FF0108  stfs f7, 0x108(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 830EF510: C0FF004C  lfs f7, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF514: D0FF010C  stfs f7, 0x10c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 830EF518: C0FF0050  lfs f7, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF51C: D0FF0110  stfs f7, 0x110(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 830EF520: C0FF0044  lfs f7, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF524: D0FF0114  stfs f7, 0x114(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 830EF528: C0FF0048  lfs f7, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF52C: D0FF0118  stfs f7, 0x118(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 830EF530: C0FF004C  lfs f7, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF534: D0FF011C  stfs f7, 0x11c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 830EF538: C0FF0050  lfs f7, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF53C: D0FF0120  stfs f7, 0x120(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 830EF540: D0DF0124  stfs f6, 0x124(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 830EF544: D07F0128  stfs f3, 0x128(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 830EF548: D11F012C  stfs f8, 0x12c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 830EF54C: D15F0130  stfs f10, 0x130(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 830EF550: C0FF0024  lfs f7, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF554: D0FF0134  stfs f7, 0x134(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 830EF558: C0FF0028  lfs f7, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF55C: D0FF0138  stfs f7, 0x138(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 830EF560: C0FF002C  lfs f7, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF564: D0FF013C  stfs f7, 0x13c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 830EF568: C0FF0030  lfs f7, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EF56C: D0FF0140  stfs f7, 0x140(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 830EF570: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 830EF574: D07F0148  stfs f3, 0x148(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 830EF578: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 830EF57C: D15F0150  stfs f10, 0x150(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 830EF580: C15F0144  lfs f10, 0x144(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF584: D15F0154  stfs f10, 0x154(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 830EF588: C15F0148  lfs f10, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF58C: D15F0158  stfs f10, 0x158(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 830EF590: C15F014C  lfs f10, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF594: D15F015C  stfs f10, 0x15c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 830EF598: C15F0150  lfs f10, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF59C: D15F0160  stfs f10, 0x160(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 830EF5A0: C15F0144  lfs f10, 0x144(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF5A4: D15F0164  stfs f10, 0x164(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 830EF5A8: C15F0148  lfs f10, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF5AC: D15F0168  stfs f10, 0x168(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 830EF5B0: C15F014C  lfs f10, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF5B4: D15F016C  stfs f10, 0x16c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 830EF5B8: C15F0150  lfs f10, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF5BC: D15F0170  stfs f10, 0x170(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 830EF5C0: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 830EF5C4: D17F0178  stfs f11, 0x178(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 830EF5C8: D01F017C  stfs f0, 0x17c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 830EF5CC: D1BF0180  stfs f13, 0x180(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 830EF5D0: C01F0124  lfs f0, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF5D4: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 830EF5D8: C01F0128  lfs f0, 0x128(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF5DC: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 830EF5E0: C01F012C  lfs f0, 0x12c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF5E4: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 830EF5E8: C01F0130  lfs f0, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF5EC: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 830EF5F0: D0DF0194  stfs f6, 0x194(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 830EF5F4: D17F0198  stfs f11, 0x198(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 830EF5F8: D11F019C  stfs f8, 0x19c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 830EF5FC: D1BF01A0  stfs f13, 0x1a0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 830EF600: C01F00D4  lfs f0, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF604: D01F01A4  stfs f0, 0x1a4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 830EF608: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF60C: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 830EF610: C01F00DC  lfs f0, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF614: D01F01AC  stfs f0, 0x1ac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 830EF618: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF61C: D01F01B0  stfs f0, 0x1b0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 830EF620: D13F01B4  stfs f9, 0x1b4(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 830EF624: D17F01B8  stfs f11, 0x1b8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 830EF628: D1BF01C0  stfs f13, 0x1c0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 830EF62C: D09F01BC  stfs f4, 0x1bc(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 830EF630: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF634: D01F01C4  stfs f0, 0x1c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 830EF638: C01F00B8  lfs f0, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF63C: D01F01C8  stfs f0, 0x1c8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 830EF640: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF644: D01F01CC  stfs f0, 0x1cc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 830EF648: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF64C: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 830EF650: D19F01D4  stfs f12, 0x1d4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 830EF654: D17F01D8  stfs f11, 0x1d8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 830EF658: D1BF01DC  stfs f13, 0x1dc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 830EF65C: D1BF01E0  stfs f13, 0x1e0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 830EF660: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF664: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EF668: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EF66C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EF670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EF674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EF678: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EF67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF680 size=120
    let mut pc: u32 = 0x830EF680;
    'dispatch: loop {
        match pc {
            0x830EF680 => {
    //   block [0x830EF680..0x830EF6F8)
	// 830EF680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF684: 480B8AE9  bl 0x831a816c
	ctx.lr = 0x830EF688;
	sub_831A8130(ctx, base);
	// 830EF688: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF68C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF690: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830EF694: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 830EF698: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF69C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830EF6A0: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EF6A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EF6A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EF6AC: 419A000C  beq cr6, 0x830ef6b8
	if ctx.cr[6].eq {
	pc = 0x830EF6B8; continue 'dispatch;
	}
	// 830EF6B0: 48020DB1  bl 0x83110460
	ctx.lr = 0x830EF6B4;
	sub_83110460(ctx, base);
	// 830EF6B4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830EF6B8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830EF6BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EF6C0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF6C4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF6C8: 4BFFCBB9  bl 0x830ec280
	ctx.lr = 0x830EF6CC;
	sub_830EC280(ctx, base);
	// 830EF6CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EF6D0: 41800020  blt 0x830ef6f0
	if ctx.cr[0].lt {
	pc = 0x830EF6F0; continue 'dispatch;
	}
	// 830EF6D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EF6D8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EF6DC: 4802291D  bl 0x83111ff8
	ctx.lr = 0x830EF6E0;
	sub_83111FF8(ctx, base);
	// 830EF6E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF6E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EF6E8: 4BFEDDF1  bl 0x830dd4d8
	ctx.lr = 0x830EF6EC;
	sub_830DD4D8(ctx, base);
	// 830EF6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF6F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EF6F4: 480B8AC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF6F8 size=252
    let mut pc: u32 = 0x830EF6F8;
    'dispatch: loop {
        match pc {
            0x830EF6F8 => {
    //   block [0x830EF6F8..0x830EF7F4)
	// 830EF6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF6FC: 480B8A6D  bl 0x831a8168
	ctx.lr = 0x830EF700;
	sub_831A8130(ctx, base);
	// 830EF700: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF704: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EF708: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EF70C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF710: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 830EF714: 419A00A8  beq cr6, 0x830ef7bc
	if ctx.cr[6].eq {
	pc = 0x830EF7BC; continue 'dispatch;
	}
	// 830EF718: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 830EF71C: 419A0068  beq cr6, 0x830ef784
	if ctx.cr[6].eq {
	pc = 0x830EF784; continue 'dispatch;
	}
	// 830EF720: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 830EF724: 409A00C4  bne cr6, 0x830ef7e8
	if !ctx.cr[6].eq {
	pc = 0x830EF7E8; continue 'dispatch;
	}
	// 830EF728: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF72C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF730: 4BFDF4E1  bl 0x830cec10
	ctx.lr = 0x830EF734;
	sub_830CEC10(ctx, base);
	// 830EF734: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF738: 4BFDEE89  bl 0x830ce5c0
	ctx.lr = 0x830EF73C;
	sub_830CE5C0(ctx, base);
	// 830EF73C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EF740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF744: 4BFF5A35  bl 0x830e5178
	ctx.lr = 0x830EF748;
	sub_830E5178(ctx, base);
	// 830EF748: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830EF74C: 4182002C  beq 0x830ef778
	if ctx.cr[0].eq {
	pc = 0x830EF778; continue 'dispatch;
	}
	// 830EF750: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF754: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF758: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF75C: 419A000C  beq cr6, 0x830ef768
	if ctx.cr[6].eq {
	pc = 0x830EF768; continue 'dispatch;
	}
	// 830EF760: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EF764: 48000008  b 0x830ef76c
	pc = 0x830EF76C; continue 'dispatch;
	// 830EF768: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830EF76C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF774: 4BFDE8CD  bl 0x830ce040
	ctx.lr = 0x830EF778;
	sub_830CE040(ctx, base);
	// 830EF778: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF77C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF780: 48000068  b 0x830ef7e8
	pc = 0x830EF7E8; continue 'dispatch;
	// 830EF784: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830EF788: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EF78C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF790: 4BFEFFC9  bl 0x830df758
	ctx.lr = 0x830EF794;
	sub_830DF758(ctx, base);
	// 830EF794: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EF798: 41800050  blt 0x830ef7e8
	if ctx.cr[0].lt {
	pc = 0x830EF7E8; continue 'dispatch;
	}
	// 830EF79C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF7A0: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF7A4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EF7A8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF7AC: 38A40004  addi r5, r4, 4
	ctx.r[5].s64 = ctx.r[4].s64 + 4;
	// 830EF7B0: 4BFF8059  bl 0x830e7808
	ctx.lr = 0x830EF7B4;
	sub_830E7808(ctx, base);
	// 830EF7B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EF7B8: 48000030  b 0x830ef7e8
	pc = 0x830EF7E8; continue 'dispatch;
	// 830EF7BC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF7C0: 4BFDF451  bl 0x830cec10
	ctx.lr = 0x830EF7C4;
	sub_830CEC10(ctx, base);
	// 830EF7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF7C8: 4BFDEDF9  bl 0x830ce5c0
	ctx.lr = 0x830EF7CC;
	sub_830CE5C0(ctx, base);
	// 830EF7CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EF7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF7D4: 4BFF59A5  bl 0x830e5178
	ctx.lr = 0x830EF7D8;
	sub_830E5178(ctx, base);
	// 830EF7D8: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830EF7DC: 4182000C  beq 0x830ef7e8
	if ctx.cr[0].eq {
	pc = 0x830EF7E8; continue 'dispatch;
	}
	// 830EF7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF7E4: 4BFDE85D  bl 0x830ce040
	ctx.lr = 0x830EF7E8;
	sub_830CE040(ctx, base);
	// 830EF7E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EF7EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EF7F0: 480B89C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF7F8 size=212
    let mut pc: u32 = 0x830EF7F8;
    'dispatch: loop {
        match pc {
            0x830EF7F8 => {
    //   block [0x830EF7F8..0x830EF8CC)
	// 830EF7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF7FC: 480B8971  bl 0x831a816c
	ctx.lr = 0x830EF800;
	sub_831A8130(ctx, base);
	// 830EF800: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF804: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF80C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830EF810: 419A0068  beq cr6, 0x830ef878
	if ctx.cr[6].eq {
	pc = 0x830EF878; continue 'dispatch;
	}
	// 830EF814: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830EF818: 419A004C  beq cr6, 0x830ef864
	if ctx.cr[6].eq {
	pc = 0x830EF864; continue 'dispatch;
	}
	// 830EF81C: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 830EF820: 409A00A0  bne cr6, 0x830ef8c0
	if !ctx.cr[6].eq {
	pc = 0x830EF8C0; continue 'dispatch;
	}
	// 830EF824: 807F00A8  lwz r3, 0xa8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 830EF828: 3BDF00A8  addi r30, r31, 0xa8
	ctx.r[30].s64 = ctx.r[31].s64 + 168;
	// 830EF82C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830EF830: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EF834: 419A000C  beq cr6, 0x830ef840
	if ctx.cr[6].eq {
	pc = 0x830EF840; continue 'dispatch;
	}
	// 830EF838: 4BFEDCA1  bl 0x830dd4d8
	ctx.lr = 0x830EF83C;
	sub_830DD4D8(ctx, base);
	// 830EF83C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830EF840: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830EF844: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EF848: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF84C: 4BFEFF0D  bl 0x830df758
	ctx.lr = 0x830EF850;
	sub_830DF758(ctx, base);
	// 830EF850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EF854: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EF858: 80BF00F8  lwz r5, 0xf8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 830EF85C: 4BFFCA25  bl 0x830ec280
	ctx.lr = 0x830EF860;
	sub_830EC280(ctx, base);
	// 830EF860: 48000060  b 0x830ef8c0
	pc = 0x830EF8C0; continue 'dispatch;
	// 830EF864: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF868: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF86C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EF870: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EF874: 409A004C  bne cr6, 0x830ef8c0
	if !ctx.cr[6].eq {
	pc = 0x830EF8C0; continue 'dispatch;
	}
	// 830EF878: 807F00A8  lwz r3, 0xa8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 830EF87C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830EF880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EF884: 419A0018  beq cr6, 0x830ef89c
	if ctx.cr[6].eq {
	pc = 0x830EF89C; continue 'dispatch;
	}
	// 830EF888: 4BFEDC51  bl 0x830dd4d8
	ctx.lr = 0x830EF88C;
	sub_830DD4D8(ctx, base);
	// 830EF88C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF890: 93BF00A8  stw r29, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 830EF894: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830EF898: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EF89C: 807F00AC  lwz r3, 0xac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830EF8A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EF8A4: 419A001C  beq cr6, 0x830ef8c0
	if ctx.cr[6].eq {
	pc = 0x830EF8C0; continue 'dispatch;
	}
	// 830EF8A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EF8AC: 48020D65  bl 0x83110610
	ctx.lr = 0x830EF8B0;
	sub_83110610(ctx, base);
	// 830EF8B0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF8B4: 93BF00AC  stw r29, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 830EF8B8: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830EF8BC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EF8C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EF8C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EF8C8: 480B88F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EF8D0 size=56
    let mut pc: u32 = 0x830EF8D0;
    'dispatch: loop {
        match pc {
            0x830EF8D0 => {
    //   block [0x830EF8D0..0x830EF908)
	// 830EF8D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EF8D4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EF8D8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF8DC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EF8E0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EF8E4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830EF8E8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830EF8EC: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830EF8F0: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830EF8F4: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830EF8F8: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EF8FC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830EF900: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830EF904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EF908 size=116
    let mut pc: u32 = 0x830EF908;
    'dispatch: loop {
        match pc {
            0x830EF908 => {
    //   block [0x830EF908..0x830EF97C)
	// 830EF908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EF910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EF914: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF918: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EF91C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EF920: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830EF924: 4BFF00DD  bl 0x830dfa00
	ctx.lr = 0x830EF928;
	sub_830DFA00(ctx, base);
	// 830EF928: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EF92C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EF930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EF934: 480286FD  bl 0x83118030
	ctx.lr = 0x830EF938;
	sub_83118030(ctx, base);
	// 830EF938: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 830EF93C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EF940: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EF944: 480286ED  bl 0x83118030
	ctx.lr = 0x830EF948;
	sub_83118030(ctx, base);
	// 830EF948: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 830EF94C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EF950: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EF954: 480286DD  bl 0x83118030
	ctx.lr = 0x830EF958;
	sub_83118030(ctx, base);
	// 830EF958: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830EF95C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EF960: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EF964: 480286CD  bl 0x83118030
	ctx.lr = 0x830EF968;
	sub_83118030(ctx, base);
	// 830EF968: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830EF96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EF970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EF974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EF978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EF980 size=564
    let mut pc: u32 = 0x830EF980;
    'dispatch: loop {
        match pc {
            0x830EF980 => {
    //   block [0x830EF980..0x830EFBB4)
	// 830EF980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF984: 480B87DD  bl 0x831a8160
	ctx.lr = 0x830EF988;
	sub_831A8130(ctx, base);
	// 830EF988: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 830EF98C: 480B90DD  bl 0x831a8a68
	ctx.lr = 0x830EF990;
	sub_831A8A40(ctx, base);
	// 830EF990: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EF998: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830EF99C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EF9A0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830EF9A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF9A8: 4BFF00A9  bl 0x830dfa50
	ctx.lr = 0x830EF9AC;
	sub_830DFA50(ctx, base);
	// 830EF9AC: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830EF9B0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF9B4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EF9B8: 4BFF7E51  bl 0x830e7808
	ctx.lr = 0x830EF9BC;
	sub_830E7808(ctx, base);
	// 830EF9BC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830EF9C0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830EF9C4: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF9C8: C1810070  lfs f12, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EF9CC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF9D0: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF9D4: EFA0602A  fadds f29, f0, f12
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830EF9D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830EF9DC: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF9E0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830EF9E4: EF8D002A  fadds f28, f13, f0
	ctx.f[28].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830EF9E8: 83410078  lwz r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EF9EC: D3A10060  stfs f29, 0x60(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830EF9F0: 83DF001C  lwz r30, 0x1c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830EF9F4: D3810064  stfs f28, 0x64(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830EF9F8: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 830EF9FC: 4BFF80A5  bl 0x830e7aa0
	ctx.lr = 0x830EFA00;
	sub_830E7AA0(ctx, base);
	// 830EFA00: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830EFA04: 40980010  bge cr6, 0x830efa14
	if !ctx.cr[6].lt {
	pc = 0x830EFA14; continue 'dispatch;
	}
	// 830EFA08: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFA0C: 4BFF8095  bl 0x830e7aa0
	ctx.lr = 0x830EFA10;
	sub_830E7AA0(ctx, base);
	// 830EFA10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EFA14: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EFA18: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFA1C: 808BC0B8  lwz r4, -0x3f48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16200 as u32) ) } as u64;
	// 830EFA20: 4BFEF0C9  bl 0x830deae8
	ctx.lr = 0x830EFA24;
	sub_830DEAE8(ctx, base);
	// 830EFA24: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EFA28: 40820010  bne 0x830efa38
	if !ctx.cr[0].eq {
	pc = 0x830EFA38; continue 'dispatch;
	}
	// 830EFA2C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830EFA30: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 830EFA34: 48000160  b 0x830efb94
	pc = 0x830EFB94; continue 'dispatch;
	// 830EFA38: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830EFA3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFA40: 419A000C  beq cr6, 0x830efa4c
	if ctx.cr[6].eq {
	pc = 0x830EFA4C; continue 'dispatch;
	}
	// 830EFA44: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830EFA48: 409A0148  bne cr6, 0x830efb90
	if !ctx.cr[6].eq {
	pc = 0x830EFB90; continue 'dispatch;
	}
	// 830EFA4C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830EFA50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830EFA54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EFA58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EFA5C: 4BFF6405  bl 0x830e5e60
	ctx.lr = 0x830EFA60;
	sub_830E5E60(ctx, base);
	// 830EFA60: C3E10068  lfs f31, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EFA64: 480000B4  b 0x830efb18
	pc = 0x830EFB18; continue 'dispatch;
	// 830EFA68: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EFA6C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EFA70: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EFA74: 93410088  stw r26, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[26].u32 ) };
	// 830EFA78: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EFA7C: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EFA80: C3210088  lfs f25, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 830EFA84: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830EFA88: D3210098  stfs f25, 0x98(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830EFA8C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830EFA90: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EFA94: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830EFA98: C3010080  lfs f24, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 830EFA9C: EDB8D82A  fadds f13, f24, f27
	ctx.f[13].f64 = ((ctx.f[24].f64 + ctx.f[27].f64) as f32) as f64;
	// 830EFAA0: EF40F028  fsubs f26, f0, f30
	ctx.f[26].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 830EFAA4: D3010090  stfs f24, 0x90(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830EFAA8: D32100A4  stfs f25, 0xa4(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830EFAAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFAB0: D32100B0  stfs f25, 0xb0(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830EFAB4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFAB8: D30100B4  stfs f24, 0xb4(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830EFABC: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 830EFAC0: D32100BC  stfs f25, 0xbc(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830EFAC4: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830EFAC8: D1A100A8  stfs f13, 0xa8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830EFACC: D3410094  stfs f26, 0x94(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830EFAD0: D34100A0  stfs f26, 0xa0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830EFAD4: EC1AF02A  fadds f0, f26, f30
	ctx.f[0].f64 = ((ctx.f[26].f64 + ctx.f[30].f64) as f32) as f64;
	// 830EFAD8: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830EFADC: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830EFAE0: 4BFFFE29  bl 0x830ef908
	ctx.lr = 0x830EFAE4;
	sub_830EF908(ctx, base);
	// 830EFAE4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 830EFAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFAEC: 4BFF69AD  bl 0x830e6498
	ctx.lr = 0x830EFAF0;
	sub_830E6498(ctx, base);
	// 830EFAF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFAF4: 408200B0  bne 0x830efba4
	if !ctx.cr[0].eq {
	pc = 0x830EFBA4; continue 'dispatch;
	}
	// 830EFAF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EFAFC: 419A0080  beq cr6, 0x830efb7c
	if ctx.cr[6].eq {
	pc = 0x830EFB7C; continue 'dispatch;
	}
	// 830EFB00: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 830EFB04: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830EFB08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830EFB0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EFB10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EFB14: 4BFF634D  bl 0x830e5e60
	ctx.lr = 0x830EFB18;
	sub_830E5E60(ctx, base);
	// 830EFB18: C3610050  lfs f27, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 830EFB1C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830EFB20: C3C10054  lfs f30, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830EFB24: EC1BE82A  fadds f0, f27, f29
	ctx.f[0].f64 = ((ctx.f[27].f64 + ctx.f[29].f64) as f32) as f64;
	// 830EFB28: EDBEE02A  fadds f13, f30, f28
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[28].f64) as f32) as f64;
	// 830EFB2C: D3A10090  stfs f29, 0x90(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830EFB30: D3810094  stfs f28, 0x94(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830EFB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFB38: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830EFB3C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFB40: D38100A0  stfs f28, 0xa0(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830EFB44: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830EFB48: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830EFB4C: D3A100B4  stfs f29, 0xb4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830EFB50: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830EFB54: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830EFB58: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830EFB5C: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830EFB60: D1A100B8  stfs f13, 0xb8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830EFB64: 4BFFFDA5  bl 0x830ef908
	ctx.lr = 0x830EFB68;
	sub_830EF908(ctx, base);
	// 830EFB68: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 830EFB6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFB70: 4BFF6929  bl 0x830e6498
	ctx.lr = 0x830EFB74;
	sub_830E6498(ctx, base);
	// 830EFB74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFB78: 4182FEF0  beq 0x830efa68
	if ctx.cr[0].eq {
	pc = 0x830EFA68; continue 'dispatch;
	}
	// 830EFB7C: D3BC0000  stfs f29, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EFB80: D39C0004  stfs f28, 4(r28)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EFB84: D3FC0008  stfs f31, 8(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EFB88: D37B0000  stfs f27, 0(r27)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EFB8C: D3DB0004  stfs f30, 4(r27)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EFB90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EFB94: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 830EFB98: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 830EFB9C: 480B8F19  bl 0x831a8ab4
	ctx.lr = 0x830EFBA0;
	sub_831A8A8C(ctx, base);
	// 830EFBA0: 480B8610  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 830EFBA4: D31C0000  stfs f24, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EFBA8: D35C0004  stfs f26, 4(r28)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EFBAC: D33C0008  stfs f25, 8(r28)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EFBB0: 4BFFFFD8  b 0x830efb88
	pc = 0x830EFB88; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EFBB8 size=512
    let mut pc: u32 = 0x830EFBB8;
    'dispatch: loop {
        match pc {
            0x830EFBB8 => {
    //   block [0x830EFBB8..0x830EFDB8)
	// 830EFBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFBBC: 480B85A5  bl 0x831a8160
	ctx.lr = 0x830EFBC0;
	sub_831A8130(ctx, base);
	// 830EFBC0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFBC4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830EFBC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EFBCC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830EFBD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EFBD4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFBD8: 4BFF1981  bl 0x830e1558
	ctx.lr = 0x830EFBDC;
	sub_830E1558(ctx, base);
	// 830EFBDC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EFBE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EFBE4: 419A01C4  beq cr6, 0x830efda8
	if ctx.cr[6].eq {
	pc = 0x830EFDA8; continue 'dispatch;
	}
	// 830EFBE8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EFBEC: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 830EFBF0: 388B95B8  addi r4, r11, -0x6a48
	ctx.r[4].s64 = ctx.r[11].s64 + -27208;
	// 830EFBF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EFBF8: 4BFF00E9  bl 0x830dfce0
	ctx.lr = 0x830EFBFC;
	sub_830DFCE0(ctx, base);
	// 830EFBFC: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EFC00: 3B9E0008  addi r28, r30, 8
	ctx.r[28].s64 = ctx.r[30].s64 + 8;
	// 830EFC04: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EFC08: 388B959C  addi r4, r11, -0x6a64
	ctx.r[4].s64 = ctx.r[11].s64 + -27236;
	// 830EFC0C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EFC10: 4BFF00D1  bl 0x830dfce0
	ctx.lr = 0x830EFC14;
	sub_830DFCE0(ctx, base);
	// 830EFC14: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EFC18: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 830EFC1C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EFC20: 388B9580  addi r4, r11, -0x6a80
	ctx.r[4].s64 = ctx.r[11].s64 + -27264;
	// 830EFC24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EFC28: 4BFF00B9  bl 0x830dfce0
	ctx.lr = 0x830EFC2C;
	sub_830DFCE0(ctx, base);
	// 830EFC2C: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFC30: 3F608339  lis r27, -0x7cc7
	ctx.r[27].s64 = -2093416448;
	// 830EFC34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EFC38: 419A0018  beq cr6, 0x830efc50
	if ctx.cr[6].eq {
	pc = 0x830EFC50; continue 'dispatch;
	}
	// 830EFC3C: 809BC0C4  lwz r4, -0x3f3c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16188 as u32) ) } as u64;
	// 830EFC40: 4BFDEF31  bl 0x830ceb70
	ctx.lr = 0x830EFC44;
	sub_830CEB70(ctx, base);
	// 830EFC44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EFC48: 40820008  bne 0x830efc50
	if !ctx.cr[0].eq {
	pc = 0x830EFC50; continue 'dispatch;
	}
	// 830EFC4C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 830EFC50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EFC58: 419A0150  beq cr6, 0x830efda8
	if ctx.cr[6].eq {
	pc = 0x830EFDA8; continue 'dispatch;
	}
	// 830EFC5C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFC60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EFC64: 419A0144  beq cr6, 0x830efda8
	if ctx.cr[6].eq {
	pc = 0x830EFDA8; continue 'dispatch;
	}
	// 830EFC68: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EFC6C: 4BFEFDE5  bl 0x830dfa50
	ctx.lr = 0x830EFC70;
	sub_830DFA50(ctx, base);
	// 830EFC70: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830EFC74: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EFC78: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFC7C: 4BFF7B8D  bl 0x830e7808
	ctx.lr = 0x830EFC80;
	sub_830E7808(ctx, base);
	// 830EFC80: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EFC84: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFC88: 4BFEFDC9  bl 0x830dfa50
	ctx.lr = 0x830EFC8C;
	sub_830DFA50(ctx, base);
	// 830EFC8C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830EFC90: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EFC94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFC98: 4BFF7B71  bl 0x830e7808
	ctx.lr = 0x830EFC9C;
	sub_830E7808(ctx, base);
	// 830EFC9C: C1A10070  lfs f13, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EFCA0: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EFCA4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCA8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EFCAC: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EFCB0: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830EFCB4: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EFCB8: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830EFCBC: D1BE0018  stfs f13, 0x18(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830EFCC0: 4BFEFA51  bl 0x830df710
	ctx.lr = 0x830EFCC4;
	sub_830DF710(ctx, base);
	// 830EFCC4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCC8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCCC: 4BFEF9F5  bl 0x830df6c0
	ctx.lr = 0x830EFCD0;
	sub_830DF6C0(ctx, base);
	// 830EFCD0: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EFCD8: 419A0014  beq cr6, 0x830efcec
	if ctx.cr[6].eq {
	pc = 0x830EFCEC; continue 'dispatch;
	}
	// 830EFCDC: 4BFEFA35  bl 0x830df710
	ctx.lr = 0x830EFCE0;
	sub_830DF710(ctx, base);
	// 830EFCE0: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCE8: 4BFEF9D9  bl 0x830df6c0
	ctx.lr = 0x830EFCEC;
	sub_830DF6C0(ctx, base);
	// 830EFCEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCF0: 4BFEFA21  bl 0x830df710
	ctx.lr = 0x830EFCF4;
	sub_830DF710(ctx, base);
	// 830EFCF4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCF8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFCFC: 4BFEF9C5  bl 0x830df6c0
	ctx.lr = 0x830EFD00;
	sub_830DF6C0(ctx, base);
	// 830EFD00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EFD04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD08: 4BFF7B71  bl 0x830e7878
	ctx.lr = 0x830EFD0C;
	sub_830E7878(ctx, base);
	// 830EFD0C: 809BC0C4  lwz r4, -0x3f3c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16188 as u32) ) } as u64;
	// 830EFD10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD14: 4BFEEDD5  bl 0x830deae8
	ctx.lr = 0x830EFD18;
	sub_830DEAE8(ctx, base);
	// 830EFD18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EFD1C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD20: 4BFDEEF1  bl 0x830cec10
	ctx.lr = 0x830EFD24;
	sub_830CEC10(ctx, base);
	// 830EFD24: 907C0004  stw r3, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830EFD28: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EFD2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD30: 808BC0B8  lwz r4, -0x3f48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16200 as u32) ) } as u64;
	// 830EFD34: 4BFEEDB5  bl 0x830deae8
	ctx.lr = 0x830EFD38;
	sub_830DEAE8(ctx, base);
	// 830EFD38: 816300A0  lwz r11, 0xa0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 830EFD3C: 917E0028  stw r11, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830EFD40: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EFD44: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD48: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 830EFD4C: 4BFF7C15  bl 0x830e7960
	ctx.lr = 0x830EFD50;
	sub_830E7960(ctx, base);
	// 830EFD50: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EFD54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EFD58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EFD5C: 419A0044  beq cr6, 0x830efda0
	if ctx.cr[6].eq {
	pc = 0x830EFDA0; continue 'dispatch;
	}
	// 830EFD60: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EFD64: 4198003C  blt cr6, 0x830efda0
	if ctx.cr[6].lt {
	pc = 0x830EFDA0; continue 'dispatch;
	}
	// 830EFD68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EFD6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD70: 4BFF82F1  bl 0x830e8060
	ctx.lr = 0x830EFD74;
	sub_830E8060(ctx, base);
	// 830EFD74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EFD78: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD7C: 4BFF7EC5  bl 0x830e7c40
	ctx.lr = 0x830EFD80;
	sub_830E7C40(ctx, base);
	// 830EFD80: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830EFD84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EFD88: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD8C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 830EFD90: 4BFF8389  bl 0x830e8118
	ctx.lr = 0x830EFD94;
	sub_830E8118(ctx, base);
	// 830EFD94: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EFD98: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFD9C: 4BFF7EFD  bl 0x830e7c98
	ctx.lr = 0x830EFDA0;
	sub_830E7C98(ctx, base);
	// 830EFDA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EFDA4: 4800000C  b 0x830efdb0
	pc = 0x830EFDB0; continue 'dispatch;
	// 830EFDA8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830EFDAC: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830EFDB0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EFDB4: 480B83FC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EFDB8 size=12
    let mut pc: u32 = 0x830EFDB8;
    'dispatch: loop {
        match pc {
            0x830EFDB8 => {
    //   block [0x830EFDB8..0x830EFDC4)
	// 830EFDB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EFDBC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EFDC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830EFDC8 size=140
    let mut pc: u32 = 0x830EFDC8;
    'dispatch: loop {
        match pc {
            0x830EFDC8 => {
    //   block [0x830EFDC8..0x830EFE54)
	// 830EFDC8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830EFDCC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFDD0: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFDD4: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EFDD8: 419A007C  beq cr6, 0x830efe54
	if ctx.cr[6].eq {
		sub_830EFE54(ctx, base);
		return;
	}
	// 830EFDDC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EFDE0: 419A0074  beq cr6, 0x830efe54
	if ctx.cr[6].eq {
		sub_830EFE54(ctx, base);
		return;
	}
	// 830EFDE4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFDE8: 0CC90000  twi 6, r9, 0
	// 830EFDEC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFDF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EFDF4: 7CEB3A14  add r7, r11, r7
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830EFDF8: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFDFC: 7CA74BD6  divw r5, r7, r9
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 830EFE00: 54EB083E  rotlwi r11, r7, 1
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830EFE04: 7CA549D6  mullw r5, r5, r9
	ctx.r[5].s64 = (ctx.r[5].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830EFE08: 7CE53850  subf r7, r5, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 830EFE0C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830EFE10: 1D670014  mulli r11, r7, 0x14
	ctx.r[11].s64 = ctx.r[7].s64 * 20;
	// 830EFE14: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830EFE18: 7D292878  andc r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[5].u64;
	// 830EFE1C: 0CA9FFFF  twi 5, r9, -1
	// 830EFE20: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 830EFE24: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EFE28: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EFE2C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EFE30: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EFE34: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFE38: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830EFE3C: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EFE40: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830EFE44: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFE48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EFE4C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EFE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFE54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EFE54 size=12
    let mut pc: u32 = 0x830EFE54;
    'dispatch: loop {
        match pc {
            0x830EFE54 => {
    //   block [0x830EFE54..0x830EFE60)
	// 830EFE54: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830EFE58: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 830EFE5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830EFE60 size=128
    let mut pc: u32 = 0x830EFE60;
    'dispatch: loop {
        match pc {
            0x830EFE60 => {
    //   block [0x830EFE60..0x830EFEE0)
	// 830EFE60: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830EFE64: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EFE68: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFE6C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EFE70: 419A0070  beq cr6, 0x830efee0
	if ctx.cr[6].eq {
		sub_830EFEE0(ctx, base);
		return;
	}
	// 830EFE74: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EFE78: 419A0068  beq cr6, 0x830efee0
	if ctx.cr[6].eq {
		sub_830EFEE0(ctx, base);
		return;
	}
	// 830EFE7C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFE80: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EFE84: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EFE88: 4080000C  bge 0x830efe94
	if !ctx.cr[0].lt {
	pc = 0x830EFE94; continue 'dispatch;
	}
	// 830EFE8C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EFE90: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EFE94: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFE98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EFE9C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFEA0: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 830EFEA4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFEA8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EFEAC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830EFEB0: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EFEB4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EFEB8: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EFEBC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EFEC0: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EFEC4: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830EFEC8: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EFECC: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830EFED0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFED4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EFED8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EFEDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EFEE0 size=12
    let mut pc: u32 = 0x830EFEE0;
    'dispatch: loop {
        match pc {
            0x830EFEE0 => {
    //   block [0x830EFEE0..0x830EFEEC)
	// 830EFEE0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830EFEE4: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 830EFEE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EFEF0 size=88
    let mut pc: u32 = 0x830EFEF0;
    'dispatch: loop {
        match pc {
            0x830EFEF0 => {
    //   block [0x830EFEF0..0x830EFF48)
	// 830EFEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFEF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EFEF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EFEFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EFF00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFF04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EFF08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EFF0C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFF10: 4BFED5C9  bl 0x830dd4d8
	ctx.lr = 0x830EFF14;
	sub_830DD4D8(ctx, base);
	// 830EFF14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EFF18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EFF1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EFF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFF24: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EFF28: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EFF2C: 4BFF695D  bl 0x830e6888
	ctx.lr = 0x830EFF30;
	sub_830E6888(ctx, base);
	// 830EFF30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EFF34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EFF38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EFF3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EFF40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EFF44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EFF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EFF48 size=324
    let mut pc: u32 = 0x830EFF48;
    'dispatch: loop {
        match pc {
            0x830EFF48 => {
    //   block [0x830EFF48..0x830F008C)
	// 830EFF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EFF4C: 480B8205  bl 0x831a8150
	ctx.lr = 0x830EFF50;
	sub_831A8130(ctx, base);
	// 830EFF50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EFF54: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830EFF58: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 830EFF5C: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EFF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EFF64: 419A011C  beq cr6, 0x830f0080
	if ctx.cr[6].eq {
	pc = 0x830F0080; continue 'dispatch;
	}
	// 830EFF68: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EFF6C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830EFF70: 815A00F0  lwz r10, 0xf0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(240 as u32) ) } as u64;
	// 830EFF74: 7F78DB78  mr r24, r27
	ctx.r[24].u64 = ctx.r[27].u64;
	// 830EFF78: 554B0420  rlwinm r11, r10, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830EFF7C: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 830EFF80: 2B0B8000  cmplwi cr6, r11, 0x8000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32768 as u32, &mut ctx.xer);
	// 830EFF84: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830EFF88: 419A0024  beq cr6, 0x830effac
	if ctx.cr[6].eq {
	pc = 0x830EFFAC; continue 'dispatch;
	}
	// 830EFF8C: 4BFDEC85  bl 0x830cec10
	ctx.lr = 0x830EFF90;
	sub_830CEC10(ctx, base);
	// 830EFF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EFF94: 4BFDE62D  bl 0x830ce5c0
	ctx.lr = 0x830EFF98;
	sub_830CE5C0(ctx, base);
	// 830EFF98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EFF9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EFFA0: 4BFF51D9  bl 0x830e5178
	ctx.lr = 0x830EFFA4;
	sub_830E5178(ctx, base);
	// 830EFFA4: 90760000  stw r3, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830EFFA8: 480000D8  b 0x830f0080
	pc = 0x830F0080; continue 'dispatch;
	// 830EFFAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EFFB0: 419A00CC  beq cr6, 0x830f007c
	if ctx.cr[6].eq {
	pc = 0x830F007C; continue 'dispatch;
	}
	// 830EFFB4: 3EE08339  lis r23, -0x7cc7
	ctx.r[23].s64 = -2093416448;
	// 830EFFB8: 4BFDEC59  bl 0x830cec10
	ctx.lr = 0x830EFFBC;
	sub_830CEC10(ctx, base);
	// 830EFFBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EFFC0: 4BFDE601  bl 0x830ce5c0
	ctx.lr = 0x830EFFC4;
	sub_830CE5C0(ctx, base);
	// 830EFFC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EFFC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EFFCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EFFD0: 4BFF51A9  bl 0x830e5178
	ctx.lr = 0x830EFFD4;
	sub_830E5178(ctx, base);
	// 830EFFD4: 8177C0E8  lwz r11, -0x3f18(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-16152 as u32) ) } as u64;
	// 830EFFD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EFFDC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EFFE0: 409A005C  bne cr6, 0x830f003c
	if !ctx.cr[6].eq {
	pc = 0x830F003C; continue 'dispatch;
	}
	// 830EFFE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EFFE8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EFFEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EFFF0: 409A004C  bne cr6, 0x830f003c
	if !ctx.cr[6].eq {
	pc = 0x830F003C; continue 'dispatch;
	}
	// 830EFFF4: 807F00A4  lwz r3, 0xa4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EFFF8: 3B9F00A4  addi r28, r31, 0xa4
	ctx.r[28].s64 = ctx.r[31].s64 + 164;
	// 830EFFFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F0000: 419A000C  beq cr6, 0x830f000c
	if ctx.cr[6].eq {
	pc = 0x830F000C; continue 'dispatch;
	}
	// 830F0004: 4BFED4D5  bl 0x830dd4d8
	ctx.lr = 0x830F0008;
	sub_830DD4D8(ctx, base);
	// 830F0008: 937C0000  stw r27, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830F000C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F0010: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F0014: 4BFEEAD5  bl 0x830deae8
	ctx.lr = 0x830F0018;
	sub_830DEAE8(ctx, base);
	// 830F0018: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 830F001C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F0020: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F0024: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0028: 4BFEF731  bl 0x830df758
	ctx.lr = 0x830F002C;
	sub_830DF758(ctx, base);
	// 830F002C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F0030: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F0034: 80BE00F8  lwz r5, 0xf8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 830F0038: 4BFFC249  bl 0x830ec280
	ctx.lr = 0x830F003C;
	sub_830EC280(ctx, base);
	// 830F003C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0040: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830F0044: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F0048: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F004C: 409A000C  bne cr6, 0x830f0058
	if !ctx.cr[6].eq {
	pc = 0x830F0058; continue 'dispatch;
	}
	// 830F0050: 7FF8FB78  mr r24, r31
	ctx.r[24].u64 = ctx.r[31].u64;
	// 830F0054: 48000008  b 0x830f005c
	pc = 0x830F005C; continue 'dispatch;
	// 830F0058: 93F90018  stw r31, 0x18(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 830F005C: 937F0018  stw r27, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[27].u32 ) };
	// 830F0060: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F0064: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F0068: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 830F006C: 4BFEF855  bl 0x830df8c0
	ctx.lr = 0x830F0070;
	sub_830DF8C0(ctx, base);
	// 830F0070: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F0074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F0078: 409AFF40  bne cr6, 0x830effb8
	if !ctx.cr[6].eq {
	pc = 0x830EFFB8; continue 'dispatch;
	}
	// 830F007C: 93160000  stw r24, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 830F0080: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F0084: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F0088: 480B8118  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0090 size=156
    let mut pc: u32 = 0x830F0090;
    'dispatch: loop {
        match pc {
            0x830F0090 => {
    //   block [0x830F0090..0x830F012C)
	// 830F0090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0094: 480B80D9  bl 0x831a816c
	ctx.lr = 0x830F0098;
	sub_831A8130(ctx, base);
	// 830F0098: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F009C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F00A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F00A4: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830F00A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F00AC: 409A0010  bne cr6, 0x830f00bc
	if !ctx.cr[6].eq {
	pc = 0x830F00BC; continue 'dispatch;
	}
	// 830F00B0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F00B4: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 830F00B8: 4800006C  b 0x830f0124
	pc = 0x830F0124; continue 'dispatch;
	// 830F00BC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F00C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F00C4: 409A000C  bne cr6, 0x830f00d0
	if !ctx.cr[6].eq {
	pc = 0x830F00D0; continue 'dispatch;
	}
	// 830F00C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F00CC: 48000058  b 0x830f0124
	pc = 0x830F0124; continue 'dispatch;
	// 830F00D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F00D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F00D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F00DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F00E0: 4BFFFE69  bl 0x830eff48
	ctx.lr = 0x830F00E4;
	sub_830EFF48(ctx, base);
	// 830F00E4: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F00E8: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F00EC: 556A0420  rlwinm r10, r11, 0, 0x10, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F00F0: 2B0A8000  cmplwi cr6, r10, 0x8000
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32768 as u32, &mut ctx.xer);
	// 830F00F4: 409A0018  bne cr6, 0x830f010c
	if !ctx.cr[6].eq {
	pc = 0x830F010C; continue 'dispatch;
	}
	// 830F00F8: 556B045E  rlwinm r11, r11, 0, 0x11, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F00FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F0100: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F0104: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0108: 480279B9  bl 0x83117ac0
	ctx.lr = 0x830F010C;
	sub_83117AC0(ctx, base);
	// 830F010C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F0110: 419A0014  beq cr6, 0x830f0124
	if ctx.cr[6].eq {
	pc = 0x830F0124; continue 'dispatch;
	}
	// 830F0114: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F0118: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830F011C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0120: 48025C81  bl 0x83115da0
	ctx.lr = 0x830F0124;
	sub_83115DA0(ctx, base);
	// 830F0124: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F0128: 480B8094  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F0130 size=1660
    let mut pc: u32 = 0x830F0130;
    'dispatch: loop {
        match pc {
            0x830F0130 => {
    //   block [0x830F0130..0x830F07AC)
	// 830F0130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0134: 480B7FFD  bl 0x831a8130
	ctx.lr = 0x830F0138;
	sub_831A8130(ctx, base);
	// 830F0138: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 830F013C: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F07B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F07B0 size=72
    let mut pc: u32 = 0x830F07B0;
    'dispatch: loop {
        match pc {
            0x830F07B0 => {
    //   block [0x830F07B0..0x830F07F8)
	// 830F07B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F07B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F07B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F07BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F07C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F07C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F07C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F07CC: 4BFFF965  bl 0x830f0130
	ctx.lr = 0x830F07D0;
	sub_830F0130(ctx, base);
	// 830F07D0: 389F00A4  addi r4, r31, 0xa4
	ctx.r[4].s64 = ctx.r[31].s64 + 164;
	// 830F07D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F07D8: 4801FAE1  bl 0x831102b8
	ctx.lr = 0x830F07DC;
	sub_831102B8(ctx, base);
	// 830F07DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F07E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F07E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F07E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F07EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F07F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F07F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F07F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F07F8 size=200
    let mut pc: u32 = 0x830F07F8;
    'dispatch: loop {
        match pc {
            0x830F07F8 => {
    //   block [0x830F07F8..0x830F08C0)
	// 830F07F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F07FC: 480B7971  bl 0x831a816c
	ctx.lr = 0x830F0800;
	sub_831A8130(ctx, base);
	// 830F0800: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830F0804: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F080C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F0810: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F0814: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F0818: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F081C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F0820: 409A0008  bne cr6, 0x830f0828
	if !ctx.cr[6].eq {
	pc = 0x830F0828; continue 'dispatch;
	}
	// 830F0824: 4BFF841D  bl 0x830e8c40
	ctx.lr = 0x830F0828;
	sub_830E8C40(ctx, base);
	// 830F0828: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F082C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F0830: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F0834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F0838: 419A000C  beq cr6, 0x830f0844
	if ctx.cr[6].eq {
	pc = 0x830F0844; continue 'dispatch;
	}
	// 830F083C: 4BFF62A5  bl 0x830e6ae0
	ctx.lr = 0x830F0840;
	sub_830E6AE0(ctx, base);
	// 830F0840: 48000008  b 0x830f0848
	pc = 0x830F0848; continue 'dispatch;
	// 830F0844: 4BFF6265  bl 0x830e6aa8
	ctx.lr = 0x830F0848;
	sub_830E6AA8(ctx, base);
	// 830F0848: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 830F084C: 419A0064  beq cr6, 0x830f08b0
	if ctx.cr[6].eq {
	pc = 0x830F08B0; continue 'dispatch;
	}
	// 830F0850: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F0854: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F0858: 816700F0  lwz r11, 0xf0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F085C: 83E70020  lwz r31, 0x20(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F0860: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F0864: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F0868: 409A003C  bne cr6, 0x830f08a4
	if !ctx.cr[6].eq {
	pc = 0x830F08A4; continue 'dispatch;
	}
	// 830F086C: C0070014  lfs f0, 0x14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0870: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F0874: 409A0024  bne cr6, 0x830f0898
	if !ctx.cr[6].eq {
	pc = 0x830F0898; continue 'dispatch;
	}
	// 830F0878: 816700EC  lwz r11, 0xec(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F087C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F0880: 419A0024  beq cr6, 0x830f08a4
	if ctx.cr[6].eq {
	pc = 0x830F08A4; continue 'dispatch;
	}
	// 830F0884: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F0888: 409A0010  bne cr6, 0x830f0898
	if !ctx.cr[6].eq {
	pc = 0x830F0898; continue 'dispatch;
	}
	// 830F088C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0890: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F0894: 419A0010  beq cr6, 0x830f08a4
	if ctx.cr[6].eq {
	pc = 0x830F08A4; continue 'dispatch;
	}
	// 830F0898: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F089C: 80670000  lwz r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F08A0: 4BFE51D9  bl 0x830d5a78
	ctx.lr = 0x830F08A4;
	sub_830D5A78(ctx, base);
	// 830F08A4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830F08A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F08AC: 409AFFAC  bne cr6, 0x830f0858
	if !ctx.cr[6].eq {
	pc = 0x830F0858; continue 'dispatch;
	}
	// 830F08B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F08B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F08B8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830F08BC: 480B7900  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F08C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F08C0 size=100
    let mut pc: u32 = 0x830F08C0;
    'dispatch: loop {
        match pc {
            0x830F08C0 => {
    //   block [0x830F08C0..0x830F0924)
	// 830F08C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F08C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F08C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F08CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F08D0: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830F08D4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F08D8: 3BEBD900  addi r31, r11, -0x2700
	ctx.r[31].s64 = ctx.r[11].s64 + -9984;
	// 830F08DC: 816AD914  lwz r11, -0x26ec(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9964 as u32) ) } as u64;
	// 830F08E0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F08E4: 40820028  bne 0x830f090c
	if !ctx.cr[0].eq {
	pc = 0x830F090C; continue 'dispatch;
	}
	// 830F08E8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830F08EC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830F08F0: 916AD914  stw r11, -0x26ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-9964 as u32), ctx.r[11].u32 ) };
	// 830F08F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F08F8: C0299584  lfs f1, -0x6a7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F08FC: 48011BED  bl 0x831024e8
	ctx.lr = 0x830F0900;
	sub_831024E8(ctx, base);
	// 830F0900: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830F0904: 386B2490  addi r3, r11, 0x2490
	ctx.r[3].s64 = ctx.r[11].s64 + 9360;
	// 830F0908: 480B7BD1  bl 0x831a84d8
	ctx.lr = 0x830F090C;
	sub_831A84D8(ctx, base);
	// 830F090C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0910: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F0914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F091C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F0928 size=100
    let mut pc: u32 = 0x830F0928;
    'dispatch: loop {
        match pc {
            0x830F0928 => {
    //   block [0x830F0928..0x830F098C)
	// 830F0928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F092C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0938: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830F093C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F0940: 3BEBD918  addi r31, r11, -0x26e8
	ctx.r[31].s64 = ctx.r[11].s64 + -9960;
	// 830F0944: 816AD92C  lwz r11, -0x26d4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9940 as u32) ) } as u64;
	// 830F0948: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F094C: 40820028  bne 0x830f0974
	if !ctx.cr[0].eq {
	pc = 0x830F0974; continue 'dispatch;
	}
	// 830F0950: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830F0954: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830F0958: 916AD92C  stw r11, -0x26d4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-9940 as u32), ctx.r[11].u32 ) };
	// 830F095C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0960: C029093C  lfs f1, 0x93c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2364 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F0964: 48011B85  bl 0x831024e8
	ctx.lr = 0x830F0968;
	sub_831024E8(ctx, base);
	// 830F0968: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830F096C: 386B24A0  addi r3, r11, 0x24a0
	ctx.r[3].s64 = ctx.r[11].s64 + 9376;
	// 830F0970: 480B7B69  bl 0x831a84d8
	ctx.lr = 0x830F0974;
	sub_831A84D8(ctx, base);
	// 830F0974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0978: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F097C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830F0990 size=12
    let mut pc: u32 = 0x830F0990;
    'dispatch: loop {
        match pc {
            0x830F0990 => {
    //   block [0x830F0990..0x830F099C)
	// 830F0990: C0430010  lfs f2, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F0994: C023000C  lfs f1, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F0998: 4BFF8B30  b 0x830e94c8
	sub_830E94C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F09A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F09A0 size=716
    let mut pc: u32 = 0x830F09A0;
    'dispatch: loop {
        match pc {
            0x830F09A0 => {
    //   block [0x830F09A0..0x830F0C6C)
	// 830F09A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F09A4: 480B77B5  bl 0x831a8158
	ctx.lr = 0x830F09A8;
	sub_831A8130(ctx, base);
	// 830F09A8: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 830F09AC: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 830F09B0: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F09B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F09B8: 9081019C  stw r4, 0x19c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), ctx.r[4].u32 ) };
	// 830F09BC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830F09C0: 93E10194  stw r31, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[31].u32 ) };
	// 830F09C4: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830F09C8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830F09CC: 556B05AF  rlwinm. r11, r11, 0, 0x16, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F09D0: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F09D4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F09D8: 408201DC  bne 0x830f0bb4
	if !ctx.cr[0].eq {
	pc = 0x830F0BB4; continue 'dispatch;
	}
	// 830F09DC: 409A006C  bne cr6, 0x830f0a48
	if !ctx.cr[6].eq {
	pc = 0x830F0A48; continue 'dispatch;
	}
	// 830F09E0: 4BFF8E01  bl 0x830e97e0
	ctx.lr = 0x830F09E4;
	sub_830E97E0(ctx, base);
	// 830F09E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F09E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F09EC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F09F0: 4801FA29  bl 0x83110418
	ctx.lr = 0x830F09F4;
	sub_83110418(ctx, base);
	// 830F09F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F09F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F09FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830F0A00: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830F0A04: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F0A08: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830F0A0C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830F0A10: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830F0A14: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830F0A18: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F0A1C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F0A20: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F0A24: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F0A28: EC436824  fdivs f2, f3, f13
	ctx.f[2].f64 = ((ctx.f[3].f64 / ctx.f[13].f64) as f32) as f64;
	// 830F0A2C: EC230024  fdivs f1, f3, f0
	ctx.f[1].f64 = ((ctx.f[3].f64 / ctx.f[0].f64) as f32) as f64;
	// 830F0A30: 480272A9  bl 0x83117cd8
	ctx.lr = 0x830F0A34;
	sub_83117CD8(ctx, base);
	// 830F0A34: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830F0A38: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 830F0A3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F0A40: 480273A1  bl 0x83117de0
	ctx.lr = 0x830F0A44;
	sub_83117DE0(ctx, base);
	// 830F0A44: 48000148  b 0x830f0b8c
	pc = 0x830F0B8C; continue 'dispatch;
	// 830F0A48: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830F0A4C: 419A000C  beq cr6, 0x830f0a58
	if ctx.cr[6].eq {
	pc = 0x830F0A58; continue 'dispatch;
	}
	// 830F0A50: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F0A54: 409A0028  bne cr6, 0x830f0a7c
	if !ctx.cr[6].eq {
	pc = 0x830F0A7C; continue 'dispatch;
	}
	// 830F0A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0A5C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F0A60: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F0A64: 4BFF8E8D  bl 0x830e98f0
	ctx.lr = 0x830F0A68;
	sub_830E98F0(ctx, base);
	// 830F0A68: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 830F0A6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F0A70: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 830F0A74: 480B7A9D  bl 0x831a8510
	ctx.lr = 0x830F0A78;
	sub_831A8510(ctx, base);
	// 830F0A78: 48000114  b 0x830f0b8c
	pc = 0x830F0B8C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0C70 size=400
    let mut pc: u32 = 0x830F0C70;
    'dispatch: loop {
        match pc {
            0x830F0C70 => {
    //   block [0x830F0C70..0x830F0E00)
	// 830F0C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0C74: 480B74F5  bl 0x831a8168
	ctx.lr = 0x830F0C78;
	sub_831A8130(ctx, base);
	// 830F0C78: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 830F0C7C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830F0C80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0C84: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830F0C88: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830F0C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0C90: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830F0C94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F0C98: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 830F0C9C: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830F0CA0: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830F0CA4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F0CA8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F0CAC: 419A0010  beq cr6, 0x830f0cbc
	if ctx.cr[6].eq {
	pc = 0x830F0CBC; continue 'dispatch;
	}
	// 830F0CB0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0CB4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0CB8: 480000DC  b 0x830f0d94
	pc = 0x830F0D94; continue 'dispatch;
	// 830F0CBC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0CC0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F0CC4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830F0CC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F0CCC: 419A000C  beq cr6, 0x830f0cd8
	if ctx.cr[6].eq {
	pc = 0x830F0CD8; continue 'dispatch;
	}
	// 830F0CD0: 4801F791  bl 0x83110460
	ctx.lr = 0x830F0CD4;
	sub_83110460(ctx, base);
	// 830F0CD4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830F0CD8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F0CDC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F0CE0: 409A0050  bne cr6, 0x830f0d30
	if !ctx.cr[6].eq {
	pc = 0x830F0D30; continue 'dispatch;
	}
	// 830F0CE4: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F0CE8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830F0CEC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830F0CF0: 419A00A4  beq cr6, 0x830f0d94
	if ctx.cr[6].eq {
	pc = 0x830F0D94; continue 'dispatch;
	}
	// 830F0CF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F0CF8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F0CFC: 4BFFB585  bl 0x830ec280
	ctx.lr = 0x830F0D00;
	sub_830EC280(ctx, base);
	// 830F0D00: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F0D04: 418000EC  blt 0x830f0df0
	if ctx.cr[0].lt {
	pc = 0x830F0DF0; continue 'dispatch;
	}
	// 830F0D08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F0D0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F0D10: 480212E9  bl 0x83111ff8
	ctx.lr = 0x830F0D14;
	sub_83111FF8(ctx, base);
	// 830F0D14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F0D18: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F0D1C: 4BFEC7BD  bl 0x830dd4d8
	ctx.lr = 0x830F0D20;
	sub_830DD4D8(ctx, base);
	// 830F0D20: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F0D24: 40980070  bge cr6, 0x830f0d94
	if !ctx.cr[6].lt {
	pc = 0x830F0D94; continue 'dispatch;
	}
	// 830F0D28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F0D2C: 480000C4  b 0x830f0df0
	pc = 0x830F0DF0; continue 'dispatch;
	// 830F0D30: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830F0D34: 419A002C  beq cr6, 0x830f0d60
	if ctx.cr[6].eq {
	pc = 0x830F0D60; continue 'dispatch;
	}
	// 830F0D38: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F0D3C: 419A0024  beq cr6, 0x830f0d60
	if ctx.cr[6].eq {
	pc = 0x830F0D60; continue 'dispatch;
	}
	// 830F0D40: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F0D44: 409A0050  bne cr6, 0x830f0d94
	if !ctx.cr[6].eq {
	pc = 0x830F0D94; continue 'dispatch;
	}
	// 830F0D48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F0D4C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F0D50: 48021209  bl 0x83111f58
	ctx.lr = 0x830F0D54;
	sub_83111F58(ctx, base);
	// 830F0D54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F0D58: 4080003C  bge 0x830f0d94
	if !ctx.cr[0].lt {
	pc = 0x830F0D94; continue 'dispatch;
	}
	// 830F0D5C: 48000094  b 0x830f0df0
	pc = 0x830F0DF0; continue 'dispatch;
	// 830F0D60: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F0D64: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830F0D68: 4198002C  blt cr6, 0x830f0d94
	if ctx.cr[6].lt {
	pc = 0x830F0D94; continue 'dispatch;
	}
	// 830F0D6C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F0D70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F0D74: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F0D78: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F0D7C: 4182000C  beq 0x830f0d88
	if ctx.cr[0].eq {
	pc = 0x830F0D88; continue 'dispatch;
	}
	// 830F0D80: 48021491  bl 0x83112210
	ctx.lr = 0x830F0D84;
	sub_83112210(ctx, base);
	// 830F0D84: 48000008  b 0x830f0d8c
	pc = 0x830F0D8C; continue 'dispatch;
	// 830F0D88: 480213D1  bl 0x83112158
	ctx.lr = 0x830F0D8C;
	sub_83112158(ctx, base);
	// 830F0D8C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F0D90: 41980060  blt cr6, 0x830f0df0
	if ctx.cr[6].lt {
	pc = 0x830F0DF0; continue 'dispatch;
	}
	// 830F0D94: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830F0D98: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F0D9C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F0DA0: 419A0010  beq cr6, 0x830f0db0
	if ctx.cr[6].eq {
	pc = 0x830F0DB0; continue 'dispatch;
	}
	// 830F0DA4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0DA8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F0DAC: 48000040  b 0x830f0dec
	pc = 0x830F0DEC; continue 'dispatch;
	// 830F0DB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F0DB4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F0DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0DBC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F0DC0: 4BFFFBE1  bl 0x830f09a0
	ctx.lr = 0x830F0DC4;
	sub_830F09A0(ctx, base);
	// 830F0DC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0DC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F0DCC: 419A000C  beq cr6, 0x830f0dd8
	if ctx.cr[6].eq {
	pc = 0x830F0DD8; continue 'dispatch;
	}
	// 830F0DD0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F0DD4: 4801F5FD  bl 0x831103d0
	ctx.lr = 0x830F0DD8;
	sub_831103D0(ctx, base);
	// 830F0DD8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830F0DDC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F0DE0: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F0DE4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830F0DE8: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F0DEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F0DF0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830F0DF4: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830F0DF8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F0DFC: 480B73BC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F0E00 size=172
    let mut pc: u32 = 0x830F0E00;
    'dispatch: loop {
        match pc {
            0x830F0E00 => {
    //   block [0x830F0E00..0x830F0EAC)
	// 830F0E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0E04: 480B735D  bl 0x831a8160
	ctx.lr = 0x830F0E08;
	sub_831A8130(ctx, base);
	// 830F0E08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0E0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F0E10: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F0E14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F0E18: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0E1C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F0E20: 40990084  ble cr6, 0x830f0ea4
	if !ctx.cr[6].gt {
	pc = 0x830F0EA4; continue 'dispatch;
	}
	// 830F0E24: 3B7DFFFF  addi r27, r29, -1
	ctx.r[27].s64 = ctx.r[29].s64 + -1;
	// 830F0E28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F0E2C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F0E30: 7F1FD800  cmpw cr6, r31, r27
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830F0E34: 7D7E5214  add r11, r30, r10
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 830F0E38: 40980008  bge cr6, 0x830f0e40
	if !ctx.cr[6].lt {
	pc = 0x830F0E40; continue 'dispatch;
	}
	// 830F0E3C: 394B001C  addi r10, r11, 0x1c
	ctx.r[10].s64 = ctx.r[11].s64 + 28;
	// 830F0E40: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830F0E44: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F0E48: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F0E4C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830F0E50: C16B0014  lfs f11, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F0E54: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F0E58: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F0E5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830F0E60: C12A0004  lfs f9, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830F0E64: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830F0E68: C0EB0004  lfs f7, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F0E6C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0E70: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830F0E74: D0E10064  stfs f7, 0x64(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830F0E78: D1010060  stfs f8, 0x60(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830F0E7C: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830F0E80: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830F0E84: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830F0E88: D1410078  stfs f10, 0x78(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830F0E8C: D121007C  stfs f9, 0x7c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830F0E90: 4BFF7A51  bl 0x830e88e0
	ctx.lr = 0x830F0E94;
	sub_830E88E0(ctx, base);
	// 830F0E94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830F0E98: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 830F0E9C: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830F0EA0: 4198FF8C  blt cr6, 0x830f0e2c
	if ctx.cr[6].lt {
	pc = 0x830F0E2C; continue 'dispatch;
	}
	// 830F0EA4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830F0EA8: 480B7308  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F0EB0 size=184
    let mut pc: u32 = 0x830F0EB0;
    'dispatch: loop {
        match pc {
            0x830F0EB0 => {
    //   block [0x830F0EB0..0x830F0F68)
	// 830F0EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0EB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0EBC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0EC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F0EC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F0ECC: 409A0014  bne cr6, 0x830f0ee0
	if !ctx.cr[6].eq {
	pc = 0x830F0EE0; continue 'dispatch;
	}
	// 830F0ED0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F0ED4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0ED8: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830F0EDC: 48000074  b 0x830f0f50
	pc = 0x830F0F50; continue 'dispatch;
	// 830F0EE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F0EE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F0EE8: 3D208219  lis r9, -0x7de7
	ctx.r[9].s64 = -2112290816;
	// 830F0EEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830F0EF0: 39299484  addi r9, r9, -0x6b7c
	ctx.r[9].s64 = ctx.r[9].s64 + -27516;
	// 830F0EF4: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F0EF8: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 830F0EFC: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0F00: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 830F0F04: D1BF00D0  stfs f13, 0xd0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830F0F08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F0F0C: D1BF00CC  stfs f13, 0xcc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830F0F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0F14: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830F0F18: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830F0F1C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830F0F20: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830F0F24: 4BFFFEDD  bl 0x830f0e00
	ctx.lr = 0x830F0F28;
	sub_830F0E00(ctx, base);
	// 830F0F28: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F0F2C: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F0F30: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0F34: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830F0F38: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F0F3C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F0F40: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F0F44: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 830F0F48: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 830F0F4C: D1BF00C0  stfs f13, 0xc0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830F0F50: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830F0F54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F0F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0F60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F0F68 size=88
    let mut pc: u32 = 0x830F0F68;
    'dispatch: loop {
        match pc {
            0x830F0F68 => {
    //   block [0x830F0F68..0x830F0FC0)
	// 830F0F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F0F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0F78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F0F80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F0F84: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F0F88: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F0F8C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F0F90: 419A0008  beq cr6, 0x830f0f98
	if ctx.cr[6].eq {
	pc = 0x830F0F98; continue 'dispatch;
	}
	// 830F0F94: 4BFFFF1D  bl 0x830f0eb0
	ctx.lr = 0x830F0F98;
	sub_830F0EB0(ctx, base);
	// 830F0F98: C01F00BC  lfs f0, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0F9C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F0FA0: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F0FA4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F0FA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F0FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F0FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F0FB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F0FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F0FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F0FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F0FC0 size=96
    let mut pc: u32 = 0x830F0FC0;
    'dispatch: loop {
        match pc {
            0x830F0FC0 => {
    //   block [0x830F0FC0..0x830F1020)
	// 830F0FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F0FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F0FC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F0FCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F0FD0: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830F0FD4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F0FD8: 3BEBD930  addi r31, r11, -0x26d0
	ctx.r[31].s64 = ctx.r[11].s64 + -9936;
	// 830F0FDC: 816AD944  lwz r11, -0x26bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9916 as u32) ) } as u64;
	// 830F0FE0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F0FE4: 40820024  bne 0x830f1008
	if !ctx.cr[0].eq {
	pc = 0x830F1008; continue 'dispatch;
	}
	// 830F0FE8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830F0FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F0FF0: 916AD944  stw r11, -0x26bc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-9916 as u32), ctx.r[11].u32 ) };
	// 830F0FF4: 38805840  li r4, 0x5840
	ctx.r[4].s64 = 22592;
	// 830F0FF8: 480114E1  bl 0x831024d8
	ctx.lr = 0x830F0FFC;
	sub_831024D8(ctx, base);
	// 830F0FFC: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830F1000: 386B24B0  addi r3, r11, 0x24b0
	ctx.r[3].s64 = ctx.r[11].s64 + 9392;
	// 830F1004: 480B74D5  bl 0x831a84d8
	ctx.lr = 0x830F1008;
	sub_831A84D8(ctx, base);
	// 830F1008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F100C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F101C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1020 size=308
    let mut pc: u32 = 0x830F1020;
    'dispatch: loop {
        match pc {
            0x830F1020 => {
    //   block [0x830F1020..0x830F1154)
	// 830F1020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1024: 480B7145  bl 0x831a8168
	ctx.lr = 0x830F1028;
	sub_831A8130(ctx, base);
	// 830F1028: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F102C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830F1030: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F1034: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F1038: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F103C: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830F1040: 419A00CC  beq cr6, 0x830f110c
	if ctx.cr[6].eq {
	pc = 0x830F110C; continue 'dispatch;
	}
	// 830F1044: 2B0B07D0  cmplwi cr6, r11, 0x7d0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2000 as u32, &mut ctx.xer);
	// 830F1048: 419A00A8  beq cr6, 0x830f10f0
	if ctx.cr[6].eq {
	pc = 0x830F10F0; continue 'dispatch;
	}
	// 830F104C: 2B0B07D1  cmplwi cr6, r11, 0x7d1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2001 as u32, &mut ctx.xer);
	// 830F1050: 419A0020  beq cr6, 0x830f1070
	if ctx.cr[6].eq {
	pc = 0x830F1070; continue 'dispatch;
	}
	// 830F1054: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830F1058: 409A00F0  bne cr6, 0x830f1148
	if !ctx.cr[6].eq {
	pc = 0x830F1148; continue 'dispatch;
	}
	// 830F105C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1060: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1064: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F1068: 4BFF9CF9  bl 0x830ead60
	ctx.lr = 0x830F106C;
	sub_830EAD60(ctx, base);
	// 830F106C: 480000DC  b 0x830f1148
	pc = 0x830F1148; continue 'dispatch;
	// 830F1070: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1074: 839F0010  lwz r28, 0x10(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1078: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F107C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F1080: 4BFDDB91  bl 0x830cec10
	ctx.lr = 0x830F1084;
	sub_830CEC10(ctx, base);
	// 830F1084: 4BFF6CBD  bl 0x830e7d40
	ctx.lr = 0x830F1088;
	sub_830E7D40(ctx, base);
	// 830F1088: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F108C: 40820040  bne 0x830f10cc
	if !ctx.cr[0].eq {
	pc = 0x830F10CC; continue 'dispatch;
	}
	// 830F1090: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1094: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F1098: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F109C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F10A0: 41820010  beq 0x830f10b0
	if ctx.cr[0].eq {
	pc = 0x830F10B0; continue 'dispatch;
	}
	// 830F10A4: 409A00A4  bne cr6, 0x830f1148
	if !ctx.cr[6].eq {
	pc = 0x830F1148; continue 'dispatch;
	}
	// 830F10A8: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F10AC: 4800000C  b 0x830f10b8
	pc = 0x830F10B8; continue 'dispatch;
	// 830F10B0: 419A0098  beq cr6, 0x830f1148
	if ctx.cr[6].eq {
	pc = 0x830F1148; continue 'dispatch;
	}
	// 830F10B4: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F10B8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F10BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F10C0: 4BFDDB51  bl 0x830cec10
	ctx.lr = 0x830F10C4;
	sub_830CEC10(ctx, base);
	// 830F10C4: 4BFF6D0D  bl 0x830e7dd0
	ctx.lr = 0x830F10C8;
	sub_830E7DD0(ctx, base);
	// 830F10C8: 48000080  b 0x830f1148
	pc = 0x830F1148; continue 'dispatch;
	// 830F10CC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F10D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F10D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F10D8: 419A000C  beq cr6, 0x830f10e4
	if ctx.cr[6].eq {
	pc = 0x830F10E4; continue 'dispatch;
	}
	// 830F10DC: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F10E0: 48000008  b 0x830f10e8
	pc = 0x830F10E8; continue 'dispatch;
	// 830F10E4: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F10E8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F10EC: 4800005C  b 0x830f1148
	pc = 0x830F1148; continue 'dispatch;
	// 830F10F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F10F4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F10F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F10FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1100: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F1104: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F1108: 48000040  b 0x830f1148
	pc = 0x830F1148; continue 'dispatch;
	// 830F110C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1110: 886B000C  lbz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1114: 4BFEDA85  bl 0x830deb98
	ctx.lr = 0x830F1118;
	sub_830DEB98(ctx, base);
	// 830F1118: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F111C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F1120: 419A0010  beq cr6, 0x830f1130
	if ctx.cr[6].eq {
	pc = 0x830F1130; continue 'dispatch;
	}
	// 830F1124: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1128: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F112C: 4800001C  b 0x830f1148
	pc = 0x830F1148; continue 'dispatch;
	// 830F1130: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F1134: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1138: 4BFDDAD9  bl 0x830cec10
	ctx.lr = 0x830F113C;
	sub_830CEC10(ctx, base);
	// 830F113C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F1140: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F1144: 4BFF9995  bl 0x830eaad8
	ctx.lr = 0x830F1148;
	sub_830EAAD8(ctx, base);
	// 830F1148: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F114C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F1150: 480B7068  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1158 size=248
    let mut pc: u32 = 0x830F1158;
    'dispatch: loop {
        match pc {
            0x830F1158 => {
    //   block [0x830F1158..0x830F1250)
	// 830F1158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F115C: 480B7005  bl 0x831a8160
	ctx.lr = 0x830F1160;
	sub_831A8130(ctx, base);
	// 830F1160: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1164: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F1168: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830F116C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830F1170: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1174: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F1178: 40980010  bge cr6, 0x830f1188
	if !ctx.cr[6].lt {
	pc = 0x830F1188; continue 'dispatch;
	}
	// 830F117C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F1180: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830F1184: 480000B8  b 0x830f123c
	pc = 0x830F123C; continue 'dispatch;
	// 830F1188: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830F118C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 830F1190: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1194: 394A92C0  addi r10, r10, -0x6d40
	ctx.r[10].s64 = ctx.r[10].s64 + -27968;
	// 830F1198: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830F119C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830F11A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F11A4: 40810064  ble 0x830f1208
	if !ctx.cr[0].gt {
	pc = 0x830F1208; continue 'dispatch;
	}
	// 830F11A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F11AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F11B0: 48011309  bl 0x831024b8
	ctx.lr = 0x830F11B4;
	sub_831024B8(ctx, base);
	// 830F11B4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F11B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F11BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830F11C0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F11C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F11C8: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F11CC: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F11D0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F11D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F11D8: 4E800421  bctrl
	ctx.lr = 0x830F11DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F11DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F11E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F11E4: 41800060  blt 0x830f1244
	if ctx.cr[0].lt {
	pc = 0x830F1244; continue 'dispatch;
	}
	// 830F11E8: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830F11EC: 4801189D  bl 0x83102a88
	ctx.lr = 0x830F11F0;
	sub_83102A88(ctx, base);
	// 830F11F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F11F4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830F11F8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830F11FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1200: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1204: 4198FFA8  blt cr6, 0x830f11ac
	if ctx.cr[6].lt {
	pc = 0x830F11AC; continue 'dispatch;
	}
	// 830F1208: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F120C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830F1210: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F1214: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F1218: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F121C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1224: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F1228: 81490010  lwz r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F122C: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830F1230: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F1238: 4E800421  bctrl
	ctx.lr = 0x830F123C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F123C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F1240: 480B6F70  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 830F1244: 48011845  bl 0x83102a88
	ctx.lr = 0x830F1248;
	sub_83102A88(ctx, base);
	// 830F1248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F124C: 4BFFFFF0  b 0x830f123c
	pc = 0x830F123C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1250 size=528
    let mut pc: u32 = 0x830F1250;
    'dispatch: loop {
        match pc {
            0x830F1250 => {
    //   block [0x830F1250..0x830F1460)
	// 830F1250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1254: 480B6EFD  bl 0x831a8150
	ctx.lr = 0x830F1258;
	sub_831A8130(ctx, base);
	// 830F1258: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F125C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F1260: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 830F1264: 389B001C  addi r4, r27, 0x1c
	ctx.r[4].s64 = ctx.r[27].s64 + 28;
	// 830F1268: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830F126C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 830F1270: 4BFEE9C1  bl 0x830dfc30
	ctx.lr = 0x830F1274;
	sub_830DFC30(ctx, base);
	// 830F1274: 83380008  lwz r25, 8(r24)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F1278: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 830F127C: 419801D8  blt cr6, 0x830f1454
	if ctx.cr[6].lt {
	pc = 0x830F1454; continue 'dispatch;
	}
	// 830F1280: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 830F1284: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 830F1288: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 830F128C: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F1290: 1D79000C  mulli r11, r25, 0xc
	ctx.r[11].s64 = ctx.r[25].s64 * 12;
	// 830F1294: 40990008  ble cr6, 0x830f129c
	if !ctx.cr[6].gt {
	pc = 0x830F129C; continue 'dispatch;
	}
	// 830F1298: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830F129C: 3B80FFFB  li r28, -5
	ctx.r[28].s64 = -5;
	// 830F12A0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830F12A4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830F12A8: 40990008  ble cr6, 0x830f12b0
	if !ctx.cr[6].gt {
	pc = 0x830F12B0; continue 'dispatch;
	}
	// 830F12AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830F12B0: 4BFEC201  bl 0x830dd4b0
	ctx.lr = 0x830F12B4;
	sub_830DD4B0(ctx, base);
	// 830F12B4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830F12B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F12BC: 41820030  beq 0x830f12ec
	if ctx.cr[0].eq {
	pc = 0x830F12EC; continue 'dispatch;
	}
	// 830F12C0: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 830F12C4: 93230000  stw r25, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830F12C8: 37F9FFFF  addic. r31, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F12CC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830F12D0: 41800020  blt 0x830f12f0
	if ctx.cr[0].lt {
	pc = 0x830F12F0; continue 'dispatch;
	}
	// 830F12D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F12D8: 48011F91  bl 0x83103268
	ctx.lr = 0x830F12DC;
	sub_83103268(ctx, base);
	// 830F12DC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F12E0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830F12E4: 4080FFF0  bge 0x830f12d4
	if !ctx.cr[0].lt {
	pc = 0x830F12D4; continue 'dispatch;
	}
	// 830F12E8: 48000008  b 0x830f12f0
	pc = 0x830F12F0; continue 'dispatch;
	// 830F12EC: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 830F12F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F12F4: 93BB0010  stw r29, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 830F12F8: 419A0088  beq cr6, 0x830f1380
	if ctx.cr[6].eq {
	pc = 0x830F1380; continue 'dispatch;
	}
	// 830F12FC: 5723103A  slwi r3, r25, 2
	ctx.r[3].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830F1300: 4BFEC1B1  bl 0x830dd4b0
	ctx.lr = 0x830F1304;
	sub_830DD4B0(ctx, base);
	// 830F1304: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1308: 907B0014  stw r3, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 830F130C: 41820074  beq 0x830f1380
	if ctx.cr[0].eq {
	pc = 0x830F1380; continue 'dispatch;
	}
	// 830F1310: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 830F1314: 616BCCCC  ori r11, r11, 0xcccc
	ctx.r[11].u64 = ctx.r[11].u64 | 52428;
	// 830F1318: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F131C: 1D790014  mulli r11, r25, 0x14
	ctx.r[11].s64 = ctx.r[25].s64 * 20;
	// 830F1320: 40990008  ble cr6, 0x830f1328
	if !ctx.cr[6].gt {
	pc = 0x830F1328; continue 'dispatch;
	}
	// 830F1324: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830F1328: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830F132C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830F1330: 40990008  ble cr6, 0x830f1338
	if !ctx.cr[6].gt {
	pc = 0x830F1338; continue 'dispatch;
	}
	// 830F1334: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830F1338: 4BFEC179  bl 0x830dd4b0
	ctx.lr = 0x830F133C;
	sub_830DD4B0(ctx, base);
	// 830F133C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F1340: 41820030  beq 0x830f1370
	if ctx.cr[0].eq {
	pc = 0x830F1370; continue 'dispatch;
	}
	// 830F1344: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 830F1348: 93230000  stw r25, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830F134C: 37F9FFFF  addic. r31, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F1350: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830F1354: 41800020  blt 0x830f1374
	if ctx.cr[0].lt {
	pc = 0x830F1374; continue 'dispatch;
	}
	// 830F1358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F135C: 4801115D  bl 0x831024b8
	ctx.lr = 0x830F1360;
	sub_831024B8(ctx, base);
	// 830F1360: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F1364: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 830F1368: 4080FFF0  bge 0x830f1358
	if !ctx.cr[0].lt {
	pc = 0x830F1358; continue 'dispatch;
	}
	// 830F136C: 48000008  b 0x830f1374
	pc = 0x830F1374; continue 'dispatch;
	// 830F1370: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 830F1374: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F1378: 93BB0018  stw r29, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 830F137C: 409A0050  bne cr6, 0x830f13cc
	if !ctx.cr[6].eq {
	pc = 0x830F13CC; continue 'dispatch;
	}
	// 830F1380: 3FA08007  lis r29, -0x7ff9
	ctx.r[29].s64 = -2147024896;
	// 830F1384: 63BD000E  ori r29, r29, 0xe
	ctx.r[29].u64 = ctx.r[29].u64 | 14;
	// 830F1388: 807B0010  lwz r3, 0x10(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F138C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F1390: 419A000C  beq cr6, 0x830f139c
	if ctx.cr[6].eq {
	pc = 0x830F139C; continue 'dispatch;
	}
	// 830F1394: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830F1398: 4BFDEA51  bl 0x830cfde8
	ctx.lr = 0x830F139C;
	sub_830CFDE8(ctx, base);
	// 830F139C: 92FB0010  stw r23, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 830F13A0: 807B0014  lwz r3, 0x14(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F13A4: 4BFEC135  bl 0x830dd4d8
	ctx.lr = 0x830F13A8;
	sub_830DD4D8(ctx, base);
	// 830F13A8: 807B0018  lwz r3, 0x18(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F13AC: 92FB0014  stw r23, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[23].u32 ) };
	// 830F13B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F13B4: 419A000C  beq cr6, 0x830f13c0
	if ctx.cr[6].eq {
	pc = 0x830F13C0; continue 'dispatch;
	}
	// 830F13B8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830F13BC: 4BFDEAB5  bl 0x830cfe70
	ctx.lr = 0x830F13C0;
	sub_830CFE70(ctx, base);
	// 830F13C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F13C4: 92FB0018  stw r23, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[23].u32 ) };
	// 830F13C8: 48000090  b 0x830f1458
	pc = 0x830F1458; continue 'dispatch;
	// 830F13CC: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 830F13D0: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F13D4: 4099007C  ble cr6, 0x830f1450
	if !ctx.cr[6].gt {
	pc = 0x830F1450; continue 'dispatch;
	}
	// 830F13D8: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 830F13DC: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 830F13E0: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 830F13E4: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F13E8: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F13EC: 7C9F5214  add r4, r31, r10
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 830F13F0: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830F13F4: 48011EF5  bl 0x831032e8
	ctx.lr = 0x830F13F8;
	sub_831032E8(ctx, base);
	// 830F13F8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F13FC: 4180FF8C  blt 0x830f1388
	if ctx.cr[0].lt {
	pc = 0x830F1388; continue 'dispatch;
	}
	// 830F1400: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1404: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830F1408: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F140C: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F1410: 7D6AF12E  stwx r11, r10, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 830F1414: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1418: 813B0014  lwz r9, 0x14(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F141C: 815B0018  lwz r10, 0x18(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F1420: 7CCAE214  add r6, r10, r28
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 830F1424: 7C9F5A14  add r4, r31, r11
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830F1428: 7CA9F02E  lwzx r5, r9, r30
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F142C: 4BFFFD2D  bl 0x830f1158
	ctx.lr = 0x830F1430;
	sub_830F1158(ctx, base);
	// 830F1430: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F1434: 4180FF54  blt 0x830f1388
	if ctx.cr[0].lt {
	pc = 0x830F1388; continue 'dispatch;
	}
	// 830F1438: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830F143C: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 830F1440: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F1444: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830F1448: 7F1AC800  cmpw cr6, r26, r25
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830F144C: 4198FF98  blt cr6, 0x830f13e4
	if ctx.cr[6].lt {
	pc = 0x830F13E4; continue 'dispatch;
	}
	// 830F1450: 933B000C  stw r25, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 830F1454: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1458: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F145C: 480B6D44  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1460 size=360
    let mut pc: u32 = 0x830F1460;
    'dispatch: loop {
        match pc {
            0x830F1460 => {
    //   block [0x830F1460..0x830F15C8)
	// 830F1460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1464: 480B6CE1  bl 0x831a8144
	ctx.lr = 0x830F1468;
	sub_831A8130(ctx, base);
	// 830F1468: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F146C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F1470: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 830F1474: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830F1478: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 830F147C: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1480: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1484: 4099012C  ble cr6, 0x830f15b0
	if !ctx.cr[6].gt {
	pc = 0x830F15B0; continue 'dispatch;
	}
	// 830F1488: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F148C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830F1490: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830F1494: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830F1498: 3A8B92C0  addi r20, r11, -0x6d40
	ctx.r[20].s64 = ctx.r[11].s64 + -27968;
	// 830F149C: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F14A0: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F14A4: 7FF65A14  add r31, r22, r11
	ctx.r[31].u64 = ctx.r[22].u64 + ctx.r[11].u64;
	// 830F14A8: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F14AC: 7F385A14  add r25, r24, r11
	ctx.r[25].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 830F14B0: 7F4AB82E  lwzx r26, r10, r23
	ctx.r[26].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830F14B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F14B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F14BC: 419800EC  blt cr6, 0x830f15a8
	if ctx.cr[6].lt {
	pc = 0x830F15A8; continue 'dispatch;
	}
	// 830F14C0: 92610054  stw r19, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[19].u32 ) };
	// 830F14C4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 830F14C8: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830F14CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F14D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F14D4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F14D8: 40810064  ble 0x830f153c
	if !ctx.cr[0].gt {
	pc = 0x830F153C; continue 'dispatch;
	}
	// 830F14DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F14E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F14E4: 48010FD5  bl 0x831024b8
	ctx.lr = 0x830F14E8;
	sub_831024B8(ctx, base);
	// 830F14E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F14EC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F14F0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830F14F4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830F14F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F14FC: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1500: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F1504: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1508: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F150C: 4E800421  bctrl
	ctx.lr = 0x830F1510;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F1510: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F1514: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F1518: 41800084  blt 0x830f159c
	if ctx.cr[0].lt {
	pc = 0x830F159C; continue 'dispatch;
	}
	// 830F151C: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830F1520: 48011569  bl 0x83102a88
	ctx.lr = 0x830F1524;
	sub_83102A88(ctx, base);
	// 830F1524: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1528: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830F152C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830F1530: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1534: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1538: 4198FFA8  blt cr6, 0x830f14e0
	if ctx.cr[6].lt {
	pc = 0x830F14E0; continue 'dispatch;
	}
	// 830F153C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1540: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830F1544: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F1548: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830F154C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1550: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1558: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F155C: 81490014  lwz r10, 0x14(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F1560: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830F1564: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1568: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F156C: 4E800421  bctrl
	ctx.lr = 0x830F1570;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830F1570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1574: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F1578: 41980038  blt cr6, 0x830f15b0
	if ctx.cr[6].lt {
	pc = 0x830F15B0; continue 'dispatch;
	}
	// 830F157C: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1580: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 830F1584: 3B180014  addi r24, r24, 0x14
	ctx.r[24].s64 = ctx.r[24].s64 + 20;
	// 830F1588: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 830F158C: 3AD6000C  addi r22, r22, 0xc
	ctx.r[22].s64 = ctx.r[22].s64 + 12;
	// 830F1590: 7F155800  cmpw cr6, r21, r11
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1594: 4198FF08  blt cr6, 0x830f149c
	if ctx.cr[6].lt {
	pc = 0x830F149C; continue 'dispatch;
	}
	// 830F1598: 48000018  b 0x830f15b0
	pc = 0x830F15B0; continue 'dispatch;
	// 830F159C: 480114ED  bl 0x83102a88
	ctx.lr = 0x830F15A0;
	sub_83102A88(ctx, base);
	// 830F15A0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830F15A4: 4BFFFFD0  b 0x830f1574
	pc = 0x830F1574; continue 'dispatch;
	// 830F15A8: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 830F15AC: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 830F15B0: 389B001C  addi r4, r27, 0x1c
	ctx.r[4].s64 = ctx.r[27].s64 + 28;
	// 830F15B4: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830F15B8: 4BFEE629  bl 0x830dfbe0
	ctx.lr = 0x830F15BC;
	sub_830DFBE0(ctx, base);
	// 830F15BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F15C0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830F15C4: 480B6BD0  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F15C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F15C8 size=276
    let mut pc: u32 = 0x830F15C8;
    'dispatch: loop {
        match pc {
            0x830F15C8 => {
    //   block [0x830F15C8..0x830F16DC)
	// 830F15C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F15CC: 480B6B99  bl 0x831a8164
	ctx.lr = 0x830F15D0;
	sub_831A8130(ctx, base);
	// 830F15D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F15D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F15D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F15DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F15E0: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F15E4: 419A0068  beq cr6, 0x830f164c
	if ctx.cr[6].eq {
	pc = 0x830F164C; continue 'dispatch;
	}
	// 830F15E8: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830F15EC: 419A0048  beq cr6, 0x830f1634
	if ctx.cr[6].eq {
	pc = 0x830F1634; continue 'dispatch;
	}
	// 830F15F0: 2B0B0808  cmplwi cr6, r11, 0x808
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2056 as u32, &mut ctx.xer);
	// 830F15F4: 419A0018  beq cr6, 0x830f160c
	if ctx.cr[6].eq {
	pc = 0x830F160C; continue 'dispatch;
	}
	// 830F15F8: 2B0B080D  cmplwi cr6, r11, 0x80d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2061 as u32, &mut ctx.xer);
	// 830F15FC: 409A00D4  bne cr6, 0x830f16d0
	if !ctx.cr[6].eq {
	pc = 0x830F16D0; continue 'dispatch;
	}
	// 830F1600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1604: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F1608: 480000C0  b 0x830f16c8
	pc = 0x830F16C8; continue 'dispatch;
	// 830F160C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1610: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F1614: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F1618: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F161C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 830F1620: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1624: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830F1628: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F162C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830F1630: 48000098  b 0x830f16c8
	pc = 0x830F16C8; continue 'dispatch;
	// 830F1634: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1638: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F163C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1640: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F1644: 4BFF47B5  bl 0x830e5df8
	ctx.lr = 0x830F1648;
	sub_830E5DF8(ctx, base);
	// 830F1648: 48000088  b 0x830f16d0
	pc = 0x830F16D0; continue 'dispatch;
	// 830F164C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F1650: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1654: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F1658: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 830F165C: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 830F1660: 93BF002C  stw r29, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 830F1664: 3B7F002C  addi r27, r31, 0x2c
	ctx.r[27].s64 = ctx.r[31].s64 + 44;
	// 830F1668: 4BFDCEB1  bl 0x830ce518
	ctx.lr = 0x830F166C;
	sub_830CE518(ctx, base);
	// 830F166C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F1670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F1674: 419A005C  beq cr6, 0x830f16d0
	if ctx.cr[6].eq {
	pc = 0x830F16D0; continue 'dispatch;
	}
	// 830F1678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F167C: 4BFE454D  bl 0x830d5bc8
	ctx.lr = 0x830F1680;
	sub_830D5BC8(ctx, base);
	// 830F1680: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F1684: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830F1688: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F168C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F1690: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1694: 4BFEFEC5  bl 0x830e1558
	ctx.lr = 0x830F1698;
	sub_830E1558(ctx, base);
	// 830F1698: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F169C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F16A0: 419A0030  beq cr6, 0x830f16d0
	if ctx.cr[6].eq {
	pc = 0x830F16D0; continue 'dispatch;
	}
	// 830F16A4: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F16A8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F16AC: 388B95F8  addi r4, r11, -0x6a08
	ctx.r[4].s64 = ctx.r[11].s64 + -27144;
	// 830F16B0: 4BFEE631  bl 0x830dfce0
	ctx.lr = 0x830F16B4;
	sub_830DFCE0(ctx, base);
	// 830F16B4: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F16B8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F16BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F16C0: 388B95D8  addi r4, r11, -0x6a28
	ctx.r[4].s64 = ctx.r[11].s64 + -27176;
	// 830F16C4: 4BFEE61D  bl 0x830dfce0
	ctx.lr = 0x830F16C8;
	sub_830DFCE0(ctx, base);
	// 830F16C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F16CC: 4BFFB6CD  bl 0x830ecd98
	ctx.lr = 0x830F16D0;
	sub_830ECD98(ctx, base);
	// 830F16D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F16D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F16D8: 480B6ADC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F16E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F16E0 size=408
    let mut pc: u32 = 0x830F16E0;
    'dispatch: loop {
        match pc {
            0x830F16E0 => {
    //   block [0x830F16E0..0x830F1878)
	// 830F16E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F16E4: 480B6A85  bl 0x831a8168
	ctx.lr = 0x830F16E8;
	sub_831A8130(ctx, base);
	// 830F16E8: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 830F16EC: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830F16F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F16F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F16F8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830F16FC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F1700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1704: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F1708: 4BFFB741  bl 0x830ece48
	ctx.lr = 0x830F170C;
	sub_830ECE48(ctx, base);
	// 830F170C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F1710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1714: 4BFEE38D  bl 0x830dfaa0
	ctx.lr = 0x830F1718;
	sub_830DFAA0(ctx, base);
	// 830F1718: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F171C: 4180014C  blt 0x830f1868
	if ctx.cr[0].lt {
	pc = 0x830F1868; continue 'dispatch;
	}
	// 830F1720: C3C1005C  lfs f30, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F1724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1728: C3E10058  lfs f31, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F172C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F1730: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F1734: 4BFF02D5  bl 0x830e1a08
	ctx.lr = 0x830F1738;
	sub_830E1A08(ctx, base);
	// 830F1738: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F173C: 4180012C  blt 0x830f1868
	if ctx.cr[0].lt {
	pc = 0x830F1868; continue 'dispatch;
	}
	// 830F1740: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F1744: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1748: 409A0080  bne cr6, 0x830f17c8
	if !ctx.cr[6].eq {
	pc = 0x830F17C8; continue 'dispatch;
	}
	// 830F174C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1750: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F1754: 419A0074  beq cr6, 0x830f17c8
	if ctx.cr[6].eq {
	pc = 0x830F17C8; continue 'dispatch;
	}
	// 830F1758: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F175C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F1760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1764: 4BFFBE65  bl 0x830ed5c8
	ctx.lr = 0x830F1768;
	sub_830ED5C8(ctx, base);
	// 830F1768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F176C: 4BFEF315  bl 0x830e0a80
	ctx.lr = 0x830F1770;
	sub_830E0A80(ctx, base);
	// 830F1770: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F1774: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 830F1778: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F177C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F1780: 40990038  ble cr6, 0x830f17b8
	if !ctx.cr[6].gt {
	pc = 0x830F17B8; continue 'dispatch;
	}
	// 830F1784: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F1788: 419A0030  beq cr6, 0x830f17b8
	if ctx.cr[6].eq {
	pc = 0x830F17B8; continue 'dispatch;
	}
	// 830F178C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F1790: 419A0028  beq cr6, 0x830f17b8
	if ctx.cr[6].eq {
	pc = 0x830F17B8; continue 'dispatch;
	}
	// 830F1794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1798: 4BFED6F1  bl 0x830dee88
	ctx.lr = 0x830F179C;
	sub_830DEE88(ctx, base);
	// 830F179C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F17A0: 41820010  beq 0x830f17b0
	if ctx.cr[0].eq {
	pc = 0x830F17B0; continue 'dispatch;
	}
	// 830F17A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F17A8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830F17AC: 480000B8  b 0x830f1864
	pc = 0x830F1864; continue 'dispatch;
	// 830F17B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F17B4: 480000A8  b 0x830f185c
	pc = 0x830F185C; continue 'dispatch;
	// 830F17B8: FF006800  fcmpu cr6, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F17BC: 419900A8  bgt cr6, 0x830f1864
	if ctx.cr[6].gt {
	pc = 0x830F1864; continue 'dispatch;
	}
	// 830F17C0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F17C4: 4800007C  b 0x830f1840
	pc = 0x830F1840; continue 'dispatch;
	// 830F17C8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F17CC: 409A0098  bne cr6, 0x830f1864
	if !ctx.cr[6].eq {
	pc = 0x830F1864; continue 'dispatch;
	}
	// 830F17D0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F17D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F17D8: 419A008C  beq cr6, 0x830f1864
	if ctx.cr[6].eq {
	pc = 0x830F1864; continue 'dispatch;
	}
	// 830F17DC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F17E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F17E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F17E8: 4BFFBDE1  bl 0x830ed5c8
	ctx.lr = 0x830F17EC;
	sub_830ED5C8(ctx, base);
	// 830F17EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F17F0: 4BFEF291  bl 0x830e0a80
	ctx.lr = 0x830F17F4;
	sub_830E0A80(ctx, base);
	// 830F17F4: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F17F8: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F17FC: C3C10050  lfs f30, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F1800: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F1804: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830F1808: 40990024  ble cr6, 0x830f182c
	if !ctx.cr[6].gt {
	pc = 0x830F182C; continue 'dispatch;
	}
	// 830F180C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F1810: 419A001C  beq cr6, 0x830f182c
	if ctx.cr[6].eq {
	pc = 0x830F182C; continue 'dispatch;
	}
	// 830F1814: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F1818: 419A0014  beq cr6, 0x830f182c
	if ctx.cr[6].eq {
	pc = 0x830F182C; continue 'dispatch;
	}
	// 830F181C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1820: 4BFED669  bl 0x830dee88
	ctx.lr = 0x830F1824;
	sub_830DEE88(ctx, base);
	// 830F1824: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F1828: 4182FF6C  beq 0x830f1794
	if ctx.cr[0].eq {
	pc = 0x830F1794; continue 'dispatch;
	}
	// 830F182C: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F1830: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F1834: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830F1838: 4199002C  bgt cr6, 0x830f1864
	if ctx.cr[6].gt {
	pc = 0x830F1864; continue 'dispatch;
	}
	// 830F183C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F1840: 409A0024  bne cr6, 0x830f1864
	if !ctx.cr[6].eq {
	pc = 0x830F1864; continue 'dispatch;
	}
	// 830F1844: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1848: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F184C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F1850: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1854: 40980010  bge cr6, 0x830f1864
	if !ctx.cr[6].lt {
	pc = 0x830F1864; continue 'dispatch;
	}
	// 830F1858: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F185C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F1860: 4BFF6019  bl 0x830e7878
	ctx.lr = 0x830F1864;
	sub_830E7878(ctx, base);
	// 830F1864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1868: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F186C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830F1870: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F1874: 480B6944  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1878 size=168
    let mut pc: u32 = 0x830F1878;
    'dispatch: loop {
        match pc {
            0x830F1878 => {
    //   block [0x830F1878..0x830F1920)
	// 830F1878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F187C: 480B68F1  bl 0x831a816c
	ctx.lr = 0x830F1880;
	sub_831A8130(ctx, base);
	// 830F1880: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1884: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F1888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F188C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F1890: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F1894: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830F1898: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830F189C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830F18A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F18A4: 807F00A8  lwz r3, 0xa8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 830F18A8: 4BFF2779  bl 0x830e4020
	ctx.lr = 0x830F18AC;
	sub_830E4020(ctx, base);
	// 830F18AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F18B0: 41800068  blt 0x830f1918
	if ctx.cr[0].lt {
	pc = 0x830F1918; continue 'dispatch;
	}
	// 830F18B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F18B8: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F18BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F18C0: 4BFFFE21  bl 0x830f16e0
	ctx.lr = 0x830F18C4;
	sub_830F16E0(ctx, base);
	// 830F18C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F18C8: 41800050  blt 0x830f1918
	if ctx.cr[0].lt {
	pc = 0x830F1918; continue 'dispatch;
	}
	// 830F18CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F18D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F18D4: 4BFF5FA5  bl 0x830e7878
	ctx.lr = 0x830F18D8;
	sub_830E7878(ctx, base);
	// 830F18D8: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F18DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F18E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F18E4: 419A0008  beq cr6, 0x830f18ec
	if ctx.cr[6].eq {
	pc = 0x830F18EC; continue 'dispatch;
	}
	// 830F18E8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F18EC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F18F0: 4BFDD321  bl 0x830cec10
	ctx.lr = 0x830F18F4;
	sub_830CEC10(ctx, base);
	// 830F18F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F18F8: 4BFEDDC9  bl 0x830df6c0
	ctx.lr = 0x830F18FC;
	sub_830DF6C0(ctx, base);
	// 830F18FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F1900: 41800018  blt 0x830f1918
	if ctx.cr[0].lt {
	pc = 0x830F1918; continue 'dispatch;
	}
	// 830F1904: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F1908: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F190C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F1910: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1914: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 830F1918: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F191C: 480B68A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F1920 size=320
    let mut pc: u32 = 0x830F1920;
    'dispatch: loop {
        match pc {
            0x830F1920 => {
    //   block [0x830F1920..0x830F1A60)
	// 830F1920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1924: 480B6845  bl 0x831a8168
	ctx.lr = 0x830F1928;
	sub_831A8130(ctx, base);
	// 830F1928: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F192C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F1930: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F1934: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1938: 419A003C  beq cr6, 0x830f1974
	if ctx.cr[6].eq {
	pc = 0x830F1974; continue 'dispatch;
	}
	// 830F193C: 83FE00AC  lwz r31, 0xac(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F1940: 37BFFFFF  addic. r29, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F1944: 4180005C  blt 0x830f19a0
	if ctx.cr[0].lt {
	pc = 0x830F19A0; continue 'dispatch;
	}
	// 830F1948: 57BC103A  slwi r28, r29, 2
	ctx.r[28].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 830F194C: 817E00B0  lwz r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F1950: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F1954: 4BFEF12D  bl 0x830e0a80
	ctx.lr = 0x830F1958;
	sub_830E0A80(ctx, base);
	// 830F1958: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F195C: 40820044  bne 0x830f19a0
	if !ctx.cr[0].eq {
	pc = 0x830F19A0; continue 'dispatch;
	}
	// 830F1960: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F1964: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830F1968: 3B9CFFFC  addi r28, r28, -4
	ctx.r[28].s64 = ctx.r[28].s64 + -4;
	// 830F196C: 4080FFE0  bge 0x830f194c
	if !ctx.cr[0].lt {
	pc = 0x830F194C; continue 'dispatch;
	}
	// 830F1970: 48000030  b 0x830f19a0
	pc = 0x830F19A0; continue 'dispatch;
	// 830F1974: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1978: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F197C: 409A0030  bne cr6, 0x830f19ac
	if !ctx.cr[6].eq {
	pc = 0x830F19AC; continue 'dispatch;
	}
	// 830F1980: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F1984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1988: 409A0024  bne cr6, 0x830f19ac
	if !ctx.cr[6].eq {
	pc = 0x830F19AC; continue 'dispatch;
	}
	// 830F198C: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1990: 83FE00AC  lwz r31, 0xac(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F1994: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830F1998: 40980008  bge cr6, 0x830f19a0
	if !ctx.cr[6].lt {
	pc = 0x830F19A0; continue 'dispatch;
	}
	// 830F199C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830F19A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F19A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F19A8: 480B6810  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 830F19AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F19B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F19B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F19B8: 4BFFBC11  bl 0x830ed5c8
	ctx.lr = 0x830F19BC;
	sub_830ED5C8(ctx, base);
	// 830F19BC: 817E00AC  lwz r11, 0xac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F19C0: 37EBFFFF  addic. r31, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F19C4: 41800074  blt 0x830f1a38
	if ctx.cr[0].lt {
	pc = 0x830F1A38; continue 'dispatch;
	}
	// 830F19C8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830F19CC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F19D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F19D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F19D8: 4BFFB471  bl 0x830ece48
	ctx.lr = 0x830F19DC;
	sub_830ECE48(ctx, base);
	// 830F19DC: 817E00A0  lwz r11, 0xa0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F19E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F19E4: 409A001C  bne cr6, 0x830f1a00
	if !ctx.cr[6].eq {
	pc = 0x830F1A00; continue 'dispatch;
	}
	// 830F19E8: C1A10064  lfs f13, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F19EC: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F19F0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F19F4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F19F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F19FC: 40990030  ble cr6, 0x830f1a2c
	if !ctx.cr[6].gt {
	pc = 0x830F1A2C; continue 'dispatch;
	}
	// 830F1A00: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F1A04: 409A001C  bne cr6, 0x830f1a20
	if !ctx.cr[6].eq {
	pc = 0x830F1A20; continue 'dispatch;
	}
	// 830F1A08: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F1A0C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F1A10: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F1A14: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F1A18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F1A1C: 40990010  ble cr6, 0x830f1a2c
	if !ctx.cr[6].gt {
	pc = 0x830F1A2C; continue 'dispatch;
	}
	// 830F1A20: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F1A24: 4080FFA4  bge 0x830f19c8
	if !ctx.cr[0].lt {
	pc = 0x830F19C8; continue 'dispatch;
	}
	// 830F1A28: 48000010  b 0x830f1a38
	pc = 0x830F1A38; continue 'dispatch;
	// 830F1A2C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830F1A30: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F1A34: 409AFF6C  bne cr6, 0x830f19a0
	if !ctx.cr[6].eq {
	pc = 0x830F19A0; continue 'dispatch;
	}
	// 830F1A38: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1A3C: 83FE00AC  lwz r31, 0xac(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F1A40: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830F1A44: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830F1A48: 41980008  blt cr6, 0x830f1a50
	if ctx.cr[6].lt {
	pc = 0x830F1A50; continue 'dispatch;
	}
	// 830F1A4C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 830F1A50: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F1A54: 4099FF40  ble cr6, 0x830f1994
	if !ctx.cr[6].gt {
	pc = 0x830F1994; continue 'dispatch;
	}
	// 830F1A58: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 830F1A5C: 4BFFFF44  b 0x830f19a0
	pc = 0x830F19A0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1A60 size=100
    let mut pc: u32 = 0x830F1A60;
    'dispatch: loop {
        match pc {
            0x830F1A60 => {
    //   block [0x830F1A60..0x830F1AC4)
	// 830F1A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1A68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1A6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1A70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1A74: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F1A78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1A7C: 41980030  blt cr6, 0x830f1aac
	if ctx.cr[6].lt {
	pc = 0x830F1AAC; continue 'dispatch;
	}
	// 830F1A80: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1A84: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F1A88: 40980024  bge cr6, 0x830f1aac
	if !ctx.cr[6].lt {
	pc = 0x830F1AAC; continue 'dispatch;
	}
	// 830F1A8C: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830F1A90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1A94: 41980018  blt cr6, 0x830f1aac
	if ctx.cr[6].lt {
	pc = 0x830F1AAC; continue 'dispatch;
	}
	// 830F1A98: 4BFFFE89  bl 0x830f1920
	ctx.lr = 0x830F1A9C;
	sub_830F1920(ctx, base);
	// 830F1A9C: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830F1AA0: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830F1AA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F1AA8: 41980008  blt cr6, 0x830f1ab0
	if ctx.cr[6].lt {
	pc = 0x830F1AB0; continue 'dispatch;
	}
	// 830F1AAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1AB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1AC8 size=72
    let mut pc: u32 = 0x830F1AC8;
    'dispatch: loop {
        match pc {
            0x830F1AC8 => {
    //   block [0x830F1AC8..0x830F1B10)
	// 830F1AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1AD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1AD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1ADC: 4BFFFF85  bl 0x830f1a60
	ctx.lr = 0x830F1AE0;
	sub_830F1A60(ctx, base);
	// 830F1AE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F1AE4: 41820014  beq 0x830f1af8
	if ctx.cr[0].eq {
	pc = 0x830F1AF8; continue 'dispatch;
	}
	// 830F1AE8: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830F1AEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F1AF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1AF4: 419A0008  beq cr6, 0x830f1afc
	if ctx.cr[6].eq {
	pc = 0x830F1AFC; continue 'dispatch;
	}
	// 830F1AF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1AFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1B00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1B04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1B08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1B0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F1B10 size=84
    let mut pc: u32 = 0x830F1B10;
    'dispatch: loop {
        match pc {
            0x830F1B10 => {
    //   block [0x830F1B10..0x830F1B64)
	// 830F1B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F1B18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F1B1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1B24: 4BFFFF3D  bl 0x830f1a60
	ctx.lr = 0x830F1B28;
	sub_830F1A60(ctx, base);
	// 830F1B28: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F1B2C: 41820020  beq 0x830f1b4c
	if ctx.cr[0].eq {
	pc = 0x830F1B4C; continue 'dispatch;
	}
	// 830F1B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1B34: 4BFFFDED  bl 0x830f1920
	ctx.lr = 0x830F1B38;
	sub_830F1920(ctx, base);
	// 830F1B38: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830F1B3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F1B40: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830F1B44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F1B48: 419A0008  beq cr6, 0x830f1b50
	if ctx.cr[6].eq {
	pc = 0x830F1B50; continue 'dispatch;
	}
	// 830F1B4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F1B50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F1B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F1B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F1B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F1B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F1B68 size=264
    let mut pc: u32 = 0x830F1B68;
    'dispatch: loop {
        match pc {
            0x830F1B68 => {
    //   block [0x830F1B68..0x830F1C70)
	// 830F1B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1B6C: 480B6601  bl 0x831a816c
	ctx.lr = 0x830F1B70;
	sub_831A8130(ctx, base);
	// 830F1B70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1B74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F1B78: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F1B7C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F1B80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1B84: 419A003C  beq cr6, 0x830f1bc0
	if ctx.cr[6].eq {
	pc = 0x830F1BC0; continue 'dispatch;
	}
	// 830F1B88: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1B8C: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F1B90: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F1B94: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1B98: 418000CC  blt 0x830f1c64
	if ctx.cr[0].lt {
	pc = 0x830F1C64; continue 'dispatch;
	}
	// 830F1B9C: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F1BA0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F1BA4: 409800C0  bge cr6, 0x830f1c64
	if !ctx.cr[6].lt {
	pc = 0x830F1C64; continue 'dispatch;
	}
	// 830F1BA8: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F1BAC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F1BB0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F1BB4: 4BFEEECD  bl 0x830e0a80
	ctx.lr = 0x830F1BB8;
	sub_830E0A80(ctx, base);
	// 830F1BB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F1BBC: 480000A8  b 0x830f1c64
	pc = 0x830F1C64; continue 'dispatch;
	// 830F1BC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F1BC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1BC8: 409A0030  bne cr6, 0x830f1bf8
	if !ctx.cr[6].eq {
	pc = 0x830F1BF8; continue 'dispatch;
	}
	// 830F1BCC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F1BD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1BD4: 409A0024  bne cr6, 0x830f1bf8
	if !ctx.cr[6].eq {
	pc = 0x830F1BF8; continue 'dispatch;
	}
	// 830F1BD8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F1BDC: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F1BE0: 813F00F0  lwz r9, 0xf0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1BE4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F1BE8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F1BEC: 40980074  bge cr6, 0x830f1c60
	if !ctx.cr[6].lt {
	pc = 0x830F1C60; continue 'dispatch;
	}
	// 830F1BF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F1BF4: 48000070  b 0x830f1c64
	pc = 0x830F1C64; continue 'dispatch;
	// 830F1BF8: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1BFC: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F1C00: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F1C04: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F1C08: 4180005C  blt 0x830f1c64
	if ctx.cr[0].lt {
	pc = 0x830F1C64; continue 'dispatch;
	}
	// 830F1C0C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F1C10: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1C14: 40980050  bge cr6, 0x830f1c64
	if !ctx.cr[6].lt {
	pc = 0x830F1C64; continue 'dispatch;
	}
	// 830F1C18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F1C1C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F1C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1C24: 4BFFB9A5  bl 0x830ed5c8
	ctx.lr = 0x830F1C28;
	sub_830ED5C8(ctx, base);
	// 830F1C28: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830F1C2C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F1C30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F1C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1C38: 4BFFB211  bl 0x830ece48
	ctx.lr = 0x830F1C3C;
	sub_830ECE48(ctx, base);
	// 830F1C3C: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F1C40: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F1C44: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F1C48: 4198001C  blt cr6, 0x830f1c64
	if ctx.cr[6].lt {
	pc = 0x830F1C64; continue 'dispatch;
	}
	// 830F1C4C: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F1C50: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F1C54: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F1C58: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F1C5C: 41990008  bgt cr6, 0x830f1c64
	if ctx.cr[6].gt {
	pc = 0x830F1C64; continue 'dispatch;
	}
	// 830F1C60: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830F1C64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F1C68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F1C6C: 480B6550  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F1C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F1C70 size=2920
    let mut pc: u32 = 0x830F1C70;
    'dispatch: loop {
        match pc {
            0x830F1C70 => {
    //   block [0x830F1C70..0x830F27D8)
	// 830F1C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F1C74: 480B64DD  bl 0x831a8150
	ctx.lr = 0x830F1C78;
	sub_831A8130(ctx, base);
	// 830F1C78: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 830F1C7C: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 830F1C80: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 830F1C84: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F1C88: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F1C8C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F1C90: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 830F1C94: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830F1C98: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F1C9C: 40980008  bge cr6, 0x830f1ca4
	if !ctx.cr[6].lt {
	pc = 0x830F1CA4; continue 'dispatch;
	}
	// 830F1CA0: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 830F1CA4: 817B00AC  lwz r11, 0xac(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F1CA8: 815B00C0  lwz r10, 0xc0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F1CAC: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 830F1CB0: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830F1CB4: 40980014  bge cr6, 0x830f1cc8
	if !ctx.cr[6].lt {
	pc = 0x830F1CC8; continue 'dispatch;
	}
	// 830F1CB8: 387B00BC  addi r3, r27, 0xbc
	ctx.r[3].s64 = ctx.r[27].s64 + 188;
	// 830F1CBC: 4BFFE235  bl 0x830efef0
	ctx.lr = 0x830F1CC0;
	sub_830EFEF0(ctx, base);
	// 830F1CC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F1CC4: 41800B00  blt 0x830f27c4
	if ctx.cr[0].lt {
	pc = 0x830F27C4; continue 'dispatch;
	}
	// 830F1CC8: 815B00C4  lwz r10, 0xc4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F1CCC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830F1CD0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F1CD4: 40990148  ble cr6, 0x830f1e1c
	if !ctx.cr[6].gt {
	pc = 0x830F1E1C; continue 'dispatch;
	}
	// 830F1CD8: 811B00C0  lwz r8, 0xc0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F1CDC: 3BFB00BC  addi r31, r27, 0xbc
	ctx.r[31].s64 = ctx.r[27].s64 + 188;
	// 830F1CE0: 813B00C8  lwz r9, 0xc8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F1CE4: 80FB00BC  lwz r7, 0xbc(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F1CE8: 0CC80000  twi 6, r8, 0
	// 830F1CEC: 7CC943D6  divw r6, r9, r8
	ctx.r[6].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F1CF0: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F1CF4: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F1CF8: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 830F1CFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1D00: 1D290014  mulli r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 * 20;
	// 830F1D04: 7D29382E  lwzx r9, r9, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830F1D08: 7D0B5878  andc r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830F1D0C: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F1D10: 0CABFFFF  twi 5, r11, -1
	// 830F1D14: 40990048  ble cr6, 0x830f1d5c
	if !ctx.cr[6].gt {
	pc = 0x830F1D5C; continue 'dispatch;
	}
	// 830F1D18: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1D1C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1D20: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1D24: 0CC80000  twi 6, r8, 0
	// 830F1D28: 7CC943D6  divw r6, r9, r8
	ctx.r[6].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F1D2C: 80BB00C0  lwz r5, 0xc0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F1D30: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F1D34: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F1D38: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 830F1D3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1D40: 1D290014  mulli r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 * 20;
	// 830F1D44: 7D29382E  lwzx r9, r9, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830F1D48: 7D0B5878  andc r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830F1D4C: 7D3C4850  subf r9, r28, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 830F1D50: 0CABFFFF  twi 5, r11, -1
	// 830F1D54: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830F1D58: 4198022C  blt cr6, 0x830f1f84
	if ctx.cr[6].lt {
	pc = 0x830F1F84; continue 'dispatch;
	}
	// 830F1D5C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1D60: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1D64: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1D68: 0CC80000  twi 6, r8, 0
	// 830F1D6C: 7CC943D6  divw r6, r9, r8
	ctx.r[6].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F1D70: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F1D74: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F1D78: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 830F1D7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1D80: 1D290014  mulli r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 * 20;
	// 830F1D84: 7D29382E  lwzx r9, r9, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830F1D88: 7D0B5878  andc r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830F1D8C: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F1D90: 0CABFFFF  twi 5, r11, -1
	// 830F1D94: 40980044  bge cr6, 0x830f1dd8
	if !ctx.cr[6].lt {
	pc = 0x830F1DD8; continue 'dispatch;
	}
	// 830F1D98: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1D9C: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830F1DA0: 54E7003E  slwi r7, r7, 0
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830F1DA4: 7CC943D6  divw r6, r9, r8
	ctx.r[6].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F1DA8: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F1DAC: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F1DB0: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 830F1DB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1DB8: 1D290014  mulli r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 * 20;
	// 830F1DBC: 7D29382E  lwzx r9, r9, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830F1DC0: 7D0B5878  andc r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830F1DC4: 7D29E050  subf r9, r9, r28
	ctx.r[9].s64 = ctx.r[28].s64 - ctx.r[9].s64;
	// 830F1DC8: 0CC80000  twi 6, r8, 0
	// 830F1DCC: 0CABFFFF  twi 5, r11, -1
	// 830F1DD0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F1DD4: 419801F8  blt cr6, 0x830f1fcc
	if ctx.cr[6].lt {
	pc = 0x830F1FCC; continue 'dispatch;
	}
	// 830F1DD8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1DDC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1DE0: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1DE4: 0CC90000  twi 6, r9, 0
	// 830F1DE8: 7CEA4BD6  divw r7, r10, r9
	ctx.r[7].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F1DEC: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F1DF0: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F1DF4: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 830F1DF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1DFC: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 830F1E00: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F1E04: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F1E08: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F1E0C: 0CABFFFF  twi 5, r11, -1
	// 830F1E10: 419A000C  beq cr6, 0x830f1e1c
	if ctx.cr[6].eq {
	pc = 0x830F1E1C; continue 'dispatch;
	}
	// 830F1E14: 933F0008  stw r25, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 830F1E18: 933F000C  stw r25, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 830F1E1C: 817B00C0  lwz r11, 0xc0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F1E20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F1E24: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F1E28: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1E2C: C3AA08A4  lfs f29, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830F1E30: 40980490  bge cr6, 0x830f22c0
	if !ctx.cr[6].lt {
	pc = 0x830F22C0; continue 'dispatch;
	}
	// 830F1E34: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830F1E38: 817B00F0  lwz r11, 0xf0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F1E3C: 7FBFE214  add r29, r31, r28
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[28].u64;
	// 830F1E40: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1E44: 4098047C  bge cr6, 0x830f22c0
	if !ctx.cr[6].lt {
	pc = 0x830F22C0; continue 'dispatch;
	}
	// 830F1E48: 817B00C4  lwz r11, 0xc4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F1E4C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F1E50: 40980280  bge cr6, 0x830f20d0
	if !ctx.cr[6].lt {
	pc = 0x830F20D0; continue 'dispatch;
	}
	// 830F1E54: 815B00C8  lwz r10, 0xc8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F1E58: 397B00BC  addi r11, r27, 0xbc
	ctx.r[11].s64 = ctx.r[27].s64 + 188;
	// 830F1E5C: 811B00C0  lwz r8, 0xc0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F1E60: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F1E64: 813B00BC  lwz r9, 0xbc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F1E68: 0CC80000  twi 6, r8, 0
	// 830F1E6C: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F1E70: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F1E74: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F1E78: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F1E7C: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F1E80: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830F1E84: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F1E88: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F1E8C: 0CA9FFFF  twi 5, r9, -1
	// 830F1E90: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1E94: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F1E98: 419A0174  beq cr6, 0x830f200c
	if ctx.cr[6].eq {
	pc = 0x830F200C; continue 'dispatch;
	}
	// 830F1E9C: 7F1DC000  cmpw cr6, r29, r24
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F1EA0: 419A016C  beq cr6, 0x830f200c
	if ctx.cr[6].eq {
	pc = 0x830F200C; continue 'dispatch;
	}
	// 830F1EA4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1EA8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1EAC: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F1EB0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1EB4: 0CC80000  twi 6, r8, 0
	// 830F1EB8: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F1EBC: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F1EC0: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F1EC4: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F1EC8: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F1ECC: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830F1ED0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F1ED4: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F1ED8: 0CA9FFFF  twi 5, r9, -1
	// 830F1EDC: 932A000C  stw r25, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 830F1EE0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1EE4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1EE8: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F1EEC: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F1EF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1EF4: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F1EF8: 7D6641D6  mullw r11, r6, r8
	ctx.r[11].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F1EFC: 7D6B3850  subf r11, r11, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 830F1F00: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830F1F04: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 830F1F08: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F1F0C: 7D0A4878  andc r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[9].u64;
	// 830F1F10: 480001B4  b 0x830f20c4
	pc = 0x830F20C4; continue 'dispatch;
	// 830F1F14: 817B00C4  lwz r11, 0xc4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F1F18: 815B00C0  lwz r10, 0xc0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F1F1C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F1F20: 409A0018  bne cr6, 0x830f1f38
	if !ctx.cr[6].eq {
	pc = 0x830F1F38; continue 'dispatch;
	}
	// 830F1F24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F1F28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F1F2C: 4099000C  ble cr6, 0x830f1f38
	if !ctx.cr[6].gt {
	pc = 0x830F1F38; continue 'dispatch;
	}
	// 830F1F30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1F34: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F1F38: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1F3C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F1F40: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1F48: 0CC90000  twi 6, r9, 0
	// 830F1F4C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1F50: 7CEA4BD6  divw r7, r10, r9
	ctx.r[7].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F1F54: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 830F1F58: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F1F5C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F1F60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1F64: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 830F1F68: 7D295878  andc r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F1F6C: 1D6A0014  mulli r11, r10, 0x14
	ctx.r[11].s64 = ctx.r[10].s64 * 20;
	// 830F1F70: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F1F74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1F78: 0CA9FFFF  twi 5, r9, -1
	// 830F1F7C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830F1F80: 4BFFDEE1  bl 0x830efe60
	ctx.lr = 0x830F1F84;
	sub_830EFE60(ctx, base);
	// 830F1F84: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1F88: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1F8C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1F90: 0CC90000  twi 6, r9, 0
	// 830F1F94: 7CEA4BD6  divw r7, r10, r9
	ctx.r[7].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F1F98: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F1F9C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F1FA0: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 830F1FA4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1FA8: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 830F1FAC: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F1FB0: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F1FB4: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F1FB8: 0CABFFFF  twi 5, r11, -1
	// 830F1FBC: 409AFF58  bne cr6, 0x830f1f14
	if !ctx.cr[6].eq {
	pc = 0x830F1F14; continue 'dispatch;
	}
	// 830F1FC0: 4BFFFE5C  b 0x830f1e1c
	pc = 0x830F1E1C; continue 'dispatch;
	// 830F1FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F1FC8: 4BFF46D1  bl 0x830e6698
	ctx.lr = 0x830F1FCC;
	sub_830E6698(ctx, base);
	// 830F1FCC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F1FD0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F1FD4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F1FD8: 0CC90000  twi 6, r9, 0
	// 830F1FDC: 7CEA4BD6  divw r7, r10, r9
	ctx.r[7].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F1FE0: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F1FE4: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F1FE8: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 830F1FEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F1FF0: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 830F1FF4: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F1FF8: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F1FFC: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F2000: 0CABFFFF  twi 5, r11, -1
	// 830F2004: 409AFFC0  bne cr6, 0x830f1fc4
	if !ctx.cr[6].eq {
	pc = 0x830F1FC4; continue 'dispatch;
	}
	// 830F2008: 4BFFFE14  b 0x830f1e1c
	pc = 0x830F1E1C; continue 'dispatch;
	// 830F200C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2010: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2014: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F2018: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F201C: 0CC80000  twi 6, r8, 0
	// 830F2020: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F2024: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F2028: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F202C: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F2030: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F2034: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830F2038: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F203C: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F2040: 0CA9FFFF  twi 5, r9, -1
	// 830F2044: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2048: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F204C: 409A0084  bne cr6, 0x830f20d0
	if !ctx.cr[6].eq {
	pc = 0x830F20D0; continue 'dispatch;
	}
	// 830F2050: 7F1DC000  cmpw cr6, r29, r24
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F2054: 409A007C  bne cr6, 0x830f20d0
	if !ctx.cr[6].eq {
	pc = 0x830F20D0; continue 'dispatch;
	}
	// 830F2058: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F205C: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830F2060: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2064: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F2068: 0CC80000  twi 6, r8, 0
	// 830F206C: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F2070: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F2074: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F2078: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F207C: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F2080: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830F2084: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F2088: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F208C: 0CA9FFFF  twi 5, r9, -1
	// 830F2090: 934A000C  stw r26, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830F2094: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2098: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F209C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F20A0: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 830F20A4: 7D6943D6  divw r11, r9, r8
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F20A8: 7CEB41D6  mullw r7, r11, r8
	ctx.r[7].s64 = (ctx.r[11].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F20AC: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F20B0: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 830F20B4: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F20B8: 1D690014  mulli r11, r9, 0x14
	ctx.r[11].s64 = ctx.r[9].s64 * 20;
	// 830F20BC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F20C0: 7D0A3878  andc r10, r8, r7
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[7].u64;
	// 830F20C4: 934B0010  stw r26, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 830F20C8: 0CAAFFFF  twi 5, r10, -1
	// 830F20CC: 0CC80000  twi 6, r8, 0
	// 830F20D0: 817B00C4  lwz r11, 0xc4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F20D4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F20D8: 40980048  bge cr6, 0x830f2120
	if !ctx.cr[6].lt {
	pc = 0x830F2120; continue 'dispatch;
	}
	// 830F20DC: 817B00C8  lwz r11, 0xc8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F20E0: 813B00C0  lwz r9, 0xc0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F20E4: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830F20E8: 815B00BC  lwz r10, 0xbc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F20EC: 0CC90000  twi 6, r9, 0
	// 830F20F0: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F20F4: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F20F8: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F20FC: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F2100: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F2104: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F2108: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F210C: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F2110: 0CAAFFFF  twi 5, r10, -1
	// 830F2114: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F2118: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F211C: 419A018C  beq cr6, 0x830f22a8
	if ctx.cr[6].eq {
	pc = 0x830F22A8; continue 'dispatch;
	}
	// 830F2120: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F2124: C3FB003C  lfs f31, 0x3c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F2128: C3DB0040  lfs f30, 0x40(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F212C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2130: 419A0010  beq cr6, 0x830f2140
	if ctx.cr[6].eq {
	pc = 0x830F2140; continue 'dispatch;
	}
	// 830F2134: 7F1DC000  cmpw cr6, r29, r24
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F2138: 409A0008  bne cr6, 0x830f2140
	if !ctx.cr[6].eq {
	pc = 0x830F2140; continue 'dispatch;
	}
	// 830F213C: C3FB0050  lfs f31, 0x50(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F2140: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F2144: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2148: 419A0010  beq cr6, 0x830f2158
	if ctx.cr[6].eq {
	pc = 0x830F2158; continue 'dispatch;
	}
	// 830F214C: 7F1DC000  cmpw cr6, r29, r24
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F2150: 409A0008  bne cr6, 0x830f2158
	if !ctx.cr[6].eq {
	pc = 0x830F2158; continue 'dispatch;
	}
	// 830F2154: C3DB004C  lfs f30, 0x4c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F2158: 7D7DC050  subf r11, r29, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[29].s64;
	// 830F215C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F2160: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F2164: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F2168: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F216C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F2170: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F2174: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830F2178: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F217C: 4BFF537D  bl 0x830e74f8
	ctx.lr = 0x830F2180;
	sub_830E74F8(ctx, base);
	// 830F2180: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2184: 3AE10080  addi r23, r1, 0x80
	ctx.r[23].s64 = ctx.r[1].s64 + 128;
	// 830F2188: 4BFDCA89  bl 0x830cec10
	ctx.lr = 0x830F218C;
	sub_830CEC10(ctx, base);
	// 830F218C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830F2190: 4BFE3A39  bl 0x830d5bc8
	ctx.lr = 0x830F2194;
	sub_830D5BC8(ctx, base);
	// 830F2194: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F2198: 41800020  blt 0x830f21b8
	if ctx.cr[0].lt {
	pc = 0x830F21B8; continue 'dispatch;
	}
	// 830F219C: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F21A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F21A4: 419A0014  beq cr6, 0x830f21b8
	if ctx.cr[6].eq {
	pc = 0x830F21B8; continue 'dispatch;
	}
	// 830F21A8: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F21AC: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F21B0: FFE0E82E  fsel f31, f0, f0, f29
	ctx.f[31].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[29].f64 };
	// 830F21B4: FFCDEB6E  fsel f30, f13, f13, f29
	ctx.f[30].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[29].f64 };
	// 830F21B8: 817B00C4  lwz r11, 0xc4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F21BC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F21C0: 409800C8  bge cr6, 0x830f2288
	if !ctx.cr[6].lt {
	pc = 0x830F2288; continue 'dispatch;
	}
	// 830F21C4: 815B00C8  lwz r10, 0xc8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F21C8: 397B00BC  addi r11, r27, 0xbc
	ctx.r[11].s64 = ctx.r[27].s64 + 188;
	// 830F21CC: 817B00C0  lwz r11, 0xc0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F21D0: 7D0AFA14  add r8, r10, r31
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F21D4: 813B00BC  lwz r9, 0xbc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F21D8: 0CCB0000  twi 6, r11, 0
	// 830F21DC: 7CE85BD6  divw r7, r8, r11
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 830F21E0: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F21E4: 7CE759D6  mullw r7, r7, r11
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830F21E8: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F21EC: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 830F21F0: 1D480014  mulli r10, r8, 0x14
	ctx.r[10].s64 = ctx.r[8].s64 * 20;
	// 830F21F4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F21F8: 7D6B3878  andc r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[7].u64;
	// 830F21FC: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 830F2200: 0CABFFFF  twi 5, r11, -1
	// 830F2204: D3CA0008  stfs f30, 8(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830F2208: D3EA0004  stfs f31, 4(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F220C: 80FB00C0  lwz r7, 0xc0(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F2210: 0CC70000  twi 6, r7, 0
	// 830F2214: 813B00BC  lwz r9, 0xbc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F2218: 815B00C8  lwz r10, 0xc8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F221C: 7D6AFA14  add r11, r10, r31
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F2220: 7D4B3BD6  divw r10, r11, r7
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[7].s32;
	// 830F2224: 5568083E  rotlwi r8, r11, 1
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830F2228: 7D4A39D6  mullw r10, r10, r7
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830F222C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F2230: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 830F2234: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F2238: 3948FFFF  addi r10, r8, -1
	ctx.r[10].s64 = ctx.r[8].s64 + -1;
	// 830F223C: 7CEA5078  andc r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830F2240: 932B0010  stw r25, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	// 830F2244: 0CAAFFFF  twi 5, r10, -1
	// 830F2248: 811B00C0  lwz r8, 0xc0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F224C: 815B00C8  lwz r10, 0xc8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F2250: 7D6AFA14  add r11, r10, r31
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830F2254: 7CEB43D6  divw r7, r11, r8
	ctx.r[7].s32 = ctx.r[11].s32 / ctx.r[8].s32;
	// 830F2258: 815B00BC  lwz r10, 0xbc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F225C: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830F2260: 7CE741D6  mullw r7, r7, r8
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F2264: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 830F2268: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830F226C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 830F2270: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2274: 7D0A4878  andc r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[9].u64;
	// 830F2278: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830F227C: 0CC80000  twi 6, r8, 0
	// 830F2280: 0CAAFFFF  twi 5, r10, -1
	// 830F2284: 48000024  b 0x830f22a8
	pc = 0x830F22A8; continue 'dispatch;
	// 830F2288: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830F228C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 830F2290: D3C10068  stfs f30, 0x68(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830F2294: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 830F2298: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 830F229C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F22A0: 387B00BC  addi r3, r27, 0xbc
	ctx.r[3].s64 = ctx.r[27].s64 + 188;
	// 830F22A4: 4BFFDB25  bl 0x830efdc8
	ctx.lr = 0x830F22A8;
	sub_830EFDC8(ctx, base);
	// 830F22A8: 817B00C0  lwz r11, 0xc0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F22AC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830F22B0: 7D5FE214  add r10, r31, r28
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[28].u64;
	// 830F22B4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F22B8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F22BC: 4198FB7C  blt cr6, 0x830f1e38
	if ctx.cr[6].lt {
	pc = 0x830F1E38; continue 'dispatch;
	}
	// 830F22C0: 809B00AC  lwz r4, 0xac(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F22C4: 817B00F0  lwz r11, 0xf0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F22C8: 7F845851  subf. r28, r4, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F22CC: 40800008  bge 0x830f22d4
	if !ctx.cr[0].lt {
	pc = 0x830F22D4; continue 'dispatch;
	}
	// 830F22D0: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 830F22D4: 817B00D0  lwz r11, 0xd0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 830F22D8: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830F22DC: 419A0014  beq cr6, 0x830f22f0
	if ctx.cr[6].eq {
	pc = 0x830F22F0; continue 'dispatch;
	}
	// 830F22E0: 387B00CC  addi r3, r27, 0xcc
	ctx.r[3].s64 = ctx.r[27].s64 + 204;
	// 830F22E4: 4BFFDC0D  bl 0x830efef0
	ctx.lr = 0x830F22E8;
	sub_830EFEF0(ctx, base);
	// 830F22E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F22EC: 418004D8  blt 0x830f27c4
	if ctx.cr[0].lt {
	pc = 0x830F27C4; continue 'dispatch;
	}
	// 830F22F0: 817B00D4  lwz r11, 0xd4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(212 as u32) ) } as u64;
	// 830F22F4: 815B00D0  lwz r10, 0xd0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 830F22F8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F22FC: 409A0044  bne cr6, 0x830f2340
	if !ctx.cr[6].eq {
	pc = 0x830F2340; continue 'dispatch;
	}
	// 830F2300: 813B00D0  lwz r9, 0xd0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 830F2304: 3BFB00CC  addi r31, r27, 0xcc
	ctx.r[31].s64 = ctx.r[27].s64 + 204;
	// 830F2308: 815B00D8  lwz r10, 0xd8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(216 as u32) ) } as u64;
	// 830F230C: 811B00CC  lwz r8, 0xcc(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 830F2310: 0CC90000  twi 6, r9, 0
	// 830F2314: 7CEA4BD6  divw r7, r10, r9
	ctx.r[7].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F2318: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F231C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2320: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 830F2324: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F2328: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 830F232C: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F2330: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F2334: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F2338: 0CABFFFF  twi 5, r11, -1
	// 830F233C: 419A0054  beq cr6, 0x830f2390
	if ctx.cr[6].eq {
	pc = 0x830F2390; continue 'dispatch;
	}
	// 830F2340: 933B00D4  stw r25, 0xd4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(212 as u32), ctx.r[25].u32 ) };
	// 830F2344: 3BFB00CC  addi r31, r27, 0xcc
	ctx.r[31].s64 = ctx.r[27].s64 + 204;
	// 830F2348: 933B00D8  stw r25, 0xd8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(216 as u32), ctx.r[25].u32 ) };
	// 830F234C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 830F2350: 817B00F0  lwz r11, 0xf0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F2354: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F2358: 40980038  bge cr6, 0x830f2390
	if !ctx.cr[6].lt {
	pc = 0x830F2390; continue 'dispatch;
	}
	// 830F235C: 7D7EC050  subf r11, r30, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[30].s64;
	// 830F2360: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 830F2364: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 830F2368: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F236C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F2370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2374: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F2378: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830F237C: 4BFFDA4D  bl 0x830efdc8
	ctx.lr = 0x830F2380;
	sub_830EFDC8(ctx, base);
	// 830F2380: 817B00F0  lwz r11, 0xf0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F2384: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F2388: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F238C: 4198FFD0  blt cr6, 0x830f235c
	if ctx.cr[6].lt {
	pc = 0x830F235C; continue 'dispatch;
	}
	// 830F2390: 817B00F0  lwz r11, 0xf0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F2394: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F2398: 40980428  bge cr6, 0x830f27c0
	if !ctx.cr[6].lt {
	pc = 0x830F27C0; continue 'dispatch;
	}
	// 830F239C: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 830F23A0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F23A4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F23A8: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F23AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F23B0: 0CC90000  twi 6, r9, 0
	// 830F23B4: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F23B8: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F23BC: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F23C0: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F23C4: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F23C8: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F23CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F23D0: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F23D4: 0CAAFFFF  twi 5, r10, -1
	// 830F23D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F23DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F23E0: 419A0080  beq cr6, 0x830f2460
	if ctx.cr[6].eq {
	pc = 0x830F2460; continue 'dispatch;
	}
	// 830F23E4: 7F1CC000  cmpw cr6, r28, r24
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F23E8: 419A0078  beq cr6, 0x830f2460
	if ctx.cr[6].eq {
	pc = 0x830F2460; continue 'dispatch;
	}
	// 830F23EC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F23F0: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F23F4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F23F8: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F23FC: 0CC90000  twi 6, r9, 0
	// 830F2400: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F2404: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F2408: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F240C: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F2410: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F2414: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F2418: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F241C: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F2420: 0CAAFFFF  twi 5, r10, -1
	// 830F2424: 932B000C  stw r25, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 830F2428: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F242C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2430: 0CC80000  twi 6, r8, 0
	// 830F2434: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2438: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F243C: 7CEB43D6  divw r7, r11, r8
	ctx.r[7].s32 = ctx.r[11].s32 / ctx.r[8].s32;
	// 830F2440: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830F2444: 7CE741D6  mullw r7, r7, r8
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F2448: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 830F244C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830F2450: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 830F2454: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2458: 7D0A4878  andc r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[9].u64;
	// 830F245C: 480000C0  b 0x830f251c
	pc = 0x830F251C; continue 'dispatch;
	// 830F2460: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2464: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2468: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F246C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2470: 0CC90000  twi 6, r9, 0
	// 830F2474: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F2478: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F247C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2480: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F2484: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F2488: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F248C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2490: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F2494: 0CAAFFFF  twi 5, r10, -1
	// 830F2498: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F249C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F24A0: 409A0084  bne cr6, 0x830f2524
	if !ctx.cr[6].eq {
	pc = 0x830F2524; continue 'dispatch;
	}
	// 830F24A4: 7F1CC000  cmpw cr6, r28, r24
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F24A8: 409A007C  bne cr6, 0x830f2524
	if !ctx.cr[6].eq {
	pc = 0x830F2524; continue 'dispatch;
	}
	// 830F24AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F24B0: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F24B4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F24B8: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F24BC: 0CC90000  twi 6, r9, 0
	// 830F24C0: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F24C4: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F24C8: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F24CC: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F24D0: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F24D4: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F24D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F24DC: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F24E0: 0CAAFFFF  twi 5, r10, -1
	// 830F24E4: 934B000C  stw r26, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830F24E8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F24EC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F24F0: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F24F4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F24F8: 0CC90000  twi 6, r9, 0
	// 830F24FC: 7D684BD6  divw r11, r8, r9
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F2500: 7CEB49D6  mullw r7, r11, r9
	ctx.r[7].s64 = (ctx.r[11].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2504: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F2508: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F250C: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F2510: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F2514: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2518: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F251C: 934B0010  stw r26, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 830F2520: 0CAAFFFF  twi 5, r10, -1
	// 830F2524: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2528: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F252C: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F2530: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2534: 0CC90000  twi 6, r9, 0
	// 830F2538: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F253C: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F2540: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2544: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F2548: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F254C: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F2550: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2554: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F2558: 0CAAFFFF  twi 5, r10, -1
	// 830F255C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F2560: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2564: 419A0248  beq cr6, 0x830f27ac
	if ctx.cr[6].eq {
	pc = 0x830F27AC; continue 'dispatch;
	}
	// 830F2568: 813B00C4  lwz r9, 0xc4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F256C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F2570: 40990158  ble cr6, 0x830f26c8
	if !ctx.cr[6].gt {
	pc = 0x830F26C8; continue 'dispatch;
	}
	// 830F2574: 80FB00C0  lwz r7, 0xc0(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F2578: 397B00BC  addi r11, r27, 0xbc
	ctx.r[11].s64 = ctx.r[27].s64 + 188;
	// 830F257C: 811B00C8  lwz r8, 0xc8(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F2580: 80DB00BC  lwz r6, 0xbc(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F2584: 0CC70000  twi 6, r7, 0
	// 830F2588: 7CA83BD6  divw r5, r8, r7
	ctx.r[5].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830F258C: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F2590: 7CA539D6  mullw r5, r5, r7
	ctx.r[5].s64 = (ctx.r[5].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830F2594: 7D054050  subf r8, r5, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 830F2598: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F259C: 1D080014  mulli r8, r8, 0x14
	ctx.r[8].s64 = ctx.r[8].s64 * 20;
	// 830F25A0: 7D08302E  lwzx r8, r8, r6
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 830F25A4: 7CEA5078  andc r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830F25A8: 7F1C4000  cmpw cr6, r28, r8
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830F25AC: 0CAAFFFF  twi 5, r10, -1
	// 830F25B0: 41980118  blt cr6, 0x830f26c8
	if ctx.cr[6].lt {
	pc = 0x830F26C8; continue 'dispatch;
	}
	// 830F25B4: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F25B8: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F25BC: 0CC70000  twi 6, r7, 0
	// 830F25C0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F25C4: 7CA83BD6  divw r5, r8, r7
	ctx.r[5].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830F25C8: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F25CC: 7CA539D6  mullw r5, r5, r7
	ctx.r[5].s64 = (ctx.r[5].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830F25D0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F25D4: 7D054050  subf r8, r5, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 830F25D8: 7CE75078  andc r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830F25DC: 1D480014  mulli r10, r8, 0x14
	ctx.r[10].s64 = ctx.r[8].s64 * 20;
	// 830F25E0: 7D4A302E  lwzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 830F25E4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F25E8: 0CA7FFFF  twi 5, r7, -1
	// 830F25EC: 7F1C5000  cmpw cr6, r28, r10
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F25F0: 409800D8  bge cr6, 0x830f26c8
	if !ctx.cr[6].lt {
	pc = 0x830F26C8; continue 'dispatch;
	}
	// 830F25F4: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F25F8: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F25FC: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2600: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 830F2604: 7D2733D6  divw r9, r7, r6
	ctx.r[9].s32 = ctx.r[7].s32 / ctx.r[6].s32;
	// 830F2608: 82DF0004  lwz r22, 4(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F260C: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F2610: 7EE931D6  mullw r23, r9, r6
	ctx.r[23].s64 = (ctx.r[9].s32 as i64) * (ctx.r[6].s32 as i64);
	// 830F2614: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2618: 7D773850  subf r11, r23, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[23].s64;
	// 830F261C: 3BAAFFFF  addi r29, r10, -1
	ctx.r[29].s64 = ctx.r[10].s64 + -1;
	// 830F2620: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2624: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 830F2628: 7D6B282E  lwzx r11, r11, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 830F262C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 830F2630: 7CEAF214  add r7, r10, r30
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830F2634: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 830F2638: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 830F263C: 7D47B3D6  divw r10, r7, r22
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[22].s32;
	// 830F2640: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F2644: 7D6AB1D6  mullw r11, r10, r22
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[22].s32 as i64);
	// 830F2648: 7D451BD6  divw r10, r5, r3
	ctx.r[10].s32 = ctx.r[5].s32 / ctx.r[3].s32;
	// 830F264C: 7D6B3850  subf r11, r11, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 830F2650: 7D4A19D6  mullw r10, r10, r3
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[3].s32 as i64);
	// 830F2654: 7C8A2850  subf r4, r10, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 830F2658: 1D4B0014  mulli r10, r11, 0x14
	ctx.r[10].s64 = ctx.r[11].s64 * 20;
	// 830F265C: 1D640014  mulli r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 * 20;
	// 830F2660: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830F2664: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F2668: 54E9083E  rotlwi r9, r7, 1
	ctx.r[9].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F266C: 54A8083E  rotlwi r8, r5, 1
	ctx.r[8].u64 = ((ctx.r[5].u32).rotate_left(1)) as u64;
	// 830F2670: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830F2674: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2678: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 830F267C: 7EC94878  andc r9, r22, r9
	ctx.r[9].u64 = ctx.r[22].u64 & !ctx.r[9].u64;
	// 830F2680: 0CC60000  twi 6, r6, 0
	// 830F2684: 0CA9FFFF  twi 5, r9, -1
	// 830F2688: 7CC6E878  andc r6, r6, r29
	ctx.r[6].u64 = ctx.r[6].u64 & !ctx.r[29].u64;
	// 830F268C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 830F2690: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2694: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F2698: 7C684078  andc r8, r3, r8
	ctx.r[8].u64 = ctx.r[3].u64 & !ctx.r[8].u64;
	// 830F269C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F26A0: 0CD60000  twi 6, r22, 0
	// 830F26A4: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830F26A8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F26AC: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830F26B0: 0CC30000  twi 6, r3, 0
	// 830F26B4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F26B8: 0CA6FFFF  twi 5, r6, -1
	// 830F26BC: 0CA8FFFF  twi 5, r8, -1
	// 830F26C0: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F26C4: 480000E8  b 0x830f27ac
	pc = 0x830F27AC; continue 'dispatch;
	// 830F26C8: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F26CC: C3FB003C  lfs f31, 0x3c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F26D0: C3DB0040  lfs f30, 0x40(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F26D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F26D8: 419A0010  beq cr6, 0x830f26e8
	if ctx.cr[6].eq {
	pc = 0x830F26E8; continue 'dispatch;
	}
	// 830F26DC: 7F1CC000  cmpw cr6, r28, r24
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F26E0: 409A0008  bne cr6, 0x830f26e8
	if !ctx.cr[6].eq {
	pc = 0x830F26E8; continue 'dispatch;
	}
	// 830F26E4: C3FB0050  lfs f31, 0x50(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F26E8: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F26EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F26F0: 419A0010  beq cr6, 0x830f2700
	if ctx.cr[6].eq {
	pc = 0x830F2700; continue 'dispatch;
	}
	// 830F26F4: 7F1CC000  cmpw cr6, r28, r24
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830F26F8: 409A0008  bne cr6, 0x830f2700
	if !ctx.cr[6].eq {
	pc = 0x830F2700; continue 'dispatch;
	}
	// 830F26FC: C3DB004C  lfs f30, 0x4c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F2700: 7D7CC050  subf r11, r28, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[28].s64;
	// 830F2704: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F2708: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F270C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F2710: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F2714: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F2718: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F271C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830F2720: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830F2724: 4BFF4DD5  bl 0x830e74f8
	ctx.lr = 0x830F2728;
	sub_830E74F8(ctx, base);
	// 830F2728: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F272C: 3AE10080  addi r23, r1, 0x80
	ctx.r[23].s64 = ctx.r[1].s64 + 128;
	// 830F2730: 4BFDC4E1  bl 0x830cec10
	ctx.lr = 0x830F2734;
	sub_830CEC10(ctx, base);
	// 830F2734: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830F2738: 4BFE3491  bl 0x830d5bc8
	ctx.lr = 0x830F273C;
	sub_830D5BC8(ctx, base);
	// 830F273C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F2740: 41800020  blt 0x830f2760
	if ctx.cr[0].lt {
	pc = 0x830F2760; continue 'dispatch;
	}
	// 830F2744: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F2748: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F274C: 419A0014  beq cr6, 0x830f2760
	if ctx.cr[6].eq {
	pc = 0x830F2760; continue 'dispatch;
	}
	// 830F2750: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2754: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2758: FFE0E82E  fsel f31, f0, f0, f29
	ctx.f[31].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[29].f64 };
	// 830F275C: FFCDEB6E  fsel f30, f13, f13, f29
	ctx.f[30].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[29].f64 };
	// 830F2760: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2764: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2768: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F276C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2770: 0CC90000  twi 6, r9, 0
	// 830F2774: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F2778: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F277C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2780: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F2784: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 830F2788: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F278C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2790: 7D2A3878  andc r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 830F2794: 0CAAFFFF  twi 5, r10, -1
	// 830F2798: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830F279C: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F27A0: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830F27A4: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 830F27A8: 932B0010  stw r25, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	// 830F27AC: 817B00F0  lwz r11, 0xf0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F27B0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830F27B4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F27B8: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F27BC: 4198FBE4  blt cr6, 0x830f23a0
	if ctx.cr[6].lt {
	pc = 0x830F23A0; continue 'dispatch;
	}
	// 830F27C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F27C4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 830F27C8: CBA1FF90  lfd f29, -0x70(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 830F27CC: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 830F27D0: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 830F27D4: 480B59CC  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F27D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F27D8 size=1296
    let mut pc: u32 = 0x830F27D8;
    'dispatch: loop {
        match pc {
            0x830F27D8 => {
    //   block [0x830F27D8..0x830F2CE8)
	// 830F27D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F27DC: 480B5981  bl 0x831a815c
	ctx.lr = 0x830F27E0;
	sub_831A8130(ctx, base);
	// 830F27E0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 830F27E4: 480B628D  bl 0x831a8a70
	ctx.lr = 0x830F27E8;
	sub_831A8A40(ctx, base);
	// 830F27E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F27EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F27F0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F27F4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830F27F8: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F27FC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F2800: 5579DFFE  rlwinm r25, r11, 0x1b, 0x1f, 0x1f
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F2804: 419A0020  beq cr6, 0x830f2824
	if ctx.cr[6].eq {
	pc = 0x830F2824; continue 'dispatch;
	}
	// 830F2808: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F280C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2810: 41980014  blt cr6, 0x830f2824
	if ctx.cr[6].lt {
	pc = 0x830F2824; continue 'dispatch;
	}
	// 830F2814: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2818: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F281C: 40980008  bge cr6, 0x830f2824
	if !ctx.cr[6].lt {
	pc = 0x830F2824; continue 'dispatch;
	}
	// 830F2820: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 830F2824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2828: 80BF00EC  lwz r5, 0xec(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F282C: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2830: 4BFFF441  bl 0x830f1c70
	ctx.lr = 0x830F2834;
	sub_830F1C70(ctx, base);
	// 830F2834: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F2838: 418004A0  blt 0x830f2cd8
	if ctx.cr[0].lt {
	pc = 0x830F2CD8; continue 'dispatch;
	}
	// 830F283C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F2840: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F2844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2848: 4BFFAD81  bl 0x830ed5c8
	ctx.lr = 0x830F284C;
	sub_830ED5C8(ctx, base);
	// 830F284C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F2850: 419A0018  beq cr6, 0x830f2868
	if ctx.cr[6].eq {
	pc = 0x830F2868; continue 'dispatch;
	}
	// 830F2854: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2858: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F285C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F2860: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2864: 48000014  b 0x830f2878
	pc = 0x830F2878; continue 'dispatch;
	// 830F2868: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F286C: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2870: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F2874: C1BF0088  lfs f13, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F287C: 83BF00E8  lwz r29, 0xe8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2880: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F2884: EF806828  fsubs f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F2888: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830F288C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F2890: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F2894: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830F2898: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 830F289C: 40980298  bge cr6, 0x830f2b34
	if !ctx.cr[6].lt {
	pc = 0x830F2B34; continue 'dispatch;
	}
	// 830F28A0: 3BDF00BC  addi r30, r31, 0xbc
	ctx.r[30].s64 = ctx.r[31].s64 + 188;
	// 830F28A4: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F28A8: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F28AC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F28B0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F28B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830F28B8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F28BC: 0CC80000  twi 6, r8, 0
	// 830F28C0: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830F28C4: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F28C8: 54EB083E  rotlwi r11, r7, 1
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F28CC: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F28D0: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F28D4: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 830F28D8: 1D670014  mulli r11, r7, 0x14
	ctx.r[11].s64 = ctx.r[7].s64 * 20;
	// 830F28DC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F28E0: 7D0A3078  andc r10, r8, r6
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F28E4: 0CAAFFFF  twi 5, r10, -1
	// 830F28E8: E96B0004  ld r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	// 830F28EC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830F28F0: C3610058  lfs f27, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 830F28F4: C341005C  lfs f26, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 830F28F8: 419A000C  beq cr6, 0x830f2904
	if ctx.cr[6].eq {
	pc = 0x830F2904; continue 'dispatch;
	}
	// 830F28FC: FFC0D090  fmr f30, f26
	ctx.f[30].f64 = ctx.f[26].f64;
	// 830F2900: 48000008  b 0x830f2908
	pc = 0x830F2908; continue 'dispatch;
	// 830F2904: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 830F2908: EC1EF82A  fadds f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F290C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 830F2910: 409900CC  ble cr6, 0x830f29dc
	if !ctx.cr[6].gt {
	pc = 0x830F29DC; continue 'dispatch;
	}
	// 830F2914: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830F2918: 409A0214  bne cr6, 0x830f2b2c
	if !ctx.cr[6].eq {
	pc = 0x830F2B2C; continue 'dispatch;
	}
	// 830F291C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830F2920: 419A020C  beq cr6, 0x830f2b2c
	if ctx.cr[6].eq {
	pc = 0x830F2B2C; continue 'dispatch;
	}
	// 830F2924: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 830F2928: 40990014  ble cr6, 0x830f293c
	if !ctx.cr[6].gt {
	pc = 0x830F293C; continue 'dispatch;
	}
	// 830F292C: 93BF00E8  stw r29, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[29].u32 ) };
	// 830F2930: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F2934: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 830F2938: 4800014C  b 0x830f2a84
	pc = 0x830F2A84; continue 'dispatch;
	// 830F293C: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2940: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F2944: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2948: 0CC80000  twi 6, r8, 0
	// 830F294C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2950: 7CE943D6  divw r7, r9, r8
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F2954: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F2958: 7CE741D6  mullw r7, r7, r8
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F295C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F2960: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 830F2964: 7D085878  andc r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830F2968: 1D690014  mulli r11, r9, 0x14
	ctx.r[11].s64 = ctx.r[9].s64 * 20;
	// 830F296C: 0CA8FFFF  twi 5, r8, -1
	// 830F2970: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2974: 419A000C  beq cr6, 0x830f2980
	if ctx.cr[6].eq {
	pc = 0x830F2980; continue 'dispatch;
	}
	// 830F2978: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F297C: 48000008  b 0x830f2984
	pc = 0x830F2984; continue 'dispatch;
	// 830F2980: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2984: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F2988: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F298C: 40990028  ble cr6, 0x830f29b4
	if !ctx.cr[6].gt {
	pc = 0x830F29B4; continue 'dispatch;
	}
	// 830F2990: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F2994: 419A000C  beq cr6, 0x830f29a0
	if ctx.cr[6].eq {
	pc = 0x830F29A0; continue 'dispatch;
	}
	// 830F2998: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F299C: 48000008  b 0x830f29a4
	pc = 0x830F29A4; continue 'dispatch;
	// 830F29A0: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F29A4: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F29A8: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 830F29AC: 40980008  bge cr6, 0x830f29b4
	if !ctx.cr[6].lt {
	pc = 0x830F29B4; continue 'dispatch;
	}
	// 830F29B0: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 830F29B4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F29B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F29BC: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830F29C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F29C4: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 830F29C8: 4BFF3CD1  bl 0x830e6698
	ctx.lr = 0x830F29CC;
	sub_830E6698(ctx, base);
	// 830F29CC: EC1EF82A  fadds f0, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F29D0: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 830F29D4: 4199FF68  bgt cr6, 0x830f293c
	if ctx.cr[6].gt {
	pc = 0x830F293C; continue 'dispatch;
	}
	// 830F29D8: 480000AC  b 0x830f2a84
	pc = 0x830F2A84; continue 'dispatch;
	// 830F29DC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F29E0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F29E4: 409A00A0  bne cr6, 0x830f2a84
	if !ctx.cr[6].eq {
	pc = 0x830F2A84; continue 'dispatch;
	}
	// 830F29E8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830F29EC: 409A0140  bne cr6, 0x830f2b2c
	if !ctx.cr[6].eq {
	pc = 0x830F2B2C; continue 'dispatch;
	}
	// 830F29F0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830F29F4: 419A0138  beq cr6, 0x830f2b2c
	if ctx.cr[6].eq {
	pc = 0x830F2B2C; continue 'dispatch;
	}
	// 830F29F8: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F29FC: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F2A00: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2A04: 0CC70000  twi 6, r7, 0
	// 830F2A08: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2A0C: 7CC83BD6  divw r6, r8, r7
	ctx.r[6].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830F2A10: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F2A14: 7CC639D6  mullw r6, r6, r7
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830F2A18: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F2A1C: 7D064050  subf r8, r6, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 830F2A20: 7CE75878  andc r7, r7, r11
	ctx.r[7].u64 = ctx.r[7].u64 & !ctx.r[11].u64;
	// 830F2A24: 1D680014  mulli r11, r8, 0x14
	ctx.r[11].s64 = ctx.r[8].s64 * 20;
	// 830F2A28: 0CA7FFFF  twi 5, r7, -1
	// 830F2A2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2A30: 419A000C  beq cr6, 0x830f2a3c
	if ctx.cr[6].eq {
	pc = 0x830F2A3C; continue 'dispatch;
	}
	// 830F2A34: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2A38: 48000008  b 0x830f2a40
	pc = 0x830F2A40; continue 'dispatch;
	// 830F2A3C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2A40: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F2A44: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F2A48: 40990028  ble cr6, 0x830f2a70
	if !ctx.cr[6].gt {
	pc = 0x830F2A70; continue 'dispatch;
	}
	// 830F2A4C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F2A50: 419A000C  beq cr6, 0x830f2a5c
	if ctx.cr[6].eq {
	pc = 0x830F2A5C; continue 'dispatch;
	}
	// 830F2A54: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2A58: 48000008  b 0x830f2a60
	pc = 0x830F2A60; continue 'dispatch;
	// 830F2A5C: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2A60: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F2A64: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 830F2A68: 40980008  bge cr6, 0x830f2a70
	if !ctx.cr[6].lt {
	pc = 0x830F2A70; continue 'dispatch;
	}
	// 830F2A6C: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 830F2A70: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 830F2A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F2A78: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 830F2A7C: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830F2A80: 4BFF3C19  bl 0x830e6698
	ctx.lr = 0x830F2A84;
	sub_830E6698(ctx, base);
	// 830F2A84: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830F2A88: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F2A8C: 419A0010  beq cr6, 0x830f2a9c
	if ctx.cr[6].eq {
	pc = 0x830F2A9C; continue 'dispatch;
	}
	// 830F2A90: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2A94: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 830F2A98: 4800000C  b 0x830f2aa4
	pc = 0x830F2AA4; continue 'dispatch;
	// 830F2A9C: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2AA0: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 830F2AA4: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F2AA8: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F2AAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2AB0: 419A0044  beq cr6, 0x830f2af4
	if ctx.cr[6].eq {
	pc = 0x830F2AF4; continue 'dispatch;
	}
	// 830F2AB4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2AB8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2ABC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2AC0: 0CC90000  twi 6, r9, 0
	// 830F2AC4: 7CEA4BD6  divw r7, r10, r9
	ctx.r[7].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F2AC8: 80DF00E8  lwz r6, 0xe8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2ACC: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F2AD0: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2AD4: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 830F2AD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F2ADC: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 830F2AE0: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F2AE4: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F2AE8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830F2AEC: 0CABFFFF  twi 5, r11, -1
	// 830F2AF0: 419A001C  beq cr6, 0x830f2b0c
	if ctx.cr[6].eq {
	pc = 0x830F2B0C; continue 'dispatch;
	}
	// 830F2AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2AF8: 80BF00EC  lwz r5, 0xec(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F2AFC: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2B00: 4BFFF171  bl 0x830f1c70
	ctx.lr = 0x830F2B04;
	sub_830F1C70(ctx, base);
	// 830F2B04: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F2B08: 418001D0  blt 0x830f2cd8
	if ctx.cr[0].lt {
	pc = 0x830F2CD8; continue 'dispatch;
	}
	// 830F2B0C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F2B10: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F2B14: 409A0008  bne cr6, 0x830f2b1c
	if !ctx.cr[6].eq {
	pc = 0x830F2B1C; continue 'dispatch;
	}
	// 830F2B18: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830F2B1C: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F2B20: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F2B24: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F2B28: 4198FD7C  blt cr6, 0x830f28a4
	if ctx.cr[6].lt {
	pc = 0x830F28A4; continue 'dispatch;
	}
	// 830F2B2C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F2B30: 409A0014  bne cr6, 0x830f2b44
	if !ctx.cr[6].eq {
	pc = 0x830F2B44; continue 'dispatch;
	}
	// 830F2B34: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F2B38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2B3C: 40990008  ble cr6, 0x830f2b44
	if !ctx.cr[6].gt {
	pc = 0x830F2B44; continue 'dispatch;
	}
	// 830F2B40: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 830F2B44: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830F2B48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F2B4C: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F2B50: 813F0098  lwz r9, 0x98(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 830F2B54: 811F00AC  lwz r8, 0xac(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F2B58: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830F2B5C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830F2B60: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 830F2B64: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 830F2B68: 40990148  ble cr6, 0x830f2cb0
	if !ctx.cr[6].gt {
	pc = 0x830F2CB0; continue 'dispatch;
	}
	// 830F2B6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F2B70: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2B74: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F2B78: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F2B7C: 40980118  bge cr6, 0x830f2c94
	if !ctx.cr[6].lt {
	pc = 0x830F2C94; continue 'dispatch;
	}
	// 830F2B80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F2B84: 4BFECF1D  bl 0x830dfaa0
	ctx.lr = 0x830F2B88;
	sub_830DFAA0(ctx, base);
	// 830F2B88: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F2B8C: 811F00C0  lwz r8, 0xc0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F2B90: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830F2B94: 7CEAF214  add r7, r10, r30
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830F2B98: 813F00BC  lwz r9, 0xbc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 830F2B9C: 397F00BC  addi r11, r31, 0xbc
	ctx.r[11].s64 = ctx.r[31].s64 + 188;
	// 830F2BA0: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F2BA4: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F2BA8: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F2BAC: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F2BB0: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F2BB4: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830F2BB8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F2BBC: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F2BC0: 0CC80000  twi 6, r8, 0
	// 830F2BC4: 0CA9FFFF  twi 5, r9, -1
	// 830F2BC8: 419A0020  beq cr6, 0x830f2be8
	if ctx.cr[6].eq {
	pc = 0x830F2BE8; continue 'dispatch;
	}
	// 830F2BCC: C18A0008  lfs f12, 8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F2BD0: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2BD4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F2BD8: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2BDC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F2BE0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830F2BE4: 4800001C  b 0x830f2c00
	pc = 0x830F2C00; continue 'dispatch;
	// 830F2BE8: C18A0004  lfs f12, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F2BEC: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2BF0: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F2BF4: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2BF8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F2BFC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830F2C00: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F2C04: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F2C08: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 830F2C0C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2C10: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 830F2C14: 7F6AF214  add r27, r10, r30
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830F2C18: 7D092BD6  divw r8, r9, r5
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[5].s32;
	// 830F2C1C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830F2C20: 7D6829D6  mullw r11, r8, r5
	ctx.r[11].s64 = (ctx.r[8].s32 as i64) * (ctx.r[5].s32 as i64);
	// 830F2C24: 811F00B0  lwz r8, 0xb0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2C28: 7C7D402E  lwzx r3, r29, r8
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830F2C2C: 7CDB23D6  divw r6, r27, r4
	ctx.r[6].s32 = ctx.r[27].s32 / ctx.r[4].s32;
	// 830F2C30: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F2C34: 7D0621D6  mullw r8, r6, r4
	ctx.r[8].s64 = (ctx.r[6].s32 as i64) * (ctx.r[4].s32 as i64);
	// 830F2C38: 7F48D850  subf r26, r8, r27
	ctx.r[26].s64 = ctx.r[27].s64 - ctx.r[8].s64;
	// 830F2C3C: 5526083E  rotlwi r6, r9, 1
	ctx.r[6].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F2C40: 1D0B0014  mulli r8, r11, 0x14
	ctx.r[8].s64 = ctx.r[11].s64 * 20;
	// 830F2C44: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 830F2C48: 5769083E  rotlwi r9, r27, 1
	ctx.r[9].u64 = ((ctx.r[27].u32).rotate_left(1)) as u64;
	// 830F2C4C: 1D7A0014  mulli r11, r26, 0x14
	ctx.r[11].s64 = ctx.r[26].s64 * 20;
	// 830F2C50: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2C54: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 830F2C58: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 830F2C5C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830F2C60: 7CAA3078  andc r10, r5, r6
	ctx.r[10].u64 = ctx.r[5].u64 & !ctx.r[6].u64;
	// 830F2C64: 7C894878  andc r9, r4, r9
	ctx.r[9].u64 = ctx.r[4].u64 & !ctx.r[9].u64;
	// 830F2C68: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F2C6C: 0CC50000  twi 6, r5, 0
	// 830F2C70: C0480008  lfs f2, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F2C74: 0CC40000  twi 6, r4, 0
	// 830F2C78: 0CAAFFFF  twi 5, r10, -1
	// 830F2C7C: 0CA9FFFF  twi 5, r9, -1
	// 830F2C80: 4BFEED89  bl 0x830e1a08
	ctx.lr = 0x830F2C84;
	sub_830E1A08(ctx, base);
	// 830F2C84: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2C88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F2C8C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F2C90: 48000008  b 0x830f2c98
	pc = 0x830F2C98; continue 'dispatch;
	// 830F2C94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F2C98: 4BFF4BE1  bl 0x830e7878
	ctx.lr = 0x830F2C9C;
	sub_830E7878(ctx, base);
	// 830F2C9C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F2CA0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F2CA4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830F2CA8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F2CAC: 4198FEC4  blt cr6, 0x830f2b70
	if ctx.cr[6].lt {
	pc = 0x830F2B70; continue 'dispatch;
	}
	// 830F2CB0: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F2CB4: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2CB8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F2CBC: 41980014  blt cr6, 0x830f2cd0
	if ctx.cr[6].lt {
	pc = 0x830F2CD0; continue 'dispatch;
	}
	// 830F2CC0: 7D2AE214  add r9, r10, r28
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 830F2CC4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F2CC8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F2CCC: 41980008  blt cr6, 0x830f2cd4
	if ctx.cr[6].lt {
	pc = 0x830F2CD4; continue 'dispatch;
	}
	// 830F2CD0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830F2CD4: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 830F2CD8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830F2CDC: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 830F2CE0: 480B5DDD  bl 0x831a8abc
	ctx.lr = 0x830F2CE4;
	sub_831A8A8C(ctx, base);
	// 830F2CE4: 480B54C8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F2CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F2CE8 size=868
    let mut pc: u32 = 0x830F2CE8;
    'dispatch: loop {
        match pc {
            0x830F2CE8 => {
    //   block [0x830F2CE8..0x830F304C)
	// 830F2CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F2CEC: 480B5481  bl 0x831a816c
	ctx.lr = 0x830F2CF0;
	sub_831A8130(ctx, base);
	// 830F2CF0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 830F2CF4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830F2CF8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830F2CFC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F2D00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F2D04: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2D08: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2D0C: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2D10: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F2D14: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F2D18: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F2D1C: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F2D20: 80FF00E4  lwz r7, 0xe4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2D24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F2D28: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F2D2C: 7CEB5878  andc r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & !ctx.r[11].u64;
	// 830F2D30: 7CEA5078  andc r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830F2D34: 7FC93BD6  divw r30, r9, r7
	ctx.r[30].s32 = ctx.r[9].s32 / ctx.r[7].s32;
	// 830F2D38: 0CC70000  twi 6, r7, 0
	// 830F2D3C: 0CABFFFF  twi 5, r11, -1
	// 830F2D40: 7FA83BD6  divw r29, r8, r7
	ctx.r[29].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830F2D44: 0CC70000  twi 6, r7, 0
	// 830F2D48: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 830F2D4C: 0CAAFFFF  twi 5, r10, -1
	// 830F2D50: 4BFFEBD1  bl 0x830f1920
	ctx.lr = 0x830F2D54;
	sub_830F1920(ctx, base);
	// 830F2D54: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F2D58: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 830F2D5C: 409A002C  bne cr6, 0x830f2d88
	if !ctx.cr[6].eq {
	pc = 0x830F2D88; continue 'dispatch;
	}
	// 830F2D60: 811F00E4  lwz r8, 0xe4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2D64: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830F2D68: 7D4343D6  divw r10, r3, r8
	ctx.r[10].s32 = ctx.r[3].s32 / ctx.r[8].s32;
	// 830F2D6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F2D70: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830F2D74: 7D0B5878  andc r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830F2D78: 0CC80000  twi 6, r8, 0
	// 830F2D7C: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F2D80: 0CABFFFF  twi 5, r11, -1
	// 830F2D84: 40980014  bge cr6, 0x830f2d98
	if !ctx.cr[6].lt {
	pc = 0x830F2D98; continue 'dispatch;
	}
	// 830F2D88: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 830F2D8C: 409A0120  bne cr6, 0x830f2eac
	if !ctx.cr[6].eq {
	pc = 0x830F2EAC; continue 'dispatch;
	}
	// 830F2D90: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F2D94: 40990118  ble cr6, 0x830f2eac
	if !ctx.cr[6].gt {
	pc = 0x830F2EAC; continue 'dispatch;
	}
	// 830F2D98: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2D9C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F2DA0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2DA4: 4BFECCAD  bl 0x830dfa50
	ctx.lr = 0x830F2DA8;
	sub_830DFA50(ctx, base);
	// 830F2DA8: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2DAC: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F2DB0: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2DB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F2DB8: 409800F4  bge cr6, 0x830f2eac
	if !ctx.cr[6].lt {
	pc = 0x830F2EAC; continue 'dispatch;
	}
	// 830F2DBC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2DC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F2DC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F2DC8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2DCC: 4BFF4A3D  bl 0x830e7808
	ctx.lr = 0x830F2DD0;
	sub_830E7808(ctx, base);
	// 830F2DD0: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2DD4: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2DD8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2DDC: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2DE0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F2DE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2DE8: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2DEC: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F2DF0: 4BFF4DC1  bl 0x830e7bb0
	ctx.lr = 0x830F2DF4;
	sub_830E7BB0(ctx, base);
	// 830F2DF4: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2DF8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F2DFC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2E00: 4BFECC51  bl 0x830dfa50
	ctx.lr = 0x830F2E04;
	sub_830DFA50(ctx, base);
	// 830F2E04: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2E08: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2E0C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F2E10: 813F00E4  lwz r9, 0xe4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2E14: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F2E18: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2E1C: 7FCA4BD6  divw r30, r10, r9
	ctx.r[30].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F2E20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F2E24: 0CC90000  twi 6, r9, 0
	// 830F2E28: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F2E2C: 0CABFFFF  twi 5, r11, -1
	// 830F2E30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F2E34: 4198FF88  blt cr6, 0x830f2dbc
	if ctx.cr[6].lt {
	pc = 0x830F2DBC; continue 'dispatch;
	}
	// 830F2E38: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F2E3C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F2E40: 409A006C  bne cr6, 0x830f2eac
	if !ctx.cr[6].eq {
	pc = 0x830F2EAC; continue 'dispatch;
	}
	// 830F2E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2E48: 4BFFEAD9  bl 0x830f1920
	ctx.lr = 0x830F2E4C;
	sub_830F1920(ctx, base);
	// 830F2E4C: 813F00E4  lwz r9, 0xe4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2E50: 811F00EC  lwz r8, 0xec(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F2E54: 7D634BD6  divw r11, r3, r9
	ctx.r[11].s32 = ctx.r[3].s32 / ctx.r[9].s32;
	// 830F2E58: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F2E5C: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F2E60: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830F2E64: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F2E68: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F2E6C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2E70: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830F2E74: 388AFFFF  addi r4, r10, -1
	ctx.r[4].s64 = ctx.r[10].s64 + -1;
	// 830F2E78: 7D6649D6  mullw r11, r6, r9
	ctx.r[11].s64 = (ctx.r[6].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F2E7C: 7D474050  subf r10, r7, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F2E80: 7D272878  andc r7, r9, r5
	ctx.r[7].u64 = ctx.r[9].u64 & !ctx.r[5].u64;
	// 830F2E84: 0CC90000  twi 6, r9, 0
	// 830F2E88: 0CC90000  twi 6, r9, 0
	// 830F2E8C: 7D292078  andc r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[4].u64;
	// 830F2E90: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F2E94: 0CA7FFFF  twi 5, r7, -1
	// 830F2E98: 0CA9FFFF  twi 5, r9, -1
	// 830F2E9C: 7F044000  cmpw cr6, r4, r8
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830F2EA0: 419A000C  beq cr6, 0x830f2eac
	if ctx.cr[6].eq {
	pc = 0x830F2EAC; continue 'dispatch;
	}
	// 830F2EA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2EA8: 4BFF4B19  bl 0x830e79c0
	ctx.lr = 0x830F2EAC;
	sub_830E79C0(ctx, base);
	// 830F2EAC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2EB0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F2EB4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2EB8: 4BFECB99  bl 0x830dfa50
	ctx.lr = 0x830F2EBC;
	sub_830DFA50(ctx, base);
	// 830F2EBC: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2EC0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F2EC4: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2EC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F2ECC: 40980078  bge cr6, 0x830f2f44
	if !ctx.cr[6].lt {
	pc = 0x830F2F44; continue 'dispatch;
	}
	// 830F2ED0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F2ED4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F2ED8: 409A0010  bne cr6, 0x830f2ee8
	if !ctx.cr[6].eq {
	pc = 0x830F2EE8; continue 'dispatch;
	}
	// 830F2EDC: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F2EE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F2EE4: 4BFF4ADD  bl 0x830e79c0
	ctx.lr = 0x830F2EE8;
	sub_830E79C0(ctx, base);
	// 830F2EE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F2EEC: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2EF0: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2EF4: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2EF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F2EFC: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F2F00: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F2F04: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 830F2F08: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2F0C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2F10: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830F2F14: 40990120  ble cr6, 0x830f3034
	if !ctx.cr[6].gt {
	pc = 0x830F3034; continue 'dispatch;
	}
	// 830F2F18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F2F1C: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F2F20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F2F24: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F2F28: 4BFF4951  bl 0x830e7878
	ctx.lr = 0x830F2F2C;
	sub_830E7878(ctx, base);
	// 830F2F2C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2F30: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F2F34: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F2F38: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F2F3C: 4198FFE0  blt cr6, 0x830f2f1c
	if ctx.cr[6].lt {
	pc = 0x830F2F1C; continue 'dispatch;
	}
	// 830F2F40: 480000F4  b 0x830f3034
	pc = 0x830F3034; continue 'dispatch;
	// 830F2F44: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F2F48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2F4C: 409900E8  ble cr6, 0x830f3034
	if !ctx.cr[6].gt {
	pc = 0x830F3034; continue 'dispatch;
	}
	// 830F2F50: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F2F54: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2F58: 409A000C  bne cr6, 0x830f2f64
	if !ctx.cr[6].eq {
	pc = 0x830F2F64; continue 'dispatch;
	}
	// 830F2F5C: C3BF003C  lfs f29, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830F2F60: 48000008  b 0x830f2f68
	pc = 0x830F2F68; continue 'dispatch;
	// 830F2F64: C3BF0034  lfs f29, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830F2F68: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F2F6C: C3DF0038  lfs f30, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F2F70: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830F2F74: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F2F78: 419A001C  beq cr6, 0x830f2f94
	if ctx.cr[6].eq {
	pc = 0x830F2F94; continue 'dispatch;
	}
	// 830F2F7C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830F2F80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F2F84: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 830F2F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F2F8C: 4BFFA8ED  bl 0x830ed878
	ctx.lr = 0x830F2F90;
	sub_830ED878(ctx, base);
	// 830F2F90: C3C10050  lfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F2F94: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F2F98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F2F9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F2FA0: 40990094  ble cr6, 0x830f3034
	if !ctx.cr[6].gt {
	pc = 0x830F3034; continue 'dispatch;
	}
	// 830F2FA4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F2FA8: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F2FAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F2FB0: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F2FB4: 4BFF48C5  bl 0x830e7878
	ctx.lr = 0x830F2FB8;
	sub_830E7878(ctx, base);
	// 830F2FB8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F2FBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F2FC0: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F2FC4: 4BFECA8D  bl 0x830dfa50
	ctx.lr = 0x830F2FC8;
	sub_830DFA50(ctx, base);
	// 830F2FC8: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F2FCC: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F2FD0: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 830F2FD4: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F2FD8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F2FDC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F2FE0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F2FE4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830F2FE8: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F2FEC: 4BFECAB5  bl 0x830dfaa0
	ctx.lr = 0x830F2FF0;
	sub_830DFAA0(ctx, base);
	// 830F2FF0: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F2FF4: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F2FF8: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F2FFC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 830F3000: 4BFEEA09  bl 0x830e1a08
	ctx.lr = 0x830F3004;
	sub_830E1A08(ctx, base);
	// 830F3004: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F3008: 813F00B8  lwz r9, 0xb8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F300C: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3010: 7D6BE850  subf r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 830F3014: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F3018: 7C7E482E  lwzx r3, r30, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830F301C: 4BFEC105  bl 0x830df120
	ctx.lr = 0x830F3020;
	sub_830DF120(ctx, base);
	// 830F3020: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F3024: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F3028: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F302C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3030: 4198FF78  blt cr6, 0x830f2fa8
	if ctx.cr[6].lt {
	pc = 0x830F2FA8; continue 'dispatch;
	}
	// 830F3034: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F3038: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F303C: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830F3040: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F3044: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830F3048: 480B5174  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F3050 size=692
    let mut pc: u32 = 0x830F3050;
    'dispatch: loop {
        match pc {
            0x830F3050 => {
    //   block [0x830F3050..0x830F3304)
	// 830F3050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3054: 480B5115  bl 0x831a8168
	ctx.lr = 0x830F3058;
	sub_831A8130(ctx, base);
	// 830F3058: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830F305C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3064: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3068: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F306C: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F3070: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3074: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F3078: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F307C: 409800B8  bge cr6, 0x830f3134
	if !ctx.cr[6].lt {
	pc = 0x830F3134; continue 'dispatch;
	}
	// 830F3080: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3084: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F3088: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F308C: 4BFEC9C5  bl 0x830dfa50
	ctx.lr = 0x830F3090;
	sub_830DFA50(ctx, base);
	// 830F3090: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3094: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3098: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F309C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F30A0: 40990094  ble cr6, 0x830f3134
	if !ctx.cr[6].gt {
	pc = 0x830F3134; continue 'dispatch;
	}
	// 830F30A4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F30A8: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F30AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F30B0: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F30B4: 4BFF4AFD  bl 0x830e7bb0
	ctx.lr = 0x830F30B8;
	sub_830E7BB0(ctx, base);
	// 830F30B8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F30BC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830F30C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F30C4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F30C8: 4BFF4741  bl 0x830e7808
	ctx.lr = 0x830F30CC;
	sub_830E7808(ctx, base);
	// 830F30CC: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F30D0: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F30D4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F30D8: C19F0094  lfs f12, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F30DC: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F30E0: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F30E4: EC0DF82A  fadds f0, f13, f31
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F30E8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830F30EC: 4199FFB8  bgt cr6, 0x830f30a4
	if ctx.cr[6].gt {
	pc = 0x830F30A4; continue 'dispatch;
	}
	// 830F30F0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F30F4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F30F8: 409A003C  bne cr6, 0x830f3134
	if !ctx.cr[6].eq {
	pc = 0x830F3134; continue 'dispatch;
	}
	// 830F30FC: 813F00EC  lwz r9, 0xec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3100: 811F00E4  lwz r8, 0xe4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F3104: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F3108: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F310C: 7CE943D6  divw r7, r9, r8
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F3110: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3114: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 830F3118: 7D6741D6  mullw r11, r7, r8
	ctx.r[11].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F311C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F3120: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F3124: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F3128: 0CC80000  twi 6, r8, 0
	// 830F312C: 0CA9FFFF  twi 5, r9, -1
	// 830F3130: 4BFF4891  bl 0x830e79c0
	ctx.lr = 0x830F3134;
	sub_830E79C0(ctx, base);
	// 830F3134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3138: 4BFFE7E9  bl 0x830f1920
	ctx.lr = 0x830F313C;
	sub_830F1920(ctx, base);
	// 830F313C: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3140: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F3144: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F3148: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F314C: 4BFEC905  bl 0x830dfa50
	ctx.lr = 0x830F3150;
	sub_830DFA50(ctx, base);
	// 830F3150: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3154: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3158: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F315C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F3160: 40990078  ble cr6, 0x830f31d8
	if !ctx.cr[6].gt {
	pc = 0x830F31D8; continue 'dispatch;
	}
	// 830F3164: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3168: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F316C: 409A0010  bne cr6, 0x830f317c
	if !ctx.cr[6].eq {
	pc = 0x830F317C; continue 'dispatch;
	}
	// 830F3170: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F3174: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3178: 4BFF4849  bl 0x830e79c0
	ctx.lr = 0x830F317C;
	sub_830E79C0(ctx, base);
	// 830F317C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F3180: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3184: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3188: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F318C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F3190: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F3194: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F3198: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 830F319C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F31A0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F31A4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830F31A8: 4099014C  ble cr6, 0x830f32f4
	if !ctx.cr[6].gt {
	pc = 0x830F32F4; continue 'dispatch;
	}
	// 830F31AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F31B0: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F31B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F31B8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F31BC: 4BFF46BD  bl 0x830e7878
	ctx.lr = 0x830F31C0;
	sub_830E7878(ctx, base);
	// 830F31C0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F31C4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F31C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F31CC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F31D0: 4198FFE0  blt cr6, 0x830f31b0
	if ctx.cr[6].lt {
	pc = 0x830F31B0; continue 'dispatch;
	}
	// 830F31D4: 48000120  b 0x830f32f4
	pc = 0x830F32F4; continue 'dispatch;
	// 830F31D8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F31DC: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F31E0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F31E4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F31E8: 4098010C  bge cr6, 0x830f32f4
	if !ctx.cr[6].lt {
	pc = 0x830F32F4; continue 'dispatch;
	}
	// 830F31EC: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F31F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F31F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F31F8: 409900FC  ble cr6, 0x830f32f4
	if !ctx.cr[6].gt {
	pc = 0x830F32F4; continue 'dispatch;
	}
	// 830F31FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F3200: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3204: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F3208: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F320C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F3210: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F3214: 409800E0  bge cr6, 0x830f32f4
	if !ctx.cr[6].lt {
	pc = 0x830F32F4; continue 'dispatch;
	}
	// 830F3218: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F321C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F3220: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F3224: 4BFF4655  bl 0x830e7878
	ctx.lr = 0x830F3228;
	sub_830E7878(ctx, base);
	// 830F3228: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F322C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F3230: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3234: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 830F3238: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F323C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F3240: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830F3244: 4BFEC80D  bl 0x830dfa50
	ctx.lr = 0x830F3248;
	sub_830DFA50(ctx, base);
	// 830F3248: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F324C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F3250: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3254: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F3258: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 830F325C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F3260: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F3264: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830F3268: 4BFF45A1  bl 0x830e7808
	ctx.lr = 0x830F326C;
	sub_830E7808(ctx, base);
	// 830F326C: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3270: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F3274: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3278: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F327C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F3280: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3284: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F3288: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F328C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830F3290: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F3294: 4BFEC80D  bl 0x830dfaa0
	ctx.lr = 0x830F3298;
	sub_830DFAA0(ctx, base);
	// 830F3298: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F329C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F32A0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830F32A4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830F32A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F32AC: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F32B0: 4BFFA5C9  bl 0x830ed878
	ctx.lr = 0x830F32B4;
	sub_830ED878(ctx, base);
	// 830F32B4: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F32B8: C0410050  lfs f2, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F32BC: C0210054  lfs f1, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F32C0: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F32C4: 4BFEE745  bl 0x830e1a08
	ctx.lr = 0x830F32C8;
	sub_830E1A08(ctx, base);
	// 830F32C8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F32CC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F32D0: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F32D4: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F32D8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F32DC: 4BFEBE45  bl 0x830df120
	ctx.lr = 0x830F32E0;
	sub_830DF120(ctx, base);
	// 830F32E0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F32E4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F32E8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830F32EC: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F32F0: 4198FF10  blt cr6, 0x830f3200
	if ctx.cr[6].lt {
	pc = 0x830F3200; continue 'dispatch;
	}
	// 830F32F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F32F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F32FC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F3300: 480B4EB8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F3308 size=868
    let mut pc: u32 = 0x830F3308;
    'dispatch: loop {
        match pc {
            0x830F3308 => {
    //   block [0x830F3308..0x830F366C)
	// 830F3308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F330C: 480B4E61  bl 0x831a816c
	ctx.lr = 0x830F3310;
	sub_831A8130(ctx, base);
	// 830F3310: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 830F3314: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830F3318: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830F331C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3320: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3324: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3328: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F332C: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3330: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F3334: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F3338: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F333C: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F3340: 80FF00E0  lwz r7, 0xe0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3344: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3348: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F334C: 7CEB5878  andc r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & !ctx.r[11].u64;
	// 830F3350: 7CEA5078  andc r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830F3354: 7FC93BD6  divw r30, r9, r7
	ctx.r[30].s32 = ctx.r[9].s32 / ctx.r[7].s32;
	// 830F3358: 0CC70000  twi 6, r7, 0
	// 830F335C: 0CABFFFF  twi 5, r11, -1
	// 830F3360: 7FA83BD6  divw r29, r8, r7
	ctx.r[29].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830F3364: 0CC70000  twi 6, r7, 0
	// 830F3368: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 830F336C: 0CAAFFFF  twi 5, r10, -1
	// 830F3370: 4BFFE5B1  bl 0x830f1920
	ctx.lr = 0x830F3374;
	sub_830F1920(ctx, base);
	// 830F3374: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3378: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 830F337C: 409A002C  bne cr6, 0x830f33a8
	if !ctx.cr[6].eq {
	pc = 0x830F33A8; continue 'dispatch;
	}
	// 830F3380: 811F00E0  lwz r8, 0xe0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3384: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830F3388: 7D4343D6  divw r10, r3, r8
	ctx.r[10].s32 = ctx.r[3].s32 / ctx.r[8].s32;
	// 830F338C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3390: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830F3394: 7D0B5878  andc r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 & !ctx.r[11].u64;
	// 830F3398: 0CC80000  twi 6, r8, 0
	// 830F339C: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F33A0: 0CABFFFF  twi 5, r11, -1
	// 830F33A4: 40980014  bge cr6, 0x830f33b8
	if !ctx.cr[6].lt {
	pc = 0x830F33B8; continue 'dispatch;
	}
	// 830F33A8: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 830F33AC: 409A0120  bne cr6, 0x830f34cc
	if !ctx.cr[6].eq {
	pc = 0x830F34CC; continue 'dispatch;
	}
	// 830F33B0: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F33B4: 40990118  ble cr6, 0x830f34cc
	if !ctx.cr[6].gt {
	pc = 0x830F34CC; continue 'dispatch;
	}
	// 830F33B8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F33BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F33C0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F33C4: 4BFEC68D  bl 0x830dfa50
	ctx.lr = 0x830F33C8;
	sub_830DFA50(ctx, base);
	// 830F33C8: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F33CC: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F33D0: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F33D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F33D8: 409800F4  bge cr6, 0x830f34cc
	if !ctx.cr[6].lt {
	pc = 0x830F34CC; continue 'dispatch;
	}
	// 830F33DC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F33E0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830F33E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F33E8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F33EC: 4BFF441D  bl 0x830e7808
	ctx.lr = 0x830F33F0;
	sub_830E7808(ctx, base);
	// 830F33F0: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F33F4: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F33F8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F33FC: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3400: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F3404: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3408: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F340C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3410: 4BFF47A1  bl 0x830e7bb0
	ctx.lr = 0x830F3414;
	sub_830E7BB0(ctx, base);
	// 830F3414: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3418: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F341C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3420: 4BFEC631  bl 0x830dfa50
	ctx.lr = 0x830F3424;
	sub_830DFA50(ctx, base);
	// 830F3424: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3428: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F342C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3430: 813F00E0  lwz r9, 0xe0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3434: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F3438: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F343C: 7FCA4BD6  divw r30, r10, r9
	ctx.r[30].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F3440: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3444: 0CC90000  twi 6, r9, 0
	// 830F3448: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F344C: 0CABFFFF  twi 5, r11, -1
	// 830F3450: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F3454: 4198FF88  blt cr6, 0x830f33dc
	if ctx.cr[6].lt {
	pc = 0x830F33DC; continue 'dispatch;
	}
	// 830F3458: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F345C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F3460: 409A006C  bne cr6, 0x830f34cc
	if !ctx.cr[6].eq {
	pc = 0x830F34CC; continue 'dispatch;
	}
	// 830F3464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3468: 4BFFE4B9  bl 0x830f1920
	ctx.lr = 0x830F346C;
	sub_830F1920(ctx, base);
	// 830F346C: 813F00E0  lwz r9, 0xe0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3470: 811F00EC  lwz r8, 0xec(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3474: 7D634BD6  divw r11, r3, r9
	ctx.r[11].s32 = ctx.r[3].s32 / ctx.r[9].s32;
	// 830F3478: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F347C: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F3480: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830F3484: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F3488: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F348C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F3490: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830F3494: 388AFFFF  addi r4, r10, -1
	ctx.r[4].s64 = ctx.r[10].s64 + -1;
	// 830F3498: 7D6649D6  mullw r11, r6, r9
	ctx.r[11].s64 = (ctx.r[6].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F349C: 7D474050  subf r10, r7, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F34A0: 7D272878  andc r7, r9, r5
	ctx.r[7].u64 = ctx.r[9].u64 & !ctx.r[5].u64;
	// 830F34A4: 0CC90000  twi 6, r9, 0
	// 830F34A8: 0CC90000  twi 6, r9, 0
	// 830F34AC: 7D292078  andc r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[4].u64;
	// 830F34B0: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F34B4: 0CA7FFFF  twi 5, r7, -1
	// 830F34B8: 0CA9FFFF  twi 5, r9, -1
	// 830F34BC: 7F044000  cmpw cr6, r4, r8
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830F34C0: 419A000C  beq cr6, 0x830f34cc
	if ctx.cr[6].eq {
	pc = 0x830F34CC; continue 'dispatch;
	}
	// 830F34C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F34C8: 4BFF44F9  bl 0x830e79c0
	ctx.lr = 0x830F34CC;
	sub_830E79C0(ctx, base);
	// 830F34CC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F34D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F34D4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F34D8: 4BFEC579  bl 0x830dfa50
	ctx.lr = 0x830F34DC;
	sub_830DFA50(ctx, base);
	// 830F34DC: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F34E0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F34E4: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F34E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F34EC: 40980078  bge cr6, 0x830f3564
	if !ctx.cr[6].lt {
	pc = 0x830F3564; continue 'dispatch;
	}
	// 830F34F0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F34F4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F34F8: 409A0010  bne cr6, 0x830f3508
	if !ctx.cr[6].eq {
	pc = 0x830F3508; continue 'dispatch;
	}
	// 830F34FC: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F3500: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3504: 4BFF44BD  bl 0x830e79c0
	ctx.lr = 0x830F3508;
	sub_830E79C0(ctx, base);
	// 830F3508: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F350C: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3510: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3514: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3518: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F351C: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F3520: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F3524: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 830F3528: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F352C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3530: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830F3534: 40990120  ble cr6, 0x830f3654
	if !ctx.cr[6].gt {
	pc = 0x830F3654; continue 'dispatch;
	}
	// 830F3538: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F353C: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F3540: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F3544: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F3548: 4BFF4331  bl 0x830e7878
	ctx.lr = 0x830F354C;
	sub_830E7878(ctx, base);
	// 830F354C: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3550: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F3554: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F3558: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F355C: 4198FFE0  blt cr6, 0x830f353c
	if ctx.cr[6].lt {
	pc = 0x830F353C; continue 'dispatch;
	}
	// 830F3560: 480000F4  b 0x830f3654
	pc = 0x830F3654; continue 'dispatch;
	// 830F3564: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3568: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F356C: 409900E8  ble cr6, 0x830f3654
	if !ctx.cr[6].gt {
	pc = 0x830F3654; continue 'dispatch;
	}
	// 830F3570: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F3574: C3BF0034  lfs f29, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830F3578: D3A10050  stfs f29, 0x50(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830F357C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F3580: 419A001C  beq cr6, 0x830f359c
	if ctx.cr[6].eq {
	pc = 0x830F359C; continue 'dispatch;
	}
	// 830F3584: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F3588: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F358C: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 830F3590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3594: 4BFFA2E5  bl 0x830ed878
	ctx.lr = 0x830F3598;
	sub_830ED878(ctx, base);
	// 830F3598: C3A10050  lfs f29, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830F359C: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F35A0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F35A4: 409A000C  bne cr6, 0x830f35b0
	if !ctx.cr[6].eq {
	pc = 0x830F35B0; continue 'dispatch;
	}
	// 830F35A8: C3DF0040  lfs f30, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F35AC: 48000008  b 0x830f35b4
	pc = 0x830F35B4; continue 'dispatch;
	// 830F35B0: C3DF0038  lfs f30, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F35B4: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F35B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F35BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F35C0: 40990094  ble cr6, 0x830f3654
	if !ctx.cr[6].gt {
	pc = 0x830F3654; continue 'dispatch;
	}
	// 830F35C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F35C8: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F35CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F35D0: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F35D4: 4BFF42A5  bl 0x830e7878
	ctx.lr = 0x830F35D8;
	sub_830E7878(ctx, base);
	// 830F35D8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F35DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F35E0: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F35E4: 4BFEC46D  bl 0x830dfa50
	ctx.lr = 0x830F35E8;
	sub_830DFA50(ctx, base);
	// 830F35E8: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F35EC: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F35F0: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 830F35F4: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F35F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F35FC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F3600: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3604: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830F3608: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F360C: 4BFEC495  bl 0x830dfaa0
	ctx.lr = 0x830F3610;
	sub_830DFAA0(ctx, base);
	// 830F3610: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F3614: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F3618: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F361C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 830F3620: 4BFEE3E9  bl 0x830e1a08
	ctx.lr = 0x830F3624;
	sub_830E1A08(ctx, base);
	// 830F3624: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3628: 813F00B8  lwz r9, 0xb8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F362C: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3630: 7D6BE850  subf r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 830F3634: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F3638: 7C7E482E  lwzx r3, r30, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830F363C: 4BFEBAE5  bl 0x830df120
	ctx.lr = 0x830F3640;
	sub_830DF120(ctx, base);
	// 830F3640: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3644: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F3648: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F364C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3650: 4198FF78  blt cr6, 0x830f35c8
	if ctx.cr[6].lt {
	pc = 0x830F35C8; continue 'dispatch;
	}
	// 830F3654: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F3658: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F365C: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830F3660: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F3664: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830F3668: 480B4B54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F3670 size=692
    let mut pc: u32 = 0x830F3670;
    'dispatch: loop {
        match pc {
            0x830F3670 => {
    //   block [0x830F3670..0x830F3924)
	// 830F3670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3674: 480B4AF5  bl 0x831a8168
	ctx.lr = 0x830F3678;
	sub_831A8130(ctx, base);
	// 830F3678: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830F367C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3684: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3688: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F368C: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F3690: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3694: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F3698: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F369C: 409800B8  bge cr6, 0x830f3754
	if !ctx.cr[6].lt {
	pc = 0x830F3754; continue 'dispatch;
	}
	// 830F36A0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F36A4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F36A8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F36AC: 4BFEC3A5  bl 0x830dfa50
	ctx.lr = 0x830F36B0;
	sub_830DFA50(ctx, base);
	// 830F36B0: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F36B4: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F36B8: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F36BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F36C0: 40990094  ble cr6, 0x830f3754
	if !ctx.cr[6].gt {
	pc = 0x830F3754; continue 'dispatch;
	}
	// 830F36C4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F36C8: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F36CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F36D0: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F36D4: 4BFF44DD  bl 0x830e7bb0
	ctx.lr = 0x830F36D8;
	sub_830E7BB0(ctx, base);
	// 830F36D8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F36DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F36E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F36E4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F36E8: 4BFF4121  bl 0x830e7808
	ctx.lr = 0x830F36EC;
	sub_830E7808(ctx, base);
	// 830F36EC: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F36F0: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F36F4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F36F8: C19F0090  lfs f12, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F36FC: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F3700: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3704: EC0DF82A  fadds f0, f13, f31
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3708: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830F370C: 4199FFB8  bgt cr6, 0x830f36c4
	if ctx.cr[6].gt {
	pc = 0x830F36C4; continue 'dispatch;
	}
	// 830F3710: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3714: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F3718: 409A003C  bne cr6, 0x830f3754
	if !ctx.cr[6].eq {
	pc = 0x830F3754; continue 'dispatch;
	}
	// 830F371C: 813F00EC  lwz r9, 0xec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3720: 811F00E0  lwz r8, 0xe0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3724: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F3728: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F372C: 7CE943D6  divw r7, r9, r8
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F3730: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3734: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 830F3738: 7D6741D6  mullw r11, r7, r8
	ctx.r[11].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F373C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F3740: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F3744: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F3748: 0CC80000  twi 6, r8, 0
	// 830F374C: 0CA9FFFF  twi 5, r9, -1
	// 830F3750: 4BFF4271  bl 0x830e79c0
	ctx.lr = 0x830F3754;
	sub_830E79C0(ctx, base);
	// 830F3754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3758: 4BFFE1C9  bl 0x830f1920
	ctx.lr = 0x830F375C;
	sub_830F1920(ctx, base);
	// 830F375C: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3760: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F3764: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F3768: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F376C: 4BFEC2E5  bl 0x830dfa50
	ctx.lr = 0x830F3770;
	sub_830DFA50(ctx, base);
	// 830F3770: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3774: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3778: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F377C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F3780: 40990078  ble cr6, 0x830f37f8
	if !ctx.cr[6].gt {
	pc = 0x830F37F8; continue 'dispatch;
	}
	// 830F3784: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3788: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F378C: 409A0010  bne cr6, 0x830f379c
	if !ctx.cr[6].eq {
	pc = 0x830F379C; continue 'dispatch;
	}
	// 830F3790: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F3794: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3798: 4BFF4229  bl 0x830e79c0
	ctx.lr = 0x830F379C;
	sub_830E79C0(ctx, base);
	// 830F379C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F37A0: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F37A4: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F37A8: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F37AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F37B0: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F37B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F37B8: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 830F37BC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F37C0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F37C4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830F37C8: 4099014C  ble cr6, 0x830f3914
	if !ctx.cr[6].gt {
	pc = 0x830F3914; continue 'dispatch;
	}
	// 830F37CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F37D0: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F37D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F37D8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F37DC: 4BFF409D  bl 0x830e7878
	ctx.lr = 0x830F37E0;
	sub_830E7878(ctx, base);
	// 830F37E0: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F37E4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F37E8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F37EC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F37F0: 4198FFE0  blt cr6, 0x830f37d0
	if ctx.cr[6].lt {
	pc = 0x830F37D0; continue 'dispatch;
	}
	// 830F37F4: 48000120  b 0x830f3914
	pc = 0x830F3914; continue 'dispatch;
	// 830F37F8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F37FC: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F3800: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F3804: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F3808: 4098010C  bge cr6, 0x830f3914
	if !ctx.cr[6].lt {
	pc = 0x830F3914; continue 'dispatch;
	}
	// 830F380C: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3810: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F3814: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3818: 409900FC  ble cr6, 0x830f3914
	if !ctx.cr[6].gt {
	pc = 0x830F3914; continue 'dispatch;
	}
	// 830F381C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F3820: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3824: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F3828: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F382C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F3830: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F3834: 409800E0  bge cr6, 0x830f3914
	if !ctx.cr[6].lt {
	pc = 0x830F3914; continue 'dispatch;
	}
	// 830F3838: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F383C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F3840: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F3844: 4BFF4035  bl 0x830e7878
	ctx.lr = 0x830F3848;
	sub_830E7878(ctx, base);
	// 830F3848: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F384C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F3850: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3854: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 830F3858: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F385C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F3860: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830F3864: 4BFEC1ED  bl 0x830dfa50
	ctx.lr = 0x830F3868;
	sub_830DFA50(ctx, base);
	// 830F3868: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F386C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830F3870: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3874: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F3878: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 830F387C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F3880: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F3884: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830F3888: 4BFF3F81  bl 0x830e7808
	ctx.lr = 0x830F388C;
	sub_830E7808(ctx, base);
	// 830F388C: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3890: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F3894: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3898: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F389C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F38A0: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F38A4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F38A8: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F38AC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830F38B0: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F38B4: 4BFEC1ED  bl 0x830dfaa0
	ctx.lr = 0x830F38B8;
	sub_830DFAA0(ctx, base);
	// 830F38B8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F38BC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F38C0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 830F38C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F38C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F38CC: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F38D0: 4BFF9FA9  bl 0x830ed878
	ctx.lr = 0x830F38D4;
	sub_830ED878(ctx, base);
	// 830F38D4: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F38D8: C0410054  lfs f2, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F38DC: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F38E0: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F38E4: 4BFEE125  bl 0x830e1a08
	ctx.lr = 0x830F38E8;
	sub_830E1A08(ctx, base);
	// 830F38E8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F38EC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F38F0: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830F38F4: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F38F8: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830F38FC: 4BFEB825  bl 0x830df120
	ctx.lr = 0x830F3900;
	sub_830DF120(ctx, base);
	// 830F3900: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3904: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F3908: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830F390C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3910: 4198FF10  blt cr6, 0x830f3820
	if ctx.cr[6].lt {
	pc = 0x830F3820; continue 'dispatch;
	}
	// 830F3914: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F3918: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F391C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F3920: 480B4898  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F3928 size=384
    let mut pc: u32 = 0x830F3928;
    'dispatch: loop {
        match pc {
            0x830F3928 => {
    //   block [0x830F3928..0x830F3AA8)
	// 830F3928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F392C: 480B4841  bl 0x831a816c
	ctx.lr = 0x830F3930;
	sub_831A8130(ctx, base);
	// 830F3930: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830F3934: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830F3938: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F393C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3940: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3944: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3948: 409A0014  bne cr6, 0x830f395c
	if !ctx.cr[6].eq {
	pc = 0x830F395C; continue 'dispatch;
	}
	// 830F394C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F3950: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3954: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830F3958: 48000140  b 0x830f3a98
	pc = 0x830F3A98; continue 'dispatch;
	// 830F395C: 480D1705  bl 0x831c5060
	ctx.lr = 0x830F3960;
	sub_831C5060(ctx, base);
	// 830F3960: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F3964: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F3968: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830F396C: 40980008  bge cr6, 0x830f3974
	if !ctx.cr[6].lt {
	pc = 0x830F3974; continue 'dispatch;
	}
	// 830F3970: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3974: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 830F3978: 40990008  ble cr6, 0x830f3980
	if !ctx.cr[6].gt {
	pc = 0x830F3980; continue 'dispatch;
	}
	// 830F397C: 39600022  li r11, 0x22
	ctx.r[11].s64 = 34;
	// 830F3980: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830F3984: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F3988: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830F398C: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 830F3990: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830F3994: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F3998: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F399C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F39A0: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F39A4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F39A8: C1A99F7C  lfs f13, -0x6084(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F39AC: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 830F39B0: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 830F39B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F39B8: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F39BC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830F39C0: 419A004C  beq cr6, 0x830f3a0c
	if ctx.cr[6].eq {
	pc = 0x830F3A0C; continue 'dispatch;
	}
	// 830F39C4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F39C8: 419A0044  beq cr6, 0x830f3a0c
	if ctx.cr[6].eq {
	pc = 0x830F3A0C; continue 'dispatch;
	}
	// 830F39CC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F39D0: 419A000C  beq cr6, 0x830f39dc
	if ctx.cr[6].eq {
	pc = 0x830F39DC; continue 'dispatch;
	}
	// 830F39D4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830F39D8: 409A0060  bne cr6, 0x830f3a38
	if !ctx.cr[6].eq {
	pc = 0x830F3A38; continue 'dispatch;
	}
	// 830F39DC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F39E0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F39E4: 419A001C  beq cr6, 0x830f3a00
	if ctx.cr[6].eq {
	pc = 0x830F3A00; continue 'dispatch;
	}
	// 830F39E8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F39EC: 419A0014  beq cr6, 0x830f3a00
	if ctx.cr[6].eq {
	pc = 0x830F3A00; continue 'dispatch;
	}
	// 830F39F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F39F4: 4BFFFC7D  bl 0x830f3670
	ctx.lr = 0x830F39F8;
	sub_830F3670(ctx, base);
	// 830F39F8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 830F39FC: 4800003C  b 0x830f3a38
	pc = 0x830F3A38; continue 'dispatch;
	// 830F3A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3A04: 4BFFF905  bl 0x830f3308
	ctx.lr = 0x830F3A08;
	sub_830F3308(ctx, base);
	// 830F3A08: 4BFFFFF0  b 0x830f39f8
	pc = 0x830F39F8; continue 'dispatch;
	// 830F3A0C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3A10: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F3A14: 419A0018  beq cr6, 0x830f3a2c
	if ctx.cr[6].eq {
	pc = 0x830F3A2C; continue 'dispatch;
	}
	// 830F3A18: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F3A1C: 419A0010  beq cr6, 0x830f3a2c
	if ctx.cr[6].eq {
	pc = 0x830F3A2C; continue 'dispatch;
	}
	// 830F3A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3A24: 4BFFF62D  bl 0x830f3050
	ctx.lr = 0x830F3A28;
	sub_830F3050(ctx, base);
	// 830F3A28: 4800000C  b 0x830f3a34
	pc = 0x830F3A34; continue 'dispatch;
	// 830F3A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3A30: 4BFFF2B9  bl 0x830f2ce8
	ctx.lr = 0x830F3A34;
	sub_830F2CE8(ctx, base);
	// 830F3A34: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830F3A38: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F3A3C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F3A40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3A44: 40990054  ble cr6, 0x830f3a98
	if !ctx.cr[6].gt {
	pc = 0x830F3A98; continue 'dispatch;
	}
	// 830F3A48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F3A4C: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3A50: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F3A54: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F3A58: 4BFEBFF9  bl 0x830dfa50
	ctx.lr = 0x830F3A5C;
	sub_830DFA50(ctx, base);
	// 830F3A5C: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3A60: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F3A64: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F3A68: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F3A6C: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 830F3A70: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830F3A74: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830F3A78: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F3A7C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830F3A80: 4BFEC021  bl 0x830dfaa0
	ctx.lr = 0x830F3A84;
	sub_830DFAA0(ctx, base);
	// 830F3A84: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F3A88: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F3A8C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F3A90: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3A94: 4198FFB8  blt cr6, 0x830f3a4c
	if ctx.cr[6].lt {
	pc = 0x830F3A4C; continue 'dispatch;
	}
	// 830F3A98: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F3A9C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F3AA0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830F3AA4: 480B4718  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3AA8 size=768
    let mut pc: u32 = 0x830F3AA8;
    'dispatch: loop {
        match pc {
            0x830F3AA8 => {
    //   block [0x830F3AA8..0x830F3DA8)
	// 830F3AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3AAC: 480B46BD  bl 0x831a8168
	ctx.lr = 0x830F3AB0;
	sub_831A8130(ctx, base);
	// 830F3AB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3AB8: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830F3ABC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3AC0: 419A02DC  beq cr6, 0x830f3d9c
	if ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3AC4: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F3AC8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F3ACC: 419A02D0  beq cr6, 0x830f3d9c
	if ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3AD0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830F3AD4: 419A02C8  beq cr6, 0x830f3d9c
	if ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3AD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3ADC: 419A0164  beq cr6, 0x830f3c40
	if ctx.cr[6].eq {
	pc = 0x830F3C40; continue 'dispatch;
	}
	// 830F3AE0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F3AE4: 419A015C  beq cr6, 0x830f3c40
	if ctx.cr[6].eq {
	pc = 0x830F3C40; continue 'dispatch;
	}
	// 830F3AE8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F3AEC: 419A000C  beq cr6, 0x830f3af8
	if ctx.cr[6].eq {
	pc = 0x830F3AF8; continue 'dispatch;
	}
	// 830F3AF0: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830F3AF4: 409A02A8  bne cr6, 0x830f3d9c
	if !ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3AF8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3AFC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F3B00: 409A00B0  bne cr6, 0x830f3bb0
	if !ctx.cr[6].eq {
	pc = 0x830F3BB0; continue 'dispatch;
	}
	// 830F3B04: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F3B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3B0C: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3B10: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830F3B14: 80FF00EC  lwz r7, 0xec(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3B18: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F3B1C: 80DF00E0  lwz r6, 0xe0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3B20: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F3B24: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830F3B28: 54EB083E  rotlwi r11, r7, 1
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F3B2C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F3B30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3B34: 7CC52878  andc r5, r6, r5
	ctx.r[5].u64 = ctx.r[6].u64 & !ctx.r[5].u64;
	// 830F3B38: 7CCA5078  andc r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 & !ctx.r[10].u64;
	// 830F3B3C: 7CCB5878  andc r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 & !ctx.r[11].u64;
	// 830F3B40: 7F8933D6  divw r28, r9, r6
	ctx.r[28].s32 = ctx.r[9].s32 / ctx.r[6].s32;
	// 830F3B44: 0CC60000  twi 6, r6, 0
	// 830F3B48: 0CA5FFFF  twi 5, r5, -1
	// 830F3B4C: 7FC733D6  divw r30, r7, r6
	ctx.r[30].s32 = ctx.r[7].s32 / ctx.r[6].s32;
	// 830F3B50: 0CC60000  twi 6, r6, 0
	// 830F3B54: 0CABFFFF  twi 5, r11, -1
	// 830F3B58: 7FA833D6  divw r29, r8, r6
	ctx.r[29].s32 = ctx.r[8].s32 / ctx.r[6].s32;
	// 830F3B5C: 0CC60000  twi 6, r6, 0
	// 830F3B60: 0CAAFFFF  twi 5, r10, -1
	// 830F3B64: 4BFFDDBD  bl 0x830f1920
	ctx.lr = 0x830F3B68;
	sub_830F1920(ctx, base);
	// 830F3B68: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830F3B6C: 813F00E0  lwz r9, 0xe0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3B70: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830F3B74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3B78: 7D434BD6  divw r10, r3, r9
	ctx.r[10].s32 = ctx.r[3].s32 / ctx.r[9].s32;
	// 830F3B7C: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F3B80: 0CC90000  twi 6, r9, 0
	// 830F3B84: 0CABFFFF  twi 5, r11, -1
	// 830F3B88: 40980214  bge cr6, 0x830f3d9c
	if !ctx.cr[6].lt {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3B8C: 7D6AE214  add r11, r10, r28
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 830F3B90: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 830F3B94: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3B98: 41980204  blt cr6, 0x830f3d9c
	if ctx.cr[6].lt {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3B9C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3BA0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F3BA4: 419A0188  beq cr6, 0x830f3d2c
	if ctx.cr[6].eq {
	pc = 0x830F3D2C; continue 'dispatch;
	}
	// 830F3BA8: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F3BAC: 48000148  b 0x830f3cf4
	pc = 0x830F3CF4; continue 'dispatch;
	// 830F3BB0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830F3BB4: 409A01E8  bne cr6, 0x830f3d9c
	if !ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3BB8: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3BBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3BC0: 409901DC  ble cr6, 0x830f3d9c
	if !ctx.cr[6].gt {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3BC4: 811F00E8  lwz r8, 0xe8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3BC8: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830F3BCC: 80FF00E0  lwz r7, 0xe0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F3BD0: 5509083E  rotlwi r9, r8, 1
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F3BD4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F3BD8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830F3BDC: 7D083BD6  divw r8, r8, r7
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830F3BE0: 7CE94878  andc r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & !ctx.r[9].u64;
	// 830F3BE4: 7D6B3BD6  divw r11, r11, r7
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[7].s32;
	// 830F3BE8: 7CEA5078  andc r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830F3BEC: 0CC70000  twi 6, r7, 0
	// 830F3BF0: 0CC70000  twi 6, r7, 0
	// 830F3BF4: 0CA9FFFF  twi 5, r9, -1
	// 830F3BF8: 0CAAFFFF  twi 5, r10, -1
	// 830F3BFC: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830F3C00: 409A019C  bne cr6, 0x830f3d9c
	if !ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3C04: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3C08: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F3C0C: 419A0120  beq cr6, 0x830f3d2c
	if ctx.cr[6].eq {
	pc = 0x830F3D2C; continue 'dispatch;
	}
	// 830F3C10: 54E9003E  slwi r9, r7, 0
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F3C14: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3C18: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830F3C1C: 0CC90000  twi 6, r9, 0
	// 830F3C20: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830F3C24: 7D0A4BD6  divw r8, r10, r9
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 830F3C28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3C2C: 7D0849D6  mullw r8, r8, r9
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F3C30: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F3C34: 7CA85050  subf r5, r8, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 830F3C38: 0CABFFFF  twi 5, r11, -1
	// 830F3C3C: 480000E8  b 0x830f3d24
	pc = 0x830F3D24; continue 'dispatch;
	// 830F3C40: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3C44: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F3C48: 409A00EC  bne cr6, 0x830f3d34
	if !ctx.cr[6].eq {
	pc = 0x830F3D34; continue 'dispatch;
	}
	// 830F3C4C: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F3C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3C54: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3C58: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830F3C5C: 80FF00EC  lwz r7, 0xec(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3C60: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F3C64: 80DF00E4  lwz r6, 0xe4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F3C68: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F3C6C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F3C70: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830F3C74: 54EB083E  rotlwi r11, r7, 1
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F3C78: 7CCA5078  andc r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 & !ctx.r[10].u64;
	// 830F3C7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3C80: 7CC52878  andc r5, r6, r5
	ctx.r[5].u64 = ctx.r[6].u64 & !ctx.r[5].u64;
	// 830F3C84: 7CCB5878  andc r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 & !ctx.r[11].u64;
	// 830F3C88: 7F8933D6  divw r28, r9, r6
	ctx.r[28].s32 = ctx.r[9].s32 / ctx.r[6].s32;
	// 830F3C8C: 0CC60000  twi 6, r6, 0
	// 830F3C90: 0CAAFFFF  twi 5, r10, -1
	// 830F3C94: 7FC733D6  divw r30, r7, r6
	ctx.r[30].s32 = ctx.r[7].s32 / ctx.r[6].s32;
	// 830F3C98: 0CC60000  twi 6, r6, 0
	// 830F3C9C: 0CABFFFF  twi 5, r11, -1
	// 830F3CA0: 7FA833D6  divw r29, r8, r6
	ctx.r[29].s32 = ctx.r[8].s32 / ctx.r[6].s32;
	// 830F3CA4: 0CC60000  twi 6, r6, 0
	// 830F3CA8: 0CA5FFFF  twi 5, r5, -1
	// 830F3CAC: 4BFFDC75  bl 0x830f1920
	ctx.lr = 0x830F3CB0;
	sub_830F1920(ctx, base);
	// 830F3CB0: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830F3CB4: 813F00E4  lwz r9, 0xe4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F3CB8: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830F3CBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F3CC0: 7D434BD6  divw r10, r3, r9
	ctx.r[10].s32 = ctx.r[3].s32 / ctx.r[9].s32;
	// 830F3CC4: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830F3CC8: 0CC90000  twi 6, r9, 0
	// 830F3CCC: 0CABFFFF  twi 5, r11, -1
	// 830F3CD0: 409800CC  bge cr6, 0x830f3d9c
	if !ctx.cr[6].lt {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3CD4: 7D6AE214  add r11, r10, r28
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 830F3CD8: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 830F3CDC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3CE0: 419800BC  blt cr6, 0x830f3d9c
	if ctx.cr[6].lt {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3CE4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3CE8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F3CEC: 419A0040  beq cr6, 0x830f3d2c
	if ctx.cr[6].eq {
	pc = 0x830F3D2C; continue 'dispatch;
	}
	// 830F3CF0: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F3CF4: 811F00EC  lwz r8, 0xec(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3CF8: 7D49E9D6  mullw r10, r9, r29
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[29].s32 as i64);
	// 830F3CFC: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 830F3D00: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F3D04: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830F3D08: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 830F3D0C: 0CC90000  twi 6, r9, 0
	// 830F3D10: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F3D14: 7D293078  andc r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[6].u64;
	// 830F3D18: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830F3D1C: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F3D20: 0CA9FFFF  twi 5, r9, -1
	// 830F3D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3D28: 4BFF2279  bl 0x830e5fa0
	ctx.lr = 0x830F3D2C;
	sub_830E5FA0(ctx, base);
	// 830F3D2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F3D30: 48000070  b 0x830f3da0
	pc = 0x830F3DA0; continue 'dispatch;
	// 830F3D34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3D38: 409A0064  bne cr6, 0x830f3d9c
	if !ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3D3C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F3D40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F3D44: 40990058  ble cr6, 0x830f3d9c
	if !ctx.cr[6].gt {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3D48: 811F00E8  lwz r8, 0xe8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F3D4C: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830F3D50: 80FF00E4  lwz r7, 0xe4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F3D54: 5509083E  rotlwi r9, r8, 1
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 830F3D58: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F3D5C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830F3D60: 7D083BD6  divw r8, r8, r7
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 830F3D64: 7CE94878  andc r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & !ctx.r[9].u64;
	// 830F3D68: 7D6B3BD6  divw r11, r11, r7
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[7].s32;
	// 830F3D6C: 7CEA5078  andc r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 830F3D70: 0CC70000  twi 6, r7, 0
	// 830F3D74: 0CC70000  twi 6, r7, 0
	// 830F3D78: 0CA9FFFF  twi 5, r9, -1
	// 830F3D7C: 0CAAFFFF  twi 5, r10, -1
	// 830F3D80: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830F3D84: 409A0018  bne cr6, 0x830f3d9c
	if !ctx.cr[6].eq {
	pc = 0x830F3D9C; continue 'dispatch;
	}
	// 830F3D88: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F3D8C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F3D90: 419AFF9C  beq cr6, 0x830f3d2c
	if ctx.cr[6].eq {
	pc = 0x830F3D2C; continue 'dispatch;
	}
	// 830F3D94: 54E9003E  slwi r9, r7, 0
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830F3D98: 4BFFFE7C  b 0x830f3c14
	pc = 0x830F3C14; continue 'dispatch;
	// 830F3D9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F3DA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F3DA4: 480B4414  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3DA8 size=104
    let mut pc: u32 = 0x830F3DA8;
    'dispatch: loop {
        match pc {
            0x830F3DA8 => {
    //   block [0x830F3DA8..0x830F3E10)
	// 830F3DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F3DB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F3DB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3DB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3DBC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830F3DC0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F3DC4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3DC8: 40980008  bge cr6, 0x830f3dd0
	if !ctx.cr[6].lt {
	pc = 0x830F3DD0; continue 'dispatch;
	}
	// 830F3DCC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F3DD0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3DD4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3DD8: 40990008  ble cr6, 0x830f3de0
	if !ctx.cr[6].gt {
	pc = 0x830F3DE0; continue 'dispatch;
	}
	// 830F3DDC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F3DE0: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 830F3DE4: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 830F3DE8: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 830F3DEC: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 830F3DF0: 480BE781  bl 0x831b2570
	ctx.lr = 0x830F3DF4;
	sub_831B2570(ctx, base);
	// 830F3DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3DF8: 4BFF9C39  bl 0x830eda30
	ctx.lr = 0x830F3DFC;
	sub_830EDA30(ctx, base);
	// 830F3DFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F3E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F3E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F3E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F3E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F3E10 size=368
    let mut pc: u32 = 0x830F3E10;
    'dispatch: loop {
        match pc {
            0x830F3E10 => {
    //   block [0x830F3E10..0x830F3F80)
	// 830F3E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3E14: 480B4355  bl 0x831a8168
	ctx.lr = 0x830F3E18;
	sub_831A8130(ctx, base);
	// 830F3E18: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 830F3E1C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830F3E20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3E24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3E2C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3E30: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F3E34: 419A0088  beq cr6, 0x830f3ebc
	if ctx.cr[6].eq {
	pc = 0x830F3EBC; continue 'dispatch;
	}
	// 830F3E38: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 830F3E3C: 419A0068  beq cr6, 0x830f3ea4
	if ctx.cr[6].eq {
	pc = 0x830F3EA4; continue 'dispatch;
	}
	// 830F3E40: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 830F3E44: 419A0050  beq cr6, 0x830f3e94
	if ctx.cr[6].eq {
	pc = 0x830F3E94; continue 'dispatch;
	}
	// 830F3E48: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830F3E4C: 419A003C  beq cr6, 0x830f3e88
	if ctx.cr[6].eq {
	pc = 0x830F3E88; continue 'dispatch;
	}
	// 830F3E50: 2B0B07DF  cmplwi cr6, r11, 0x7df
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2015 as u32, &mut ctx.xer);
	// 830F3E54: 409A0118  bne cr6, 0x830f3f6c
	if !ctx.cr[6].eq {
	pc = 0x830F3F6C; continue 'dispatch;
	}
	// 830F3E58: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F3E5C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3E60: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F3E64: 409A0108  bne cr6, 0x830f3f6c
	if !ctx.cr[6].eq {
	pc = 0x830F3F6C; continue 'dispatch;
	}
	// 830F3E68: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F3E6C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F3E70: 409A00FC  bne cr6, 0x830f3f6c
	if !ctx.cr[6].eq {
	pc = 0x830F3F6C; continue 'dispatch;
	}
	// 830F3E74: 395F0014  addi r10, r31, 0x14
	ctx.r[10].s64 = ctx.r[31].s64 + 20;
	// 830F3E78: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F3E7C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830F3E80: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F3E84: 480000E8  b 0x830f3f6c
	pc = 0x830F3F6C; continue 'dispatch;
	// 830F3E88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F3E8C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F3E90: 480000D4  b 0x830f3f64
	pc = 0x830F3F64; continue 'dispatch;
	// 830F3E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3E98: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F3E9C: 4BFFFF0D  bl 0x830f3da8
	ctx.lr = 0x830F3EA0;
	sub_830F3DA8(ctx, base);
	// 830F3EA0: 480000CC  b 0x830f3f6c
	pc = 0x830F3F6C; continue 'dispatch;
	// 830F3EA4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F3EA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F3EAC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F3EB0: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F3EB4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F3EB8: 480000B4  b 0x830f3f6c
	pc = 0x830F3F6C; continue 'dispatch;
	// 830F3EBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F3EC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3EC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F3EC8: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830F3ECC: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 830F3ED0: 4BFDA649  bl 0x830ce518
	ctx.lr = 0x830F3ED4;
	sub_830CE518(ctx, base);
	// 830F3ED4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F3ED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3EDC: 419A0090  beq cr6, 0x830f3f6c
	if ctx.cr[6].eq {
	pc = 0x830F3F6C; continue 'dispatch;
	}
	// 830F3EE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F3EE4: 4BFE1CE5  bl 0x830d5bc8
	ctx.lr = 0x830F3EE8;
	sub_830D5BC8(ctx, base);
	// 830F3EE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F3EEC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830F3EF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F3EF4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F3EF8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3EFC: 4BFED65D  bl 0x830e1558
	ctx.lr = 0x830F3F00;
	sub_830E1558(ctx, base);
	// 830F3F00: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F3F04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3F08: 419A0064  beq cr6, 0x830f3f6c
	if ctx.cr[6].eq {
	pc = 0x830F3F6C; continue 'dispatch;
	}
	// 830F3F0C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F3F10: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F3F14: 388B9614  addi r4, r11, -0x69ec
	ctx.r[4].s64 = ctx.r[11].s64 + -27116;
	// 830F3F18: 4BFEBDC9  bl 0x830dfce0
	ctx.lr = 0x830F3F1C;
	sub_830DFCE0(ctx, base);
	// 830F3F1C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F20: 4BFF20D1  bl 0x830e5ff0
	ctx.lr = 0x830F3F24;
	sub_830E5FF0(ctx, base);
	// 830F3F24: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F3F28: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830F3F2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F30: 4BFF38D9  bl 0x830e7808
	ctx.lr = 0x830F3F34;
	sub_830E7808(ctx, base);
	// 830F3F34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F3F38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F3C: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F3F40: C3E10058  lfs f31, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F3F44: C3C1005C  lfs f30, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F3F48: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 830F3F4C: EC3E002A  fadds f1, f30, f0
	ctx.f[1].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F3F50: 4BFEDAB9  bl 0x830e1a08
	ctx.lr = 0x830F3F54;
	sub_830E1A08(ctx, base);
	// 830F3F54: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F3F58: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 830F3F5C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 830F3F60: 4BFEDAA9  bl 0x830e1a08
	ctx.lr = 0x830F3F64;
	sub_830E1A08(ctx, base);
	// 830F3F64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F3F68: 4BFF9AC9  bl 0x830eda30
	ctx.lr = 0x830F3F6C;
	sub_830EDA30(ctx, base);
	// 830F3F6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F3F70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F3F74: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830F3F78: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F3F7C: 480B423C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F3F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F3F80 size=380
    let mut pc: u32 = 0x830F3F80;
    'dispatch: loop {
        match pc {
            0x830F3F80 => {
    //   block [0x830F3F80..0x830F40FC)
	// 830F3F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F3F84: 480B41E9  bl 0x831a816c
	ctx.lr = 0x830F3F88;
	sub_831A8130(ctx, base);
	// 830F3F88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F3F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F3F90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F3F94: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F3F98: 7F1E4800  cmpw cr6, r30, r9
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F3F9C: 40980008  bge cr6, 0x830f3fa4
	if !ctx.cr[6].lt {
	pc = 0x830F3FA4; continue 'dispatch;
	}
	// 830F3FA0: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 830F3FA4: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F3FA8: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F3FAC: 40990008  ble cr6, 0x830f3fb4
	if !ctx.cr[6].gt {
	pc = 0x830F3FB4; continue 'dispatch;
	}
	// 830F3FB0: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 830F3FB4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F3FB8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3FBC: 40980038  bge cr6, 0x830f3ff4
	if !ctx.cr[6].lt {
	pc = 0x830F3FF4; continue 'dispatch;
	}
	// 830F3FC0: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F3FC4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830F3FC8: 419A0028  beq cr6, 0x830f3ff0
	if ctx.cr[6].eq {
	pc = 0x830F3FF0; continue 'dispatch;
	}
	// 830F3FCC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F3FD0: 409A0018  bne cr6, 0x830f3fe8
	if !ctx.cr[6].eq {
	pc = 0x830F3FE8; continue 'dispatch;
	}
	// 830F3FD4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F3FDC: 419A000C  beq cr6, 0x830f3fe8
	if ctx.cr[6].eq {
	pc = 0x830F3FE8; continue 'dispatch;
	}
	// 830F3FE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F3FE4: 4BFF4365  bl 0x830e8348
	ctx.lr = 0x830F3FE8;
	sub_830E8348(ctx, base);
	// 830F3FE8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F3FEC: 48000038  b 0x830f4024
	pc = 0x830F4024; continue 'dispatch;
	// 830F3FF0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F3FF4: 40990038  ble cr6, 0x830f402c
	if !ctx.cr[6].gt {
	pc = 0x830F402C; continue 'dispatch;
	}
	// 830F3FF8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F3FFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F4000: 419A002C  beq cr6, 0x830f402c
	if ctx.cr[6].eq {
	pc = 0x830F402C; continue 'dispatch;
	}
	// 830F4004: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F4008: 409A0018  bne cr6, 0x830f4020
	if !ctx.cr[6].eq {
	pc = 0x830F4020; continue 'dispatch;
	}
	// 830F400C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F4010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4014: 419A000C  beq cr6, 0x830f4020
	if ctx.cr[6].eq {
	pc = 0x830F4020; continue 'dispatch;
	}
	// 830F4018: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F401C: 4BFF432D  bl 0x830e8348
	ctx.lr = 0x830F4020;
	sub_830E8348(ctx, base);
	// 830F4020: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4024: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830F4028: 4BFF4321  bl 0x830e8348
	ctx.lr = 0x830F402C;
	sub_830E8348(ctx, base);
	// 830F402C: 83BF0018  lwz r29, 0x18(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F4030: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F4034: 419A0040  beq cr6, 0x830f4074
	if ctx.cr[6].eq {
	pc = 0x830F4074; continue 'dispatch;
	}
	// 830F4038: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F403C: 4BFDABD5  bl 0x830cec10
	ctx.lr = 0x830F4040;
	sub_830CEC10(ctx, base);
	// 830F4040: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830F4044: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F4048: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F404C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830F4050: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830F4054: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 830F4058: 4BFF3679  bl 0x830e76d0
	ctx.lr = 0x830F405C;
	sub_830E76D0(ctx, base);
	// 830F405C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4060: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 830F4064: 4BFDABAD  bl 0x830cec10
	ctx.lr = 0x830F4068;
	sub_830CEC10(ctx, base);
	// 830F4068: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F406C: 4BFE1CED  bl 0x830d5d58
	ctx.lr = 0x830F4070;
	sub_830D5D58(ctx, base);
	// 830F4070: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4074: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F4078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F407C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 830F4080: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 830F4084: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 830F4088: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 830F408C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F4090: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 830F4094: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F4098: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 830F409C: 480BE4D5  bl 0x831b2570
	ctx.lr = 0x830F40A0;
	sub_831B2570(ctx, base);
	// 830F40A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F40A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F40A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F40AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F40B0: 4BFF9AF9  bl 0x830edba8
	ctx.lr = 0x830F40B4;
	sub_830EDBA8(ctx, base);
	// 830F40B4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F40B8: 419A003C  beq cr6, 0x830f40f4
	if ctx.cr[6].eq {
	pc = 0x830F40F4; continue 'dispatch;
	}
	// 830F40BC: 83DF0018  lwz r30, 0x18(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F40C0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F40C4: 4BFDAB4D  bl 0x830cec10
	ctx.lr = 0x830F40C8;
	sub_830CEC10(ctx, base);
	// 830F40C8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830F40CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F40D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F40D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830F40D8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 830F40DC: 4BFF363D  bl 0x830e7718
	ctx.lr = 0x830F40E0;
	sub_830E7718(ctx, base);
	// 830F40E0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F40E4: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 830F40E8: 4BFDAB29  bl 0x830cec10
	ctx.lr = 0x830F40EC;
	sub_830CEC10(ctx, base);
	// 830F40EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F40F0: 4BFE1C69  bl 0x830d5d58
	ctx.lr = 0x830F40F4;
	sub_830D5D58(ctx, base);
	// 830F40F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F40F8: 480B40C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4100 size=920
    let mut pc: u32 = 0x830F4100;
    'dispatch: loop {
        match pc {
            0x830F4100 => {
    //   block [0x830F4100..0x830F4498)
	// 830F4100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4104: 480B405D  bl 0x831a8160
	ctx.lr = 0x830F4108;
	sub_831A8130(ctx, base);
	// 830F4108: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F410C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F4110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4114: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4118: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830F411C: 4199024C  bgt cr6, 0x830f4368
	if ctx.cr[6].gt {
	pc = 0x830F4368; continue 'dispatch;
	}
	// 830F4120: 419A0140  beq cr6, 0x830f4260
	if ctx.cr[6].eq {
	pc = 0x830F4260; continue 'dispatch;
	}
	// 830F4124: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F4128: 419A0078  beq cr6, 0x830f41a0
	if ctx.cr[6].eq {
	pc = 0x830F41A0; continue 'dispatch;
	}
	// 830F412C: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830F4130: 419A005C  beq cr6, 0x830f418c
	if ctx.cr[6].eq {
	pc = 0x830F418C; continue 'dispatch;
	}
	// 830F4134: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830F4138: 419A001C  beq cr6, 0x830f4154
	if ctx.cr[6].eq {
	pc = 0x830F4154; continue 'dispatch;
	}
	// 830F413C: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 830F4140: 409A034C  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4144: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F4148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F414C: 4BFFFE35  bl 0x830f3f80
	ctx.lr = 0x830F4150;
	sub_830F3F80(ctx, base);
	// 830F4150: 4800033C  b 0x830f448c
	pc = 0x830F448C; continue 'dispatch;
	// 830F4154: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4158: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F415C: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 830F4160: 409A032C  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4164: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F4168: 915A0008  stw r10, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F416C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4170: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F4174: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F4178: 419A00DC  beq cr6, 0x830f4254
	if ctx.cr[6].eq {
	pc = 0x830F4254; continue 'dispatch;
	}
	// 830F417C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4180: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F4184: 409A0308  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4188: 480000CC  b 0x830f4254
	pc = 0x830F4254; continue 'dispatch;
	// 830F418C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F4190: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F4194: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F4198: 409A02F4  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F419C: 480002E8  b 0x830f4484
	pc = 0x830F4484; continue 'dispatch;
	// 830F41A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F41A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F41A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F41AC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830F41B0: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 830F41B4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F41B8: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 830F41BC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830F41C0: 3B7F000C  addi r27, r31, 0xc
	ctx.r[27].s64 = ctx.r[31].s64 + 12;
	// 830F41C4: 4BFDA355  bl 0x830ce518
	ctx.lr = 0x830F41C8;
	sub_830CE518(ctx, base);
	// 830F41C8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F41CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F41D0: 419A02BC  beq cr6, 0x830f448c
	if ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F41D4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F41D8: 4BFE19F1  bl 0x830d5bc8
	ctx.lr = 0x830F41DC;
	sub_830D5BC8(ctx, base);
	// 830F41DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F41E0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830F41E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F41E8: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F41EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F41F0: 4BFED369  bl 0x830e1558
	ctx.lr = 0x830F41F4;
	sub_830E1558(ctx, base);
	// 830F41F4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F41F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F41FC: 419A0290  beq cr6, 0x830f448c
	if ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4200: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F4204: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830F4208: 388B9658  addi r4, r11, -0x69a8
	ctx.r[4].s64 = ctx.r[11].s64 + -27048;
	// 830F420C: 4BFEBAD5  bl 0x830dfce0
	ctx.lr = 0x830F4210;
	sub_830DFCE0(ctx, base);
	// 830F4210: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F4214: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F4218: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F421C: 388B9644  addi r4, r11, -0x69bc
	ctx.r[4].s64 = ctx.r[11].s64 + -27068;
	// 830F4220: 4BFEBAC1  bl 0x830dfce0
	ctx.lr = 0x830F4224;
	sub_830DFCE0(ctx, base);
	// 830F4224: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F4228: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F422C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F4230: 388B9630  addi r4, r11, -0x69d0
	ctx.r[4].s64 = ctx.r[11].s64 + -27088;
	// 830F4234: 4BFEBAAD  bl 0x830dfce0
	ctx.lr = 0x830F4238;
	sub_830DFCE0(ctx, base);
	// 830F4238: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F423C: 4BFF1DB5  bl 0x830e5ff0
	ctx.lr = 0x830F4240;
	sub_830E5FF0(ctx, base);
	// 830F4240: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F4244: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F4248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F424C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F4250: 4BFF9959  bl 0x830edba8
	ctx.lr = 0x830F4254;
	sub_830EDBA8(ctx, base);
	// 830F4254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4258: 4BFF98D9  bl 0x830edb30
	ctx.lr = 0x830F425C;
	sub_830EDB30(ctx, base);
	// 830F425C: 48000230  b 0x830f448c
	pc = 0x830F448C; continue 'dispatch;
	// 830F4260: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4264: 4BFEC93D  bl 0x830e0ba0
	ctx.lr = 0x830F4268;
	sub_830E0BA0(ctx, base);
	// 830F4268: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F426C: 41820220  beq 0x830f448c
	if ctx.cr[0].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4270: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F4274: 807A0010  lwz r3, 0x10(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4278: 4BFEAA69  bl 0x830dece0
	ctx.lr = 0x830F427C;
	sub_830DECE0(ctx, base);
	// 830F427C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F4280: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4284: 4082006C  bne 0x830f42f0
	if !ctx.cr[0].eq {
	pc = 0x830F42F0; continue 'dispatch;
	}
	// 830F4288: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830F428C: 409A005C  bne cr6, 0x830f42e8
	if !ctx.cr[6].eq {
	pc = 0x830F42E8; continue 'dispatch;
	}
	// 830F4290: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F4294: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4298: 40990018  ble cr6, 0x830f42b0
	if !ctx.cr[6].gt {
	pc = 0x830F42B0; continue 'dispatch;
	}
	// 830F429C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F42A0: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F42A4: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F42A8: 409A001C  bne cr6, 0x830f42c4
	if !ctx.cr[6].eq {
	pc = 0x830F42C4; continue 'dispatch;
	}
	// 830F42AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F42B0: 409801DC  bge cr6, 0x830f448c
	if !ctx.cr[6].lt {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F42B4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F42B8: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F42BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F42C0: 419A01CC  beq cr6, 0x830f448c
	if ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F42C4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830F42C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F42CC: 4BFF0D6D  bl 0x830e5038
	ctx.lr = 0x830F42D0;
	sub_830E5038(ctx, base);
	// 830F42D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F42D4: 40820088  bne 0x830f435c
	if !ctx.cr[0].eq {
	pc = 0x830F435C; continue 'dispatch;
	}
	// 830F42D8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F42DC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F42E0: 7C8A5850  subf r4, r10, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F42E4: 48000070  b 0x830f4354
	pc = 0x830F4354; continue 'dispatch;
	// 830F42E8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830F42EC: 48000010  b 0x830f42fc
	pc = 0x830F42FC; continue 'dispatch;
	// 830F42F0: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830F42F4: 419AFF9C  beq cr6, 0x830f4290
	if ctx.cr[6].eq {
	pc = 0x830F4290; continue 'dispatch;
	}
	// 830F42F8: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830F42FC: 409A0190  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4300: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F4304: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4308: 40990018  ble cr6, 0x830f4320
	if !ctx.cr[6].gt {
	pc = 0x830F4320; continue 'dispatch;
	}
	// 830F430C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4310: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F4314: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F4318: 409A001C  bne cr6, 0x830f4334
	if !ctx.cr[6].eq {
	pc = 0x830F4334; continue 'dispatch;
	}
	// 830F431C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4320: 4098016C  bge cr6, 0x830f448c
	if !ctx.cr[6].lt {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4324: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4328: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F432C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F4330: 419A015C  beq cr6, 0x830f448c
	if ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4334: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F4338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F433C: 4BFF0CFD  bl 0x830e5038
	ctx.lr = 0x830F4340;
	sub_830E5038(ctx, base);
	// 830F4340: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4344: 40820018  bne 0x830f435c
	if !ctx.cr[0].eq {
	pc = 0x830F435C; continue 'dispatch;
	}
	// 830F4348: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F434C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F4350: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F4354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4358: 4BFFFC29  bl 0x830f3f80
	ctx.lr = 0x830F435C;
	sub_830F3F80(ctx, base);
	// 830F435C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4360: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F4364: 48000128  b 0x830f448c
	pc = 0x830F448C; continue 'dispatch;
	// 830F4368: 2B0B0025  cmplwi cr6, r11, 0x25
	ctx.cr[6].compare_u32(ctx.r[11].u32, 37 as u32, &mut ctx.xer);
	// 830F436C: 419A00C8  beq cr6, 0x830f4434
	if ctx.cr[6].eq {
	pc = 0x830F4434; continue 'dispatch;
	}
	// 830F4370: 2B0B0027  cmplwi cr6, r11, 0x27
	ctx.cr[6].compare_u32(ctx.r[11].u32, 39 as u32, &mut ctx.xer);
	// 830F4374: 419A007C  beq cr6, 0x830f43f0
	if ctx.cr[6].eq {
	pc = 0x830F43F0; continue 'dispatch;
	}
	// 830F4378: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830F437C: 419A003C  beq cr6, 0x830f43b8
	if ctx.cr[6].eq {
	pc = 0x830F43B8; continue 'dispatch;
	}
	// 830F4380: 2B0B07DF  cmplwi cr6, r11, 0x7df
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2015 as u32, &mut ctx.xer);
	// 830F4384: 409A0108  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4388: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F438C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4390: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F4394: 409A00F8  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4398: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F439C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F43A0: 409A00EC  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F43A4: 395F0030  addi r10, r31, 0x30
	ctx.r[10].s64 = ctx.r[31].s64 + 48;
	// 830F43A8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F43AC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830F43B0: 913A0008  stw r9, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F43B4: 480000D8  b 0x830f448c
	pc = 0x830F448C; continue 'dispatch;
	// 830F43B8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F43BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F43C0: 4BFDA159  bl 0x830ce518
	ctx.lr = 0x830F43C4;
	sub_830CE518(ctx, base);
	// 830F43C4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F43C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F43CC: 419A00C0  beq cr6, 0x830f448c
	if ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F43D0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830F43D4: 4BFE17F5  bl 0x830d5bc8
	ctx.lr = 0x830F43D8;
	sub_830D5BC8(ctx, base);
	// 830F43D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F43DC: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F43E0: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F43E4: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F43E8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F43EC: 4BFFFE5C  b 0x830f4248
	pc = 0x830F4248; continue 'dispatch;
	// 830F43F0: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F43F4: 3D40AABB  lis r10, -0x5545
	ctx.r[10].s64 = -1430585344;
	// 830F43F8: 614ACCDD  ori r10, r10, 0xccdd
	ctx.r[10].u64 = ctx.r[10].u64 | 52445;
	// 830F43FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4400: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F4404: 409A0088  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4408: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F440C: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F4410: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F4414: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F4418: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F441C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830F4420: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F4424: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830F4428: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830F442C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F4430: 4BFFFD18  b 0x830f4148
	pc = 0x830F4148; continue 'dispatch;
	// 830F4434: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F4438: 807A0010  lwz r3, 0x10(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F443C: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F4440: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F4444: 409A0048  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F4448: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F444C: 4BFEA895  bl 0x830dece0
	ctx.lr = 0x830F4450;
	sub_830DECE0(ctx, base);
	// 830F4450: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F4454: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4458: 40820014  bne 0x830f446c
	if !ctx.cr[0].eq {
	pc = 0x830F446C; continue 'dispatch;
	}
	// 830F445C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830F4460: 419A001C  beq cr6, 0x830f447c
	if ctx.cr[6].eq {
	pc = 0x830F447C; continue 'dispatch;
	}
	// 830F4464: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830F4468: 48000010  b 0x830f4478
	pc = 0x830F4478; continue 'dispatch;
	// 830F446C: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830F4470: 419A000C  beq cr6, 0x830f447c
	if ctx.cr[6].eq {
	pc = 0x830F447C; continue 'dispatch;
	}
	// 830F4474: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830F4478: 409A0014  bne cr6, 0x830f448c
	if !ctx.cr[6].eq {
	pc = 0x830F448C; continue 'dispatch;
	}
	// 830F447C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4480: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F4484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4488: 4BFF0C21  bl 0x830e50a8
	ctx.lr = 0x830F448C;
	sub_830E50A8(ctx, base);
	// 830F448C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F4490: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F4494: 480B3D1C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F4498 size=800
    let mut pc: u32 = 0x830F4498;
    'dispatch: loop {
        match pc {
            0x830F4498 => {
    //   block [0x830F4498..0x830F47B8)
	// 830F4498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F449C: 480B3CCD  bl 0x831a8168
	ctx.lr = 0x830F44A0;
	sub_831A8130(ctx, base);
	// 830F44A0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830F44A4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F44A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F44AC: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F44B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F44B4: 419A02F4  beq cr6, 0x830f47a8
	if ctx.cr[6].eq {
	pc = 0x830F47A8; continue 'dispatch;
	}
	// 830F44B8: 4BFEACF1  bl 0x830df1a8
	ctx.lr = 0x830F44BC;
	sub_830DF1A8(ctx, base);
	// 830F44BC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F44C0: 418202E8  beq 0x830f47a8
	if ctx.cr[0].eq {
	pc = 0x830F47A8; continue 'dispatch;
	}
	// 830F44C4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F44C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F44CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F44D0: 409A000C  bne cr6, 0x830f44dc
	if !ctx.cr[6].eq {
	pc = 0x830F44DC; continue 'dispatch;
	}
	// 830F44D4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 830F44D8: 48000010  b 0x830f44e8
	pc = 0x830F44E8; continue 'dispatch;
	// 830F44DC: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830F44E0: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F44E4: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F44E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F44EC: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F44F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F44F4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F44F8: 419A007C  beq cr6, 0x830f4574
	if ctx.cr[6].eq {
	pc = 0x830F4574; continue 'dispatch;
	}
	// 830F44FC: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F4500: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F4504: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F4508: 419A006C  beq cr6, 0x830f4574
	if ctx.cr[6].eq {
	pc = 0x830F4574; continue 'dispatch;
	}
	// 830F450C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4510: 4BFEC691  bl 0x830e0ba0
	ctx.lr = 0x830F4514;
	sub_830E0BA0(ctx, base);
	// 830F4514: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4518: 4182005C  beq 0x830f4574
	if ctx.cr[0].eq {
	pc = 0x830F4574; continue 'dispatch;
	}
	// 830F451C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F4520: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4524: 4BFEB52D  bl 0x830dfa50
	ctx.lr = 0x830F4528;
	sub_830DFA50(ctx, base);
	// 830F4528: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830F452C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F4530: 4BFEB521  bl 0x830dfa50
	ctx.lr = 0x830F4534;
	sub_830DFA50(ctx, base);
	// 830F4534: D3E10090  stfs f31, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830F4538: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830F453C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 830F4540: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830F4544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F4548: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F454C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F4550: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F4554: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F4558: 80BF006C  lwz r5, 0x6c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F455C: 4801796D  bl 0x8310bec8
	ctx.lr = 0x830F4560;
	sub_8310BEC8(ctx, base);
	// 830F4560: C0010098  lfs f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4564: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830F4568: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F456C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F4570: 4BFEB531  bl 0x830dfaa0
	ctx.lr = 0x830F4574;
	sub_830DFAA0(ctx, base);
	// 830F4574: C01F009C  lfs f0, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4578: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F457C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830F4580: 813F0094  lwz r9, 0x94(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F4584: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830F4588: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F458C: 7D4A5B96  divwu r10, r10, r11
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 830F4590: 0CCB0000  twi 6, r11, 0
	// 830F4594: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 830F4598: 552B07BC  rlwinm r11, r9, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 830F459C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F45A0: 409A0030  bne cr6, 0x830f45d0
	if !ctx.cr[6].eq {
	pc = 0x830F45D0; continue 'dispatch;
	}
	// 830F45A4: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830F45A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F45AC: 419A0024  beq cr6, 0x830f45d0
	if ctx.cr[6].eq {
	pc = 0x830F45D0; continue 'dispatch;
	}
	// 830F45B0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F45B4: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F45B8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F45BC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F45C0: 419A0010  beq cr6, 0x830f45d0
	if ctx.cr[6].eq {
	pc = 0x830F45D0; continue 'dispatch;
	}
	// 830F45C4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830F45C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F45CC: 4BFF1C45  bl 0x830e6210
	ctx.lr = 0x830F45D0;
	sub_830E6210(ctx, base);
	// 830F45D0: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F45D4: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F45D8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F45DC: 419A00DC  beq cr6, 0x830f46b8
	if ctx.cr[6].eq {
	pc = 0x830F46B8; continue 'dispatch;
	}
	// 830F45E0: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F45E4: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 830F45E8: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F45EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830F45F0: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830F45F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F45F8: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830F45FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F4600: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830F4604: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F4608: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830F460C: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F4610: 480178B9  bl 0x8310bec8
	ctx.lr = 0x830F4614;
	sub_8310BEC8(ctx, base);
	// 830F4614: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4618: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F461C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F4620: 41990014  bgt cr6, 0x830f4634
	if ctx.cr[6].gt {
	pc = 0x830F4634; continue 'dispatch;
	}
	// 830F4624: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F4628: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 830F462C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F4630: 40990008  ble cr6, 0x830f4638
	if !ctx.cr[6].gt {
	pc = 0x830F4638; continue 'dispatch;
	}
	// 830F4634: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F4638: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F463C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4640: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 830F4644: 4BFF3235  bl 0x830e7878
	ctx.lr = 0x830F4648;
	sub_830E7878(ctx, base);
	// 830F4648: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F464C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F4650: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 830F4654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4658: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F465C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F4660: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F4664: 4BFF9745  bl 0x830edda8
	ctx.lr = 0x830F4668;
	sub_830EDDA8(ctx, base);
	// 830F4668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F466C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4670: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 830F4674: 4BFF3205  bl 0x830e7878
	ctx.lr = 0x830F4678;
	sub_830E7878(ctx, base);
	// 830F4678: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F467C: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4680: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4684: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F4688: 41990008  bgt cr6, 0x830f4690
	if ctx.cr[6].gt {
	pc = 0x830F4690; continue 'dispatch;
	}
	// 830F468C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 830F4690: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830F4694: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F4698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F469C: 4BFF970D  bl 0x830edda8
	ctx.lr = 0x830F46A0;
	sub_830EDDA8(ctx, base);
	// 830F46A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F46A4: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F46A8: 4BFF31D1  bl 0x830e7878
	ctx.lr = 0x830F46AC;
	sub_830E7878(ctx, base);
	// 830F46AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F46B0: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830F46B4: 4BFF31C5  bl 0x830e7878
	ctx.lr = 0x830F46B8;
	sub_830E7878(ctx, base);
	// 830F46B8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830F46BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F46C0: 419A00D0  beq cr6, 0x830f4790
	if ctx.cr[6].eq {
	pc = 0x830F4790; continue 'dispatch;
	}
	// 830F46C4: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F46C8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F46CC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F46D0: 40990030  ble cr6, 0x830f4700
	if !ctx.cr[6].gt {
	pc = 0x830F4700; continue 'dispatch;
	}
	// 830F46D4: 55642036  slwi r4, r11, 4
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830F46D8: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F46DC: 4BFE8E15  bl 0x830dd4f0
	ctx.lr = 0x830F46E0;
	sub_830DD4F0(ctx, base);
	// 830F46E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F46E4: 40820010  bne 0x830f46f4
	if !ctx.cr[0].eq {
	pc = 0x830F46F4; continue 'dispatch;
	}
	// 830F46E8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F46EC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830F46F0: 480000BC  b 0x830f47ac
	pc = 0x830F47AC; continue 'dispatch;
	// 830F46F4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F46F8: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 830F46FC: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F4700: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830F4704: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F4708: 409900A0  ble cr6, 0x830f47a8
	if !ctx.cr[6].gt {
	pc = 0x830F47A8; continue 'dispatch;
	}
	// 830F470C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 830F4710: 811F0044  lwz r8, 0x44(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830F4714: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F4718: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F471C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830F4720: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830F4724: 8108000C  lwz r8, 0xc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F4728: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830F472C: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F4730: 811F0044  lwz r8, 0x44(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830F4734: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830F4738: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830F473C: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F4740: 91090008  stw r8, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F4744: 813F0044  lwz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830F4748: 811F004C  lwz r8, 0x4c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F474C: 80FF0074  lwz r7, 0x74(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F4750: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F4754: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 830F4758: 7D28592E  stwx r9, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 830F475C: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F4760: 80FF0074  lwz r7, 0x74(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F4764: 811F0044  lwz r8, 0x44(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830F4768: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830F476C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830F4770: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4774: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830F4778: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830F477C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830F4780: 813F0048  lwz r9, 0x48(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F4784: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F4788: 4198FF88  blt cr6, 0x830f4710
	if ctx.cr[6].lt {
	pc = 0x830F4710; continue 'dispatch;
	}
	// 830F478C: 4800001C  b 0x830f47a8
	pc = 0x830F47A8; continue 'dispatch;
	// 830F4790: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F4794: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F4798: 419A0010  beq cr6, 0x830f47a8
	if ctx.cr[6].eq {
	pc = 0x830F47A8; continue 'dispatch;
	}
	// 830F479C: 4BFE8D3D  bl 0x830dd4d8
	ctx.lr = 0x830F47A0;
	sub_830DD4D8(ctx, base);
	// 830F47A0: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 830F47A4: 939F0050  stw r28, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830F47A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F47AC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830F47B0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F47B4: 480B3A04  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F47B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F47B8 size=820
    let mut pc: u32 = 0x830F47B8;
    'dispatch: loop {
        match pc {
            0x830F47B8 => {
    //   block [0x830F47B8..0x830F4AEC)
	// 830F47B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F47BC: 480B39A9  bl 0x831a8164
	ctx.lr = 0x830F47C0;
	sub_831A8130(ctx, base);
	// 830F47C0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 830F47C4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F47C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F47CC: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F47D0: 4BFEA9D9  bl 0x830df1a8
	ctx.lr = 0x830F47D4;
	sub_830DF1A8(ctx, base);
	// 830F47D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F47D8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F47DC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830F47E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F47E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F47E8: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F47EC: 419A005C  beq cr6, 0x830f4848
	if ctx.cr[6].eq {
	pc = 0x830F4848; continue 'dispatch;
	}
	// 830F47F0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F47F4: 419A0054  beq cr6, 0x830f4848
	if ctx.cr[6].eq {
	pc = 0x830F4848; continue 'dispatch;
	}
	// 830F47F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830F47FC: 4BFEAA6D  bl 0x830df268
	ctx.lr = 0x830F4800;
	sub_830DF268(ctx, base);
	// 830F4800: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 830F4804: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F4808: 4BFEAA99  bl 0x830df2a0
	ctx.lr = 0x830F480C;
	sub_830DF2A0(ctx, base);
	// 830F480C: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 830F4810: 389F0084  addi r4, r31, 0x84
	ctx.r[4].s64 = ctx.r[31].s64 + 132;
	// 830F4814: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F4818: 48013E81  bl 0x83108698
	ctx.lr = 0x830F481C;
	sub_83108698(ctx, base);
	// 830F481C: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F4820: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830F4824: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 830F4828: 3BBF00C0  addi r29, r31, 0xc0
	ctx.r[29].s64 = ctx.r[31].s64 + 192;
	// 830F482C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F4830: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F4834: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F4838: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 830F483C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F4840: 4BFF2FC9  bl 0x830e7808
	ctx.lr = 0x830F4844;
	sub_830E7808(ctx, base);
	// 830F4844: 48000020  b 0x830f4864
	pc = 0x830F4864; continue 'dispatch;
	// 830F4848: D3FF00C0  stfs f31, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830F484C: 3BBF00C0  addi r29, r31, 0xc0
	ctx.r[29].s64 = ctx.r[31].s64 + 192;
	// 830F4850: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830F4854: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 830F4858: 937F0060  stw r27, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 830F485C: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 830F4860: 937F0080  stw r27, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 830F4864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4868: 4BFF19A9  bl 0x830e6210
	ctx.lr = 0x830F486C;
	sub_830E6210(ctx, base);
	// 830F486C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F4870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F4874: 419A0024  beq cr6, 0x830f4898
	if ctx.cr[6].eq {
	pc = 0x830F4898; continue 'dispatch;
	}
	// 830F4878: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F487C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F4880: 419A0018  beq cr6, 0x830f4898
	if ctx.cr[6].eq {
	pc = 0x830F4898; continue 'dispatch;
	}
	// 830F4884: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F4888: 419A0010  beq cr6, 0x830f4898
	if ctx.cr[6].eq {
	pc = 0x830F4898; continue 'dispatch;
	}
	// 830F488C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F4890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4894: 4BFF95AD  bl 0x830ede40
	ctx.lr = 0x830F4898;
	sub_830EDE40(ctx, base);
	// 830F4898: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F489C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F48A0: 419A00B0  beq cr6, 0x830f4950
	if ctx.cr[6].eq {
	pc = 0x830F4950; continue 'dispatch;
	}
	// 830F48A4: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830F48A8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F48AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F48B0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F48B4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F48B8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F48BC: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830F48C0: 480B7449  bl 0x831abd08
	ctx.lr = 0x830F48C4;
	sub_831ABD08(ctx, base);
	// 830F48C4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F48C8: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F48CC: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F48D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F48D4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F48D8: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830F48DC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F48E0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F48E4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830F48E8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F48EC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830F48F0: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F48F4: EDAC6838  fmsubs f13, f12, f0, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F48F8: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 830F48FC: 4098000C  bge cr6, 0x830f4908
	if !ctx.cr[6].lt {
	pc = 0x830F4908; continue 'dispatch;
	}
	// 830F4900: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 830F4904: 48000044  b 0x830f4948
	pc = 0x830F4948; continue 'dispatch;
	// 830F4908: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F490C: EC2D0024  fdivs f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 830F4910: 480B73F9  bl 0x831abd08
	ctx.lr = 0x830F4914;
	sub_831ABD08(ctx, base);
	// 830F4914: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F4918: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F491C: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F4920: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F4924: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F4928: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830F492C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F4930: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830F4934: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F4938: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830F493C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F4940: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 830F4944: EC0D0338  fmsubs f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F4948: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830F494C: 48000008  b 0x830f4954
	pc = 0x830F4954; continue 'dispatch;
	// 830F4950: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830F4954: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F4958: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F495C: 419A006C  beq cr6, 0x830f49c8
	if ctx.cr[6].eq {
	pc = 0x830F49C8; continue 'dispatch;
	}
	// 830F4960: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F4964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F4968: 419A0060  beq cr6, 0x830f49c8
	if ctx.cr[6].eq {
	pc = 0x830F49C8; continue 'dispatch;
	}
	// 830F496C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F4970: 419A0058  beq cr6, 0x830f49c8
	if ctx.cr[6].eq {
	pc = 0x830F49C8; continue 'dispatch;
	}
	// 830F4974: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4978: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 830F497C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4980: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830F4984: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830F4988: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F498C: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830F4990: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F4994: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830F4998: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F499C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830F49A0: 48017529  bl 0x8310bec8
	ctx.lr = 0x830F49A4;
	sub_8310BEC8(ctx, base);
	// 830F49A4: C1A10060  lfs f13, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F49A8: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F49AC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F49B0: C181006C  lfs f12, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F49B4: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830F49B8: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F49BC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F49C0: D1BF00C8  stfs f13, 0xc8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830F49C4: 4800000C  b 0x830f49d0
	pc = 0x830F49D0; continue 'dispatch;
	// 830F49C8: D3FF00CC  stfs f31, 0xcc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830F49CC: D3FF00C8  stfs f31, 0xc8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830F49D0: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F49D4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830F49D8: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F49DC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F49E0: 409A004C  bne cr6, 0x830f4a2c
	if !ctx.cr[6].eq {
	pc = 0x830F4A2C; continue 'dispatch;
	}
	// 830F49E4: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F49E8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830F49EC: C01F00C8  lfs f0, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F49F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F49F4: 41990008  bgt cr6, 0x830f49fc
	if ctx.cr[6].gt {
	pc = 0x830F49FC; continue 'dispatch;
	}
	// 830F49F8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830F49FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F4A00: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F4A04: 4BFF2E75  bl 0x830e7878
	ctx.lr = 0x830F4A08;
	sub_830E7878(ctx, base);
	// 830F4A08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F4A0C: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830F4A10: 4BFF2E69  bl 0x830e7878
	ctx.lr = 0x830F4A14;
	sub_830E7878(ctx, base);
	// 830F4A14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F4A18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4A1C: 4BFF2E5D  bl 0x830e7878
	ctx.lr = 0x830F4A20;
	sub_830E7878(ctx, base);
	// 830F4A20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F4A24: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F4A28: 4BFF2E51  bl 0x830e7878
	ctx.lr = 0x830F4A2C;
	sub_830E7878(ctx, base);
	// 830F4A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4A30: 4BFFFA69  bl 0x830f4498
	ctx.lr = 0x830F4A34;
	sub_830F4498(ctx, base);
	// 830F4A34: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F4A38: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F4A3C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F4A40: 409A00A0  bne cr6, 0x830f4ae0
	if !ctx.cr[6].eq {
	pc = 0x830F4AE0; continue 'dispatch;
	}
	// 830F4A44: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4A48: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4A4C: 40990094  ble cr6, 0x830f4ae0
	if !ctx.cr[6].gt {
	pc = 0x830F4AE0; continue 'dispatch;
	}
	// 830F4A50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830F4A54: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4A58: C3EB9F7C  lfs f31, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F4A5C: ED80F828  fsubs f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 830F4A60: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830F4A64: 40990014  ble cr6, 0x830f4a78
	if !ctx.cr[6].gt {
	pc = 0x830F4A78; continue 'dispatch;
	}
	// 830F4A68: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F4A6C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830F4A70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F4A74: 41980008  blt cr6, 0x830f4a7c
	if ctx.cr[6].lt {
	pc = 0x830F4A7C; continue 'dispatch;
	}
	// 830F4A78: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830F4A7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F4A80: 9BBF0040  stb r29, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 830F4A84: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830F4A88: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F4A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4A90: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F4A94: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830F4A98: 4BFF9311  bl 0x830edda8
	ctx.lr = 0x830F4A9C;
	sub_830EDDA8(ctx, base);
	// 830F4A9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830F4AA0: C01F009C  lfs f0, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4AA4: C1ABB59C  lfs f13, -0x4a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4AA8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F4AAC: 40990010  ble cr6, 0x830f4abc
	if !ctx.cr[6].gt {
	pc = 0x830F4ABC; continue 'dispatch;
	}
	// 830F4AB0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4AB4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830F4AB8: 41980008  blt cr6, 0x830f4ac0
	if ctx.cr[6].lt {
	pc = 0x830F4AC0; continue 'dispatch;
	}
	// 830F4ABC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830F4AC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F4AC4: 9BBF0030  stb r29, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 830F4AC8: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830F4ACC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F4AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4AD4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F4AD8: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830F4ADC: 4BFF92CD  bl 0x830edda8
	ctx.lr = 0x830F4AE0;
	sub_830EDDA8(ctx, base);
	// 830F4AE0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F4AE4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830F4AE8: 480B36CC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F4AF0 size=612
    let mut pc: u32 = 0x830F4AF0;
    'dispatch: loop {
        match pc {
            0x830F4AF0 => {
    //   block [0x830F4AF0..0x830F4D54)
	// 830F4AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F4AF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F4AFC: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 830F4B00: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830F4B04: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4B08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4B0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F4B10: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830F4B14: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F4B18: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F4B1C: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F4B20: C3C99F7C  lfs f30, -0x6084(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F4B24: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F4B28: 409A0078  bne cr6, 0x830f4ba0
	if !ctx.cr[6].eq {
	pc = 0x830F4BA0; continue 'dispatch;
	}
	// 830F4B2C: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4B30: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4B34: 419A006C  beq cr6, 0x830f4ba0
	if ctx.cr[6].eq {
	pc = 0x830F4BA0; continue 'dispatch;
	}
	// 830F4B38: 480D0529  bl 0x831c5060
	ctx.lr = 0x830F4B3C;
	sub_831C5060(ctx, base);
	// 830F4B3C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830F4B40: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F4B44: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F4B48: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830F4B4C: C1AA92E0  lfs f13, -0x6d20(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27936 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4B50: 40980018  bge cr6, 0x830f4b68
	if !ctx.cr[6].lt {
	pc = 0x830F4B68; continue 'dispatch;
	}
	// 830F4B54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F4B58: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830F4B5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F4B60: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F4B64: 48000010  b 0x830f4b74
	pc = 0x830F4B74; continue 'dispatch;
	// 830F4B68: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830F4B6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F4B70: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F4B74: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F4B78: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F4B7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F4B80: 40990008  ble cr6, 0x830f4b88
	if !ctx.cr[6].gt {
	pc = 0x830F4B88; continue 'dispatch;
	}
	// 830F4B84: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830F4B88: EDA007B2  fmuls f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 830F4B8C: C19F009C  lfs f12, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F4B90: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4B94: 907F00B8  stw r3, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[3].u32 ) };
	// 830F4B98: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 830F4B9C: 48000010  b 0x830f4bac
	pc = 0x830F4BAC; continue 'dispatch;
	// 830F4BA0: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4BA4: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4BA8: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F4BAC: D1BF009C  stfs f13, 0x9c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F4BB0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4BB4: 4099006C  ble cr6, 0x830f4c20
	if !ctx.cr[6].gt {
	pc = 0x830F4C20; continue 'dispatch;
	}
	// 830F4BB8: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4BBC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F4BC0: 419800D4  blt cr6, 0x830f4c94
	if ctx.cr[6].lt {
	pc = 0x830F4C94; continue 'dispatch;
	}
	// 830F4BC4: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F4BC8: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 830F4BCC: D3FF00A8  stfs f31, 0xa8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F4BD0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4BD4: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 830F4BD8: 4800B3E1  bl 0x830fffb8
	ctx.lr = 0x830F4BDC;
	sub_830FFFB8(ctx, base);
	// 830F4BDC: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4BE0: ED80F028  fsubs f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 830F4BE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F4BE8: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4BEC: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 830F4BF0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830F4BF4: 40990014  ble cr6, 0x830f4c08
	if !ctx.cr[6].gt {
	pc = 0x830F4C08; continue 'dispatch;
	}
	// 830F4BF8: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 830F4BFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F4C00: 40980008  bge cr6, 0x830f4c08
	if !ctx.cr[6].lt {
	pc = 0x830F4C08; continue 'dispatch;
	}
	// 830F4C04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4C08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F4C0C: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830F4C10: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F4C14: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F4C18: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830F4C1C: 48000070  b 0x830f4c8c
	pc = 0x830F4C8C; continue 'dispatch;
	// 830F4C20: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4C24: 40980078  bge cr6, 0x830f4c9c
	if !ctx.cr[6].lt {
	pc = 0x830F4C9C; continue 'dispatch;
	}
	// 830F4C28: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4C2C: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4C30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F4C34: 41990060  bgt cr6, 0x830f4c94
	if ctx.cr[6].gt {
	pc = 0x830F4C94; continue 'dispatch;
	}
	// 830F4C38: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F4C3C: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 830F4C40: D3FF00A8  stfs f31, 0xa8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F4C44: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4C48: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 830F4C4C: 4800B36D  bl 0x830fffb8
	ctx.lr = 0x830F4C50;
	sub_830FFFB8(ctx, base);
	// 830F4C50: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830F4C54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F4C58: C01F009C  lfs f0, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4C5C: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 830F4C60: C1AAB59C  lfs f13, -0x4a64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4C64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F4C68: 40990010  ble cr6, 0x830f4c78
	if !ctx.cr[6].gt {
	pc = 0x830F4C78; continue 'dispatch;
	}
	// 830F4C6C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830F4C70: 40980008  bge cr6, 0x830f4c78
	if !ctx.cr[6].lt {
	pc = 0x830F4C78; continue 'dispatch;
	}
	// 830F4C74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4C78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F4C7C: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830F4C80: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F4C84: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F4C88: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830F4C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4C90: 4BFF9119  bl 0x830edda8
	ctx.lr = 0x830F4C94;
	sub_830EDDA8(ctx, base);
	// 830F4C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4C98: 4BFFF801  bl 0x830f4498
	ctx.lr = 0x830F4C9C;
	sub_830F4498(ctx, base);
	// 830F4C9C: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F4CA0: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F4CA4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F4CA8: 409A0090  bne cr6, 0x830f4d38
	if !ctx.cr[6].eq {
	pc = 0x830F4D38; continue 'dispatch;
	}
	// 830F4CAC: C01F00A8  lfs f0, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F4CB0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4CB4: 419A0084  beq cr6, 0x830f4d38
	if ctx.cr[6].eq {
	pc = 0x830F4D38; continue 'dispatch;
	}
	// 830F4CB8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4CBC: 40990038  ble cr6, 0x830f4cf4
	if !ctx.cr[6].gt {
	pc = 0x830F4CF4; continue 'dispatch;
	}
	// 830F4CC0: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F4CC4: C1BF00B0  lfs f13, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4CC8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830F4CCC: C19F00B4  lfs f12, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F4CD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F4CD4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F4CD8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830F4CDC: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830F4CE0: ED4D002A  fadds f10, f13, f0
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F4CE4: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 830F4CE8: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 830F4CEC: 41980048  blt cr6, 0x830f4d34
	if ctx.cr[6].lt {
	pc = 0x830F4D34; continue 'dispatch;
	}
	// 830F4CF0: 48000040  b 0x830f4d30
	pc = 0x830F4D30; continue 'dispatch;
	// 830F4CF4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F4CF8: 40980040  bge cr6, 0x830f4d38
	if !ctx.cr[6].lt {
	pc = 0x830F4D38; continue 'dispatch;
	}
	// 830F4CFC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F4D00: C19F00B4  lfs f12, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F4D04: C1BF00B0  lfs f13, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F4D08: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830F4D0C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F4D10: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F4D14: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830F4D18: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830F4D1C: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F4D20: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 830F4D24: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 830F4D28: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 830F4D2C: 41990008  bgt cr6, 0x830f4d34
	if ctx.cr[6].gt {
	pc = 0x830F4D34; continue 'dispatch;
	}
	// 830F4D30: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F4D34: D19F00A8  stfs f12, 0xa8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F4D38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F4D3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F4D40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F4D44: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830F4D48: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F4D4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F4D50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4D58 size=180
    let mut pc: u32 = 0x830F4D58;
    'dispatch: loop {
        match pc {
            0x830F4D58 => {
    //   block [0x830F4D58..0x830F4E0C)
	// 830F4D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4D5C: 480B340D  bl 0x831a8168
	ctx.lr = 0x830F4D60;
	sub_831A8130(ctx, base);
	// 830F4D60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4D64: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830F4D68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4D6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F4D70: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4D74: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F4D78: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F4D7C: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4D80: 419A001C  beq cr6, 0x830f4d9c
	if ctx.cr[6].eq {
	pc = 0x830F4D9C; continue 'dispatch;
	}
	// 830F4D84: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830F4D88: 409A0078  bne cr6, 0x830f4e00
	if !ctx.cr[6].eq {
	pc = 0x830F4E00; continue 'dispatch;
	}
	// 830F4D8C: 4BFF982D  bl 0x830ee5b8
	ctx.lr = 0x830F4D90;
	sub_830EE5B8(ctx, base);
	// 830F4D90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4D94: 4080006C  bge 0x830f4e00
	if !ctx.cr[0].lt {
	pc = 0x830F4E00; continue 'dispatch;
	}
	// 830F4D98: 4800006C  b 0x830f4e04
	pc = 0x830F4E04; continue 'dispatch;
	// 830F4D9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F4DA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F4DA4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F4DA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F4DAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F4DB0: 4BFEB6A1  bl 0x830e0450
	ctx.lr = 0x830F4DB4;
	sub_830E0450(ctx, base);
	// 830F4DB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F4DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4DBC: 4BFF978D  bl 0x830ee548
	ctx.lr = 0x830F4DC0;
	sub_830EE548(ctx, base);
	// 830F4DC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4DC4: 4180002C  blt 0x830f4df0
	if ctx.cr[0].lt {
	pc = 0x830F4DF0; continue 'dispatch;
	}
	// 830F4DC8: 809F0084  lwz r4, 0x84(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830F4DCC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F4DD0: 419A0020  beq cr6, 0x830f4df0
	if ctx.cr[6].eq {
	pc = 0x830F4DF0; continue 'dispatch;
	}
	// 830F4DD4: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F4DD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F4DDC: 6165000A  ori r5, r11, 0xa
	ctx.r[5].u64 = ctx.r[11].u64 | 10;
	// 830F4DE0: 4801B551  bl 0x83110330
	ctx.lr = 0x830F4DE4;
	sub_83110330(ctx, base);
	// 830F4DE4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 830F4DE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F4DEC: 4801B595  bl 0x83110380
	ctx.lr = 0x830F4DF0;
	sub_83110380(ctx, base);
	// 830F4DF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F4DF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F4DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F4DFC: 4BFEB6B5  bl 0x830e04b0
	ctx.lr = 0x830F4E00;
	sub_830E04B0(ctx, base);
	// 830F4E00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F4E04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F4E08: 480B33B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4E10 size=312
    let mut pc: u32 = 0x830F4E10;
    'dispatch: loop {
        match pc {
            0x830F4E10 => {
    //   block [0x830F4E10..0x830F4F48)
	// 830F4E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4E14: 480B3355  bl 0x831a8168
	ctx.lr = 0x830F4E18;
	sub_831A8130(ctx, base);
	// 830F4E18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4E1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F4E20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4E24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4E28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F4E2C: 419A0074  beq cr6, 0x830f4ea0
	if ctx.cr[6].eq {
	pc = 0x830F4EA0; continue 'dispatch;
	}
	// 830F4E30: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F4E34: 419A0060  beq cr6, 0x830f4e94
	if ctx.cr[6].eq {
	pc = 0x830F4E94; continue 'dispatch;
	}
	// 830F4E38: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830F4E3C: 419A004C  beq cr6, 0x830f4e88
	if ctx.cr[6].eq {
	pc = 0x830F4E88; continue 'dispatch;
	}
	// 830F4E40: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830F4E44: 419A001C  beq cr6, 0x830f4e60
	if ctx.cr[6].eq {
	pc = 0x830F4E60; continue 'dispatch;
	}
	// 830F4E48: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 830F4E4C: 409A00DC  bne cr6, 0x830f4f28
	if !ctx.cr[6].eq {
	pc = 0x830F4F28; continue 'dispatch;
	}
	// 830F4E50: 4BFF9919  bl 0x830ee768
	ctx.lr = 0x830F4E54;
	sub_830EE768(ctx, base);
	// 830F4E54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4E58: 408000D0  bge 0x830f4f28
	if !ctx.cr[0].lt {
	pc = 0x830F4F28; continue 'dispatch;
	}
	// 830F4E5C: 480000E4  b 0x830f4f40
	pc = 0x830F4F40; continue 'dispatch;
	// 830F4E60: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4E64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4E68: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F4E6C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F4E70: 409A00B8  bne cr6, 0x830f4f28
	if !ctx.cr[6].eq {
	pc = 0x830F4F28; continue 'dispatch;
	}
	// 830F4E74: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830F4E78: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F4E7C: 409A00AC  bne cr6, 0x830f4f28
	if !ctx.cr[6].eq {
	pc = 0x830F4F28; continue 'dispatch;
	}
	// 830F4E80: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F4E84: 4BFF14C5  bl 0x830e6348
	ctx.lr = 0x830F4E88;
	sub_830E6348(ctx, base);
	// 830F4E88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4E8C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 830F4E90: 48000098  b 0x830f4f28
	pc = 0x830F4F28; continue 'dispatch;
	// 830F4E94: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F4E98: 4BFF14B1  bl 0x830e6348
	ctx.lr = 0x830F4E9C;
	sub_830E6348(ctx, base);
	// 830F4E9C: 4800008C  b 0x830f4f28
	pc = 0x830F4F28; continue 'dispatch;
	// 830F4EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4EA4: 4BFF98C5  bl 0x830ee768
	ctx.lr = 0x830F4EA8;
	sub_830EE768(ctx, base);
	// 830F4EA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4EAC: 41800094  blt 0x830f4f40
	if ctx.cr[0].lt {
	pc = 0x830F4F40; continue 'dispatch;
	}
	// 830F4EB0: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830F4EB4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F4EB8: 409A0078  bne cr6, 0x830f4f30
	if !ctx.cr[6].eq {
	pc = 0x830F4F30; continue 'dispatch;
	}
	// 830F4EBC: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4EC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F4EC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F4EC8: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4ECC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F4ED0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4ED4: 4BFEB57D  bl 0x830e0450
	ctx.lr = 0x830F4ED8;
	sub_830E0450(ctx, base);
	// 830F4ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4EDC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4EE0: 4BFF9A31  bl 0x830ee910
	ctx.lr = 0x830F4EE4;
	sub_830EE910(ctx, base);
	// 830F4EE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4EE8: 41800030  blt 0x830f4f18
	if ctx.cr[0].lt {
	pc = 0x830F4F18; continue 'dispatch;
	}
	// 830F4EEC: 809F0088  lwz r4, 0x88(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F4EF0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F4EF4: 419A0024  beq cr6, 0x830f4f18
	if ctx.cr[6].eq {
	pc = 0x830F4F18; continue 'dispatch;
	}
	// 830F4EF8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830F4EFC: 38DF0098  addi r6, r31, 0x98
	ctx.r[6].s64 = ctx.r[31].s64 + 152;
	// 830F4F00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F4F04: 6165000A  ori r5, r11, 0xa
	ctx.r[5].u64 = ctx.r[11].u64 | 10;
	// 830F4F08: 4801BA49  bl 0x83110950
	ctx.lr = 0x830F4F0C;
	sub_83110950(ctx, base);
	// 830F4F0C: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 830F4F10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F4F14: 4801B46D  bl 0x83110380
	ctx.lr = 0x830F4F18;
	sub_83110380(ctx, base);
	// 830F4F18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F4F1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4F20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F4F24: 4BFEB58D  bl 0x830e04b0
	ctx.lr = 0x830F4F28;
	sub_830E04B0(ctx, base);
	// 830F4F28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F4F2C: 48000014  b 0x830f4f40
	pc = 0x830F4F40; continue 'dispatch;
	// 830F4F30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F4F34: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4F38: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F4F3C: 4BFFFE1D  bl 0x830f4d58
	ctx.lr = 0x830F4F40;
	sub_830F4D58(ctx, base);
	// 830F4F40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F4F44: 480B3274  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F4F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F4F48 size=220
    let mut pc: u32 = 0x830F4F48;
    'dispatch: loop {
        match pc {
            0x830F4F48 => {
    //   block [0x830F4F48..0x830F5024)
	// 830F4F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F4F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F4F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F4F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F4F58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F4F5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F4F60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F4F64: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F4F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F4F6C: 419A0080  beq cr6, 0x830f4fec
	if ctx.cr[6].eq {
	pc = 0x830F4FEC; continue 'dispatch;
	}
	// 830F4F70: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830F4F74: 419A0054  beq cr6, 0x830f4fc8
	if ctx.cr[6].eq {
	pc = 0x830F4FC8; continue 'dispatch;
	}
	// 830F4F78: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 830F4F7C: 419A005C  beq cr6, 0x830f4fd8
	if ctx.cr[6].eq {
	pc = 0x830F4FD8; continue 'dispatch;
	}
	// 830F4F80: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830F4F84: 419A001C  beq cr6, 0x830f4fa0
	if ctx.cr[6].eq {
	pc = 0x830F4FA0; continue 'dispatch;
	}
	// 830F4F88: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 830F4F8C: 409A0044  bne cr6, 0x830f4fd0
	if !ctx.cr[6].eq {
	pc = 0x830F4FD0; continue 'dispatch;
	}
	// 830F4F90: 4BFF99F1  bl 0x830ee980
	ctx.lr = 0x830F4F94;
	sub_830EE980(ctx, base);
	// 830F4F94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4F98: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F4F9C: 48000034  b 0x830f4fd0
	pc = 0x830F4FD0; continue 'dispatch;
	// 830F4FA0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4FA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F4FA8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F4FAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F4FB0: 409A0020  bne cr6, 0x830f4fd0
	if !ctx.cr[6].eq {
	pc = 0x830F4FD0; continue 'dispatch;
	}
	// 830F4FB4: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830F4FB8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F4FBC: 409A0014  bne cr6, 0x830f4fd0
	if !ctx.cr[6].eq {
	pc = 0x830F4FD0; continue 'dispatch;
	}
	// 830F4FC0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F4FC4: 4BFF1385  bl 0x830e6348
	ctx.lr = 0x830F4FC8;
	sub_830E6348(ctx, base);
	// 830F4FC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4FCC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 830F4FD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F4FD4: 48000038  b 0x830f500c
	pc = 0x830F500C; continue 'dispatch;
	// 830F4FD8: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F4FDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F4FE0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F4FE4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F4FE8: 4BFFFFE8  b 0x830f4fd0
	pc = 0x830F4FD0; continue 'dispatch;
	// 830F4FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F4FF0: 4BFF9991  bl 0x830ee980
	ctx.lr = 0x830F4FF4;
	sub_830EE980(ctx, base);
	// 830F4FF4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F4FF8: 41800014  blt 0x830f500c
	if ctx.cr[0].lt {
	pc = 0x830F500C; continue 'dispatch;
	}
	// 830F4FFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F5000: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5004: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F5008: 4BFFFD51  bl 0x830f4d58
	ctx.lr = 0x830F500C;
	sub_830F4D58(ctx, base);
	// 830F500C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F5010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5018: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F501C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F5028 size=884
    let mut pc: u32 = 0x830F5028;
    'dispatch: loop {
        match pc {
            0x830F5028 => {
    //   block [0x830F5028..0x830F539C)
	// 830F5028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F502C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5034: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F503C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F5040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F5044: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5048: 4BFF27C1  bl 0x830e7808
	ctx.lr = 0x830F504C;
	sub_830E7808(ctx, base);
	// 830F504C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 830F5050: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F5054: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F5058: 4801B3C1  bl 0x83110418
	ctx.lr = 0x830F505C;
	sub_83110418(ctx, base);
	// 830F505C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F5060: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830F5064: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5068: 397F0024  addi r11, r31, 0x24
	ctx.r[11].s64 = ctx.r[31].s64 + 36;
	// 830F506C: C1810050  lfs f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F5070: 397F0044  addi r11, r31, 0x44
	ctx.r[11].s64 = ctx.r[31].s64 + 68;
	// 830F5074: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F5078: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 830F507C: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5080: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F5084: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F5088: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F508C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F5090: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830F5094: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830F5098: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830F509C: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830F50A0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 830F50A4: C9010050  lfd f8, 0x50(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F50A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F50AC: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830F50B0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830F50B4: C8E10060  lfd f7, 0x60(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830F50B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830F50BC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830F50C0: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830F50C4: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830F50C8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 830F50CC: C8C10068  lfd f6, 0x68(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830F50D0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830F50D4: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 830F50D8: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 830F50DC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 830F50E0: C8A10068  lfd f5, 0x68(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 830F50E4: FCA02E9C  fcfid f5, f5
	ctx.f[5].f64 = (ctx.f[5].s64 as f64);
	// 830F50E8: 397F0084  addi r11, r31, 0x84
	ctx.r[11].s64 = ctx.r[31].s64 + 132;
	// 830F50EC: FCE03E9C  fcfid f7, f7
	ctx.f[7].f64 = (ctx.f[7].s64 as f64);
	// 830F50F0: 397F00A4  addi r11, r31, 0xa4
	ctx.r[11].s64 = ctx.r[31].s64 + 164;
	// 830F50F4: FCC0369C  fcfid f6, f6
	ctx.f[6].f64 = (ctx.f[6].s64 as f64);
	// 830F50F8: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 830F50FC: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 830F5100: FCA02818  frsp f5, f5
	ctx.f[5].f64 = (ctx.f[5].f64 as f32) as f64;
	// 830F5104: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830F5108: FCE03818  frsp f7, f7
	ctx.f[7].f64 = (ctx.f[7].f64 as f32) as f64;
	// 830F510C: D0FF0028  stfs f7, 0x28(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 830F5110: FCC03018  frsp f6, f6
	ctx.f[6].f64 = (ctx.f[6].f64 as f32) as f64;
	// 830F5114: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830F5118: EC894024  fdivs f4, f9, f8
	ctx.f[4].f64 = ((ctx.f[9].f64 / ctx.f[8].f64) as f32) as f64;
	// 830F511C: ED2C4828  fsubs f9, f12, f9
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 830F5120: ED4A2824  fdivs f10, f10, f5
	ctx.f[10].f64 = ((ctx.f[10].f64 / ctx.f[5].f64) as f32) as f64;
	// 830F5124: ECA72824  fdivs f5, f7, f5
	ctx.f[5].f64 = ((ctx.f[7].f64 / ctx.f[5].f64) as f32) as f64;
	// 830F5128: D0BF0030  stfs f5, 0x30(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830F512C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830F5130: ED064024  fdivs f8, f6, f8
	ctx.f[8].f64 = ((ctx.f[6].f64 / ctx.f[8].f64) as f32) as f64;
	// 830F5134: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830F5138: EC6B3828  fsubs f3, f11, f7
	ctx.f[3].f64 = (((ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 830F513C: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830F5140: EC8D2028  fsubs f4, f13, f4
	ctx.f[4].f64 = (((ctx.f[13].f64 - ctx.f[4].f64) as f32) as f64);
	// 830F5144: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830F5148: D0DF0044  stfs f6, 0x44(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830F514C: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 830F5150: D0FF0048  stfs f7, 0x48(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830F5154: D11F004C  stfs f8, 0x4c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830F5158: D0BF0050  stfs f5, 0x50(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830F515C: D0DF0054  stfs f6, 0x54(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830F5160: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830F5164: D11F005C  stfs f8, 0x5c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830F5168: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830F516C: D13F0064  stfs f9, 0x64(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830F5170: D0FF0068  stfs f7, 0x68(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830F5174: D09F006C  stfs f4, 0x6c(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830F5178: D0BF0070  stfs f5, 0x70(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830F517C: D13F0074  stfs f9, 0x74(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830F5180: 397F00B4  addi r11, r31, 0xb4
	ctx.r[11].s64 = ctx.r[31].s64 + 180;
	// 830F5184: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830F5188: 397F00C4  addi r11, r31, 0xc4
	ctx.r[11].s64 = ctx.r[31].s64 + 196;
	// 830F518C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830F5190: 397F00D4  addi r11, r31, 0xd4
	ctx.r[11].s64 = ctx.r[31].s64 + 212;
	// 830F5194: D09F007C  stfs f4, 0x7c(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830F5198: 397F00E4  addi r11, r31, 0xe4
	ctx.r[11].s64 = ctx.r[31].s64 + 228;
	// 830F519C: D19F0084  stfs f12, 0x84(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830F51A0: 397F00F4  addi r11, r31, 0xf4
	ctx.r[11].s64 = ctx.r[31].s64 + 244;
	// 830F51A4: D0FF0088  stfs f7, 0x88(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830F51A8: 397F0104  addi r11, r31, 0x104
	ctx.r[11].s64 = ctx.r[31].s64 + 260;
	// 830F51AC: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830F51B0: 397F0114  addi r11, r31, 0x114
	ctx.r[11].s64 = ctx.r[31].s64 + 276;
	// 830F51B4: D0BF0090  stfs f5, 0x90(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830F51B8: 397F0124  addi r11, r31, 0x124
	ctx.r[11].s64 = ctx.r[31].s64 + 292;
	// 830F51BC: D19F0094  stfs f12, 0x94(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830F51C0: 397F0134  addi r11, r31, 0x134
	ctx.r[11].s64 = ctx.r[31].s64 + 308;
	// 830F51C4: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830F51C8: 397F0154  addi r11, r31, 0x154
	ctx.r[11].s64 = ctx.r[31].s64 + 340;
	// 830F51CC: D1BF009C  stfs f13, 0x9c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F51D0: 397F0174  addi r11, r31, 0x174
	ctx.r[11].s64 = ctx.r[31].s64 + 372;
	// 830F51D4: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F51D8: 395F0194  addi r10, r31, 0x194
	ctx.r[10].s64 = ctx.r[31].s64 + 404;
	// 830F51DC: C0FF0084  lfs f7, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F51E0: D0FF00A4  stfs f7, 0xa4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830F51E4: C0FF0088  lfs f7, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F51E8: D0FF00A8  stfs f7, 0xa8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F51EC: C0FF008C  lfs f7, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F51F0: D0FF00AC  stfs f7, 0xac(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830F51F4: C0FF0090  lfs f7, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F51F8: D0FF00B0  stfs f7, 0xb0(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830F51FC: D19F00B4  stfs f12, 0xb4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830F5200: D07F00B8  stfs f3, 0xb8(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830F5204: D1BF00BC  stfs f13, 0xbc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830F5208: D15F00C0  stfs f10, 0xc0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830F520C: C0FF0064  lfs f7, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5210: D0FF00C4  stfs f7, 0xc4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830F5214: C0FF0068  lfs f7, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5218: D0FF00C8  stfs f7, 0xc8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830F521C: C0FF006C  lfs f7, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5220: D0FF00CC  stfs f7, 0xcc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830F5224: C0FF0070  lfs f7, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5228: D0FF00D0  stfs f7, 0xd0(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830F522C: D13F00D4  stfs f9, 0xd4(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 830F5230: D07F00D8  stfs f3, 0xd8(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 830F5234: D09F00DC  stfs f4, 0xdc(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 830F5238: D15F00E0  stfs f10, 0xe0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 830F523C: C0FF0044  lfs f7, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5240: D0FF00E4  stfs f7, 0xe4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 830F5244: C0FF0048  lfs f7, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5248: D0FF00E8  stfs f7, 0xe8(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 830F524C: C0FF004C  lfs f7, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5250: D0FF00EC  stfs f7, 0xec(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 830F5254: C0FF0050  lfs f7, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5258: D0FF00F0  stfs f7, 0xf0(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 830F525C: D0DF00F4  stfs f6, 0xf4(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 830F5260: D07F00F8  stfs f3, 0xf8(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 830F5264: D11F00FC  stfs f8, 0xfc(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 830F5268: D15F0100  stfs f10, 0x100(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 830F526C: C0FF0024  lfs f7, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5270: D0FF0104  stfs f7, 0x104(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 830F5274: C0FF0028  lfs f7, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5278: D0FF0108  stfs f7, 0x108(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 830F527C: C0FF002C  lfs f7, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5280: D0FF010C  stfs f7, 0x10c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 830F5284: C0FF0030  lfs f7, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830F5288: D0FF0110  stfs f7, 0x110(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 830F528C: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 830F5290: D07F0118  stfs f3, 0x118(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 830F5294: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 830F5298: D15F0120  stfs f10, 0x120(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 830F529C: C15F0114  lfs f10, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52A0: D15F0124  stfs f10, 0x124(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 830F52A4: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52A8: D15F0128  stfs f10, 0x128(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 830F52AC: C15F011C  lfs f10, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52B0: D15F012C  stfs f10, 0x12c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 830F52B4: C15F0120  lfs f10, 0x120(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52B8: D15F0130  stfs f10, 0x130(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 830F52BC: C15F0114  lfs f10, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52C0: D15F0134  stfs f10, 0x134(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 830F52C4: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52C8: D15F0138  stfs f10, 0x138(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 830F52CC: C15F011C  lfs f10, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52D0: D15F013C  stfs f10, 0x13c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 830F52D4: C15F0120  lfs f10, 0x120(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F52D8: D15F0140  stfs f10, 0x140(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 830F52DC: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 830F52E0: D17F0148  stfs f11, 0x148(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 830F52E4: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 830F52E8: D1BF0150  stfs f13, 0x150(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 830F52EC: C01F00F4  lfs f0, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F52F0: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 830F52F4: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F52F8: D01F0158  stfs f0, 0x158(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 830F52FC: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5300: D01F015C  stfs f0, 0x15c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 830F5304: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5308: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 830F530C: D0DF0164  stfs f6, 0x164(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 830F5310: D17F0168  stfs f11, 0x168(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 830F5314: D11F016C  stfs f8, 0x16c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 830F5318: D1BF0170  stfs f13, 0x170(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 830F531C: C01F00D4  lfs f0, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5320: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 830F5324: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5328: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 830F532C: C01F00DC  lfs f0, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5330: D01F017C  stfs f0, 0x17c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 830F5334: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5338: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 830F533C: D13F0184  stfs f9, 0x184(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 830F5340: D17F0188  stfs f11, 0x188(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 830F5344: D09F018C  stfs f4, 0x18c(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 830F5348: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 830F534C: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5350: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 830F5354: C01F00B8  lfs f0, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5358: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 830F535C: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5360: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 830F5364: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F5368: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 830F536C: D19F01A4  stfs f12, 0x1a4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 830F5370: D17F01A8  stfs f11, 0x1a8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 830F5374: D1BF01AC  stfs f13, 0x1ac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 830F5378: D1BF01B0  stfs f13, 0x1b0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 830F537C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5380: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F5384: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F5388: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F538C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5394: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F53A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F53A0 size=404
    let mut pc: u32 = 0x830F53A0;
    'dispatch: loop {
        match pc {
            0x830F53A0 => {
    //   block [0x830F53A0..0x830F5534)
	// 830F53A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F53A4: 480B2DC9  bl 0x831a816c
	ctx.lr = 0x830F53A8;
	sub_831A8130(ctx, base);
	// 830F53A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F53AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F53B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F53B4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F53B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F53BC: 419A00B0  beq cr6, 0x830f546c
	if ctx.cr[6].eq {
	pc = 0x830F546C; continue 'dispatch;
	}
	// 830F53C0: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830F53C4: 419A0068  beq cr6, 0x830f542c
	if ctx.cr[6].eq {
	pc = 0x830F542C; continue 'dispatch;
	}
	// 830F53C8: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830F53CC: 419A0038  beq cr6, 0x830f5404
	if ctx.cr[6].eq {
	pc = 0x830F5404; continue 'dispatch;
	}
	// 830F53D0: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 830F53D4: 409A0154  bne cr6, 0x830f5528
	if !ctx.cr[6].eq {
	pc = 0x830F5528; continue 'dispatch;
	}
	// 830F53D8: 4BFFA2A9  bl 0x830ef680
	ctx.lr = 0x830F53DC;
	sub_830EF680(ctx, base);
	// 830F53DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F53E0: 4180014C  blt 0x830f552c
	if ctx.cr[0].lt {
	pc = 0x830F552C; continue 'dispatch;
	}
	// 830F53E4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F53E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F53EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F53F0: 409A000C  bne cr6, 0x830f53fc
	if !ctx.cr[6].eq {
	pc = 0x830F53FC; continue 'dispatch;
	}
	// 830F53F4: 4BFFFC35  bl 0x830f5028
	ctx.lr = 0x830F53F8;
	sub_830F5028(ctx, base);
	// 830F53F8: 48000130  b 0x830f5528
	pc = 0x830F5528; continue 'dispatch;
	// 830F53FC: 4BFF9EA5  bl 0x830ef2a0
	ctx.lr = 0x830F5400;
	sub_830EF2A0(ctx, base);
	// 830F5400: 48000128  b 0x830f5528
	pc = 0x830F5528; continue 'dispatch;
	// 830F5404: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F5408: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F540C: 419A011C  beq cr6, 0x830f5528
	if ctx.cr[6].eq {
	pc = 0x830F5528; continue 'dispatch;
	}
	// 830F5410: 4801B051  bl 0x83110460
	ctx.lr = 0x830F5414;
	sub_83110460(ctx, base);
	// 830F5414: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F5418: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830F541C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5420: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830F5424: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F5428: 48000100  b 0x830f5528
	pc = 0x830F5528; continue 'dispatch;
	// 830F542C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F5430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F5434: 419A002C  beq cr6, 0x830f5460
	if ctx.cr[6].eq {
	pc = 0x830F5460; continue 'dispatch;
	}
	// 830F5438: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F543C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5440: 40820020  bne 0x830f5460
	if !ctx.cr[0].eq {
	pc = 0x830F5460; continue 'dispatch;
	}
	// 830F5444: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F5448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F544C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5450: 409A000C  bne cr6, 0x830f545c
	if !ctx.cr[6].eq {
	pc = 0x830F545C; continue 'dispatch;
	}
	// 830F5454: 4BFFFBD5  bl 0x830f5028
	ctx.lr = 0x830F5458;
	sub_830F5028(ctx, base);
	// 830F5458: 48000008  b 0x830f5460
	pc = 0x830F5460; continue 'dispatch;
	// 830F545C: 4BFF9E45  bl 0x830ef2a0
	ctx.lr = 0x830F5460;
	sub_830EF2A0(ctx, base);
	// 830F5460: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F5464: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F5468: 480000C0  b 0x830f5528
	pc = 0x830F5528; continue 'dispatch;
	// 830F546C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F5470: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F5474: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5478: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F547C: 4182000C  beq 0x830f5488
	if ctx.cr[0].eq {
	pc = 0x830F5488; continue 'dispatch;
	}
	// 830F5480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5484: 4BFFA1FD  bl 0x830ef680
	ctx.lr = 0x830F5488;
	sub_830EF680(ctx, base);
	// 830F5488: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F548C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F5490: 419A0098  beq cr6, 0x830f5528
	if ctx.cr[6].eq {
	pc = 0x830F5528; continue 'dispatch;
	}
	// 830F5494: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5498: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F549C: 41820020  beq 0x830f54bc
	if ctx.cr[0].eq {
	pc = 0x830F54BC; continue 'dispatch;
	}
	// 830F54A0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F54A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F54A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F54AC: 409A000C  bne cr6, 0x830f54b8
	if !ctx.cr[6].eq {
	pc = 0x830F54B8; continue 'dispatch;
	}
	// 830F54B0: 4BFFFB79  bl 0x830f5028
	ctx.lr = 0x830F54B4;
	sub_830F5028(ctx, base);
	// 830F54B4: 48000008  b 0x830f54bc
	pc = 0x830F54BC; continue 'dispatch;
	// 830F54B8: 4BFF9DE9  bl 0x830ef2a0
	ctx.lr = 0x830F54BC;
	sub_830EF2A0(ctx, base);
	// 830F54BC: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F54C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F54C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F54C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F54CC: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F54D0: 4BFEAF81  bl 0x830e0450
	ctx.lr = 0x830F54D4;
	sub_830E0450(ctx, base);
	// 830F54D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F54D8: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F54DC: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 830F54E0: 4801AE51  bl 0x83110330
	ctx.lr = 0x830F54E4;
	sub_83110330(ctx, base);
	// 830F54E4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F54E8: 38DF0024  addi r6, r31, 0x24
	ctx.r[6].s64 = ctx.r[31].s64 + 36;
	// 830F54EC: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 830F54F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F54F4: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F54F8: 212B0000  subfic r9, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[9].s64 = (0 as i64) - ctx.r[11].s64;
	// 830F54FC: 554B07BE  clrlwi r11, r10, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 830F5500: 7D494910  subfe r10, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830F5504: 38EB0019  addi r7, r11, 0x19
	ctx.r[7].s64 = ctx.r[11].s64 + 25;
	// 830F5508: 554B07BE  clrlwi r11, r10, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 830F550C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F5510: 38AB0017  addi r5, r11, 0x17
	ctx.r[5].s64 = ctx.r[11].s64 + 23;
	// 830F5514: 4801B36D  bl 0x83110880
	ctx.lr = 0x830F5518;
	sub_83110880(ctx, base);
	// 830F5518: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F551C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F5520: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5524: 4BFEAF8D  bl 0x830e04b0
	ctx.lr = 0x830F5528;
	sub_830E04B0(ctx, base);
	// 830F5528: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F552C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F5530: 480B2C8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5538 size=168
    let mut pc: u32 = 0x830F5538;
    'dispatch: loop {
        match pc {
            0x830F5538 => {
    //   block [0x830F5538..0x830F55E0)
	// 830F5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F553C: 480B2C31  bl 0x831a816c
	ctx.lr = 0x830F5540;
	sub_831A8130(ctx, base);
	// 830F5540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5548: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F554C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F5550: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5554: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F5558: 409A0050  bne cr6, 0x830f55a8
	if !ctx.cr[6].eq {
	pc = 0x830F55A8; continue 'dispatch;
	}
	// 830F555C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5560: 409A000C  bne cr6, 0x830f556c
	if !ctx.cr[6].eq {
	pc = 0x830F556C; continue 'dispatch;
	}
	// 830F5564: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F5568: 4800001C  b 0x830f5584
	pc = 0x830F5584; continue 'dispatch;
	// 830F556C: 557E083D  rlwinm. r30, r11, 1, 0, 0x1e
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F5570: 40810028  ble 0x830f5598
	if !ctx.cr[0].gt {
	pc = 0x830F5598; continue 'dispatch;
	}
	// 830F5574: 3D600492  lis r11, 0x492
	ctx.r[11].s64 = 76677120;
	// 830F5578: 616B4924  ori r11, r11, 0x4924
	ctx.r[11].u64 = ctx.r[11].u64 | 18724;
	// 830F557C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F5580: 40980018  bge cr6, 0x830f5598
	if !ctx.cr[6].lt {
	pc = 0x830F5598; continue 'dispatch;
	}
	// 830F5584: 1C9E001C  mulli r4, r30, 0x1c
	ctx.r[4].s64 = ctx.r[30].s64 * 28;
	// 830F5588: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F558C: 4BFE7F65  bl 0x830dd4f0
	ctx.lr = 0x830F5590;
	sub_830DD4F0(ctx, base);
	// 830F5590: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F5594: 4082000C  bne 0x830f55a0
	if !ctx.cr[0].eq {
	pc = 0x830F55A0; continue 'dispatch;
	}
	// 830F5598: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F559C: 4800003C  b 0x830f55d8
	pc = 0x830F55D8; continue 'dispatch;
	// 830F55A0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F55A4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F55A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F55AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F55B0: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 830F55B4: 7C6B5215  add. r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F55B8: 41820010  beq 0x830f55c8
	if ctx.cr[0].eq {
	pc = 0x830F55C8; continue 'dispatch;
	}
	// 830F55BC: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 830F55C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F55C4: 480B2F4D  bl 0x831a8510
	ctx.lr = 0x830F55C8;
	sub_831A8510(ctx, base);
	// 830F55C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F55CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F55D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F55D4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F55D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F55DC: 480B2BE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F55E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F55E0 size=72
    let mut pc: u32 = 0x830F55E0;
    'dispatch: loop {
        match pc {
            0x830F55E0 => {
    //   block [0x830F55E0..0x830F5628)
	// 830F55E0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F55E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F55E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F55EC: 40990028  ble cr6, 0x830f5614
	if !ctx.cr[6].gt {
	pc = 0x830F5614; continue 'dispatch;
	}
	// 830F55F0: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F55F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F55F8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F55FC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830F5600: 419A0018  beq cr6, 0x830f5618
	if ctx.cr[6].eq {
	pc = 0x830F5618; continue 'dispatch;
	}
	// 830F5604: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830F5608: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F560C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F5610: 4198FFE8  blt cr6, 0x830f55f8
	if ctx.cr[6].lt {
	pc = 0x830F55F8; continue 'dispatch;
	}
	// 830F5614: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 830F5618: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 830F561C: 409A000C  bne cr6, 0x830f5628
	if !ctx.cr[6].eq {
		sub_830F5628(ctx, base);
		return;
	}
	// 830F5620: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F5628 size=8
    let mut pc: u32 = 0x830F5628;
    'dispatch: loop {
        match pc {
            0x830F5628 => {
    //   block [0x830F5628..0x830F5630)
	// 830F5628: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 830F562C: 4BFF11DC  b 0x830e6808
	sub_830E6808(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5630 size=260
    let mut pc: u32 = 0x830F5630;
    'dispatch: loop {
        match pc {
            0x830F5630 => {
    //   block [0x830F5630..0x830F5734)
	// 830F5630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5634: 480B2B2D  bl 0x831a8160
	ctx.lr = 0x830F5638;
	sub_831A8130(ctx, base);
	// 830F5638: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F563C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830F5640: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F5644: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F5648: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830F564C: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 830F5650: 409A0008  bne cr6, 0x830f5658
	if !ctx.cr[6].eq {
	pc = 0x830F5658; continue 'dispatch;
	}
	// 830F5654: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5658: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F565C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F5660: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830F5664: 419800C4  blt cr6, 0x830f5728
	if ctx.cr[6].lt {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F5668: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F566C: 419900BC  bgt cr6, 0x830f5728
	if ctx.cr[6].gt {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F5670: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830F5674: 419800B4  blt cr6, 0x830f5728
	if ctx.cr[6].lt {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F5678: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F567C: 419800AC  blt cr6, 0x830f5728
	if ctx.cr[6].lt {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F5680: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 830F5684: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830F5688: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F568C: 4098009C  bge cr6, 0x830f5728
	if !ctx.cr[6].lt {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F5690: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F5694: 7F1C5000  cmpw cr6, r28, r10
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F5698: 40990030  ble cr6, 0x830f56c8
	if !ctx.cr[6].gt {
	pc = 0x830F56C8; continue 'dispatch;
	}
	// 830F569C: 579E083D  rlwinm. r30, r28, 1, 0, 0x1e
	ctx.r[30].u64 = ctx.r[28].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F56A0: 40810088  ble 0x830f5728
	if !ctx.cr[0].gt {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F56A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F56A8: 40980080  bge cr6, 0x830f5728
	if !ctx.cr[6].lt {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F56AC: 57C4103A  slwi r4, r30, 2
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830F56B0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F56B4: 4BFE7E3D  bl 0x830dd4f0
	ctx.lr = 0x830F56B8;
	sub_830DD4F0(ctx, base);
	// 830F56B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F56BC: 4182006C  beq 0x830f5728
	if ctx.cr[0].eq {
	pc = 0x830F5728; continue 'dispatch;
	}
	// 830F56C0: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F56C4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F56C8: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830F56CC: 7D3FE050  subf r9, r31, r28
	ctx.r[9].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 830F56D0: 7FDFDA14  add r30, r31, r27
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 830F56D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F56D8: 7D3B4850  subf r9, r27, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[27].s64;
	// 830F56DC: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F56E0: 57FC103A  slwi r28, r31, 2
	ctx.r[28].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 830F56E4: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830F56E8: 7C9C5A14  add r4, r28, r11
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830F56EC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F56F0: 480B7C61  bl 0x831ad350
	ctx.lr = 0x830F56F4;
	sub_831AD350(ctx, base);
	// 830F56F4: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F56F8: 40980028  bge cr6, 0x830f5720
	if !ctx.cr[6].lt {
	pc = 0x830F5720; continue 'dispatch;
	}
	// 830F56FC: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 830F5700: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5704: 7D7C5A15  add. r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5708: 4182000C  beq 0x830f5714
	if ctx.cr[0].eq {
	pc = 0x830F5714; continue 'dispatch;
	}
	// 830F570C: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5710: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F5714: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F5718: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830F571C: 4082FFE4  bne 0x830f5700
	if !ctx.cr[0].eq {
	pc = 0x830F5700; continue 'dispatch;
	}
	// 830F5720: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F5724: 48000008  b 0x830f572c
	pc = 0x830F572C; continue 'dispatch;
	// 830F5728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F572C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F5730: 480B2A80  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5738 size=168
    let mut pc: u32 = 0x830F5738;
    'dispatch: loop {
        match pc {
            0x830F5738 => {
    //   block [0x830F5738..0x830F57E0)
	// 830F5738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F573C: 480B2A31  bl 0x831a816c
	ctx.lr = 0x830F5740;
	sub_831A8130(ctx, base);
	// 830F5740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5748: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F574C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F5750: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5754: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F5758: 409A0050  bne cr6, 0x830f57a8
	if !ctx.cr[6].eq {
	pc = 0x830F57A8; continue 'dispatch;
	}
	// 830F575C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5760: 409A000C  bne cr6, 0x830f576c
	if !ctx.cr[6].eq {
	pc = 0x830F576C; continue 'dispatch;
	}
	// 830F5764: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F5768: 4800001C  b 0x830f5784
	pc = 0x830F5784; continue 'dispatch;
	// 830F576C: 557E083D  rlwinm. r30, r11, 1, 0, 0x1e
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F5770: 40810028  ble 0x830f5798
	if !ctx.cr[0].gt {
	pc = 0x830F5798; continue 'dispatch;
	}
	// 830F5774: 3D6000C3  lis r11, 0xc3
	ctx.r[11].s64 = 12779520;
	// 830F5778: 616B0C30  ori r11, r11, 0xc30
	ctx.r[11].u64 = ctx.r[11].u64 | 3120;
	// 830F577C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F5780: 40980018  bge cr6, 0x830f5798
	if !ctx.cr[6].lt {
	pc = 0x830F5798; continue 'dispatch;
	}
	// 830F5784: 1C9E00A8  mulli r4, r30, 0xa8
	ctx.r[4].s64 = ctx.r[30].s64 * 168;
	// 830F5788: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F578C: 4BFE7D65  bl 0x830dd4f0
	ctx.lr = 0x830F5790;
	sub_830DD4F0(ctx, base);
	// 830F5790: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F5794: 4082000C  bne 0x830f57a0
	if !ctx.cr[0].eq {
	pc = 0x830F57A0; continue 'dispatch;
	}
	// 830F5798: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F579C: 4800003C  b 0x830f57d8
	pc = 0x830F57D8; continue 'dispatch;
	// 830F57A0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F57A4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F57A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F57AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F57B0: 1D6B00A8  mulli r11, r11, 0xa8
	ctx.r[11].s64 = ctx.r[11].s64 * 168;
	// 830F57B4: 7C6B5215  add. r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F57B8: 41820010  beq 0x830f57c8
	if ctx.cr[0].eq {
	pc = 0x830F57C8; continue 'dispatch;
	}
	// 830F57BC: 38A000A8  li r5, 0xa8
	ctx.r[5].s64 = 168;
	// 830F57C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F57C4: 480B2D4D  bl 0x831a8510
	ctx.lr = 0x830F57C8;
	sub_831A8510(ctx, base);
	// 830F57C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F57CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F57D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F57D4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F57D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F57DC: 480B29E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F57E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F57E0 size=172
    let mut pc: u32 = 0x830F57E0;
    'dispatch: loop {
        match pc {
            0x830F57E0 => {
    //   block [0x830F57E0..0x830F588C)
	// 830F57E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F57E4: 480B2989  bl 0x831a816c
	ctx.lr = 0x830F57E8;
	sub_831A8130(ctx, base);
	// 830F57E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F57EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F57F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F57F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F57F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F57FC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F5800: 409A0050  bne cr6, 0x830f5850
	if !ctx.cr[6].eq {
	pc = 0x830F5850; continue 'dispatch;
	}
	// 830F5804: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5808: 409A000C  bne cr6, 0x830f5814
	if !ctx.cr[6].eq {
	pc = 0x830F5814; continue 'dispatch;
	}
	// 830F580C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F5810: 4800001C  b 0x830f582c
	pc = 0x830F582C; continue 'dispatch;
	// 830F5814: 557E083D  rlwinm. r30, r11, 1, 0, 0x1e
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F5818: 40810028  ble 0x830f5840
	if !ctx.cr[0].gt {
	pc = 0x830F5840; continue 'dispatch;
	}
	// 830F581C: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 830F5820: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830F5824: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F5828: 40980018  bge cr6, 0x830f5840
	if !ctx.cr[6].lt {
	pc = 0x830F5840; continue 'dispatch;
	}
	// 830F582C: 57C41838  slwi r4, r30, 3
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830F5830: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5834: 4BFE7CBD  bl 0x830dd4f0
	ctx.lr = 0x830F5838;
	sub_830DD4F0(ctx, base);
	// 830F5838: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F583C: 4082000C  bne 0x830f5848
	if !ctx.cr[0].eq {
	pc = 0x830F5848; continue 'dispatch;
	}
	// 830F5840: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5844: 48000040  b 0x830f5884
	pc = 0x830F5884; continue 'dispatch;
	// 830F5848: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F584C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F5850: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5854: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5858: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F585C: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F5860: 41820014  beq 0x830f5874
	if ctx.cr[0].eq {
	pc = 0x830F5874; continue 'dispatch;
	}
	// 830F5864: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5868: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F586C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5870: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830F5874: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5878: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F587C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F5880: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F5884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F5888: 480B2934  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5890 size=144
    let mut pc: u32 = 0x830F5890;
    'dispatch: loop {
        match pc {
            0x830F5890 => {
    //   block [0x830F5890..0x830F5920)
	// 830F5890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5894: 480B28D1  bl 0x831a8164
	ctx.lr = 0x830F5898;
	sub_831A8130(ctx, base);
	// 830F5898: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F589C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F58A0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830F58A4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830F58A8: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F58AC: 7FDDE214  add r30, r29, r28
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 830F58B0: 389E0001  addi r4, r30, 1
	ctx.r[4].s64 = ctx.r[30].s64 + 1;
	// 830F58B4: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830F58B8: 4099005C  ble cr6, 0x830f5914
	if !ctx.cr[6].gt {
	pc = 0x830F5914; continue 'dispatch;
	}
	// 830F58BC: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830F58C0: 40990054  ble cr6, 0x830f5914
	if !ctx.cr[6].gt {
	pc = 0x830F5914; continue 'dispatch;
	}
	// 830F58C4: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 830F58C8: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830F58CC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F58D0: 40980044  bge cr6, 0x830f5914
	if !ctx.cr[6].lt {
	pc = 0x830F5914; continue 'dispatch;
	}
	// 830F58D4: 4BFE84F5  bl 0x830dddc8
	ctx.lr = 0x830F58D8;
	sub_830DDDC8(ctx, base);
	// 830F58D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F58DC: 41800038  blt 0x830f5914
	if ctx.cr[0].lt {
	pc = 0x830F5914; continue 'dispatch;
	}
	// 830F58E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F58E4: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F58E8: 5785083C  slwi r5, r28, 1
	ctx.r[5].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830F58EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F58F0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F58F4: 480B2C1D  bl 0x831a8510
	ctx.lr = 0x830F58F8;
	sub_831A8510(ctx, base);
	// 830F58F8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F58FC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F5900: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F5904: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F5908: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F590C: 7D4B4B2E  sthx r10, r11, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u16) };
	// 830F5910: 48000008  b 0x830f5918
	pc = 0x830F5918; continue 'dispatch;
	// 830F5914: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5918: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F591C: 480B2898  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F5920 size=640
    let mut pc: u32 = 0x830F5920;
    'dispatch: loop {
        match pc {
            0x830F5920 => {
    //   block [0x830F5920..0x830F5BA0)
	// 830F5920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5924: 480B281D  bl 0x831a8140
	ctx.lr = 0x830F5928;
	sub_831A8130(ctx, base);
	// 830F5928: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F592C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5930: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F5934: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830F5938: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 830F593C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830F5940: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830F5944: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830F5948: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 830F594C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 830F5950: 4BFE04A9  bl 0x830d5df8
	ctx.lr = 0x830F5954;
	sub_830D5DF8(ctx, base);
	// 830F5954: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F5958: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 830F595C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830F5960: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F5964: 4BFFAF5D  bl 0x830f08c0
	ctx.lr = 0x830F5968;
	sub_830F08C0(ctx, base);
	// 830F5968: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F596C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830F5970: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 830F5974: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830F5978: 4BFFAFB1  bl 0x830f0928
	ctx.lr = 0x830F597C;
	sub_830F0928(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5BA0 size=120
    let mut pc: u32 = 0x830F5BA0;
    'dispatch: loop {
        match pc {
            0x830F5BA0 => {
    //   block [0x830F5BA0..0x830F5C18)
	// 830F5BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5BB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5BB8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F5BBC: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830F5BC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F5BC4: 419A000C  beq cr6, 0x830f5bd0
	if ctx.cr[6].eq {
	pc = 0x830F5BD0; continue 'dispatch;
	}
	// 830F5BC8: 4801F819  bl 0x831153e0
	ctx.lr = 0x830F5BCC;
	sub_831153E0(ctx, base);
	// 830F5BCC: 93DF00F4  stw r30, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[30].u32 ) };
	// 830F5BD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F5BD4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830F5BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5BDC: 4BFFA36D  bl 0x830eff48
	ctx.lr = 0x830F5BE0;
	sub_830EFF48(ctx, base);
	// 830F5BE0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F5BE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F5BE8: 419A0014  beq cr6, 0x830f5bfc
	if ctx.cr[6].eq {
	pc = 0x830F5BFC; continue 'dispatch;
	}
	// 830F5BEC: 4801E4ED  bl 0x831140d8
	ctx.lr = 0x830F5BF0;
	sub_831140D8(ctx, base);
	// 830F5BF0: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F5BF4: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 830F5BF8: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F5BFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F5C00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F5C04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F5C08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F5C0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F5C10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F5C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F5C18 size=916
    let mut pc: u32 = 0x830F5C18;
    'dispatch: loop {
        match pc {
            0x830F5C18 => {
    //   block [0x830F5C18..0x830F5FAC)
	// 830F5C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5C1C: 480B2535  bl 0x831a8150
	ctx.lr = 0x830F5C20;
	sub_831A8130(ctx, base);
	// 830F5C20: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 830F5C24: 480B2E39  bl 0x831a8a5c
	ctx.lr = 0x830F5C28;
	sub_831A8A40(ctx, base);
	// 830F5C28: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5C2C: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5C30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5C34: 9081024C  stw r4, 0x24c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(588 as u32), ctx.r[4].u32 ) };
	// 830F5C38: 93E10244  stw r31, 0x244(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(580 as u32), ctx.r[31].u32 ) };
	// 830F5C3C: C03F000C  lfs f1, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F5C40: 93C100B8  stw r30, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 830F5C44: 480B5E55  bl 0x831aba98
	ctx.lr = 0x830F5C48;
	sub_831ABA98(ctx, base);
	// 830F5C48: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F5C4C: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F5C50: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830F5C54: D80100B0  stfd f0, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.f[0].u64 ) };
	// 830F5C58: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 830F5C5C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830F5C60: 480B5E39  bl 0x831aba98
	ctx.lr = 0x830F5C64;
	sub_831ABA98(ctx, base);
	// 830F5C64: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F5C68: 3BBF00F4  addi r29, r31, 0xf4
	ctx.r[29].s64 = ctx.r[31].s64 + 244;
	// 830F5C6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5C70: 93A100B0  stw r29, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[29].u32 ) };
	// 830F5C74: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5C78: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F5C7C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830F5C80: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830F5C84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F5C88: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830F5C8C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830F5C90: 409A0314  bne cr6, 0x830f5fa4
	if !ctx.cr[6].eq {
	pc = 0x830F5FA4; continue 'dispatch;
	}
	// 830F5C94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F5C98: 48021DA9  bl 0x83117a40
	ctx.lr = 0x830F5C9C;
	sub_83117A40(ctx, base);
	// 830F5C9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F5CA0: 418002F4  blt 0x830f5f94
	if ctx.cr[0].lt {
	pc = 0x830F5F94; continue 'dispatch;
	}
	// 830F5CA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5CA8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F5CAC: 4801F99D  bl 0x83115648
	ctx.lr = 0x830F5CB0;
	sub_83115648(ctx, base);
	// 830F5CB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F5CB4: 418002E0  blt 0x830f5f94
	if ctx.cr[0].lt {
	pc = 0x830F5F94; continue 'dispatch;
	}
	// 830F5CB8: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 830F5CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5CC0: 4BFF3141  bl 0x830e8e00
	ctx.lr = 0x830F5CC4;
	sub_830E8E00(ctx, base);
	// 830F5CC4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 830F5CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F5CCC: 4BFF31F5  bl 0x830e8ec0
	ctx.lr = 0x830F5CD0;
	sub_830E8EC0(ctx, base);
	// 830F5CD0: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 830F5CD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F5CD8: 4801A631  bl 0x83110308
	ctx.lr = 0x830F5CDC;
	sub_83110308(ctx, base);
	// 830F5CDC: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F5FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F5FB0 size=128
    let mut pc: u32 = 0x830F5FB0;
    'dispatch: loop {
        match pc {
            0x830F5FB0 => {
    //   block [0x830F5FB0..0x830F6030)
	// 830F5FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F5FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F5FB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F5FBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F5FC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F5FC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F5FC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F5FCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F5FD0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F5FD4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F5FD8: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F5FDC: 654A0004  oris r10, r10, 4
	ctx.r[10].u64 = ctx.r[10].u64 | 262144;
	// 830F5FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F5FE4: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830F5FE8: 419A002C  beq cr6, 0x830f6014
	if ctx.cr[6].eq {
	pc = 0x830F6014; continue 'dispatch;
	}
	// 830F5FEC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830F5FF0: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F5FF4: 4BFFA805  bl 0x830f07f8
	ctx.lr = 0x830F5FF8;
	sub_830F07F8(ctx, base);
	// 830F5FF8: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F5FFC: 556B0462  rlwinm r11, r11, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F6000: 2B0B4000  cmplwi cr6, r11, 0x4000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16384 as u32, &mut ctx.xer);
	// 830F6004: 409A0010  bne cr6, 0x830f6014
	if !ctx.cr[6].eq {
	pc = 0x830F6014; continue 'dispatch;
	}
	// 830F6008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F600C: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F6010: 4BFFFC09  bl 0x830f5c18
	ctx.lr = 0x830F6014;
	sub_830F5C18(ctx, base);
	// 830F6014: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6018: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F601C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6020: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6024: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F6028: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F602C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6030 size=156
    let mut pc: u32 = 0x830F6030;
    'dispatch: loop {
        match pc {
            0x830F6030 => {
    //   block [0x830F6030..0x830F60CC)
	// 830F6030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6034: 480B2139  bl 0x831a816c
	ctx.lr = 0x830F6038;
	sub_831A8130(ctx, base);
	// 830F6038: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F603C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F6040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6044: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F6048: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F604C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F6050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6054: 419A006C  beq cr6, 0x830f60c0
	if ctx.cr[6].eq {
	pc = 0x830F60C0; continue 'dispatch;
	}
	// 830F6058: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F605C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F6060: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F6064: 556B0462  rlwinm r11, r11, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F6068: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F606C: 2B0B4000  cmplwi cr6, r11, 0x4000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16384 as u32, &mut ctx.xer);
	// 830F6070: 409A0018  bne cr6, 0x830f6088
	if !ctx.cr[6].eq {
	pc = 0x830F6088; continue 'dispatch;
	}
	// 830F6074: 4BFFA0BD  bl 0x830f0130
	ctx.lr = 0x830F6078;
	sub_830F0130(ctx, base);
	// 830F6078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F607C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6080: 4BFEF089  bl 0x830e5108
	ctx.lr = 0x830F6084;
	sub_830E5108(ctx, base);
	// 830F6084: 48000018  b 0x830f609c
	pc = 0x830F609C; continue 'dispatch;
	// 830F6088: 4BFFA0A9  bl 0x830f0130
	ctx.lr = 0x830F608C;
	sub_830F0130(ctx, base);
	// 830F608C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F6090: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F6094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6098: 4BFFA761  bl 0x830f07f8
	ctx.lr = 0x830F609C;
	sub_830F07F8(ctx, base);
	// 830F609C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F60A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F60A4: 4BFEF195  bl 0x830e5238
	ctx.lr = 0x830F60A8;
	sub_830E5238(ctx, base);
	// 830F60A8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F60AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F60B0: 409A0010  bne cr6, 0x830f60c0
	if !ctx.cr[6].eq {
	pc = 0x830F60C0; continue 'dispatch;
	}
	// 830F60B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F60B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F60BC: 4BFF294D  bl 0x830e8a08
	ctx.lr = 0x830F60C0;
	sub_830E8A08(ctx, base);
	// 830F60C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F60C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F60C8: 480B20F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F60D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F60D0 size=376
    let mut pc: u32 = 0x830F60D0;
    'dispatch: loop {
        match pc {
            0x830F60D0 => {
    //   block [0x830F60D0..0x830F6248)
	// 830F60D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F60D4: 480B2099  bl 0x831a816c
	ctx.lr = 0x830F60D8;
	sub_831A8130(ctx, base);
	// 830F60D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F60DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F60E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F60E4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F60E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F60EC: 419A0150  beq cr6, 0x830f623c
	if ctx.cr[6].eq {
	pc = 0x830F623C; continue 'dispatch;
	}
	// 830F60F0: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F60F4: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830F60F8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F60FC: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F6100: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F6104: 83CAC0E4  lwz r30, -0x3f1c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16156 as u32) ) } as u64;
	// 830F6108: 4BFD8B09  bl 0x830cec10
	ctx.lr = 0x830F610C;
	sub_830CEC10(ctx, base);
	// 830F610C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F6110: 4BFD8A61  bl 0x830ceb70
	ctx.lr = 0x830F6114;
	sub_830CEB70(ctx, base);
	// 830F6114: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F6118: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F611C: 4182006C  beq 0x830f6188
	if ctx.cr[0].eq {
	pc = 0x830F6188; continue 'dispatch;
	}
	// 830F6120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6124: 419A0010  beq cr6, 0x830f6134
	if ctx.cr[6].eq {
	pc = 0x830F6134; continue 'dispatch;
	}
	// 830F6128: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F612C: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 830F6130: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830F6134: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F6138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F613C: 419A000C  beq cr6, 0x830f6148
	if ctx.cr[6].eq {
	pc = 0x830F6148; continue 'dispatch;
	}
	// 830F6140: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F6144: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830F6148: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F614C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6150: 419A000C  beq cr6, 0x830f615c
	if ctx.cr[6].eq {
	pc = 0x830F615C; continue 'dispatch;
	}
	// 830F6154: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F6158: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830F615C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F6160: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F6164: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830F6168: 409A000C  bne cr6, 0x830f6174
	if !ctx.cr[6].eq {
	pc = 0x830F6174; continue 'dispatch;
	}
	// 830F616C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F6170: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 830F6174: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F6178: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830F617C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830F6180: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830F6184: 480000B8  b 0x830f623c
	pc = 0x830F623C; continue 'dispatch;
	// 830F6188: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F618C: 4BFD8A85  bl 0x830cec10
	ctx.lr = 0x830F6190;
	sub_830CEC10(ctx, base);
	// 830F6190: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F6194: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F6198: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F619C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F61A0: 419A000C  beq cr6, 0x830f61ac
	if ctx.cr[6].eq {
	pc = 0x830F61AC; continue 'dispatch;
	}
	// 830F61A4: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830F61A8: 4800000C  b 0x830f61b4
	pc = 0x830F61B4; continue 'dispatch;
	// 830F61AC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F61B0: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830F61B4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F61B8: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F61BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F61C0: 419A000C  beq cr6, 0x830f61cc
	if ctx.cr[6].eq {
	pc = 0x830F61CC; continue 'dispatch;
	}
	// 830F61C4: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830F61C8: 4800000C  b 0x830f61d4
	pc = 0x830F61D4; continue 'dispatch;
	// 830F61CC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F61D0: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 830F61D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F61D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F61DC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830F61E0: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830F61E4: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830F61E8: 4BFD8A29  bl 0x830cec10
	ctx.lr = 0x830F61EC;
	sub_830CEC10(ctx, base);
	// 830F61EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830F61F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F61F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F61F8: 4BFF07B9  bl 0x830e69b0
	ctx.lr = 0x830F61FC;
	sub_830E69B0(ctx, base);
	// 830F61FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F6200: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6204: 4BFDF9C5  bl 0x830d5bc8
	ctx.lr = 0x830F6208;
	sub_830D5BC8(ctx, base);
	// 830F6208: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F620C: 409A0028  bne cr6, 0x830f6234
	if !ctx.cr[6].eq {
	pc = 0x830F6234; continue 'dispatch;
	}
	// 830F6210: 4BFE93D9  bl 0x830df5e8
	ctx.lr = 0x830F6214;
	sub_830DF5E8(ctx, base);
	// 830F6214: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6218: 4082001C  bne 0x830f6234
	if !ctx.cr[0].eq {
	pc = 0x830F6234; continue 'dispatch;
	}
	// 830F621C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6220: 4BFD89F1  bl 0x830cec10
	ctx.lr = 0x830F6224;
	sub_830CEC10(ctx, base);
	// 830F6224: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6228: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F622C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830F6230: 4BFF2951  bl 0x830e8b80
	ctx.lr = 0x830F6234;
	sub_830E8B80(ctx, base);
	// 830F6234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6238: 4BFFF969  bl 0x830f5ba0
	ctx.lr = 0x830F623C;
	sub_830F5BA0(ctx, base);
	// 830F623C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6240: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F6244: 480B1F78  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F6248 size=160
    let mut pc: u32 = 0x830F6248;
    'dispatch: loop {
        match pc {
            0x830F6248 => {
    //   block [0x830F6248..0x830F62E8)
	// 830F6248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F624C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6250: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6254: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F6258: 39630030  addi r11, r3, 0x30
	ctx.r[11].s64 = ctx.r[3].s64 + 48;
	// 830F625C: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830F6260: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F6264: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830F6268: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F626C: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830F6270: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F6274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F6278: 419A0044  beq cr6, 0x830f62bc
	if ctx.cr[6].eq {
	pc = 0x830F62BC; continue 'dispatch;
	}
	// 830F627C: 812A00F0  lwz r9, 0xf0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F6280: 552906B4  rlwinm r9, r9, 0, 0x1a, 0x1a
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 830F6284: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 830F6288: 409A0034  bne cr6, 0x830f62bc
	if !ctx.cr[6].eq {
	pc = 0x830F62BC; continue 'dispatch;
	}
	// 830F628C: C1AA0104  lfs f13, 0x104(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F6290: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F6294: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830F6298: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F629C: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F62A0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F62A4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F62A8: C1AA0108  lfs f13, 0x108(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F62AC: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F62B0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830F62B4: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830F62B8: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830F62BC: 816300F0  lwz r11, 0xf0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F62C0: C0430010  lfs f2, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F62C4: C023000C  lfs f1, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F62C8: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F62CC: 916300F0  stw r11, 0xf0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F62D0: 4BFF31F9  bl 0x830e94c8
	ctx.lr = 0x830F62D4;
	sub_830E94C8(ctx, base);
	// 830F62D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F62D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F62DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F62E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F62E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F62E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F62E8 size=392
    let mut pc: u32 = 0x830F62E8;
    'dispatch: loop {
        match pc {
            0x830F62E8 => {
    //   block [0x830F62E8..0x830F6470)
	// 830F62E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F62EC: 480B1E79  bl 0x831a8164
	ctx.lr = 0x830F62F0;
	sub_831A8130(ctx, base);
	// 830F62F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F62F4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F62F8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830F62FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6300: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F6304: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830F6308: 4BFD8869  bl 0x830ceb70
	ctx.lr = 0x830F630C;
	sub_830CEB70(ctx, base);
	// 830F630C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F6310: 40820010  bne 0x830f6320
	if !ctx.cr[0].eq {
	pc = 0x830F6320; continue 'dispatch;
	}
	// 830F6314: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830F6318: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830F631C: 4800014C  b 0x830f6468
	pc = 0x830F6468; continue 'dispatch;
	// 830F6320: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F6324: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6328: 4BFD8149  bl 0x830ce470
	ctx.lr = 0x830F632C;
	sub_830CE470(ctx, base);
	// 830F632C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6330: 4180FFE4  blt 0x830f6314
	if ctx.cr[0].lt {
	pc = 0x830F6314; continue 'dispatch;
	}
	// 830F6334: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F6338: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F633C: 419AFFD8  beq cr6, 0x830f6314
	if ctx.cr[6].eq {
	pc = 0x830F6314; continue 'dispatch;
	}
	// 830F6340: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F6344: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F6348: 838BC0E4  lwz r28, -0x3f1c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16156 as u32) ) } as u64;
	// 830F634C: 4BFD88C5  bl 0x830cec10
	ctx.lr = 0x830F6350;
	sub_830CEC10(ctx, base);
	// 830F6350: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F6354: 4BFD881D  bl 0x830ceb70
	ctx.lr = 0x830F6358;
	sub_830CEB70(ctx, base);
	// 830F6358: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F635C: 41820014  beq 0x830f6370
	if ctx.cr[0].eq {
	pc = 0x830F6370; continue 'dispatch;
	}
	// 830F6360: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F6364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6368: 4BFEF061  bl 0x830e53c8
	ctx.lr = 0x830F636C;
	sub_830E53C8(ctx, base);
	// 830F636C: 480000FC  b 0x830f6468
	pc = 0x830F6468; continue 'dispatch;
	// 830F6370: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6374: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830F6378: 48000014  b 0x830f638c
	pc = 0x830F638C; continue 'dispatch;
	// 830F637C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F6380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6384: 419A001C  beq cr6, 0x830f63a0
	if ctx.cr[6].eq {
	pc = 0x830F63A0; continue 'dispatch;
	}
	// 830F6388: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F638C: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830F6390: 409AFFEC  bne cr6, 0x830f637c
	if !ctx.cr[6].eq {
	pc = 0x830F637C; continue 'dispatch;
	}
	// 830F6394: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F6398: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830F639C: 480000CC  b 0x830f6468
	pc = 0x830F6468; continue 'dispatch;
	// 830F63A0: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F63A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F63A8: 409AFFEC  bne cr6, 0x830f6394
	if !ctx.cr[6].eq {
	pc = 0x830F6394; continue 'dispatch;
	}
	// 830F63AC: 93FE0028  stw r31, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 830F63B0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F63B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F63B8: 409A000C  bne cr6, 0x830f63c4
	if !ctx.cr[6].eq {
	pc = 0x830F63C4; continue 'dispatch;
	}
	// 830F63BC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 830F63C0: 48000010  b 0x830f63d0
	pc = 0x830F63D0; continue 'dispatch;
	// 830F63C4: 93CB0020  stw r30, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830F63C8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F63CC: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830F63D0: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830F63D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F63D8: C05E0010  lfs f2, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F63DC: C03E000C  lfs f1, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F63E0: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F63E4: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F63E8: 917E00F0  stw r11, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F63EC: 4BFF30DD  bl 0x830e94c8
	ctx.lr = 0x830F63F0;
	sub_830E94C8(ctx, base);
	// 830F63F0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830F63F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F63F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F63FC: 4BFF0565  bl 0x830e6960
	ctx.lr = 0x830F6400;
	sub_830E6960(ctx, base);
	// 830F6400: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6404: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 830F6408: 4BFD8809  bl 0x830cec10
	ctx.lr = 0x830F640C;
	sub_830CEC10(ctx, base);
	// 830F640C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F6410: 4BFDF7B9  bl 0x830d5bc8
	ctx.lr = 0x830F6414;
	sub_830D5BC8(ctx, base);
	// 830F6414: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F6418: 41800040  blt 0x830f6458
	if ctx.cr[0].lt {
	pc = 0x830F6458; continue 'dispatch;
	}
	// 830F641C: 4BFE91CD  bl 0x830df5e8
	ctx.lr = 0x830F6420;
	sub_830DF5E8(ctx, base);
	// 830F6420: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6424: 4082002C  bne 0x830f6450
	if !ctx.cr[0].eq {
	pc = 0x830F6450; continue 'dispatch;
	}
	// 830F6428: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F642C: 4BFD87E5  bl 0x830cec10
	ctx.lr = 0x830F6430;
	sub_830CEC10(ctx, base);
	// 830F6430: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6434: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F6438: 4BFD87D9  bl 0x830cec10
	ctx.lr = 0x830F643C;
	sub_830CEC10(ctx, base);
	// 830F643C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F6440: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F6444: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830F6448: 4BFF2739  bl 0x830e8b80
	ctx.lr = 0x830F644C;
	sub_830E8B80(ctx, base);
	// 830F644C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F6450: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F6454: 40980010  bge cr6, 0x830f6464
	if !ctx.cr[6].lt {
	pc = 0x830F6464; continue 'dispatch;
	}
	// 830F6458: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F645C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6460: 4BFFFC71  bl 0x830f60d0
	ctx.lr = 0x830F6464;
	sub_830F60D0(ctx, base);
	// 830F6464: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6468: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F646C: 480B1D48  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F6470 size=692
    let mut pc: u32 = 0x830F6470;
    'dispatch: loop {
        match pc {
            0x830F6470 => {
    //   block [0x830F6470..0x830F6724)
	// 830F6470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6474: 480B1CD9  bl 0x831a814c
	ctx.lr = 0x830F6478;
	sub_831A8130(ctx, base);
	// 830F6478: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F647C: 3F208339  lis r25, -0x7cc7
	ctx.r[25].s64 = -2093416448;
	// 830F6480: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 830F6484: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F6488: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830F648C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 830F6490: 8099C06C  lwz r4, -0x3f94(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830F6494: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 830F6498: 4BFD86D9  bl 0x830ceb70
	ctx.lr = 0x830F649C;
	sub_830CEB70(ctx, base);
	// 830F649C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F64A0: 41820274  beq 0x830f6714
	if ctx.cr[0].eq {
	pc = 0x830F6714; continue 'dispatch;
	}
	// 830F64A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F64A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F64AC: 4BFD7FC5  bl 0x830ce470
	ctx.lr = 0x830F64B0;
	sub_830CE470(ctx, base);
	// 830F64B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F64B4: 41800260  blt 0x830f6714
	if ctx.cr[0].lt {
	pc = 0x830F6714; continue 'dispatch;
	}
	// 830F64B8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F64BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830F64C0: 419A0254  beq cr6, 0x830f6714
	if ctx.cr[6].eq {
	pc = 0x830F6714; continue 'dispatch;
	}
	// 830F64C4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F64C8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830F64CC: 48000014  b 0x830f64e0
	pc = 0x830F64E0; continue 'dispatch;
	// 830F64D0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F64D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F64D8: 419A001C  beq cr6, 0x830f64f4
	if ctx.cr[6].eq {
	pc = 0x830F64F4; continue 'dispatch;
	}
	// 830F64DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F64E0: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830F64E4: 409AFFEC  bne cr6, 0x830f64d0
	if !ctx.cr[6].eq {
	pc = 0x830F64D0; continue 'dispatch;
	}
	// 830F64E8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F64EC: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830F64F0: 4800022C  b 0x830f671c
	pc = 0x830F671C; continue 'dispatch;
	// 830F64F4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F64F8: 3ADF0028  addi r22, r31, 0x28
	ctx.r[22].s64 = ctx.r[31].s64 + 40;
	// 830F64FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6500: 409AFFE8  bne cr6, 0x830f64e8
	if !ctx.cr[6].eq {
	pc = 0x830F64E8; continue 'dispatch;
	}
	// 830F6504: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830F6508: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830F650C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 830F6510: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 830F6514: 419A0038  beq cr6, 0x830f654c
	if ctx.cr[6].eq {
	pc = 0x830F654C; continue 'dispatch;
	}
	// 830F6518: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830F651C: 8099C06C  lwz r4, -0x3f94(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830F6520: 4BFD8651  bl 0x830ceb70
	ctx.lr = 0x830F6524;
	sub_830CEB70(ctx, base);
	// 830F6524: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F6528: 418201EC  beq 0x830f6714
	if ctx.cr[0].eq {
	pc = 0x830F6714; continue 'dispatch;
	}
	// 830F652C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F6530: 4BFD7F41  bl 0x830ce470
	ctx.lr = 0x830F6534;
	sub_830CE470(ctx, base);
	// 830F6534: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6538: 41800008  blt 0x830f6540
	if ctx.cr[0].lt {
	pc = 0x830F6540; continue 'dispatch;
	}
	// 830F653C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F6540: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F6544: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830F6548: 409AFFA0  bne cr6, 0x830f64e8
	if !ctx.cr[6].eq {
	pc = 0x830F64E8; continue 'dispatch;
	}
	// 830F654C: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830F6550: 419A003C  beq cr6, 0x830f658c
	if ctx.cr[6].eq {
	pc = 0x830F658C; continue 'dispatch;
	}
	// 830F6554: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830F6558: 8099C06C  lwz r4, -0x3f94(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830F655C: 4BFD8615  bl 0x830ceb70
	ctx.lr = 0x830F6560;
	sub_830CEB70(ctx, base);
	// 830F6560: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F6564: 418201B0  beq 0x830f6714
	if ctx.cr[0].eq {
	pc = 0x830F6714; continue 'dispatch;
	}
	// 830F6568: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F656C: 4BFD7F05  bl 0x830ce470
	ctx.lr = 0x830F6570;
	sub_830CE470(ctx, base);
	// 830F6570: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6574: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 830F6578: 41800008  blt 0x830f6580
	if ctx.cr[0].lt {
	pc = 0x830F6580; continue 'dispatch;
	}
	// 830F657C: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F6580: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 830F6584: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830F6588: 409AFF60  bne cr6, 0x830f64e8
	if !ctx.cr[6].eq {
	pc = 0x830F64E8; continue 'dispatch;
	}
	// 830F658C: 93560000  stw r26, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 830F6590: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F6594: 935F0020  stw r26, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 830F6598: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830F659C: 935F0024  stw r26, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	// 830F65A0: 83CBC0E4  lwz r30, -0x3f1c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16156 as u32) ) } as u64;
	// 830F65A4: 4BFD866D  bl 0x830cec10
	ctx.lr = 0x830F65A8;
	sub_830CEC10(ctx, base);
	// 830F65A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F65AC: 4BFD85C5  bl 0x830ceb70
	ctx.lr = 0x830F65B0;
	sub_830CEB70(ctx, base);
	// 830F65B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F65B4: 41820048  beq 0x830f65fc
	if ctx.cr[0].eq {
	pc = 0x830F65FC; continue 'dispatch;
	}
	// 830F65B8: 93B60000  stw r29, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830F65BC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F65C0: 939F0024  stw r28, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[28].u32 ) };
	// 830F65C4: 937F0020  stw r27, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 830F65C8: 419A0008  beq cr6, 0x830f65d0
	if ctx.cr[6].eq {
	pc = 0x830F65D0; continue 'dispatch;
	}
	// 830F65CC: 93FC0020  stw r31, 0x20(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 830F65D0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830F65D4: 419A0008  beq cr6, 0x830f65dc
	if ctx.cr[6].eq {
	pc = 0x830F65DC; continue 'dispatch;
	}
	// 830F65D8: 93FB0024  stw r31, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 830F65DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F65E0: 409A0008  bne cr6, 0x830f65e8
	if !ctx.cr[6].eq {
	pc = 0x830F65E8; continue 'dispatch;
	}
	// 830F65E4: 93FD002C  stw r31, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 830F65E8: 817D00F0  lwz r11, 0xf0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F65EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F65F0: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 830F65F4: 917D00F0  stw r11, 0xf0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F65F8: 48000124  b 0x830f671c
	pc = 0x830F671C; continue 'dispatch;
	// 830F65FC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830F6600: 409A0030  bne cr6, 0x830f6630
	if !ctx.cr[6].eq {
	pc = 0x830F6630; continue 'dispatch;
	}
	// 830F6604: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F6608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F660C: 409A000C  bne cr6, 0x830f6618
	if !ctx.cr[6].eq {
	pc = 0x830F6618; continue 'dispatch;
	}
	// 830F6610: 93FD001C  stw r31, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 830F6614: 48000014  b 0x830f6628
	pc = 0x830F6628; continue 'dispatch;
	// 830F6618: 93EB0024  stw r31, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 830F661C: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F6620: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830F6624: 935F0024  stw r26, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	// 830F6628: 93FD0018  stw r31, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 830F662C: 4800004C  b 0x830f6678
	pc = 0x830F6678; continue 'dispatch;
	// 830F6630: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830F6634: 409A0024  bne cr6, 0x830f6658
	if !ctx.cr[6].eq {
	pc = 0x830F6658; continue 'dispatch;
	}
	// 830F6638: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F663C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F6640: 419AFFD0  beq cr6, 0x830f6610
	if ctx.cr[6].eq {
	pc = 0x830F6610; continue 'dispatch;
	}
	// 830F6644: 93EB0020  stw r31, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 830F6648: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 830F664C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830F6650: 93FD001C  stw r31, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 830F6654: 48000024  b 0x830f6678
	pc = 0x830F6678; continue 'dispatch;
	// 830F6658: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F665C: 419A00B8  beq cr6, 0x830f6714
	if ctx.cr[6].eq {
	pc = 0x830F6714; continue 'dispatch;
	}
	// 830F6660: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830F6664: 419A00B0  beq cr6, 0x830f6714
	if ctx.cr[6].eq {
	pc = 0x830F6714; continue 'dispatch;
	}
	// 830F6668: 939F0024  stw r28, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[28].u32 ) };
	// 830F666C: 937F0020  stw r27, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 830F6670: 93FC0020  stw r31, 0x20(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 830F6674: 93FB0024  stw r31, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 830F6678: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F667C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6680: 93B60000  stw r29, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830F6684: C05F0010  lfs f2, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F6688: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F668C: C03F000C  lfs f1, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6690: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F6694: 4BFF2E35  bl 0x830e94c8
	ctx.lr = 0x830F6698;
	sub_830E94C8(ctx, base);
	// 830F6698: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 830F669C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830F66A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F66A4: 4BFF02BD  bl 0x830e6960
	ctx.lr = 0x830F66A8;
	sub_830E6960(ctx, base);
	// 830F66A8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F66AC: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 830F66B0: 4BFD8561  bl 0x830cec10
	ctx.lr = 0x830F66B4;
	sub_830CEC10(ctx, base);
	// 830F66B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F66B8: 4BFDF511  bl 0x830d5bc8
	ctx.lr = 0x830F66BC;
	sub_830D5BC8(ctx, base);
	// 830F66BC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F66C0: 41800040  blt 0x830f6700
	if ctx.cr[0].lt {
	pc = 0x830F6700; continue 'dispatch;
	}
	// 830F66C4: 4BFE8F25  bl 0x830df5e8
	ctx.lr = 0x830F66C8;
	sub_830DF5E8(ctx, base);
	// 830F66C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F66CC: 4082002C  bne 0x830f66f8
	if !ctx.cr[0].eq {
	pc = 0x830F66F8; continue 'dispatch;
	}
	// 830F66D0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F66D4: 4BFD853D  bl 0x830cec10
	ctx.lr = 0x830F66D8;
	sub_830CEC10(ctx, base);
	// 830F66D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F66DC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830F66E0: 4BFD8531  bl 0x830cec10
	ctx.lr = 0x830F66E4;
	sub_830CEC10(ctx, base);
	// 830F66E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F66E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F66EC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F66F0: 4BFF2491  bl 0x830e8b80
	ctx.lr = 0x830F66F4;
	sub_830E8B80(ctx, base);
	// 830F66F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F66F8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F66FC: 40980010  bge cr6, 0x830f670c
	if !ctx.cr[6].lt {
	pc = 0x830F670C; continue 'dispatch;
	}
	// 830F6700: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F6704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6708: 4BFFF9C9  bl 0x830f60d0
	ctx.lr = 0x830F670C;
	sub_830F60D0(ctx, base);
	// 830F670C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F6710: 4800000C  b 0x830f671c
	pc = 0x830F671C; continue 'dispatch;
	// 830F6714: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830F6718: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830F671C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830F6720: 480B1A7C  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6728 size=352
    let mut pc: u32 = 0x830F6728;
    'dispatch: loop {
        match pc {
            0x830F6728 => {
    //   block [0x830F6728..0x830F6888)
	// 830F6728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F672C: 480B1A41  bl 0x831a816c
	ctx.lr = 0x830F6730;
	sub_831A8130(ctx, base);
	// 830F6730: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6734: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830F6738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F673C: 3BAAD8F4  addi r29, r10, -0x270c
	ctx.r[29].s64 = ctx.r[10].s64 + -9996;
	// 830F6740: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 830F6744: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F6748: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830F674C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6750: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F6754: 40990024  ble cr6, 0x830f6778
	if !ctx.cr[6].gt {
	pc = 0x830F6778; continue 'dispatch;
	}
	// 830F6758: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F675C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6760: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830F6764: 419A00B4  beq cr6, 0x830f6818
	if ctx.cr[6].eq {
	pc = 0x830F6818; continue 'dispatch;
	}
	// 830F6768: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F676C: 3BFF00A8  addi r31, r31, 0xa8
	ctx.r[31].s64 = ctx.r[31].s64 + 168;
	// 830F6770: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F6774: 4198FFE8  blt cr6, 0x830f675c
	if ctx.cr[6].lt {
	pc = 0x830F675C; continue 'dispatch;
	}
	// 830F6778: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830F677C: 419A0094  beq cr6, 0x830f6810
	if ctx.cr[6].eq {
	pc = 0x830F6810; continue 'dispatch;
	}
	// 830F6780: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 830F6784: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6788: 392100E4  addi r9, r1, 0xe4
	ctx.r[9].s64 = ctx.r[1].s64 + 228;
	// 830F678C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830F6790: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830F6794: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830F6798: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F679C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F67A0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F67A4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F67A8: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F67AC: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F67B0: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F67B4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F67B8: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F67BC: 91690010  stw r11, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830F67C0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 830F67C4: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 830F67C8: 4801A141  bl 0x83110908
	ctx.lr = 0x830F67CC;
	sub_83110908(ctx, base);
	// 830F67CC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 830F67D0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F67D4: 4801973D  bl 0x8310ff10
	ctx.lr = 0x830F67D8;
	sub_8310FF10(ctx, base);
	// 830F67D8: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 830F67DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F67E0: 48019B29  bl 0x83110308
	ctx.lr = 0x830F67E4;
	sub_83110308(ctx, base);
	// 830F67E4: 396100E4  addi r11, r1, 0xe4
	ctx.r[11].s64 = ctx.r[1].s64 + 228;
	// 830F67E8: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 830F67EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F67F0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F67F4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F67F8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F67FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6800: 4200FFF0  bdnz 0x830f67f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830F67F0; continue 'dispatch;
	}
	// 830F6804: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6808: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F680C: 4BFFEF2D  bl 0x830f5738
	ctx.lr = 0x830F6810;
	sub_830F5738(ctx, base);
	// 830F6810: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 830F6814: 480B19A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 830F6818: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830F681C: 419A005C  beq cr6, 0x830f6878
	if ctx.cr[6].eq {
	pc = 0x830F6878; continue 'dispatch;
	}
	// 830F6820: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F6824: 38DF0010  addi r6, r31, 0x10
	ctx.r[6].s64 = ctx.r[31].s64 + 16;
	// 830F6828: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F682C: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 830F6830: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 830F6834: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6838: 4801A0D1  bl 0x83110908
	ctx.lr = 0x830F683C;
	sub_83110908(ctx, base);
	// 830F683C: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 830F6840: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6844: 480196CD  bl 0x8310ff10
	ctx.lr = 0x830F6848;
	sub_8310FF10(ctx, base);
	// 830F6848: 389F0054  addi r4, r31, 0x54
	ctx.r[4].s64 = ctx.r[31].s64 + 84;
	// 830F684C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6850: 48019AB9  bl 0x83110308
	ctx.lr = 0x830F6854;
	sub_83110308(ctx, base);
	// 830F6854: 397F0094  addi r11, r31, 0x94
	ctx.r[11].s64 = ctx.r[31].s64 + 148;
	// 830F6858: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 830F685C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830F6860: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6864: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830F6868: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F686C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6870: 4200FFF0  bdnz 0x830f6860
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830F6860; continue 'dispatch;
	}
	// 830F6874: 4BFFFF9C  b 0x830f6810
	pc = 0x830F6810; continue 'dispatch;
	// 830F6878: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F687C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 830F6880: 4BFEFF09  bl 0x830e6788
	ctx.lr = 0x830F6884;
	sub_830E6788(ctx, base);
	// 830F6884: 4BFFFF8C  b 0x830f6810
	pc = 0x830F6810; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F6888 size=440
    let mut pc: u32 = 0x830F6888;
    'dispatch: loop {
        match pc {
            0x830F6888 => {
    //   block [0x830F6888..0x830F6A40)
	// 830F6888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F688C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F6894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F6898: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F689C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F68A0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830F68A4: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 830F68A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F68AC: 480BC105  bl 0x831b29b0
	ctx.lr = 0x830F68B0;
	sub_831B29B0(ctx, base);
	// 830F68B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F68B4: 40810170  ble 0x830f6a24
	if !ctx.cr[0].gt {
	pc = 0x830F6A24; continue 'dispatch;
	}
	// 830F68B8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F68BC: 4099014C  ble cr6, 0x830f6a08
	if !ctx.cr[6].gt {
	pc = 0x830F6A08; continue 'dispatch;
	}
	// 830F68C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F68C4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F68C8: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F68CC: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830F68D0: 409A000C  bne cr6, 0x830f68dc
	if !ctx.cr[6].eq {
	pc = 0x830F68DC; continue 'dispatch;
	}
	// 830F68D4: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830F68D8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F68DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F68E0: 480BBE29  bl 0x831b2708
	ctx.lr = 0x830F68E4;
	sub_831B2708(ctx, base);
	// 830F68E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F68E8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F68EC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830F68F0: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F68F4: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830F68F8: 409A000C  bne cr6, 0x830f6904
	if !ctx.cr[6].eq {
	pc = 0x830F6904; continue 'dispatch;
	}
	// 830F68FC: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830F6900: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F6904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F6908: 480BBE01  bl 0x831b2708
	ctx.lr = 0x830F690C;
	sub_831B2708(ctx, base);
	// 830F690C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F6910: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F6914: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830F6918: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F691C: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830F6920: 409A000C  bne cr6, 0x830f692c
	if !ctx.cr[6].eq {
	pc = 0x830F692C; continue 'dispatch;
	}
	// 830F6924: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830F6928: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F692C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F6930: 480BBDD9  bl 0x831b2708
	ctx.lr = 0x830F6934;
	sub_831B2708(ctx, base);
	// 830F6934: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F6938: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F693C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830F6940: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6944: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830F6948: 409A000C  bne cr6, 0x830f6954
	if !ctx.cr[6].eq {
	pc = 0x830F6954; continue 'dispatch;
	}
	// 830F694C: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830F6950: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F6954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F6958: 480BBDB1  bl 0x831b2708
	ctx.lr = 0x830F695C;
	sub_831B2708(ctx, base);
	// 830F695C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F6960: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F6964: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830F6968: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F696C: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830F6970: 409A000C  bne cr6, 0x830f697c
	if !ctx.cr[6].eq {
	pc = 0x830F697C; continue 'dispatch;
	}
	// 830F6974: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830F6978: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F697C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F6980: 480BBD89  bl 0x831b2708
	ctx.lr = 0x830F6984;
	sub_831B2708(ctx, base);
	// 830F6984: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F6988: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F698C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830F6990: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6994: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830F6998: 409A000C  bne cr6, 0x830f69a4
	if !ctx.cr[6].eq {
	pc = 0x830F69A4; continue 'dispatch;
	}
	// 830F699C: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830F69A0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F69A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F69A8: 480BBD61  bl 0x831b2708
	ctx.lr = 0x830F69AC;
	sub_831B2708(ctx, base);
	// 830F69AC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F69B0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F69B4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830F69B8: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F69BC: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830F69C0: 409A000C  bne cr6, 0x830f69cc
	if !ctx.cr[6].eq {
	pc = 0x830F69CC; continue 'dispatch;
	}
	// 830F69C4: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830F69C8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830F69CC: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 830F69D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F69D4: 480BBFDD  bl 0x831b29b0
	ctx.lr = 0x830F69D8;
	sub_831B29B0(ctx, base);
	// 830F69D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F69DC: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830F69E0: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F69E4: 2B0A002C  cmplwi cr6, r10, 0x2c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 44 as u32, &mut ctx.xer);
	// 830F69E8: 409A000C  bne cr6, 0x830f69f4
	if !ctx.cr[6].eq {
	pc = 0x830F69F4; continue 'dispatch;
	}
	// 830F69EC: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 830F69F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F69F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F69F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F69FC: 4BFFEB3D  bl 0x830f5538
	ctx.lr = 0x830F6A00;
	sub_830F5538(ctx, base);
	// 830F6A00: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F6A04: 4082FEC0  bne 0x830f68c4
	if !ctx.cr[0].eq {
	pc = 0x830F68C4; continue 'dispatch;
	}
	// 830F6A08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F6A0C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6A10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F6A14: 41820010  beq 0x830f6a24
	if ctx.cr[0].eq {
	pc = 0x830F6A24; continue 'dispatch;
	}
	// 830F6A18: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830F6A1C: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 830F6A20: 48000008  b 0x830f6a28
	pc = 0x830F6A28; continue 'dispatch;
	// 830F6A24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6A28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F6A2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6A30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6A34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F6A38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F6A3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F6A40 size=200
    let mut pc: u32 = 0x830F6A40;
    'dispatch: loop {
        match pc {
            0x830F6A40 => {
    //   block [0x830F6A40..0x830F6B08)
	// 830F6A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6A44: 480B1721  bl 0x831a8164
	ctx.lr = 0x830F6A48;
	sub_831A8130(ctx, base);
	// 830F6A48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6A4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F6A50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830F6A54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F6A58: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F6A5C: 4BFFA50D  bl 0x830f0f68
	ctx.lr = 0x830F6A60;
	sub_830F0F68(ctx, base);
	// 830F6A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6A64: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6A68: 480107D1  bl 0x83107238
	ctx.lr = 0x830F6A6C;
	sub_83107238(ctx, base);
	// 830F6A6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6A70: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6A74: 480107C5  bl 0x83107238
	ctx.lr = 0x830F6A78;
	sub_83107238(ctx, base);
	// 830F6A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6A7C: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6A80: 48010789  bl 0x83107208
	ctx.lr = 0x830F6A84;
	sub_83107208(ctx, base);
	// 830F6A84: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6A88: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F6A8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6A90: 4099006C  ble cr6, 0x830f6afc
	if !ctx.cr[6].gt {
	pc = 0x830F6AFC; continue 'dispatch;
	}
	// 830F6A94: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830F6A98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6AA0: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830F6AA4: 7C2BDC2E  lfsx f1, r11, r27
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6AA8: 48010791  bl 0x83107238
	ctx.lr = 0x830F6AAC;
	sub_83107238(ctx, base);
	// 830F6AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6AB0: C03E0004  lfs f1, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6AB4: 48010785  bl 0x83107238
	ctx.lr = 0x830F6AB8;
	sub_83107238(ctx, base);
	// 830F6AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6ABC: C03E0008  lfs f1, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6AC0: 48010779  bl 0x83107238
	ctx.lr = 0x830F6AC4;
	sub_83107238(ctx, base);
	// 830F6AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6AC8: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6ACC: 4801076D  bl 0x83107238
	ctx.lr = 0x830F6AD0;
	sub_83107238(ctx, base);
	// 830F6AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6AD4: C03E0010  lfs f1, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6AD8: 48010761  bl 0x83107238
	ctx.lr = 0x830F6ADC;
	sub_83107238(ctx, base);
	// 830F6ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F6AE0: C03E0014  lfs f1, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F6AE4: 48010755  bl 0x83107238
	ctx.lr = 0x830F6AE8;
	sub_83107238(ctx, base);
	// 830F6AE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6AEC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830F6AF0: 3B7B001C  addi r27, r27, 0x1c
	ctx.r[27].s64 = ctx.r[27].s64 + 28;
	// 830F6AF4: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F6AF8: 4198FFA0  blt cr6, 0x830f6a98
	if ctx.cr[6].lt {
	pc = 0x830F6A98; continue 'dispatch;
	}
	// 830F6AFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6B00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F6B04: 480B16B0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F6B08 size=276
    let mut pc: u32 = 0x830F6B08;
    'dispatch: loop {
        match pc {
            0x830F6B08 => {
    //   block [0x830F6B08..0x830F6C1C)
	// 830F6B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6B0C: 480B1661  bl 0x831a816c
	ctx.lr = 0x830F6B10;
	sub_831A8130(ctx, base);
	// 830F6B10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6B14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F6B18: 2B050008  cmplwi cr6, r5, 8
	ctx.cr[6].compare_u32(ctx.r[5].u32, 8 as u32, &mut ctx.xer);
	// 830F6B1C: 40980010  bge cr6, 0x830f6b2c
	if !ctx.cr[6].lt {
	pc = 0x830F6B2C; continue 'dispatch;
	}
	// 830F6B20: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830F6B24: 60630003  ori r3, r3, 3
	ctx.r[3].u64 = ctx.r[3].u64 | 3;
	// 830F6B28: 480000EC  b 0x830f6c14
	pc = 0x830F6C14; continue 'dispatch;
	// 830F6B2C: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6B30: 3965FFF8  addi r11, r5, -8
	ctx.r[11].s64 = ctx.r[5].s64 + -8;
	// 830F6B34: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6B38: 39440008  addi r10, r4, 8
	ctx.r[10].s64 = ctx.r[4].s64 + 8;
	// 830F6B3C: 80FD000C  lwz r7, 0xc(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F6B40: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F6B44: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 830F6B48: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F6B4C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 830F6B50: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F6B54: D00700BC  stfs f0, 0xbc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830F6B58: D1A700C0  stfs f13, 0xc0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830F6B5C: 812700C8  lwz r9, 0xc8(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F6B60: 61290004  ori r9, r9, 4
	ctx.r[9].u64 = ctx.r[9].u64 | 4;
	// 830F6B64: 912700C8  stw r9, 0xc8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 830F6B68: 4198FFB8  blt cr6, 0x830f6b20
	if ctx.cr[6].lt {
	pc = 0x830F6B20; continue 'dispatch;
	}
	// 830F6B6C: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6B70: 3BEA0004  addi r31, r10, 4
	ctx.r[31].s64 = ctx.r[10].s64 + 4;
	// 830F6B74: 1D5E0018  mulli r10, r30, 0x18
	ctx.r[10].s64 = ctx.r[30].s64 * 24;
	// 830F6B78: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830F6B7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F6B80: 4198FFA0  blt cr6, 0x830f6b20
	if ctx.cr[6].lt {
	pc = 0x830F6B20; continue 'dispatch;
	}
	// 830F6B84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F6B88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6B8C: 4BFEFA1D  bl 0x830e65a8
	ctx.lr = 0x830F6B90;
	sub_830E65A8(ctx, base);
	// 830F6B90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6B94: 40820010  bne 0x830f6ba4
	if !ctx.cr[0].eq {
	pc = 0x830F6BA4; continue 'dispatch;
	}
	// 830F6B98: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F6B9C: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830F6BA0: 48000074  b 0x830f6c14
	pc = 0x830F6C14; continue 'dispatch;
	// 830F6BA4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F6BA8: 40990068  ble cr6, 0x830f6c10
	if !ctx.cr[6].gt {
	pc = 0x830F6C10; continue 'dispatch;
	}
	// 830F6BAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F6BB0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 830F6BB4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 830F6BB8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6BBC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6BC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F6BC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6BC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F6BCC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830F6BD0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 830F6BD4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6BD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6BDC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6BE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6BE4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 830F6BE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6BEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830F6BF0: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 830F6BF4: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 830F6BF8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6BFC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 830F6C00: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830F6C04: 4BFFE935  bl 0x830f5538
	ctx.lr = 0x830F6C08;
	sub_830F5538(ctx, base);
	// 830F6C08: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F6C0C: 4082FFA8  bne 0x830f6bb4
	if !ctx.cr[0].eq {
	pc = 0x830F6BB4; continue 'dispatch;
	}
	// 830F6C10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6C14: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F6C18: 480B15A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F6C20 size=72
    let mut pc: u32 = 0x830F6C20;
    'dispatch: loop {
        match pc {
            0x830F6C20 => {
    //   block [0x830F6C20..0x830F6C68)
	// 830F6C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F6C28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6C2C: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830F6C30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F6C34: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830F6C38: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 830F6C3C: 4BFFEBA5  bl 0x830f57e0
	ctx.lr = 0x830F6C40;
	sub_830F57E0(ctx, base);
	// 830F6C40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6C44: 40820010  bne 0x830f6c54
	if !ctx.cr[0].eq {
	pc = 0x830F6C54; continue 'dispatch;
	}
	// 830F6C48: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F6C4C: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830F6C50: 48000008  b 0x830f6c58
	pc = 0x830F6C58; continue 'dispatch;
	// 830F6C54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6C58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F6C5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F6C60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F6C64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F6C68 size=900
    let mut pc: u32 = 0x830F6C68;
    'dispatch: loop {
        match pc {
            0x830F6C68 => {
    //   block [0x830F6C68..0x830F6FEC)
	// 830F6C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6C6C: 480B14F9  bl 0x831a8164
	ctx.lr = 0x830F6C70;
	sub_831A8130(ctx, base);
	// 830F6C70: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6C74: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 830F6C78: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F6C7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F6C80: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830F6C84: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830F6C88: 93E10194  stw r31, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[31].u32 ) };
	// 830F6C8C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F6C90: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F6C94: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 830F6C98: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830F6C9C: 4BFEFD65  bl 0x830e6a00
	ctx.lr = 0x830F6CA0;
	sub_830E6A00(ctx, base);
	// 830F6CA0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 830F6CA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6CA8: 4BFD7871  bl 0x830ce518
	ctx.lr = 0x830F6CAC;
	sub_830CE518(ctx, base);
	// 830F6CAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6CB0: 41800028  blt 0x830f6cd8
	if ctx.cr[0].lt {
	pc = 0x830F6CD8; continue 'dispatch;
	}
	// 830F6CB4: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 830F6CB8: 806100C0  lwz r3, 0xc0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 830F6CBC: 4BFDEF0D  bl 0x830d5bc8
	ctx.lr = 0x830F6CC0;
	sub_830D5BC8(ctx, base);
	// 830F6CC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6CC4: 41800014  blt 0x830f6cd8
	if ctx.cr[0].lt {
	pc = 0x830F6CD8; continue 'dispatch;
	}
	// 830F6CC8: 816100E8  lwz r11, 0xe8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F6CCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6CD0: 409A0010  bne cr6, 0x830f6ce0
	if !ctx.cr[6].eq {
	pc = 0x830F6CE0; continue 'dispatch;
	}
	// 830F6CD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F6CD8: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 830F6CDC: 480B14D8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 830F6CE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6CE4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830F6CE8: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 830F6CEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F6CF0: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 830F6CF4: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830F6CF8: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 830F6CFC: 40990064  ble cr6, 0x830f6d60
	if !ctx.cr[6].gt {
	pc = 0x830F6D60; continue 'dispatch;
	}
	// 830F6D00: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830F6D04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6D08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F6D0C: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F6D10: 4BFFEAD1  bl 0x830f57e0
	ctx.lr = 0x830F6D14;
	sub_830F57E0(ctx, base);
	// 830F6D14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6D18: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F6D1C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F6D20: 4098002C  bge cr6, 0x830f6d4c
	if !ctx.cr[6].lt {
	pc = 0x830F6D4C; continue 'dispatch;
	}
	// 830F6D24: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6D28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F6D2C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F6D30: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 830F6D34: 4BFFEAAD  bl 0x830f57e0
	ctx.lr = 0x830F6D38;
	sub_830F57E0(ctx, base);
	// 830F6D38: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6D3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F6D40: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F6D44: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 830F6D48: 4BFFEA99  bl 0x830f57e0
	ctx.lr = 0x830F6D4C;
	sub_830F57E0(ctx, base);
	// 830F6D4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6D50: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830F6D54: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 830F6D58: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F6D5C: 4198FFA8  blt cr6, 0x830f6d04
	if ctx.cr[6].lt {
	pc = 0x830F6D04; continue 'dispatch;
	}
	// 830F6D60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F6D64: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830F6D68: 41980040  blt cr6, 0x830f6da8
	if ctx.cr[6].lt {
	pc = 0x830F6DA8; continue 'dispatch;
	}
	// 830F6D6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F6D70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F6D74: 1FCB001C  mulli r30, r11, 0x1c
	ctx.r[30].s64 = ctx.r[11].s64 * 28;
	// 830F6D78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6D7C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F6D80: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 830F6D84: 4BFFEA5D  bl 0x830f57e0
	ctx.lr = 0x830F6D88;
	sub_830F57E0(ctx, base);
	// 830F6D88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6D8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F6D90: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830F6D94: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 830F6D98: 4BFFEA49  bl 0x830f57e0
	ctx.lr = 0x830F6D9C;
	sub_830F57E0(ctx, base);
	// 830F6D9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F6DA0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F6DA4: 4BFFEA3D  bl 0x830f57e0
	ctx.lr = 0x830F6DA8;
	sub_830F57E0(ctx, base);
	// 830F6DA8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830F6DAC: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830F6DB0: 936100D4  stw r27, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[27].u32 ) };
	// 830F6DB4: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830F6DB8: 378BFFFD  addic. r28, r11, -3
	ctx.xer.ca = (ctx.r[11].u32 > (!(-3 as u32)));
	ctx.r[28].s64 = ctx.r[11].s64 + -3;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F6DBC: 936100D8  stw r27, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[27].u32 ) };
	// 830F6DC0: 396A95D4  addi r11, r10, -0x6a2c
	ctx.r[11].s64 = ctx.r[10].s64 + -27180;
	// 830F6DC4: 936100DC  stw r27, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[27].u32 ) };
	// 830F6DC8: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 830F6DCC: 40810038  ble 0x830f6e04
	if !ctx.cr[0].gt {
	pc = 0x830F6E04; continue 'dispatch;
	}
	// 830F6DD0: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F6DD4: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 830F6DD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F6DDC: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 830F6DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F6DE4: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 830F6DE8: 4BFF1AF9  bl 0x830e88e0
	ctx.lr = 0x830F6DEC;
	sub_830E88E0(ctx, base);
	// 830F6DEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F6DF0: 418001E0  blt 0x830f6fd0
	if ctx.cr[0].lt {
	pc = 0x830F6FD0; continue 'dispatch;
	}
	// 830F6DF4: 3BBD0003  addi r29, r29, 3
	ctx.r[29].s64 = ctx.r[29].s64 + 3;
	// 830F6DF8: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 830F6DFC: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830F6E00: 4198FFD4  blt cr6, 0x830f6dd4
	if ctx.cr[6].lt {
	pc = 0x830F6DD4; continue 'dispatch;
	}
	// 830F6E04: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 830F6E08: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F6E0C: 4BFE8BF5  bl 0x830dfa00
	ctx.lr = 0x830F6E10;
	sub_830DFA00(ctx, base);
	// 830F6E10: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F6FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F6FF0 size=232
    let mut pc: u32 = 0x830F6FF0;
    'dispatch: loop {
        match pc {
            0x830F6FF0 => {
    //   block [0x830F6FF0..0x830F70D8)
	// 830F6FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F6FF4: 480B1179  bl 0x831a816c
	ctx.lr = 0x830F6FF8;
	sub_831A8130(ctx, base);
	// 830F6FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F6FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7000: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F7004: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F7008: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F700C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F7010: 419A0014  beq cr6, 0x830f7024
	if ctx.cr[6].eq {
	pc = 0x830F7024; continue 'dispatch;
	}
	// 830F7014: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F7018: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F701C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7020: 480000B0  b 0x830f70d0
	pc = 0x830F70D0; continue 'dispatch;
	// 830F7024: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F7028: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 830F702C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F7030: 419A0010  beq cr6, 0x830f7040
	if ctx.cr[6].eq {
	pc = 0x830F7040; continue 'dispatch;
	}
	// 830F7034: 4801B295  bl 0x831122c8
	ctx.lr = 0x830F7038;
	sub_831122C8(ctx, base);
	// 830F7038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F703C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7040: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F7044: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7048: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F704C: 419A000C  beq cr6, 0x830f7058
	if ctx.cr[6].eq {
	pc = 0x830F7058; continue 'dispatch;
	}
	// 830F7050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7054: 4BFF9E5D  bl 0x830f0eb0
	ctx.lr = 0x830F7058;
	sub_830F0EB0(ctx, base);
	// 830F7058: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F705C: C01F00BC  lfs f0, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7060: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F7064: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 830F7068: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F706C: C18A08A8  lfs f12, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F7070: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F7074: 419A0014  beq cr6, 0x830f7088
	if ctx.cr[6].eq {
	pc = 0x830F7088; continue 'dispatch;
	}
	// 830F7078: C17F00B4  lfs f11, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F707C: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 830F7080: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830F7084: 48000008  b 0x830f708c
	pc = 0x830F708C; continue 'dispatch;
	// 830F7088: D19F00CC  stfs f12, 0xcc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830F708C: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7090: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F7094: 419A0014  beq cr6, 0x830f70a8
	if ctx.cr[6].eq {
	pc = 0x830F70A8; continue 'dispatch;
	}
	// 830F7098: C1BF00B8  lfs f13, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F709C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 830F70A0: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830F70A4: 48000008  b 0x830f70ac
	pc = 0x830F70AC; continue 'dispatch;
	// 830F70A8: D19F00D0  stfs f12, 0xd0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830F70AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F70B0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F70B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F70B8: 4801BFF1  bl 0x831130a8
	ctx.lr = 0x830F70BC;
	sub_831130A8(ctx, base);
	// 830F70BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F70C0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F70C4: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F70C8: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F70CC: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 830F70D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F70D4: 480B10E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F70D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F70D8 size=1188
    let mut pc: u32 = 0x830F70D8;
    'dispatch: loop {
        match pc {
            0x830F70D8 => {
    //   block [0x830F70D8..0x830F757C)
	// 830F70D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F70DC: 480B108D  bl 0x831a8168
	ctx.lr = 0x830F70E0;
	sub_831A8130(ctx, base);
	// 830F70E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F70E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830F70E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F70EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F70F0: 2B0A03E9  cmplwi cr6, r10, 0x3e9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1001 as u32, &mut ctx.xer);
	// 830F70F4: 41990240  bgt cr6, 0x830f7334
	if ctx.cr[6].gt {
	pc = 0x830F7334; continue 'dispatch;
	}
	// 830F70F8: 419A020C  beq cr6, 0x830f7304
	if ctx.cr[6].eq {
	pc = 0x830F7304; continue 'dispatch;
	}
	// 830F70FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F7100: 419A0100  beq cr6, 0x830f7200
	if ctx.cr[6].eq {
	pc = 0x830F7200; continue 'dispatch;
	}
	// 830F7104: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 830F7108: 419A00E8  beq cr6, 0x830f71f0
	if ctx.cr[6].eq {
	pc = 0x830F71F0; continue 'dispatch;
	}
	// 830F710C: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 830F7110: 419A0098  beq cr6, 0x830f71a8
	if ctx.cr[6].eq {
	pc = 0x830F71A8; continue 'dispatch;
	}
	// 830F7114: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	// 830F7118: 419A0070  beq cr6, 0x830f7188
	if ctx.cr[6].eq {
	pc = 0x830F7188; continue 'dispatch;
	}
	// 830F711C: 2B0A0029  cmplwi cr6, r10, 0x29
	ctx.cr[6].compare_u32(ctx.r[10].u32, 41 as u32, &mut ctx.xer);
	// 830F7120: 419A0024  beq cr6, 0x830f7144
	if ctx.cr[6].eq {
	pc = 0x830F7144; continue 'dispatch;
	}
	// 830F7124: 2B0A03E8  cmplwi cr6, r10, 0x3e8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1000 as u32, &mut ctx.xer);
	// 830F7128: 409A0448  bne cr6, 0x830f7570
	if !ctx.cr[6].eq {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F712C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7130: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F7134: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F7138: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F713C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F7140: 48000430  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F7144: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F7148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F714C: 4BFFFEA5  bl 0x830f6ff0
	ctx.lr = 0x830F7150;
	sub_830F6FF0(ctx, base);
	// 830F7150: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F7154: 4180041C  blt 0x830f7570
	if ctx.cr[0].lt {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7158: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F715C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F7160: 419A0410  beq cr6, 0x830f7570
	if ctx.cr[6].eq {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7164: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 830F7168: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F716C: 419A0404  beq cr6, 0x830f7570
	if ctx.cr[6].eq {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7170: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830F7174: C05F00B8  lfs f2, 0xb8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F7178: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830F717C: C03F00B4  lfs f1, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F7180: 4BFF9AF1  bl 0x830f0c70
	ctx.lr = 0x830F7184;
	sub_830F0C70(ctx, base);
	// 830F7184: 480003EC  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F7188: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F718C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7190: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F7194: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F7198: 409A03D8  bne cr6, 0x830f7570
	if !ctx.cr[6].eq {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F719C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830F71A0: 4BFEDDE1  bl 0x830e4f80
	ctx.lr = 0x830F71A4;
	sub_830E4F80(ctx, base);
	// 830F71A4: 480003CC  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F71A8: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F71AC: 395F0014  addi r10, r31, 0x14
	ctx.r[10].s64 = ctx.r[31].s64 + 20;
	// 830F71B0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F71B4: C009000C  lfs f0, 0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F71B8: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F71BC: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830F71C0: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830F71C4: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 830F71C8: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 830F71CC: 915F0098  stw r10, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 830F71D0: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F71D4: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 830F71D8: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 830F71DC: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 830F71E0: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 830F71E4: 915F0098  stw r10, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 830F71E8: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F71EC: 48000384  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F71F0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830F71F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F71F8: 4BFFFA71  bl 0x830f6c68
	ctx.lr = 0x830F71FC;
	sub_830F6C68(ctx, base);
	// 830F71FC: 48000378  b 0x830f7574
	pc = 0x830F7574; continue 'dispatch;
	// 830F7200: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F7204: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F7208: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F720C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F7210: 41980360  blt cr6, 0x830f7570
	if ctx.cr[6].lt {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7214: 838B0010  lwz r28, 0x10(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7218: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830F721C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7220: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F7224: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7228: 4BFE9229  bl 0x830e0450
	ctx.lr = 0x830F722C;
	sub_830E0450(ctx, base);
	// 830F722C: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F7230: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F7234: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F7238: 83BF00C4  lwz r29, 0xc4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 830F723C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830F7240: 409A0014  bne cr6, 0x830f7254
	if !ctx.cr[6].eq {
	pc = 0x830F7254; continue 'dispatch;
	}
	// 830F7244: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F7248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F724C: 4BFFFDA5  bl 0x830f6ff0
	ctx.lr = 0x830F7250;
	sub_830F6FF0(ctx, base);
	// 830F7250: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F7254: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F7258: 419A0098  beq cr6, 0x830f72f0
	if ctx.cr[6].eq {
	pc = 0x830F72F0; continue 'dispatch;
	}
	// 830F725C: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 830F7260: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7264: 419A0040  beq cr6, 0x830f72a4
	if ctx.cr[6].eq {
	pc = 0x830F72A4; continue 'dispatch;
	}
	// 830F7268: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830F726C: C05F00B8  lfs f2, 0xb8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F7270: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830F7274: C03F00B4  lfs f1, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F7278: 4BFF99F9  bl 0x830f0c70
	ctx.lr = 0x830F727C;
	sub_830F0C70(ctx, base);
	// 830F727C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F7280: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F7284: 419A0020  beq cr6, 0x830f72a4
	if ctx.cr[6].eq {
	pc = 0x830F72A4; continue 'dispatch;
	}
	// 830F7288: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 830F728C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F7290: 5565F6BE  rlwinm r5, r11, 0x1e, 0x1a, 0x1f
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 830F7294: 4801909D  bl 0x83110330
	ctx.lr = 0x830F7298;
	sub_83110330(ctx, base);
	// 830F7298: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F729C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F72A0: 48019109  bl 0x831103a8
	ctx.lr = 0x830F72A4;
	sub_831103A8(ctx, base);
	// 830F72A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F72A8: C1BF00A4  lfs f13, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F72AC: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F72B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F72B4: 4198003C  blt cr6, 0x830f72f0
	if ctx.cr[6].lt {
	pc = 0x830F72F0; continue 'dispatch;
	}
	// 830F72B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F72BC: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 830F72C0: 4BFEE649  bl 0x830e5908
	ctx.lr = 0x830F72C4;
	sub_830E5908(ctx, base);
	// 830F72C4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F72C8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F72CC: 419A0024  beq cr6, 0x830f72f0
	if ctx.cr[6].eq {
	pc = 0x830F72F0; continue 'dispatch;
	}
	// 830F72D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F72D4: 4801AC5D  bl 0x83111f30
	ctx.lr = 0x830F72D8;
	sub_83111F30(ctx, base);
	// 830F72D8: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F72DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F72E0: C03F00A4  lfs f1, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F72E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F72E8: 5566FFFE  rlwinm r6, r11, 0x1f, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F72EC: 48018C4D  bl 0x8310ff38
	ctx.lr = 0x830F72F0;
	sub_8310FF38(ctx, base);
	// 830F72F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830F72F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F72F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F72FC: 4BFE91B5  bl 0x830e04b0
	ctx.lr = 0x830F7300;
	sub_830E04B0(ctx, base);
	// 830F7300: 48000270  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F7304: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F7308: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F730C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F7310: 512A07FE  rlwimi r10, r9, 0, 0x1f, 0x1f
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFFE);
	// 830F7314: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F7318: 512A077A  rlwimi r10, r9, 0, 0x1d, 0x1d
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000004) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFFB);
	// 830F731C: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 830F7320: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F7324: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7328: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F732C: 4BFFE20D  bl 0x830f5538
	ctx.lr = 0x830F7330;
	sub_830F5538(ctx, base);
	// 830F7330: 48000240  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F7334: 2B0A03EA  cmplwi cr6, r10, 0x3ea
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1002 as u32, &mut ctx.xer);
	// 830F7338: 419A020C  beq cr6, 0x830f7544
	if ctx.cr[6].eq {
	pc = 0x830F7544; continue 'dispatch;
	}
	// 830F733C: 2B0A03EB  cmplwi cr6, r10, 0x3eb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1003 as u32, &mut ctx.xer);
	// 830F7340: 419A0168  beq cr6, 0x830f74a8
	if ctx.cr[6].eq {
	pc = 0x830F74A8; continue 'dispatch;
	}
	// 830F7344: 2B0A03EC  cmplwi cr6, r10, 0x3ec
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1004 as u32, &mut ctx.xer);
	// 830F7348: 419A00B0  beq cr6, 0x830f73f8
	if ctx.cr[6].eq {
	pc = 0x830F73F8; continue 'dispatch;
	}
	// 830F734C: 40990224  ble cr6, 0x830f7570
	if !ctx.cr[6].gt {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7350: 2B0A03EE  cmplwi cr6, r10, 0x3ee
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1006 as u32, &mut ctx.xer);
	// 830F7354: 4099003C  ble cr6, 0x830f7390
	if !ctx.cr[6].gt {
	pc = 0x830F7390; continue 'dispatch;
	}
	// 830F7358: 2B0A03EF  cmplwi cr6, r10, 0x3ef
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1007 as u32, &mut ctx.xer);
	// 830F735C: 409A0214  bne cr6, 0x830f7570
	if !ctx.cr[6].eq {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7360: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F7364: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F736C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F7370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7374: C0080004  lfs f0, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7378: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830F737C: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7380: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830F7384: 4BFF2285  bl 0x830e9608
	ctx.lr = 0x830F7388;
	sub_830E9608(ctx, base);
	// 830F7388: 90680008  stw r3, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830F738C: 480001E4  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F7390: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7394: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F7398: 2B0A03ED  cmplwi cr6, r10, 0x3ed
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1005 as u32, &mut ctx.xer);
	// 830F739C: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F73A0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F73A4: 409A0024  bne cr6, 0x830f73c8
	if !ctx.cr[6].eq {
	pc = 0x830F73C8; continue 'dispatch;
	}
	// 830F73A8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F73AC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F73B0: 4098003C  bge cr6, 0x830f73ec
	if !ctx.cr[6].lt {
	pc = 0x830F73EC; continue 'dispatch;
	}
	// 830F73B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F73B8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F73BC: 409A0034  bne cr6, 0x830f73f0
	if !ctx.cr[6].eq {
	pc = 0x830F73F0; continue 'dispatch;
	}
	// 830F73C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F73C4: 4800002C  b 0x830f73f0
	pc = 0x830F73F0; continue 'dispatch;
	// 830F73C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F73CC: 41980020  blt cr6, 0x830f73ec
	if ctx.cr[6].lt {
	pc = 0x830F73EC; continue 'dispatch;
	}
	// 830F73D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F73D4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F73D8: 40980014  bge cr6, 0x830f73ec
	if !ctx.cr[6].lt {
	pc = 0x830F73EC; continue 'dispatch;
	}
	// 830F73DC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F73E0: 40800010  bge 0x830f73f0
	if !ctx.cr[0].lt {
	pc = 0x830F73F0; continue 'dispatch;
	}
	// 830F73E4: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 830F73E8: 48000008  b 0x830f73f0
	pc = 0x830F73F0; continue 'dispatch;
	// 830F73EC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830F73F0: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F73F4: 4800017C  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F73F8: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F73FC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F7400: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F7404: 512A07FE  rlwimi r10, r9, 0, 0x1f, 0x1f
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFFE);
	// 830F7408: 512A077A  rlwimi r10, r9, 0, 0x1d, 0x1d
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000004) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFFB);
	// 830F740C: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 830F7410: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7414: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F7418: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F741C: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7420: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F7424: 4098014C  bge cr6, 0x830f7570
	if !ctx.cr[6].lt {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7428: 1D09001C  mulli r8, r9, 0x1c
	ctx.r[8].s64 = ctx.r[9].s64 * 28;
	// 830F742C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7430: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F7434: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F7438: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F743C: 40980134  bge cr6, 0x830f7570
	if !ctx.cr[6].lt {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F7440: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F7444: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7448: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F744C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F7450: 1D4A001C  mulli r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 * 28;
	// 830F7454: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F7458: 7D464214  add r10, r6, r8
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 830F745C: 3908001C  addi r8, r8, 0x1c
	ctx.r[8].s64 = ctx.r[8].s64 + 28;
	// 830F7460: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7464: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F7468: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F746C: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F7470: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7474: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830F7478: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F747C: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830F7480: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7484: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830F7488: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F748C: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830F7490: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F7494: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830F7498: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F749C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F74A0: 4198FF8C  blt cr6, 0x830f742c
	if ctx.cr[6].lt {
	pc = 0x830F742C; continue 'dispatch;
	}
	// 830F74A4: 480000CC  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F74A8: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F74AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F74B0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F74B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F74B8: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F74BC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F74C0: 409800B0  bge cr6, 0x830f7570
	if !ctx.cr[6].lt {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F74C4: 1D09001C  mulli r8, r9, 0x1c
	ctx.r[8].s64 = ctx.r[9].s64 * 28;
	// 830F74C8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F74CC: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F74D0: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F74D4: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F74D8: 40980098  bge cr6, 0x830f7570
	if !ctx.cr[6].lt {
	pc = 0x830F7570; continue 'dispatch;
	}
	// 830F74DC: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F74E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F74E4: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F74E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830F74EC: 1D4A001C  mulli r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 * 28;
	// 830F74F0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830F74F4: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 830F74F8: 3908001C  addi r8, r8, 0x1c
	ctx.r[8].s64 = ctx.r[8].s64 + 28;
	// 830F74FC: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7500: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F7504: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7508: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F750C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7510: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830F7514: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7518: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830F751C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7520: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830F7524: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7528: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830F752C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F7530: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830F7534: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F7538: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F753C: 4198FF8C  blt cr6, 0x830f74c8
	if ctx.cr[6].lt {
	pc = 0x830F74C8; continue 'dispatch;
	}
	// 830F7540: 48000030  b 0x830f7570
	pc = 0x830F7570; continue 'dispatch;
	// 830F7544: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830F7548: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F754C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830F7550: 512A07FE  rlwimi r10, r9, 0, 0x1f, 0x1f
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFFE);
	// 830F7554: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830F7558: 512A077A  rlwimi r10, r9, 0, 0x1d, 0x1d
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000004) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFFB);
	// 830F755C: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 830F7560: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830F7564: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F7568: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F756C: 4BFEF0AD  bl 0x830e6618
	ctx.lr = 0x830F7570;
	sub_830E6618(ctx, base);
	// 830F7570: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F7574: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F7578: 480B0C40  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F7580 size=20
    let mut pc: u32 = 0x830F7580;
    'dispatch: loop {
        match pc {
            0x830F7580 => {
    //   block [0x830F7580..0x830F7594)
	// 830F7580: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F7584: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830F7588: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830F758C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7590: 4BFF9A90  b 0x830f1020
	sub_830F1020(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7598 size=272
    let mut pc: u32 = 0x830F7598;
    'dispatch: loop {
        match pc {
            0x830F7598 => {
    //   block [0x830F7598..0x830F76A8)
	// 830F7598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F759C: 480B0BCD  bl 0x831a8168
	ctx.lr = 0x830F75A0;
	sub_831A8130(ctx, base);
	// 830F75A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F75A4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F75A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F75AC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F75B0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 830F75B4: 409A00E8  bne cr6, 0x830f769c
	if !ctx.cr[6].eq {
	pc = 0x830F769C; continue 'dispatch;
	}
	// 830F75B8: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F75BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F75C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F75C4: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F75C8: 409A00D4  bne cr6, 0x830f769c
	if !ctx.cr[6].eq {
	pc = 0x830F769C; continue 'dispatch;
	}
	// 830F75CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830F75D0: 4BFE8189  bl 0x830df758
	ctx.lr = 0x830F75D4;
	sub_830DF758(ctx, base);
	// 830F75D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F75D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F75DC: 419A00B8  beq cr6, 0x830f7694
	if ctx.cr[6].eq {
	pc = 0x830F7694; continue 'dispatch;
	}
	// 830F75E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F75E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F75E8: 4BFE81E9  bl 0x830df7d0
	ctx.lr = 0x830F75EC;
	sub_830DF7D0(ctx, base);
	// 830F75EC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F75F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F75F4: 419A00A0  beq cr6, 0x830f7694
	if ctx.cr[6].eq {
	pc = 0x830F7694; continue 'dispatch;
	}
	// 830F75F8: 4BFE7559  bl 0x830deb50
	ctx.lr = 0x830F75FC;
	sub_830DEB50(ctx, base);
	// 830F75FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F7600: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F7604: 557D07FF  clrlwi. r29, r11, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F7608: 40820010  bne 0x830f7618
	if !ctx.cr[0].eq {
	pc = 0x830F7618; continue 'dispatch;
	}
	// 830F760C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F7614: 409A0048  bne cr6, 0x830f765c
	if !ctx.cr[6].eq {
	pc = 0x830F765C; continue 'dispatch;
	}
	// 830F7618: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F761C: 4BFE7F75  bl 0x830df590
	ctx.lr = 0x830F7620;
	sub_830DF590(ctx, base);
	// 830F7620: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F7624: 4BFE80ED  bl 0x830df710
	ctx.lr = 0x830F7628;
	sub_830DF710(ctx, base);
	// 830F7628: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F762C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7630: 4BFE8291  bl 0x830df8c0
	ctx.lr = 0x830F7634;
	sub_830DF8C0(ctx, base);
	// 830F7634: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F7638: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F763C: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7640: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F7644: 4BFE836D  bl 0x830df9b0
	ctx.lr = 0x830F7648;
	sub_830DF9B0(ctx, base);
	// 830F7648: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F764C: 4BFE7F45  bl 0x830df590
	ctx.lr = 0x830F7650;
	sub_830DF590(ctx, base);
	// 830F7650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7654: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F7658: 4BFF9E09  bl 0x830f1460
	ctx.lr = 0x830F765C;
	sub_830F1460(ctx, base);
	// 830F765C: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F7660: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F7664: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7668: 917E0038  stw r11, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830F766C: 409A0020  bne cr6, 0x830f768c
	if !ctx.cr[6].eq {
	pc = 0x830F768C; continue 'dispatch;
	}
	// 830F7670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7674: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F7678: 4BFF9DE9  bl 0x830f1460
	ctx.lr = 0x830F767C;
	sub_830F1460(ctx, base);
	// 830F767C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F7680: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F7684: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F7688: 4BFEAD61  bl 0x830e23e8
	ctx.lr = 0x830F768C;
	sub_830E23E8(ctx, base);
	// 830F768C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7690: 4BFE2199  bl 0x830d9828
	ctx.lr = 0x830F7694;
	sub_830D9828(ctx, base);
	// 830F7694: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7698: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F769C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F76A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F76A4: 480B0B14  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F76A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F76A8 size=96
    let mut pc: u32 = 0x830F76A8;
    'dispatch: loop {
        match pc {
            0x830F76A8 => {
    //   block [0x830F76A8..0x830F7708)
	// 830F76A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F76AC: 480B0AC1  bl 0x831a816c
	ctx.lr = 0x830F76B0;
	sub_831A8130(ctx, base);
	// 830F76B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F76B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F76B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F76BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830F76C0: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F76C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F76C8: 40990038  ble cr6, 0x830f7700
	if !ctx.cr[6].gt {
	pc = 0x830F7700; continue 'dispatch;
	}
	// 830F76CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F76D0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830F76D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F76D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F76DC: 7CBD582E  lwzx r5, r29, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830F76E0: 4BFFA001  bl 0x830f16e0
	ctx.lr = 0x830F76E4;
	sub_830F16E0(ctx, base);
	// 830F76E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F76E8: 41800018  blt 0x830f7700
	if ctx.cr[0].lt {
	pc = 0x830F7700; continue 'dispatch;
	}
	// 830F76EC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F76F0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F76F4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830F76F8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F76FC: 4198FFD4  blt cr6, 0x830f76d0
	if ctx.cr[6].lt {
	pc = 0x830F76D0; continue 'dispatch;
	}
	// 830F7700: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7704: 480B0AB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7708 size=404
    let mut pc: u32 = 0x830F7708;
    'dispatch: loop {
        match pc {
            0x830F7708 => {
    //   block [0x830F7708..0x830F789C)
	// 830F7708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F770C: 480B0A61  bl 0x831a816c
	ctx.lr = 0x830F7710;
	sub_831A8130(ctx, base);
	// 830F7710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7718: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F771C: 4BFFA205  bl 0x830f1920
	ctx.lr = 0x830F7720;
	sub_830F1920(ctx, base);
	// 830F7720: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830F7724: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830F7728: 2F1E0005  cmpwi cr6, r30, 5
	ctx.cr[6].compare_i32(ctx.r[30].s32, 5, &mut ctx.xer);
	// 830F772C: 409A0094  bne cr6, 0x830f77c0
	if !ctx.cr[6].eq {
	pc = 0x830F77C0; continue 'dispatch;
	}
	// 830F7730: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F7734: 4099001C  ble cr6, 0x830f7750
	if !ctx.cr[6].gt {
	pc = 0x830F7750; continue 'dispatch;
	}
	// 830F7738: 83DF00E8  lwz r30, 0xe8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F773C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7740: 4BFD74D1  bl 0x830cec10
	ctx.lr = 0x830F7744;
	sub_830CEC10(ctx, base);
	// 830F7744: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F7748: 4BFF0279  bl 0x830e79c0
	ctx.lr = 0x830F774C;
	sub_830E79C0(ctx, base);
	// 830F774C: 48000148  b 0x830f7894
	pc = 0x830F7894; continue 'dispatch;
	// 830F7750: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F7754: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830F7758: 4099013C  ble cr6, 0x830f7894
	if !ctx.cr[6].gt {
	pc = 0x830F7894; continue 'dispatch;
	}
	// 830F775C: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F7760: 7D6B4851  subf. r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7764: 3BCAFFFF  addi r30, r10, -1
	ctx.r[30].s64 = ctx.r[10].s64 + -1;
	// 830F7768: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 830F776C: 41810010  bgt 0x830f777c
	if ctx.cr[0].gt {
	pc = 0x830F777C; continue 'dispatch;
	}
	// 830F7770: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F7774: 48000008  b 0x830f777c
	pc = 0x830F777C; continue 'dispatch;
	// 830F7778: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 830F777C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7780: 4BFD7491  bl 0x830cec10
	ctx.lr = 0x830F7784;
	sub_830CEC10(ctx, base);
	// 830F7784: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F7788: 4BFF0429  bl 0x830e7bb0
	ctx.lr = 0x830F778C;
	sub_830E7BB0(ctx, base);
	// 830F778C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7790: 83BF00E8  lwz r29, 0xe8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F7794: 4BFD747D  bl 0x830cec10
	ctx.lr = 0x830F7798;
	sub_830CEC10(ctx, base);
	// 830F7798: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F779C: 4BFF0225  bl 0x830e79c0
	ctx.lr = 0x830F77A0;
	sub_830E79C0(ctx, base);
	// 830F77A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F77A4: 4BFFA17D  bl 0x830f1920
	ctx.lr = 0x830F77A8;
	sub_830F1920(ctx, base);
	// 830F77A8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F77AC: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 830F77B0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F77B4: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F77B8: 4198FFC0  blt cr6, 0x830f7778
	if ctx.cr[6].lt {
	pc = 0x830F7778; continue 'dispatch;
	}
	// 830F77BC: 480000D8  b 0x830f7894
	pc = 0x830F7894; continue 'dispatch;
	// 830F77C0: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 830F77C4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830F77C8: 4098004C  bge cr6, 0x830f7814
	if !ctx.cr[6].lt {
	pc = 0x830F7814; continue 'dispatch;
	}
	// 830F77CC: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F77D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F77D4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F77D8: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 830F77DC: 4BFD7435  bl 0x830cec10
	ctx.lr = 0x830F77E0;
	sub_830CEC10(ctx, base);
	// 830F77E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F77E4: 4BFF01DD  bl 0x830e79c0
	ctx.lr = 0x830F77E8;
	sub_830E79C0(ctx, base);
	// 830F77E8: 4800001C  b 0x830f7804
	pc = 0x830F7804; continue 'dispatch;
	// 830F77EC: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F77F0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F77F4: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 830F77F8: 4BFD7419  bl 0x830cec10
	ctx.lr = 0x830F77FC;
	sub_830CEC10(ctx, base);
	// 830F77FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F7800: 4BFF03B1  bl 0x830e7bb0
	ctx.lr = 0x830F7804;
	sub_830E7BB0(ctx, base);
	// 830F7804: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830F7808: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830F780C: 419AFFE0  beq cr6, 0x830f77ec
	if ctx.cr[6].eq {
	pc = 0x830F77EC; continue 'dispatch;
	}
	// 830F7810: 48000084  b 0x830f7894
	pc = 0x830F7894; continue 'dispatch;
	// 830F7814: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F7818: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F781C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F7820: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F7824: 40980070  bge cr6, 0x830f7894
	if !ctx.cr[6].lt {
	pc = 0x830F7894; continue 'dispatch;
	}
	// 830F7828: 5545003E  slwi r5, r10, 0
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830F782C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7830: 3BA50001  addi r29, r5, 1
	ctx.r[29].s64 = ctx.r[5].s64 + 1;
	// 830F7834: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F7838: 4BFFA439  bl 0x830f1c70
	ctx.lr = 0x830F783C;
	sub_830F1C70(ctx, base);
	// 830F783C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7840: 4BFF5E01  bl 0x830ed640
	ctx.lr = 0x830F7844;
	sub_830ED640(ctx, base);
	// 830F7844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F7848: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F784C: 48000008  b 0x830f7854
	pc = 0x830F7854; continue 'dispatch;
	// 830F7850: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830F7854: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F7858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F785C: 4BFFA415  bl 0x830f1c70
	ctx.lr = 0x830F7860;
	sub_830F1C70(ctx, base);
	// 830F7860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7864: 4BFF5DDD  bl 0x830ed640
	ctx.lr = 0x830F7868;
	sub_830ED640(ctx, base);
	// 830F7868: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830F786C: 7F05F000  cmpw cr6, r5, r30
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F7870: 409AFFE0  bne cr6, 0x830f7850
	if !ctx.cr[6].eq {
	pc = 0x830F7850; continue 'dispatch;
	}
	// 830F7874: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7878: 4BFD7399  bl 0x830cec10
	ctx.lr = 0x830F787C;
	sub_830CEC10(ctx, base);
	// 830F787C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F7880: 4BFF0141  bl 0x830e79c0
	ctx.lr = 0x830F7884;
	sub_830E79C0(ctx, base);
	// 830F7884: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7888: 4BFD7389  bl 0x830cec10
	ctx.lr = 0x830F788C;
	sub_830CEC10(ctx, base);
	// 830F788C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F7890: 4BFF0321  bl 0x830e7bb0
	ctx.lr = 0x830F7894;
	sub_830E7BB0(ctx, base);
	// 830F7894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7898: 480B0924  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F78A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F78A0 size=508
    let mut pc: u32 = 0x830F78A0;
    'dispatch: loop {
        match pc {
            0x830F78A0 => {
    //   block [0x830F78A0..0x830F7A9C)
	// 830F78A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F78A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F78A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F78AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F78B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F78B4: 80BF00EC  lwz r5, 0xec(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830F78B8: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830F78BC: 4BFFA3B5  bl 0x830f1c70
	ctx.lr = 0x830F78C0;
	sub_830F1C70(ctx, base);
	// 830F78C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F78C4: 40800010  bge 0x830f78d4
	if !ctx.cr[0].lt {
	pc = 0x830F78D4; continue 'dispatch;
	}
	// 830F78C8: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F78CC: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 830F78D0: 480001B8  b 0x830f7a88
	pc = 0x830F7A88; continue 'dispatch;
	// 830F78D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F78D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F78DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F78E0: 4BFF5CE9  bl 0x830ed5c8
	ctx.lr = 0x830F78E4;
	sub_830ED5C8(ctx, base);
	// 830F78E4: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F78E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F78EC: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 830F78F0: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F78F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F78F8: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 830F78FC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7900: 409A00C8  bne cr6, 0x830f79c8
	if !ctx.cr[6].eq {
	pc = 0x830F79C8; continue 'dispatch;
	}
	// 830F7904: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7908: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F790C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F7910: C19F008C  lfs f12, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F7914: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7918: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830F791C: 4180016C  blt 0x830f7a88
	if ctx.cr[0].lt {
	pc = 0x830F7A88; continue 'dispatch;
	}
	// 830F7920: C17F0054  lfs f11, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F7924: 815F00D8  lwz r10, 0xd8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 830F7928: 811F00D0  lwz r8, 0xd0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 830F792C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F7930: 813F00CC  lwz r9, 0xcc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 830F7934: 0CC80000  twi 6, r8, 0
	// 830F7938: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F793C: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F7940: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F7944: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F7948: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F794C: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830F7950: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F7954: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F7958: 0CA9FFFF  twi 5, r9, -1
	// 830F795C: E94A0004  ld r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	// 830F7960: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830F7964: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F7968: ED4C002A  fadds f10, f12, f0
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F796C: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 830F7970: 4199003C  bgt cr6, 0x830f79ac
	if ctx.cr[6].gt {
	pc = 0x830F79AC; continue 'dispatch;
	}
	// 830F7974: 813F00D8  lwz r9, 0xd8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 830F7978: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830F797C: 80FF00CC  lwz r7, 0xcc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 830F7980: 7CC943D6  divw r6, r9, r8
	ctx.r[6].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F7984: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F7988: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F798C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F7990: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 830F7994: 0CC80000  twi 6, r8, 0
	// 830F7998: 7D085078  andc r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 & !ctx.r[10].u64;
	// 830F799C: 1D490014  mulli r10, r9, 0x14
	ctx.r[10].s64 = ctx.r[9].s64 * 20;
	// 830F79A0: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830F79A4: 0CA8FFFF  twi 5, r8, -1
	// 830F79A8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F79AC: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 830F79B0: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F79B4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F79B8: 419900D0  bgt cr6, 0x830f7a88
	if ctx.cr[6].gt {
	pc = 0x830F7A88; continue 'dispatch;
	}
	// 830F79BC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F79C0: 4080FF64  bge 0x830f7924
	if !ctx.cr[0].lt {
	pc = 0x830F7924; continue 'dispatch;
	}
	// 830F79C4: 480000C4  b 0x830f7a88
	pc = 0x830F7A88; continue 'dispatch;
	// 830F79C8: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F79CC: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F79D0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F79D4: C19F0088  lfs f12, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F79D8: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F79DC: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830F79E0: 418000A8  blt 0x830f7a88
	if ctx.cr[0].lt {
	pc = 0x830F7A88; continue 'dispatch;
	}
	// 830F79E4: C17F0058  lfs f11, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F79E8: 815F00D8  lwz r10, 0xd8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 830F79EC: 811F00D0  lwz r8, 0xd0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 830F79F0: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F79F4: 813F00CC  lwz r9, 0xcc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 830F79F8: 0CC80000  twi 6, r8, 0
	// 830F79FC: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 830F7A00: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830F7A04: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F7A08: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 830F7A0C: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 830F7A10: 1D470014  mulli r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 * 20;
	// 830F7A14: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830F7A18: 7D093078  andc r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 & !ctx.r[6].u64;
	// 830F7A1C: 0CA9FFFF  twi 5, r9, -1
	// 830F7A20: E94A0004  ld r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	// 830F7A24: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830F7A28: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F7A2C: ED4C002A  fadds f10, f12, f0
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F7A30: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 830F7A34: 4199003C  bgt cr6, 0x830f7a70
	if ctx.cr[6].gt {
	pc = 0x830F7A70; continue 'dispatch;
	}
	// 830F7A38: 813F00D8  lwz r9, 0xd8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 830F7A3C: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830F7A40: 80FF00CC  lwz r7, 0xcc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 830F7A44: 7CC943D6  divw r6, r9, r8
	ctx.r[6].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830F7A48: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830F7A4C: 7CC641D6  mullw r6, r6, r8
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830F7A50: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830F7A54: 7D264850  subf r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 830F7A58: 0CC80000  twi 6, r8, 0
	// 830F7A5C: 7D085078  andc r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 & !ctx.r[10].u64;
	// 830F7A60: 1D490014  mulli r10, r9, 0x14
	ctx.r[10].s64 = ctx.r[9].s64 * 20;
	// 830F7A64: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830F7A68: 0CA8FFFF  twi 5, r8, -1
	// 830F7A6C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F7A70: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 830F7A74: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830F7A78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F7A7C: 4199000C  bgt cr6, 0x830f7a88
	if ctx.cr[6].gt {
	pc = 0x830F7A88; continue 'dispatch;
	}
	// 830F7A80: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F7A84: 4080FF64  bge 0x830f79e8
	if !ctx.cr[0].lt {
	pc = 0x830F79E8; continue 'dispatch;
	}
	// 830F7A88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7A8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7A90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7AA0 size=184
    let mut pc: u32 = 0x830F7AA0;
    'dispatch: loop {
        match pc {
            0x830F7AA0 => {
    //   block [0x830F7AA0..0x830F7B58)
	// 830F7AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F7AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7AB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F7ABC: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7AC0: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7AC4: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 830F7AC8: 409A0018  bne cr6, 0x830f7ae0
	if !ctx.cr[6].eq {
	pc = 0x830F7AE0; continue 'dispatch;
	}
	// 830F7ACC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F7AD0: 409A0018  bne cr6, 0x830f7ae8
	if !ctx.cr[6].eq {
	pc = 0x830F7AE8; continue 'dispatch;
	}
	// 830F7AD4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F7AD8: 60634001  ori r3, r3, 0x4001
	ctx.r[3].u64 = ctx.r[3].u64 | 16385;
	// 830F7ADC: 48000064  b 0x830f7b40
	pc = 0x830F7B40; continue 'dispatch;
	// 830F7AE0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F7AE4: 419A000C  beq cr6, 0x830f7af0
	if ctx.cr[6].eq {
	pc = 0x830F7AF0; continue 'dispatch;
	}
	// 830F7AE8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830F7AEC: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830F7AF0: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F7AF4: 4BFE7775  bl 0x830df268
	ctx.lr = 0x830F7AF8;
	sub_830DF268(ctx, base);
	// 830F7AF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830F7AFC: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7B00: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F7B04: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F7B08: 419A0018  beq cr6, 0x830f7b20
	if ctx.cr[6].eq {
	pc = 0x830F7B20; continue 'dispatch;
	}
	// 830F7B0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F7B10: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830F7B14: 51446EB6  rlwimi r4, r10, 0xd, 0x1a, 0x1b
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(13) as u64) & 0x0000000000000030) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFFFCF);
	// 830F7B18: 51446CA4  rlwimi r4, r10, 0xd, 0x12, 0x12
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(13) as u64) & 0x0000000000002000) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFDFFF);
	// 830F7B1C: 48000014  b 0x830f7b30
	pc = 0x830F7B30; continue 'dispatch;
	// 830F7B20: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 830F7B24: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7B28: 514426B6  rlwimi r4, r10, 4, 0x1a, 0x1b
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(4) as u64) & 0x0000000000000030) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFFFCF);
	// 830F7B2C: 514424A4  rlwimi r4, r10, 4, 0x12, 0x12
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(4) as u64) & 0x0000000000002000) | (ctx.r[4].u64 & 0xFFFFFFFFFFFFDFFF);
	// 830F7B30: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830F7B34: 4BFE76DD  bl 0x830df210
	ctx.lr = 0x830F7B38;
	sub_830DF210(ctx, base);
	// 830F7B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7B3C: 4BFFC95D  bl 0x830f4498
	ctx.lr = 0x830F7B40;
	sub_830F4498(ctx, base);
	// 830F7B40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7B44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7B48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7B4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F7B50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7B58 size=100
    let mut pc: u32 = 0x830F7B58;
    'dispatch: loop {
        match pc {
            0x830F7B58 => {
    //   block [0x830F7B58..0x830F7BBC)
	// 830F7B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7B60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7B64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7B6C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830F7B70: 419A0024  beq cr6, 0x830f7b94
	if ctx.cr[6].eq {
	pc = 0x830F7B94; continue 'dispatch;
	}
	// 830F7B74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F7B78: 4BFF61B1  bl 0x830edd28
	ctx.lr = 0x830F7B7C;
	sub_830EDD28(ctx, base);
	// 830F7B7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F7B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7B84: 4BFFFF1D  bl 0x830f7aa0
	ctx.lr = 0x830F7B88;
	sub_830F7AA0(ctx, base);
	// 830F7B88: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7B8C: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830F7B90: 4800000C  b 0x830f7b9c
	pc = 0x830F7B9C; continue 'dispatch;
	// 830F7B94: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7B98: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7B9C: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830F7BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7BA4: 4BFFC8F5  bl 0x830f4498
	ctx.lr = 0x830F7BA8;
	sub_830F4498(ctx, base);
	// 830F7BA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F7BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7BB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7BC0 size=108
    let mut pc: u32 = 0x830F7BC0;
    'dispatch: loop {
        match pc {
            0x830F7BC0 => {
    //   block [0x830F7BC0..0x830F7C2C)
	// 830F7BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7BC4: 480B05A9  bl 0x831a816c
	ctx.lr = 0x830F7BC8;
	sub_831A8130(ctx, base);
	// 830F7BC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7BCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7BD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F7BD4: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830F7BD8: 4BFE5901  bl 0x830dd4d8
	ctx.lr = 0x830F7BDC;
	sub_830DD4D8(ctx, base);
	// 830F7BDC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830F7BE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F7BE4: 93BF0068  stw r29, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 830F7BE8: 419A0034  beq cr6, 0x830f7c1c
	if ctx.cr[6].eq {
	pc = 0x830F7C1C; continue 'dispatch;
	}
	// 830F7BEC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 830F7BF0: 4BFE58C1  bl 0x830dd4b0
	ctx.lr = 0x830F7BF4;
	sub_830DD4B0(ctx, base);
	// 830F7BF4: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 830F7BF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F7BFC: 40820010  bne 0x830f7c0c
	if !ctx.cr[0].eq {
	pc = 0x830F7C0C; continue 'dispatch;
	}
	// 830F7C00: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F7C04: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830F7C08: 4800001C  b 0x830f7c24
	pc = 0x830F7C24; continue 'dispatch;
	// 830F7C0C: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7C10: B1630000  sth r11, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830F7C14: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830F7C18: B3AB0002  sth r29, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[29].u16 ) };
	// 830F7C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7C20: 4BFFC879  bl 0x830f4498
	ctx.lr = 0x830F7C24;
	sub_830F4498(ctx, base);
	// 830F7C24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7C28: 480B0594  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830F7C30 size=68
    let mut pc: u32 = 0x830F7C30;
    'dispatch: loop {
        match pc {
            0x830F7C30 => {
    //   block [0x830F7C30..0x830F7C74)
	// 830F7C30: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 830F7C34: 90830090  stw r4, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[4].u32 ) };
	// 830F7C38: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F7C3C: 40980014  bge cr6, 0x830f7c50
	if !ctx.cr[6].lt {
	pc = 0x830F7C50; continue 'dispatch;
	}
	// 830F7C40: 8163005C  lwz r11, 0x5c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F7C44: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830F7C48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830F7C4C: 7D2B532E  sthx r9, r11, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u16) };
	// 830F7C50: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F7C54: 8123006C  lwz r9, 0x6c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F7C58: 81430090  lwz r10, 0x90(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 830F7C5C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830F7C60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830F7C64: 4098000C  bge cr6, 0x830f7c70
	if !ctx.cr[6].lt {
	pc = 0x830F7C70; continue 'dispatch;
	}
	// 830F7C68: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830F7C6C: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830F7C70: 4BFFC828  b 0x830f4498
	sub_830F4498(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7C78 size=160
    let mut pc: u32 = 0x830F7C78;
    'dispatch: loop {
        match pc {
            0x830F7C78 => {
    //   block [0x830F7C78..0x830F7D18)
	// 830F7C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F7C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7C88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7C90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F7C94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7C98: 4BFE8F09  bl 0x830e0ba0
	ctx.lr = 0x830F7C9C;
	sub_830E0BA0(ctx, base);
	// 830F7C9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F7CA0: 41820060  beq 0x830f7d00
	if ctx.cr[0].eq {
	pc = 0x830F7D00; continue 'dispatch;
	}
	// 830F7CA4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F7CA8: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7CAC: 396BFFFB  addi r11, r11, -5
	ctx.r[11].s64 = ctx.r[11].s64 + -5;
	// 830F7CB0: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 830F7CB4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830F7CB8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F7CBC: 409A000C  bne cr6, 0x830f7cc8
	if !ctx.cr[6].eq {
	pc = 0x830F7CC8; continue 'dispatch;
	}
	// 830F7CC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F7CC4: 4800000C  b 0x830f7cd0
	pc = 0x830F7CD0; continue 'dispatch;
	// 830F7CC8: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F7CCC: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 830F7CD0: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830F7CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7CD8: 4BFEE539  bl 0x830e6210
	ctx.lr = 0x830F7CDC;
	sub_830E6210(ctx, base);
	// 830F7CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7CE0: 4BFFC7B9  bl 0x830f4498
	ctx.lr = 0x830F7CE4;
	sub_830F4498(ctx, base);
	// 830F7CE4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F7CE8: 419A0018  beq cr6, 0x830f7d00
	if ctx.cr[6].eq {
	pc = 0x830F7D00; continue 'dispatch;
	}
	// 830F7CEC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830F7CF0: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 830F7CF4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F7CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7CFC: 4BFF60AD  bl 0x830edda8
	ctx.lr = 0x830F7D00;
	sub_830EDDA8(ctx, base);
	// 830F7D00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7D0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F7D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F7D18 size=160
    let mut pc: u32 = 0x830F7D18;
    'dispatch: loop {
        match pc {
            0x830F7D18 => {
    //   block [0x830F7D18..0x830F7DB8)
	// 830F7D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F7D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7D30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F7D34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7D38: 4BFE8E69  bl 0x830e0ba0
	ctx.lr = 0x830F7D3C;
	sub_830E0BA0(ctx, base);
	// 830F7D3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F7D40: 41820060  beq 0x830f7da0
	if ctx.cr[0].eq {
	pc = 0x830F7DA0; continue 'dispatch;
	}
	// 830F7D44: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F7D48: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7D4C: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 830F7D50: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 830F7D54: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830F7D58: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F7D5C: 409A000C  bne cr6, 0x830f7d68
	if !ctx.cr[6].eq {
	pc = 0x830F7D68; continue 'dispatch;
	}
	// 830F7D60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F7D64: 4800000C  b 0x830f7d70
	pc = 0x830F7D70; continue 'dispatch;
	// 830F7D68: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F7D6C: 396BFFFB  addi r11, r11, -5
	ctx.r[11].s64 = ctx.r[11].s64 + -5;
	// 830F7D70: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830F7D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7D78: 4BFEE499  bl 0x830e6210
	ctx.lr = 0x830F7D7C;
	sub_830E6210(ctx, base);
	// 830F7D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7D80: 4BFFC719  bl 0x830f4498
	ctx.lr = 0x830F7D84;
	sub_830F4498(ctx, base);
	// 830F7D84: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F7D88: 419A0018  beq cr6, 0x830f7da0
	if ctx.cr[6].eq {
	pc = 0x830F7DA0; continue 'dispatch;
	}
	// 830F7D8C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830F7D90: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 830F7D94: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830F7D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7D9C: 4BFF600D  bl 0x830edda8
	ctx.lr = 0x830F7DA0;
	sub_830EDDA8(ctx, base);
	// 830F7DA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7DA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7DA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7DAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F7DB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F7DB8 size=464
    let mut pc: u32 = 0x830F7DB8;
    'dispatch: loop {
        match pc {
            0x830F7DB8 => {
    //   block [0x830F7DB8..0x830F7F88)
	// 830F7DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7DC4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830F7DC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7DCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7DD0: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F7DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F7DD8: 419A0190  beq cr6, 0x830f7f68
	if ctx.cr[6].eq {
	pc = 0x830F7F68; continue 'dispatch;
	}
	// 830F7DDC: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7DE0: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F7DE4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F7DE8: 409A0180  bne cr6, 0x830f7f68
	if !ctx.cr[6].eq {
	pc = 0x830F7F68; continue 'dispatch;
	}
	// 830F7DEC: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7DF0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F7DF4: 409A0174  bne cr6, 0x830f7f68
	if !ctx.cr[6].eq {
	pc = 0x830F7F68; continue 'dispatch;
	}
	// 830F7DF8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830F7DFC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F7E00: 41980010  blt cr6, 0x830f7e10
	if ctx.cr[6].lt {
	pc = 0x830F7E10; continue 'dispatch;
	}
	// 830F7E04: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F7E08: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830F7E0C: 48000164  b 0x830f7f70
	pc = 0x830F7F70; continue 'dispatch;
	// 830F7E10: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F7E14: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830F7E18: 7D4B21D6  mullw r10, r11, r4
	ctx.r[10].s64 = (ctx.r[11].s32 as i64) * (ctx.r[4].s32 as i64);
	// 830F7E1C: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 830F7E20: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830F7E24: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F7E28: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830F7E2C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830F7E30: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F7E34: 419A009C  beq cr6, 0x830f7ed0
	if ctx.cr[6].eq {
	pc = 0x830F7ED0; continue 'dispatch;
	}
	// 830F7E38: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F7E3C: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830F7E40: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F7E44: C01F00AC  lfs f0, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7E48: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 830F7E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7E50: 4098003C  bge cr6, 0x830f7e8c
	if !ctx.cr[6].lt {
	pc = 0x830F7E8C; continue 'dispatch;
	}
	// 830F7E54: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F7E58: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F7E5C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F7E60: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 830F7E64: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F7E68: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830F7E6C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F7E70: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 830F7E74: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F7E78: 4BFF5F31  bl 0x830edda8
	ctx.lr = 0x830F7E7C;
	sub_830EDDA8(ctx, base);
	// 830F7E7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7E80: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830F7E84: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830F7E88: 48000034  b 0x830f7ebc
	pc = 0x830F7EBC; continue 'dispatch;
	// 830F7E8C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F7E90: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830F7E94: 915F003C  stw r10, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 830F7E98: C9A10050  lfd f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F7E9C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F7EA0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F7EA4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830F7EA8: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F7EAC: 4BFF5EFD  bl 0x830edda8
	ctx.lr = 0x830F7EB0;
	sub_830EDDA8(ctx, base);
	// 830F7EB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7EB4: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830F7EB8: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830F7EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7EC0: 4BFF5EE9  bl 0x830edda8
	ctx.lr = 0x830F7EC4;
	sub_830EDDA8(ctx, base);
	// 830F7EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7EC8: 4BFEE429  bl 0x830e62f0
	ctx.lr = 0x830F7ECC;
	sub_830E62F0(ctx, base);
	// 830F7ECC: 48000090  b 0x830f7f5c
	pc = 0x830F7F5C; continue 'dispatch;
	// 830F7ED0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830F7ED4: D01F009C  stfs f0, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F7ED8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830F7EDC: C1ABB59C  lfs f13, -0x4a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F7EE0: C3EA9F7C  lfs f31, -0x6084(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F7EE4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F7EE8: 40990010  ble cr6, 0x830f7ef8
	if !ctx.cr[6].gt {
	pc = 0x830F7EF8; continue 'dispatch;
	}
	// 830F7EEC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830F7EF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7EF4: 41980008  blt cr6, 0x830f7efc
	if ctx.cr[6].lt {
	pc = 0x830F7EFC; continue 'dispatch;
	}
	// 830F7EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F7EFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F7F00: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830F7F04: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F7F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7F0C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F7F10: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830F7F14: 4BFF5E95  bl 0x830edda8
	ctx.lr = 0x830F7F18;
	sub_830EDDA8(ctx, base);
	// 830F7F18: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7F1C: ED80F828  fsubs f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 830F7F20: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F7F24: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830F7F28: 40990014  ble cr6, 0x830f7f3c
	if !ctx.cr[6].gt {
	pc = 0x830F7F3C; continue 'dispatch;
	}
	// 830F7F2C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830F7F30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F7F34: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F7F38: 41980008  blt cr6, 0x830f7f40
	if ctx.cr[6].lt {
	pc = 0x830F7F40; continue 'dispatch;
	}
	// 830F7F3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F7F40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F7F44: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830F7F48: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F7F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7F50: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F7F54: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830F7F58: 4BFF5E51  bl 0x830edda8
	ctx.lr = 0x830F7F5C;
	sub_830EDDA8(ctx, base);
	// 830F7F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F7F60: 4BFFC539  bl 0x830f4498
	ctx.lr = 0x830F7F64;
	sub_830F4498(ctx, base);
	// 830F7F64: 4800000C  b 0x830f7f70
	pc = 0x830F7F70; continue 'dispatch;
	// 830F7F68: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F7F6C: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830F7F70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F7F74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F7F78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F7F7C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F7F80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F7F84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F7F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F7F88 size=476
    let mut pc: u32 = 0x830F7F88;
    'dispatch: loop {
        match pc {
            0x830F7F88 => {
    //   block [0x830F7F88..0x830F8164)
	// 830F7F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F7F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F7F90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F7F94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F7F98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F7F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F7FA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F7FA4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F7FA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F7FAC: 419A0198  beq cr6, 0x830f8144
	if ctx.cr[6].eq {
	pc = 0x830F8144; continue 'dispatch;
	}
	// 830F7FB0: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F7FB4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F7FB8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F7FBC: 409A0188  bne cr6, 0x830f8144
	if !ctx.cr[6].eq {
	pc = 0x830F8144; continue 'dispatch;
	}
	// 830F7FC0: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F7FC4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F7FC8: 409A017C  bne cr6, 0x830f8144
	if !ctx.cr[6].eq {
	pc = 0x830F8144; continue 'dispatch;
	}
	// 830F7FCC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F7FD0: 4BFE8BD1  bl 0x830e0ba0
	ctx.lr = 0x830F7FD4;
	sub_830E0BA0(ctx, base);
	// 830F7FD4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F7FD8: 4182016C  beq 0x830f8144
	if ctx.cr[0].eq {
	pc = 0x830F8144; continue 'dispatch;
	}
	// 830F7FDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830F7FE0: C01F009C  lfs f0, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F7FE4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830F7FE8: C16BB59C  lfs f11, -0x4a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19044 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F7FEC: C14A9F7C  lfs f10, -0x6084(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830F7FF0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 830F7FF4: 40990010  ble cr6, 0x830f8004
	if !ctx.cr[6].gt {
	pc = 0x830F8004; continue 'dispatch;
	}
	// 830F7FF8: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 830F7FFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8000: 41980008  blt cr6, 0x830f8008
	if ctx.cr[6].lt {
	pc = 0x830F8008; continue 'dispatch;
	}
	// 830F8004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F8008: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F800C: 4082012C  bne 0x830f8138
	if !ctx.cr[0].eq {
	pc = 0x830F8138; continue 'dispatch;
	}
	// 830F8010: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F8014: 409A0064  bne cr6, 0x830f8078
	if !ctx.cr[6].eq {
	pc = 0x830F8078; continue 'dispatch;
	}
	// 830F8018: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F801C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F8020: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830F8024: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F8028: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F802C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F8030: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F8034: FD206818  frsp f9, f13
	ctx.f[9].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F8038: C1A99534  lfs f13, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F803C: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F8040: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 830F8044: FC00602E  fsel f0, f0, f0, f12
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 830F8048: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F804C: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F8050: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 830F8054: 40990010  ble cr6, 0x830f8064
	if !ctx.cr[6].gt {
	pc = 0x830F8064; continue 'dispatch;
	}
	// 830F8058: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 830F805C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8060: 41980008  blt cr6, 0x830f8068
	if ctx.cr[6].lt {
	pc = 0x830F8068; continue 'dispatch;
	}
	// 830F8064: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F8068: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F806C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F8070: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F8074: 48000094  b 0x830f8108
	pc = 0x830F8108; continue 'dispatch;
	// 830F8078: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F807C: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F8080: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F8084: 409A0044  bne cr6, 0x830f80c8
	if !ctx.cr[6].eq {
	pc = 0x830F80C8; continue 'dispatch;
	}
	// 830F8088: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F808C: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F8090: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F8094: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F8098: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F809C: 41980060  blt cr6, 0x830f80fc
	if ctx.cr[6].lt {
	pc = 0x830F80FC; continue 'dispatch;
	}
	// 830F80A0: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F80A4: C01F00AC  lfs f0, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F80A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F80AC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F80B0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F80B4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F80B8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830F80BC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 830F80C0: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F80C4: 48000038  b 0x830f80fc
	pc = 0x830F80FC; continue 'dispatch;
	// 830F80C8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F80CC: C1BF00A0  lfs f13, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F80D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830F80D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F80D8: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F80DC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F80E0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830F80E4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830F80E8: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830F80EC: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 830F80F0: D19F00A8  stfs f12, 0xa8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F80F4: FC0D036E  fsel f0, f13, f13, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 830F80F8: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F80FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8100: 4BFEE1F1  bl 0x830e62f0
	ctx.lr = 0x830F8104;
	sub_830E62F0(ctx, base);
	// 830F8104: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830F8108: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830F810C: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830F8110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8114: 4BFF5C95  bl 0x830edda8
	ctx.lr = 0x830F8118;
	sub_830EDDA8(ctx, base);
	// 830F8118: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F811C: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830F8120: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830F8124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8128: 4BFF5C81  bl 0x830edda8
	ctx.lr = 0x830F812C;
	sub_830EDDA8(ctx, base);
	// 830F812C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8130: 4BFFC369  bl 0x830f4498
	ctx.lr = 0x830F8134;
	sub_830F4498(ctx, base);
	// 830F8134: 48000018  b 0x830f814c
	pc = 0x830F814C; continue 'dispatch;
	// 830F8138: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F813C: 60630019  ori r3, r3, 0x19
	ctx.r[3].u64 = ctx.r[3].u64 | 25;
	// 830F8140: 4800000C  b 0x830f814c
	pc = 0x830F814C; continue 'dispatch;
	// 830F8144: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F8148: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830F814C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F8150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F8154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F8158: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F815C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F8160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F8168 size=476
    let mut pc: u32 = 0x830F8168;
    'dispatch: loop {
        match pc {
            0x830F8168 => {
    //   block [0x830F8168..0x830F8344)
	// 830F8168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F816C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F8170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F8174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F8178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F817C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8180: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F8184: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F8188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F818C: 419A0198  beq cr6, 0x830f8324
	if ctx.cr[6].eq {
	pc = 0x830F8324; continue 'dispatch;
	}
	// 830F8190: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F8194: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F8198: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F819C: 409A0188  bne cr6, 0x830f8324
	if !ctx.cr[6].eq {
	pc = 0x830F8324; continue 'dispatch;
	}
	// 830F81A0: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F81A4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F81A8: 409A017C  bne cr6, 0x830f8324
	if !ctx.cr[6].eq {
	pc = 0x830F8324; continue 'dispatch;
	}
	// 830F81AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F81B0: 4BFE89F1  bl 0x830e0ba0
	ctx.lr = 0x830F81B4;
	sub_830E0BA0(ctx, base);
	// 830F81B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F81B8: 4182016C  beq 0x830f8324
	if ctx.cr[0].eq {
	pc = 0x830F8324; continue 'dispatch;
	}
	// 830F81BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830F81C0: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F81C4: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F81C8: C16B9F7C  lfs f11, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F81CC: ED805828  fsubs f12, f0, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 830F81D0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830F81D4: 40990014  ble cr6, 0x830f81e8
	if !ctx.cr[6].gt {
	pc = 0x830F81E8; continue 'dispatch;
	}
	// 830F81D8: ED40582A  fadds f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 830F81DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F81E0: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 830F81E4: 41980008  blt cr6, 0x830f81ec
	if ctx.cr[6].lt {
	pc = 0x830F81EC; continue 'dispatch;
	}
	// 830F81E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F81EC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F81F0: 40820128  bne 0x830f8318
	if !ctx.cr[0].eq {
	pc = 0x830F8318; continue 'dispatch;
	}
	// 830F81F4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F81F8: 409A0068  bne cr6, 0x830f8260
	if !ctx.cr[6].eq {
	pc = 0x830F8260; continue 'dispatch;
	}
	// 830F81FC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F8200: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F8204: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F8208: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 830F820C: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 830F8210: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 830F8214: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F8218: 40980008  bge cr6, 0x830f8220
	if !ctx.cr[6].lt {
	pc = 0x830F8220; continue 'dispatch;
	}
	// 830F821C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 830F8220: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F8224: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830F8228: D1BF00A0  stfs f13, 0xa0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F822C: D1BF009C  stfs f13, 0x9c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830F8230: C18B08A8  lfs f12, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F8234: D19F00A8  stfs f12, 0xa8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F8238: 40990014  ble cr6, 0x830f824c
	if !ctx.cr[6].gt {
	pc = 0x830F824C; continue 'dispatch;
	}
	// 830F823C: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 830F8240: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8244: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F8248: 41980008  blt cr6, 0x830f8250
	if ctx.cr[6].lt {
	pc = 0x830F8250; continue 'dispatch;
	}
	// 830F824C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F8250: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830F8254: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830F8258: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830F825C: 4800008C  b 0x830f82e8
	pc = 0x830F82E8; continue 'dispatch;
	// 830F8260: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F8264: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F8268: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F826C: 409A0040  bne cr6, 0x830f82ac
	if !ctx.cr[6].eq {
	pc = 0x830F82AC; continue 'dispatch;
	}
	// 830F8270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F8274: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F8278: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F827C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F8280: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F8284: 41990058  bgt cr6, 0x830f82dc
	if ctx.cr[6].gt {
	pc = 0x830F82DC; continue 'dispatch;
	}
	// 830F8288: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F828C: C01F00AC  lfs f0, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F8290: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F8294: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F8298: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830F829C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830F82A0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830F82A4: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F82A8: 48000034  b 0x830f82dc
	pc = 0x830F82DC; continue 'dispatch;
	// 830F82AC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830F82B0: C1BF00A0  lfs f13, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F82B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830F82B8: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830F82BC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830F82C0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830F82C4: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830F82C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830F82CC: 41980008  blt cr6, 0x830f82d4
	if ctx.cr[6].lt {
	pc = 0x830F82D4; continue 'dispatch;
	}
	// 830F82D0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830F82D4: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830F82D8: D19F00A8  stfs f12, 0xa8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830F82DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F82E0: 4BFEE011  bl 0x830e62f0
	ctx.lr = 0x830F82E4;
	sub_830E62F0(ctx, base);
	// 830F82E4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830F82E8: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830F82EC: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830F82F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F82F4: 4BFF5AB5  bl 0x830edda8
	ctx.lr = 0x830F82F8;
	sub_830EDDA8(ctx, base);
	// 830F82F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F82FC: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830F8300: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830F8304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8308: 4BFF5AA1  bl 0x830edda8
	ctx.lr = 0x830F830C;
	sub_830EDDA8(ctx, base);
	// 830F830C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8310: 4BFFC189  bl 0x830f4498
	ctx.lr = 0x830F8314;
	sub_830F4498(ctx, base);
	// 830F8314: 48000018  b 0x830f832c
	pc = 0x830F832C; continue 'dispatch;
	// 830F8318: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F831C: 60630019  ori r3, r3, 0x19
	ctx.r[3].u64 = ctx.r[3].u64 | 25;
	// 830F8320: 4800000C  b 0x830f832c
	pc = 0x830F832C; continue 'dispatch;
	// 830F8324: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F8328: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830F832C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F8330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F8334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F8338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F833C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F8340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8348 size=224
    let mut pc: u32 = 0x830F8348;
    'dispatch: loop {
        match pc {
            0x830F8348 => {
    //   block [0x830F8348..0x830F8428)
	// 830F8348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F834C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F8350: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F8354: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F8358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F835C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8360: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F8364: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F8368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F836C: 419A009C  beq cr6, 0x830f8408
	if ctx.cr[6].eq {
	pc = 0x830F8408; continue 'dispatch;
	}
	// 830F8370: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8374: 4BFE882D  bl 0x830e0ba0
	ctx.lr = 0x830F8378;
	sub_830E0BA0(ctx, base);
	// 830F8378: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F837C: 4182008C  beq 0x830f8408
	if ctx.cr[0].eq {
	pc = 0x830F8408; continue 'dispatch;
	}
	// 830F8380: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F8384: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830F8388: 409A0010  bne cr6, 0x830f8398
	if !ctx.cr[6].eq {
	pc = 0x830F8398; continue 'dispatch;
	}
	// 830F838C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F8390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8394: 419A0074  beq cr6, 0x830f8408
	if ctx.cr[6].eq {
	pc = 0x830F8408; continue 'dispatch;
	}
	// 830F8398: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F839C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F83A0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 830F83A4: 409A002C  bne cr6, 0x830f83d0
	if !ctx.cr[6].eq {
	pc = 0x830F83D0; continue 'dispatch;
	}
	// 830F83A8: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F83AC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F83B0: 419A0058  beq cr6, 0x830f8408
	if ctx.cr[6].eq {
	pc = 0x830F8408; continue 'dispatch;
	}
	// 830F83B4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F83B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F83BC: 4099004C  ble cr6, 0x830f8408
	if !ctx.cr[6].gt {
	pc = 0x830F8408; continue 'dispatch;
	}
	// 830F83C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F83C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F83C8: 4BFFF8B1  bl 0x830f7c78
	ctx.lr = 0x830F83CC;
	sub_830F7C78(ctx, base);
	// 830F83CC: 48000030  b 0x830f83fc
	pc = 0x830F83FC; continue 'dispatch;
	// 830F83D0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F83D4: 409A001C  bne cr6, 0x830f83f0
	if !ctx.cr[6].eq {
	pc = 0x830F83F0; continue 'dispatch;
	}
	// 830F83D8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F83DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F83E0: 40990010  ble cr6, 0x830f83f0
	if !ctx.cr[6].gt {
	pc = 0x830F83F0; continue 'dispatch;
	}
	// 830F83E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F83E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F83EC: 4BFFF88D  bl 0x830f7c78
	ctx.lr = 0x830F83F0;
	sub_830F7C78(ctx, base);
	// 830F83F0: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F83F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830F83F8: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830F83FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8400: 4BFFC099  bl 0x830f4498
	ctx.lr = 0x830F8404;
	sub_830F4498(ctx, base);
	// 830F8404: 4800000C  b 0x830f8410
	pc = 0x830F8410; continue 'dispatch;
	// 830F8408: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F840C: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830F8410: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F8414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F8418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F841C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F8420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F8424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F8428 size=336
    let mut pc: u32 = 0x830F8428;
    'dispatch: loop {
        match pc {
            0x830F8428 => {
    //   block [0x830F8428..0x830F8578)
	// 830F8428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F842C: 480AFD3D  bl 0x831a8168
	ctx.lr = 0x830F8430;
	sub_831A8130(ctx, base);
	// 830F8430: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8438: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F843C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F8440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8444: 419A00C0  beq cr6, 0x830f8504
	if ctx.cr[6].eq {
	pc = 0x830F8504; continue 'dispatch;
	}
	// 830F8448: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F844C: 4BFE8755  bl 0x830e0ba0
	ctx.lr = 0x830F8450;
	sub_830E0BA0(ctx, base);
	// 830F8450: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8454: 418200B0  beq 0x830f8504
	if ctx.cr[0].eq {
	pc = 0x830F8504; continue 'dispatch;
	}
	// 830F8458: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F845C: 480B0C6D  bl 0x831a90c8
	ctx.lr = 0x830F8460;
	sub_831A90C8(ctx, base);
	// 830F8460: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F8464: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F8468: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F846C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F8470: 40980094  bge cr6, 0x830f8504
	if !ctx.cr[6].lt {
	pc = 0x830F8504; continue 'dispatch;
	}
	// 830F8474: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830F8478: C01F00C4  lfs f0, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F847C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830F8480: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830F8484: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F8488: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F848C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830F8490: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F8494: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F8498: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F849C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830F84A0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830F84A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F84A8: 480B0C21  bl 0x831a90c8
	ctx.lr = 0x830F84AC;
	sub_831A90C8(ctx, base);
	// 830F84AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F84B0: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F84B4: 4BFE6CF5  bl 0x830df1a8
	ctx.lr = 0x830F84B8;
	sub_830DF1A8(ctx, base);
	// 830F84B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F84BC: 41820048  beq 0x830f8504
	if ctx.cr[0].eq {
	pc = 0x830F8504; continue 'dispatch;
	}
	// 830F84C0: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F84C4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F84C8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F84CC: 409A0048  bne cr6, 0x830f8514
	if !ctx.cr[6].eq {
	pc = 0x830F8514; continue 'dispatch;
	}
	// 830F84D0: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F84D4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F84D8: 419A002C  beq cr6, 0x830f8504
	if ctx.cr[6].eq {
	pc = 0x830F8504; continue 'dispatch;
	}
	// 830F84DC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830F84E0: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F84E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F84E8: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F84EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F84F0: 480139D9  bl 0x8310bec8
	ctx.lr = 0x830F84F4;
	sub_8310BEC8(ctx, base);
	// 830F84F4: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F84F8: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F84FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F8500: 41990060  bgt cr6, 0x830f8560
	if ctx.cr[6].gt {
	pc = 0x830F8560; continue 'dispatch;
	}
	// 830F8504: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F8508: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830F850C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F8510: 480AFCA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 830F8514: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F8518: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F851C: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 830F8520: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830F8524: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F8528: 4098000C  bge cr6, 0x830f8534
	if !ctx.cr[6].lt {
	pc = 0x830F8534; continue 'dispatch;
	}
	// 830F852C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F8530: 4800000C  b 0x830f853c
	pc = 0x830F853C; continue 'dispatch;
	// 830F8534: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F8538: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 830F853C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830F8540: 80FF0080  lwz r7, 0x80(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 830F8544: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F8548: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F854C: 4801397D  bl 0x8310bec8
	ctx.lr = 0x830F8550;
	sub_8310BEC8(ctx, base);
	// 830F8550: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F8554: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F8558: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830F855C: 40990010  ble cr6, 0x830f856c
	if !ctx.cr[6].gt {
	pc = 0x830F856C; continue 'dispatch;
	}
	// 830F8560: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F8564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8568: 4BFFF7B1  bl 0x830f7d18
	ctx.lr = 0x830F856C;
	sub_830F7D18(ctx, base);
	// 830F856C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8570: 4BFFBF29  bl 0x830f4498
	ctx.lr = 0x830F8574;
	sub_830F4498(ctx, base);
	// 830F8574: 4BFFFF98  b 0x830f850c
	pc = 0x830F850C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8578 size=176
    let mut pc: u32 = 0x830F8578;
    'dispatch: loop {
        match pc {
            0x830F8578 => {
    //   block [0x830F8578..0x830F8628)
	// 830F8578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F857C: 480AFBE9  bl 0x831a8164
	ctx.lr = 0x830F8580;
	sub_831A8130(ctx, base);
	// 830F8580: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8584: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830F8588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F858C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830F8590: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F8594: 409A0010  bne cr6, 0x830f85a4
	if !ctx.cr[6].eq {
	pc = 0x830F85A4; continue 'dispatch;
	}
	// 830F8598: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830F859C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830F85A0: 48000054  b 0x830f85f4
	pc = 0x830F85F4; continue 'dispatch;
	// 830F85A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F85A8: 480B0B21  bl 0x831a90c8
	ctx.lr = 0x830F85AC;
	sub_831A90C8(ctx, base);
	// 830F85AC: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830F85B0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F85B4: 40990010  ble cr6, 0x830f85c4
	if !ctx.cr[6].gt {
	pc = 0x830F85C4; continue 'dispatch;
	}
	// 830F85B8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F85BC: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830F85C0: 48000060  b 0x830f8620
	pc = 0x830F8620; continue 'dispatch;
	// 830F85C4: 3BC30032  addi r30, r3, 0x32
	ctx.r[30].s64 = ctx.r[3].s64 + 50;
	// 830F85C8: 57C3103A  slwi r3, r30, 2
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830F85CC: 4BFE4EE5  bl 0x830dd4b0
	ctx.lr = 0x830F85D0;
	sub_830DD4B0(ctx, base);
	// 830F85D0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F85D4: 40820010  bne 0x830f85e4
	if !ctx.cr[0].eq {
	pc = 0x830F85E4; continue 'dispatch;
	}
	// 830F85D8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F85DC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830F85E0: 48000040  b 0x830f8620
	pc = 0x830F8620; continue 'dispatch;
	// 830F85E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830F85E8: 57C4083C  slwi r4, r30, 1
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830F85EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F85F0: 480B98C9  bl 0x831b1eb8
	ctx.lr = 0x830F85F4;
	sub_831B1EB8(ctx, base);
	// 830F85F4: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F85F8: 4BFE4EE1  bl 0x830dd4d8
	ctx.lr = 0x830F85FC;
	sub_830DD4D8(ctx, base);
	// 830F85FC: 93BF005C  stw r29, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 830F8600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8604: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 830F8608: 937F006C  stw r27, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 830F860C: 937F0070  stw r27, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 830F8610: 937F0074  stw r27, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 830F8614: 4BFFC1A5  bl 0x830f47b8
	ctx.lr = 0x830F8618;
	sub_830F47B8(ctx, base);
	// 830F8618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F861C: 4BFFBE7D  bl 0x830f4498
	ctx.lr = 0x830F8620;
	sub_830F4498(ctx, base);
	// 830F8620: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F8624: 480AFB90  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F8628 size=416
    let mut pc: u32 = 0x830F8628;
    'dispatch: loop {
        match pc {
            0x830F8628 => {
    //   block [0x830F8628..0x830F87C8)
	// 830F8628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F862C: 480AFB41  bl 0x831a816c
	ctx.lr = 0x830F8630;
	sub_831A8130(ctx, base);
	// 830F8630: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830F8634: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830F8638: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F863C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8640: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F8644: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F864C: 419A0094  beq cr6, 0x830f86e0
	if ctx.cr[6].eq {
	pc = 0x830F86E0; continue 'dispatch;
	}
	// 830F8650: 4BFE8431  bl 0x830e0a80
	ctx.lr = 0x830F8654;
	sub_830E0A80(ctx, base);
	// 830F8654: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F8658: 409A0014  bne cr6, 0x830f866c
	if !ctx.cr[6].eq {
	pc = 0x830F866C; continue 'dispatch;
	}
	// 830F865C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F8660: 409A0080  bne cr6, 0x830f86e0
	if !ctx.cr[6].eq {
	pc = 0x830F86E0; continue 'dispatch;
	}
	// 830F8664: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F8668: 480000A0  b 0x830f8708
	pc = 0x830F8708; continue 'dispatch;
	// 830F866C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 830F8670: 409A0084  bne cr6, 0x830f86f4
	if !ctx.cr[6].eq {
	pc = 0x830F86F4; continue 'dispatch;
	}
	// 830F8674: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F8678: 419A0068  beq cr6, 0x830f86e0
	if ctx.cr[6].eq {
	pc = 0x830F86E0; continue 'dispatch;
	}
	// 830F867C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8680: 4BFD6591  bl 0x830cec10
	ctx.lr = 0x830F8684;
	sub_830CEC10(ctx, base);
	// 830F8684: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F8688: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F868C: 4BFFE09D  bl 0x830f6728
	ctx.lr = 0x830F8690;
	sub_830F6728(ctx, base);
	// 830F8690: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F8694: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8698: 4BFEF1E1  bl 0x830e7878
	ctx.lr = 0x830F869C;
	sub_830E7878(ctx, base);
	// 830F869C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830F86A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F86A4: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F86A8: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830F86AC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830F86B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830F86B4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830F86B8: C08B08A4  lfs f4, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830F86BC: FC602090  fmr f3, f4
	ctx.f[3].f64 = ctx.f[4].f64;
	// 830F86C0: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	// 830F86C4: FC202090  fmr f1, f4
	ctx.f[1].f64 = ctx.f[4].f64;
	// 830F86C8: 4BFEEB79  bl 0x830e7240
	ctx.lr = 0x830F86CC;
	sub_830E7240(ctx, base);
	// 830F86CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F86D0: 3BE100B0  addi r31, r1, 0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + 176;
	// 830F86D4: 4BFD653D  bl 0x830cec10
	ctx.lr = 0x830F86D8;
	sub_830CEC10(ctx, base);
	// 830F86D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F86DC: 4BFDD67D  bl 0x830d5d58
	ctx.lr = 0x830F86E0;
	sub_830D5D58(ctx, base);
	// 830F86E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F86E4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830F86E8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830F86EC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830F86F0: 480AFACC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 830F86F4: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 830F86F8: 409AFFE8  bne cr6, 0x830f86e0
	if !ctx.cr[6].eq {
	pc = 0x830F86E0; continue 'dispatch;
	}
	// 830F86FC: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830F8700: 557EDFFF  rlwinm. r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F8704: 4182FF78  beq 0x830f867c
	if ctx.cr[0].eq {
	pc = 0x830F867C; continue 'dispatch;
	}
	// 830F8708: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830F870C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830F8710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8714: 4BFF726D  bl 0x830ef980
	ctx.lr = 0x830F8718;
	sub_830EF980(ctx, base);
	// 830F8718: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F871C: 4180FFC8  blt 0x830f86e4
	if ctx.cr[0].lt {
	pc = 0x830F86E4; continue 'dispatch;
	}
	// 830F8720: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8724: C3C10064  lfs f30, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F8728: C3E10060  lfs f31, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F872C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830F8730: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830F8734: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8738: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830F873C: C041006C  lfs f2, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F8740: C0210068  lfs f1, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F8744: FC80F090  fmr f4, f30
	ctx.f[4].f64 = ctx.f[30].f64;
	// 830F8748: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F874C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 830F8750: 4BFEEAF1  bl 0x830e7240
	ctx.lr = 0x830F8754;
	sub_830E7240(ctx, base);
	// 830F8754: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8758: 3BA100B0  addi r29, r1, 0xb0
	ctx.r[29].s64 = ctx.r[1].s64 + 176;
	// 830F875C: 4BFD64B5  bl 0x830cec10
	ctx.lr = 0x830F8760;
	sub_830CEC10(ctx, base);
	// 830F8760: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F8764: 4BFDD5F5  bl 0x830d5d58
	ctx.lr = 0x830F8768;
	sub_830D5D58(ctx, base);
	// 830F8768: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830F876C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F8770: 419A001C  beq cr6, 0x830f878c
	if ctx.cr[6].eq {
	pc = 0x830F878C; continue 'dispatch;
	}
	// 830F8774: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F8778: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F877C: C3E10098  lfs f31, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830F8780: C3C1009C  lfs f30, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830F8784: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830F8788: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830F878C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830F8790: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8794: 4BFE730D  bl 0x830dfaa0
	ctx.lr = 0x830F8798;
	sub_830DFAA0(ctx, base);
	// 830F8798: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F879C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830F87A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830F87A4: 4BFE9265  bl 0x830e1a08
	ctx.lr = 0x830F87A8;
	sub_830E1A08(ctx, base);
	// 830F87A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F87AC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F87B0: 4BFEF1B1  bl 0x830e7960
	ctx.lr = 0x830F87B4;
	sub_830E7960(ctx, base);
	// 830F87B4: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 830F87B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F87BC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F87C0: 4BFEF0B9  bl 0x830e7878
	ctx.lr = 0x830F87C4;
	sub_830E7878(ctx, base);
	// 830F87C4: 4BFFFF1C  b 0x830f86e0
	pc = 0x830F86E0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F87C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F87C8 size=252
    let mut pc: u32 = 0x830F87C8;
    'dispatch: loop {
        match pc {
            0x830F87C8 => {
    //   block [0x830F87C8..0x830F88C4)
	// 830F87C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F87CC: 480AF999  bl 0x831a8164
	ctx.lr = 0x830F87D0;
	sub_831A8130(ctx, base);
	// 830F87D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F87D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F87D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F87DC: 83BF000C  lwz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F87E0: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F87E4: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F87E8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F87EC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F87F0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830F87F4: 4BFE6635  bl 0x830dee28
	ctx.lr = 0x830F87F8;
	sub_830DEE28(ctx, base);
	// 830F87F8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F87FC: 41820078  beq 0x830f8874
	if ctx.cr[0].eq {
	pc = 0x830F8874; continue 'dispatch;
	}
	// 830F8800: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830F8804: 419A0020  beq cr6, 0x830f8824
	if ctx.cr[6].eq {
	pc = 0x830F8824; continue 'dispatch;
	}
	// 830F8808: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830F880C: 419A0060  beq cr6, 0x830f886c
	if ctx.cr[6].eq {
	pc = 0x830F886C; continue 'dispatch;
	}
	// 830F8810: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F8814: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F8818: 4BFE7659  bl 0x830dfe70
	ctx.lr = 0x830F881C;
	sub_830DFE70(ctx, base);
	// 830F881C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8820: 4082004C  bne 0x830f886c
	if !ctx.cr[0].eq {
	pc = 0x830F886C; continue 'dispatch;
	}
	// 830F8824: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F8828: 419A0020  beq cr6, 0x830f8848
	if ctx.cr[6].eq {
	pc = 0x830F8848; continue 'dispatch;
	}
	// 830F882C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830F8830: 419A003C  beq cr6, 0x830f886c
	if ctx.cr[6].eq {
	pc = 0x830F886C; continue 'dispatch;
	}
	// 830F8834: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F8838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F883C: 4BFE7635  bl 0x830dfe70
	ctx.lr = 0x830F8840;
	sub_830DFE70(ctx, base);
	// 830F8840: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8844: 40820028  bne 0x830f886c
	if !ctx.cr[0].eq {
	pc = 0x830F886C; continue 'dispatch;
	}
	// 830F8848: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F884C: 419A0028  beq cr6, 0x830f8874
	if ctx.cr[6].eq {
	pc = 0x830F8874; continue 'dispatch;
	}
	// 830F8850: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830F8854: 419A0018  beq cr6, 0x830f886c
	if ctx.cr[6].eq {
	pc = 0x830F886C; continue 'dispatch;
	}
	// 830F8858: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F885C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8860: 4BFE7611  bl 0x830dfe70
	ctx.lr = 0x830F8864;
	sub_830DFE70(ctx, base);
	// 830F8864: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8868: 4182000C  beq 0x830f8874
	if ctx.cr[0].eq {
	pc = 0x830F8874; continue 'dispatch;
	}
	// 830F886C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8870: 4BFE6611  bl 0x830dee80
	ctx.lr = 0x830F8874;
	sub_830DEE80(ctx, base);
	// 830F8874: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F8878: 419A0020  beq cr6, 0x830f8898
	if ctx.cr[6].eq {
	pc = 0x830F8898; continue 'dispatch;
	}
	// 830F887C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8880: 4BFD6391  bl 0x830cec10
	ctx.lr = 0x830F8884;
	sub_830CEC10(ctx, base);
	// 830F8884: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F8888: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F888C: 4BFFDE9D  bl 0x830f6728
	ctx.lr = 0x830F8890;
	sub_830F6728(ctx, base);
	// 830F8890: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F8894: 4BFE0F95  bl 0x830d9828
	ctx.lr = 0x830F8898;
	sub_830D9828(ctx, base);
	// 830F8898: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830F889C: 419A000C  beq cr6, 0x830f88a8
	if ctx.cr[6].eq {
	pc = 0x830F88A8; continue 'dispatch;
	}
	// 830F88A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F88A4: 4BFE0F85  bl 0x830d9828
	ctx.lr = 0x830F88A8;
	sub_830D9828(ctx, base);
	// 830F88A8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830F88AC: 419A000C  beq cr6, 0x830f88b8
	if ctx.cr[6].eq {
	pc = 0x830F88B8; continue 'dispatch;
	}
	// 830F88B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F88B4: 4BFE0F75  bl 0x830d9828
	ctx.lr = 0x830F88B8;
	sub_830D9828(ctx, base);
	// 830F88B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F88BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830F88C0: 480AF8F4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F88C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F88C8 size=1436
    let mut pc: u32 = 0x830F88C8;
    'dispatch: loop {
        match pc {
            0x830F88C8 => {
    //   block [0x830F88C8..0x830F8E64)
	// 830F88C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F88CC: 480AF89D  bl 0x831a8168
	ctx.lr = 0x830F88D0;
	sub_831A8130(ctx, base);
	// 830F88D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F88D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F88D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F88DC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F88E0: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830F88E4: 4199025C  bgt cr6, 0x830f8b40
	if ctx.cr[6].gt {
	pc = 0x830F8B40; continue 'dispatch;
	}
	// 830F88E8: 419A0104  beq cr6, 0x830f89ec
	if ctx.cr[6].eq {
	pc = 0x830F89EC; continue 'dispatch;
	}
	// 830F88EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F88F0: 419A00CC  beq cr6, 0x830f89bc
	if ctx.cr[6].eq {
	pc = 0x830F89BC; continue 'dispatch;
	}
	// 830F88F4: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830F88F8: 419A0058  beq cr6, 0x830f8950
	if ctx.cr[6].eq {
	pc = 0x830F8950; continue 'dispatch;
	}
	// 830F88FC: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F8900: 419A040C  beq cr6, 0x830f8d0c
	if ctx.cr[6].eq {
	pc = 0x830F8D0C; continue 'dispatch;
	}
	// 830F8904: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 830F8908: 419A0020  beq cr6, 0x830f8928
	if ctx.cr[6].eq {
	pc = 0x830F8928; continue 'dispatch;
	}
	// 830F890C: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830F8910: 409A0548  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8914: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F891C: 419A053C  beq cr6, 0x830f8e58
	if ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8920: 4BFE6561  bl 0x830dee80
	ctx.lr = 0x830F8924;
	sub_830DEE80(ctx, base);
	// 830F8924: 4800052C  b 0x830f8e50
	pc = 0x830F8E50; continue 'dispatch;
	// 830F8928: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830F892C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F8930: 419A0528  beq cr6, 0x830f8e58
	if ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8934: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F893C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830F8940: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F8944: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F8948: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830F894C: 4800050C  b 0x830f8e58
	pc = 0x830F8E58; continue 'dispatch;
	// 830F8950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8954: 4BFFFE75  bl 0x830f87c8
	ctx.lr = 0x830F8958;
	sub_830F87C8(ctx, base);
	// 830F8958: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F895C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8960: 4BFD5BB9  bl 0x830ce518
	ctx.lr = 0x830F8964;
	sub_830CE518(ctx, base);
	// 830F8964: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F8968: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F896C: 419A04EC  beq cr6, 0x830f8e58
	if ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8970: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F8974: 4BFDD255  bl 0x830d5bc8
	ctx.lr = 0x830F8978;
	sub_830D5BC8(ctx, base);
	// 830F8978: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F897C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8980: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F8984: 418004D8  blt 0x830f8e5c
	if ctx.cr[0].lt {
	pc = 0x830F8E5C; continue 'dispatch;
	}
	// 830F8988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F898C: 4BFF722D  bl 0x830efbb8
	ctx.lr = 0x830F8990;
	sub_830EFBB8(ctx, base);
	// 830F8990: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8994: 418004C8  blt 0x830f8e5c
	if ctx.cr[0].lt {
	pc = 0x830F8E5C; continue 'dispatch;
	}
	// 830F8998: 4BFE6491  bl 0x830dee28
	ctx.lr = 0x830F899C;
	sub_830DEE28(ctx, base);
	// 830F899C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F89A0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F89A4: 409A04B4  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F89A8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F89AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F89B0: 419A04A8  beq cr6, 0x830f8e58
	if ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F89B4: 4BFE64CD  bl 0x830dee80
	ctx.lr = 0x830F89B8;
	sub_830DEE80(ctx, base);
	// 830F89B8: 480004A0  b 0x830f8e58
	pc = 0x830F8E58; continue 'dispatch;
	// 830F89BC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F89C0: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 830F89C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F89C8: 419A0010  beq cr6, 0x830f89d8
	if ctx.cr[6].eq {
	pc = 0x830F89D8; continue 'dispatch;
	}
	// 830F89CC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830F89D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F89D4: 409A0484  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F89D8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F89DC: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 830F89E0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F89E4: 48017665  bl 0x83110048
	ctx.lr = 0x830F89E8;
	sub_83110048(ctx, base);
	// 830F89E8: 48000470  b 0x830f8e58
	pc = 0x830F8E58; continue 'dispatch;
	// 830F89EC: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F89F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F89F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F89F8: 409A006C  bne cr6, 0x830f8a64
	if !ctx.cr[6].eq {
	pc = 0x830F8A64; continue 'dispatch;
	}
	// 830F89FC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8A00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8A04: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8A08: 409A0018  bne cr6, 0x830f8a20
	if !ctx.cr[6].eq {
	pc = 0x830F8A20; continue 'dispatch;
	}
	// 830F8A0C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830F8A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8A14: 4BFFFC15  bl 0x830f8628
	ctx.lr = 0x830F8A18;
	sub_830F8628(ctx, base);
	// 830F8A18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8A1C: 4BFFFF04  b 0x830f8920
	pc = 0x830F8920; continue 'dispatch;
	// 830F8A20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8A24: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8A28: 409A0020  bne cr6, 0x830f8a48
	if !ctx.cr[6].eq {
	pc = 0x830F8A48; continue 'dispatch;
	}
	// 830F8A2C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8A34: 409A0014  bne cr6, 0x830f8a48
	if !ctx.cr[6].eq {
	pc = 0x830F8A48; continue 'dispatch;
	}
	// 830F8A38: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830F8A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8A40: 4BFFFBE9  bl 0x830f8628
	ctx.lr = 0x830F8A44;
	sub_830F8628(ctx, base);
	// 830F8A44: 4800040C  b 0x830f8e50
	pc = 0x830F8E50; continue 'dispatch;
	// 830F8A48: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F8A4C: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830F8A50: 4BFD6121  bl 0x830ceb70
	ctx.lr = 0x830F8A54;
	sub_830CEB70(ctx, base);
	// 830F8A54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F8A58: 4182000C  beq 0x830f8a64
	if ctx.cr[0].eq {
	pc = 0x830F8A64; continue 'dispatch;
	}
	// 830F8A5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F8A60: 4BFFFFB0  b 0x830f8a10
	pc = 0x830F8A10; continue 'dispatch;
	// 830F8A64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8A68: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F8A6C: 409A0054  bne cr6, 0x830f8ac0
	if !ctx.cr[6].eq {
	pc = 0x830F8AC0; continue 'dispatch;
	}
	// 830F8A70: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8A74: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8A78: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F8A7C: 409A0044  bne cr6, 0x830f8ac0
	if !ctx.cr[6].eq {
	pc = 0x830F8AC0; continue 'dispatch;
	}
	// 830F8A80: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8A84: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8A88: 4BFEF5D9  bl 0x830e8060
	ctx.lr = 0x830F8A8C;
	sub_830E8060(ctx, base);
	// 830F8A8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830F8A90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8A94: 4BFEF1AD  bl 0x830e7c40
	ctx.lr = 0x830F8A98;
	sub_830E7C40(ctx, base);
	// 830F8A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F8A9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F8AA0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8AA4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8AA8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F8AAC: 4BFEF66D  bl 0x830e8118
	ctx.lr = 0x830F8AB0;
	sub_830E8118(ctx, base);
	// 830F8AB0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F8AB4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8AB8: 4BFEF1E1  bl 0x830e7c98
	ctx.lr = 0x830F8ABC;
	sub_830E7C98(ctx, base);
	// 830F8ABC: 48000394  b 0x830f8e50
	pc = 0x830F8E50; continue 'dispatch;
	// 830F8AC0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830F8AC4: 409A0394  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8AC8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8ACC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8AD0: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8AD4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8AD8: 4BFE7399  bl 0x830dfe70
	ctx.lr = 0x830F8ADC;
	sub_830DFE70(ctx, base);
	// 830F8ADC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8AE0: 40820378  bne 0x830f8e58
	if !ctx.cr[0].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8AE4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8AE8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8AEC: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F8AF0: 419A0368  beq cr6, 0x830f8e58
	if ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8AF4: 4BFE737D  bl 0x830dfe70
	ctx.lr = 0x830F8AF8;
	sub_830DFE70(ctx, base);
	// 830F8AF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8AFC: 4082035C  bne 0x830f8e58
	if !ctx.cr[0].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8B00: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8B04: 4BFE89AD  bl 0x830e14b0
	ctx.lr = 0x830F8B08;
	sub_830E14B0(ctx, base);
	// 830F8B08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F8B0C: 41820024  beq 0x830f8b30
	if ctx.cr[0].eq {
	pc = 0x830F8B30; continue 'dispatch;
	}
	// 830F8B10: 4BFD6101  bl 0x830cec10
	ctx.lr = 0x830F8B14;
	sub_830CEC10(ctx, base);
	// 830F8B14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F8B18: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8B1C: 4BFD60F5  bl 0x830cec10
	ctx.lr = 0x830F8B20;
	sub_830CEC10(ctx, base);
	// 830F8B20: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F8B24: 409A000C  bne cr6, 0x830f8b30
	if !ctx.cr[6].eq {
	pc = 0x830F8B30; continue 'dispatch;
	}
	// 830F8B28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8B2C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830F8B30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F8B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8B38: 4BFFFAF1  bl 0x830f8628
	ctx.lr = 0x830F8B3C;
	sub_830F8628(ctx, base);
	// 830F8B3C: 4800031C  b 0x830f8e58
	pc = 0x830F8E58; continue 'dispatch;
	// 830F8B40: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830F8B44: 419A02F0  beq cr6, 0x830f8e34
	if ctx.cr[6].eq {
	pc = 0x830F8E34; continue 'dispatch;
	}
	// 830F8B48: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 830F8B4C: 419A0270  beq cr6, 0x830f8dbc
	if ctx.cr[6].eq {
	pc = 0x830F8DBC; continue 'dispatch;
	}
	// 830F8B50: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830F8B54: 419A01C4  beq cr6, 0x830f8d18
	if ctx.cr[6].eq {
	pc = 0x830F8D18; continue 'dispatch;
	}
	// 830F8B58: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830F8B5C: 419A01A0  beq cr6, 0x830f8cfc
	if ctx.cr[6].eq {
	pc = 0x830F8CFC; continue 'dispatch;
	}
	// 830F8B60: 2B0B07E6  cmplwi cr6, r11, 0x7e6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2022 as u32, &mut ctx.xer);
	// 830F8B64: 409A02F4  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8B68: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8B6C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8B70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F8B74: 419A02E4  beq cr6, 0x830f8e58
	if ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8B78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8B7C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F8B80: 419A011C  beq cr6, 0x830f8c9c
	if ctx.cr[6].eq {
	pc = 0x830F8C9C; continue 'dispatch;
	}
	// 830F8B84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F8B88: 419A0114  beq cr6, 0x830f8c9c
	if ctx.cr[6].eq {
	pc = 0x830F8C9C; continue 'dispatch;
	}
	// 830F8B8C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830F8B90: 409A0048  bne cr6, 0x830f8bd8
	if !ctx.cr[6].eq {
	pc = 0x830F8BD8; continue 'dispatch;
	}
	// 830F8B94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8B98: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8B9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8BA0: 409A0010  bne cr6, 0x830f8bb0
	if !ctx.cr[6].eq {
	pc = 0x830F8BB0; continue 'dispatch;
	}
	// 830F8BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8BA8: 409A0120  bne cr6, 0x830f8cc8
	if !ctx.cr[6].eq {
	pc = 0x830F8CC8; continue 'dispatch;
	}
	// 830F8BAC: 4800000C  b 0x830f8bb8
	pc = 0x830F8BB8; continue 'dispatch;
	// 830F8BB0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8BB4: 409A0018  bne cr6, 0x830f8bcc
	if !ctx.cr[6].eq {
	pc = 0x830F8BCC; continue 'dispatch;
	}
	// 830F8BB8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8BBC: 4BFE7EC5  bl 0x830e0a80
	ctx.lr = 0x830F8BC0;
	sub_830E0A80(ctx, base);
	// 830F8BC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8BC4: 41820294  beq 0x830f8e58
	if ctx.cr[0].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8BC8: 480000FC  b 0x830f8cc4
	pc = 0x830F8CC4; continue 'dispatch;
	// 830F8BCC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8BD0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8BD4: 480000A8  b 0x830f8c7c
	pc = 0x830F8C7C; continue 'dispatch;
	// 830F8BD8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830F8BDC: 409A0014  bne cr6, 0x830f8bf0
	if !ctx.cr[6].eq {
	pc = 0x830F8BF0; continue 'dispatch;
	}
	// 830F8BE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8BE4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8BE8: 409A0270  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8BEC: 48000080  b 0x830f8c6c
	pc = 0x830F8C6C; continue 'dispatch;
	// 830F8BF0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F8BF4: 409A0040  bne cr6, 0x830f8c34
	if !ctx.cr[6].eq {
	pc = 0x830F8C34; continue 'dispatch;
	}
	// 830F8BF8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8BFC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8C00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8C04: 419AFFA0  beq cr6, 0x830f8ba4
	if ctx.cr[6].eq {
	pc = 0x830F8BA4; continue 'dispatch;
	}
	// 830F8C08: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8C0C: 419AFFAC  beq cr6, 0x830f8bb8
	if ctx.cr[6].eq {
	pc = 0x830F8BB8; continue 'dispatch;
	}
	// 830F8C10: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8C14: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8C18: 419AFF18  beq cr6, 0x830f8b30
	if ctx.cr[6].eq {
	pc = 0x830F8B30; continue 'dispatch;
	}
	// 830F8C1C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F8C20: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830F8C24: 4BFD5F4D  bl 0x830ceb70
	ctx.lr = 0x830F8C28;
	sub_830CEB70(ctx, base);
	// 830F8C28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F8C2C: 4182022C  beq 0x830f8e58
	if ctx.cr[0].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8C30: 4BFFFF00  b 0x830f8b30
	pc = 0x830F8B30; continue 'dispatch;
	// 830F8C34: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830F8C38: 409A0220  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8C3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8C40: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8C44: 419A0040  beq cr6, 0x830f8c84
	if ctx.cr[6].eq {
	pc = 0x830F8C84; continue 'dispatch;
	}
	// 830F8C48: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F8C4C: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830F8C50: 4BFD5F21  bl 0x830ceb70
	ctx.lr = 0x830F8C54;
	sub_830CEB70(ctx, base);
	// 830F8C54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F8C58: 4082002C  bne 0x830f8c84
	if !ctx.cr[0].eq {
	pc = 0x830F8C84; continue 'dispatch;
	}
	// 830F8C5C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8C60: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8C64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F8C68: 409A000C  bne cr6, 0x830f8c74
	if !ctx.cr[6].eq {
	pc = 0x830F8C74; continue 'dispatch;
	}
	// 830F8C6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8C70: 48000058  b 0x830f8cc8
	pc = 0x830F8CC8; continue 'dispatch;
	// 830F8C74: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8C78: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F8C7C: 409A01DC  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8C80: 4BFFFEB0  b 0x830f8b30
	pc = 0x830F8B30; continue 'dispatch;
	// 830F8C84: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8C8C: 409A0008  bne cr6, 0x830f8c94
	if !ctx.cr[6].eq {
	pc = 0x830F8C94; continue 'dispatch;
	}
	// 830F8C90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8C94: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F8C98: 480001B8  b 0x830f8e50
	pc = 0x830F8E50; continue 'dispatch;
	// 830F8C9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8CA0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8CA4: 419A0010  beq cr6, 0x830f8cb4
	if ctx.cr[6].eq {
	pc = 0x830F8CB4; continue 'dispatch;
	}
	// 830F8CA8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8CAC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8CB0: 409A0028  bne cr6, 0x830f8cd8
	if !ctx.cr[6].eq {
	pc = 0x830F8CD8; continue 'dispatch;
	}
	// 830F8CB4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8CB8: 4BFE7DC9  bl 0x830e0a80
	ctx.lr = 0x830F8CBC;
	sub_830E0A80(ctx, base);
	// 830F8CBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8CC0: 41820018  beq 0x830f8cd8
	if ctx.cr[0].eq {
	pc = 0x830F8CD8; continue 'dispatch;
	}
	// 830F8CC4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8CC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F8CCC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F8CD0: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F8CD4: 48000184  b 0x830f8e58
	pc = 0x830F8E58; continue 'dispatch;
	// 830F8CD8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8CDC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8CE0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F8CE4: 409A0174  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8CE8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F8CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8CF0: 4BFFF939  bl 0x830f8628
	ctx.lr = 0x830F8CF4;
	sub_830F8628(ctx, base);
	// 830F8CF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8CF8: 4BFFFCBC  b 0x830f89b4
	pc = 0x830F89B4; continue 'dispatch;
	// 830F8CFC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8D00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8D08: 419A0150  beq cr6, 0x830f8e58
	if ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8D10: 4BFFFAB9  bl 0x830f87c8
	ctx.lr = 0x830F8D14;
	sub_830F87C8(ctx, base);
	// 830F8D14: 48000144  b 0x830f8e58
	pc = 0x830F8E58; continue 'dispatch;
	// 830F8D18: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8D1C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830F8D20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F8D24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F8D28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F8D2C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8D30: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8D34: 551C0738  rlwinm r28, r8, 0, 0x1c, 0x1c
	ctx.r[28].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 830F8D38: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F8D3C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8D40: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830F8D44: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8D48: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F8D4C: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8D50: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830F8D54: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 830F8D58: 4BFE5F89  bl 0x830dece0
	ctx.lr = 0x830F8D5C;
	sub_830DECE0(ctx, base);
	// 830F8D5C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F8D60: 419A0014  beq cr6, 0x830f8d74
	if ctx.cr[6].eq {
	pc = 0x830F8D74; continue 'dispatch;
	}
	// 830F8D64: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830F8D68: 419AFCA4  beq cr6, 0x830f8a0c
	if ctx.cr[6].eq {
	pc = 0x830F8A0C; continue 'dispatch;
	}
	// 830F8D6C: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830F8D70: 419AFC9C  beq cr6, 0x830f8a0c
	if ctx.cr[6].eq {
	pc = 0x830F8A0C; continue 'dispatch;
	}
	// 830F8D74: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8D78: 4BFE7D09  bl 0x830e0a80
	ctx.lr = 0x830F8D7C;
	sub_830E0A80(ctx, base);
	// 830F8D7C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F8D80: 418200D8  beq 0x830f8e58
	if ctx.cr[0].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8D84: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8D88: 2B0B001B  cmplwi cr6, r11, 0x1b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 27 as u32, &mut ctx.xer);
	// 830F8D8C: 419A000C  beq cr6, 0x830f8d98
	if ctx.cr[6].eq {
	pc = 0x830F8D98; continue 'dispatch;
	}
	// 830F8D90: 2B0B5801  cmplwi cr6, r11, 0x5801
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22529 as u32, &mut ctx.xer);
	// 830F8D94: 409A00C4  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8D98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F8D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8DA0: 4BFFF889  bl 0x830f8628
	ctx.lr = 0x830F8DA4;
	sub_830F8628(ctx, base);
	// 830F8DA4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8DA8: 4BFE60D9  bl 0x830dee80
	ctx.lr = 0x830F8DAC;
	sub_830DEE80(ctx, base);
	// 830F8DAC: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F8DB0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8DB4: 4BFEEC0D  bl 0x830e79c0
	ctx.lr = 0x830F8DB8;
	sub_830E79C0(ctx, base);
	// 830F8DB8: 48000098  b 0x830f8e50
	pc = 0x830F8E50; continue 'dispatch;
	// 830F8DBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F8DC0: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8DC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F8DC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F8DCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8DD0: 4BFE6989  bl 0x830df758
	ctx.lr = 0x830F8DD4;
	sub_830DF758(ctx, base);
	// 830F8DD4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8DD8: 4BFD5E39  bl 0x830cec10
	ctx.lr = 0x830F8DDC;
	sub_830CEC10(ctx, base);
	// 830F8DDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F8DE0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F8DE4: 409A0074  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8DE8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8DEC: 4BFD5E25  bl 0x830cec10
	ctx.lr = 0x830F8DF0;
	sub_830CEC10(ctx, base);
	// 830F8DF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8DF4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8DF8: 419A002C  beq cr6, 0x830f8e24
	if ctx.cr[6].eq {
	pc = 0x830F8E24; continue 'dispatch;
	}
	// 830F8DFC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8E00: 4BFD5E11  bl 0x830cec10
	ctx.lr = 0x830F8E04;
	sub_830CEC10(ctx, base);
	// 830F8E04: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F8E08: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8E0C: 419A0018  beq cr6, 0x830f8e24
	if ctx.cr[6].eq {
	pc = 0x830F8E24; continue 'dispatch;
	}
	// 830F8E10: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8E14: 4BFD5DFD  bl 0x830cec10
	ctx.lr = 0x830F8E18;
	sub_830CEC10(ctx, base);
	// 830F8E18: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F8E1C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F8E20: 409A0038  bne cr6, 0x830f8e58
	if !ctx.cr[6].eq {
	pc = 0x830F8E58; continue 'dispatch;
	}
	// 830F8E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8E28: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F8E2C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F8E30: 48000028  b 0x830f8e58
	pc = 0x830F8E58; continue 'dispatch;
	// 830F8E34: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F8E3C: C08B000C  lfs f4, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830F8E40: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830F8E44: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F8E48: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F8E4C: 4BFED6CD  bl 0x830e6518
	ctx.lr = 0x830F8E50;
	sub_830E6518(ctx, base);
	// 830F8E50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8E54: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F8E58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F8E5C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F8E60: 480AF358  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8E68 size=288
    let mut pc: u32 = 0x830F8E68;
    'dispatch: loop {
        match pc {
            0x830F8E68 => {
    //   block [0x830F8E68..0x830F8F88)
	// 830F8E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F8E6C: 480AF301  bl 0x831a816c
	ctx.lr = 0x830F8E70;
	sub_831A8130(ctx, base);
	// 830F8E70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8E74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F8E78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F8E7C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8E80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8E84: 419A00CC  beq cr6, 0x830f8f50
	if ctx.cr[6].eq {
	pc = 0x830F8F50; continue 'dispatch;
	}
	// 830F8E88: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F8E8C: 419A00AC  beq cr6, 0x830f8f38
	if ctx.cr[6].eq {
	pc = 0x830F8F38; continue 'dispatch;
	}
	// 830F8E90: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830F8E94: 419A003C  beq cr6, 0x830f8ed0
	if ctx.cr[6].eq {
	pc = 0x830F8ED0; continue 'dispatch;
	}
	// 830F8E98: 2B0B07DC  cmplwi cr6, r11, 0x7dc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2012 as u32, &mut ctx.xer);
	// 830F8E9C: 419A0080  beq cr6, 0x830f8f1c
	if ctx.cr[6].eq {
	pc = 0x830F8F1C; continue 'dispatch;
	}
	// 830F8EA0: 2B0B07DF  cmplwi cr6, r11, 0x7df
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2015 as u32, &mut ctx.xer);
	// 830F8EA4: 419A0078  beq cr6, 0x830f8f1c
	if ctx.cr[6].eq {
	pc = 0x830F8F1C; continue 'dispatch;
	}
	// 830F8EA8: 2B0B07E1  cmplwi cr6, r11, 0x7e1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2017 as u32, &mut ctx.xer);
	// 830F8EAC: 419A0070  beq cr6, 0x830f8f1c
	if ctx.cr[6].eq {
	pc = 0x830F8F1C; continue 'dispatch;
	}
	// 830F8EB0: 2B0B07E6  cmplwi cr6, r11, 0x7e6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2022 as u32, &mut ctx.xer);
	// 830F8EB4: 409A00C8  bne cr6, 0x830f8f7c
	if !ctx.cr[6].eq {
	pc = 0x830F8F7C; continue 'dispatch;
	}
	// 830F8EB8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8EBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8EC0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830F8EC4: 419A0058  beq cr6, 0x830f8f1c
	if ctx.cr[6].eq {
	pc = 0x830F8F1C; continue 'dispatch;
	}
	// 830F8EC8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830F8ECC: 4800004C  b 0x830f8f18
	pc = 0x830F8F18; continue 'dispatch;
	// 830F8ED0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8ED4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8ED8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F8EDC: 409A0030  bne cr6, 0x830f8f0c
	if !ctx.cr[6].eq {
	pc = 0x830F8F0C; continue 'dispatch;
	}
	// 830F8EE0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F8EE8: 419A0094  beq cr6, 0x830f8f7c
	if ctx.cr[6].eq {
	pc = 0x830F8F7C; continue 'dispatch;
	}
	// 830F8EEC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F8EF0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8EF4: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830F8EF8: 4BFD5C79  bl 0x830ceb70
	ctx.lr = 0x830F8EFC;
	sub_830CEB70(ctx, base);
	// 830F8EFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F8F00: 4182007C  beq 0x830f8f7c
	if ctx.cr[0].eq {
	pc = 0x830F8F7C; continue 'dispatch;
	}
	// 830F8F04: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8F08: 48000020  b 0x830f8f28
	pc = 0x830F8F28; continue 'dispatch;
	// 830F8F0C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F8F10: 419A000C  beq cr6, 0x830f8f1c
	if ctx.cr[6].eq {
	pc = 0x830F8F1C; continue 'dispatch;
	}
	// 830F8F14: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830F8F18: 409A0064  bne cr6, 0x830f8f7c
	if !ctx.cr[6].eq {
	pc = 0x830F8F7C; continue 'dispatch;
	}
	// 830F8F1C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8F20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F8F24: 419A0058  beq cr6, 0x830f8f7c
	if ctx.cr[6].eq {
	pc = 0x830F8F7C; continue 'dispatch;
	}
	// 830F8F28: 4BFD5CE9  bl 0x830cec10
	ctx.lr = 0x830F8F2C;
	sub_830CEC10(ctx, base);
	// 830F8F2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F8F30: 4BFDCC99  bl 0x830d5bc8
	ctx.lr = 0x830F8F34;
	sub_830D5BC8(ctx, base);
	// 830F8F34: 48000048  b 0x830f8f7c
	pc = 0x830F8F7C; continue 'dispatch;
	// 830F8F38: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8F3C: 4BFD5CD5  bl 0x830cec10
	ctx.lr = 0x830F8F40;
	sub_830CEC10(ctx, base);
	// 830F8F40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F8F44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F8F48: 4BFFD7E1  bl 0x830f6728
	ctx.lr = 0x830F8F4C;
	sub_830F6728(ctx, base);
	// 830F8F4C: 48000030  b 0x830f8f7c
	pc = 0x830F8F7C; continue 'dispatch;
	// 830F8F50: 83FE0010  lwz r31, 0x10(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8F54: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F8F58: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F8F5C: 40820020  bne 0x830f8f7c
	if !ctx.cr[0].eq {
	pc = 0x830F8F7C; continue 'dispatch;
	}
	// 830F8F60: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8F64: 4BFD5CAD  bl 0x830cec10
	ctx.lr = 0x830F8F68;
	sub_830CEC10(ctx, base);
	// 830F8F68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F8F6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830F8F70: 4BFFD7B9  bl 0x830f6728
	ctx.lr = 0x830F8F74;
	sub_830F6728(ctx, base);
	// 830F8F74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F8F78: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F8F7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F8F80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F8F84: 480AF238  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F8F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F8F88 size=176
    let mut pc: u32 = 0x830F8F88;
    'dispatch: loop {
        match pc {
            0x830F8F88 => {
    //   block [0x830F8F88..0x830F9038)
	// 830F8F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F8F8C: 480AF1D5  bl 0x831a8160
	ctx.lr = 0x830F8F90;
	sub_831A8130(ctx, base);
	// 830F8F90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F8F94: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830F8F98: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830F8F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F8FA0: 7FDDD214  add r30, r29, r26
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[26].u64;
	// 830F8FA4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830F8FA8: 41980084  blt cr6, 0x830f902c
	if ctx.cr[6].lt {
	pc = 0x830F902C; continue 'dispatch;
	}
	// 830F8FAC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830F8FB0: 4198007C  blt cr6, 0x830f902c
	if ctx.cr[6].lt {
	pc = 0x830F902C; continue 'dispatch;
	}
	// 830F8FB4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F8FB8: 41980074  blt cr6, 0x830f902c
	if ctx.cr[6].lt {
	pc = 0x830F902C; continue 'dispatch;
	}
	// 830F8FBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8FC0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F8FC4: 41990068  bgt cr6, 0x830f902c
	if ctx.cr[6].gt {
	pc = 0x830F902C; continue 'dispatch;
	}
	// 830F8FC8: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F8FCC: 40980028  bge cr6, 0x830f8ff4
	if !ctx.cr[6].lt {
	pc = 0x830F8FF4; continue 'dispatch;
	}
	// 830F8FD0: 1F7D000C  mulli r27, r29, 0xc
	ctx.r[27].s64 = ctx.r[29].s64 * 12;
	// 830F8FD4: 7F9DF050  subf r28, r29, r30
	ctx.r[28].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 830F8FD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F8FDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F8FE0: 7C7B5A14  add r3, r27, r11
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 830F8FE4: 4BFD400D  bl 0x830ccff0
	ctx.lr = 0x830F8FE8;
	sub_830CCFF0(ctx, base);
	// 830F8FE8: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F8FEC: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 830F8FF0: 4082FFE8  bne 0x830f8fd8
	if !ctx.cr[0].eq {
	pc = 0x830F8FD8; continue 'dispatch;
	}
	// 830F8FF4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F8FF8: 1D3E000C  mulli r9, r30, 0xc
	ctx.r[9].s64 = ctx.r[30].s64 * 12;
	// 830F8FFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9000: 1D5D000C  mulli r10, r29, 0xc
	ctx.r[10].s64 = ctx.r[29].s64 * 12;
	// 830F9004: 7D1E4050  subf r8, r30, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	// 830F9008: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830F900C: 1CA8000C  mulli r5, r8, 0xc
	ctx.r[5].s64 = ctx.r[8].s64 * 12;
	// 830F9010: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F9014: 480B433D  bl 0x831ad350
	ctx.lr = 0x830F9018;
	sub_831AD350(ctx, base);
	// 830F9018: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F901C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F9020: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 830F9024: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F9028: 48000008  b 0x830f9030
	pc = 0x830F9030; continue 'dispatch;
	// 830F902C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F9030: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F9034: 480AF17C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F9038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F9038 size=56
    let mut pc: u32 = 0x830F9038;
    'dispatch: loop {
        match pc {
            0x830F9038 => {
    //   block [0x830F9038..0x830F9070)
	// 830F9038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F903C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F9040: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F9044: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F9048: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F904C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9050: 4BFE4489  bl 0x830dd4d8
	ctx.lr = 0x830F9054;
	sub_830DD4D8(ctx, base);
	// 830F9054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F9058: 4BFFCB49  bl 0x830f5ba0
	ctx.lr = 0x830F905C;
	sub_830F5BA0(ctx, base);
	// 830F905C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830F9060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F9064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F9068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F906C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F9070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F9070 size=844
    let mut pc: u32 = 0x830F9070;
    'dispatch: loop {
        match pc {
            0x830F9070 => {
    //   block [0x830F9070..0x830F93BC)
	// 830F9070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F9074: 480AF0F9  bl 0x831a816c
	ctx.lr = 0x830F9078;
	sub_831A8130(ctx, base);
	// 830F9078: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F907C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F9080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F9084: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9088: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 830F908C: 419901B4  bgt cr6, 0x830f9240
	if ctx.cr[6].gt {
	pc = 0x830F9240; continue 'dispatch;
	}
	// 830F9090: 419A0184  beq cr6, 0x830f9214
	if ctx.cr[6].eq {
	pc = 0x830F9214; continue 'dispatch;
	}
	// 830F9094: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F9098: 4198014C  blt cr6, 0x830f91e4
	if ctx.cr[6].lt {
	pc = 0x830F91E4; continue 'dispatch;
	}
	// 830F909C: 419A0118  beq cr6, 0x830f91b4
	if ctx.cr[6].eq {
	pc = 0x830F91B4; continue 'dispatch;
	}
	// 830F90A0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830F90A4: 419A0100  beq cr6, 0x830f91a4
	if ctx.cr[6].eq {
	pc = 0x830F91A4; continue 'dispatch;
	}
	// 830F90A8: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 830F90AC: 419A00D8  beq cr6, 0x830f9184
	if ctx.cr[6].eq {
	pc = 0x830F9184; continue 'dispatch;
	}
	// 830F90B0: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F90B4: 419A0028  beq cr6, 0x830f90dc
	if ctx.cr[6].eq {
	pc = 0x830F90DC; continue 'dispatch;
	}
	// 830F90B8: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 830F90BC: 409A02F4  bne cr6, 0x830f93b0
	if !ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F90C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F90C4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F90C8: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F90CC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F90D0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F90D4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830F90D8: 480002D8  b 0x830f93b0
	pc = 0x830F93B0; continue 'dispatch;
	// 830F90DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F90E0: 4BFE5DA9  bl 0x830dee88
	ctx.lr = 0x830F90E4;
	sub_830DEE88(ctx, base);
	// 830F90E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F90E8: 41820018  beq 0x830f9100
	if ctx.cr[0].eq {
	pc = 0x830F9100; continue 'dispatch;
	}
	// 830F90EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F90F0: 4BFE5E11  bl 0x830def00
	ctx.lr = 0x830F90F4;
	sub_830DEF00(ctx, base);
	// 830F90F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830F90F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F90FC: 4BFE9B25  bl 0x830e2c20
	ctx.lr = 0x830F9100;
	sub_830E2C20(ctx, base);
	// 830F9100: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9104: 4BFE5B6D  bl 0x830dec70
	ctx.lr = 0x830F9108;
	sub_830DEC70(ctx, base);
	// 830F9108: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F910C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F9110: 419A0008  beq cr6, 0x830f9118
	if ctx.cr[6].eq {
	pc = 0x830F9118; continue 'dispatch;
	}
	// 830F9114: 480066CD  bl 0x830ff7e0
	ctx.lr = 0x830F9118;
	sub_830FF7E0(ctx, base);
	// 830F9118: 83DF00E4  lwz r30, 0xe4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F911C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F9120: 419A0014  beq cr6, 0x830f9134
	if ctx.cr[6].eq {
	pc = 0x830F9134; continue 'dispatch;
	}
	// 830F9124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F9128: 48006CE1  bl 0x830ffe08
	ctx.lr = 0x830F912C;
	sub_830FFE08(ctx, base);
	// 830F912C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F9130: 4BFE43A9  bl 0x830dd4d8
	ctx.lr = 0x830F9134;
	sub_830DD4D8(ctx, base);
	// 830F9134: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F9138: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F913C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 830F9140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F9144: 4BFFCF8D  bl 0x830f60d0
	ctx.lr = 0x830F9148;
	sub_830F60D0(ctx, base);
	// 830F9148: 48000010  b 0x830f9158
	pc = 0x830F9158; continue 'dispatch;
	// 830F914C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F9150: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9154: 4BFE06D5  bl 0x830d9828
	ctx.lr = 0x830F9158;
	sub_830D9828(ctx, base);
	// 830F9158: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F915C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F9160: 409AFFEC  bne cr6, 0x830f914c
	if !ctx.cr[6].eq {
	pc = 0x830F914C; continue 'dispatch;
	}
	// 830F9164: 48000010  b 0x830f9174
	pc = 0x830F9174; continue 'dispatch;
	// 830F9168: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F916C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9170: 4BFE06B9  bl 0x830d9828
	ctx.lr = 0x830F9174;
	sub_830D9828(ctx, base);
	// 830F9174: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F9178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F917C: 409AFFEC  bne cr6, 0x830f9168
	if !ctx.cr[6].eq {
	pc = 0x830F9168; continue 'dispatch;
	}
	// 830F9180: 48000230  b 0x830f93b0
	pc = 0x830F93B0; continue 'dispatch;
	// 830F9184: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9188: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F918C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F9190: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830F9194: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F9198: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830F919C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F91A0: 48000210  b 0x830f93b0
	pc = 0x830F93B0; continue 'dispatch;
	// 830F91A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F91A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F91AC: 4BFEFEB5  bl 0x830e9060
	ctx.lr = 0x830F91B0;
	sub_830E9060(ctx, base);
	// 830F91B0: 48000204  b 0x830f93b4
	pc = 0x830F93B4; continue 'dispatch;
	// 830F91B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F91B8: 4BFEFA89  bl 0x830e8c40
	ctx.lr = 0x830F91BC;
	sub_830E8C40(ctx, base);
	// 830F91BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F91C0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F91C4: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F91C8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F91CC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F91D0: 409A01E0  bne cr6, 0x830f93b0
	if !ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F91D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F91D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F91DC: 4BFFCDD5  bl 0x830f5fb0
	ctx.lr = 0x830F91E0;
	sub_830F5FB0(ctx, base);
	// 830F91E0: 480001D4  b 0x830f93b4
	pc = 0x830F93B4; continue 'dispatch;
	// 830F91E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F91E8: 4BFEFA59  bl 0x830e8c40
	ctx.lr = 0x830F91EC;
	sub_830E8C40(ctx, base);
	// 830F91EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F91F0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F91F4: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F91F8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F91FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F9200: 409A01B0  bne cr6, 0x830f93b0
	if !ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F9204: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F9208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F920C: 4BFFCE25  bl 0x830f6030
	ctx.lr = 0x830F9210;
	sub_830F6030(ctx, base);
	// 830F9210: 480001A4  b 0x830f93b4
	pc = 0x830F93B4; continue 'dispatch;
	// 830F9214: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F9218: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F921C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F9220: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9224: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F9228: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F922C: 419A000C  beq cr6, 0x830f9238
	if ctx.cr[6].eq {
	pc = 0x830F9238; continue 'dispatch;
	}
	// 830F9230: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830F9234: 48000178  b 0x830f93ac
	pc = 0x830F93AC; continue 'dispatch;
	// 830F9238: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F923C: 48000170  b 0x830f93ac
	pc = 0x830F93AC; continue 'dispatch;
	// 830F9240: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 830F9244: 419A0154  beq cr6, 0x830f9398
	if ctx.cr[6].eq {
	pc = 0x830F9398; continue 'dispatch;
	}
	// 830F9248: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830F924C: 419A012C  beq cr6, 0x830f9378
	if ctx.cr[6].eq {
	pc = 0x830F9378; continue 'dispatch;
	}
	// 830F9250: 2B0B0800  cmplwi cr6, r11, 0x800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2048 as u32, &mut ctx.xer);
	// 830F9254: 419A00DC  beq cr6, 0x830f9330
	if ctx.cr[6].eq {
	pc = 0x830F9330; continue 'dispatch;
	}
	// 830F9258: 2B0B0806  cmplwi cr6, r11, 0x806
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2054 as u32, &mut ctx.xer);
	// 830F925C: 419A00C4  beq cr6, 0x830f9320
	if ctx.cr[6].eq {
	pc = 0x830F9320; continue 'dispatch;
	}
	// 830F9260: 2B0B0807  cmplwi cr6, r11, 0x807
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2055 as u32, &mut ctx.xer);
	// 830F9264: 409A014C  bne cr6, 0x830f93b0
	if !ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F9268: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F926C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F9270: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F9274: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9278: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F927C: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F9280: 419A000C  beq cr6, 0x830f928c
	if ctx.cr[6].eq {
	pc = 0x830F928C; continue 'dispatch;
	}
	// 830F9284: 656B0001  oris r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 65536;
	// 830F9288: 48000008  b 0x830f9290
	pc = 0x830F9290; continue 'dispatch;
	// 830F928C: 556B041C  rlwinm r11, r11, 0, 0x10, 0xe
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F9290: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F9294: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830F9298: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 830F929C: 556B03DE  rlwinm r11, r11, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F92A0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830F92A4: 409A010C  bne cr6, 0x830f93b0
	if !ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F92A8: 48000064  b 0x830f930c
	pc = 0x830F930C; continue 'dispatch;
	// 830F92AC: 4BFE5C55  bl 0x830def00
	ctx.lr = 0x830F92B0;
	sub_830DEF00(ctx, base);
	// 830F92B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F92B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F92B8: 4BFD5959  bl 0x830cec10
	ctx.lr = 0x830F92BC;
	sub_830CEC10(ctx, base);
	// 830F92BC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830F92C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F92C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F92C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F92CC: 4BFE7645  bl 0x830e0910
	ctx.lr = 0x830F92D0;
	sub_830E0910(ctx, base);
	// 830F92D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F92D4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 830F92D8: 4BFD5939  bl 0x830cec10
	ctx.lr = 0x830F92DC;
	sub_830CEC10(ctx, base);
	// 830F92DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F92E0: 4BFDC8E9  bl 0x830d5bc8
	ctx.lr = 0x830F92E4;
	sub_830D5BC8(ctx, base);
	// 830F92E4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830F92E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F92EC: 419A0014  beq cr6, 0x830f9300
	if ctx.cr[6].eq {
	pc = 0x830F9300; continue 'dispatch;
	}
	// 830F92F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F92F4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F92F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F92FC: 419A0008  beq cr6, 0x830f9304
	if ctx.cr[6].eq {
	pc = 0x830F9304; continue 'dispatch;
	}
	// 830F9300: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F9304: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F9308: 4BFE9919  bl 0x830e2c20
	ctx.lr = 0x830F930C;
	sub_830E2C20(ctx, base);
	// 830F930C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9310: 4BFE81A1  bl 0x830e14b0
	ctx.lr = 0x830F9314;
	sub_830E14B0(ctx, base);
	// 830F9314: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F9318: 4082FF94  bne 0x830f92ac
	if !ctx.cr[0].eq {
	pc = 0x830F92AC; continue 'dispatch;
	}
	// 830F931C: 48000094  b 0x830f93b0
	pc = 0x830F93B0; continue 'dispatch;
	// 830F9320: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F9324: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F9328: A17F00F0  lhz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F932C: 4BFFFDA0  b 0x830f90cc
	pc = 0x830F90CC; continue 'dispatch;
	// 830F9330: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9334: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830F9338: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F933C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9340: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9344: 4BFE98E5  bl 0x830e2c28
	ctx.lr = 0x830F9348;
	sub_830E2C28(ctx, base);
	// 830F9348: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F934C: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830F9350: 41820060  beq 0x830f93b0
	if ctx.cr[0].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F9354: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 830F9358: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 830F935C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9360: 4BFD58B1  bl 0x830cec10
	ctx.lr = 0x830F9364;
	sub_830CEC10(ctx, base);
	// 830F9364: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F9368: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F936C: 409A0044  bne cr6, 0x830f93b0
	if !ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F9370: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 830F9374: 4800003C  b 0x830f93b0
	pc = 0x830F93B0; continue 'dispatch;
	// 830F9378: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F937C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9380: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F9384: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F9388: 409A0028  bne cr6, 0x830f93b0
	if !ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F938C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F9390: 4BFFC811  bl 0x830f5ba0
	ctx.lr = 0x830F9394;
	sub_830F5BA0(ctx, base);
	// 830F9394: 4800001C  b 0x830f93b0
	pc = 0x830F93B0; continue 'dispatch;
	// 830F9398: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830F939C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F93A0: 419A0010  beq cr6, 0x830f93b0
	if ctx.cr[6].eq {
	pc = 0x830F93B0; continue 'dispatch;
	}
	// 830F93A4: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F93A8: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 830F93AC: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830F93B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F93B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830F93B8: 480AEE04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F93C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F93C0 size=248
    let mut pc: u32 = 0x830F93C0;
    'dispatch: loop {
        match pc {
            0x830F93C0 => {
    //   block [0x830F93C0..0x830F94B8)
	// 830F93C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F93C4: 480AED9D  bl 0x831a8160
	ctx.lr = 0x830F93C8;
	sub_831A8130(ctx, base);
	// 830F93C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F93CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830F93D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F93D4: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 830F93D8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F93DC: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 830F93E0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F93E4: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 830F93E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F93EC: 388B969C  addi r4, r11, -0x6964
	ctx.r[4].s64 = ctx.r[11].s64 + -26980;
	// 830F93F0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F93F4: 4BFE4C2D  bl 0x830de020
	ctx.lr = 0x830F93F8;
	sub_830DE020(ctx, base);
	// 830F93F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F93FC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830F9400: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F9404: 40990088  ble cr6, 0x830f948c
	if !ctx.cr[6].gt {
	pc = 0x830F948C; continue 'dispatch;
	}
	// 830F9408: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F940C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 830F9410: 3B8B9670  addi r28, r11, -0x6990
	ctx.r[28].s64 = ctx.r[11].s64 + -27024;
	// 830F9414: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9418: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F941C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830F9420: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830F9424: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F9428: C0CB0014  lfs f6, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 830F942C: C0AB0010  lfs f5, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 830F9430: C08B000C  lfs f4, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830F9434: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830F9438: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F943C: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F9440: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830F9444: D8C10048  stfd f6, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.f[6].u64 ) };
	// 830F9448: E9410048  ld r10, 0x48(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(72 as u32) ) };
	// 830F944C: D8A10040  stfd f5, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.f[5].u64 ) };
	// 830F9450: E9210040  ld r9, 0x40(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(64 as u32) ) };
	// 830F9454: D8810038  stfd f4, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[4].u64 ) };
	// 830F9458: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 830F945C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830F9460: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830F9464: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830F9468: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830F946C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830F9470: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830F9474: 4BFE4BAD  bl 0x830de020
	ctx.lr = 0x830F9478;
	sub_830DE020(ctx, base);
	// 830F9478: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F947C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830F9480: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 830F9484: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F9488: 4198FF8C  blt cr6, 0x830f9414
	if ctx.cr[6].lt {
	pc = 0x830F9414; continue 'dispatch;
	}
	// 830F948C: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830F9490: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830F9494: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830F9498: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830F949C: 4BFD57ED  bl 0x830cec88
	ctx.lr = 0x830F94A0;
	sub_830CEC88(ctx, base);
	// 830F94A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F94A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F94A8: 4BFE4031  bl 0x830dd4d8
	ctx.lr = 0x830F94AC;
	sub_830DD4D8(ctx, base);
	// 830F94AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F94B0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830F94B4: 480AECFC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F94B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F94B8 size=556
    let mut pc: u32 = 0x830F94B8;
    'dispatch: loop {
        match pc {
            0x830F94B8 => {
    //   block [0x830F94B8..0x830F96E4)
	// 830F94B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F94BC: 480AECA1  bl 0x831a815c
	ctx.lr = 0x830F94C0;
	sub_831A8130(ctx, base);
	// 830F94C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F94C4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830F94C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F94CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830F94D0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F94D4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F94D8: 419A0060  beq cr6, 0x830f9538
	if ctx.cr[6].eq {
	pc = 0x830F9538; continue 'dispatch;
	}
	// 830F94DC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830F94E0: 419A0040  beq cr6, 0x830f9520
	if ctx.cr[6].eq {
	pc = 0x830F9520; continue 'dispatch;
	}
	// 830F94E4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830F94E8: 419A0020  beq cr6, 0x830f9508
	if ctx.cr[6].eq {
	pc = 0x830F9508; continue 'dispatch;
	}
	// 830F94EC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F94F0: 409A01C8  bne cr6, 0x830f96b8
	if !ctx.cr[6].eq {
	pc = 0x830F96B8; continue 'dispatch;
	}
	// 830F94F4: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F94F8: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830F94FC: 3B8B849C  addi r28, r11, -0x7b64
	ctx.r[28].s64 = ctx.r[11].s64 + -31588;
	// 830F9500: 3BAA96F8  addi r29, r10, -0x6908
	ctx.r[29].s64 = ctx.r[10].s64 + -26888;
	// 830F9504: 48000044  b 0x830f9548
	pc = 0x830F9548; continue 'dispatch;
	// 830F9508: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F950C: 83DF0048  lwz r30, 0x48(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F9510: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830F9514: 3B8B8484  addi r28, r11, -0x7b7c
	ctx.r[28].s64 = ctx.r[11].s64 + -31612;
	// 830F9518: 3BAA96D8  addi r29, r10, -0x6928
	ctx.r[29].s64 = ctx.r[10].s64 + -26920;
	// 830F951C: 48000030  b 0x830f954c
	pc = 0x830F954C; continue 'dispatch;
	// 830F9520: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F9524: 83DF0048  lwz r30, 0x48(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830F9528: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830F952C: 3B8B84C8  addi r28, r11, -0x7b38
	ctx.r[28].s64 = ctx.r[11].s64 + -31544;
	// 830F9530: 3BAA96BC  addi r29, r10, -0x6944
	ctx.r[29].s64 = ctx.r[10].s64 + -26948;
	// 830F9534: 48000018  b 0x830f954c
	pc = 0x830F954C; continue 'dispatch;
	// 830F9538: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830F953C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830F9540: 3B8B84B8  addi r28, r11, -0x7b48
	ctx.r[28].s64 = ctx.r[11].s64 + -31560;
	// 830F9544: 3BAA96A4  addi r29, r10, -0x695c
	ctx.r[29].s64 = ctx.r[10].s64 + -26972;
	// 830F9548: 83DF004C  lwz r30, 0x4c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830F954C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830F9550: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F9554: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F9558: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830F955C: 419A00FC  beq cr6, 0x830f9658
	if ctx.cr[6].eq {
	pc = 0x830F9658; continue 'dispatch;
	}
	// 830F9560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F9564: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830F9568: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830F956C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830F9570: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830F9574: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830F9578: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830F957C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830F9580: 480AFB49  bl 0x831a90c8
	ctx.lr = 0x830F9584;
	sub_831A90C8(ctx, base);
	// 830F9584: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830F9588: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F958C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830F9590: 4BFFC301  bl 0x830f5890
	ctx.lr = 0x830F9594;
	sub_830F5890(ctx, base);
	// 830F9594: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F9598: 40820020  bne 0x830f95b8
	if !ctx.cr[0].eq {
	pc = 0x830F95B8; continue 'dispatch;
	}
	// 830F959C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F95A0: 4BFE3F39  bl 0x830dd4d8
	ctx.lr = 0x830F95A4;
	sub_830DD4D8(ctx, base);
	// 830F95A4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F95A8: 4BFE3F31  bl 0x830dd4d8
	ctx.lr = 0x830F95AC;
	sub_830DD4D8(ctx, base);
	// 830F95AC: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F95B0: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830F95B4: 48000108  b 0x830f96bc
	pc = 0x830F96BC; continue 'dispatch;
	// 830F95B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830F95BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F95C0: 3B6B9698  addi r27, r11, -0x6968
	ctx.r[27].s64 = ctx.r[11].s64 + -26984;
	// 830F95C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830F95C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F95CC: 4BFE4A55  bl 0x830de020
	ctx.lr = 0x830F95D0;
	sub_830DE020(ctx, base);
	// 830F95D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F95D4: 480AFAF5  bl 0x831a90c8
	ctx.lr = 0x830F95D8;
	sub_831A90C8(ctx, base);
	// 830F95D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830F95DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F95E0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830F95E4: 4BFFC2AD  bl 0x830f5890
	ctx.lr = 0x830F95E8;
	sub_830F5890(ctx, base);
	// 830F95E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F95EC: 4082000C  bne 0x830f95f8
	if !ctx.cr[0].eq {
	pc = 0x830F95F8; continue 'dispatch;
	}
	// 830F95F0: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830F95F4: 4BFFFFAC  b 0x830f95a0
	pc = 0x830F95A0; continue 'dispatch;
	// 830F95F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F95FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F9600: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830F9604: 4BFE4A1D  bl 0x830de020
	ctx.lr = 0x830F9608;
	sub_830DE020(ctx, base);
	// 830F9608: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F960C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F9610: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9614: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F9618: 4BFE6BA1  bl 0x830e01b8
	ctx.lr = 0x830F961C;
	sub_830E01B8(ctx, base);
	// 830F961C: 83610068  lwz r27, 0x68(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830F9620: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830F9624: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9628: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830F962C: 4BFE6B8D  bl 0x830e01b8
	ctx.lr = 0x830F9630;
	sub_830E01B8(ctx, base);
	// 830F9630: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F9634: 4BFE3EA5  bl 0x830dd4d8
	ctx.lr = 0x830F9638;
	sub_830DD4D8(ctx, base);
	// 830F9638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F963C: 4BFE3E9D  bl 0x830dd4d8
	ctx.lr = 0x830F9640;
	sub_830DD4D8(ctx, base);
	// 830F9640: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9644: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830F9648: 41980010  blt cr6, 0x830f9658
	if ctx.cr[6].lt {
	pc = 0x830F9658; continue 'dispatch;
	}
	// 830F964C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F9650: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830F9654: 4098002C  bge cr6, 0x830f9680
	if !ctx.cr[6].lt {
	pc = 0x830F9680; continue 'dispatch;
	}
	// 830F9658: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F965C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9660: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F9664: 4BFE6B55  bl 0x830e01b8
	ctx.lr = 0x830F9668;
	sub_830E01B8(ctx, base);
	// 830F9668: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830F966C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F9670: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9674: 4BFE6B45  bl 0x830e01b8
	ctx.lr = 0x830F9678;
	sub_830E01B8(ctx, base);
	// 830F9678: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F967C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F9680: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830F9684: 41980040  blt cr6, 0x830f96c4
	if ctx.cr[6].lt {
	pc = 0x830F96C4; continue 'dispatch;
	}
	// 830F9688: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830F968C: 41980038  blt cr6, 0x830f96c4
	if ctx.cr[6].lt {
	pc = 0x830F96C4; continue 'dispatch;
	}
	// 830F9690: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830F9694: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830F9698: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830F969C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830F96A0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830F96A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F96A8: 4BFE6AB1  bl 0x830e0158
	ctx.lr = 0x830F96AC;
	sub_830E0158(ctx, base);
	// 830F96AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F96B0: 4180000C  blt 0x830f96bc
	if ctx.cr[0].lt {
	pc = 0x830F96BC; continue 'dispatch;
	}
	// 830F96B4: 93D90004  stw r30, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830F96B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F96BC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830F96C0: 480AEAEC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
	// 830F96C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830F96C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F96CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830F96D0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 830F96D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F96D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F96DC: 4BFE6A7D  bl 0x830e0158
	ctx.lr = 0x830F96E0;
	sub_830E0158(ctx, base);
	// 830F96E0: 4BFFFFDC  b 0x830f96bc
	pc = 0x830F96BC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F96E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F96E8 size=380
    let mut pc: u32 = 0x830F96E8;
    'dispatch: loop {
        match pc {
            0x830F96E8 => {
    //   block [0x830F96E8..0x830F9864)
	// 830F96E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F96EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F96F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F96F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F96F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F96FC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830F9700: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830F9704: 813F00F0  lwz r9, 0xf0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F9708: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F970C: 7C6B4850  subf r3, r11, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830F9710: 419A0010  beq cr6, 0x830f9720
	if ctx.cr[6].eq {
	pc = 0x830F9720; continue 'dispatch;
	}
	// 830F9714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F9718: 4BFFE189  bl 0x830f78a0
	ctx.lr = 0x830F971C;
	sub_830F78A0(ctx, base);
	// 830F971C: 480000D0  b 0x830f97ec
	pc = 0x830F97EC; continue 'dispatch;
	// 830F9720: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F9724: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F9728: 409A005C  bne cr6, 0x830f9784
	if !ctx.cr[6].eq {
	pc = 0x830F9784; continue 'dispatch;
	}
	// 830F972C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9730: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F9734: 419A0050  beq cr6, 0x830f9784
	if ctx.cr[6].eq {
	pc = 0x830F9784; continue 'dispatch;
	}
	// 830F9738: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F973C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830F9740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F9744: 4BFF3E85  bl 0x830ed5c8
	ctx.lr = 0x830F9748;
	sub_830ED5C8(ctx, base);
	// 830F9748: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F974C: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F9750: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F9754: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F9758: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F975C: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 830F9760: C1BF004C  lfs f13, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F9764: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F9768: EC206024  fdivs f1, f0, f12
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830F976C: 480B259D  bl 0x831abd08
	ctx.lr = 0x830F9770;
	sub_831ABD08(ctx, base);
	// 830F9770: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F9774: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830F9778: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 830F977C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F9780: 48000060  b 0x830f97e0
	pc = 0x830F97E0; continue 'dispatch;
	// 830F9784: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830F9788: 409A0064  bne cr6, 0x830f97ec
	if !ctx.cr[6].eq {
	pc = 0x830F97EC; continue 'dispatch;
	}
	// 830F978C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830F9790: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F9794: 419A0058  beq cr6, 0x830f97ec
	if ctx.cr[6].eq {
	pc = 0x830F97EC; continue 'dispatch;
	}
	// 830F9798: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F979C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F97A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F97A4: 4BFF3E25  bl 0x830ed5c8
	ctx.lr = 0x830F97A8;
	sub_830ED5C8(ctx, base);
	// 830F97A8: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830F97AC: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F97B0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830F97B4: C19F0058  lfs f12, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830F97B8: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830F97BC: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 830F97C0: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830F97C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830F97C8: EC206024  fdivs f1, f0, f12
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830F97CC: 480B253D  bl 0x831abd08
	ctx.lr = 0x830F97D0;
	sub_831ABD08(ctx, base);
	// 830F97D0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830F97D4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830F97D8: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 830F97DC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F97E0: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830F97E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830F97E8: 7C6B5050  subf r3, r11, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830F97EC: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830F97F0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830F97F4: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830F97F8: 419A0014  beq cr6, 0x830f980c
	if ctx.cr[6].eq {
	pc = 0x830F980C; continue 'dispatch;
	}
	// 830F97FC: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 830F9800: 419A000C  beq cr6, 0x830f980c
	if ctx.cr[6].eq {
	pc = 0x830F980C; continue 'dispatch;
	}
	// 830F9804: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 830F9808: 409A0008  bne cr6, 0x830f9810
	if !ctx.cr[6].eq {
	pc = 0x830F9810; continue 'dispatch;
	}
	// 830F980C: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830F9810: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F9814: 419A0030  beq cr6, 0x830f9844
	if ctx.cr[6].eq {
	pc = 0x830F9844; continue 'dispatch;
	}
	// 830F9818: 546A083E  rotlwi r10, r3, 1
	ctx.r[10].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830F981C: 7D235BD6  divw r9, r3, r11
	ctx.r[9].s32 = ctx.r[3].s32 / ctx.r[11].s32;
	// 830F9820: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 830F9824: 7D4959D6  mullw r10, r9, r11
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830F9828: 7D694078  andc r9, r11, r8
	ctx.r[9].u64 = ctx.r[11].u64 & !ctx.r[8].u64;
	// 830F982C: 0CCB0000  twi 6, r11, 0
	// 830F9830: 7D4A1851  subf. r10, r10, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F9834: 0CA9FFFF  twi 5, r9, -1
	// 830F9838: 4182000C  beq 0x830f9844
	if ctx.cr[0].eq {
	pc = 0x830F9844; continue 'dispatch;
	}
	// 830F983C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830F9840: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 830F9844: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830F9848: 40980008  bge cr6, 0x830f9850
	if !ctx.cr[6].lt {
	pc = 0x830F9850; continue 'dispatch;
	}
	// 830F984C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F9850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F9854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F9858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F985C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F9860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F9868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F9868 size=236
    let mut pc: u32 = 0x830F9868;
    'dispatch: loop {
        match pc {
            0x830F9868 => {
    //   block [0x830F9868..0x830F9954)
	// 830F9868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F986C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830F9870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830F9874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830F9878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F987C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F9880: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F9884: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830F9888: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F988C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F9890: 419A00A4  beq cr6, 0x830f9934
	if ctx.cr[6].eq {
	pc = 0x830F9934; continue 'dispatch;
	}
	// 830F9894: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9898: 4BFE7309  bl 0x830e0ba0
	ctx.lr = 0x830F989C;
	sub_830E0BA0(ctx, base);
	// 830F989C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F98A0: 41820094  beq 0x830f9934
	if ctx.cr[0].eq {
	pc = 0x830F9934; continue 'dispatch;
	}
	// 830F98A4: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F98A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F98AC: 409A0010  bne cr6, 0x830f98bc
	if !ctx.cr[6].eq {
	pc = 0x830F98BC; continue 'dispatch;
	}
	// 830F98B0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F98B4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830F98B8: 48000084  b 0x830f993c
	pc = 0x830F993C; continue 'dispatch;
	// 830F98BC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F98C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F98C4: 419A0070  beq cr6, 0x830f9934
	if ctx.cr[6].eq {
	pc = 0x830F9934; continue 'dispatch;
	}
	// 830F98C8: 480AF801  bl 0x831a90c8
	ctx.lr = 0x830F98CC;
	sub_831A90C8(ctx, base);
	// 830F98CC: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F98D0: 4099001C  ble cr6, 0x830f98ec
	if !ctx.cr[6].gt {
	pc = 0x830F98EC; continue 'dispatch;
	}
	// 830F98D4: 4BFFFFDC  b 0x830f98b0
	pc = 0x830F98B0; continue 'dispatch;
	// 830F98D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F98DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F98E0: 4BFFEA69  bl 0x830f8348
	ctx.lr = 0x830F98E4;
	sub_830F8348(ctx, base);
	// 830F98E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F98E8: 41800054  blt 0x830f993c
	if ctx.cr[0].lt {
	pc = 0x830F993C; continue 'dispatch;
	}
	// 830F98EC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F98F0: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F98F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F98F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F98FC: 4198FFDC  blt cr6, 0x830f98d8
	if ctx.cr[6].lt {
	pc = 0x830F98D8; continue 'dispatch;
	}
	// 830F9900: 48000018  b 0x830f9918
	pc = 0x830F9918; continue 'dispatch;
	// 830F9904: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F9908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F990C: 4BFFEB1D  bl 0x830f8428
	ctx.lr = 0x830F9910;
	sub_830F8428(ctx, base);
	// 830F9910: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9914: 41800028  blt 0x830f993c
	if ctx.cr[0].lt {
	pc = 0x830F993C; continue 'dispatch;
	}
	// 830F9918: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830F991C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830F9920: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830F9924: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F9928: 4199FFDC  bgt cr6, 0x830f9904
	if ctx.cr[6].gt {
	pc = 0x830F9904; continue 'dispatch;
	}
	// 830F992C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F9930: 4800000C  b 0x830f993c
	pc = 0x830F993C; continue 'dispatch;
	// 830F9934: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F9938: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830F993C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830F9940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830F9944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830F9948: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830F994C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830F9950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F9958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830F9958 size=276
    let mut pc: u32 = 0x830F9958;
    'dispatch: loop {
        match pc {
            0x830F9958 => {
    //   block [0x830F9958..0x830F9A6C)
	// 830F9958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F995C: 480AE805  bl 0x831a8160
	ctx.lr = 0x830F9960;
	sub_831A8130(ctx, base);
	// 830F9960: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F9964: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830F9968: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F996C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830F9970: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830F9974: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 830F9978: 409A0008  bne cr6, 0x830f9980
	if !ctx.cr[6].eq {
	pc = 0x830F9980; continue 'dispatch;
	}
	// 830F997C: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9980: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9984: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830F9988: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830F998C: 419800D4  blt cr6, 0x830f9a60
	if ctx.cr[6].lt {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F9990: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830F9994: 419900CC  bgt cr6, 0x830f9a60
	if ctx.cr[6].gt {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F9998: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830F999C: 419800C4  blt cr6, 0x830f9a60
	if ctx.cr[6].lt {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F99A0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F99A4: 419800BC  blt cr6, 0x830f9a60
	if ctx.cr[6].lt {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F99A8: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 830F99AC: 616BAAAA  ori r11, r11, 0xaaaa
	ctx.r[11].u64 = ctx.r[11].u64 | 43690;
	// 830F99B0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F99B4: 409800AC  bge cr6, 0x830f9a60
	if !ctx.cr[6].lt {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F99B8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F99BC: 7F1C5000  cmpw cr6, r28, r10
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830F99C0: 40990030  ble cr6, 0x830f99f0
	if !ctx.cr[6].gt {
	pc = 0x830F99F0; continue 'dispatch;
	}
	// 830F99C4: 579E083D  rlwinm. r30, r28, 1, 0, 0x1e
	ctx.r[30].u64 = ctx.r[28].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F99C8: 40810098  ble 0x830f9a60
	if !ctx.cr[0].gt {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F99CC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F99D0: 40980090  bge cr6, 0x830f9a60
	if !ctx.cr[6].lt {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F99D4: 1C9E000C  mulli r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 * 12;
	// 830F99D8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F99DC: 4BFE3B15  bl 0x830dd4f0
	ctx.lr = 0x830F99E0;
	sub_830DD4F0(ctx, base);
	// 830F99E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F99E4: 4182007C  beq 0x830f9a60
	if ctx.cr[0].eq {
	pc = 0x830F9A60; continue 'dispatch;
	}
	// 830F99E8: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830F99EC: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830F99F0: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830F99F4: 7D3FE050  subf r9, r31, r28
	ctx.r[9].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 830F99F8: 7FDFDA14  add r30, r31, r27
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 830F99FC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9A00: 7D3B4850  subf r9, r27, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[27].s64;
	// 830F9A04: 1D5E000C  mulli r10, r30, 0xc
	ctx.r[10].s64 = ctx.r[30].s64 * 12;
	// 830F9A08: 1F9F000C  mulli r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 * 12;
	// 830F9A0C: 7C9C5A14  add r4, r28, r11
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830F9A10: 1CA9000C  mulli r5, r9, 0xc
	ctx.r[5].s64 = ctx.r[9].s64 * 12;
	// 830F9A14: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830F9A18: 480B3939  bl 0x831ad350
	ctx.lr = 0x830F9A1C;
	sub_831AD350(ctx, base);
	// 830F9A1C: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830F9A20: 40980038  bge cr6, 0x830f9a58
	if !ctx.cr[6].lt {
	pc = 0x830F9A58; continue 'dispatch;
	}
	// 830F9A24: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 830F9A28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9A2C: 7D7C5A15  add. r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830F9A30: 4182001C  beq 0x830f9a4c
	if ctx.cr[0].eq {
	pc = 0x830F9A4C; continue 'dispatch;
	}
	// 830F9A34: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9A38: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830F9A3C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9A40: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830F9A44: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F9A48: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830F9A4C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830F9A50: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 830F9A54: 4082FFD4  bne 0x830f9a28
	if !ctx.cr[0].eq {
	pc = 0x830F9A28; continue 'dispatch;
	}
	// 830F9A58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830F9A5C: 48000008  b 0x830f9a64
	pc = 0x830F9A64; continue 'dispatch;
	// 830F9A60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830F9A64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830F9A68: 480AE748  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830F9A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830F9A70 size=2172
    let mut pc: u32 = 0x830F9A70;
    'dispatch: loop {
        match pc {
            0x830F9A70 => {
    //   block [0x830F9A70..0x830FA2EC)
	// 830F9A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830F9A74: 480AE6F1  bl 0x831a8164
	ctx.lr = 0x830F9A78;
	sub_831A8130(ctx, base);
	// 830F9A78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830F9A7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830F9A80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830F9A84: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9A88: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 830F9A8C: 419905D8  bgt cr6, 0x830fa064
	if ctx.cr[6].gt {
	pc = 0x830FA064; continue 'dispatch;
	}
	// 830F9A90: 419A0590  beq cr6, 0x830fa020
	if ctx.cr[6].eq {
	pc = 0x830FA020; continue 'dispatch;
	}
	// 830F9A94: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830F9A98: 419904E4  bgt cr6, 0x830f9f7c
	if ctx.cr[6].gt {
	pc = 0x830F9F7C; continue 'dispatch;
	}
	// 830F9A9C: 419A0490  beq cr6, 0x830f9f2c
	if ctx.cr[6].eq {
	pc = 0x830F9F2C; continue 'dispatch;
	}
	// 830F9AA0: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830F9AA4: 419A0420  beq cr6, 0x830f9ec4
	if ctx.cr[6].eq {
	pc = 0x830F9EC4; continue 'dispatch;
	}
	// 830F9AA8: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830F9AAC: 419A0408  beq cr6, 0x830f9eb4
	if ctx.cr[6].eq {
	pc = 0x830F9EB4; continue 'dispatch;
	}
	// 830F9AB0: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830F9AB4: 419A02FC  beq cr6, 0x830f9db0
	if ctx.cr[6].eq {
	pc = 0x830F9DB0; continue 'dispatch;
	}
	// 830F9AB8: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830F9ABC: 419A0060  beq cr6, 0x830f9b1c
	if ctx.cr[6].eq {
	pc = 0x830F9B1C; continue 'dispatch;
	}
	// 830F9AC0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 830F9AC4: 409A081C  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9AC8: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F9ACC: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9AD0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830F9AD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830F9AD8: 409A0808  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9ADC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9AE0: 4BFD5131  bl 0x830cec10
	ctx.lr = 0x830F9AE4;
	sub_830CEC10(ctx, base);
	// 830F9AE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9AE8: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830F9AEC: 409A07F4  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9AF0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F9AF4: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F9AF8: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830F9AFC: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830F9B00: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830F9B04: 419A07DC  beq cr6, 0x830fa2e0
	if ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9B08: 80BF0044  lwz r5, 0x44(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830F9B0C: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 830F9B10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B14: 4BFE88D5  bl 0x830e23e8
	ctx.lr = 0x830F9B18;
	sub_830E23E8(ctx, base);
	// 830F9B18: 480007C8  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9B1C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9B20: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B24: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830F9B28: 419A00C0  beq cr6, 0x830f9be8
	if ctx.cr[6].eq {
	pc = 0x830F9BE8; continue 'dispatch;
	}
	// 830F9B2C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830F9B30: 419A0034  beq cr6, 0x830f9b64
	if ctx.cr[6].eq {
	pc = 0x830F9B64; continue 'dispatch;
	}
	// 830F9B34: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 830F9B38: 409A07A8  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9B3C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F9B40: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B44: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B48: 4BFE6329  bl 0x830dfe70
	ctx.lr = 0x830F9B4C;
	sub_830DFE70(ctx, base);
	// 830F9B4C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9B50: 40820790  bne 0x830fa2e0
	if !ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9B54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F9B58: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B5C: 4BFE550D  bl 0x830df068
	ctx.lr = 0x830F9B60;
	sub_830DF068(ctx, base);
	// 830F9B60: 48000780  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9B64: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830F9B68: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F9B6C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9B70: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B74: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B78: 4BFE6279  bl 0x830dfdf0
	ctx.lr = 0x830F9B7C;
	sub_830DFDF0(ctx, base);
	// 830F9B7C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9B80: 41820760  beq 0x830fa2e0
	if ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9B84: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830F9B88: 419A0018  beq cr6, 0x830f9ba0
	if ctx.cr[6].eq {
	pc = 0x830F9BA0; continue 'dispatch;
	}
	// 830F9B8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F9B90: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9B94: 4BFE62DD  bl 0x830dfe70
	ctx.lr = 0x830F9B98;
	sub_830DFE70(ctx, base);
	// 830F9B98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9B9C: 40820010  bne 0x830f9bac
	if !ctx.cr[0].eq {
	pc = 0x830F9BAC; continue 'dispatch;
	}
	// 830F9BA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F9BA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9BA8: 4BFE54C1  bl 0x830df068
	ctx.lr = 0x830F9BAC;
	sub_830DF068(ctx, base);
	// 830F9BAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9BB0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F9BB4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830F9BB8: 419A0728  beq cr6, 0x830fa2e0
	if ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9BBC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F9BC0: 4BFE5521  bl 0x830df0e0
	ctx.lr = 0x830F9BC4;
	sub_830DF0E0(ctx, base);
	// 830F9BC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830F9BC8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F9BCC: 4BFE5515  bl 0x830df0e0
	ctx.lr = 0x830F9BD0;
	sub_830DF0E0(ctx, base);
	// 830F9BD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830F9BD4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9BD8: 4BFD5039  bl 0x830cec10
	ctx.lr = 0x830F9BDC;
	sub_830CEC10(ctx, base);
	// 830F9BDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F9BE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F9BE4: 48000658  b 0x830fa23c
	pc = 0x830FA23C; continue 'dispatch;
	// 830F9BE8: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F9BEC: 554A06F6  rlwinm r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830F9BF0: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 830F9BF4: 419A06EC  beq cr6, 0x830fa2e0
	if ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9BF8: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9BFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9C00: 4BFE5779  bl 0x830df378
	ctx.lr = 0x830F9C04;
	sub_830DF378(ctx, base);
	// 830F9C04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F9C08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9C0C: 4BFE5735  bl 0x830df340
	ctx.lr = 0x830F9C10;
	sub_830DF340(ctx, base);
	// 830F9C10: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9C14: 408200D0  bne 0x830f9ce4
	if !ctx.cr[0].eq {
	pc = 0x830F9CE4; continue 'dispatch;
	}
	// 830F9C18: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F9C1C: 409A00C8  bne cr6, 0x830f9ce4
	if !ctx.cr[6].eq {
	pc = 0x830F9CE4; continue 'dispatch;
	}
	// 830F9C20: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F9C24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9C28: 808BC0B8  lwz r4, -0x3f48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16200 as u32) ) } as u64;
	// 830F9C2C: 4BFD4F45  bl 0x830ceb70
	ctx.lr = 0x830F9C30;
	sub_830CEB70(ctx, base);
	// 830F9C30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F9C34: 418206AC  beq 0x830fa2e0
	if ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9C38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F9C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9C40: 4BFEDD21  bl 0x830e7960
	ctx.lr = 0x830F9C44;
	sub_830E7960(ctx, base);
	// 830F9C44: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830F9C48: 40800010  bge 0x830f9c58
	if !ctx.cr[0].lt {
	pc = 0x830F9C58; continue 'dispatch;
	}
	// 830F9C4C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830F9C50: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 830F9C54: 48000690  b 0x830fa2e4
	pc = 0x830FA2E4; continue 'dispatch;
	// 830F9C58: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 830F9C5C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 830F9C60: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 830F9C64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830F9C68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9C6C: 4BFEE5C5  bl 0x830e8230
	ctx.lr = 0x830F9C70;
	sub_830E8230(ctx, base);
	// 830F9C70: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9C74: 41800670  blt 0x830fa2e4
	if ctx.cr[0].lt {
	pc = 0x830FA2E4; continue 'dispatch;
	}
	// 830F9C78: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9C7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830F9C80: 419A0660  beq cr6, 0x830fa2e0
	if ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9C84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F9C88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830F9C8C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F9C90: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 830F9C94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830F9C98: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9C9C: 4BFEDB15  bl 0x830e77b0
	ctx.lr = 0x830F9CA0;
	sub_830E77B0(ctx, base);
	// 830F9CA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830F9CA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F9CA8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F9CAC: 4BFEA36D  bl 0x830e4018
	ctx.lr = 0x830F9CB0;
	sub_830E4018(ctx, base);
	// 830F9CB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9CB4: 41800630  blt 0x830fa2e4
	if ctx.cr[0].lt {
	pc = 0x830FA2E4; continue 'dispatch;
	}
	// 830F9CB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F9CBC: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830F9CC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9CC4: 4BFE6635  bl 0x830e02f8
	ctx.lr = 0x830F9CC8;
	sub_830E02F8(ctx, base);
	// 830F9CC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F9CCC: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F9CD0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9CD4: 4BFE6625  bl 0x830e02f8
	ctx.lr = 0x830F9CD8;
	sub_830E02F8(ctx, base);
	// 830F9CD8: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9CDC: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F9CE0: 480000B8  b 0x830f9d98
	pc = 0x830F9D98; continue 'dispatch;
	// 830F9CE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F9CE8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830F9CEC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F9CF0: 419A0024  beq cr6, 0x830f9d14
	if ctx.cr[6].eq {
	pc = 0x830F9D14; continue 'dispatch;
	}
	// 830F9CF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9CF8: 4BFD4F19  bl 0x830cec10
	ctx.lr = 0x830F9CFC;
	sub_830CEC10(ctx, base);
	// 830F9CFC: 4BFEE605  bl 0x830e8300
	ctx.lr = 0x830F9D00;
	sub_830E8300(ctx, base);
	// 830F9D00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830F9D04: 38A000FD  li r5, 0xfd
	ctx.r[5].s64 = 253;
	// 830F9D08: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9D0C: 4BFEA9F5  bl 0x830e4700
	ctx.lr = 0x830F9D10;
	sub_830E4700(ctx, base);
	// 830F9D10: 480005D0  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9D14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830F9D18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9D1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830F9D20: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 830F9D24: 4BFE568D  bl 0x830df3b0
	ctx.lr = 0x830F9D28;
	sub_830DF3B0(ctx, base);
	// 830F9D28: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830F9D2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9D30: 4BFEDA81  bl 0x830e77b0
	ctx.lr = 0x830F9D34;
	sub_830E77B0(ctx, base);
	// 830F9D34: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830F9D38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830F9D3C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830F9D40: 4BFEA2D9  bl 0x830e4018
	ctx.lr = 0x830F9D44;
	sub_830E4018(ctx, base);
	// 830F9D44: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9D48: 4180059C  blt 0x830fa2e4
	if ctx.cr[0].lt {
	pc = 0x830FA2E4; continue 'dispatch;
	}
	// 830F9D4C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830F9D50: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830F9D54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9D58: 4BFE56C9  bl 0x830df420
	ctx.lr = 0x830F9D5C;
	sub_830DF420(ctx, base);
	// 830F9D5C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9D60: 41800024  blt 0x830f9d84
	if ctx.cr[0].lt {
	pc = 0x830F9D84; continue 'dispatch;
	}
	// 830F9D64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830F9D68: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830F9D6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9D70: 4BFE6589  bl 0x830e02f8
	ctx.lr = 0x830F9D74;
	sub_830E02F8(ctx, base);
	// 830F9D74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F9D78: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830F9D7C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9D80: 4BFE6579  bl 0x830e02f8
	ctx.lr = 0x830F9D84;
	sub_830E02F8(ctx, base);
	// 830F9D84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830F9D88: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9D8C: 4BFE565D  bl 0x830df3e8
	ctx.lr = 0x830F9D90;
	sub_830DF3E8(ctx, base);
	// 830F9D90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830F9D94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830F9D98: 38C000FD  li r6, 0xfd
	ctx.r[6].s64 = 253;
	// 830F9D9C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9DA0: 4BFEA771  bl 0x830e4510
	ctx.lr = 0x830F9DA4;
	sub_830E4510(ctx, base);
	// 830F9DA4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9DA8: 40800538  bge 0x830fa2e0
	if !ctx.cr[0].lt {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9DAC: 48000538  b 0x830fa2e4
	pc = 0x830FA2E4; continue 'dispatch;
	// 830F9DB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F9DB4: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9DB8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F9DBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9DC0: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9DC4: 4BFD4E4D  bl 0x830cec10
	ctx.lr = 0x830F9DC8;
	sub_830CEC10(ctx, base);
	// 830F9DC8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830F9DCC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830F9DD0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 830F9DD4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830F9DD8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830F9DDC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830F9DE0: 4BFECEA9  bl 0x830e6c88
	ctx.lr = 0x830F9DE4;
	sub_830E6C88(ctx, base);
	// 830F9DE4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830F9DE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F9DEC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830F9DF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830F9DF4: 4BFE5965  bl 0x830df758
	ctx.lr = 0x830F9DF8;
	sub_830DF758(ctx, base);
	// 830F9DF8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830F9DFC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9E00: 4BFDBF59  bl 0x830d5d58
	ctx.lr = 0x830F9E04;
	sub_830D5D58(ctx, base);
	// 830F9E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830F9E08: 4BFEBE31  bl 0x830e5c38
	ctx.lr = 0x830F9E0C;
	sub_830E5C38(ctx, base);
	// 830F9E0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9E10: 4182001C  beq 0x830f9e2c
	if ctx.cr[0].eq {
	pc = 0x830F9E2C; continue 'dispatch;
	}
	// 830F9E14: 889D0004  lbz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9E18: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830F9E1C: 4BFE8E05  bl 0x830e2c20
	ctx.lr = 0x830F9E20;
	sub_830E2C20(ctx, base);
	// 830F9E20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9E24: 4180000C  blt 0x830f9e30
	if ctx.cr[0].lt {
	pc = 0x830F9E30; continue 'dispatch;
	}
	// 830F9E28: 480004B8  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9E2C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830F9E30: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9E34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9E38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830F9E3C: 419A0024  beq cr6, 0x830f9e60
	if ctx.cr[6].eq {
	pc = 0x830F9E60; continue 'dispatch;
	}
	// 830F9E40: 4800C2F1  bl 0x83106130
	ctx.lr = 0x830F9E44;
	sub_83106130(ctx, base);
	// 830F9E44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F9E48: 41820058  beq 0x830f9ea0
	if ctx.cr[0].eq {
	pc = 0x830F9EA0; continue 'dispatch;
	}
	// 830F9E4C: 889D0004  lbz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9E50: 4BFE8DD1  bl 0x830e2c20
	ctx.lr = 0x830F9E54;
	sub_830E2C20(ctx, base);
	// 830F9E54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9E58: 41800048  blt 0x830f9ea0
	if ctx.cr[0].lt {
	pc = 0x830F9EA0; continue 'dispatch;
	}
	// 830F9E5C: 48000484  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9E60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F9E64: 4BFE596D  bl 0x830df7d0
	ctx.lr = 0x830F9E68;
	sub_830DF7D0(ctx, base);
	// 830F9E68: 4800002C  b 0x830f9e94
	pc = 0x830F9E94; continue 'dispatch;
	// 830F9E6C: 4BFE4F9D  bl 0x830dee08
	ctx.lr = 0x830F9E70;
	sub_830DEE08(ctx, base);
	// 830F9E70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830F9E74: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9E78: 889D0004  lbz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830F9E7C: 4BFE9DE5  bl 0x830e3c60
	ctx.lr = 0x830F9E80;
	sub_830E3C60(ctx, base);
	// 830F9E80: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9E84: 4080045C  bge 0x830fa2e0
	if !ctx.cr[0].lt {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9E88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F9E8C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9E90: 4BFE5A31  bl 0x830df8c0
	ctx.lr = 0x830F9E94;
	sub_830DF8C0(ctx, base);
	// 830F9E94: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830F9E9C: 409AFFD0  bne cr6, 0x830f9e6c
	if !ctx.cr[6].eq {
	pc = 0x830F9E6C; continue 'dispatch;
	}
	// 830F9EA0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9EA4: 4BFD4D6D  bl 0x830cec10
	ctx.lr = 0x830F9EA8;
	sub_830CEC10(ctx, base);
	// 830F9EA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830F9EAC: 4BFEDF65  bl 0x830e7e10
	ctx.lr = 0x830F9EB0;
	sub_830E7E10(ctx, base);
	// 830F9EB0: 48000430  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9EB4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830F9EB8: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 830F9EBC: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830F9EC0: 48000420  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9EC4: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9EC8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F9ECC: 808BC078  lwz r4, -0x3f88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16264 as u32) ) } as u64;
	// 830F9ED0: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9ED4: 4BFD4C9D  bl 0x830ceb70
	ctx.lr = 0x830F9ED8;
	sub_830CEB70(ctx, base);
	// 830F9ED8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830F9EDC: 41820404  beq 0x830fa2e0
	if ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9EE0: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 830F9EE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9EE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830F9EEC: 4BFEBCDD  bl 0x830e5bc8
	ctx.lr = 0x830F9EF0;
	sub_830E5BC8(ctx, base);
	// 830F9EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F9EF4: 4BFE527D  bl 0x830df170
	ctx.lr = 0x830F9EF8;
	sub_830DF170(ctx, base);
	// 830F9EF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9EFC: 418203E4  beq 0x830fa2e0
	if ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9F00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830F9F04: 4BFD4D0D  bl 0x830cec10
	ctx.lr = 0x830F9F08;
	sub_830CEC10(ctx, base);
	// 830F9F08: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 830F9F0C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830F9F10: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830F9F14: 48005CBD  bl 0x830ffbd0
	ctx.lr = 0x830F9F18;
	sub_830FFBD0(ctx, base);
	// 830F9F18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9F1C: 408203C4  bne 0x830fa2e0
	if !ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9F20: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830F9F24: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830F9F28: 480003BC  b 0x830fa2e4
	pc = 0x830FA2E4; continue 'dispatch;
	// 830F9F2C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830F9F30: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9F34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9F38: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830F9F3C: 4BFD4C35  bl 0x830ceb70
	ctx.lr = 0x830F9F40;
	sub_830CEB70(ctx, base);
	// 830F9F40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830F9F44: 4182039C  beq 0x830fa2e0
	if ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9F48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830F9F4C: 4BFD4525  bl 0x830ce470
	ctx.lr = 0x830F9F50;
	sub_830CE470(ctx, base);
	// 830F9F50: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830F9F58: 419A0388  beq cr6, 0x830fa2e0
	if ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9F5C: C05E000C  lfs f2, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F9F60: C03E0008  lfs f1, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F9F64: 4BFEB8F5  bl 0x830e5858
	ctx.lr = 0x830F9F68;
	sub_830E5858(ctx, base);
	// 830F9F68: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830F9F6C: C05E000C  lfs f2, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830F9F70: C03E0008  lfs f1, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830F9F74: 4BFEF555  bl 0x830e94c8
	ctx.lr = 0x830F9F78;
	sub_830E94C8(ctx, base);
	// 830F9F78: 48000368  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9F7C: 2B0B0018  cmplwi cr6, r11, 0x18
	ctx.cr[6].compare_u32(ctx.r[11].u32, 24 as u32, &mut ctx.xer);
	// 830F9F80: 419A0080  beq cr6, 0x830fa000
	if ctx.cr[6].eq {
	pc = 0x830FA000; continue 'dispatch;
	}
	// 830F9F84: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 830F9F88: 419A0054  beq cr6, 0x830f9fdc
	if ctx.cr[6].eq {
	pc = 0x830F9FDC; continue 'dispatch;
	}
	// 830F9F8C: 2B0B001B  cmplwi cr6, r11, 0x1b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 27 as u32, &mut ctx.xer);
	// 830F9F90: 419A0034  beq cr6, 0x830f9fc4
	if ctx.cr[6].eq {
	pc = 0x830F9FC4; continue 'dispatch;
	}
	// 830F9F94: 2B0B001C  cmplwi cr6, r11, 0x1c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 28 as u32, &mut ctx.xer);
	// 830F9F98: 409A0348  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830F9F9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F9FA0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9FA4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F9FA8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F9FAC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830F9FB0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9FB4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9FB8: 4BFD4C59  bl 0x830cec10
	ctx.lr = 0x830F9FBC;
	sub_830CEC10(ctx, base);
	// 830F9FBC: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 830F9FC0: 48000320  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9FC4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9FC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830F9FCC: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830F9FD0: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830F9FD4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830F9FD8: 48000308  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830F9FDC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 830F9FE0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830F9FE4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830F9FE8: 4BFD4CA1  bl 0x830cec88
	ctx.lr = 0x830F9FEC;
	sub_830CEC88(ctx, base);
	// 830F9FEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830F9FF0: 418002F4  blt 0x830fa2e4
	if ctx.cr[0].lt {
	pc = 0x830FA2E4; continue 'dispatch;
	}
	// 830F9FF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830F9FF8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830F9FFC: 480002E4  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA000: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FA004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FA008: 419A02D8  beq cr6, 0x830fa2e0
	if ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA00C: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA010: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830FA014: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830FA018: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830FA01C: 480002C4  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA020: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 830FA024: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA02C: 4BFFF48D  bl 0x830f94b8
	ctx.lr = 0x830FA030;
	sub_830F94B8(ctx, base);
	// 830FA030: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FA034: 41800028  blt 0x830fa05c
	if ctx.cr[0].lt {
	pc = 0x830FA05C; continue 'dispatch;
	}
	// 830FA038: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FA03C: 556B0738  rlwinm r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830FA040: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 830FA044: 409A0018  bne cr6, 0x830fa05c
	if !ctx.cr[6].eq {
	pc = 0x830FA05C; continue 'dispatch;
	}
	// 830FA048: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 830FA04C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA050: 38A000FA  li r5, 0xfa
	ctx.r[5].s64 = 250;
	// 830FA054: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 830FA058: 48005EA1  bl 0x830ffef8
	ctx.lr = 0x830FA05C;
	sub_830FFEF8(ctx, base);
	// 830FA05C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FA060: 48000284  b 0x830fa2e4
	pc = 0x830FA2E4; continue 'dispatch;
	// 830FA064: 2B0B0025  cmplwi cr6, r11, 0x25
	ctx.cr[6].compare_u32(ctx.r[11].u32, 37 as u32, &mut ctx.xer);
	// 830FA068: 41990130  bgt cr6, 0x830fa198
	if ctx.cr[6].gt {
	pc = 0x830FA198; continue 'dispatch;
	}
	// 830FA06C: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830FA070: 409800E0  bge cr6, 0x830fa150
	if !ctx.cr[6].lt {
	pc = 0x830FA150; continue 'dispatch;
	}
	// 830FA074: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 830FA078: 419A00AC  beq cr6, 0x830fa124
	if ctx.cr[6].eq {
	pc = 0x830FA124; continue 'dispatch;
	}
	// 830FA07C: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 830FA080: 419A0088  beq cr6, 0x830fa108
	if ctx.cr[6].eq {
	pc = 0x830FA108; continue 'dispatch;
	}
	// 830FA084: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830FA088: 419A0024  beq cr6, 0x830fa0ac
	if ctx.cr[6].eq {
	pc = 0x830FA0AC; continue 'dispatch;
	}
	// 830FA08C: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 830FA090: 419A0014  beq cr6, 0x830fa0a4
	if ctx.cr[6].eq {
	pc = 0x830FA0A4; continue 'dispatch;
	}
	// 830FA094: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 830FA098: 409A0248  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA09C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 830FA0A0: 4BFFFF40  b 0x830f9fe0
	pc = 0x830F9FE0; continue 'dispatch;
	// 830FA0A4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FA0A8: 4BFFFF5C  b 0x830fa004
	pc = 0x830FA004; continue 'dispatch;
	// 830FA0AC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FA0B0: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA0B4: 4082022C  bne 0x830fa2e0
	if !ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA0B8: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA0BC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FA0C0: 808BC078  lwz r4, -0x3f88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16264 as u32) ) } as u64;
	// 830FA0C4: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA0C8: 4BFD4AA9  bl 0x830ceb70
	ctx.lr = 0x830FA0CC;
	sub_830CEB70(ctx, base);
	// 830FA0CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FA0D0: 41820210  beq 0x830fa2e0
	if ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA0D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA0D8: 4BFEBA91  bl 0x830e5b68
	ctx.lr = 0x830FA0DC;
	sub_830E5B68(ctx, base);
	// 830FA0DC: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830FA0E0: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830FA0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FA0E8: 4BFE5039  bl 0x830df120
	ctx.lr = 0x830FA0EC;
	sub_830DF120(ctx, base);
	// 830FA0EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FA0F0: 4BFD4B21  bl 0x830cec10
	ctx.lr = 0x830FA0F4;
	sub_830CEC10(ctx, base);
	// 830FA0F4: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 830FA0F8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830FA0FC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830FA100: 4BFFB4E1  bl 0x830f55e0
	ctx.lr = 0x830FA104;
	sub_830F55E0(ctx, base);
	// 830FA104: 480001DC  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA108: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FA10C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FA110: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA114: 4BFF085D  bl 0x830ea970
	ctx.lr = 0x830FA118;
	sub_830EA970(ctx, base);
	// 830FA118: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FA11C: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830FA120: 4BFFFD9C  b 0x830f9ebc
	pc = 0x830F9EBC; continue 'dispatch;
	// 830FA124: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FA128: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FA12C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FA130: 556B0738  rlwinm r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830FA134: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 830FA138: 409A01A8  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA13C: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 830FA140: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA144: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 830FA148: 48005E71  bl 0x830fffb8
	ctx.lr = 0x830FA14C;
	sub_830FFFB8(ctx, base);
	// 830FA14C: 48000194  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA150: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA154: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FA158: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA15C: 40990184  ble cr6, 0x830fa2e0
	if !ctx.cr[6].gt {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA160: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 830FA164: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FA168: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FA16C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA170: 4BFDBA59  bl 0x830d5bc8
	ctx.lr = 0x830FA174;
	sub_830D5BC8(ctx, base);
	// 830FA174: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FA178: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA17C: 409A0164  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA180: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA184: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830FA188: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830FA18C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA190: 4198FFD4  blt cr6, 0x830fa164
	if ctx.cr[6].lt {
	pc = 0x830FA164; continue 'dispatch;
	}
	// 830FA194: 4800014C  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA198: 2B0B0027  cmplwi cr6, r11, 0x27
	ctx.cr[6].compare_u32(ctx.r[11].u32, 39 as u32, &mut ctx.xer);
	// 830FA19C: 419A0100  beq cr6, 0x830fa29c
	if ctx.cr[6].eq {
	pc = 0x830FA29C; continue 'dispatch;
	}
	// 830FA1A0: 2B0B002A  cmplwi cr6, r11, 0x2a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 42 as u32, &mut ctx.xer);
	// 830FA1A4: 419A00E4  beq cr6, 0x830fa288
	if ctx.cr[6].eq {
	pc = 0x830FA288; continue 'dispatch;
	}
	// 830FA1A8: 2B0B07D7  cmplwi cr6, r11, 0x7d7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2007 as u32, &mut ctx.xer);
	// 830FA1AC: 419A0098  beq cr6, 0x830fa244
	if ctx.cr[6].eq {
	pc = 0x830FA244; continue 'dispatch;
	}
	// 830FA1B0: 2B0B07D8  cmplwi cr6, r11, 0x7d8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2008 as u32, &mut ctx.xer);
	// 830FA1B4: 409A012C  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA1B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FA1BC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA1C0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FA1C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA1C8: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA1CC: 4BFED88D  bl 0x830e7a58
	ctx.lr = 0x830FA1D0;
	sub_830E7A58(ctx, base);
	// 830FA1D0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FA1D4: 40820010  bne 0x830fa1e4
	if !ctx.cr[0].eq {
	pc = 0x830FA1E4; continue 'dispatch;
	}
	// 830FA1D8: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830FA1DC: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830FA1E0: 48000104  b 0x830fa2e4
	pc = 0x830FA2E4; continue 'dispatch;
	// 830FA1E4: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FA1E8: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830FA1EC: 419A00F4  beq cr6, 0x830fa2e0
	if ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA1F0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830FA1F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA1F8: 4BFE72B9  bl 0x830e14b0
	ctx.lr = 0x830FA1FC;
	sub_830E14B0(ctx, base);
	// 830FA1FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FA200: 41820014  beq 0x830fa214
	if ctx.cr[0].eq {
	pc = 0x830FA214; continue 'dispatch;
	}
	// 830FA204: 4BFE4CFD  bl 0x830def00
	ctx.lr = 0x830FA208;
	sub_830DEF00(ctx, base);
	// 830FA208: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FA20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FA210: 4BFE8A11  bl 0x830e2c20
	ctx.lr = 0x830FA214;
	sub_830E2C20(ctx, base);
	// 830FA214: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FA218: 4BFE4EC9  bl 0x830df0e0
	ctx.lr = 0x830FA21C;
	sub_830DF0E0(ctx, base);
	// 830FA21C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FA220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FA224: 4BFE4EBD  bl 0x830df0e0
	ctx.lr = 0x830FA228;
	sub_830DF0E0(ctx, base);
	// 830FA228: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FA22C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA230: 4BFD49E1  bl 0x830cec10
	ctx.lr = 0x830FA234;
	sub_830CEC10(ctx, base);
	// 830FA234: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FA238: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830FA23C: 4BFED7CD  bl 0x830e7a08
	ctx.lr = 0x830FA240;
	sub_830E7A08(ctx, base);
	// 830FA240: 480000A0  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA244: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FA248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA24C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FA250: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 830FA254: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830FA258: 4BFEB9E1  bl 0x830e5c38
	ctx.lr = 0x830FA25C;
	sub_830E5C38(ctx, base);
	// 830FA25C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA260: 41820014  beq 0x830fa274
	if ctx.cr[0].eq {
	pc = 0x830FA274; continue 'dispatch;
	}
	// 830FA264: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FA268: 4BFE4E79  bl 0x830df0e0
	ctx.lr = 0x830FA26C;
	sub_830DF0E0(ctx, base);
	// 830FA26C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FA270: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830FA274: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA278: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830FA27C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA280: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830FA284: 4800005C  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA288: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FA28C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA290: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FA294: 4BFF0795  bl 0x830eaa28
	ctx.lr = 0x830FA298;
	sub_830EAA28(ctx, base);
	// 830FA298: 48000048  b 0x830fa2e0
	pc = 0x830FA2E0; continue 'dispatch;
	// 830FA29C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA2A0: 3D40AABB  lis r10, -0x5545
	ctx.r[10].s64 = -1430585344;
	// 830FA2A4: 6144CCDD  ori r4, r10, 0xccdd
	ctx.r[4].u64 = ctx.r[10].u64 | 52445;
	// 830FA2A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA2AC: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830FA2B0: 409A0030  bne cr6, 0x830fa2e0
	if !ctx.cr[6].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA2B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FA2B8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FA2BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA2C0: 48005CF9  bl 0x830fffb8
	ctx.lr = 0x830FA2C4;
	sub_830FFFB8(ctx, base);
	// 830FA2C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA2C8: 4BFE53B1  bl 0x830df678
	ctx.lr = 0x830FA2CC;
	sub_830DF678(ctx, base);
	// 830FA2CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA2D0: 40820010  bne 0x830fa2e0
	if !ctx.cr[0].eq {
	pc = 0x830FA2E0; continue 'dispatch;
	}
	// 830FA2D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FA2D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA2DC: 4BFE5345  bl 0x830df620
	ctx.lr = 0x830FA2E0;
	sub_830DF620(ctx, base);
	// 830FA2E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FA2E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830FA2E8: 480ADECC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FA2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FA2F0 size=1128
    let mut pc: u32 = 0x830FA2F0;
    'dispatch: loop {
        match pc {
            0x830FA2F0 => {
    //   block [0x830FA2F0..0x830FA758)
	// 830FA2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FA2F4: 480ADE65  bl 0x831a8158
	ctx.lr = 0x830FA2F8;
	sub_831A8130(ctx, base);
	// 830FA2F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FA2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FA300: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA304: 83BF00F0  lwz r29, 0xf0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FA308: 4BFD4909  bl 0x830cec10
	ctx.lr = 0x830FA30C;
	sub_830CEC10(ctx, base);
	// 830FA30C: 4BFED795  bl 0x830e7aa0
	ctx.lr = 0x830FA310;
	sub_830E7AA0(ctx, base);
	// 830FA310: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FA314: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FA318: 907F00F0  stw r3, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 830FA31C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA320: 419A0014  beq cr6, 0x830fa334
	if ctx.cr[6].eq {
	pc = 0x830FA334; continue 'dispatch;
	}
	// 830FA324: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 830FA328: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 830FA32C: 93DF00D4  stw r30, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	// 830FA330: 93DF00D8  stw r30, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 830FA334: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FA338: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA33C: 409A009C  bne cr6, 0x830fa3d8
	if !ctx.cr[6].eq {
	pc = 0x830FA3D8; continue 'dispatch;
	}
	// 830FA340: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA344: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830FA348: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 830FA34C: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 830FA350: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FA354: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 830FA358: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 830FA35C: 40990038  ble cr6, 0x830fa394
	if !ctx.cr[6].gt {
	pc = 0x830FA394; continue 'dispatch;
	}
	// 830FA360: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA364: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830FA368: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA36C: 4BFE4DB5  bl 0x830df120
	ctx.lr = 0x830FA370;
	sub_830DF120(ctx, base);
	// 830FA370: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA374: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA378: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA37C: 4BFED4FD  bl 0x830e7878
	ctx.lr = 0x830FA380;
	sub_830E7878(ctx, base);
	// 830FA380: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA384: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830FA388: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830FA38C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA390: 4198FFD0  blt cr6, 0x830fa360
	if ctx.cr[6].lt {
	pc = 0x830FA360; continue 'dispatch;
	}
	// 830FA394: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FA398: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA39C: 419A000C  beq cr6, 0x830fa3a8
	if ctx.cr[6].eq {
	pc = 0x830FA3A8; continue 'dispatch;
	}
	// 830FA3A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA3A4: 4BFEDFA5  bl 0x830e8348
	ctx.lr = 0x830FA3A8;
	sub_830E8348(ctx, base);
	// 830FA3A8: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FA3AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA3B0: 419A000C  beq cr6, 0x830fa3bc
	if ctx.cr[6].eq {
	pc = 0x830FA3BC; continue 'dispatch;
	}
	// 830FA3B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA3B8: 4BFEDF91  bl 0x830e8348
	ctx.lr = 0x830FA3BC;
	sub_830E8348(ctx, base);
	// 830FA3BC: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FA3C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA3C4: 419A038C  beq cr6, 0x830fa750
	if ctx.cr[6].eq {
	pc = 0x830FA750; continue 'dispatch;
	}
	// 830FA3C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830FA3CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FA3D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA3D4: 48000378  b 0x830fa74c
	pc = 0x830FA74C; continue 'dispatch;
	// 830FA3D8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FA3DC: 409A0040  bne cr6, 0x830fa41c
	if !ctx.cr[6].eq {
	pc = 0x830FA41C; continue 'dispatch;
	}
	// 830FA3E0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA3E4: 4BFD482D  bl 0x830cec10
	ctx.lr = 0x830FA3E8;
	sub_830CEC10(ctx, base);
	// 830FA3E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA3EC: 4BFED7C5  bl 0x830e7bb0
	ctx.lr = 0x830FA3F0;
	sub_830E7BB0(ctx, base);
	// 830FA3F0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA3F4: 4BFD481D  bl 0x830cec10
	ctx.lr = 0x830FA3F8;
	sub_830CEC10(ctx, base);
	// 830FA3F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA3FC: 4BFED5C5  bl 0x830e79c0
	ctx.lr = 0x830FA400;
	sub_830E79C0(ctx, base);
	// 830FA400: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FA404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FA408: 419A0348  beq cr6, 0x830fa750
	if ctx.cr[6].eq {
	pc = 0x830FA750; continue 'dispatch;
	}
	// 830FA40C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA410: 4BFF7511  bl 0x830f1920
	ctx.lr = 0x830FA414;
	sub_830F1920(ctx, base);
	// 830FA414: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FA418: 48000328  b 0x830fa740
	pc = 0x830FA740; continue 'dispatch;
	// 830FA41C: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FA420: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA424: 41980010  blt cr6, 0x830fa434
	if ctx.cr[6].lt {
	pc = 0x830FA434; continue 'dispatch;
	}
	// 830FA428: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830FA42C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 830FA430: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 830FA434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA438: 4BFFF2B1  bl 0x830f96e8
	ctx.lr = 0x830FA43C;
	sub_830F96E8(ctx, base);
	// 830FA43C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FA440: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FA444: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA448: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830FA44C: 40990014  ble cr6, 0x830fa460
	if !ctx.cr[6].gt {
	pc = 0x830FA460; continue 'dispatch;
	}
	// 830FA450: 4BFD47C1  bl 0x830cec10
	ctx.lr = 0x830FA454;
	sub_830CEC10(ctx, base);
	// 830FA454: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FA458: 4BFED759  bl 0x830e7bb0
	ctx.lr = 0x830FA45C;
	sub_830E7BB0(ctx, base);
	// 830FA45C: 480002CC  b 0x830fa728
	pc = 0x830FA728; continue 'dispatch;
	// 830FA460: 4BFE7051  bl 0x830e14b0
	ctx.lr = 0x830FA464;
	sub_830E14B0(ctx, base);
	// 830FA464: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830FA468: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA46C: 4BFE6735  bl 0x830e0ba0
	ctx.lr = 0x830FA470;
	sub_830E0BA0(ctx, base);
	// 830FA470: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA474: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830FA478: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 830FA47C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA480: 409901C4  ble cr6, 0x830fa644
	if !ctx.cr[6].gt {
	pc = 0x830FA644; continue 'dispatch;
	}
	// 830FA484: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 830FA488: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FA48C: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FA490: 7F9A5A14  add r28, r26, r11
	ctx.r[28].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 830FA494: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA498: 7F1C5000  cmpw cr6, r28, r10
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FA49C: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA4A0: 40980164  bge cr6, 0x830fa604
	if !ctx.cr[6].lt {
	pc = 0x830FA604; continue 'dispatch;
	}
	// 830FA4A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830FA4A8: 4BFE4C79  bl 0x830df120
	ctx.lr = 0x830FA4AC;
	sub_830DF120(ctx, base);
	// 830FA4AC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA4B0: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA4B4: 4BFE65CD  bl 0x830e0a80
	ctx.lr = 0x830FA4B8;
	sub_830E0A80(ctx, base);
	// 830FA4B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA4BC: 40820020  bne 0x830fa4dc
	if !ctx.cr[0].eq {
	pc = 0x830FA4DC; continue 'dispatch;
	}
	// 830FA4C0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA4C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FA4C8: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA4CC: 4BFED3AD  bl 0x830e7878
	ctx.lr = 0x830FA4D0;
	sub_830E7878(ctx, base);
	// 830FA4D0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA4D4: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA4D8: 4BFED8F9  bl 0x830e7dd0
	ctx.lr = 0x830FA4DC;
	sub_830E7DD0(ctx, base);
	// 830FA4DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FA4E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA4E4: 419A0024  beq cr6, 0x830fa508
	if ctx.cr[6].eq {
	pc = 0x830FA508; continue 'dispatch;
	}
	// 830FA4E8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA4EC: 4BFD4725  bl 0x830cec10
	ctx.lr = 0x830FA4F0;
	sub_830CEC10(ctx, base);
	// 830FA4F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830FA4F4: 4BFEDA85  bl 0x830e7f78
	ctx.lr = 0x830FA4F8;
	sub_830E7F78(ctx, base);
	// 830FA4F8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA4FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FA500: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA504: 4BFED99D  bl 0x830e7ea0
	ctx.lr = 0x830FA508;
	sub_830E7EA0(ctx, base);
	// 830FA508: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830FA50C: 409A000C  bne cr6, 0x830fa518
	if !ctx.cr[6].eq {
	pc = 0x830FA518; continue 'dispatch;
	}
	// 830FA510: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 830FA514: 48000018  b 0x830fa52c
	pc = 0x830FA52C; continue 'dispatch;
	// 830FA518: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA51C: 4BFD46F5  bl 0x830cec10
	ctx.lr = 0x830FA520;
	sub_830CEC10(ctx, base);
	// 830FA520: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830FA524: 4BFEDA9D  bl 0x830e7fc0
	ctx.lr = 0x830FA528;
	sub_830E7FC0(ctx, base);
	// 830FA528: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FA52C: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA530: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA534: 4BFE666D  bl 0x830e0ba0
	ctx.lr = 0x830FA538;
	sub_830E0BA0(ctx, base);
	// 830FA538: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FA53C: 419A0010  beq cr6, 0x830fa54c
	if ctx.cr[6].eq {
	pc = 0x830FA54C; continue 'dispatch;
	}
	// 830FA540: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830FA544: 419A0010  beq cr6, 0x830fa554
	if ctx.cr[6].eq {
	pc = 0x830FA554; continue 'dispatch;
	}
	// 830FA548: 4800001C  b 0x830fa564
	pc = 0x830FA564; continue 'dispatch;
	// 830FA54C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830FA550: 419A0014  beq cr6, 0x830fa564
	if ctx.cr[6].eq {
	pc = 0x830FA564; continue 'dispatch;
	}
	// 830FA554: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA558: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FA55C: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA560: 4BFED799  bl 0x830e7cf8
	ctx.lr = 0x830FA564;
	sub_830E7CF8(ctx, base);
	// 830FA564: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FA568: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA56C: 409A00C4  bne cr6, 0x830fa630
	if !ctx.cr[6].eq {
	pc = 0x830FA630; continue 'dispatch;
	}
	// 830FA570: 83BF00DC  lwz r29, 0xdc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FA574: 935F00DC  stw r26, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[26].u32 ) };
	// 830FA578: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA57C: 4BFD4695  bl 0x830cec10
	ctx.lr = 0x830FA580;
	sub_830CEC10(ctx, base);
	// 830FA580: 7F191840  cmplw cr6, r25, r3
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830FA584: 409A0028  bne cr6, 0x830fa5ac
	if !ctx.cr[6].eq {
	pc = 0x830FA5AC; continue 'dispatch;
	}
	// 830FA588: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830FA58C: 4BFE4975  bl 0x830def00
	ctx.lr = 0x830FA590;
	sub_830DEF00(ctx, base);
	// 830FA590: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FA594: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA598: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FA59C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FA5A0: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FA5A4: 4BFE867D  bl 0x830e2c20
	ctx.lr = 0x830FA5A8;
	sub_830E2C20(ctx, base);
	// 830FA5A8: 48000088  b 0x830fa630
	pc = 0x830FA630; continue 'dispatch;
	// 830FA5AC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830FA5B0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA5B4: 4BFE58BD  bl 0x830dfe70
	ctx.lr = 0x830FA5B8;
	sub_830DFE70(ctx, base);
	// 830FA5B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA5BC: 40820074  bne 0x830fa630
	if !ctx.cr[0].eq {
	pc = 0x830FA630; continue 'dispatch;
	}
	// 830FA5C0: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FA5C4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA5C8: 419A0068  beq cr6, 0x830fa630
	if ctx.cr[6].eq {
	pc = 0x830FA630; continue 'dispatch;
	}
	// 830FA5CC: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA5D0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FA5D4: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FA5D8: 4BFED7F9  bl 0x830e7dd0
	ctx.lr = 0x830FA5DC;
	sub_830E7DD0(ctx, base);
	// 830FA5DC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FA5E0: 41980050  blt cr6, 0x830fa630
	if ctx.cr[6].lt {
	pc = 0x830FA630; continue 'dispatch;
	}
	// 830FA5E4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA5E8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA5EC: 40980044  bge cr6, 0x830fa630
	if !ctx.cr[6].lt {
	pc = 0x830FA630; continue 'dispatch;
	}
	// 830FA5F0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA5F4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830FA5F8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA5FC: 4BFED7D5  bl 0x830e7dd0
	ctx.lr = 0x830FA600;
	sub_830E7DD0(ctx, base);
	// 830FA600: 48000030  b 0x830fa630
	pc = 0x830FA630; continue 'dispatch;
	// 830FA604: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830FA608: 4BFE4B19  bl 0x830df120
	ctx.lr = 0x830FA60C;
	sub_830DF120(ctx, base);
	// 830FA60C: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA610: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA614: 4BFE646D  bl 0x830e0a80
	ctx.lr = 0x830FA618;
	sub_830E0A80(ctx, base);
	// 830FA618: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA61C: 41820014  beq 0x830fa630
	if ctx.cr[0].eq {
	pc = 0x830FA630; continue 'dispatch;
	}
	// 830FA620: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA624: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA628: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FA62C: 4BFED24D  bl 0x830e7878
	ctx.lr = 0x830FA630;
	sub_830E7878(ctx, base);
	// 830FA630: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA634: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830FA638: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 830FA63C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA640: 4198FE48  blt cr6, 0x830fa488
	if ctx.cr[6].lt {
	pc = 0x830FA488; continue 'dispatch;
	}
	// 830FA644: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FA648: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA64C: 419A0014  beq cr6, 0x830fa660
	if ctx.cr[6].eq {
	pc = 0x830FA660; continue 'dispatch;
	}
	// 830FA650: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA658: 4BFF8181  bl 0x830f27d8
	ctx.lr = 0x830FA65C;
	sub_830F27D8(ctx, base);
	// 830FA65C: 48000024  b 0x830fa680
	pc = 0x830FA680; continue 'dispatch;
	// 830FA660: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA664: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA668: 409A0010  bne cr6, 0x830fa678
	if !ctx.cr[6].eq {
	pc = 0x830FA678; continue 'dispatch;
	}
	// 830FA66C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FA670: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA674: 419A000C  beq cr6, 0x830fa680
	if ctx.cr[6].eq {
	pc = 0x830FA680; continue 'dispatch;
	}
	// 830FA678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA67C: 4BFFD02D  bl 0x830f76a8
	ctx.lr = 0x830FA680;
	sub_830F76A8(ctx, base);
	// 830FA680: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FA684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FA688: 419A0050  beq cr6, 0x830fa6d8
	if ctx.cr[6].eq {
	pc = 0x830FA6D8; continue 'dispatch;
	}
	// 830FA68C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA690: 4BFF74D9  bl 0x830f1b68
	ctx.lr = 0x830FA694;
	sub_830F1B68(ctx, base);
	// 830FA694: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA698: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FA69C: 4082000C  bne 0x830fa6a8
	if !ctx.cr[0].eq {
	pc = 0x830FA6A8; continue 'dispatch;
	}
	// 830FA6A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FA6A4: 48000030  b 0x830fa6d4
	pc = 0x830FA6D4; continue 'dispatch;
	// 830FA6A8: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FA6AC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FA6B0: 419A000C  beq cr6, 0x830fa6bc
	if ctx.cr[6].eq {
	pc = 0x830FA6BC; continue 'dispatch;
	}
	// 830FA6B4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FA6B8: 409A0018  bne cr6, 0x830fa6d0
	if !ctx.cr[6].eq {
	pc = 0x830FA6D0; continue 'dispatch;
	}
	// 830FA6BC: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FA6C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FA6C4: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FA6C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FA6CC: 419A0008  beq cr6, 0x830fa6d4
	if ctx.cr[6].eq {
	pc = 0x830FA6D4; continue 'dispatch;
	}
	// 830FA6D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA6D4: 4BFEDC75  bl 0x830e8348
	ctx.lr = 0x830FA6D8;
	sub_830E8348(ctx, base);
	// 830FA6D8: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FA6DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA6E0: 419A0048  beq cr6, 0x830fa728
	if ctx.cr[6].eq {
	pc = 0x830FA728; continue 'dispatch;
	}
	// 830FA6E4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FA6E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA6EC: 4099000C  ble cr6, 0x830fa6f8
	if !ctx.cr[6].gt {
	pc = 0x830FA6F8; continue 'dispatch;
	}
	// 830FA6F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FA6F4: 48000030  b 0x830fa724
	pc = 0x830FA724; continue 'dispatch;
	// 830FA6F8: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FA6FC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FA700: 419A000C  beq cr6, 0x830fa70c
	if ctx.cr[6].eq {
	pc = 0x830FA70C; continue 'dispatch;
	}
	// 830FA704: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FA708: 409A0018  bne cr6, 0x830fa720
	if !ctx.cr[6].eq {
	pc = 0x830FA720; continue 'dispatch;
	}
	// 830FA70C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FA710: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FA714: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FA718: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FA71C: 419A0008  beq cr6, 0x830fa724
	if ctx.cr[6].eq {
	pc = 0x830FA724; continue 'dispatch;
	}
	// 830FA720: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA724: 4BFEDC25  bl 0x830e8348
	ctx.lr = 0x830FA728;
	sub_830E8348(ctx, base);
	// 830FA728: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FA72C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FA730: 419A0020  beq cr6, 0x830fa750
	if ctx.cr[6].eq {
	pc = 0x830FA750; continue 'dispatch;
	}
	// 830FA734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA738: 4BFF71E9  bl 0x830f1920
	ctx.lr = 0x830FA73C;
	sub_830F1920(ctx, base);
	// 830FA73C: 80BF00E8  lwz r5, 0xe8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FA740: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830FA744: 809F00F0  lwz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FA748: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FA74C: 4BFEDC45  bl 0x830e8390
	ctx.lr = 0x830FA750;
	sub_830E8390(ctx, base);
	// 830FA750: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830FA754: 480ADA54  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FA758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FA758 size=2344
    let mut pc: u32 = 0x830FA758;
    'dispatch: loop {
        match pc {
            0x830FA758 => {
    //   block [0x830FA758..0x830FB080)
	// 830FA758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FA75C: 480ADA01  bl 0x831a815c
	ctx.lr = 0x830FA760;
	sub_831A8130(ctx, base);
	// 830FA760: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 830FA764: 480AE315  bl 0x831a8a78
	ctx.lr = 0x830FA768;
	sub_831A8A40(ctx, base);
	// 830FA768: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FA76C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FA770: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 830FA774: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 830FA778: FFE01890  fmr f31, f3
	ctx.f[31].f64 = ctx.f[3].f64;
	// 830FA77C: FFC02090  fmr f30, f4
	ctx.f[30].f64 = ctx.f[4].f64;
	// 830FA780: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA784: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA788: 419A08E4  beq cr6, 0x830fb06c
	if ctx.cr[6].eq {
	pc = 0x830FB06C; continue 'dispatch;
	}
	// 830FA78C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FA790: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA794: 419A002C  beq cr6, 0x830fa7c0
	if ctx.cr[6].eq {
	pc = 0x830FA7C0; continue 'dispatch;
	}
	// 830FA798: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FA79C: 4BFE574D  bl 0x830dfee8
	ctx.lr = 0x830FA7A0;
	sub_830DFEE8(ctx, base);
	// 830FA7A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA7A4: 418008CC  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FA7A8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FA7AC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FA7B0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FA7B4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830FA7B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FA7BC: 4BFEAE25  bl 0x830e55e0
	ctx.lr = 0x830FA7C0;
	sub_830E55E0(ctx, base);
	// 830FA7C0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FA7C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA7C8: 419A002C  beq cr6, 0x830fa7f4
	if ctx.cr[6].eq {
	pc = 0x830FA7F4; continue 'dispatch;
	}
	// 830FA7CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FA7D0: 4BFE5719  bl 0x830dfee8
	ctx.lr = 0x830FA7D4;
	sub_830DFEE8(ctx, base);
	// 830FA7D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA7D8: 41800898  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FA7DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FA7E0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FA7E4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FA7E8: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830FA7EC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FA7F0: 4BFEADF1  bl 0x830e55e0
	ctx.lr = 0x830FA7F4;
	sub_830E55E0(ctx, base);
	// 830FA7F4: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FA7F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA7FC: 419A002C  beq cr6, 0x830fa828
	if ctx.cr[6].eq {
	pc = 0x830FA828; continue 'dispatch;
	}
	// 830FA800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FA804: 4BFE56E5  bl 0x830dfee8
	ctx.lr = 0x830FA808;
	sub_830DFEE8(ctx, base);
	// 830FA808: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA80C: 41800864  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FA810: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FA814: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FA818: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FA81C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830FA820: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FA824: 4BFEADBD  bl 0x830e55e0
	ctx.lr = 0x830FA828;
	sub_830E55E0(ctx, base);
	// 830FA828: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FA82C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA830: 419A002C  beq cr6, 0x830fa85c
	if ctx.cr[6].eq {
	pc = 0x830FA85C; continue 'dispatch;
	}
	// 830FA834: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FA838: 4BFE56B1  bl 0x830dfee8
	ctx.lr = 0x830FA83C;
	sub_830DFEE8(ctx, base);
	// 830FA83C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA840: 41800830  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FA844: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FA848: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FA84C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FA850: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830FA854: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FA858: 4BFEAD89  bl 0x830e55e0
	ctx.lr = 0x830FA85C;
	sub_830E55E0(ctx, base);
	// 830FA85C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FA860: D3810060  stfs f28, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830FA864: FF80F890  fmr f28, f31
	ctx.f[28].f64 = ctx.f[31].f64;
	// 830FA868: D3A10068  stfs f29, 0x68(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830FA86C: D3810054  stfs f28, 0x54(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830FA870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FA874: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830FA878: 419A0054  beq cr6, 0x830fa8cc
	if ctx.cr[6].eq {
	pc = 0x830FA8CC; continue 'dispatch;
	}
	// 830FA87C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830FA880: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830FA884: 4BFECF85  bl 0x830e7808
	ctx.lr = 0x830FA888;
	sub_830E7808(ctx, base);
	// 830FA888: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FA88C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FA890: 4BFE5659  bl 0x830dfee8
	ctx.lr = 0x830FA894;
	sub_830DFEE8(ctx, base);
	// 830FA894: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA898: 418007D8  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FA89C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FA8A0: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FA8A4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FA8A8: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830FA8AC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FA8B0: 4BFEAD31  bl 0x830e55e0
	ctx.lr = 0x830FA8B4;
	sub_830E55E0(ctx, base);
	// 830FA8B4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830FA8B8: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FA8BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830FA8C0: 4BFECF49  bl 0x830e7808
	ctx.lr = 0x830FA8C4;
	sub_830E7808(ctx, base);
	// 830FA8C4: C3810054  lfs f28, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830FA8C8: C3C10058  lfs f30, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FA8CC: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FA8D0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830FA8D4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FA8D8: 419A0054  beq cr6, 0x830fa92c
	if ctx.cr[6].eq {
	pc = 0x830FA92C; continue 'dispatch;
	}
	// 830FA8DC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FA8E0: 419A004C  beq cr6, 0x830fa92c
	if ctx.cr[6].eq {
	pc = 0x830FA92C; continue 'dispatch;
	}
	// 830FA8E4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA8E8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 830FA8EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA8F0: 4099005C  ble cr6, 0x830fa94c
	if !ctx.cr[6].gt {
	pc = 0x830FA94C; continue 'dispatch;
	}
	// 830FA8F4: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 830FA8F8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA8FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FA900: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 830FA904: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830FA908: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 830FA90C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FA910: 4BFEACD1  bl 0x830e55e0
	ctx.lr = 0x830FA914;
	sub_830E55E0(ctx, base);
	// 830FA914: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FA918: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830FA91C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830FA920: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FA924: 4198FFD4  blt cr6, 0x830fa8f8
	if ctx.cr[6].lt {
	pc = 0x830FA8F8; continue 'dispatch;
	}
	// 830FA928: 48000024  b 0x830fa94c
	pc = 0x830FA94C; continue 'dispatch;
	// 830FA92C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FA930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FA934: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA938: 419A0010  beq cr6, 0x830fa948
	if ctx.cr[6].eq {
	pc = 0x830FA948; continue 'dispatch;
	}
	// 830FA93C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FA940: 4BFF7E99  bl 0x830f27d8
	ctx.lr = 0x830FA944;
	sub_830F27D8(ctx, base);
	// 830FA944: 48000008  b 0x830fa94c
	pc = 0x830FA94C; continue 'dispatch;
	// 830FA948: 4BFFCD61  bl 0x830f76a8
	ctx.lr = 0x830FA94C;
	sub_830F76A8(ctx, base);
	// 830FA94C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FA950: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA954: 409A0030  bne cr6, 0x830fa984
	if !ctx.cr[6].eq {
	pc = 0x830FA984; continue 'dispatch;
	}
	// 830FA958: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FA95C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA960: 409A0024  bne cr6, 0x830fa984
	if !ctx.cr[6].eq {
	pc = 0x830FA984; continue 'dispatch;
	}
	// 830FA964: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA968: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 830FA96C: 389F003C  addi r4, r31, 0x3c
	ctx.r[4].s64 = ctx.r[31].s64 + 60;
	// 830FA970: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA974: 4BFECE95  bl 0x830e7808
	ctx.lr = 0x830FA978;
	sub_830E7808(ctx, base);
	// 830FA978: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA97C: 4080008C  bge 0x830faa08
	if !ctx.cr[0].lt {
	pc = 0x830FAA08; continue 'dispatch;
	}
	// 830FA980: 480006F0  b 0x830fb070
	pc = 0x830FB070; continue 'dispatch;
	// 830FA984: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA988: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FA98C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FA990: EFFE0028  fsubs f31, f30, f0
	ctx.f[31].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FA994: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA998: 4BFE5551  bl 0x830dfee8
	ctx.lr = 0x830FA99C;
	sub_830DFEE8(ctx, base);
	// 830FA99C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA9A0: 418006D0  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FA9A4: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FA9A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830FA9AC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FA9B0: 4BFE5141  bl 0x830dfaf0
	ctx.lr = 0x830FA9B4;
	sub_830DFAF0(ctx, base);
	// 830FA9B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FA9B8: 418006B8  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FA9BC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830FA9C0: 716A0005  andi. r10, r11, 5
	ctx.r[10].u64 = ctx.r[11].u64 & 5;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FA9C4: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 830FA9C8: 409A0020  bne cr6, 0x830fa9e8
	if !ctx.cr[6].eq {
	pc = 0x830FA9E8; continue 'dispatch;
	}
	// 830FA9CC: C0010068  lfs f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FA9D0: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FA9D4: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FA9D8: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FA9DC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FA9E0: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FA9E4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830FA9E8: 716B000A  andi. r11, r11, 0xa
	ctx.r[11].u64 = ctx.r[11].u64 & 10;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FA9EC: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830FA9F0: 409A0018  bne cr6, 0x830faa08
	if !ctx.cr[6].eq {
	pc = 0x830FAA08; continue 'dispatch;
	}
	// 830FA9F4: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FA9F8: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 830FA9FC: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FAA00: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830FAA04: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830FAA08: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830FAA0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAA10: 419A065C  beq cr6, 0x830fb06c
	if ctx.cr[6].eq {
	pc = 0x830FB06C; continue 'dispatch;
	}
	// 830FAA14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FAA18: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FAA1C: 554A077B  rlwinm. r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FAA20: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FAA24: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 830FAA28: 4182000C  beq 0x830faa34
	if ctx.cr[0].eq {
	pc = 0x830FAA34; continue 'dispatch;
	}
	// 830FAA2C: C3BF0088  lfs f29, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FAA30: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAA34: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FAA38: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830FAA3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAA40: 419A01A0  beq cr6, 0x830fabe0
	if ctx.cr[6].eq {
	pc = 0x830FABE0; continue 'dispatch;
	}
	// 830FAA44: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FAA48: 419A00F0  beq cr6, 0x830fab38
	if ctx.cr[6].eq {
	pc = 0x830FAB38; continue 'dispatch;
	}
	// 830FAA4C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FAA50: 409900DC  ble cr6, 0x830fab2c
	if !ctx.cr[6].gt {
	pc = 0x830FAB2C; continue 'dispatch;
	}
	// 830FAA54: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FAA58: 419900D4  bgt cr6, 0x830fab2c
	if ctx.cr[6].gt {
	pc = 0x830FAB2C; continue 'dispatch;
	}
	// 830FAA5C: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FAA60: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830FAA64: EDBE6828  fsubs f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 830FAA68: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FAA6C: C17F0054  lfs f11, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FAA70: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 830FAA74: C3DF0038  lfs f30, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FAA78: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FAA7C: EFE06024  fdivs f31, f0, f12
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830FAA80: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAA84: 480B15BD  bl 0x831ac040
	ctx.lr = 0x830FAA88;
	sub_831AC040(ctx, base);
	// 830FAA88: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAA8C: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FAA90: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FAA94: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAA98: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830FAA9C: 4198000C  blt cr6, 0x830faaa8
	if ctx.cr[6].lt {
	pc = 0x830FAAA8; continue 'dispatch;
	}
	// 830FAAA0: 480B0FF9  bl 0x831aba98
	ctx.lr = 0x830FAAA4;
	sub_831ABA98(ctx, base);
	// 830FAAA4: 48000008  b 0x830faaac
	pc = 0x830FAAAC; continue 'dispatch;
	// 830FAAA8: 480B1261  bl 0x831abd08
	ctx.lr = 0x830FAAAC;
	sub_831ABD08(ctx, base);
	// 830FAAAC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FAAB0: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FAAB4: C19F0058  lfs f12, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FAAB8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830FAABC: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FAAC0: C3DF0034  lfs f30, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FAAC4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FAAC8: 398000E0  li r12, 0xe0
	ctx.r[12].s64 = 224;
	// 830FAACC: 7C1F67AE  stfiwx f0, r31, r12
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 830FAAD0: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAAD4: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FAAD8: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 830FAADC: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FAAE0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAAE4: 480B155D  bl 0x831ac040
	ctx.lr = 0x830FAAE8;
	sub_831AC040(ctx, base);
	// 830FAAE8: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAAEC: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FAAF0: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FAAF4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAAF8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830FAAFC: 4198000C  blt cr6, 0x830fab08
	if ctx.cr[6].lt {
	pc = 0x830FAB08; continue 'dispatch;
	}
	// 830FAB00: 480B0F99  bl 0x831aba98
	ctx.lr = 0x830FAB04;
	sub_831ABA98(ctx, base);
	// 830FAB04: 48000008  b 0x830fab0c
	pc = 0x830FAB0C; continue 'dispatch;
	// 830FAB08: 480B1201  bl 0x831abd08
	ctx.lr = 0x830FAB0C;
	sub_831ABD08(ctx, base);
	// 830FAB0C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FAB10: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FAB14: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FAB18: 398000E4  li r12, 0xe4
	ctx.r[12].s64 = 228;
	// 830FAB1C: 7C1F67AE  stfiwx f0, r31, r12
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 830FAB20: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FAB24: 7FCB51D6  mullw r30, r11, r10
	ctx.r[30].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830FAB28: 48000160  b 0x830fac88
	pc = 0x830FAC88; continue 'dispatch;
	// 830FAB2C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830FAB30: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830FAB34: 4800053C  b 0x830fb070
	pc = 0x830FB070; continue 'dispatch;
	// 830FAB38: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAB3C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FAB40: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FAB44: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FAB48: C19F0058  lfs f12, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FAB4C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FAB50: C3DF0034  lfs f30, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FAB54: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 830FAB58: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FAB5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAB60: 480B14E1  bl 0x831ac040
	ctx.lr = 0x830FAB64;
	sub_831AC040(ctx, base);
	// 830FAB64: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAB68: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FAB6C: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FAB70: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAB74: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830FAB78: 4198001C  blt cr6, 0x830fab94
	if ctx.cr[6].lt {
	pc = 0x830FAB94; continue 'dispatch;
	}
	// 830FAB7C: 480B0F1D  bl 0x831aba98
	ctx.lr = 0x830FAB80;
	sub_831ABA98(ctx, base);
	// 830FAB80: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FAB84: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FAB88: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 830FAB8C: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FAB90: 48000018  b 0x830faba8
	pc = 0x830FABA8; continue 'dispatch;
	// 830FAB94: 480B1175  bl 0x831abd08
	ctx.lr = 0x830FAB98;
	sub_831ABD08(ctx, base);
	// 830FAB98: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FAB9C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FABA0: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 830FABA4: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FABA8: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 830FABAC: C01F0044  lfs f0, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FABB0: 93BF00E0  stw r29, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 830FABB4: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FABB8: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FABBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830FABC0: C19F0040  lfs f12, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FABC4: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FABC8: EC2D033A  fmadds f1, f13, f12, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830FABCC: 480B113D  bl 0x831abd08
	ctx.lr = 0x830FABD0;
	sub_831ABD08(ctx, base);
	// 830FABD0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FABD4: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FABD8: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830FABDC: 480000A8  b 0x830fac84
	pc = 0x830FAC84; continue 'dispatch;
	// 830FABE0: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FABE4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FABE8: EDBE6828  fsubs f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 830FABEC: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FABF0: C17F0054  lfs f11, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FABF4: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 830FABF8: C3DF0038  lfs f30, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FABFC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FAC00: EFE06024  fdivs f31, f0, f12
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830FAC04: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAC08: 480B1439  bl 0x831ac040
	ctx.lr = 0x830FAC0C;
	sub_831AC040(ctx, base);
	// 830FAC0C: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAC10: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FAC14: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FAC18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FAC1C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830FAC20: 4198001C  blt cr6, 0x830fac3c
	if ctx.cr[6].lt {
	pc = 0x830FAC3C; continue 'dispatch;
	}
	// 830FAC24: 480B0E75  bl 0x831aba98
	ctx.lr = 0x830FAC28;
	sub_831ABA98(ctx, base);
	// 830FAC28: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FAC2C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FAC30: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 830FAC34: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FAC38: 48000018  b 0x830fac50
	pc = 0x830FAC50; continue 'dispatch;
	// 830FAC3C: 480B10CD  bl 0x831abd08
	ctx.lr = 0x830FAC40;
	sub_831ABD08(ctx, base);
	// 830FAC40: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FAC44: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FAC48: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 830FAC4C: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FAC50: C01F0044  lfs f0, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAC54: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830FAC58: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830FAC5C: 93BF00E4  stw r29, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 830FAC60: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAC64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830FAC68: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FAC6C: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FAC70: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FAC74: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAC78: EC2D033A  fmadds f1, f13, f12, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830FAC7C: 480B108D  bl 0x831abd08
	ctx.lr = 0x830FAC80;
	sub_831ABD08(ctx, base);
	// 830FAC80: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FAC84: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830FAC88: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FAC8C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FAC90: 40980008  bge cr6, 0x830fac98
	if !ctx.cr[6].lt {
	pc = 0x830FAC98; continue 'dispatch;
	}
	// 830FAC94: 93BF00E0  stw r29, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 830FAC98: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FAC9C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FACA0: 40980008  bge cr6, 0x830faca8
	if !ctx.cr[6].lt {
	pc = 0x830FACA8; continue 'dispatch;
	}
	// 830FACA4: 93BF00E4  stw r29, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 830FACA8: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 830FACAC: 4098002C  bge cr6, 0x830facd8
	if !ctx.cr[6].lt {
	pc = 0x830FACD8; continue 'dispatch;
	}
	// 830FACB0: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FACB4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FACB8: 409A000C  bne cr6, 0x830facc4
	if !ctx.cr[6].eq {
	pc = 0x830FACC4; continue 'dispatch;
	}
	// 830FACBC: 83DF00E4  lwz r30, 0xe4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FACC0: 48000018  b 0x830facd8
	pc = 0x830FACD8; continue 'dispatch;
	// 830FACC4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FACC8: 409A000C  bne cr6, 0x830facd4
	if !ctx.cr[6].eq {
	pc = 0x830FACD4; continue 'dispatch;
	}
	// 830FACCC: 83DF00E0  lwz r30, 0xe0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FACD0: 48000008  b 0x830facd8
	pc = 0x830FACD8; continue 'dispatch;
	// 830FACD4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830FACD8: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FACDC: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FACE0: 4098009C  bge cr6, 0x830fad7c
	if !ctx.cr[6].lt {
	pc = 0x830FAD7C; continue 'dispatch;
	}
	// 830FACE4: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FACE8: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830FACEC: 41980018  blt cr6, 0x830fad04
	if ctx.cr[6].lt {
	pc = 0x830FAD04; continue 'dispatch;
	}
	// 830FACF0: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FACF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FACF8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FACFC: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 830FAD00: 4BFECCC1  bl 0x830e79c0
	ctx.lr = 0x830FAD04;
	sub_830E79C0(ctx, base);
	// 830FAD04: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FAD08: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 830FAD0C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FAD10: 40980030  bge cr6, 0x830fad40
	if !ctx.cr[6].lt {
	pc = 0x830FAD40; continue 'dispatch;
	}
	// 830FAD14: 57DD103A  slwi r29, r30, 2
	ctx.r[29].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830FAD18: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FAD1C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FAD20: 4BFDEB09  bl 0x830d9828
	ctx.lr = 0x830FAD24;
	sub_830D9828(ctx, base);
	// 830FAD24: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FAD28: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830FAD2C: 7F2BE92E  stwx r25, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[25].u32) };
	// 830FAD30: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830FAD34: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FAD38: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FAD3C: 4198FFDC  blt cr6, 0x830fad18
	if ctx.cr[6].lt {
	pc = 0x830FAD18; continue 'dispatch;
	}
	// 830FAD40: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FAD44: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 830FAD48: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830FAD4C: 4198000C  blt cr6, 0x830fad58
	if ctx.cr[6].lt {
	pc = 0x830FAD58; continue 'dispatch;
	}
	// 830FAD50: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 830FAD54: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 830FAD58: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FAD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FAD60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAD64: 419A0010  beq cr6, 0x830fad74
	if ctx.cr[6].eq {
	pc = 0x830FAD74; continue 'dispatch;
	}
	// 830FAD68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FAD6C: 4BFF7A6D  bl 0x830f27d8
	ctx.lr = 0x830FAD70;
	sub_830F27D8(ctx, base);
	// 830FAD70: 4800016C  b 0x830faedc
	pc = 0x830FAEDC; continue 'dispatch;
	// 830FAD74: 4BFFC935  bl 0x830f76a8
	ctx.lr = 0x830FAD78;
	sub_830F76A8(ctx, base);
	// 830FAD78: 48000164  b 0x830faedc
	pc = 0x830FAEDC; continue 'dispatch;
	// 830FAD7C: 4099016C  ble cr6, 0x830faee8
	if !ctx.cr[6].gt {
	pc = 0x830FAEE8; continue 'dispatch;
	}
	// 830FAD80: 57C4103A  slwi r4, r30, 2
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830FAD84: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FAD88: 4BFE2769  bl 0x830dd4f0
	ctx.lr = 0x830FAD8C;
	sub_830DD4F0(ctx, base);
	// 830FAD8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FAD90: 40820010  bne 0x830fada0
	if !ctx.cr[0].eq {
	pc = 0x830FADA0; continue 'dispatch;
	}
	// 830FAD94: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830FAD98: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830FAD9C: 480002D4  b 0x830fb070
	pc = 0x830FB070; continue 'dispatch;
	// 830FADA0: 907F00B0  stw r3, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 830FADA4: 3F408339  lis r26, -0x7cc7
	ctx.r[26].s64 = -2093416448;
	// 830FADA8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FADAC: 809AC06C  lwz r4, -0x3f94(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830FADB0: 4BFE3D39  bl 0x830deae8
	ctx.lr = 0x830FADB4;
	sub_830DEAE8(ctx, base);
	// 830FADB4: 83BF00AC  lwz r29, 0xac(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FADB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830FADBC: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830FADC0: 4098005C  bge cr6, 0x830fae1c
	if !ctx.cr[6].lt {
	pc = 0x830FAE1C; continue 'dispatch;
	}
	// 830FADC4: 57BB103A  slwi r27, r29, 2
	ctx.r[27].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 830FADC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FADCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FADD0: 4BFF6AA9  bl 0x830f1878
	ctx.lr = 0x830FADD4;
	sub_830F1878(ctx, base);
	// 830FADD4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FADD8: 41800298  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FADDC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FADE0: 809AC06C  lwz r4, -0x3f94(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830FADE4: 7C6BD82E  lwzx r3, r11, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 830FADE8: 4BFE3D01  bl 0x830deae8
	ctx.lr = 0x830FADEC;
	sub_830DEAE8(ctx, base);
	// 830FADEC: C01C0104  lfs f0, 0x104(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FADF0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830FADF4: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 830FADF8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 830FADFC: C01C0108  lfs f0, 0x108(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAE00: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830FAE04: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 830FAE08: C01C010C  lfs f0, 0x10c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAE0C: D003010C  stfs f0, 0x10c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 830FAE10: C01C0110  lfs f0, 0x110(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FAE14: D0030110  stfs f0, 0x110(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 830FAE18: 4198FFB0  blt cr6, 0x830fadc8
	if ctx.cr[6].lt {
	pc = 0x830FADC8; continue 'dispatch;
	}
	// 830FAE1C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FAE20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FAE24: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 830FAE28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAE2C: 419A0010  beq cr6, 0x830fae3c
	if ctx.cr[6].eq {
	pc = 0x830FAE3C; continue 'dispatch;
	}
	// 830FAE30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FAE34: 4BFF79A5  bl 0x830f27d8
	ctx.lr = 0x830FAE38;
	sub_830F27D8(ctx, base);
	// 830FAE38: 48000008  b 0x830fae40
	pc = 0x830FAE40; continue 'dispatch;
	// 830FAE3C: 4BFFC86D  bl 0x830f76a8
	ctx.lr = 0x830FAE40;
	sub_830F76A8(ctx, base);
	// 830FAE40: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830FAE44: 4BFE474D  bl 0x830df590
	ctx.lr = 0x830FAE48;
	sub_830DF590(ctx, base);
	// 830FAE48: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FAE4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FAE50: 419A0014  beq cr6, 0x830fae64
	if ctx.cr[6].eq {
	pc = 0x830FAE64; continue 'dispatch;
	}
	// 830FAE54: 4BFE48BD  bl 0x830df710
	ctx.lr = 0x830FAE58;
	sub_830DF710(ctx, base);
	// 830FAE58: 809F0024  lwz r4, 0x24(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FAE5C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FAE60: 4BFE4861  bl 0x830df6c0
	ctx.lr = 0x830FAE64;
	sub_830DF6C0(ctx, base);
	// 830FAE64: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FAE68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FAE6C: 419A0014  beq cr6, 0x830fae80
	if ctx.cr[6].eq {
	pc = 0x830FAE80; continue 'dispatch;
	}
	// 830FAE70: 4BFE48A1  bl 0x830df710
	ctx.lr = 0x830FAE74;
	sub_830DF710(ctx, base);
	// 830FAE74: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FAE78: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FAE7C: 4BFE4845  bl 0x830df6c0
	ctx.lr = 0x830FAE80;
	sub_830DF6C0(ctx, base);
	// 830FAE80: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FAE84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FAE88: 419A0014  beq cr6, 0x830fae9c
	if ctx.cr[6].eq {
	pc = 0x830FAE9C; continue 'dispatch;
	}
	// 830FAE8C: 4BFE4885  bl 0x830df710
	ctx.lr = 0x830FAE90;
	sub_830DF710(ctx, base);
	// 830FAE90: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FAE94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FAE98: 4BFE4829  bl 0x830df6c0
	ctx.lr = 0x830FAE9C;
	sub_830DF6C0(ctx, base);
	// 830FAE9C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FAEA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FAEA4: 419A0014  beq cr6, 0x830faeb8
	if ctx.cr[6].eq {
	pc = 0x830FAEB8; continue 'dispatch;
	}
	// 830FAEA8: 4BFE4869  bl 0x830df710
	ctx.lr = 0x830FAEAC;
	sub_830DF710(ctx, base);
	// 830FAEAC: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FAEB0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FAEB4: 4BFE480D  bl 0x830df6c0
	ctx.lr = 0x830FAEB8;
	sub_830DF6C0(ctx, base);
	// 830FAEB8: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FAEBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FAEC0: 419A0014  beq cr6, 0x830faed4
	if ctx.cr[6].eq {
	pc = 0x830FAED4; continue 'dispatch;
	}
	// 830FAEC4: 4BFE484D  bl 0x830df710
	ctx.lr = 0x830FAEC8;
	sub_830DF710(ctx, base);
	// 830FAEC8: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FAECC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FAED0: 4BFE47F1  bl 0x830df6c0
	ctx.lr = 0x830FAED4;
	sub_830DF6C0(ctx, base);
	// 830FAED4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FAED8: 4BFE46B9  bl 0x830df590
	ctx.lr = 0x830FAEDC;
	sub_830DF590(ctx, base);
	// 830FAEDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FAEE0: 4BFFF411  bl 0x830fa2f0
	ctx.lr = 0x830FAEE4;
	sub_830FA2F0(ctx, base);
	// 830FAEE4: 4800003C  b 0x830faf20
	pc = 0x830FAF20; continue 'dispatch;
	// 830FAEE8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FAEEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAEF0: 409A0010  bne cr6, 0x830faf00
	if !ctx.cr[6].eq {
	pc = 0x830FAF00; continue 'dispatch;
	}
	// 830FAEF4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FAEF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAEFC: 419A0024  beq cr6, 0x830faf20
	if ctx.cr[6].eq {
	pc = 0x830FAF20; continue 'dispatch;
	}
	// 830FAF00: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FAF04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FAF08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAF0C: 419A0010  beq cr6, 0x830faf1c
	if ctx.cr[6].eq {
	pc = 0x830FAF1C; continue 'dispatch;
	}
	// 830FAF10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FAF14: 4BFF78C5  bl 0x830f27d8
	ctx.lr = 0x830FAF18;
	sub_830F27D8(ctx, base);
	// 830FAF18: 48000008  b 0x830faf20
	pc = 0x830FAF20; continue 'dispatch;
	// 830FAF1C: 4BFFC78D  bl 0x830f76a8
	ctx.lr = 0x830FAF20;
	sub_830F76A8(ctx, base);
	// 830FAF20: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FAF24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAF28: 419A001C  beq cr6, 0x830faf44
	if ctx.cr[6].eq {
	pc = 0x830FAF44; continue 'dispatch;
	}
	// 830FAF2C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FAF30: 419A0014  beq cr6, 0x830faf44
	if ctx.cr[6].eq {
	pc = 0x830FAF44; continue 'dispatch;
	}
	// 830FAF34: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FAF38: 419A000C  beq cr6, 0x830faf44
	if ctx.cr[6].eq {
	pc = 0x830FAF44; continue 'dispatch;
	}
	// 830FAF3C: 839F00E0  lwz r28, 0xe0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FAF40: 48000008  b 0x830faf48
	pc = 0x830FAF48; continue 'dispatch;
	// 830FAF44: 839F00E4  lwz r28, 0xe4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FAF48: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 830FAF4C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830FAF50: 4098011C  bge cr6, 0x830fb06c
	if !ctx.cr[6].lt {
	pc = 0x830FB06C; continue 'dispatch;
	}
	// 830FAF54: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 830FAF58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FAF5C: 4099003C  ble cr6, 0x830faf98
	if !ctx.cr[6].gt {
	pc = 0x830FAF98; continue 'dispatch;
	}
	// 830FAF60: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 830FAF64: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FAF68: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FAF6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830FAF70: 419A0014  beq cr6, 0x830faf84
	if ctx.cr[6].eq {
	pc = 0x830FAF84; continue 'dispatch;
	}
	// 830FAF74: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830FAF78: 4BFDE8B1  bl 0x830d9828
	ctx.lr = 0x830FAF7C;
	sub_830D9828(ctx, base);
	// 830FAF7C: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FAF80: 7F2BF12E  stwx r25, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[25].u32) };
	// 830FAF84: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 830FAF88: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830FAF8C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830FAF90: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FAF94: 4198FFD0  blt cr6, 0x830faf64
	if ctx.cr[6].lt {
	pc = 0x830FAF64; continue 'dispatch;
	}
	// 830FAF98: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FAF9C: 4BFE253D  bl 0x830dd4d8
	ctx.lr = 0x830FAFA0;
	sub_830DD4D8(ctx, base);
	// 830FAFA0: 933F00B8  stw r25, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[25].u32 ) };
	// 830FAFA4: 5783103A  slwi r3, r28, 2
	ctx.r[3].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830FAFA8: 933F00B4  stw r25, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[25].u32 ) };
	// 830FAFAC: 4BFE2505  bl 0x830dd4b0
	ctx.lr = 0x830FAFB0;
	sub_830DD4B0(ctx, base);
	// 830FAFB0: 907F00B8  stw r3, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[3].u32 ) };
	// 830FAFB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FAFB8: 4182FDDC  beq 0x830fad94
	if ctx.cr[0].eq {
	pc = 0x830FAD94; continue 'dispatch;
	}
	// 830FAFBC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FAFC0: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 830FAFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FAFC8: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 830FAFCC: 409A001C  bne cr6, 0x830fafe8
	if !ctx.cr[6].eq {
	pc = 0x830FAFE8; continue 'dispatch;
	}
	// 830FAFD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830FAFD4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FAFD8: 4BFE47F9  bl 0x830df7d0
	ctx.lr = 0x830FAFDC;
	sub_830DF7D0(ctx, base);
	// 830FAFDC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830FAFE0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FAFE4: 4BFE48DD  bl 0x830df8c0
	ctx.lr = 0x830FAFE8;
	sub_830DF8C0(ctx, base);
	// 830FAFE8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 830FAFEC: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830FAFF0: 40990078  ble cr6, 0x830fb068
	if !ctx.cr[6].gt {
	pc = 0x830FB068; continue 'dispatch;
	}
	// 830FAFF4: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 830FAFF8: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FAFFC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FB000: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830FB004: 807F00A8  lwz r3, 0xa8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 830FB008: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830FB00C: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FB010: 4BFE9011  bl 0x830e4020
	ctx.lr = 0x830FB014;
	sub_830E4020(ctx, base);
	// 830FB014: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB018: 41800058  blt 0x830fb070
	if ctx.cr[0].lt {
	pc = 0x830FB070; continue 'dispatch;
	}
	// 830FB01C: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FB020: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FB024: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FB028: 4BFEC851  bl 0x830e7878
	ctx.lr = 0x830FB02C;
	sub_830E7878(ctx, base);
	// 830FB02C: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FB030: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FB034: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FB038: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FB03C: 409A0018  bne cr6, 0x830fb054
	if !ctx.cr[6].eq {
	pc = 0x830FB054; continue 'dispatch;
	}
	// 830FB040: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830FB044: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB048: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FB04C: 4BFE4965  bl 0x830df9b0
	ctx.lr = 0x830FB050;
	sub_830DF9B0(ctx, base);
	// 830FB050: 48000008  b 0x830fb058
	pc = 0x830FB058; continue 'dispatch;
	// 830FB054: 4BFE466D  bl 0x830df6c0
	ctx.lr = 0x830FB058;
	sub_830DF6C0(ctx, base);
	// 830FB058: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830FB05C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830FB060: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830FB064: 4198FF94  blt cr6, 0x830faff8
	if ctx.cr[6].lt {
	pc = 0x830FAFF8; continue 'dispatch;
	}
	// 830FB068: 939F00B4  stw r28, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 830FB06C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FB070: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830FB074: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 830FB078: 480ADA4D  bl 0x831a8ac4
	ctx.lr = 0x830FB07C;
	sub_831A8A8C(ctx, base);
	// 830FB07C: 480AD130  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FB080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FB080 size=1956
    let mut pc: u32 = 0x830FB080;
    'dispatch: loop {
        match pc {
            0x830FB080 => {
    //   block [0x830FB080..0x830FB824)
	// 830FB080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FB084: 480AD0DD  bl 0x831a8160
	ctx.lr = 0x830FB088;
	sub_831A8130(ctx, base);
	// 830FB088: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 830FB08C: 480AD9ED  bl 0x831a8a78
	ctx.lr = 0x830FB090;
	sub_831A8A40(ctx, base);
	// 830FB090: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FB094: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830FB098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FB09C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830FB0A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830FB0A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FB0A8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830FB0AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830FB0B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FB0B4: 807F00A8  lwz r3, 0xa8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 830FB0B8: 4BFE8F69  bl 0x830e4020
	ctx.lr = 0x830FB0BC;
	sub_830E4020(ctx, base);
	// 830FB0BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB0C0: 41800030  blt 0x830fb0f0
	if ctx.cr[0].lt {
	pc = 0x830FB0F0; continue 'dispatch;
	}
	// 830FB0C4: 3B9F0038  addi r28, r31, 0x38
	ctx.r[28].s64 = ctx.r[31].s64 + 56;
	// 830FB0C8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB0CC: 3B7F0034  addi r27, r31, 0x34
	ctx.r[27].s64 = ctx.r[31].s64 + 52;
	// 830FB0D0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830FB0D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830FB0D8: 4BFEC731  bl 0x830e7808
	ctx.lr = 0x830FB0DC;
	sub_830E7808(ctx, base);
	// 830FB0DC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FB0E0: 40800020  bge 0x830fb100
	if !ctx.cr[0].lt {
	pc = 0x830FB100; continue 'dispatch;
	}
	// 830FB0E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB0E8: 4BFDE741  bl 0x830d9828
	ctx.lr = 0x830FB0EC;
	sub_830D9828(ctx, base);
	// 830FB0EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FB0F0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 830FB0F4: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 830FB0F8: 480AD9CD  bl 0x831a8ac4
	ctx.lr = 0x830FB0FC;
	sub_831A8A8C(ctx, base);
	// 830FB0FC: 480AD0B4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 830FB100: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830FB104: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB108: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 830FB10C: 388B8A58  addi r4, r11, -0x75a8
	ctx.r[4].s64 = ctx.r[11].s64 + -30120;
	// 830FB110: 4BFD35E1  bl 0x830ce6f0
	ctx.lr = 0x830FB114;
	sub_830CE6F0(ctx, base);
	// 830FB114: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830FB118: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 830FB11C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB120: 388B8A48  addi r4, r11, -0x75b8
	ctx.r[4].s64 = ctx.r[11].s64 + -30136;
	// 830FB124: 4BFD35CD  bl 0x830ce6f0
	ctx.lr = 0x830FB128;
	sub_830CE6F0(ctx, base);
	// 830FB128: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830FB12C: 4800738D  bl 0x831024b8
	ctx.lr = 0x830FB130;
	sub_831024B8(ctx, base);
	// 830FB130: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830FB134: 48007385  bl 0x831024b8
	ctx.lr = 0x830FB138;
	sub_831024B8(ctx, base);
	// 830FB138: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 830FB13C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FB140: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB144: 4BFEC6C5  bl 0x830e7808
	ctx.lr = 0x830FB148;
	sub_830E7808(ctx, base);
	// 830FB148: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830FB14C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FB150: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830FB154: 4BFF226D  bl 0x830ed3c0
	ctx.lr = 0x830FB158;
	sub_830ED3C0(ctx, base);
	// 830FB158: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB15C: 4180000C  blt 0x830fb168
	if ctx.cr[0].lt {
	pc = 0x830FB168; continue 'dispatch;
	}
	// 830FB160: C38100A4  lfs f28, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830FB164: 48000008  b 0x830fb16c
	pc = 0x830FB16C; continue 'dispatch;
	// 830FB168: C3810060  lfs f28, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830FB16C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830FB170: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FB174: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FB178: 4BFF2249  bl 0x830ed3c0
	ctx.lr = 0x830FB17C;
	sub_830ED3C0(ctx, base);
	// 830FB17C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB180: 4180000C  blt 0x830fb18c
	if ctx.cr[0].lt {
	pc = 0x830FB18C; continue 'dispatch;
	}
	// 830FB184: C3A10084  lfs f29, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FB188: 48000008  b 0x830fb190
	pc = 0x830FB190; continue 'dispatch;
	// 830FB18C: C3A10064  lfs f29, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FB190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FB194: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB198: C3EB08A8  lfs f31, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830FB19C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830FB1A0: 41980010  blt cr6, 0x830fb1b0
	if ctx.cr[6].lt {
	pc = 0x830FB1B0; continue 'dispatch;
	}
	// 830FB1A4: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB1A8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830FB1AC: 4098005C  bge cr6, 0x830fb208
	if !ctx.cr[6].lt {
	pc = 0x830FB208; continue 'dispatch;
	}
	// 830FB1B0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 830FB1B4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FB1B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB1BC: 4BFE4AC5  bl 0x830dfc80
	ctx.lr = 0x830FB1C0;
	sub_830DFC80(ctx, base);
	// 830FB1C0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830FB1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FB1C8: 409A0010  bne cr6, 0x830fb1d8
	if !ctx.cr[6].eq {
	pc = 0x830FB1D8; continue 'dispatch;
	}
	// 830FB1CC: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830FB1D0: 396B971C  addi r11, r11, -0x68e4
	ctx.r[11].s64 = ctx.r[11].s64 + -26852;
	// 830FB1D4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830FB1D8: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 830FB1DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FB1E0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB1E4: 4BFE4A9D  bl 0x830dfc80
	ctx.lr = 0x830FB1E8;
	sub_830DFC80(ctx, base);
	// 830FB1E8: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB1EC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830FB1F0: 40980008  bge cr6, 0x830fb1f8
	if !ctx.cr[6].lt {
	pc = 0x830FB1F8; continue 'dispatch;
	}
	// 830FB1F4: D3FB0000  stfs f31, 0(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830FB1F8: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB1FC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830FB200: 40980008  bge cr6, 0x830fb208
	if !ctx.cr[6].lt {
	pc = 0x830FB208; continue 'dispatch;
	}
	// 830FB204: D3FC0000  stfs f31, 0(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830FB208: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB20C: 4BFDE61D  bl 0x830d9828
	ctx.lr = 0x830FB210;
	sub_830D9828(ctx, base);
	// 830FB210: C19C0000  lfs f12, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB214: C01F0044  lfs f0, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB218: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830FB21C: 40980008  bge cr6, 0x830fb224
	if !ctx.cr[6].lt {
	pc = 0x830FB224; continue 'dispatch;
	}
	// 830FB220: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830FB224: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB228: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB22C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830FB230: 40980008  bge cr6, 0x830fb238
	if !ctx.cr[6].lt {
	pc = 0x830FB238; continue 'dispatch;
	}
	// 830FB234: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830FB238: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FB23C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FB240: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830FB244: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FB248: 409A0028  bne cr6, 0x830fb270
	if !ctx.cr[6].eq {
	pc = 0x830FB270; continue 'dispatch;
	}
	// 830FB24C: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB250: C17F0094  lfs f11, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FB254: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830FB258: ED6B602A  fadds f11, f11, f12
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FB25C: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FB260: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830FB264: EC1D5828  fsubs f0, f29, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[11].f64) as f32) as f64);
	// 830FB268: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830FB26C: 4800000C  b 0x830fb278
	pc = 0x830FB278; continue 'dispatch;
	// 830FB270: D3DF008C  stfs f30, 0x8c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830FB274: D3DF0088  stfs f30, 0x88(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830FB278: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830FB27C: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FB280: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830FB284: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB288: C00AC3C8  lfs f0, -0x3c38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB28C: 419A000C  beq cr6, 0x830fb298
	if ctx.cr[6].eq {
	pc = 0x830FB298; continue 'dispatch;
	}
	// 830FB290: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FB294: 409A001C  bne cr6, 0x830fb2b0
	if !ctx.cr[6].eq {
	pc = 0x830FB2B0; continue 'dispatch;
	}
	// 830FB298: C17F0044  lfs f11, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FB29C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830FB2A0: ED6B6028  fsubs f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 830FB2A4: FD605A10  fabs f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 & !0x8000_0000_0000_0000u64;
	// 830FB2A8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 830FB2AC: 40980008  bge cr6, 0x830fb2b4
	if !ctx.cr[6].lt {
	pc = 0x830FB2B4; continue 'dispatch;
	}
	// 830FB2B0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 830FB2B4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830FB2B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB2BC: 419A000C  beq cr6, 0x830fb2c8
	if ctx.cr[6].eq {
	pc = 0x830FB2C8; continue 'dispatch;
	}
	// 830FB2C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FB2C4: 409A001C  bne cr6, 0x830fb2e0
	if !ctx.cr[6].eq {
	pc = 0x830FB2E0; continue 'dispatch;
	}
	// 830FB2C8: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FB2CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830FB2D0: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830FB2D4: FD605A10  fabs f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 & !0x8000_0000_0000_0000u64;
	// 830FB2D8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 830FB2DC: 40980008  bge cr6, 0x830fb2e4
	if !ctx.cr[6].lt {
	pc = 0x830FB2E4; continue 'dispatch;
	}
	// 830FB2E0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830FB2E4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830FB2E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FB2EC: 409A0008  bne cr6, 0x830fb2f4
	if !ctx.cr[6].eq {
	pc = 0x830FB2F4; continue 'dispatch;
	}
	// 830FB2F0: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830FB2F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB2F8: 409A0008  bne cr6, 0x830fb300
	if !ctx.cr[6].eq {
	pc = 0x830FB300; continue 'dispatch;
	}
	// 830FB2FC: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830FB300: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830FB304: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FB308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FB30C: 4BFF22BD  bl 0x830ed5c8
	ctx.lr = 0x830FB310;
	sub_830ED5C8(ctx, base);
	// 830FB310: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830FB314: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB318: 419A02F0  beq cr6, 0x830fb608
	if ctx.cr[6].eq {
	pc = 0x830FB608; continue 'dispatch;
	}
	// 830FB31C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FB320: FC00F090  fmr f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[30].f64;
	// 830FB324: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB328: 4182000C  beq 0x830fb334
	if ctx.cr[0].eq {
	pc = 0x830FB334; continue 'dispatch;
	}
	// 830FB32C: C3DF0088  lfs f30, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FB330: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB334: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FB338: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB33C: 419A01C8  beq cr6, 0x830fb504
	if ctx.cr[6].eq {
	pc = 0x830FB504; continue 'dispatch;
	}
	// 830FB340: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FB344: 419A0110  beq cr6, 0x830fb454
	if ctx.cr[6].eq {
	pc = 0x830FB454; continue 'dispatch;
	}
	// 830FB348: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FB34C: 409900E8  ble cr6, 0x830fb434
	if !ctx.cr[6].gt {
	pc = 0x830FB434; continue 'dispatch;
	}
	// 830FB350: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FB354: 419900E0  bgt cr6, 0x830fb434
	if ctx.cr[6].gt {
	pc = 0x830FB434; continue 'dispatch;
	}
	// 830FB358: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB35C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830FB360: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB364: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830FB368: C19C0000  lfs f12, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB36C: C17F0054  lfs f11, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FB370: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FB374: C3BC0000  lfs f29, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FB378: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FB37C: EFE06024  fdivs f31, f0, f12
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830FB380: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB384: 480B0CBD  bl 0x831ac040
	ctx.lr = 0x830FB388;
	sub_831AC040(ctx, base);
	// 830FB388: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB38C: EC1D002A  fadds f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FB390: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FB394: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB398: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 830FB39C: 4198000C  blt cr6, 0x830fb3a8
	if ctx.cr[6].lt {
	pc = 0x830FB3A8; continue 'dispatch;
	}
	// 830FB3A0: 480B06F9  bl 0x831aba98
	ctx.lr = 0x830FB3A4;
	sub_831ABA98(ctx, base);
	// 830FB3A4: 48000008  b 0x830fb3ac
	pc = 0x830FB3AC; continue 'dispatch;
	// 830FB3A8: 480B0961  bl 0x831abd08
	ctx.lr = 0x830FB3AC;
	sub_831ABD08(ctx, base);
	// 830FB3AC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB3B0: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB3B4: C19F0058  lfs f12, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB3B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830FB3BC: C3BB0000  lfs f29, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FB3C0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FB3C4: 398000E0  li r12, 0xe0
	ctx.r[12].s64 = 224;
	// 830FB3C8: 7C1F67AE  stfiwx f0, r31, r12
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 830FB3CC: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB3D0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FB3D4: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB3D8: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FB3DC: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 830FB3E0: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FB3E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB3E8: 480B0C59  bl 0x831ac040
	ctx.lr = 0x830FB3EC;
	sub_831AC040(ctx, base);
	// 830FB3EC: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB3F0: EC1D002A  fadds f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FB3F4: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FB3F8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB3FC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 830FB400: 4198000C  blt cr6, 0x830fb40c
	if ctx.cr[6].lt {
	pc = 0x830FB40C; continue 'dispatch;
	}
	// 830FB404: 480B0695  bl 0x831aba98
	ctx.lr = 0x830FB408;
	sub_831ABA98(ctx, base);
	// 830FB408: 48000008  b 0x830fb410
	pc = 0x830FB410; continue 'dispatch;
	// 830FB40C: 480B08FD  bl 0x831abd08
	ctx.lr = 0x830FB410;
	sub_831ABD08(ctx, base);
	// 830FB410: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB414: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FB418: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FB41C: 398000E4  li r12, 0xe4
	ctx.r[12].s64 = 228;
	// 830FB420: 7C1F67AE  stfiwx f0, r31, r12
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 830FB424: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FB428: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830FB42C: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 830FB430: 48000184  b 0x830fb5b4
	pc = 0x830FB5B4; continue 'dispatch;
	// 830FB434: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 830FB438: 63FFFFFF  ori r31, r31, 0xffff
	ctx.r[31].u64 = ctx.r[31].u64 | 65535;
	// 830FB43C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830FB440: 48007649  bl 0x83102a88
	ctx.lr = 0x830FB444;
	sub_83102A88(ctx, base);
	// 830FB444: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830FB448: 48007641  bl 0x83102a88
	ctx.lr = 0x830FB44C;
	sub_83102A88(ctx, base);
	// 830FB44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FB450: 4BFFFCA0  b 0x830fb0f0
	pc = 0x830FB0F0; continue 'dispatch;
	// 830FB454: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB458: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FB45C: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB460: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FB464: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB468: C19F0058  lfs f12, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB46C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FB470: C3BB0000  lfs f29, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FB474: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 830FB478: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FB47C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB480: 480B0BC1  bl 0x831ac040
	ctx.lr = 0x830FB484;
	sub_831AC040(ctx, base);
	// 830FB484: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB488: EC1D002A  fadds f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FB48C: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FB490: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB494: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 830FB498: 4198001C  blt cr6, 0x830fb4b4
	if ctx.cr[6].lt {
	pc = 0x830FB4B4; continue 'dispatch;
	}
	// 830FB49C: 480B05FD  bl 0x831aba98
	ctx.lr = 0x830FB4A0;
	sub_831ABA98(ctx, base);
	// 830FB4A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB4A4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FB4A8: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 830FB4AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FB4B0: 48000018  b 0x830fb4c8
	pc = 0x830FB4C8; continue 'dispatch;
	// 830FB4B4: 480B0855  bl 0x831abd08
	ctx.lr = 0x830FB4B8;
	sub_831ABD08(ctx, base);
	// 830FB4B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB4BC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FB4C0: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 830FB4C4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FB4C8: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 830FB4CC: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB4D0: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 830FB4D4: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB4D8: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830FB4DC: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FB4E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830FB4E4: C19F0044  lfs f12, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB4E8: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB4EC: EC2D033A  fmadds f1, f13, f12, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830FB4F0: 480B0819  bl 0x831abd08
	ctx.lr = 0x830FB4F4;
	sub_831ABD08(ctx, base);
	// 830FB4F4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB4F8: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB4FC: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830FB500: 480000B0  b 0x830fb5b0
	pc = 0x830FB5B0; continue 'dispatch;
	// 830FB504: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB508: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FB50C: C1810060  lfs f12, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB510: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830FB514: C19C0000  lfs f12, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB518: C17F0054  lfs f11, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FB51C: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 830FB520: C3DC0000  lfs f30, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FB524: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830FB528: EFE06024  fdivs f31, f0, f12
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830FB52C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB530: 480B0B11  bl 0x831ac040
	ctx.lr = 0x830FB534;
	sub_831AC040(ctx, base);
	// 830FB534: C01F0054  lfs f0, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB538: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FB53C: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 830FB540: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830FB544: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830FB548: 4198001C  blt cr6, 0x830fb564
	if ctx.cr[6].lt {
	pc = 0x830FB564; continue 'dispatch;
	}
	// 830FB54C: 480B054D  bl 0x831aba98
	ctx.lr = 0x830FB550;
	sub_831ABA98(ctx, base);
	// 830FB550: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB554: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FB558: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 830FB55C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FB560: 48000018  b 0x830fb578
	pc = 0x830FB578; continue 'dispatch;
	// 830FB564: 480B07A5  bl 0x831abd08
	ctx.lr = 0x830FB568;
	sub_831ABD08(ctx, base);
	// 830FB568: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB56C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FB570: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 830FB574: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FB578: C01F0044  lfs f0, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB57C: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 830FB580: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830FB584: 917F00E0  stw r11, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 830FB588: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 830FB58C: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB590: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FB594: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830FB598: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FB59C: C19F0048  lfs f12, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FB5A0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FB5A4: EC2D033A  fmadds f1, f13, f12, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830FB5A8: 480B0761  bl 0x831abd08
	ctx.lr = 0x830FB5AC;
	sub_831ABD08(ctx, base);
	// 830FB5AC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830FB5B0: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830FB5B4: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FB5B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FB5BC: 40980008  bge cr6, 0x830fb5c4
	if !ctx.cr[6].lt {
	pc = 0x830FB5C4; continue 'dispatch;
	}
	// 830FB5C0: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830FB5C4: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FB5C8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FB5CC: 40980008  bge cr6, 0x830fb5d4
	if !ctx.cr[6].lt {
	pc = 0x830FB5D4; continue 'dispatch;
	}
	// 830FB5D0: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 830FB5D4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FB5D8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FB5DC: 40980038  bge cr6, 0x830fb614
	if !ctx.cr[6].lt {
	pc = 0x830FB614; continue 'dispatch;
	}
	// 830FB5E0: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FB5E4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FB5E8: 409A000C  bne cr6, 0x830fb5f4
	if !ctx.cr[6].eq {
	pc = 0x830FB5F4; continue 'dispatch;
	}
	// 830FB5EC: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FB5F0: 48000010  b 0x830fb600
	pc = 0x830FB600; continue 'dispatch;
	// 830FB5F4: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FB5F8: 409A0018  bne cr6, 0x830fb610
	if !ctx.cr[6].eq {
	pc = 0x830FB610; continue 'dispatch;
	}
	// 830FB5FC: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FB600: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 830FB604: 48000010  b 0x830fb614
	pc = 0x830FB614; continue 'dispatch;
	// 830FB608: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 830FB60C: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 830FB610: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 830FB614: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FB618: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FB61C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FB620: 41980018  blt cr6, 0x830fb638
	if ctx.cr[6].lt {
	pc = 0x830FB638; continue 'dispatch;
	}
	// 830FB624: 813F00EC  lwz r9, 0xec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FB628: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830FB62C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830FB630: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830FB634: 915F00EC  stw r10, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 830FB638: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830FB63C: 4BFE1E75  bl 0x830dd4b0
	ctx.lr = 0x830FB640;
	sub_830DD4B0(ctx, base);
	// 830FB640: 907F00B0  stw r3, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 830FB644: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FB648: 40820010  bne 0x830fb658
	if !ctx.cr[0].eq {
	pc = 0x830FB658; continue 'dispatch;
	}
	// 830FB64C: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 830FB650: 63FF000E  ori r31, r31, 0xe
	ctx.r[31].u64 = ctx.r[31].u64 | 14;
	// 830FB654: 4BFFFDE8  b 0x830fb43c
	pc = 0x830FB43C; continue 'dispatch;
	// 830FB658: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FB65C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 830FB660: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB664: 40990028  ble cr6, 0x830fb68c
	if !ctx.cr[6].gt {
	pc = 0x830FB68C; continue 'dispatch;
	}
	// 830FB668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FB66C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FB670: 4BFF6209  bl 0x830f1878
	ctx.lr = 0x830FB674;
	sub_830F1878(ctx, base);
	// 830FB674: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB678: 41800038  blt 0x830fb6b0
	if ctx.cr[0].lt {
	pc = 0x830FB6B0; continue 'dispatch;
	}
	// 830FB67C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FB680: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830FB684: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FB688: 4198FFE0  blt cr6, 0x830fb668
	if ctx.cr[6].lt {
	pc = 0x830FB668; continue 'dispatch;
	}
	// 830FB68C: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FB690: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB694: 419A0024  beq cr6, 0x830fb6b8
	if ctx.cr[6].eq {
	pc = 0x830FB6B8; continue 'dispatch;
	}
	// 830FB698: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FB69C: 419A001C  beq cr6, 0x830fb6b8
	if ctx.cr[6].eq {
	pc = 0x830FB6B8; continue 'dispatch;
	}
	// 830FB6A0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FB6A4: 419A0014  beq cr6, 0x830fb6b8
	if ctx.cr[6].eq {
	pc = 0x830FB6B8; continue 'dispatch;
	}
	// 830FB6A8: 837F00E0  lwz r27, 0xe0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FB6AC: 48000010  b 0x830fb6bc
	pc = 0x830FB6BC; continue 'dispatch;
	// 830FB6B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FB6B4: 4BFFFD88  b 0x830fb43c
	pc = 0x830FB43C; continue 'dispatch;
	// 830FB6B8: 837F00E4  lwz r27, 0xe4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FB6BC: 5763103A  slwi r3, r27, 2
	ctx.r[3].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830FB6C0: 4BFE1DF1  bl 0x830dd4b0
	ctx.lr = 0x830FB6C4;
	sub_830DD4B0(ctx, base);
	// 830FB6C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FB6C8: 907F00B8  stw r3, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[3].u32 ) };
	// 830FB6CC: 4182FF80  beq 0x830fb64c
	if ctx.cr[0].eq {
	pc = 0x830FB64C; continue 'dispatch;
	}
	// 830FB6D0: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 830FB6D4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FB6D8: 4099006C  ble cr6, 0x830fb744
	if !ctx.cr[6].gt {
	pc = 0x830FB744; continue 'dispatch;
	}
	// 830FB6DC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 830FB6E0: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FB6E4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FB6E8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830FB6EC: 807F00A8  lwz r3, 0xa8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 830FB6F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830FB6F4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FB6F8: 4BFE8929  bl 0x830e4020
	ctx.lr = 0x830FB6FC;
	sub_830E4020(ctx, base);
	// 830FB6FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB700: 4180FFB0  blt 0x830fb6b0
	if ctx.cr[0].lt {
	pc = 0x830FB6B0; continue 'dispatch;
	}
	// 830FB704: 83BF002C  lwz r29, 0x2c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FB708: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830FB70C: 409A0008  bne cr6, 0x830fb714
	if !ctx.cr[6].eq {
	pc = 0x830FB714; continue 'dispatch;
	}
	// 830FB710: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB714: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FB718: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FB71C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FB720: 4BFEC159  bl 0x830e7878
	ctx.lr = 0x830FB724;
	sub_830E7878(ctx, base);
	// 830FB724: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 830FB728: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FB72C: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FB730: 4BFE3F91  bl 0x830df6c0
	ctx.lr = 0x830FB734;
	sub_830DF6C0(ctx, base);
	// 830FB734: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830FB738: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830FB73C: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830FB740: 4198FFA0  blt cr6, 0x830fb6e0
	if ctx.cr[6].lt {
	pc = 0x830FB6E0; continue 'dispatch;
	}
	// 830FB744: 937F00B4  stw r27, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[27].u32 ) };
	// 830FB748: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830FB74C: 4BFE3E45  bl 0x830df590
	ctx.lr = 0x830FB750;
	sub_830DF590(ctx, base);
	// 830FB750: 809F0024  lwz r4, 0x24(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FB754: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830FB758: 419A000C  beq cr6, 0x830fb764
	if ctx.cr[6].eq {
	pc = 0x830FB764; continue 'dispatch;
	}
	// 830FB75C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB760: 4BFE3F61  bl 0x830df6c0
	ctx.lr = 0x830FB764;
	sub_830DF6C0(ctx, base);
	// 830FB764: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FB768: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830FB76C: 419A000C  beq cr6, 0x830fb778
	if ctx.cr[6].eq {
	pc = 0x830FB778; continue 'dispatch;
	}
	// 830FB770: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB774: 4BFE3F4D  bl 0x830df6c0
	ctx.lr = 0x830FB778;
	sub_830DF6C0(ctx, base);
	// 830FB778: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FB77C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830FB780: 419A000C  beq cr6, 0x830fb78c
	if ctx.cr[6].eq {
	pc = 0x830FB78C; continue 'dispatch;
	}
	// 830FB784: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB788: 4BFE3F39  bl 0x830df6c0
	ctx.lr = 0x830FB78C;
	sub_830DF6C0(ctx, base);
	// 830FB78C: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FB790: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830FB794: 419A000C  beq cr6, 0x830fb7a0
	if ctx.cr[6].eq {
	pc = 0x830FB7A0; continue 'dispatch;
	}
	// 830FB798: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB79C: 4BFE3F25  bl 0x830df6c0
	ctx.lr = 0x830FB7A0;
	sub_830DF6C0(ctx, base);
	// 830FB7A0: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FB7A4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830FB7A8: 419A000C  beq cr6, 0x830fb7b4
	if ctx.cr[6].eq {
	pc = 0x830FB7B4; continue 'dispatch;
	}
	// 830FB7AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB7B0: 4BFE3F11  bl 0x830df6c0
	ctx.lr = 0x830FB7B4;
	sub_830DF6C0(ctx, base);
	// 830FB7B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FB7B8: 4BFE3DD9  bl 0x830df590
	ctx.lr = 0x830FB7BC;
	sub_830DF590(ctx, base);
	// 830FB7BC: 935F001C  stw r26, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 830FB7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FB7C4: 4BFFEB2D  bl 0x830fa2f0
	ctx.lr = 0x830FB7C8;
	sub_830FA2F0(ctx, base);
	// 830FB7C8: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FB7CC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FB7D0: 419A004C  beq cr6, 0x830fb81c
	if ctx.cr[6].eq {
	pc = 0x830FB81C; continue 'dispatch;
	}
	// 830FB7D4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FB7D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB7DC: 419A0040  beq cr6, 0x830fb81c
	if ctx.cr[6].eq {
	pc = 0x830FB81C; continue 'dispatch;
	}
	// 830FB7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FB7E4: 83DF00E8  lwz r30, 0xe8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FB7E8: 4BFFDF01  bl 0x830f96e8
	ctx.lr = 0x830FB7EC;
	sub_830F96E8(ctx, base);
	// 830FB7EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FB7F0: 48000020  b 0x830fb810
	pc = 0x830FB810; continue 'dispatch;
	// 830FB7F4: 935F001C  stw r26, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 830FB7F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FB7FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FB800: 4BFEC3B1  bl 0x830e7bb0
	ctx.lr = 0x830FB804;
	sub_830E7BB0(ctx, base);
	// 830FB804: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FB808: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB80C: 419A0010  beq cr6, 0x830fb81c
	if ctx.cr[6].eq {
	pc = 0x830FB81C; continue 'dispatch;
	}
	// 830FB810: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830FB814: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830FB818: 4099FFDC  ble cr6, 0x830fb7f4
	if !ctx.cr[6].gt {
	pc = 0x830FB7F4; continue 'dispatch;
	}
	// 830FB81C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830FB820: 4BFFFC1C  b 0x830fb43c
	pc = 0x830FB43C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FB828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FB828 size=1932
    let mut pc: u32 = 0x830FB828;
    'dispatch: loop {
        match pc {
            0x830FB828 => {
    //   block [0x830FB828..0x830FBFB4)
	// 830FB828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FB82C: 480AC905  bl 0x831a8130
	ctx.lr = 0x830FB830;
	sub_831A8130(ctx, base);
	// 830FB830: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 830FB834: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FB838: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830FB83C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FB840: 9361017C  stw r27, 0x17c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), ctx.r[27].u32 ) };
	// 830FB844: 4BFF1C25  bl 0x830ed468
	ctx.lr = 0x830FB848;
	sub_830ED468(ctx, base);
	// 830FB848: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FB84C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FB850: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830FB854: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FB858: 4BFE3F79  bl 0x830df7d0
	ctx.lr = 0x830FB85C;
	sub_830DF7D0(ctx, base);
	// 830FB85C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FB864: 419A04BC  beq cr6, 0x830fbd20
	if ctx.cr[6].eq {
	pc = 0x830FBD20; continue 'dispatch;
	}
	// 830FB868: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FB86C: 3CE08219  lis r7, -0x7de7
	ctx.r[7].s64 = -2112290816;
	// 830FB870: 3CC08219  lis r6, -0x7de7
	ctx.r[6].s64 = -2112290816;
	// 830FB874: 3CA08219  lis r5, -0x7de7
	ctx.r[5].s64 = -2112290816;
	// 830FB878: 3C808219  lis r4, -0x7de7
	ctx.r[4].s64 = -2112290816;
	// 830FB87C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830FB880: 3FE08219  lis r31, -0x7de7
	ctx.r[31].s64 = -2112290816;
	// 830FB884: 3FC08219  lis r30, -0x7de7
	ctx.r[30].s64 = -2112290816;
	// 830FB888: 3D008219  lis r8, -0x7de7
	ctx.r[8].s64 = -2112290816;
	// 830FB88C: 3D208219  lis r9, -0x7de7
	ctx.r[9].s64 = -2112290816;
	// 830FB890: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830FB894: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830FB898: 3DE08339  lis r15, -0x7cc7
	ctx.r[15].s64 = -2093416448;
	// 830FB89C: 3E008339  lis r16, -0x7cc7
	ctx.r[16].s64 = -2093416448;
	// 830FB8A0: 3E808339  lis r20, -0x7cc7
	ctx.r[20].s64 = -2093416448;
	// 830FB8A4: 3A678640  addi r19, r7, -0x79c0
	ctx.r[19].s64 = ctx.r[7].s64 + -31168;
	// 830FB8A8: 3B468688  addi r26, r6, -0x7978
	ctx.r[26].s64 = ctx.r[6].s64 + -31096;
	// 830FB8AC: 3B258598  addi r25, r5, -0x7a68
	ctx.r[25].s64 = ctx.r[5].s64 + -31336;
	// 830FB8B0: 3B0485CC  addi r24, r4, -0x7a34
	ctx.r[24].s64 = ctx.r[4].s64 + -31284;
	// 830FB8B4: 3AFF85F8  addi r23, r31, -0x7a08
	ctx.r[23].s64 = ctx.r[31].s64 + -31240;
	// 830FB8B8: 3ADE8624  addi r22, r30, -0x79dc
	ctx.r[22].s64 = ctx.r[30].s64 + -31196;
	// 830FB8BC: 3AA88664  addi r21, r8, -0x799c
	ctx.r[21].s64 = ctx.r[8].s64 + -31132;
	// 830FB8C0: 3A4986A4  addi r18, r9, -0x795c
	ctx.r[18].s64 = ctx.r[9].s64 + -31068;
	// 830FB8C4: 39CA974C  addi r14, r10, -0x68b4
	ctx.r[14].s64 = ctx.r[10].s64 + -26804;
	// 830FB8C8: 3A2B9730  addi r17, r11, -0x68d0
	ctx.r[17].s64 = ctx.r[11].s64 + -26832;
	// 830FB8CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FB8D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FB8D4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 830FB8D8: 4BFE43A9  bl 0x830dfc80
	ctx.lr = 0x830FB8DC;
	sub_830DFC80(ctx, base);
	// 830FB8DC: 8094C0B0  lwz r4, -0x3f50(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-16208 as u32) ) } as u64;
	// 830FB8E0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB8E4: 4BFD328D  bl 0x830ceb70
	ctx.lr = 0x830FB8E8;
	sub_830CEB70(ctx, base);
	// 830FB8E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FB8EC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB8F0: 41820058  beq 0x830fb948
	if ctx.cr[0].eq {
	pc = 0x830FB948; continue 'dispatch;
	}
	// 830FB8F4: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 830FB8F8: 4BFE3BC9  bl 0x830df4c0
	ctx.lr = 0x830FB8FC;
	sub_830DF4C0(ctx, base);
	// 830FB8FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB900: 418006A8  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FB904: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FB908: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FB90C: 419A0024  beq cr6, 0x830fb930
	if ctx.cr[6].eq {
	pc = 0x830FB930; continue 'dispatch;
	}
	// 830FB910: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FB914: 419A001C  beq cr6, 0x830fb930
	if ctx.cr[6].eq {
	pc = 0x830FB930; continue 'dispatch;
	}
	// 830FB918: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FB91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FB920: 409A03E0  bne cr6, 0x830fbd00
	if !ctx.cr[6].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FB924: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB928: 917D0020  stw r11, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830FB92C: 480003D4  b 0x830fbd00
	pc = 0x830FBD00; continue 'dispatch;
	// 830FB930: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FB934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FB938: 409A03C8  bne cr6, 0x830fbd00
	if !ctx.cr[6].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FB93C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB940: 917D0024  stw r11, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830FB944: 480003BC  b 0x830fbd00
	pc = 0x830FBD00; continue 'dispatch;
	// 830FB948: 8090C0B4  lwz r4, -0x3f4c(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-16204 as u32) ) } as u64;
	// 830FB94C: 4BFD3225  bl 0x830ceb70
	ctx.lr = 0x830FB950;
	sub_830CEB70(ctx, base);
	// 830FB950: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FB954: 41820030  beq 0x830fb984
	if ctx.cr[0].eq {
	pc = 0x830FB984; continue 'dispatch;
	}
	// 830FB958: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830FB95C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB960: 4BFE3BC9  bl 0x830df528
	ctx.lr = 0x830FB964;
	sub_830DF528(ctx, base);
	// 830FB964: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB968: 41800640  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FB96C: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FB970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FB974: 409A038C  bne cr6, 0x830fbd00
	if !ctx.cr[6].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FB978: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB97C: 917D0028  stw r11, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830FB980: 48000380  b 0x830fbd00
	pc = 0x830FBD00; continue 'dispatch;
	// 830FB984: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830FB988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FB98C: 419A0020  beq cr6, 0x830fb9ac
	if ctx.cr[6].eq {
	pc = 0x830FB9AC; continue 'dispatch;
	}
	// 830FB990: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830FB994: 480B649D  bl 0x831b1e30
	ctx.lr = 0x830FB998;
	sub_831B1E30(ctx, base);
	// 830FB998: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FB99C: 40820010  bne 0x830fb9ac
	if !ctx.cr[0].eq {
	pc = 0x830FB9AC; continue 'dispatch;
	}
	// 830FB9A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB9A4: 917D0030  stw r11, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830FB9A8: 48000358  b 0x830fbd00
	pc = 0x830FBD00; continue 'dispatch;
	// 830FB9AC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830FB9B0: 409A0350  bne cr6, 0x830fbd00
	if !ctx.cr[6].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FB9B4: 808FC0A0  lwz r4, -0x3f60(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-16224 as u32) ) } as u64;
	// 830FB9B8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB9BC: 4BFD31B5  bl 0x830ceb70
	ctx.lr = 0x830FB9C0;
	sub_830CEB70(ctx, base);
	// 830FB9C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FB9C4: 4082001C  bne 0x830fb9e0
	if !ctx.cr[0].eq {
	pc = 0x830FB9E0; continue 'dispatch;
	}
	// 830FB9C8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FB9CC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB9D0: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830FB9D4: 4BFD319D  bl 0x830ceb70
	ctx.lr = 0x830FB9D8;
	sub_830CEB70(ctx, base);
	// 830FB9D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FB9DC: 41820324  beq 0x830fbd00
	if ctx.cr[0].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FB9E0: 808FC0A0  lwz r4, -0x3f60(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-16224 as u32) ) } as u64;
	// 830FB9E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FB9E8: 4BFD3189  bl 0x830ceb70
	ctx.lr = 0x830FB9EC;
	sub_830CEB70(ctx, base);
	// 830FB9EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FB9F0: 41820080  beq 0x830fba70
	if ctx.cr[0].eq {
	pc = 0x830FBA70; continue 'dispatch;
	}
	// 830FB9F4: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 830FB9F8: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 830FB9FC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FBA00: 4BFE4281  bl 0x830dfc80
	ctx.lr = 0x830FBA04;
	sub_830DFC80(ctx, base);
	// 830FBA04: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830FBA08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBA0C: 419A02F4  beq cr6, 0x830fbd00
	if ctx.cr[6].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FBA10: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 830FBA14: 480B641D  bl 0x831b1e30
	ctx.lr = 0x830FBA18;
	sub_831B1E30(ctx, base);
	// 830FBA18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBA1C: 408202E4  bne 0x830fbd00
	if !ctx.cr[0].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FBA20: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FBA24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FBA28: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830FBA2C: 907D002C  stw r3, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 830FBA30: 4BFE3DA1  bl 0x830df7d0
	ctx.lr = 0x830FBA34;
	sub_830DF7D0(ctx, base);
	// 830FBA34: 48000024  b 0x830fba58
	pc = 0x830FBA58; continue 'dispatch;
	// 830FBA38: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FBA3C: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830FBA40: 4BFD3131  bl 0x830ceb70
	ctx.lr = 0x830FBA44;
	sub_830CEB70(ctx, base);
	// 830FBA44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FBA48: 40820020  bne 0x830fba68
	if !ctx.cr[0].eq {
	pc = 0x830FBA68; continue 'dispatch;
	}
	// 830FBA4C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FBA50: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830FBA54: 4BFE3E6D  bl 0x830df8c0
	ctx.lr = 0x830FBA58;
	sub_830DF8C0(ctx, base);
	// 830FBA58: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830FBA5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBA60: 409AFFD8  bne cr6, 0x830fba38
	if !ctx.cr[6].eq {
	pc = 0x830FBA38; continue 'dispatch;
	}
	// 830FBA64: 4800029C  b 0x830fbd00
	pc = 0x830FBD00; continue 'dispatch;
	// 830FBA68: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830FBA6C: 48000008  b 0x830fba74
	pc = 0x830FBA74; continue 'dispatch;
	// 830FBA70: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FBA74: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830FBA78: 419A0288  beq cr6, 0x830fbd00
	if ctx.cr[6].eq {
	pc = 0x830FBD00; continue 'dispatch;
	}
	// 830FBA7C: 389D0090  addi r4, r29, 0x90
	ctx.r[4].s64 = ctx.r[29].s64 + 144;
	// 830FBA80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBA84: 4BFE3FCD  bl 0x830dfa50
	ctx.lr = 0x830FBA88;
	sub_830DFA50(ctx, base);
	// 830FBA88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBA8C: 4180051C  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBA90: 3BDD0040  addi r30, r29, 0x40
	ctx.r[30].s64 = ctx.r[29].s64 + 64;
	// 830FBA94: 3B7D003C  addi r27, r29, 0x3c
	ctx.r[27].s64 = ctx.r[29].s64 + 60;
	// 830FBA98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830FBA9C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830FBAA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBAA4: 4BFEBD65  bl 0x830e7808
	ctx.lr = 0x830FBAA8;
	sub_830E7808(ctx, base);
	// 830FBAA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBAAC: 418004FC  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBAB0: 389D009C  addi r4, r29, 0x9c
	ctx.r[4].s64 = ctx.r[29].s64 + 156;
	// 830FBAB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBAB8: 4BFE4431  bl 0x830dfee8
	ctx.lr = 0x830FBABC;
	sub_830DFEE8(ctx, base);
	// 830FBABC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBAC0: 418004E8  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBAC4: 389D00A0  addi r4, r29, 0xa0
	ctx.r[4].s64 = ctx.r[29].s64 + 160;
	// 830FBAC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBACC: 4BFE380D  bl 0x830df2d8
	ctx.lr = 0x830FBAD0;
	sub_830DF2D8(ctx, base);
	// 830FBAD0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBAD4: 418004D4  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBAD8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830FBADC: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 830FBAE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830FBAE4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBAE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBAEC: 4BFD2C05  bl 0x830ce6f0
	ctx.lr = 0x830FBAF0;
	sub_830CE6F0(ctx, base);
	// 830FBAF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBAF4: 418004B4  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBAF8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830FBAFC: 480069BD  bl 0x831024b8
	ctx.lr = 0x830FBB00;
	sub_831024B8(ctx, base);
	// 830FBB00: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBB04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBB08: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBB0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBB10: 4BFD67D9  bl 0x830d22e8
	ctx.lr = 0x830FBB14;
	sub_830D22E8(ctx, base);
	// 830FBB14: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830FBB18: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830FBB1C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBB20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBB24: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FBB28: 4BFD2BC9  bl 0x830ce6f0
	ctx.lr = 0x830FBB2C;
	sub_830CE6F0(ctx, base);
	// 830FBB2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FBB30: 418001FC  blt 0x830fbd2c
	if ctx.cr[0].lt {
	pc = 0x830FBD2C; continue 'dispatch;
	}
	// 830FBB34: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBB38: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBB3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBB40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBB44: 4BFD67A5  bl 0x830d22e8
	ctx.lr = 0x830FBB48;
	sub_830D22E8(ctx, base);
	// 830FBB48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830FBB4C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 830FBB50: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBB54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBB58: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FBB5C: 4BFD2B95  bl 0x830ce6f0
	ctx.lr = 0x830FBB60;
	sub_830CE6F0(ctx, base);
	// 830FBB60: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FBB64: 418001C8  blt 0x830fbd2c
	if ctx.cr[0].lt {
	pc = 0x830FBD2C; continue 'dispatch;
	}
	// 830FBB68: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBB6C: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBB70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBB74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBB78: 4BFD6771  bl 0x830d22e8
	ctx.lr = 0x830FBB7C;
	sub_830D22E8(ctx, base);
	// 830FBB7C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830FBB80: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830FBB84: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBB88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBB8C: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830FBB90: 4BFD2B61  bl 0x830ce6f0
	ctx.lr = 0x830FBB94;
	sub_830CE6F0(ctx, base);
	// 830FBB94: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FBB98: 41800194  blt 0x830fbd2c
	if ctx.cr[0].lt {
	pc = 0x830FBD2C; continue 'dispatch;
	}
	// 830FBB9C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBBA0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBBA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBBA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBBAC: 4BFD673D  bl 0x830d22e8
	ctx.lr = 0x830FBBB0;
	sub_830D22E8(ctx, base);
	// 830FBBB0: C0010084  lfs f0, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FBBB4: FC00F82E  fsel f0, f0, f0, f31
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 830FBBB8: D3FD0078  stfs f31, 0x78(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830FBBBC: D01D0068  stfs f0, 0x68(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830FBBC0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830FBBC4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBBC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBBCC: 4BFD2B25  bl 0x830ce6f0
	ctx.lr = 0x830FBBD0;
	sub_830CE6F0(ctx, base);
	// 830FBBD0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FBBD4: 41800158  blt 0x830fbd2c
	if ctx.cr[0].lt {
	pc = 0x830FBD2C; continue 'dispatch;
	}
	// 830FBBD8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBBDC: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBBE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBBE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBBE8: 4BFD6701  bl 0x830d22e8
	ctx.lr = 0x830FBBEC;
	sub_830D22E8(ctx, base);
	// 830FBBEC: C0010084  lfs f0, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FBBF0: FC00F82E  fsel f0, f0, f0, f31
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 830FBBF4: D01D006C  stfs f0, 0x6c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830FBBF8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830FBBFC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBC00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBC04: 4BFD2AED  bl 0x830ce6f0
	ctx.lr = 0x830FBC08;
	sub_830CE6F0(ctx, base);
	// 830FBC08: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FBC0C: 41800120  blt 0x830fbd2c
	if ctx.cr[0].lt {
	pc = 0x830FBD2C; continue 'dispatch;
	}
	// 830FBC10: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBC14: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBC18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBC1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBC20: 4BFD66C9  bl 0x830d22e8
	ctx.lr = 0x830FBC24;
	sub_830D22E8(ctx, base);
	// 830FBC24: C0010084  lfs f0, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FBC28: FC00F82E  fsel f0, f0, f0, f31
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 830FBC2C: D01D0070  stfs f0, 0x70(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830FBC30: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FBC34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830FBC38: C19D0034  lfs f12, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FBC3C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBC40: C17B0000  lfs f11, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FBC44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBC48: D1BD004C  stfs f13, 0x4c(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830FBC4C: D19D0048  stfs f12, 0x48(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830FBC50: D17D0050  stfs f11, 0x50(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830FBC54: C01D0038  lfs f0, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FBC58: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830FBC5C: 4BFD2A95  bl 0x830ce6f0
	ctx.lr = 0x830FBC60;
	sub_830CE6F0(ctx, base);
	// 830FBC60: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FBC64: 418000C8  blt 0x830fbd2c
	if ctx.cr[0].lt {
	pc = 0x830FBD2C; continue 'dispatch;
	}
	// 830FBC68: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBC6C: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBC70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBC74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBC78: 4BFD6671  bl 0x830d22e8
	ctx.lr = 0x830FBC7C;
	sub_830D22E8(ctx, base);
	// 830FBC7C: C0010088  lfs f0, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FBC80: C1BD0038  lfs f13, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FBC84: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830FBC88: 40990008  ble cr6, 0x830fbc90
	if !ctx.cr[6].gt {
	pc = 0x830FBC90; continue 'dispatch;
	}
	// 830FBC8C: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830FBC90: C1BD0034  lfs f13, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FBC94: C0010084  lfs f0, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FBC98: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830FBC9C: 40990008  ble cr6, 0x830fbca4
	if !ctx.cr[6].gt {
	pc = 0x830FBCA4; continue 'dispatch;
	}
	// 830FBCA0: D01D0048  stfs f0, 0x48(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830FBCA4: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 830FBCA8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830FBCAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBCB0: 4BFD2A41  bl 0x830ce6f0
	ctx.lr = 0x830FBCB4;
	sub_830CE6F0(ctx, base);
	// 830FBCB4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FBCB8: 41800074  blt 0x830fbd2c
	if ctx.cr[0].lt {
	pc = 0x830FBD2C; continue 'dispatch;
	}
	// 830FBCBC: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830FBCC0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FBCC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FBCC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBCCC: 4BFD661D  bl 0x830d22e8
	ctx.lr = 0x830FBCD0;
	sub_830D22E8(ctx, base);
	// 830FBCD0: C0010088  lfs f0, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FBCD4: C1A10084  lfs f13, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FBCD8: FC00F82E  fsel f0, f0, f0, f31
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 830FBCDC: FDADFB6E  fsel f13, f13, f13, f31
	ctx.f[13].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[31].f64 };
	// 830FBCE0: D01D0054  stfs f0, 0x54(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830FBCE4: D1BD0058  stfs f13, 0x58(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830FBCE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FBCEC: 4BFEA24D  bl 0x830e5f38
	ctx.lr = 0x830FBCF0;
	sub_830E5F38(ctx, base);
	// 830FBCF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830FBCF4: 48006D95  bl 0x83102a88
	ctx.lr = 0x830FBCF8;
	sub_83102A88(ctx, base);
	// 830FBCF8: 8361017C  lwz r27, 0x17c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 830FBCFC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FBD00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FBD04: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FBD08: 4BFE3BB9  bl 0x830df8c0
	ctx.lr = 0x830FBD0C;
	sub_830DF8C0(ctx, base);
	// 830FBD0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FBD10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBD14: 409AFBB8  bne cr6, 0x830fb8cc
	if !ctx.cr[6].eq {
	pc = 0x830FB8CC; continue 'dispatch;
	}
	// 830FBD18: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830FBD1C: 409A0020  bne cr6, 0x830fbd3c
	if !ctx.cr[6].eq {
	pc = 0x830FBD3C; continue 'dispatch;
	}
	// 830FBD20: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830FBD24: 60630017  ori r3, r3, 0x17
	ctx.r[3].u64 = ctx.r[3].u64 | 23;
	// 830FBD28: 48000280  b 0x830fbfa8
	pc = 0x830FBFA8; continue 'dispatch;
	// 830FBD2C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830FBD30: 48006D59  bl 0x83102a88
	ctx.lr = 0x830FBD34;
	sub_83102A88(ctx, base);
	// 830FBD34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FBD38: 48000270  b 0x830fbfa8
	pc = 0x830FBFA8; continue 'dispatch;
	// 830FBD3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830FBD40: 4BFE3851  bl 0x830df590
	ctx.lr = 0x830FBD44;
	sub_830DF590(ctx, base);
	// 830FBD44: 807D0024  lwz r3, 0x24(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FBD48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBD4C: 419A0008  beq cr6, 0x830fbd54
	if ctx.cr[6].eq {
	pc = 0x830FBD54; continue 'dispatch;
	}
	// 830FBD50: 4BFE39C1  bl 0x830df710
	ctx.lr = 0x830FBD54;
	sub_830DF710(ctx, base);
	// 830FBD54: 807D0020  lwz r3, 0x20(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FBD58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBD5C: 419A0008  beq cr6, 0x830fbd64
	if ctx.cr[6].eq {
	pc = 0x830FBD64; continue 'dispatch;
	}
	// 830FBD60: 4BFE39B1  bl 0x830df710
	ctx.lr = 0x830FBD64;
	sub_830DF710(ctx, base);
	// 830FBD64: 807D0028  lwz r3, 0x28(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FBD68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBD6C: 419A0008  beq cr6, 0x830fbd74
	if ctx.cr[6].eq {
	pc = 0x830FBD74; continue 'dispatch;
	}
	// 830FBD70: 4BFE39A1  bl 0x830df710
	ctx.lr = 0x830FBD74;
	sub_830DF710(ctx, base);
	// 830FBD74: 807D002C  lwz r3, 0x2c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FBD78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBD7C: 419A0008  beq cr6, 0x830fbd84
	if ctx.cr[6].eq {
	pc = 0x830FBD84; continue 'dispatch;
	}
	// 830FBD80: 4BFE3991  bl 0x830df710
	ctx.lr = 0x830FBD84;
	sub_830DF710(ctx, base);
	// 830FBD84: 807D0030  lwz r3, 0x30(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FBD88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FBD8C: 419A0008  beq cr6, 0x830fbd94
	if ctx.cr[6].eq {
	pc = 0x830FBD94; continue 'dispatch;
	}
	// 830FBD90: 4BFE3981  bl 0x830df710
	ctx.lr = 0x830FBD94;
	sub_830DF710(ctx, base);
	// 830FBD94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBD98: 4BFE3979  bl 0x830df710
	ctx.lr = 0x830FBD9C;
	sub_830DF710(ctx, base);
	// 830FBD9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FBDA0: 4BFE37F1  bl 0x830df590
	ctx.lr = 0x830FBDA4;
	sub_830DF590(ctx, base);
	// 830FBDA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FBDA8: 4BFDDA81  bl 0x830d9828
	ctx.lr = 0x830FBDAC;
	sub_830D9828(ctx, base);
	// 830FBDAC: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 830FBDB0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830FBDB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FBDB8: 4BFE3EC9  bl 0x830dfc80
	ctx.lr = 0x830FBDBC;
	sub_830DFC80(ctx, base);
	// 830FBDBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBDC0: 418001E8  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBDC4: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 830FBDC8: 3BE10074  addi r31, r1, 0x74
	ctx.r[31].s64 = ctx.r[1].s64 + 116;
	// 830FBDCC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FBDD0: 3B81005C  addi r28, r1, 0x5c
	ctx.r[28].s64 = ctx.r[1].s64 + 92;
	// 830FBDD4: 4BFEB985  bl 0x830e7758
	ctx.lr = 0x830FBDD8;
	sub_830E7758(ctx, base);
	// 830FBDD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FBDDC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830FBDE0: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830FBDE4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830FBDE8: 4BFE7539  bl 0x830e3320
	ctx.lr = 0x830FBDEC;
	sub_830E3320(ctx, base);
	// 830FBDEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBDF0: 418001B8  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBDF4: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FBDF8: 93DD00A8  stw r30, 0xa8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 830FBDFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FBE00: 419A00F8  beq cr6, 0x830fbef8
	if ctx.cr[6].eq {
	pc = 0x830FBEF8; continue 'dispatch;
	}
	// 830FBE04: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830FBE08: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FBE0C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 830FBE10: 388B8910  addi r4, r11, -0x76f0
	ctx.r[4].s64 = ctx.r[11].s64 + -30448;
	// 830FBE14: 4BFD28DD  bl 0x830ce6f0
	ctx.lr = 0x830FBE18;
	sub_830CE6F0(ctx, base);
	// 830FBE18: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830FBE1C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FBE20: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FBE28: 409A000C  bne cr6, 0x830fbe34
	if !ctx.cr[6].eq {
	pc = 0x830FBE34; continue 'dispatch;
	}
	// 830FBE2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830FBE30: 4800000C  b 0x830fbe3c
	pc = 0x830FBE3C; continue 'dispatch;
	// 830FBE34: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBE38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FBE3C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FBE40: 40980138  bge cr6, 0x830fbf78
	if !ctx.cr[6].lt {
	pc = 0x830FBF78; continue 'dispatch;
	}
	// 830FBE44: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBE48: 83CFC0A0  lwz r30, -0x3f60(r15)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-16224 as u32) ) } as u64;
	// 830FBE4C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FBE50: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[31].s32 as i64);
	// 830FBE54: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FBE58: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 830FBE5C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBE60: 4BFD9C09  bl 0x830d5a68
	ctx.lr = 0x830FBE64;
	sub_830D5A68(ctx, base);
	// 830FBE64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FBE68: 4BFD6441  bl 0x830d22a8
	ctx.lr = 0x830FBE6C;
	sub_830D22A8(ctx, base);
	// 830FBE6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBE70: 41820054  beq 0x830fbec4
	if ctx.cr[0].eq {
	pc = 0x830FBEC4; continue 'dispatch;
	}
	// 830FBE74: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830FBE78: 48006641  bl 0x831024b8
	ctx.lr = 0x830FBE7C;
	sub_831024B8(ctx, base);
	// 830FBE7C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FBE80: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830FBE84: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FBE88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBE8C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FBE90: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[31].s32 as i64);
	// 830FBE94: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FBE98: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 830FBE9C: 4BFF1525  bl 0x830ed3c0
	ctx.lr = 0x830FBEA0;
	sub_830ED3C0(ctx, base);
	// 830FBEA0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBEA4: 41800018  blt 0x830fbebc
	if ctx.cr[0].lt {
	pc = 0x830FBEBC; continue 'dispatch;
	}
	// 830FBEA8: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 830FBEAC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830FBEB0: 480B5F81  bl 0x831b1e30
	ctx.lr = 0x830FBEB4;
	sub_831B1E30(ctx, base);
	// 830FBEB4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBEB8: 41820018  beq 0x830fbed0
	if ctx.cr[0].eq {
	pc = 0x830FBED0; continue 'dispatch;
	}
	// 830FBEBC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830FBEC0: 48006BC9  bl 0x83102a88
	ctx.lr = 0x830FBEC4;
	sub_83102A88(ctx, base);
	// 830FBEC4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830FBEC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FBECC: 4BFFFF50  b 0x830fbe1c
	pc = 0x830FBE1C; continue 'dispatch;
	// 830FBED0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FBED4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830FBED8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBEDC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FBEE0: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[31].s32 as i64);
	// 830FBEE4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FBEE8: 3B8B0008  addi r28, r11, 8
	ctx.r[28].s64 = ctx.r[11].s64 + 8;
	// 830FBEEC: 48006B9D  bl 0x83102a88
	ctx.lr = 0x830FBEF0;
	sub_83102A88(ctx, base);
	// 830FBEF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FBEF4: 48000008  b 0x830fbefc
	pc = 0x830FBEFC; continue 'dispatch;
	// 830FBEF8: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FBEFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830FBF00: 419A0078  beq cr6, 0x830fbf78
	if ctx.cr[6].eq {
	pc = 0x830FBF78; continue 'dispatch;
	}
	// 830FBF04: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830FBF08: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBF0C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830FBF10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FBF14: 419A0008  beq cr6, 0x830fbf1c
	if ctx.cr[6].eq {
	pc = 0x830FBF1C; continue 'dispatch;
	}
	// 830FBF18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FBF1C: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FBF20: 40980058  bge cr6, 0x830fbf78
	if !ctx.cr[6].lt {
	pc = 0x830FBF78; continue 'dispatch;
	}
	// 830FBF24: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830FBF28: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FBF2C: 83CAC0AC  lwz r30, -0x3f54(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830FBF30: 7D49F9D6  mullw r10, r9, r31
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[31].s32 as i64);
	// 830FBF34: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FBF38: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 830FBF3C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBF40: 4BFD9B29  bl 0x830d5a68
	ctx.lr = 0x830FBF44;
	sub_830D5A68(ctx, base);
	// 830FBF44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FBF48: 4BFD6361  bl 0x830d22a8
	ctx.lr = 0x830FBF4C;
	sub_830D22A8(ctx, base);
	// 830FBF4C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBF50: 40820010  bne 0x830fbf60
	if !ctx.cr[0].eq {
	pc = 0x830FBF60; continue 'dispatch;
	}
	// 830FBF54: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830FBF58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FBF5C: 4BFFFFAC  b 0x830fbf08
	pc = 0x830FBF08; continue 'dispatch;
	// 830FBF60: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FBF64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FBF68: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[31].s32 as i64);
	// 830FBF6C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FBF70: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830FBF74: 917D00A8  stw r11, 0xa8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 830FBF78: 817D00A8  lwz r11, 0xa8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 830FBF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FBF80: 409A0010  bne cr6, 0x830fbf90
	if !ctx.cr[6].eq {
	pc = 0x830FBF90; continue 'dispatch;
	}
	// 830FBF84: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830FBF88: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830FBF8C: 4800001C  b 0x830fbfa8
	pc = 0x830FBFA8; continue 'dispatch;
	// 830FBF90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FBF94: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FBF98: 4BFFF0E9  bl 0x830fb080
	ctx.lr = 0x830FBF9C;
	sub_830FB080(ctx, base);
	// 830FBF9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FBFA0: 41800008  blt 0x830fbfa8
	if ctx.cr[0].lt {
	pc = 0x830FBFA8; continue 'dispatch;
	}
	// 830FBFA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FBFA8: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 830FBFAC: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 830FBFB0: 480AC1D0  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FBFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FBFB8 size=7088
    let mut pc: u32 = 0x830FBFB8;
    'dispatch: loop {
        match pc {
            0x830FBFB8 => {
    //   block [0x830FBFB8..0x830FDB68)
	// 830FBFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FBFBC: 480AC18D  bl 0x831a8148
	ctx.lr = 0x830FBFC0;
	sub_831A8130(ctx, base);
	// 830FBFC0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FBFC4: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 830FBFC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FBFCC: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FBFD0: 2B0B07D8  cmplwi cr6, r11, 0x7d8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2008 as u32, &mut ctx.xer);
	// 830FBFD4: 41990D0C  bgt cr6, 0x830fcce0
	if ctx.cr[6].gt {
	pc = 0x830FCCE0; continue 'dispatch;
	}
	// 830FBFD8: 419A0B4C  beq cr6, 0x830fcb24
	if ctx.cr[6].eq {
	pc = 0x830FCB24; continue 'dispatch;
	}
	// 830FBFDC: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830FBFE0: 41990680  bgt cr6, 0x830fc660
	if ctx.cr[6].gt {
	pc = 0x830FC660; continue 'dispatch;
	}
	// 830FBFE4: 419A0654  beq cr6, 0x830fc638
	if ctx.cr[6].eq {
	pc = 0x830FC638; continue 'dispatch;
	}
	// 830FBFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FBFEC: 419A0640  beq cr6, 0x830fc62c
	if ctx.cr[6].eq {
	pc = 0x830FC62C; continue 'dispatch;
	}
	// 830FBFF0: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830FBFF4: 419A059C  beq cr6, 0x830fc590
	if ctx.cr[6].eq {
	pc = 0x830FC590; continue 'dispatch;
	}
	// 830FBFF8: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830FBFFC: 419A0588  beq cr6, 0x830fc584
	if ctx.cr[6].eq {
	pc = 0x830FC584; continue 'dispatch;
	}
	// 830FC000: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830FC004: 419A0458  beq cr6, 0x830fc45c
	if ctx.cr[6].eq {
	pc = 0x830FC45C; continue 'dispatch;
	}
	// 830FC008: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830FC00C: 419A03DC  beq cr6, 0x830fc3e8
	if ctx.cr[6].eq {
	pc = 0x830FC3E8; continue 'dispatch;
	}
	// 830FC010: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830FC014: 409A1B48  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC018: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC01C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC020: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830FC024: 419A0330  beq cr6, 0x830fc354
	if ctx.cr[6].eq {
	pc = 0x830FC354; continue 'dispatch;
	}
	// 830FC028: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830FC02C: 419A01FC  beq cr6, 0x830fc228
	if ctx.cr[6].eq {
	pc = 0x830FC228; continue 'dispatch;
	}
	// 830FC030: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 830FC034: 419A0128  beq cr6, 0x830fc15c
	if ctx.cr[6].eq {
	pc = 0x830FC15C; continue 'dispatch;
	}
	// 830FC038: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 830FC03C: 419A0078  beq cr6, 0x830fc0b4
	if ctx.cr[6].eq {
	pc = 0x830FC0B4; continue 'dispatch;
	}
	// 830FC040: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 830FC044: 419A0050  beq cr6, 0x830fc094
	if ctx.cr[6].eq {
	pc = 0x830FC094; continue 'dispatch;
	}
	// 830FC048: 2B0A000E  cmplwi cr6, r10, 0xe
	ctx.cr[6].compare_u32(ctx.r[10].u32, 14 as u32, &mut ctx.xer);
	// 830FC04C: 409A1B10  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC050: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FC054: 91560008  stw r10, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FC058: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FC05C: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FC060: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FC064: 409A1AF8  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC068: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FC06C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC070: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC074: 4BFEBB3D  bl 0x830e7bb0
	ctx.lr = 0x830FC078;
	sub_830E7BB0(ctx, base);
	// 830FC078: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC07C: 4BFE538D  bl 0x830e1408
	ctx.lr = 0x830FC080;
	sub_830E1408(ctx, base);
	// 830FC080: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC084: 40821AD8  bne 0x830fdb5c
	if !ctx.cr[0].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC088: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC08C: 4BFE2DF5  bl 0x830dee80
	ctx.lr = 0x830FC090;
	sub_830DEE80(ctx, base);
	// 830FC090: 48001ACC  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC094: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FC098: 91560008  stw r10, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FC09C: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FC0A0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC0A4: 889E0008  lbz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FC0A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC0AC: 4BFED9ED  bl 0x830e9a98
	ctx.lr = 0x830FC0B0;
	sub_830E9A98(ctx, base);
	// 830FC0B0: 48000D80  b 0x830fce30
	pc = 0x830FCE30; continue 'dispatch;
	// 830FC0B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FC0B8: 91560008  stw r10, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FC0BC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FC0C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FC0C4: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830FC0C8: 409A0038  bne cr6, 0x830fc100
	if !ctx.cr[6].eq {
	pc = 0x830FC100; continue 'dispatch;
	}
	// 830FC0CC: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FC0D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC0D4: 4199004C  bgt cr6, 0x830fc120
	if ctx.cr[6].gt {
	pc = 0x830FC120; continue 'dispatch;
	}
	// 830FC0D8: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FC0DC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FC0E0: 419A000C  beq cr6, 0x830fc0ec
	if ctx.cr[6].eq {
	pc = 0x830FC0EC; continue 'dispatch;
	}
	// 830FC0E4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FC0E8: 409A0068  bne cr6, 0x830fc150
	if !ctx.cr[6].eq {
	pc = 0x830FC150; continue 'dispatch;
	}
	// 830FC0EC: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FC0F0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FC0F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FC0F8: 409A0058  bne cr6, 0x830fc150
	if !ctx.cr[6].eq {
	pc = 0x830FC150; continue 'dispatch;
	}
	// 830FC0FC: 48000024  b 0x830fc120
	pc = 0x830FC120; continue 'dispatch;
	// 830FC100: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FC104: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830FC108: 409A1A54  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC10C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC110: 4BFF5A59  bl 0x830f1b68
	ctx.lr = 0x830FC114;
	sub_830F1B68(ctx, base);
	// 830FC114: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC118: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FC11C: 4082000C  bne 0x830fc128
	if !ctx.cr[0].eq {
	pc = 0x830FC128; continue 'dispatch;
	}
	// 830FC120: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC124: 48000030  b 0x830fc154
	pc = 0x830FC154; continue 'dispatch;
	// 830FC128: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FC12C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FC130: 419A000C  beq cr6, 0x830fc13c
	if ctx.cr[6].eq {
	pc = 0x830FC13C; continue 'dispatch;
	}
	// 830FC134: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FC138: 409A0018  bne cr6, 0x830fc150
	if !ctx.cr[6].eq {
	pc = 0x830FC150; continue 'dispatch;
	}
	// 830FC13C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FC140: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC144: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FC148: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FC14C: 419A0008  beq cr6, 0x830fc154
	if ctx.cr[6].eq {
	pc = 0x830FC154; continue 'dispatch;
	}
	// 830FC150: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FC154: 4BFEC1F5  bl 0x830e8348
	ctx.lr = 0x830FC158;
	sub_830E8348(ctx, base);
	// 830FC158: 48001A04  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC15C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FC160: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC164: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830FC168: 419A003C  beq cr6, 0x830fc1a4
	if ctx.cr[6].eq {
	pc = 0x830FC1A4; continue 'dispatch;
	}
	// 830FC16C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC170: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC174: 4BFE3CFD  bl 0x830dfe70
	ctx.lr = 0x830FC178;
	sub_830DFE70(ctx, base);
	// 830FC178: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC17C: 40820020  bne 0x830fc19c
	if !ctx.cr[0].eq {
	pc = 0x830FC19C; continue 'dispatch;
	}
	// 830FC180: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC184: 4BFD2A8D  bl 0x830cec10
	ctx.lr = 0x830FC188;
	sub_830CEC10(ctx, base);
	// 830FC188: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FC18C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC190: 4BFD2A81  bl 0x830cec10
	ctx.lr = 0x830FC194;
	sub_830CEC10(ctx, base);
	// 830FC194: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830FC198: 409A000C  bne cr6, 0x830fc1a4
	if !ctx.cr[6].eq {
	pc = 0x830FC1A4; continue 'dispatch;
	}
	// 830FC19C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FC1A0: 48000028  b 0x830fc1c8
	pc = 0x830FC1C8; continue 'dispatch;
	// 830FC1A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FC1A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC1AC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830FC1B0: 4BFE2EB9  bl 0x830df068
	ctx.lr = 0x830FC1B4;
	sub_830DF068(ctx, base);
	// 830FC1B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC1B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC1BC: 48003DFD  bl 0x830fffb8
	ctx.lr = 0x830FC1C0;
	sub_830FFFB8(ctx, base);
	// 830FC1C0: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FC1C4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830FC1C8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FC1CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830FC1D0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830FC1D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC1D8: 409A0024  bne cr6, 0x830fc1fc
	if !ctx.cr[6].eq {
	pc = 0x830FC1FC; continue 'dispatch;
	}
	// 830FC1DC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC1E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC1E4: 409A0010  bne cr6, 0x830fc1f4
	if !ctx.cr[6].eq {
	pc = 0x830FC1F4; continue 'dispatch;
	}
	// 830FC1E8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FC1EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC1F0: 419A000C  beq cr6, 0x830fc1fc
	if ctx.cr[6].eq {
	pc = 0x830FC1FC; continue 'dispatch;
	}
	// 830FC1F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC1F8: 4BFFB4B1  bl 0x830f76a8
	ctx.lr = 0x830FC1FC;
	sub_830F76A8(ctx, base);
	// 830FC1FC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FC200: 419A195C  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC204: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FC208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FC20C: 419A1950  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC214: 4BFF5955  bl 0x830f1b68
	ctx.lr = 0x830FC218;
	sub_830F1B68(ctx, base);
	// 830FC218: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC21C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FC220: 4182FF00  beq 0x830fc120
	if ctx.cr[0].eq {
	pc = 0x830FC120; continue 'dispatch;
	}
	// 830FC224: 4BFFFEB4  b 0x830fc0d8
	pc = 0x830FC0D8; continue 'dispatch;
	// 830FC228: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FC22C: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FC230: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC234: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC238: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC23C: 4BFE3C35  bl 0x830dfe70
	ctx.lr = 0x830FC240;
	sub_830DFE70(ctx, base);
	// 830FC240: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC244: 418200D8  beq 0x830fc31c
	if ctx.cr[0].eq {
	pc = 0x830FC31C; continue 'dispatch;
	}
	// 830FC248: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FC24C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC250: 808BC0AC  lwz r4, -0x3f54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) } as u64;
	// 830FC254: 4BFD291D  bl 0x830ceb70
	ctx.lr = 0x830FC258;
	sub_830CEB70(ctx, base);
	// 830FC258: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FC25C: 4182007C  beq 0x830fc2d8
	if ctx.cr[0].eq {
	pc = 0x830FC2D8; continue 'dispatch;
	}
	// 830FC260: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FC264: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC268: 41980064  blt cr6, 0x830fc2cc
	if ctx.cr[6].lt {
	pc = 0x830FC2CC; continue 'dispatch;
	}
	// 830FC26C: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FC270: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FC274: 40980018  bge cr6, 0x830fc28c
	if !ctx.cr[6].lt {
	pc = 0x830FC28C; continue 'dispatch;
	}
	// 830FC278: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FC27C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830FC280: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FC284: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830FC288: 419A0050  beq cr6, 0x830fc2d8
	if ctx.cr[6].eq {
	pc = 0x830FC2D8; continue 'dispatch;
	}
	// 830FC28C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC290: 4198003C  blt cr6, 0x830fc2cc
	if ctx.cr[6].lt {
	pc = 0x830FC2CC; continue 'dispatch;
	}
	// 830FC294: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FC298: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FC29C: 40980030  bge cr6, 0x830fc2cc
	if !ctx.cr[6].lt {
	pc = 0x830FC2CC; continue 'dispatch;
	}
	// 830FC2A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC2A4: 4BFE2C5D  bl 0x830def00
	ctx.lr = 0x830FC2A8;
	sub_830DEF00(ctx, base);
	// 830FC2A8: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FC2AC: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FC2B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FC2B4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FC2B8: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FC2BC: 4BFE6965  bl 0x830e2c20
	ctx.lr = 0x830FC2C0;
	sub_830E2C20(ctx, base);
	// 830FC2C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC2C4: 4BFEBB0D  bl 0x830e7dd0
	ctx.lr = 0x830FC2C8;
	sub_830E7DD0(ctx, base);
	// 830FC2C8: 48000010  b 0x830fc2d8
	pc = 0x830FC2D8; continue 'dispatch;
	// 830FC2CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC2D4: 4BFE8CFD  bl 0x830e4fd0
	ctx.lr = 0x830FC2D8;
	sub_830E4FD0(ctx, base);
	// 830FC2D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830FC2DC: 419A0034  beq cr6, 0x830fc310
	if ctx.cr[6].eq {
	pc = 0x830FC310; continue 'dispatch;
	}
	// 830FC2E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FC2E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC2E8: 4BFE3B89  bl 0x830dfe70
	ctx.lr = 0x830FC2EC;
	sub_830DFE70(ctx, base);
	// 830FC2EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC2F0: 4082002C  bne 0x830fc31c
	if !ctx.cr[0].eq {
	pc = 0x830FC31C; continue 'dispatch;
	}
	// 830FC2F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC2F8: 4BFD2919  bl 0x830cec10
	ctx.lr = 0x830FC2FC;
	sub_830CEC10(ctx, base);
	// 830FC2FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FC300: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FC304: 4BFD290D  bl 0x830cec10
	ctx.lr = 0x830FC308;
	sub_830CEC10(ctx, base);
	// 830FC308: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830FC30C: 419A0010  beq cr6, 0x830fc31c
	if ctx.cr[6].eq {
	pc = 0x830FC31C; continue 'dispatch;
	}
	// 830FC310: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC314: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC318: 4BFE2D51  bl 0x830df068
	ctx.lr = 0x830FC31C;
	sub_830DF068(ctx, base);
	// 830FC31C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FC320: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FC324: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830FC328: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC32C: 409A1830  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC330: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC334: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC338: 409A0010  bne cr6, 0x830fc348
	if !ctx.cr[6].eq {
	pc = 0x830FC348; continue 'dispatch;
	}
	// 830FC33C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FC340: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC344: 419A1818  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC34C: 4BFFB35D  bl 0x830f76a8
	ctx.lr = 0x830FC350;
	sub_830F76A8(ctx, base);
	// 830FC350: 4800180C  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC354: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FC358: 91560008  stw r10, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FC35C: 838B000C  lwz r28, 0xc(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FC360: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FC364: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FC368: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FC36C: 419A006C  beq cr6, 0x830fc3d8
	if ctx.cr[6].eq {
	pc = 0x830FC3D8; continue 'dispatch;
	}
	// 830FC370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC374: 4BFE2D6D  bl 0x830df0e0
	ctx.lr = 0x830FC378;
	sub_830DF0E0(ctx, base);
	// 830FC378: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FC37C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC380: 4BFD2891  bl 0x830cec10
	ctx.lr = 0x830FC384;
	sub_830CEC10(ctx, base);
	// 830FC384: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FC388: 4BFEBBF1  bl 0x830e7f78
	ctx.lr = 0x830FC38C;
	sub_830E7F78(ctx, base);
	// 830FC38C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830FC390: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC394: 4BFEBAC5  bl 0x830e7e58
	ctx.lr = 0x830FC398;
	sub_830E7E58(ctx, base);
	// 830FC398: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FC39C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FC3A0: 419A0010  beq cr6, 0x830fc3b0
	if ctx.cr[6].eq {
	pc = 0x830FC3B0; continue 'dispatch;
	}
	// 830FC3A4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FC3A8: 419A0010  beq cr6, 0x830fc3b8
	if ctx.cr[6].eq {
	pc = 0x830FC3B8; continue 'dispatch;
	}
	// 830FC3AC: 4800002C  b 0x830fc3d8
	pc = 0x830FC3D8; continue 'dispatch;
	// 830FC3B0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FC3B4: 419A0024  beq cr6, 0x830fc3d8
	if ctx.cr[6].eq {
	pc = 0x830FC3D8; continue 'dispatch;
	}
	// 830FC3B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC3BC: 4BFE2D25  bl 0x830df0e0
	ctx.lr = 0x830FC3C0;
	sub_830DF0E0(ctx, base);
	// 830FC3C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FC3C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC3C8: 4BFD2849  bl 0x830cec10
	ctx.lr = 0x830FC3CC;
	sub_830CEC10(ctx, base);
	// 830FC3CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC3D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830FC3D4: 4BFEB825  bl 0x830e7bf8
	ctx.lr = 0x830FC3D8;
	sub_830E7BF8(ctx, base);
	// 830FC3D8: 889C0000  lbz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC3DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC3E0: 4BFED731  bl 0x830e9b10
	ctx.lr = 0x830FC3E4;
	sub_830E9B10(ctx, base);
	// 830FC3E4: 48001778  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC3E8: 83D60010  lwz r30, 0x10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC3EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC3F0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC3F4: 4BFE3A7D  bl 0x830dfe70
	ctx.lr = 0x830FC3F8;
	sub_830DFE70(ctx, base);
	// 830FC3F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC3FC: 41820054  beq 0x830fc450
	if ctx.cr[0].eq {
	pc = 0x830FC450; continue 'dispatch;
	}
	// 830FC400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FC404: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FC408: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC40C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC410: 4BFD2801  bl 0x830cec10
	ctx.lr = 0x830FC414;
	sub_830CEC10(ctx, base);
	// 830FC414: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FC418: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 830FC41C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830FC420: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830FC424: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FC428: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830FC42C: 4BFEA89D  bl 0x830e6cc8
	ctx.lr = 0x830FC430;
	sub_830E6CC8(ctx, base);
	// 830FC430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FC434: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FC438: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830FC43C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FC440: 4BFE3319  bl 0x830df758
	ctx.lr = 0x830FC444;
	sub_830DF758(ctx, base);
	// 830FC444: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830FC448: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FC44C: 4BFD990D  bl 0x830d5d58
	ctx.lr = 0x830FC450;
	sub_830D5D58(ctx, base);
	// 830FC450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FC454: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830FC458: 48001704  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC45C: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 830FC460: 83D60010  lwz r30, 0x10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC464: 92960008  stw r20, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830FC468: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC46C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC470: 4BFD27A1  bl 0x830cec10
	ctx.lr = 0x830FC474;
	sub_830CEC10(ctx, base);
	// 830FC474: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830FC478: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830FC47C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830FC480: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830FC484: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FC488: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830FC48C: 4BFEA7FD  bl 0x830e6c88
	ctx.lr = 0x830FC490;
	sub_830E6C88(ctx, base);
	// 830FC490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FC494: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FC498: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830FC49C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FC4A0: 4BFE32B9  bl 0x830df758
	ctx.lr = 0x830FC4A4;
	sub_830DF758(ctx, base);
	// 830FC4A4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830FC4A8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FC4AC: 4BFD98AD  bl 0x830d5d58
	ctx.lr = 0x830FC4B0;
	sub_830D5D58(ctx, base);
	// 830FC4B0: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FC4B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC4B8: 419A008C  beq cr6, 0x830fc544
	if ctx.cr[6].eq {
	pc = 0x830FC544; continue 'dispatch;
	}
	// 830FC4BC: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FC4C0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FC4C4: 419A0080  beq cr6, 0x830fc544
	if ctx.cr[6].eq {
	pc = 0x830FC544; continue 'dispatch;
	}
	// 830FC4C8: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FC4CC: 554A07BC  rlwinm r10, r10, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830FC4D0: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830FC4D4: 419A0070  beq cr6, 0x830fc544
	if ctx.cr[6].eq {
	pc = 0x830FC544; continue 'dispatch;
	}
	// 830FC4D8: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FC4DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FC4E0: 889E0004  lbz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FC4E4: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FC4E8: 4BFE6739  bl 0x830e2c20
	ctx.lr = 0x830FC4EC;
	sub_830E2C20(ctx, base);
	// 830FC4EC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FC4F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FC4F4: 419A0050  beq cr6, 0x830fc544
	if ctx.cr[6].eq {
	pc = 0x830FC544; continue 'dispatch;
	}
	// 830FC4F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC4FC: 4BFF566D  bl 0x830f1b68
	ctx.lr = 0x830FC500;
	sub_830F1B68(ctx, base);
	// 830FC500: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC504: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FC508: 4082000C  bne 0x830fc514
	if !ctx.cr[0].eq {
	pc = 0x830FC514; continue 'dispatch;
	}
	// 830FC50C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC510: 48000030  b 0x830fc540
	pc = 0x830FC540; continue 'dispatch;
	// 830FC514: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FC518: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FC51C: 419A000C  beq cr6, 0x830fc528
	if ctx.cr[6].eq {
	pc = 0x830FC528; continue 'dispatch;
	}
	// 830FC520: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FC524: 409A0018  bne cr6, 0x830fc53c
	if !ctx.cr[6].eq {
	pc = 0x830FC53C; continue 'dispatch;
	}
	// 830FC528: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FC52C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC530: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FC534: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FC538: 419A0008  beq cr6, 0x830fc540
	if ctx.cr[6].eq {
	pc = 0x830FC540; continue 'dispatch;
	}
	// 830FC53C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FC540: 4BFEBE09  bl 0x830e8348
	ctx.lr = 0x830FC544;
	sub_830E8348(ctx, base);
	// 830FC544: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FC548: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830FC54C: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 830FC550: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC554: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830FC558: 419A0014  beq cr6, 0x830fc56c
	if ctx.cr[6].eq {
	pc = 0x830FC56C; continue 'dispatch;
	}
	// 830FC55C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC560: 4BFE3911  bl 0x830dfe70
	ctx.lr = 0x830FC564;
	sub_830DFE70(ctx, base);
	// 830FC564: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC568: 40820014  bne 0x830fc57c
	if !ctx.cr[0].eq {
	pc = 0x830FC57C; continue 'dispatch;
	}
	// 830FC56C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC570: 4BFD26A1  bl 0x830cec10
	ctx.lr = 0x830FC574;
	sub_830CEC10(ctx, base);
	// 830FC574: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC578: 4BFEB899  bl 0x830e7e10
	ctx.lr = 0x830FC57C;
	sub_830E7E10(ctx, base);
	// 830FC57C: 929F000C  stw r20, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[20].u32 ) };
	// 830FC580: 480015DC  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC588: 4BFF0EE1  bl 0x830ed468
	ctx.lr = 0x830FC58C;
	sub_830ED468(ctx, base);
	// 830FC58C: 480015D0  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC590: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FC594: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FC598: 4BFE3051  bl 0x830df5e8
	ctx.lr = 0x830FC59C;
	sub_830DF5E8(ctx, base);
	// 830FC59C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC5A0: 408215BC  bne 0x830fdb5c
	if !ctx.cr[0].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC5A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC5A8: 4BFE2A21  bl 0x830defc8
	ctx.lr = 0x830FC5AC;
	sub_830DEFC8(ctx, base);
	// 830FC5AC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FC5B0: 40800014  bge 0x830fc5c4
	if !ctx.cr[0].lt {
	pc = 0x830FC5C4; continue 'dispatch;
	}
	// 830FC5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC5B8: 4BFF0EB1  bl 0x830ed468
	ctx.lr = 0x830FC5BC;
	sub_830ED468(ctx, base);
	// 830FC5BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FC5C0: 480015A0  b 0x830fdb60
	pc = 0x830FDB60; continue 'dispatch;
	// 830FC5C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FC5C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC5CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FC5D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830FC5D4: 4BFE4F85  bl 0x830e1558
	ctx.lr = 0x830FC5D8;
	sub_830E1558(ctx, base);
	// 830FC5D8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FC5DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830FC5E0: 409A0010  bne cr6, 0x830fc5f0
	if !ctx.cr[6].eq {
	pc = 0x830FC5F0; continue 'dispatch;
	}
	// 830FC5E4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830FC5E8: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830FC5EC: 48001574  b 0x830fdb60
	pc = 0x830FDB60; continue 'dispatch;
	// 830FC5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC5F4: 4BFFF235  bl 0x830fb828
	ctx.lr = 0x830FC5F8;
	sub_830FB828(ctx, base);
	// 830FC5F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC5FC: 4080000C  bge 0x830fc608
	if !ctx.cr[0].lt {
	pc = 0x830FC608; continue 'dispatch;
	}
	// 830FC600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC604: 4BFF0E65  bl 0x830ed468
	ctx.lr = 0x830FC608;
	sub_830ED468(ctx, base);
	// 830FC608: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FC60C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830FC610: 4BFEA971  bl 0x830e6f80
	ctx.lr = 0x830FC614;
	sub_830E6F80(ctx, base);
	// 830FC614: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC618: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 830FC61C: 4BFD25F5  bl 0x830cec10
	ctx.lr = 0x830FC620;
	sub_830CEC10(ctx, base);
	// 830FC620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830FC624: 4BFD95A5  bl 0x830d5bc8
	ctx.lr = 0x830FC628;
	sub_830D5BC8(ctx, base);
	// 830FC628: 48001534  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC630: 4BFF72F9  bl 0x830f3928
	ctx.lr = 0x830FC634;
	sub_830F3928(ctx, base);
	// 830FC634: 48001528  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC638: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FC63C: 81560010  lwz r10, 0x10(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC644: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FC648: C04A0004  lfs f2, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830FC64C: C02A0000  lfs f1, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830FC650: C06A0008  lfs f3, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830FC654: C08A000C  lfs f4, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830FC658: 4BFFE101  bl 0x830fa758
	ctx.lr = 0x830FC65C;
	sub_830FA758(ctx, base);
	// 830FC65C: 48001500  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC660: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 830FC664: 419A03D4  beq cr6, 0x830fca38
	if ctx.cr[6].eq {
	pc = 0x830FCA38; continue 'dispatch;
	}
	// 830FC668: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830FC66C: 419A0160  beq cr6, 0x830fc7cc
	if ctx.cr[6].eq {
	pc = 0x830FC7CC; continue 'dispatch;
	}
	// 830FC670: 2B0B0025  cmplwi cr6, r11, 0x25
	ctx.cr[6].compare_u32(ctx.r[11].u32, 37 as u32, &mut ctx.xer);
	// 830FC674: 419A012C  beq cr6, 0x830fc7a0
	if ctx.cr[6].eq {
	pc = 0x830FC7A0; continue 'dispatch;
	}
	// 830FC678: 2B0B0027  cmplwi cr6, r11, 0x27
	ctx.cr[6].compare_u32(ctx.r[11].u32, 39 as u32, &mut ctx.xer);
	// 830FC67C: 419A00F8  beq cr6, 0x830fc774
	if ctx.cr[6].eq {
	pc = 0x830FC774; continue 'dispatch;
	}
	// 830FC680: 2B0B07D3  cmplwi cr6, r11, 0x7d3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2003 as u32, &mut ctx.xer);
	// 830FC684: 419A004C  beq cr6, 0x830fc6d0
	if ctx.cr[6].eq {
	pc = 0x830FC6D0; continue 'dispatch;
	}
	// 830FC688: 2B0B07D7  cmplwi cr6, r11, 0x7d7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2007 as u32, &mut ctx.xer);
	// 830FC68C: 409A14D0  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC690: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FC694: 81560010  lwz r10, 0x10(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC698: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FC69C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FC6A0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830FC6A4: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FC6A8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FC6AC: 419A0014  beq cr6, 0x830fc6c0
	if ctx.cr[6].eq {
	pc = 0x830FC6C0; continue 'dispatch;
	}
	// 830FC6B0: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FC6B4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FC6B8: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FC6BC: 48000008  b 0x830fc6c4
	pc = 0x830FC6C4; continue 'dispatch;
	// 830FC6C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FC6C4: 81560010  lwz r10, 0x10(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC6C8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FC6CC: 48001490  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC6D0: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FC6D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FC6D8: 83760010  lwz r27, 0x10(r22)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC6DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC6E0: 4099147C  ble cr6, 0x830fdb5c
	if !ctx.cr[6].gt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC6E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830FC6E8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FC6EC: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FC6F0: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830FC6F4: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FC6F8: 40980064  bge cr6, 0x830fc75c
	if !ctx.cr[6].lt {
	pc = 0x830FC75C; continue 'dispatch;
	}
	// 830FC6FC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC700: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC704: 409A000C  bne cr6, 0x830fc710
	if !ctx.cr[6].eq {
	pc = 0x830FC710; continue 'dispatch;
	}
	// 830FC708: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FC70C: 48000018  b 0x830fc724
	pc = 0x830FC724; continue 'dispatch;
	// 830FC710: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC714: 4BFD24FD  bl 0x830cec10
	ctx.lr = 0x830FC718;
	sub_830CEC10(ctx, base);
	// 830FC718: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC71C: 4BFEB8A5  bl 0x830e7fc0
	ctx.lr = 0x830FC720;
	sub_830E7FC0(ctx, base);
	// 830FC720: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FC724: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FC728: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FC72C: 4BFE4475  bl 0x830e0ba0
	ctx.lr = 0x830FC730;
	sub_830E0BA0(ctx, base);
	// 830FC730: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FC734: 419A0010  beq cr6, 0x830fc744
	if ctx.cr[6].eq {
	pc = 0x830FC744; continue 'dispatch;
	}
	// 830FC738: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830FC73C: 419A0010  beq cr6, 0x830fc74c
	if ctx.cr[6].eq {
	pc = 0x830FC74C; continue 'dispatch;
	}
	// 830FC740: 4800001C  b 0x830fc75c
	pc = 0x830FC75C; continue 'dispatch;
	// 830FC744: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830FC748: 419A0014  beq cr6, 0x830fc75c
	if ctx.cr[6].eq {
	pc = 0x830FC75C; continue 'dispatch;
	}
	// 830FC74C: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FC750: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC754: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FC758: 4BFEB5A1  bl 0x830e7cf8
	ctx.lr = 0x830FC75C;
	sub_830E7CF8(ctx, base);
	// 830FC75C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FC760: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830FC764: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830FC768: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FC76C: 4198FF7C  blt cr6, 0x830fc6e8
	if ctx.cr[6].lt {
	pc = 0x830FC6E8; continue 'dispatch;
	}
	// 830FC770: 480013EC  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC774: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FC778: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FC77C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FC780: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830FC784: C01F006C  lfs f0, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FC788: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830FC78C: 40990008  ble cr6, 0x830fc794
	if !ctx.cr[6].gt {
	pc = 0x830FC794; continue 'dispatch;
	}
	// 830FC790: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830FC794: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FC798: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FC79C: 480013C0  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC7A0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FC7A4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FC7A8: 419A000C  beq cr6, 0x830fc7b4
	if ctx.cr[6].eq {
	pc = 0x830FC7B4; continue 'dispatch;
	}
	// 830FC7AC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FC7B0: 409A13AC  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC7B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FC7B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC7BC: 480037FD  bl 0x830fffb8
	ctx.lr = 0x830FC7C0;
	sub_830FFFB8(ctx, base);
	// 830FC7C0: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FC7C4: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 830FC7C8: 4BFFFFCC  b 0x830fc794
	pc = 0x830FC794; continue 'dispatch;
	// 830FC7CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FC7D0: 80760010  lwz r3, 0x10(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FC7D4: 4BFE250D  bl 0x830dece0
	ctx.lr = 0x830FC7D8;
	sub_830DECE0(ctx, base);
	// 830FC7D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FC7DC: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 830FC7E0: 419A000C  beq cr6, 0x830fc7ec
	if ctx.cr[6].eq {
	pc = 0x830FC7EC; continue 'dispatch;
	}
	// 830FC7E4: 2F1D0006  cmpwi cr6, r29, 6
	ctx.cr[6].compare_i32(ctx.r[29].s32, 6, &mut ctx.xer);
	// 830FC7E8: 409A1374  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC7EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FC7F0: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FC7F4: 83DF00E8  lwz r30, 0xe8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FC7F8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FC7FC: 41981360  blt cr6, 0x830fdb5c
	if ctx.cr[6].lt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC804: 839F00EC  lwz r28, 0xec(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FC808: 4BFF5259  bl 0x830f1a60
	ctx.lr = 0x830FC80C;
	sub_830F1A60(ctx, base);
	// 830FC80C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FC810: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830FC814: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC81C: 419A0010  beq cr6, 0x830fc82c
	if ctx.cr[6].eq {
	pc = 0x830FC82C; continue 'dispatch;
	}
	// 830FC820: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FC824: 4BFFAEE5  bl 0x830f7708
	ctx.lr = 0x830FC828;
	sub_830F7708(ctx, base);
	// 830FC828: 48001334  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC82C: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 830FC830: 409A00C0  bne cr6, 0x830fc8f0
	if !ctx.cr[6].eq {
	pc = 0x830FC8F0; continue 'dispatch;
	}
	// 830FC834: 4BFF50ED  bl 0x830f1920
	ctx.lr = 0x830FC838;
	sub_830F1920(ctx, base);
	// 830FC838: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FC83C: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830FC840: 40990088  ble cr6, 0x830fc8c8
	if !ctx.cr[6].gt {
	pc = 0x830FC8C8; continue 'dispatch;
	}
	// 830FC844: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FC848: 419A0080  beq cr6, 0x830fc8c8
	if ctx.cr[6].eq {
	pc = 0x830FC8C8; continue 'dispatch;
	}
	// 830FC84C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC850: 4BFF5279  bl 0x830f1ac8
	ctx.lr = 0x830FC854;
	sub_830F1AC8(ctx, base);
	// 830FC854: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC858: 40820020  bne 0x830fc878
	if !ctx.cr[0].eq {
	pc = 0x830FC878; continue 'dispatch;
	}
	// 830FC85C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FC860: 419A0018  beq cr6, 0x830fc878
	if ctx.cr[6].eq {
	pc = 0x830FC878; continue 'dispatch;
	}
	// 830FC864: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC868: 4BFD23A9  bl 0x830cec10
	ctx.lr = 0x830FC86C;
	sub_830CEC10(ctx, base);
	// 830FC86C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC870: 4BFEB151  bl 0x830e79c0
	ctx.lr = 0x830FC874;
	sub_830E79C0(ctx, base);
	// 830FC874: 480012E8  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FC878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC87C: 4BFF50A5  bl 0x830f1920
	ctx.lr = 0x830FC880;
	sub_830F1920(ctx, base);
	// 830FC880: 7FA3F051  subf. r29, r3, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[3].s64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FC884: 40800008  bge 0x830fc88c
	if !ctx.cr[0].lt {
	pc = 0x830FC88C; continue 'dispatch;
	}
	// 830FC888: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830FC88C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FC890: 419A0028  beq cr6, 0x830fc8b8
	if ctx.cr[6].eq {
	pc = 0x830FC8B8; continue 'dispatch;
	}
	// 830FC894: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FC898: 7D6BE050  subf r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 830FC89C: 7FCBEA15  add. r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FC8A0: 40800008  bge 0x830fc8a8
	if !ctx.cr[0].lt {
	pc = 0x830FC8A8; continue 'dispatch;
	}
	// 830FC8A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FC8A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC8AC: 4BFD2365  bl 0x830cec10
	ctx.lr = 0x830FC8B0;
	sub_830CEC10(ctx, base);
	// 830FC8B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FC8B4: 4BFEB10D  bl 0x830e79c0
	ctx.lr = 0x830FC8B8;
	sub_830E79C0(ctx, base);
	// 830FC8B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC8BC: 4BFD2355  bl 0x830cec10
	ctx.lr = 0x830FC8C0;
	sub_830CEC10(ctx, base);
	// 830FC8C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FC8C4: 4800013C  b 0x830fca00
	pc = 0x830FCA00; continue 'dispatch;
	// 830FC8C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC8CC: 4BFF51FD  bl 0x830f1ac8
	ctx.lr = 0x830FC8D0;
	sub_830F1AC8(ctx, base);
	// 830FC8D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC8D4: 40821288  bne 0x830fdb5c
	if !ctx.cr[0].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC8D8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FC8DC: 419A1280  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FC8E0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC8E4: 4BFD232D  bl 0x830cec10
	ctx.lr = 0x830FC8E8;
	sub_830CEC10(ctx, base);
	// 830FC8E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FC8EC: 4BFFFF84  b 0x830fc870
	pc = 0x830FC870; continue 'dispatch;
	// 830FC8F0: 4BFF5031  bl 0x830f1920
	ctx.lr = 0x830FC8F4;
	sub_830F1920(ctx, base);
	// 830FC8F4: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FC8F8: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830FC8FC: 4099010C  ble cr6, 0x830fca08
	if !ctx.cr[6].gt {
	pc = 0x830FCA08; continue 'dispatch;
	}
	// 830FC900: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 830FC904: 419A001C  beq cr6, 0x830fc920
	if ctx.cr[6].eq {
	pc = 0x830FC920; continue 'dispatch;
	}
	// 830FC908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC90C: 4BFF5015  bl 0x830f1920
	ctx.lr = 0x830FC910;
	sub_830F1920(ctx, base);
	// 830FC910: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FC914: 7D43F214  add r10, r3, r30
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 830FC918: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FC91C: 409800EC  bge cr6, 0x830fca08
	if !ctx.cr[6].lt {
	pc = 0x830FCA08; continue 'dispatch;
	}
	// 830FC920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC924: 4BFF51ED  bl 0x830f1b10
	ctx.lr = 0x830FC928;
	sub_830F1B10(ctx, base);
	// 830FC928: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FC92C: 40820020  bne 0x830fc94c
	if !ctx.cr[0].eq {
	pc = 0x830FC94C; continue 'dispatch;
	}
	// 830FC930: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FC934: 419A0018  beq cr6, 0x830fc94c
	if ctx.cr[6].eq {
	pc = 0x830FC94C; continue 'dispatch;
	}
	// 830FC938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC93C: 4BFF4FE5  bl 0x830f1920
	ctx.lr = 0x830FC940;
	sub_830F1920(ctx, base);
	// 830FC940: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 830FC944: 7FC35A14  add r30, r3, r11
	ctx.r[30].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 830FC948: 4BFFFF1C  b 0x830fc864
	pc = 0x830FC864; continue 'dispatch;
	// 830FC94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FC950: 4BFF4FD1  bl 0x830f1920
	ctx.lr = 0x830FC954;
	sub_830F1920(ctx, base);
	// 830FC954: 7FC3F214  add r30, r3, r30
	ctx.r[30].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 830FC958: 813F00F0  lwz r9, 0xf0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FC95C: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 830FC960: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FC964: 41980008  blt cr6, 0x830fc96c
	if ctx.cr[6].lt {
	pc = 0x830FC96C; continue 'dispatch;
	}
	// 830FC968: 7FC34850  subf r30, r3, r9
	ctx.r[30].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 830FC96C: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FC970: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FC974: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830FC978: 419A0014  beq cr6, 0x830fc98c
	if ctx.cr[6].eq {
	pc = 0x830FC98C; continue 'dispatch;
	}
	// 830FC97C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 830FC980: 419A000C  beq cr6, 0x830fc98c
	if ctx.cr[6].eq {
	pc = 0x830FC98C; continue 'dispatch;
	}
	// 830FC984: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 830FC988: 409A0008  bne cr6, 0x830fc990
	if !ctx.cr[6].eq {
	pc = 0x830FC990; continue 'dispatch;
	}
	// 830FC98C: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FC990: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FC994: 419A0030  beq cr6, 0x830fc9c4
	if ctx.cr[6].eq {
	pc = 0x830FC9C4; continue 'dispatch;
	}
	// 830FC998: 57CA083E  rotlwi r10, r30, 1
	ctx.r[10].u64 = ((ctx.r[30].u32).rotate_left(1)) as u64;
	// 830FC99C: 7D1E5BD6  divw r8, r30, r11
	ctx.r[8].s32 = ctx.r[30].s32 / ctx.r[11].s32;
	// 830FC9A0: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 830FC9A4: 7D4859D6  mullw r10, r8, r11
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830FC9A8: 7D683878  andc r8, r11, r7
	ctx.r[8].u64 = ctx.r[11].u64 & !ctx.r[7].u64;
	// 830FC9AC: 0CCB0000  twi 6, r11, 0
	// 830FC9B0: 7D4AF051  subf. r10, r10, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FC9B4: 0CA8FFFF  twi 5, r8, -1
	// 830FC9B8: 4182000C  beq 0x830fc9c4
	if ctx.cr[0].eq {
	pc = 0x830FC9C4; continue 'dispatch;
	}
	// 830FC9BC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830FC9C0: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FC9C4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FC9C8: 419A002C  beq cr6, 0x830fc9f4
	if ctx.cr[6].eq {
	pc = 0x830FC9F4; continue 'dispatch;
	}
	// 830FC9CC: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FC9D0: 7D6BE050  subf r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 830FC9D4: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FC9D8: 7F1D4800  cmpw cr6, r29, r9
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FC9DC: 41980008  blt cr6, 0x830fc9e4
	if ctx.cr[6].lt {
	pc = 0x830FC9E4; continue 'dispatch;
	}
	// 830FC9E0: 3BA9FFFF  addi r29, r9, -1
	ctx.r[29].s64 = ctx.r[9].s64 + -1;
	// 830FC9E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC9E8: 4BFD2229  bl 0x830cec10
	ctx.lr = 0x830FC9EC;
	sub_830CEC10(ctx, base);
	// 830FC9EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FC9F0: 4BFEAFD1  bl 0x830e79c0
	ctx.lr = 0x830FC9F4;
	sub_830E79C0(ctx, base);
	// 830FC9F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FC9F8: 4BFD2219  bl 0x830cec10
	ctx.lr = 0x830FC9FC;
	sub_830CEC10(ctx, base);
	// 830FC9FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FCA00: 4BFEB1B1  bl 0x830e7bb0
	ctx.lr = 0x830FCA04;
	sub_830E7BB0(ctx, base);
	// 830FCA04: 48001158  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCA0C: 4BFF5105  bl 0x830f1b10
	ctx.lr = 0x830FCA10;
	sub_830F1B10(ctx, base);
	// 830FCA10: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FCA14: 40821148  bne 0x830fdb5c
	if !ctx.cr[0].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCA18: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FCA1C: 419A1140  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCA20: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FCA24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCA28: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 830FCA2C: 4BFD21E5  bl 0x830cec10
	ctx.lr = 0x830FCA30;
	sub_830CEC10(ctx, base);
	// 830FCA30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830FCA34: 4BFFFE3C  b 0x830fc870
	pc = 0x830FC870; continue 'dispatch;
	// 830FCA38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FCA3C: 83D60010  lwz r30, 0x10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FCA40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FCA44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830FCA48: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCA4C: 4BFE2D0D  bl 0x830df758
	ctx.lr = 0x830FCA50;
	sub_830DF758(ctx, base);
	// 830FCA50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCA54: 4BFD21BD  bl 0x830cec10
	ctx.lr = 0x830FCA58;
	sub_830CEC10(ctx, base);
	// 830FCA58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FCA5C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830FCA60: 409A10FC  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCA64: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCA68: 4BFD21A9  bl 0x830cec10
	ctx.lr = 0x830FCA6C;
	sub_830CEC10(ctx, base);
	// 830FCA6C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FCA70: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 830FCA74: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FCA78: 419A0054  beq cr6, 0x830fcacc
	if ctx.cr[6].eq {
	pc = 0x830FCACC; continue 'dispatch;
	}
	// 830FCA7C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCA80: 4BFD2191  bl 0x830cec10
	ctx.lr = 0x830FCA84;
	sub_830CEC10(ctx, base);
	// 830FCA84: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FCA88: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FCA8C: 419A0040  beq cr6, 0x830fcacc
	if ctx.cr[6].eq {
	pc = 0x830FCACC; continue 'dispatch;
	}
	// 830FCA90: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCA94: 4BFD217D  bl 0x830cec10
	ctx.lr = 0x830FCA98;
	sub_830CEC10(ctx, base);
	// 830FCA98: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FCA9C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FCAA0: 419A002C  beq cr6, 0x830fcacc
	if ctx.cr[6].eq {
	pc = 0x830FCACC; continue 'dispatch;
	}
	// 830FCAA4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCAA8: 4BFD2169  bl 0x830cec10
	ctx.lr = 0x830FCAAC;
	sub_830CEC10(ctx, base);
	// 830FCAAC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FCAB0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FCAB4: 419A0018  beq cr6, 0x830fcacc
	if ctx.cr[6].eq {
	pc = 0x830FCACC; continue 'dispatch;
	}
	// 830FCAB8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCABC: 4BFD2155  bl 0x830cec10
	ctx.lr = 0x830FCAC0;
	sub_830CEC10(ctx, base);
	// 830FCAC0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FCAC4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FCAC8: 409A000C  bne cr6, 0x830fcad4
	if !ctx.cr[6].eq {
	pc = 0x830FCAD4; continue 'dispatch;
	}
	// 830FCACC: 92960008  stw r20, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830FCAD0: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 830FCAD4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FCAD8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FCADC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCAE0: 4099107C  ble cr6, 0x830fdb5c
	if !ctx.cr[6].gt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCAE4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830FCAE8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCAEC: 4BFD2125  bl 0x830cec10
	ctx.lr = 0x830FCAF0;
	sub_830CEC10(ctx, base);
	// 830FCAF0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FCAF4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FCAF8: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FCAFC: 419A001C  beq cr6, 0x830fcb18
	if ctx.cr[6].eq {
	pc = 0x830FCB18; continue 'dispatch;
	}
	// 830FCB00: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FCB04: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830FCB08: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830FCB0C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FCB10: 4198FFD8  blt cr6, 0x830fcae8
	if ctx.cr[6].lt {
	pc = 0x830FCAE8; continue 'dispatch;
	}
	// 830FCB14: 48001048  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCB18: 92960008  stw r20, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830FCB1C: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 830FCB20: 4800103C  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCB24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FCB28: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FCB2C: 91560008  stw r10, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FCB30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCB34: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FCB38: 4098000C  bge cr6, 0x830fcb44
	if !ctx.cr[6].lt {
	pc = 0x830FCB44; continue 'dispatch;
	}
	// 830FCB3C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 830FCB40: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830FCB44: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FCB48: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCB4C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FCB50: 4198000C  blt cr6, 0x830fcb5c
	if ctx.cr[6].lt {
	pc = 0x830FCB5C; continue 'dispatch;
	}
	// 830FCB54: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830FCB58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830FCB5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCB60: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FCB64: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FCB68: 419A0FF4  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCB6C: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FCB70: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 830FCB74: 839F00DC  lwz r28, 0xdc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FCB78: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 830FCB7C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FCB80: 41980024  blt cr6, 0x830fcba4
	if ctx.cr[6].lt {
	pc = 0x830FCBA4; continue 'dispatch;
	}
	// 830FCB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCB88: 553E003E  slwi r30, r9, 0
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830FCB8C: 557D003E  slwi r29, r11, 0
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830FCB90: 4BFF4D91  bl 0x830f1920
	ctx.lr = 0x830FCB94;
	sub_830F1920(ctx, base);
	// 830FCB94: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 830FCB98: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FCB9C: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 830FCBA0: 41980008  blt cr6, 0x830fcba8
	if ctx.cr[6].lt {
	pc = 0x830FCBA8; continue 'dispatch;
	}
	// 830FCBA4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830FCBA8: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 830FCBAC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FCBB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCBB4: 419A0110  beq cr6, 0x830fccc4
	if ctx.cr[6].eq {
	pc = 0x830FCCC4; continue 'dispatch;
	}
	// 830FCBB8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FCBBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCBC0: 419A0014  beq cr6, 0x830fcbd4
	if ctx.cr[6].eq {
	pc = 0x830FCBD4; continue 'dispatch;
	}
	// 830FCBC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FCBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCBCC: 4BFF5C0D  bl 0x830f27d8
	ctx.lr = 0x830FCBD0;
	sub_830F27D8(ctx, base);
	// 830FCBD0: 48000024  b 0x830fcbf4
	pc = 0x830FCBF4; continue 'dispatch;
	// 830FCBD4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FCBD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCBDC: 409A0010  bne cr6, 0x830fcbec
	if !ctx.cr[6].eq {
	pc = 0x830FCBEC; continue 'dispatch;
	}
	// 830FCBE0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FCBE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCBE8: 419A000C  beq cr6, 0x830fcbf4
	if ctx.cr[6].eq {
	pc = 0x830FCBF4; continue 'dispatch;
	}
	// 830FCBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCBF0: 4BFFAAB9  bl 0x830f76a8
	ctx.lr = 0x830FCBF4;
	sub_830F76A8(ctx, base);
	// 830FCBF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCBF8: 4BFE48B9  bl 0x830e14b0
	ctx.lr = 0x830FCBFC;
	sub_830E14B0(ctx, base);
	// 830FCBFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FCC00: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCC04: 4BFD200D  bl 0x830cec10
	ctx.lr = 0x830FCC08;
	sub_830CEC10(ctx, base);
	// 830FCC08: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830FCC0C: 409A0034  bne cr6, 0x830fcc40
	if !ctx.cr[6].eq {
	pc = 0x830FCC40; continue 'dispatch;
	}
	// 830FCC10: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FCC14: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FCC18: 419A00AC  beq cr6, 0x830fccc4
	if ctx.cr[6].eq {
	pc = 0x830FCCC4; continue 'dispatch;
	}
	// 830FCC1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FCC20: 4BFE22E1  bl 0x830def00
	ctx.lr = 0x830FCC24;
	sub_830DEF00(ctx, base);
	// 830FCC24: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FCC28: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FCC2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FCC30: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FCC34: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FCC38: 4BFE5FE9  bl 0x830e2c20
	ctx.lr = 0x830FCC3C;
	sub_830E2C20(ctx, base);
	// 830FCC3C: 48000088  b 0x830fccc4
	pc = 0x830FCCC4; continue 'dispatch;
	// 830FCC40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FCC44: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCC48: 4BFE3229  bl 0x830dfe70
	ctx.lr = 0x830FCC4C;
	sub_830DFE70(ctx, base);
	// 830FCC4C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FCC50: 41820040  beq 0x830fcc90
	if ctx.cr[0].eq {
	pc = 0x830FCC90; continue 'dispatch;
	}
	// 830FCC54: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FCC58: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FCC5C: 409AFFC0  bne cr6, 0x830fcc1c
	if !ctx.cr[6].eq {
	pc = 0x830FCC1C; continue 'dispatch;
	}
	// 830FCC60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FCC64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCC68: 4BFE8369  bl 0x830e4fd0
	ctx.lr = 0x830FCC6C;
	sub_830E4FD0(ctx, base);
	// 830FCC6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FCC70: 41800014  blt 0x830fcc84
	if ctx.cr[0].lt {
	pc = 0x830FCC84; continue 'dispatch;
	}
	// 830FCC74: 3D608030  lis r11, -0x7fd0
	ctx.r[11].s64 = -2144337920;
	// 830FCC78: 616B0014  ori r11, r11, 0x14
	ctx.r[11].u64 = ctx.r[11].u64 | 20;
	// 830FCC7C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FCC80: 409A0044  bne cr6, 0x830fccc4
	if !ctx.cr[6].eq {
	pc = 0x830FCCC4; continue 'dispatch;
	}
	// 830FCC84: 939F00DC  stw r28, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[28].u32 ) };
	// 830FCC88: 937F00EC  stw r27, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[27].u32 ) };
	// 830FCC8C: 48000038  b 0x830fccc4
	pc = 0x830FCCC4; continue 'dispatch;
	// 830FCC90: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 830FCC94: 419A0014  beq cr6, 0x830fcca8
	if ctx.cr[6].eq {
	pc = 0x830FCCA8; continue 'dispatch;
	}
	// 830FCC98: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FCC9C: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830FCCA0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830FCCA4: 4BFEB12D  bl 0x830e7dd0
	ctx.lr = 0x830FCCA8;
	sub_830E7DD0(ctx, base);
	// 830FCCA8: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FCCAC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FCCB0: 419A0014  beq cr6, 0x830fccc4
	if ctx.cr[6].eq {
	pc = 0x830FCCC4; continue 'dispatch;
	}
	// 830FCCB4: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FCCB8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FCCBC: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FCCC0: 4BFEB111  bl 0x830e7dd0
	ctx.lr = 0x830FCCC4;
	sub_830E7DD0(ctx, base);
	// 830FCCC4: 83DF00EC  lwz r30, 0xec(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FCCC8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCCCC: 4BFD1F45  bl 0x830cec10
	ctx.lr = 0x830FCCD0;
	sub_830CEC10(ctx, base);
	// 830FCCD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FCCD4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830FCCD8: 4BFEAD31  bl 0x830e7a08
	ctx.lr = 0x830FCCDC;
	sub_830E7A08(ctx, base);
	// 830FCCDC: 48000E80  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCCE0: 2B0B0800  cmplwi cr6, r11, 0x800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2048 as u32, &mut ctx.xer);
	// 830FCCE4: 41990E78  bgt cr6, 0x830fdb5c
	if ctx.cr[6].gt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCCE8: 419A0E34  beq cr6, 0x830fdb1c
	if ctx.cr[6].eq {
	pc = 0x830FDB1C; continue 'dispatch;
	}
	// 830FCCEC: 2B0B07E4  cmplwi cr6, r11, 0x7e4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2020 as u32, &mut ctx.xer);
	// 830FCCF0: 41990840  bgt cr6, 0x830fd530
	if ctx.cr[6].gt {
	pc = 0x830FD530; continue 'dispatch;
	}
	// 830FCCF4: 419A0738  beq cr6, 0x830fd42c
	if ctx.cr[6].eq {
	pc = 0x830FD42C; continue 'dispatch;
	}
	// 830FCCF8: 2B0B07DA  cmplwi cr6, r11, 0x7da
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2010 as u32, &mut ctx.xer);
	// 830FCCFC: 419A0718  beq cr6, 0x830fd414
	if ctx.cr[6].eq {
	pc = 0x830FD414; continue 'dispatch;
	}
	// 830FCD00: 2B0B07DB  cmplwi cr6, r11, 0x7db
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2011 as u32, &mut ctx.xer);
	// 830FCD04: 419A0134  beq cr6, 0x830fce38
	if ctx.cr[6].eq {
	pc = 0x830FCE38; continue 'dispatch;
	}
	// 830FCD08: 2B0B07DC  cmplwi cr6, r11, 0x7dc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2012 as u32, &mut ctx.xer);
	// 830FCD0C: 419A0074  beq cr6, 0x830fcd80
	if ctx.cr[6].eq {
	pc = 0x830FCD80; continue 'dispatch;
	}
	// 830FCD10: 2B0B07DD  cmplwi cr6, r11, 0x7dd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2013 as u32, &mut ctx.xer);
	// 830FCD14: 419A0020  beq cr6, 0x830fcd34
	if ctx.cr[6].eq {
	pc = 0x830FCD34; continue 'dispatch;
	}
	// 830FCD18: 2B0B07DE  cmplwi cr6, r11, 0x7de
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2014 as u32, &mut ctx.xer);
	// 830FCD1C: 409A0E40  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCD20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FCD24: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FCD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCD2C: 4BFFD5C5  bl 0x830fa2f0
	ctx.lr = 0x830FCD30;
	sub_830FA2F0(ctx, base);
	// 830FCD30: 48000E2C  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCD34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FCD38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830FCD3C: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FCD40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FCD44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830FCD48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCD4C: 4BFE480D  bl 0x830e1558
	ctx.lr = 0x830FCD50;
	sub_830E1558(ctx, base);
	// 830FCD50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FCD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FCD58: 409AFFD0  bne cr6, 0x830fcd28
	if !ctx.cr[6].eq {
	pc = 0x830FCD28; continue 'dispatch;
	}
	// 830FCD5C: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 830FCD60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830FCD64: 4800528D  bl 0x83101ff0
	ctx.lr = 0x830FCD68;
	sub_83101FF0(ctx, base);
	// 830FCD68: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCD6C: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 830FCD70: 4BFD1EA1  bl 0x830cec10
	ctx.lr = 0x830FCD74;
	sub_830CEC10(ctx, base);
	// 830FCD74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FCD78: 4BFD8E51  bl 0x830d5bc8
	ctx.lr = 0x830FCD7C;
	sub_830D5BC8(ctx, base);
	// 830FCD7C: 4BFFFFAC  b 0x830fcd28
	pc = 0x830FCD28; continue 'dispatch;
	// 830FCD80: 83D60010  lwz r30, 0x10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FCD84: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCD88: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FCD8C: 419A0094  beq cr6, 0x830fce20
	if ctx.cr[6].eq {
	pc = 0x830FCE20; continue 'dispatch;
	}
	// 830FCD90: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FCD94: 419A0078  beq cr6, 0x830fce0c
	if ctx.cr[6].eq {
	pc = 0x830FCE0C; continue 'dispatch;
	}
	// 830FCD98: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FCD9C: 419A0040  beq cr6, 0x830fcddc
	if ctx.cr[6].eq {
	pc = 0x830FCDDC; continue 'dispatch;
	}
	// 830FCDA0: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FCDA4: 409A0DB8  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCDA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FCDAC: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FCDB0: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FCDB4: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FCDB8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FCDBC: 419A0014  beq cr6, 0x830fcdd0
	if ctx.cr[6].eq {
	pc = 0x830FCDD0; continue 'dispatch;
	}
	// 830FCDC0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FCDC4: 419A000C  beq cr6, 0x830fcdd0
	if ctx.cr[6].eq {
	pc = 0x830FCDD0; continue 'dispatch;
	}
	// 830FCDC8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FCDCC: 409A0008  bne cr6, 0x830fcdd4
	if !ctx.cr[6].eq {
	pc = 0x830FCDD4; continue 'dispatch;
	}
	// 830FCDD0: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FCDD4: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830FCDD8: 48000D84  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCDDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FCDE0: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FCDE4: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FCDE8: 815F00E0  lwz r10, 0xe0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FCDEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FCDF0: 419A0014  beq cr6, 0x830fce04
	if ctx.cr[6].eq {
	pc = 0x830FCE04; continue 'dispatch;
	}
	// 830FCDF4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FCDF8: 419A000C  beq cr6, 0x830fce04
	if ctx.cr[6].eq {
	pc = 0x830FCE04; continue 'dispatch;
	}
	// 830FCDFC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FCE00: 409AFFD4  bne cr6, 0x830fcdd4
	if !ctx.cr[6].eq {
	pc = 0x830FCDD4; continue 'dispatch;
	}
	// 830FCE04: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FCE08: 4BFFFFCC  b 0x830fcdd4
	pc = 0x830FCDD4; continue 'dispatch;
	// 830FCE0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FCE10: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FCE14: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FCE18: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FCE1C: 48000D40  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCE20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FCE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCE28: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FCE2C: 4BFF4AF5  bl 0x830f1920
	ctx.lr = 0x830FCE30;
	sub_830F1920(ctx, base);
	// 830FCE30: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830FCE34: 48000D28  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCE38: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 830FCE3C: 83D60010  lwz r30, 0x10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FCE40: 92960008  stw r20, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830FCE44: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCE48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCE4C: 40980010  bge cr6, 0x830fce5c
	if !ctx.cr[6].lt {
	pc = 0x830FCE5C; continue 'dispatch;
	}
	// 830FCE50: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830FCE54: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830FCE58: 48000D08  b 0x830fdb60
	pc = 0x830FDB60; continue 'dispatch;
	// 830FCE5C: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FCE60: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FCE64: 409A0010  bne cr6, 0x830fce74
	if !ctx.cr[6].eq {
	pc = 0x830FCE74; continue 'dispatch;
	}
	// 830FCE68: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830FCE6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830FCE70: 48000CEC  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FCE74: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FCE78: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FCE7C: 419A0CE0  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCE84: 4BFFC865  bl 0x830f96e8
	ctx.lr = 0x830FCE88;
	sub_830F96E8(ctx, base);
	// 830FCE88: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCE8C: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830FCE90: 40990008  ble cr6, 0x830fce98
	if !ctx.cr[6].gt {
	pc = 0x830FCE98; continue 'dispatch;
	}
	// 830FCE94: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830FCE98: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FCE9C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FCEA0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830FCEA4: 419A0014  beq cr6, 0x830fceb8
	if ctx.cr[6].eq {
	pc = 0x830FCEB8; continue 'dispatch;
	}
	// 830FCEA8: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 830FCEAC: 419A000C  beq cr6, 0x830fceb8
	if ctx.cr[6].eq {
	pc = 0x830FCEB8; continue 'dispatch;
	}
	// 830FCEB0: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 830FCEB4: 409A0008  bne cr6, 0x830fcebc
	if !ctx.cr[6].eq {
	pc = 0x830FCEBC; continue 'dispatch;
	}
	// 830FCEB8: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FCEBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCEC0: 419A0030  beq cr6, 0x830fcef0
	if ctx.cr[6].eq {
	pc = 0x830FCEF0; continue 'dispatch;
	}
	// 830FCEC4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCEC8: 0CCB0000  twi 6, r11, 0
	// 830FCECC: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 830FCED0: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830FCED4: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830FCED8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830FCEDC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 830FCEE0: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 830FCEE4: 7D484850  subf r10, r8, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 830FCEE8: 0CABFFFF  twi 5, r11, -1
	// 830FCEEC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830FCEF0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FCEF4: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FCEF8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FCEFC: 419A0C60  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FCF00: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FCF04: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830FCF08: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FCF0C: 419A000C  beq cr6, 0x830fcf18
	if ctx.cr[6].eq {
	pc = 0x830FCF18; continue 'dispatch;
	}
	// 830FCF10: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FCF14: 409A0044  bne cr6, 0x830fcf58
	if !ctx.cr[6].eq {
	pc = 0x830FCF58; continue 'dispatch;
	}
	// 830FCF18: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FCF1C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FCF20: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FCF24: 409A0034  bne cr6, 0x830fcf58
	if !ctx.cr[6].eq {
	pc = 0x830FCF58; continue 'dispatch;
	}
	// 830FCF28: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FCF2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830FCF30: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FCF34: 409A000C  bne cr6, 0x830fcf40
	if !ctx.cr[6].eq {
	pc = 0x830FCF40; continue 'dispatch;
	}
	// 830FCF38: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830FCF3C: 419A0024  beq cr6, 0x830fcf60
	if ctx.cr[6].eq {
	pc = 0x830FCF60; continue 'dispatch;
	}
	// 830FCF40: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FCF44: 409A0014  bne cr6, 0x830fcf58
	if !ctx.cr[6].eq {
	pc = 0x830FCF58; continue 'dispatch;
	}
	// 830FCF48: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FCF4C: 409A000C  bne cr6, 0x830fcf58
	if !ctx.cr[6].eq {
	pc = 0x830FCF58; continue 'dispatch;
	}
	// 830FCF50: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830FCF54: 48000010  b 0x830fcf64
	pc = 0x830FCF64; continue 'dispatch;
	// 830FCF58: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FCF5C: 40980008  bge cr6, 0x830fcf64
	if !ctx.cr[6].lt {
	pc = 0x830FCF64; continue 'dispatch;
	}
	// 830FCF60: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 830FCF64: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FCF68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCF6C: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 830FCF70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCF74: 419A0198  beq cr6, 0x830fd10c
	if ctx.cr[6].eq {
	pc = 0x830FD10C; continue 'dispatch;
	}
	// 830FCF78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830FCF7C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FCF80: 4BFF0649  bl 0x830ed5c8
	ctx.lr = 0x830FCF84;
	sub_830ED5C8(ctx, base);
	// 830FCF84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FCF88: 80BF00EC  lwz r5, 0xec(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FCF8C: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FCF90: 4BFF4CE1  bl 0x830f1c70
	ctx.lr = 0x830FCF94;
	sub_830F1C70(ctx, base);
	// 830FCF94: 80FF00C0  lwz r7, 0xc0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 830FCF98: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 830FCF9C: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 830FCFA0: 0CC70000  twi 6, r7, 0
	// 830FCFA4: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FCFA8: 7CCA3BD6  divw r6, r10, r7
	ctx.r[6].s32 = ctx.r[10].s32 / ctx.r[7].s32;
	// 830FCFAC: 811F00BC  lwz r8, 0xbc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 830FCFB0: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830FCFB4: 80BF00AC  lwz r5, 0xac(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FCFB8: 7CC639D6  mullw r6, r6, r7
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[7].s32 as i64);
	// 830FCFBC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830FCFC0: 7D465050  subf r10, r6, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 830FCFC4: 7CE74878  andc r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 & !ctx.r[9].u64;
	// 830FCFC8: 1D2A0014  mulli r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 * 20;
	// 830FCFCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FCFD0: 397F00BC  addi r11, r31, 0xbc
	ctx.r[11].s64 = ctx.r[31].s64 + 188;
	// 830FCFD4: 0CA7FFFF  twi 5, r7, -1
	// 830FCFD8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 830FCFDC: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 830FCFE0: 409A0098  bne cr6, 0x830fd078
	if !ctx.cr[6].eq {
	pc = 0x830FD078; continue 'dispatch;
	}
	// 830FCFE4: C1BF0054  lfs f13, 0x54(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FCFE8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 830FCFEC: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FCFF0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830FCFF4: 4099011C  ble cr6, 0x830fd110
	if !ctx.cr[6].gt {
	pc = 0x830FD110; continue 'dispatch;
	}
	// 830FCFF8: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FCFFC: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD000: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 830FD004: 7F073000  cmpw cr6, r7, r6
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830FD008: 40980108  bge cr6, 0x830fd110
	if !ctx.cr[6].lt {
	pc = 0x830FD110; continue 'dispatch;
	}
	// 830FD00C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FD010: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FD014: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD018: 7C895214  add r4, r9, r10
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830FD01C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD020: 0CC50000  twi 6, r5, 0
	// 830FD024: 7FC42BD6  divw r30, r4, r5
	ctx.r[30].s32 = ctx.r[4].s32 / ctx.r[5].s32;
	// 830FD028: 5489083E  rotlwi r9, r4, 1
	ctx.r[9].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830FD02C: 7FDE29D6  mullw r30, r30, r5
	ctx.r[30].s64 = (ctx.r[30].s32 as i64) * (ctx.r[5].s32 as i64);
	// 830FD030: 7C9E2050  subf r4, r30, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 830FD034: 3BC9FFFF  addi r30, r9, -1
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	// 830FD038: 1D240014  mulli r9, r4, 0x14
	ctx.r[9].s64 = ctx.r[4].s64 * 20;
	// 830FD03C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 830FD040: 7CA8F078  andc r8, r5, r30
	ctx.r[8].u64 = ctx.r[5].u64 & !ctx.r[30].u64;
	// 830FD044: 0CA8FFFF  twi 5, r8, -1
	// 830FD048: C1690008  lfs f11, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FD04C: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FD050: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830FD054: 419900BC  bgt cr6, 0x830fd110
	if ctx.cr[6].gt {
	pc = 0x830FD110; continue 'dispatch;
	}
	// 830FD058: 813F00AC  lwz r9, 0xac(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD05C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830FD060: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FD064: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 830FD068: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 830FD06C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FD070: 4198FF94  blt cr6, 0x830fd004
	if ctx.cr[6].lt {
	pc = 0x830FD004; continue 'dispatch;
	}
	// 830FD074: 4800009C  b 0x830fd110
	pc = 0x830FD110; continue 'dispatch;
	// 830FD078: C1BF0058  lfs f13, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FD07C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 830FD080: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FD084: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830FD088: 40990088  ble cr6, 0x830fd110
	if !ctx.cr[6].gt {
	pc = 0x830FD110; continue 'dispatch;
	}
	// 830FD08C: 813F00E8  lwz r9, 0xe8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD090: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD094: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 830FD098: 7F073000  cmpw cr6, r7, r6
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830FD09C: 40980074  bge cr6, 0x830fd110
	if !ctx.cr[6].lt {
	pc = 0x830FD110; continue 'dispatch;
	}
	// 830FD0A0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FD0A4: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FD0A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD0AC: 7C895214  add r4, r9, r10
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830FD0B0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD0B4: 0CC50000  twi 6, r5, 0
	// 830FD0B8: 7FC42BD6  divw r30, r4, r5
	ctx.r[30].s32 = ctx.r[4].s32 / ctx.r[5].s32;
	// 830FD0BC: 5489083E  rotlwi r9, r4, 1
	ctx.r[9].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 830FD0C0: 7FDE29D6  mullw r30, r30, r5
	ctx.r[30].s64 = (ctx.r[30].s32 as i64) * (ctx.r[5].s32 as i64);
	// 830FD0C4: 7C9E2050  subf r4, r30, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 830FD0C8: 3BC9FFFF  addi r30, r9, -1
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	// 830FD0CC: 1D240014  mulli r9, r4, 0x14
	ctx.r[9].s64 = ctx.r[4].s64 * 20;
	// 830FD0D0: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 830FD0D4: 7CA8F078  andc r8, r5, r30
	ctx.r[8].u64 = ctx.r[5].u64 & !ctx.r[30].u64;
	// 830FD0D8: 0CA8FFFF  twi 5, r8, -1
	// 830FD0DC: C1690004  lfs f11, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830FD0E0: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FD0E4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830FD0E8: 41990028  bgt cr6, 0x830fd110
	if ctx.cr[6].gt {
	pc = 0x830FD110; continue 'dispatch;
	}
	// 830FD0EC: 813F00AC  lwz r9, 0xac(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD0F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830FD0F4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830FD0F8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 830FD0FC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 830FD100: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FD104: 4198FF94  blt cr6, 0x830fd098
	if ctx.cr[6].lt {
	pc = 0x830FD098; continue 'dispatch;
	}
	// 830FD108: 48000008  b 0x830fd110
	pc = 0x830FD110; continue 'dispatch;
	// 830FD10C: 4BFF4815  bl 0x830f1920
	ctx.lr = 0x830FD110;
	sub_830F1920(ctx, base);
	// 830FD110: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FD114: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD118: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FD11C: 41980014  blt cr6, 0x830fd130
	if ctx.cr[6].lt {
	pc = 0x830FD130; continue 'dispatch;
	}
	// 830FD120: 7D2A1A14  add r9, r10, r3
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 830FD124: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FD128: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830FD12C: 41980008  blt cr6, 0x830fd134
	if ctx.cr[6].lt {
	pc = 0x830FD134; continue 'dispatch;
	}
	// 830FD130: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830FD134: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 830FD138: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD13C: 4BFE3A65  bl 0x830e0ba0
	ctx.lr = 0x830FD140;
	sub_830E0BA0(ctx, base);
	// 830FD140: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD144: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830FD148: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FD14C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD150: 409900C8  ble cr6, 0x830fd218
	if !ctx.cr[6].gt {
	pc = 0x830FD218; continue 'dispatch;
	}
	// 830FD154: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830FD158: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD15C: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD160: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830FD164: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD168: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FD16C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FD170: 4098007C  bge cr6, 0x830fd1ec
	if !ctx.cr[6].lt {
	pc = 0x830FD1EC; continue 'dispatch;
	}
	// 830FD174: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD178: 4BFE1FA9  bl 0x830df120
	ctx.lr = 0x830FD17C;
	sub_830DF120(ctx, base);
	// 830FD17C: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD180: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FD184: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FD188: 4BFEA6F1  bl 0x830e7878
	ctx.lr = 0x830FD18C;
	sub_830E7878(ctx, base);
	// 830FD18C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD190: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD194: 419A0024  beq cr6, 0x830fd1b8
	if ctx.cr[6].eq {
	pc = 0x830FD1B8; continue 'dispatch;
	}
	// 830FD198: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD19C: 4BFD1A75  bl 0x830cec10
	ctx.lr = 0x830FD1A0;
	sub_830CEC10(ctx, base);
	// 830FD1A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD1A4: 4BFEADD5  bl 0x830e7f78
	ctx.lr = 0x830FD1A8;
	sub_830E7F78(ctx, base);
	// 830FD1A8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD1AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FD1B0: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FD1B4: 4BFEACED  bl 0x830e7ea0
	ctx.lr = 0x830FD1B8;
	sub_830E7EA0(ctx, base);
	// 830FD1B8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FD1BC: 409A000C  bne cr6, 0x830fd1c8
	if !ctx.cr[6].eq {
	pc = 0x830FD1C8; continue 'dispatch;
	}
	// 830FD1C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FD1C4: 48000018  b 0x830fd1dc
	pc = 0x830FD1DC; continue 'dispatch;
	// 830FD1C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD1CC: 4BFD1A45  bl 0x830cec10
	ctx.lr = 0x830FD1D0;
	sub_830CEC10(ctx, base);
	// 830FD1D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD1D4: 4BFEADED  bl 0x830e7fc0
	ctx.lr = 0x830FD1D8;
	sub_830E7FC0(ctx, base);
	// 830FD1D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FD1DC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD1E0: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FD1E4: 4BFEAB15  bl 0x830e7cf8
	ctx.lr = 0x830FD1E8;
	sub_830E7CF8(ctx, base);
	// 830FD1E8: 4800001C  b 0x830fd204
	pc = 0x830FD204; continue 'dispatch;
	// 830FD1EC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830FD1F0: 4BFE1F31  bl 0x830df120
	ctx.lr = 0x830FD1F4;
	sub_830DF120(ctx, base);
	// 830FD1F4: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD1F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FD1FC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830FD200: 4BFEA679  bl 0x830e7878
	ctx.lr = 0x830FD204;
	sub_830E7878(ctx, base);
	// 830FD204: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD208: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830FD20C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830FD210: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD214: 4198FF44  blt cr6, 0x830fd158
	if ctx.cr[6].lt {
	pc = 0x830FD158; continue 'dispatch;
	}
	// 830FD218: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD21C: 4BFE4295  bl 0x830e14b0
	ctx.lr = 0x830FD220;
	sub_830E14B0(ctx, base);
	// 830FD220: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FD224: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FD228: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD22C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FD230: 409A0024  bne cr6, 0x830fd254
	if !ctx.cr[6].eq {
	pc = 0x830FD254; continue 'dispatch;
	}
	// 830FD234: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD238: 4BFE2C39  bl 0x830dfe70
	ctx.lr = 0x830FD23C;
	sub_830DFE70(ctx, base);
	// 830FD23C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FD240: 4182006C  beq 0x830fd2ac
	if ctx.cr[0].eq {
	pc = 0x830FD2AC; continue 'dispatch;
	}
	// 830FD244: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD24C: 4BFE7D85  bl 0x830e4fd0
	ctx.lr = 0x830FD250;
	sub_830E4FD0(ctx, base);
	// 830FD250: 4800005C  b 0x830fd2ac
	pc = 0x830FD2AC; continue 'dispatch;
	// 830FD254: 4BFD19BD  bl 0x830cec10
	ctx.lr = 0x830FD258;
	sub_830CEC10(ctx, base);
	// 830FD258: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830FD25C: 419A0018  beq cr6, 0x830fd274
	if ctx.cr[6].eq {
	pc = 0x830FD274; continue 'dispatch;
	}
	// 830FD260: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD264: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD268: 4BFE2C09  bl 0x830dfe70
	ctx.lr = 0x830FD26C;
	sub_830DFE70(ctx, base);
	// 830FD26C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FD270: 4182003C  beq 0x830fd2ac
	if ctx.cr[0].eq {
	pc = 0x830FD2AC; continue 'dispatch;
	}
	// 830FD274: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FD278: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD27C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FD280: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FD284: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FD288: 419A0024  beq cr6, 0x830fd2ac
	if ctx.cr[6].eq {
	pc = 0x830FD2AC; continue 'dispatch;
	}
	// 830FD28C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FD290: 4BFE1C71  bl 0x830def00
	ctx.lr = 0x830FD294;
	sub_830DEF00(ctx, base);
	// 830FD294: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FD298: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD29C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FD2A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FD2A4: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FD2A8: 4BFE5979  bl 0x830e2c20
	ctx.lr = 0x830FD2AC;
	sub_830E2C20(ctx, base);
	// 830FD2AC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FD2B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD2B4: 419A0014  beq cr6, 0x830fd2c8
	if ctx.cr[6].eq {
	pc = 0x830FD2C8; continue 'dispatch;
	}
	// 830FD2B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FD2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD2C0: 4BFF5519  bl 0x830f27d8
	ctx.lr = 0x830FD2C4;
	sub_830F27D8(ctx, base);
	// 830FD2C4: 48000024  b 0x830fd2e8
	pc = 0x830FD2E8; continue 'dispatch;
	// 830FD2C8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD2CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD2D0: 409A0010  bne cr6, 0x830fd2e0
	if !ctx.cr[6].eq {
	pc = 0x830FD2E0; continue 'dispatch;
	}
	// 830FD2D4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FD2D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD2DC: 419A000C  beq cr6, 0x830fd2e8
	if ctx.cr[6].eq {
	pc = 0x830FD2E8; continue 'dispatch;
	}
	// 830FD2E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD2E4: 4BFFA3C5  bl 0x830f76a8
	ctx.lr = 0x830FD2E8;
	sub_830F76A8(ctx, base);
	// 830FD2E8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FD2EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FD2F0: 419A0080  beq cr6, 0x830fd370
	if ctx.cr[6].eq {
	pc = 0x830FD370; continue 'dispatch;
	}
	// 830FD2F4: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FD2F8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FD2FC: 419A000C  beq cr6, 0x830fd308
	if ctx.cr[6].eq {
	pc = 0x830FD308; continue 'dispatch;
	}
	// 830FD300: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FD304: 409A0014  bne cr6, 0x830fd318
	if !ctx.cr[6].eq {
	pc = 0x830FD318; continue 'dispatch;
	}
	// 830FD308: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FD30C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FD310: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FD314: 419A0044  beq cr6, 0x830fd358
	if ctx.cr[6].eq {
	pc = 0x830FD358; continue 'dispatch;
	}
	// 830FD318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD31C: 4BFF484D  bl 0x830f1b68
	ctx.lr = 0x830FD320;
	sub_830F1B68(ctx, base);
	// 830FD320: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FD324: 41820034  beq 0x830fd358
	if ctx.cr[0].eq {
	pc = 0x830FD358; continue 'dispatch;
	}
	// 830FD328: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FD32C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FD330: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FD334: 419A000C  beq cr6, 0x830fd340
	if ctx.cr[6].eq {
	pc = 0x830FD340; continue 'dispatch;
	}
	// 830FD338: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FD33C: 409A0014  bne cr6, 0x830fd350
	if !ctx.cr[6].eq {
	pc = 0x830FD350; continue 'dispatch;
	}
	// 830FD340: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FD344: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FD348: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FD34C: 419A001C  beq cr6, 0x830fd368
	if ctx.cr[6].eq {
	pc = 0x830FD368; continue 'dispatch;
	}
	// 830FD350: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FD354: 48000018  b 0x830fd36c
	pc = 0x830FD36C; continue 'dispatch;
	// 830FD358: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FD35C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830FD360: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830FD364: 409A0008  bne cr6, 0x830fd36c
	if !ctx.cr[6].eq {
	pc = 0x830FD36C; continue 'dispatch;
	}
	// 830FD368: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FD36C: 4BFEAFDD  bl 0x830e8348
	ctx.lr = 0x830FD370;
	sub_830E8348(ctx, base);
	// 830FD370: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FD374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FD378: 419A0070  beq cr6, 0x830fd3e8
	if ctx.cr[6].eq {
	pc = 0x830FD3E8; continue 'dispatch;
	}
	// 830FD37C: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FD380: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FD384: 419A000C  beq cr6, 0x830fd390
	if ctx.cr[6].eq {
	pc = 0x830FD390; continue 'dispatch;
	}
	// 830FD388: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FD38C: 409A0014  bne cr6, 0x830fd3a0
	if !ctx.cr[6].eq {
	pc = 0x830FD3A0; continue 'dispatch;
	}
	// 830FD390: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FD394: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 830FD398: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830FD39C: 419A0038  beq cr6, 0x830fd3d4
	if ctx.cr[6].eq {
	pc = 0x830FD3D4; continue 'dispatch;
	}
	// 830FD3A0: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD3A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FD3A8: 4199002C  bgt cr6, 0x830fd3d4
	if ctx.cr[6].gt {
	pc = 0x830FD3D4; continue 'dispatch;
	}
	// 830FD3AC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FD3B0: 419A000C  beq cr6, 0x830fd3bc
	if ctx.cr[6].eq {
	pc = 0x830FD3BC; continue 'dispatch;
	}
	// 830FD3B4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FD3B8: 409A0014  bne cr6, 0x830fd3cc
	if !ctx.cr[6].eq {
	pc = 0x830FD3CC; continue 'dispatch;
	}
	// 830FD3BC: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FD3C0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FD3C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FD3C8: 419A0018  beq cr6, 0x830fd3e0
	if ctx.cr[6].eq {
	pc = 0x830FD3E0; continue 'dispatch;
	}
	// 830FD3CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FD3D0: 48000014  b 0x830fd3e4
	pc = 0x830FD3E4; continue 'dispatch;
	// 830FD3D4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830FD3D8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830FD3DC: 419A0008  beq cr6, 0x830fd3e4
	if ctx.cr[6].eq {
	pc = 0x830FD3E4; continue 'dispatch;
	}
	// 830FD3E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FD3E4: 4BFEAF65  bl 0x830e8348
	ctx.lr = 0x830FD3E8;
	sub_830E8348(ctx, base);
	// 830FD3E8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FD3EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FD3F0: 419A076C  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD3F8: 4BFF4529  bl 0x830f1920
	ctx.lr = 0x830FD3FC;
	sub_830F1920(ctx, base);
	// 830FD3FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830FD400: 80BF00E8  lwz r5, 0xe8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD404: 809F00F0  lwz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD408: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FD40C: 4BFEAF85  bl 0x830e8390
	ctx.lr = 0x830FD410;
	sub_830E8390(ctx, base);
	// 830FD410: 4800074C  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FD414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FD418: 81560010  lwz r10, 0x10(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD41C: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FD420: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD424: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830FD428: 48000734  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FD42C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FD430: 83960010  lwz r28, 0x10(r22)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD434: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FD438: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD43C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD440: 419A071C  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD444: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD448: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FD44C: 41980710  blt cr6, 0x830fdb5c
	if ctx.cr[6].lt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD450: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD454: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD458: 40980704  bge cr6, 0x830fdb5c
	if !ctx.cr[6].lt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD45C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD460: 419A008C  beq cr6, 0x830fd4ec
	if ctx.cr[6].eq {
	pc = 0x830FD4EC; continue 'dispatch;
	}
	// 830FD464: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD468: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD46C: 419A0080  beq cr6, 0x830fd4ec
	if ctx.cr[6].eq {
	pc = 0x830FD4EC; continue 'dispatch;
	}
	// 830FD470: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD474: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD478: 41980074  blt cr6, 0x830fd4ec
	if ctx.cr[6].lt {
	pc = 0x830FD4EC; continue 'dispatch;
	}
	// 830FD47C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD480: 4198006C  blt cr6, 0x830fd4ec
	if ctx.cr[6].lt {
	pc = 0x830FD4EC; continue 'dispatch;
	}
	// 830FD484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD488: 557E003E  slwi r30, r11, 0
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830FD48C: 555D003E  slwi r29, r10, 0
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830FD490: 4BFF4491  bl 0x830f1920
	ctx.lr = 0x830FD494;
	sub_830F1920(ctx, base);
	// 830FD494: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 830FD498: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD49C: 40980050  bge cr6, 0x830fd4ec
	if !ctx.cr[6].lt {
	pc = 0x830FD4EC; continue 'dispatch;
	}
	// 830FD4A0: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 830FD4A4: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD4A8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FD4AC: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FD4B0: 4BFEA9A9  bl 0x830e7e58
	ctx.lr = 0x830FD4B4;
	sub_830E7E58(ctx, base);
	// 830FD4B4: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD4B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FD4BC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830FD4C0: 4182000C  beq 0x830fd4cc
	if ctx.cr[0].eq {
	pc = 0x830FD4CC; continue 'dispatch;
	}
	// 830FD4C4: 419A000C  beq cr6, 0x830fd4d0
	if ctx.cr[6].eq {
	pc = 0x830FD4D0; continue 'dispatch;
	}
	// 830FD4C8: 48000024  b 0x830fd4ec
	pc = 0x830FD4EC; continue 'dispatch;
	// 830FD4CC: 419A0020  beq cr6, 0x830fd4ec
	if ctx.cr[6].eq {
	pc = 0x830FD4EC; continue 'dispatch;
	}
	// 830FD4D0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD4D4: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD4D8: 813F00B0  lwz r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD4DC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830FD4E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FD4E4: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FD4E8: 4BFEA9B9  bl 0x830e7ea0
	ctx.lr = 0x830FD4EC;
	sub_830E7EA0(ctx, base);
	// 830FD4EC: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD4F0: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD4F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD4F8: 4BFD1719  bl 0x830cec10
	ctx.lr = 0x830FD4FC;
	sub_830CEC10(ctx, base);
	// 830FD4FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830FD500: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830FD504: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FD508: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830FD50C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830FD510: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 830FD514: 4BFE98C5  bl 0x830e6dd8
	ctx.lr = 0x830FD518;
	sub_830E6DD8(ctx, base);
	// 830FD518: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD51C: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 830FD520: 4BFD16F1  bl 0x830cec10
	ctx.lr = 0x830FD524;
	sub_830CEC10(ctx, base);
	// 830FD524: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830FD528: 4BFD8831  bl 0x830d5d58
	ctx.lr = 0x830FD52C;
	sub_830D5D58(ctx, base);
	// 830FD52C: 48000630  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FD530: 2B0B07E6  cmplwi cr6, r11, 0x7e6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2022 as u32, &mut ctx.xer);
	// 830FD534: 419A0188  beq cr6, 0x830fd6bc
	if ctx.cr[6].eq {
	pc = 0x830FD6BC; continue 'dispatch;
	}
	// 830FD538: 2B0B07E8  cmplwi cr6, r11, 0x7e8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2024 as u32, &mut ctx.xer);
	// 830FD53C: 419A016C  beq cr6, 0x830fd6a8
	if ctx.cr[6].eq {
	pc = 0x830FD6A8; continue 'dispatch;
	}
	// 830FD540: 2B0B07E9  cmplwi cr6, r11, 0x7e9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2025 as u32, &mut ctx.xer);
	// 830FD544: 419A00BC  beq cr6, 0x830fd600
	if ctx.cr[6].eq {
	pc = 0x830FD600; continue 'dispatch;
	}
	// 830FD548: 2B0B07F2  cmplwi cr6, r11, 0x7f2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2034 as u32, &mut ctx.xer);
	// 830FD54C: 419A0060  beq cr6, 0x830fd5ac
	if ctx.cr[6].eq {
	pc = 0x830FD5AC; continue 'dispatch;
	}
	// 830FD550: 2B0B07F3  cmplwi cr6, r11, 0x7f3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2035 as u32, &mut ctx.xer);
	// 830FD554: 409A0608  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD558: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD55C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830FD560: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD564: C1AA08A4  lfs f13, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FD568: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 830FD56C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FD570: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 830FD574: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830FD578: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FD57C: FD8C6B2E  fsel f12, f12, f12, f13
	ctx.f[12].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[13].f64 };
	// 830FD580: D19F006C  stfs f12, 0x6c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830FD584: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 830FD588: 40980008  bge cr6, 0x830fd590
	if !ctx.cr[6].lt {
	pc = 0x830FD590; continue 'dispatch;
	}
	// 830FD58C: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830FD590: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FD594: FD8C6B2E  fsel f12, f12, f12, f13
	ctx.f[12].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[13].f64 };
	// 830FD598: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FD59C: D19F0070  stfs f12, 0x70(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830FD5A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830FD5A4: 4198F1EC  blt cr6, 0x830fc790
	if ctx.cr[6].lt {
	pc = 0x830FC790; continue 'dispatch;
	}
	// 830FD5A8: 4BFFF1DC  b 0x830fc784
	pc = 0x830FC784; continue 'dispatch;
	// 830FD5AC: 815F0064  lwz r10, 0x64(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830FD5B0: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD5B4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830FD5B8: C01F0068  lfs f0, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FD5BC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830FD5C0: C01F006C  lfs f0, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FD5C4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830FD5C8: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FD5CC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830FD5D0: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FD5D4: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830FD5D8: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FD5DC: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 830FD5E0: 419A000C  beq cr6, 0x830fd5ec
	if ctx.cr[6].eq {
	pc = 0x830FD5EC; continue 'dispatch;
	}
	// 830FD5E4: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 830FD5E8: 409AF1AC  bne cr6, 0x830fc794
	if !ctx.cr[6].eq {
	pc = 0x830FC794; continue 'dispatch;
	}
	// 830FD5EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830FD5F0: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FD5F4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830FD5F8: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830FD5FC: 4BFFF198  b 0x830fc794
	pc = 0x830FC794; continue 'dispatch;
	// 830FD600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FD604: 83960010  lwz r28, 0x10(r22)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD608: 91760008  stw r11, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FD60C: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD610: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD614: 419A0548  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD618: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD61C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD620: 419A053C  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD624: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD628: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD62C: 41980530  blt cr6, 0x830fdb5c
	if ctx.cr[6].lt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD630: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD634: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD638: 41980524  blt cr6, 0x830fdb5c
	if ctx.cr[6].lt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD63C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD640: 557E003E  slwi r30, r11, 0
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 830FD644: 555D003E  slwi r29, r10, 0
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830FD648: 4BFF42D9  bl 0x830f1920
	ctx.lr = 0x830FD64C;
	sub_830F1920(ctx, base);
	// 830FD64C: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 830FD650: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD654: 40980508  bge cr6, 0x830fdb5c
	if !ctx.cr[6].lt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD658: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 830FD65C: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD660: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FD664: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FD668: 4BFE3539  bl 0x830e0ba0
	ctx.lr = 0x830FD66C;
	sub_830E0BA0(ctx, base);
	// 830FD66C: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD670: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FD674: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830FD678: 4182000C  beq 0x830fd684
	if ctx.cr[0].eq {
	pc = 0x830FD684; continue 'dispatch;
	}
	// 830FD67C: 419A000C  beq cr6, 0x830fd688
	if ctx.cr[6].eq {
	pc = 0x830FD688; continue 'dispatch;
	}
	// 830FD680: 480004DC  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FD684: 419A04D8  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD688: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD68C: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD690: 813F00B0  lwz r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD694: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830FD698: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FD69C: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FD6A0: 4BFEA659  bl 0x830e7cf8
	ctx.lr = 0x830FD6A4;
	sub_830E7CF8(ctx, base);
	// 830FD6A4: 480004B8  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FD6A8: 81760010  lwz r11, 0x10(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD6AC: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 830FD6B0: 92960008  stw r20, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830FD6B4: 928B0004  stw r20, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 830FD6B8: 480004A4  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FD6BC: 82B60010  lwz r21, 0x10(r22)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FD6C0: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD6C4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FD6C8: 419A0448  beq cr6, 0x830fdb10
	if ctx.cr[6].eq {
	pc = 0x830FDB10; continue 'dispatch;
	}
	// 830FD6CC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FD6D0: 419A0440  beq cr6, 0x830fdb10
	if ctx.cr[6].eq {
	pc = 0x830FDB10; continue 'dispatch;
	}
	// 830FD6D4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FD6D8: 80750004  lwz r3, 4(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD6DC: 808BC0B8  lwz r4, -0x3f48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16200 as u32) ) } as u64;
	// 830FD6E0: 4BFD1491  bl 0x830ceb70
	ctx.lr = 0x830FD6E4;
	sub_830CEB70(ctx, base);
	// 830FD6E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD6E8: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FD6EC: 419A0470  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD6F0: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 830FD6F4: 83DF00E4  lwz r30, 0xe4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830FD6F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FD6FC: 419A0014  beq cr6, 0x830fd710
	if ctx.cr[6].eq {
	pc = 0x830FD710; continue 'dispatch;
	}
	// 830FD700: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FD704: 419A000C  beq cr6, 0x830fd710
	if ctx.cr[6].eq {
	pc = 0x830FD710; continue 'dispatch;
	}
	// 830FD708: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FD70C: 409A0008  bne cr6, 0x830fd714
	if !ctx.cr[6].eq {
	pc = 0x830FD714; continue 'dispatch;
	}
	// 830FD710: 83DF00E0  lwz r30, 0xe0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 830FD714: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 830FD718: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830FD71C: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 830FD720: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FD724: 419A0014  beq cr6, 0x830fd738
	if ctx.cr[6].eq {
	pc = 0x830FD738; continue 'dispatch;
	}
	// 830FD728: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FD72C: 419A000C  beq cr6, 0x830fd738
	if ctx.cr[6].eq {
	pc = 0x830FD738; continue 'dispatch;
	}
	// 830FD730: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FD734: 409A000C  bne cr6, 0x830fd740
	if !ctx.cr[6].eq {
	pc = 0x830FD740; continue 'dispatch;
	}
	// 830FD738: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 830FD73C: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 830FD740: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 830FD744: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 830FD748: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FD74C: 419A0018  beq cr6, 0x830fd764
	if ctx.cr[6].eq {
	pc = 0x830FD764; continue 'dispatch;
	}
	// 830FD750: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830FD754: 409A0018  bne cr6, 0x830fd76c
	if !ctx.cr[6].eq {
	pc = 0x830FD76C; continue 'dispatch;
	}
	// 830FD758: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FD75C: 7E9BA378  mr r27, r20
	ctx.r[27].u64 = ctx.r[20].u64;
	// 830FD760: 4800000C  b 0x830fd76c
	pc = 0x830FD76C; continue 'dispatch;
	// 830FD764: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 830FD768: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 830FD76C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830FD770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD774: 4BFF6335  bl 0x830f3aa8
	ctx.lr = 0x830FD778;
	sub_830F3AA8(ctx, base);
	// 830FD778: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FD77C: 40820388  bne 0x830fdb04
	if !ctx.cr[0].eq {
	pc = 0x830FDB04; continue 'dispatch;
	}
	// 830FD780: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD784: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830FD788: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FD78C: 409903D0  ble cr6, 0x830fdb5c
	if !ctx.cr[6].gt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FD790: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 830FD794: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830FD798: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830FD79C: 419A0014  beq cr6, 0x830fd7b0
	if ctx.cr[6].eq {
	pc = 0x830FD7B0; continue 'dispatch;
	}
	// 830FD7A0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD7A4: 81150004  lwz r8, 4(r21)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FD7A8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830FD7AC: 419A001C  beq cr6, 0x830fd7c8
	if ctx.cr[6].eq {
	pc = 0x830FD7C8; continue 'dispatch;
	}
	// 830FD7B0: 813F00AC  lwz r9, 0xac(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830FD7B4: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 830FD7B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830FD7BC: 7F174800  cmpw cr6, r23, r9
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FD7C0: 4198FFD8  blt cr6, 0x830fd798
	if ctx.cr[6].lt {
	pc = 0x830FD798; continue 'dispatch;
	}
	// 830FD7C4: 48000398  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FD7C8: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD7CC: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830FD7D0: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD7D4: 813F00EC  lwz r9, 0xec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FD7D8: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830FD7DC: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 830FD7E0: 409A00C0  bne cr6, 0x830fd8a0
	if !ctx.cr[6].eq {
	pc = 0x830FD8A0; continue 'dispatch;
	}
	// 830FD7E4: 7F17F000  cmpw cr6, r23, r30
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830FD7E8: 4198000C  blt cr6, 0x830fd7f4
	if ctx.cr[6].lt {
	pc = 0x830FD7F4; continue 'dispatch;
	}
	// 830FD7EC: 7FDE4850  subf r30, r30, r9
	ctx.r[30].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	// 830FD7F0: 480002F0  b 0x830fdae0
	pc = 0x830FDAE0; continue 'dispatch;
	// 830FD7F4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FD7F8: 40990048  ble cr6, 0x830fd840
	if !ctx.cr[6].gt {
	pc = 0x830FD840; continue 'dispatch;
	}
	// 830FD7FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD800: 7FBE4850  subf r29, r30, r9
	ctx.r[29].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	// 830FD804: 4BFD140D  bl 0x830cec10
	ctx.lr = 0x830FD808;
	sub_830CEC10(ctx, base);
	// 830FD808: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FD80C: 4BFEA1B5  bl 0x830e79c0
	ctx.lr = 0x830FD810;
	sub_830E79C0(ctx, base);
	// 830FD810: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FD814: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD818: 409A0248  bne cr6, 0x830fda60
	if !ctx.cr[6].eq {
	pc = 0x830FDA60; continue 'dispatch;
	}
	// 830FD81C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD820: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD824: 409A023C  bne cr6, 0x830fda60
	if !ctx.cr[6].eq {
	pc = 0x830FDA60; continue 'dispatch;
	}
	// 830FD828: 7FDE5850  subf r30, r30, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830FD82C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD830: 4BFD13E1  bl 0x830cec10
	ctx.lr = 0x830FD834;
	sub_830CEC10(ctx, base);
	// 830FD834: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD838: 4BFEA379  bl 0x830e7bb0
	ctx.lr = 0x830FD83C;
	sub_830E7BB0(ctx, base);
	// 830FD83C: 48000224  b 0x830fda60
	pc = 0x830FDA60; continue 'dispatch;
	// 830FD840: 409A02B0  bne cr6, 0x830fdaf0
	if !ctx.cr[6].eq {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FD844: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FD848: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FD84C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FD850: 409A02A0  bne cr6, 0x830fdaf0
	if !ctx.cr[6].eq {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FD854: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD858: 0CDE0000  twi 6, r30, 0
	// 830FD85C: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830FD860: 7D0BF3D6  divw r8, r11, r30
	ctx.r[8].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 830FD864: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 830FD868: 7D48F1D6  mullw r10, r8, r30
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830FD86C: 7FC83878  andc r8, r30, r7
	ctx.r[8].u64 = ctx.r[30].u64 & !ctx.r[7].u64;
	// 830FD870: 7D4A5851  subf. r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FD874: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 830FD878: 0CA8FFFF  twi 5, r8, -1
	// 830FD87C: 4082000C  bne 0x830fd888
	if !ctx.cr[0].eq {
	pc = 0x830FD888; continue 'dispatch;
	}
	// 830FD880: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 830FD884: 48000010  b 0x830fd894
	pc = 0x830FD894; continue 'dispatch;
	// 830FD888: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FD88C: 409801C4  bge cr6, 0x830fda50
	if !ctx.cr[6].lt {
	pc = 0x830FDA50; continue 'dispatch;
	}
	// 830FD890: 7D6AE850  subf r11, r10, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[10].s64;
	// 830FD894: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830FD898: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 830FD89C: 480001B4  b 0x830fda50
	pc = 0x830FDA50; continue 'dispatch;
	// 830FD8A0: 7F0BD000  cmpw cr6, r11, r26
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830FD8A4: 409A01C4  bne cr6, 0x830fda68
	if !ctx.cr[6].eq {
	pc = 0x830FDA68; continue 'dispatch;
	}
	// 830FD8A8: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD8AC: 7F9E4A14  add r28, r30, r9
	ctx.r[28].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 830FD8B0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD8B4: 41980008  blt cr6, 0x830fd8bc
	if ctx.cr[6].lt {
	pc = 0x830FD8BC; continue 'dispatch;
	}
	// 830FD8B8: 3B8BFFFF  addi r28, r11, -1
	ctx.r[28].s64 = ctx.r[11].s64 + -1;
	// 830FD8BC: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830FD8C0: 7D2BF3D6  divw r9, r11, r30
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 830FD8C4: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 830FD8C8: 7D49F1D6  mullw r10, r9, r30
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830FD8CC: 7D4A5851  subf. r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FD8D0: 7FC94078  andc r9, r30, r8
	ctx.r[9].u64 = ctx.r[30].u64 & !ctx.r[8].u64;
	// 830FD8D4: 0CDE0000  twi 6, r30, 0
	// 830FD8D8: 0CA9FFFF  twi 5, r9, -1
	// 830FD8DC: 7FAA5850  subf r29, r10, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830FD8E0: 40820008  bne 0x830fd8e8
	if !ctx.cr[0].eq {
	pc = 0x830FD8E8; continue 'dispatch;
	}
	// 830FD8E4: 7FBE5850  subf r29, r30, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830FD8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD8EC: 4BFF4035  bl 0x830f1920
	ctx.lr = 0x830FD8F0;
	sub_830F1920(ctx, base);
	// 830FD8F0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830FD8F4: 40990010  ble cr6, 0x830fd904
	if !ctx.cr[6].gt {
	pc = 0x830FD904; continue 'dispatch;
	}
	// 830FD8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FD8FC: 4BFF4025  bl 0x830f1920
	ctx.lr = 0x830FD900;
	sub_830F1920(ctx, base);
	// 830FD900: 48000008  b 0x830fd908
	pc = 0x830FD908; continue 'dispatch;
	// 830FD904: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 830FD908: 3943FFFF  addi r10, r3, -1
	ctx.r[10].s64 = ctx.r[3].s64 + -1;
	// 830FD90C: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FD910: 0CDE0000  twi 6, r30, 0
	// 830FD914: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 830FD918: 7D4AF3D6  divw r10, r10, r30
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[30].s32;
	// 830FD91C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830FD920: 7D6AF1D6  mullw r11, r10, r30
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830FD924: 7FCA4078  andc r10, r30, r8
	ctx.r[10].u64 = ctx.r[30].u64 & !ctx.r[8].u64;
	// 830FD928: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830FD92C: 0CAAFFFF  twi 5, r10, -1
	// 830FD930: 419A0084  beq cr6, 0x830fd9b4
	if ctx.cr[6].eq {
	pc = 0x830FD9B4; continue 'dispatch;
	}
	// 830FD934: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD938: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FD93C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830FD940: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FD944: 40980050  bge cr6, 0x830fd994
	if !ctx.cr[6].lt {
	pc = 0x830FD994; continue 'dispatch;
	}
	// 830FD948: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD94C: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 830FD950: 4BFD12C1  bl 0x830cec10
	ctx.lr = 0x830FD954;
	sub_830CEC10(ctx, base);
	// 830FD954: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD958: 4BFEA069  bl 0x830e79c0
	ctx.lr = 0x830FD95C;
	sub_830E79C0(ctx, base);
	// 830FD95C: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FD960: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FD964: 409A018C  bne cr6, 0x830fdaf0
	if !ctx.cr[6].eq {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FD968: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 830FD96C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FD970: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD974: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 830FD978: 4BFD1299  bl 0x830cec10
	ctx.lr = 0x830FD97C;
	sub_830CEC10(ctx, base);
	// 830FD97C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FD980: 4BFEA231  bl 0x830e7bb0
	ctx.lr = 0x830FD984;
	sub_830E7BB0(ctx, base);
	// 830FD984: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FD988: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830FD98C: 419AFFE0  beq cr6, 0x830fd96c
	if ctx.cr[6].eq {
	pc = 0x830FD96C; continue 'dispatch;
	}
	// 830FD990: 48000160  b 0x830fdaf0
	pc = 0x830FDAF0; continue 'dispatch;
	// 830FD994: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FD998: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FD99C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FD9A0: 409A0150  bne cr6, 0x830fdaf0
	if !ctx.cr[6].eq {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FD9A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD9A8: 4BFD1269  bl 0x830cec10
	ctx.lr = 0x830FD9AC;
	sub_830CEC10(ctx, base);
	// 830FD9AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FD9B0: 480000AC  b 0x830fda5c
	pc = 0x830FDA5C; continue 'dispatch;
	// 830FD9B4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD9B8: 40980008  bge cr6, 0x830fd9c0
	if !ctx.cr[6].lt {
	pc = 0x830FD9C0; continue 'dispatch;
	}
	// 830FD9BC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830FD9C0: 7F175800  cmpw cr6, r23, r11
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FD9C4: 40980014  bge cr6, 0x830fd9d8
	if !ctx.cr[6].lt {
	pc = 0x830FD9D8; continue 'dispatch;
	}
	// 830FD9C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FD9CC: 4BFD1245  bl 0x830cec10
	ctx.lr = 0x830FD9D0;
	sub_830CEC10(ctx, base);
	// 830FD9D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830FD9D4: 48000118  b 0x830fdaec
	pc = 0x830FDAEC; continue 'dispatch;
	// 830FD9D8: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FD9DC: 0CDE0000  twi 6, r30, 0
	// 830FD9E0: 813F00F0  lwz r9, 0xf0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FD9E4: 7D0BF3D6  divw r8, r11, r30
	ctx.r[8].s32 = ctx.r[11].s32 / ctx.r[30].s32;
	// 830FD9E8: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 830FD9EC: 7D08F1D6  mullw r8, r8, r30
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830FD9F0: 7FA85850  subf r29, r8, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 830FD9F4: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 830FD9F8: 7D5DF050  subf r10, r29, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 830FD9FC: 7FC84078  andc r8, r30, r8
	ctx.r[8].u64 = ctx.r[30].u64 & !ctx.r[8].u64;
	// 830FDA00: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FDA04: 0CA8FFFF  twi 5, r8, -1
	// 830FDA08: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FDA0C: 40980034  bge cr6, 0x830fda40
	if !ctx.cr[6].lt {
	pc = 0x830FDA40; continue 'dispatch;
	}
	// 830FDA10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDA14: 4BFD11FD  bl 0x830cec10
	ctx.lr = 0x830FDA18;
	sub_830CEC10(ctx, base);
	// 830FDA18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830FDA1C: 4BFE9FA5  bl 0x830e79c0
	ctx.lr = 0x830FDA20;
	sub_830E79C0(ctx, base);
	// 830FDA20: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 830FDA24: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FDA28: 409A0038  bne cr6, 0x830fda60
	if !ctx.cr[6].eq {
	pc = 0x830FDA60; continue 'dispatch;
	}
	// 830FDA2C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 830FDA30: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FDA34: 409A002C  bne cr6, 0x830fda60
	if !ctx.cr[6].eq {
	pc = 0x830FDA60; continue 'dispatch;
	}
	// 830FDA38: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830FDA3C: 4BFFFDF0  b 0x830fd82c
	pc = 0x830FD82C; continue 'dispatch;
	// 830FDA40: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830FDA44: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FDA48: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FDA4C: 409A00A4  bne cr6, 0x830fdaf0
	if !ctx.cr[6].eq {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FDA50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDA54: 4BFD11BD  bl 0x830cec10
	ctx.lr = 0x830FDA58;
	sub_830CEC10(ctx, base);
	// 830FDA58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FDA5C: 4BFEA785  bl 0x830e81e0
	ctx.lr = 0x830FDA60;
	sub_830E81E0(ctx, base);
	// 830FDA60: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 830FDA64: 4800008C  b 0x830fdaf0
	pc = 0x830FDAF0; continue 'dispatch;
	// 830FDA68: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830FDA6C: 409A0030  bne cr6, 0x830fda9c
	if !ctx.cr[6].eq {
	pc = 0x830FDA9C; continue 'dispatch;
	}
	// 830FDA70: 56EB083E  rotlwi r11, r23, 1
	ctx.r[11].u64 = ((ctx.r[23].u32).rotate_left(1)) as u64;
	// 830FDA74: 7D57F3D6  divw r10, r23, r30
	ctx.r[10].s32 = ctx.r[23].s32 / ctx.r[30].s32;
	// 830FDA78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830FDA7C: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830FDA80: 7FCB5878  andc r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 & !ctx.r[11].u64;
	// 830FDA84: 0CDE0000  twi 6, r30, 0
	// 830FDA88: 7D4AB851  subf. r10, r10, r23
	ctx.r[10].s64 = ctx.r[23].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FDA8C: 0CABFFFF  twi 5, r11, -1
	// 830FDA90: 41820060  beq 0x830fdaf0
	if ctx.cr[0].eq {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FDA94: 3BC9FFFF  addi r30, r9, -1
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	// 830FDA98: 48000048  b 0x830fdae0
	pc = 0x830FDAE0; continue 'dispatch;
	// 830FDA9C: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830FDAA0: 409A0050  bne cr6, 0x830fdaf0
	if !ctx.cr[6].eq {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FDAA4: 7D57F3D6  divw r10, r23, r30
	ctx.r[10].s32 = ctx.r[23].s32 / ctx.r[30].s32;
	// 830FDAA8: 56EB083E  rotlwi r11, r23, 1
	ctx.r[11].u64 = ((ctx.r[23].u32).rotate_left(1)) as u64;
	// 830FDAAC: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830FDAB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830FDAB4: 7D4AB850  subf r10, r10, r23
	ctx.r[10].s64 = ctx.r[23].s64 - ctx.r[10].s64;
	// 830FDAB8: 7FCB5878  andc r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 & !ctx.r[11].u64;
	// 830FDABC: 391EFFFF  addi r8, r30, -1
	ctx.r[8].s64 = ctx.r[30].s64 + -1;
	// 830FDAC0: 0CDE0000  twi 6, r30, 0
	// 830FDAC4: 0CABFFFF  twi 5, r11, -1
	// 830FDAC8: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830FDACC: 40980024  bge cr6, 0x830fdaf0
	if !ctx.cr[6].lt {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FDAD0: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830FDAD4: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FDAD8: 40980018  bge cr6, 0x830fdaf0
	if !ctx.cr[6].lt {
	pc = 0x830FDAF0; continue 'dispatch;
	}
	// 830FDADC: 3BC90001  addi r30, r9, 1
	ctx.r[30].s64 = ctx.r[9].s64 + 1;
	// 830FDAE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDAE4: 4BFD112D  bl 0x830cec10
	ctx.lr = 0x830FDAE8;
	sub_830CEC10(ctx, base);
	// 830FDAE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FDAEC: 4BFE9ED5  bl 0x830e79c0
	ctx.lr = 0x830FDAF0;
	sub_830E79C0(ctx, base);
	// 830FDAF0: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 830FDAF4: 7F0BB800  cmpw cr6, r11, r23
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[23].s32, &mut ctx.xer);
	// 830FDAF8: 409A000C  bne cr6, 0x830fdb04
	if !ctx.cr[6].eq {
	pc = 0x830FDB04; continue 'dispatch;
	}
	// 830FDAFC: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830FDB00: 419A005C  beq cr6, 0x830fdb5c
	if ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FDB04: 92960008  stw r20, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830FDB08: 9295000C  stw r20, 0xc(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), ctx.r[20].u32 ) };
	// 830FDB0C: 48000050  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FDB10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDB14: 91750004  stw r11, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FDB18: 48000044  b 0x830fdb5c
	pc = 0x830FDB5C; continue 'dispatch;
	// 830FDB1C: 83D60010  lwz r30, 0x10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FDB20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDB24: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FDB28: 419A000C  beq cr6, 0x830fdb34
	if ctx.cr[6].eq {
	pc = 0x830FDB34; continue 'dispatch;
	}
	// 830FDB2C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830FDB30: 409A002C  bne cr6, 0x830fdb5c
	if !ctx.cr[6].eq {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FDB34: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830FDB38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDB3C: 4BFE9E25  bl 0x830e7960
	ctx.lr = 0x830FDB40;
	sub_830E7960(ctx, base);
	// 830FDB40: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830FDB44: 41800018  blt 0x830fdb5c
	if ctx.cr[0].lt {
	pc = 0x830FDB5C; continue 'dispatch;
	}
	// 830FDB48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDB4C: 4BFEA695  bl 0x830e81e0
	ctx.lr = 0x830FDB50;
	sub_830E81E0(ctx, base);
	// 830FDB50: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 830FDB54: 929E000C  stw r20, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[20].u32 ) };
	// 830FDB58: 92960008  stw r20, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830FDB5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FDB60: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830FDB64: 480AA634  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FDB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FDB68 size=352
    let mut pc: u32 = 0x830FDB68;
    'dispatch: loop {
        match pc {
            0x830FDB68 => {
    //   block [0x830FDB68..0x830FDCC8)
	// 830FDB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FDB6C: 480AA5F1  bl 0x831a815c
	ctx.lr = 0x830FDB70;
	sub_831A8130(ctx, base);
	// 830FDB70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FDB74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FDB78: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830FDB7C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830FDB80: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830FDB84: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830FDB88: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FDB8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FDB90: 419A0128  beq cr6, 0x830fdcb8
	if ctx.cr[6].eq {
	pc = 0x830FDCB8; continue 'dispatch;
	}
	// 830FDB94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDB98: 4BFE3009  bl 0x830e0ba0
	ctx.lr = 0x830FDB9C;
	sub_830E0BA0(ctx, base);
	// 830FDB9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FDBA0: 41820118  beq 0x830fdcb8
	if ctx.cr[0].eq {
	pc = 0x830FDCB8; continue 'dispatch;
	}
	// 830FDBA4: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FDBAC: 409A000C  bne cr6, 0x830fdbb8
	if !ctx.cr[6].eq {
	pc = 0x830FDBB8; continue 'dispatch;
	}
	// 830FDBB0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FDBB4: 4800000C  b 0x830fdbc0
	pc = 0x830FDBC0; continue 'dispatch;
	// 830FDBB8: 480AB511  bl 0x831a90c8
	ctx.lr = 0x830FDBBC;
	sub_831A90C8(ctx, base);
	// 830FDBBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830FDBC0: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830FDBC4: 7FDCD214  add r30, r28, r26
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[26].u64;
	// 830FDBC8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FDBCC: 40990010  ble cr6, 0x830fdbdc
	if !ctx.cr[6].gt {
	pc = 0x830FDBDC; continue 'dispatch;
	}
	// 830FDBD0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830FDBD4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830FDBD8: 480000E8  b 0x830fdcc0
	pc = 0x830FDCC0; continue 'dispatch;
	// 830FDBDC: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830FDBE0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830FDBE4: 4199003C  bgt cr6, 0x830fdc20
	if ctx.cr[6].gt {
	pc = 0x830FDC20; continue 'dispatch;
	}
	// 830FDBE8: 3BBE0032  addi r29, r30, 0x32
	ctx.r[29].s64 = ctx.r[30].s64 + 50;
	// 830FDBEC: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDBF0: 57A4103A  slwi r4, r29, 2
	ctx.r[4].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830FDBF4: 4BFDF8FD  bl 0x830dd4f0
	ctx.lr = 0x830FDBF8;
	sub_830DD4F0(ctx, base);
	// 830FDBF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FDBFC: 40820010  bne 0x830fdc0c
	if !ctx.cr[0].eq {
	pc = 0x830FDC0C; continue 'dispatch;
	}
	// 830FDC00: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830FDC04: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830FDC08: 480000B8  b 0x830fdcc0
	pc = 0x830FDCC0; continue 'dispatch;
	// 830FDC0C: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FDC10: 907F005C  stw r3, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 830FDC14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830FDC18: 93BF008C  stw r29, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 830FDC1C: 7D4B1B2E  sthx r10, r11, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u16) };
	// 830FDC20: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830FDC24: 40990030  ble cr6, 0x830fdc54
	if !ctx.cr[6].gt {
	pc = 0x830FDC54; continue 'dispatch;
	}
	// 830FDC28: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 830FDC2C: 57C9083C  slwi r9, r30, 1
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830FDC30: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830FDC34: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 830FDC38: 811F005C  lwz r8, 0x5c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDC3C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FDC40: 7CEA422E  lhzx r7, r10, r8
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830FDC44: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 830FDC48: 7CE9432E  sthx r7, r9, r8
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u16) };
	// 830FDC4C: 3929FFFE  addi r9, r9, -2
	ctx.r[9].s64 = ctx.r[9].s64 + -2;
	// 830FDC50: 4082FFE8  bne 0x830fdc38
	if !ctx.cr[0].eq {
	pc = 0x830FDC38; continue 'dispatch;
	}
	// 830FDC54: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830FDC58: 419A002C  beq cr6, 0x830fdc84
	if ctx.cr[6].eq {
	pc = 0x830FDC84; continue 'dispatch;
	}
	// 830FDC5C: 5769083C  slwi r9, r27, 1
	ctx.r[9].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830FDC60: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 830FDC64: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830FDC68: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDC6C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FDC70: 80FF005C  lwz r7, 0x5c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDC74: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830FDC78: 7D093B2E  sthx r8, r9, r7
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u16) };
	// 830FDC7C: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 830FDC80: 4082FFE8  bne 0x830fdc68
	if !ctx.cr[0].eq {
	pc = 0x830FDC68; continue 'dispatch;
	}
	// 830FDC84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDC88: 4BFE8589  bl 0x830e6210
	ctx.lr = 0x830FDC8C;
	sub_830E6210(ctx, base);
	// 830FDC8C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FDC90: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FDC94: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FDC98: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FDC9C: 41990010  bgt cr6, 0x830fdcac
	if ctx.cr[6].gt {
	pc = 0x830FDCAC; continue 'dispatch;
	}
	// 830FDCA0: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830FDCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDCA8: 4BFFBBC1  bl 0x830f9868
	ctx.lr = 0x830FDCAC;
	sub_830F9868(ctx, base);
	// 830FDCAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDCB0: 4BFF67E9  bl 0x830f4498
	ctx.lr = 0x830FDCB4;
	sub_830F4498(ctx, base);
	// 830FDCB4: 4800000C  b 0x830fdcc0
	pc = 0x830FDCC0; continue 'dispatch;
	// 830FDCB8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830FDCBC: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830FDCC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830FDCC4: 480AA4E8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FDCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FDCC8 size=208
    let mut pc: u32 = 0x830FDCC8;
    'dispatch: loop {
        match pc {
            0x830FDCC8 => {
    //   block [0x830FDCC8..0x830FDD98)
	// 830FDCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FDCCC: 480AA4A1  bl 0x831a816c
	ctx.lr = 0x830FDCD0;
	sub_831A8130(ctx, base);
	// 830FDCD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FDCD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FDCD8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830FDCDC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830FDCE0: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830FDCE4: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FDCE8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830FDCEC: 419A00A0  beq cr6, 0x830fdd8c
	if ctx.cr[6].eq {
	pc = 0x830FDD8C; continue 'dispatch;
	}
	// 830FDCF0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDCF4: 4BFE2EAD  bl 0x830e0ba0
	ctx.lr = 0x830FDCF8;
	sub_830E0BA0(ctx, base);
	// 830FDCF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FDCFC: 41820090  beq 0x830fdd8c
	if ctx.cr[0].eq {
	pc = 0x830FDD8C; continue 'dispatch;
	}
	// 830FDD00: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDD04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FDD08: 419A0008  beq cr6, 0x830fdd10
	if ctx.cr[6].eq {
	pc = 0x830FDD10; continue 'dispatch;
	}
	// 830FDD0C: 480AB3BD  bl 0x831a90c8
	ctx.lr = 0x830FDD10;
	sub_831A90C8(ctx, base);
	// 830FDD10: 7D7DF214  add r11, r29, r30
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 830FDD14: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830FDD18: 40990010  ble cr6, 0x830fdd28
	if !ctx.cr[6].gt {
	pc = 0x830FDD28; continue 'dispatch;
	}
	// 830FDD1C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830FDD20: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830FDD24: 4800006C  b 0x830fdd90
	pc = 0x830FDD90; continue 'dispatch;
	// 830FDD28: 7D3E5850  subf r9, r30, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830FDD2C: 7D0B1850  subf r8, r11, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830FDD30: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830FDD34: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830FDD38: 39680001  addi r11, r8, 1
	ctx.r[11].s64 = ctx.r[8].s64 + 1;
	// 830FDD3C: 811F005C  lwz r8, 0x5c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDD40: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FDD44: 7CEA422E  lhzx r7, r10, r8
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830FDD48: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830FDD4C: 7CE9432E  sthx r7, r9, r8
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u16) };
	// 830FDD50: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 830FDD54: 4082FFE8  bne 0x830fdd3c
	if !ctx.cr[0].eq {
	pc = 0x830FDD3C; continue 'dispatch;
	}
	// 830FDD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDD5C: 4BFE84B5  bl 0x830e6210
	ctx.lr = 0x830FDD60;
	sub_830E6210(ctx, base);
	// 830FDD60: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FDD64: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FDD68: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FDD6C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830FDD70: 40990010  ble cr6, 0x830fdd80
	if !ctx.cr[6].gt {
	pc = 0x830FDD80; continue 'dispatch;
	}
	// 830FDD74: 7C9E5850  subf r4, r30, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830FDD78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDD7C: 4BFFBAED  bl 0x830f9868
	ctx.lr = 0x830FDD80;
	sub_830F9868(ctx, base);
	// 830FDD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDD84: 4BFF6715  bl 0x830f4498
	ctx.lr = 0x830FDD88;
	sub_830F4498(ctx, base);
	// 830FDD88: 48000008  b 0x830fdd90
	pc = 0x830FDD90; continue 'dispatch;
	// 830FDD8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FDD90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FDD94: 480AA428  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FDD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FDD98 size=108
    let mut pc: u32 = 0x830FDD98;
    'dispatch: loop {
        match pc {
            0x830FDD98 => {
    //   block [0x830FDD98..0x830FDE04)
	// 830FDD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FDD9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FDDA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FDDA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FDDA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FDDAC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FDDB0: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FDDB4: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FDDB8: 41820034  beq 0x830fddec
	if ctx.cr[0].eq {
	pc = 0x830FDDEC; continue 'dispatch;
	}
	// 830FDDBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDDC0: 4BFE2DE1  bl 0x830e0ba0
	ctx.lr = 0x830FDDC4;
	sub_830E0BA0(ctx, base);
	// 830FDDC4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FDDC8: 41820024  beq 0x830fddec
	if ctx.cr[0].eq {
	pc = 0x830FDDEC; continue 'dispatch;
	}
	// 830FDDCC: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FDDD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830FDDD4: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FDDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDDDC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FDDE0: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 830FDDE4: 4BFFFEE5  bl 0x830fdcc8
	ctx.lr = 0x830FDDE8;
	sub_830FDCC8(ctx, base);
	// 830FDDE8: 48000008  b 0x830fddf0
	pc = 0x830FDDF0; continue 'dispatch;
	// 830FDDEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FDDF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830FDDF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FDDF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FDDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FDE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FDE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FDE08 size=88
    let mut pc: u32 = 0x830FDE08;
    'dispatch: loop {
        match pc {
            0x830FDE08 => {
    //   block [0x830FDE08..0x830FDE60)
	// 830FDE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FDE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FDE10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FDE14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FDE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FDE1C: B081007E  sth r4, 0x7e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(126 as u32), ctx.r[4].u16 ) };
	// 830FDE20: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDE24: 4BFE2D7D  bl 0x830e0ba0
	ctx.lr = 0x830FDE28;
	sub_830E0BA0(ctx, base);
	// 830FDE28: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FDE2C: 41820020  beq 0x830fde4c
	if ctx.cr[0].eq {
	pc = 0x830FDE4C; continue 'dispatch;
	}
	// 830FDE30: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FDE34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830FDE38: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FDE3C: 38A1007E  addi r5, r1, 0x7e
	ctx.r[5].s64 = ctx.r[1].s64 + 126;
	// 830FDE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FDE44: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FDE48: 4BFFFD21  bl 0x830fdb68
	ctx.lr = 0x830FDE4C;
	sub_830FDB68(ctx, base);
	// 830FDE4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830FDE50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FDE54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FDE58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FDE5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FDE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FDE60 size=2236
    let mut pc: u32 = 0x830FDE60;
    'dispatch: loop {
        match pc {
            0x830FDE60 => {
    //   block [0x830FDE60..0x830FE71C)
	// 830FDE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FDE64: 480AA309  bl 0x831a816c
	ctx.lr = 0x830FDE68;
	sub_831A8130(ctx, base);
	// 830FDE68: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FDE6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830FDE70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FDE74: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FDE78: 2B0B07DF  cmplwi cr6, r11, 0x7df
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2015 as u32, &mut ctx.xer);
	// 830FDE7C: 41990530  bgt cr6, 0x830fe3ac
	if ctx.cr[6].gt {
	pc = 0x830FE3AC; continue 'dispatch;
	}
	// 830FDE80: 419A049C  beq cr6, 0x830fe31c
	if ctx.cr[6].eq {
	pc = 0x830FE31C; continue 'dispatch;
	}
	// 830FDE84: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 830FDE88: 41990384  bgt cr6, 0x830fe20c
	if ctx.cr[6].gt {
	pc = 0x830FE20C; continue 'dispatch;
	}
	// 830FDE8C: 419A02FC  beq cr6, 0x830fe188
	if ctx.cr[6].eq {
	pc = 0x830FE188; continue 'dispatch;
	}
	// 830FDE90: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830FDE94: 419A02C0  beq cr6, 0x830fe154
	if ctx.cr[6].eq {
	pc = 0x830FE154; continue 'dispatch;
	}
	// 830FDE98: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830FDE9C: 419A0234  beq cr6, 0x830fe0d0
	if ctx.cr[6].eq {
	pc = 0x830FE0D0; continue 'dispatch;
	}
	// 830FDEA0: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 830FDEA4: 419A01B8  beq cr6, 0x830fe05c
	if ctx.cr[6].eq {
	pc = 0x830FE05C; continue 'dispatch;
	}
	// 830FDEA8: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830FDEAC: 419A00F0  beq cr6, 0x830fdf9c
	if ctx.cr[6].eq {
	pc = 0x830FDF9C; continue 'dispatch;
	}
	// 830FDEB0: 2B0B0025  cmplwi cr6, r11, 0x25
	ctx.cr[6].compare_u32(ctx.r[11].u32, 37 as u32, &mut ctx.xer);
	// 830FDEB4: 409A0850  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FDEB8: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FDEBC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FDEC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FDEC4: 4082018C  bne 0x830fe050
	if !ctx.cr[0].eq {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FDEC8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FDED0: 419A0834  beq cr6, 0x830fe704
	if ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FDED4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FDED8: 4BFE0E09  bl 0x830dece0
	ctx.lr = 0x830FDEDC;
	sub_830DECE0(ctx, base);
	// 830FDEDC: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830FDEE0: 419A006C  beq cr6, 0x830fdf4c
	if ctx.cr[6].eq {
	pc = 0x830FDF4C; continue 'dispatch;
	}
	// 830FDEE4: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830FDEE8: 409A081C  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FDEEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FDEF0: C1BF00A8  lfs f13, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FDEF4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FDEF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830FDEFC: 40990154  ble cr6, 0x830fe050
	if !ctx.cr[6].gt {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FDF00: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FDF04: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FDF08: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FDF0C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FDF10: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FDF14: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 830FDF18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830FDF1C: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FDF20: 0CCA0000  twi 6, r10, 0
	// 830FDF24: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830FDF28: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830FDF2C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830FDF30: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FDF34: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830FDF38: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830FDF3C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830FDF40: 41980054  blt cr6, 0x830fdf94
	if ctx.cr[6].lt {
	pc = 0x830FDF94; continue 'dispatch;
	}
	// 830FDF44: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830FDF48: 4800004C  b 0x830fdf94
	pc = 0x830FDF94; continue 'dispatch;
	// 830FDF4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FDF50: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FDF54: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FDF58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830FDF5C: 409800F4  bge cr6, 0x830fe050
	if !ctx.cr[6].lt {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FDF60: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FDF64: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FDF68: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FDF6C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FDF70: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FDF74: 7D4A5B96  divwu r10, r10, r11
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 830FDF78: 0CCB0000  twi 6, r11, 0
	// 830FDF7C: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830FDF80: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830FDF84: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830FDF88: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FDF8C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830FDF90: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830FDF94: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830FDF98: 480000B8  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FDF9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FDFA0: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FDFA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDFA8: 4BFD0571  bl 0x830ce518
	ctx.lr = 0x830FDFAC;
	sub_830CE518(ctx, base);
	// 830FDFAC: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FDFB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FDFB4: 4082009C  bne 0x830fe050
	if !ctx.cr[0].eq {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FDFB8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FDFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FDFC0: 419A0744  beq cr6, 0x830fe704
	if ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FDFC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FDFC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FDFCC: 4BFE0D15  bl 0x830dece0
	ctx.lr = 0x830FDFD0;
	sub_830DECE0(ctx, base);
	// 830FDFD0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830FDFD4: 419A0068  beq cr6, 0x830fe03c
	if ctx.cr[6].eq {
	pc = 0x830FE03C; continue 'dispatch;
	}
	// 830FDFD8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830FDFDC: 419A0050  beq cr6, 0x830fe02c
	if ctx.cr[6].eq {
	pc = 0x830FE02C; continue 'dispatch;
	}
	// 830FDFE0: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830FDFE4: 419A0038  beq cr6, 0x830fe01c
	if ctx.cr[6].eq {
	pc = 0x830FE01C; continue 'dispatch;
	}
	// 830FDFE8: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830FDFEC: 419A0020  beq cr6, 0x830fe00c
	if ctx.cr[6].eq {
	pc = 0x830FE00C; continue 'dispatch;
	}
	// 830FDFF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FDFF4: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830FDFF8: 409A070C  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FDFFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FE000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE004: 4BFFA575  bl 0x830f8578
	ctx.lr = 0x830FE008;
	sub_830F8578(ctx, base);
	// 830FE008: 48000048  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE00C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FE010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE014: 4BFFA155  bl 0x830f8168
	ctx.lr = 0x830FE018;
	sub_830F8168(ctx, base);
	// 830FE018: 48000030  b 0x830fe048
	pc = 0x830FE048; continue 'dispatch;
	// 830FE01C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FE020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE024: 4BFF9F65  bl 0x830f7f88
	ctx.lr = 0x830FE028;
	sub_830F7F88(ctx, base);
	// 830FE028: 48000020  b 0x830fe048
	pc = 0x830FE048; continue 'dispatch;
	// 830FE02C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FE030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE034: 4BFFA3F5  bl 0x830f8428
	ctx.lr = 0x830FE038;
	sub_830F8428(ctx, base);
	// 830FE038: 48000010  b 0x830fe048
	pc = 0x830FE048; continue 'dispatch;
	// 830FE03C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830FE040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE044: 4BFFA305  bl 0x830f8348
	ctx.lr = 0x830FE048;
	sub_830F8348(ctx, base);
	// 830FE048: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FE04C: 418006B8  blt 0x830fe704
	if ctx.cr[0].lt {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE050: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE054: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE058: 480006AC  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE05C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FE060: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE064: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FE068: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830FE06C: 4BFE34ED  bl 0x830e1558
	ctx.lr = 0x830FE070;
	sub_830E1558(ctx, base);
	// 830FE070: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FE074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FE078: 409A0044  bne cr6, 0x830fe0bc
	if !ctx.cr[6].eq {
	pc = 0x830FE0BC; continue 'dispatch;
	}
	// 830FE07C: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 830FE080: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FE084: 48003F6D  bl 0x83101ff0
	ctx.lr = 0x830FE088;
	sub_83101FF0(ctx, base);
	// 830FE088: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE08C: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 830FE090: 4BFD0B81  bl 0x830cec10
	ctx.lr = 0x830FE094;
	sub_830CEC10(ctx, base);
	// 830FE094: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE098: 4BFD7B31  bl 0x830d5bc8
	ctx.lr = 0x830FE09C;
	sub_830D5BC8(ctx, base);
	// 830FE09C: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 830FE0A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FE0A4: 48003F4D  bl 0x83101ff0
	ctx.lr = 0x830FE0A8;
	sub_83101FF0(ctx, base);
	// 830FE0A8: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE0AC: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 830FE0B0: 4BFD0B61  bl 0x830cec10
	ctx.lr = 0x830FE0B4;
	sub_830CEC10(ctx, base);
	// 830FE0B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE0B8: 4BFD7B11  bl 0x830d5bc8
	ctx.lr = 0x830FE0BC;
	sub_830D5BC8(ctx, base);
	// 830FE0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE0C0: 4BFEFE19  bl 0x830eded8
	ctx.lr = 0x830FE0C4;
	sub_830EDED8(ctx, base);
	// 830FE0C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE0C8: 4BFF66F1  bl 0x830f47b8
	ctx.lr = 0x830FE0CC;
	sub_830F47B8(ctx, base);
	// 830FE0CC: 48000638  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE0D0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE0D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE0D8: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 830FE0DC: 409A0628  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE0E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FE0E4: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 830FE0E8: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FE0EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE0F0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE0F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FE0F8: 409A000C  bne cr6, 0x830fe104
	if !ctx.cr[6].eq {
	pc = 0x830FE104; continue 'dispatch;
	}
	// 830FE0FC: 995F0010  stb r10, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 830FE100: 48000048  b 0x830fe148
	pc = 0x830FE148; continue 'dispatch;
	// 830FE104: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FE108: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 830FE10C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FE110: 409A000C  bne cr6, 0x830fe11c
	if !ctx.cr[6].eq {
	pc = 0x830FE11C; continue 'dispatch;
	}
	// 830FE114: 995F0020  stb r10, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 830FE118: 48000030  b 0x830fe148
	pc = 0x830FE148; continue 'dispatch;
	// 830FE11C: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FE120: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 830FE124: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FE128: 409A000C  bne cr6, 0x830fe134
	if !ctx.cr[6].eq {
	pc = 0x830FE134; continue 'dispatch;
	}
	// 830FE12C: 995F0030  stb r10, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 830FE130: 48000018  b 0x830fe148
	pc = 0x830FE148; continue 'dispatch;
	// 830FE134: 813F0034  lwz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FE138: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830FE13C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FE140: 409A05C4  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE144: 995F0040  stb r10, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u8 ) };
	// 830FE148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE14C: 4BFEFC5D  bl 0x830edda8
	ctx.lr = 0x830FE150;
	sub_830EDDA8(ctx, base);
	// 830FE150: 480005B4  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE154: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FE158: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE15C: 4BFD03BD  bl 0x830ce518
	ctx.lr = 0x830FE160;
	sub_830CE518(ctx, base);
	// 830FE160: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE164: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FE168: 4BFD7A61  bl 0x830d5bc8
	ctx.lr = 0x830FE16C;
	sub_830D5BC8(ctx, base);
	// 830FE16C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE170: 4BFEFD69  bl 0x830eded8
	ctx.lr = 0x830FE174;
	sub_830EDED8(ctx, base);
	// 830FE174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE178: 4BFF6641  bl 0x830f47b8
	ctx.lr = 0x830FE17C;
	sub_830F47B8(ctx, base);
	// 830FE17C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE180: 4BFF6319  bl 0x830f4498
	ctx.lr = 0x830FE184;
	sub_830F4498(ctx, base);
	// 830FE184: 4BFFFECC  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE188: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE18C: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE190: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830FE194: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 830FE198: 419A0068  beq cr6, 0x830fe200
	if ctx.cr[6].eq {
	pc = 0x830FE200; continue 'dispatch;
	}
	// 830FE19C: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830FE1A0: 419AFEB0  beq cr6, 0x830fe050
	if ctx.cr[6].eq {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FE1A4: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830FE1A8: 419AFEA8  beq cr6, 0x830fe050
	if ctx.cr[6].eq {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FE1AC: 2F0B001B  cmpwi cr6, r11, 0x1b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 27, &mut ctx.xer);
	// 830FE1B0: 419AFEA0  beq cr6, 0x830fe050
	if ctx.cr[6].eq {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FE1B4: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830FE1B8: 4198FE98  blt cr6, 0x830fe050
	if ctx.cr[6].lt {
	pc = 0x830FE050; continue 'dispatch;
	}
	// 830FE1BC: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 830FE1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FE1C4: 419A0030  beq cr6, 0x830fe1f4
	if ctx.cr[6].eq {
	pc = 0x830FE1F4; continue 'dispatch;
	}
	// 830FE1C8: 548A043E  clrlwi r10, r4, 0x10
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 830FE1CC: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE1D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FE1D4: 41980010  blt cr6, 0x830fe1e4
	if ctx.cr[6].lt {
	pc = 0x830FE1E4; continue 'dispatch;
	}
	// 830FE1D8: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830FE1DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FE1E0: 40990014  ble cr6, 0x830fe1f4
	if !ctx.cr[6].gt {
	pc = 0x830FE1F4; continue 'dispatch;
	}
	// 830FE1E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FE1EC: 409AFFE0  bne cr6, 0x830fe1cc
	if !ctx.cr[6].eq {
	pc = 0x830FE1CC; continue 'dispatch;
	}
	// 830FE1F0: 4BFFFE60  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE1F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE1F8: 4BFFFC11  bl 0x830fde08
	ctx.lr = 0x830FE1FC;
	sub_830FDE08(ctx, base);
	// 830FE1FC: 4BFFFE54  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE204: 4BFFFB95  bl 0x830fdd98
	ctx.lr = 0x830FE208;
	sub_830FDD98(ctx, base);
	// 830FE208: 4BFFFE48  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE20C: 2B0B0027  cmplwi cr6, r11, 0x27
	ctx.cr[6].compare_u32(ctx.r[11].u32, 39 as u32, &mut ctx.xer);
	// 830FE210: 419A00E8  beq cr6, 0x830fe2f8
	if ctx.cr[6].eq {
	pc = 0x830FE2F8; continue 'dispatch;
	}
	// 830FE214: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 830FE218: 419A0098  beq cr6, 0x830fe2b0
	if ctx.cr[6].eq {
	pc = 0x830FE2B0; continue 'dispatch;
	}
	// 830FE21C: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830FE220: 419A005C  beq cr6, 0x830fe27c
	if ctx.cr[6].eq {
	pc = 0x830FE27C; continue 'dispatch;
	}
	// 830FE224: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 830FE228: 419A0034  beq cr6, 0x830fe25c
	if ctx.cr[6].eq {
	pc = 0x830FE25C; continue 'dispatch;
	}
	// 830FE22C: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830FE230: 409A04D4  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE234: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FE238: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE23C: 4BFD02DD  bl 0x830ce518
	ctx.lr = 0x830FE240;
	sub_830CE518(ctx, base);
	// 830FE240: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE244: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FE248: 4BFD7981  bl 0x830d5bc8
	ctx.lr = 0x830FE24C;
	sub_830D5BC8(ctx, base);
	// 830FE24C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE250: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE254: 4BFD7975  bl 0x830d5bc8
	ctx.lr = 0x830FE258;
	sub_830D5BC8(ctx, base);
	// 830FE258: 4BFFFDF8  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE25C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE260: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE268: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE26C: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE270: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE274: 4BFFFA55  bl 0x830fdcc8
	ctx.lr = 0x830FE278;
	sub_830FDCC8(ctx, base);
	// 830FE278: 4800049C  b 0x830fe714
	pc = 0x830FE714; continue 'dispatch;
	// 830FE27C: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE280: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE284: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE288: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE28C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FE290: 419A047C  beq cr6, 0x830fe70c
	if ctx.cr[6].eq {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE294: 480AAE35  bl 0x831a90c8
	ctx.lr = 0x830FE298;
	sub_831A90C8(ctx, base);
	// 830FE298: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830FE29C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE2A0: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE2A4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE2A8: 4BFFF8C1  bl 0x830fdb68
	ctx.lr = 0x830FE2AC;
	sub_830FDB68(ctx, base);
	// 830FE2AC: 48000468  b 0x830fe714
	pc = 0x830FE714; continue 'dispatch;
	// 830FE2B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FE2B4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE2B8: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FE2BC: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830FE2C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE2C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830FE2C8: 40980444  bge cr6, 0x830fe70c
	if !ctx.cr[6].lt {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE2CC: 813F0094  lwz r9, 0x94(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830FE2D0: 552907BC  rlwinm r9, r9, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 830FE2D4: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 830FE2D8: 409A0014  bne cr6, 0x830fe2ec
	if !ctx.cr[6].eq {
	pc = 0x830FE2EC; continue 'dispatch;
	}
	// 830FE2DC: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830FE2E0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830FE2E4: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FE2E8: 48000008  b 0x830fe2f0
	pc = 0x830FE2F0; continue 'dispatch;
	// 830FE2EC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FE2F0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830FE2F4: 48000410  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE2F8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE2FC: 3D40AABB  lis r10, -0x5545
	ctx.r[10].s64 = -1430585344;
	// 830FE300: 614ACCDD  ori r10, r10, 0xccdd
	ctx.r[10].u64 = ctx.r[10].u64 | 52445;
	// 830FE304: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE308: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830FE30C: 409A03F8  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE314: 4BFF67DD  bl 0x830f4af0
	ctx.lr = 0x830FE318;
	sub_830F4AF0(ctx, base);
	// 830FE318: 4BFFFD38  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE31C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE320: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FE324: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FE328: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830FE32C: 419A0078  beq cr6, 0x830fe3a4
	if ctx.cr[6].eq {
	pc = 0x830FE3A4; continue 'dispatch;
	}
	// 830FE330: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830FE334: 419A0010  beq cr6, 0x830fe344
	if ctx.cr[6].eq {
	pc = 0x830FE344; continue 'dispatch;
	}
	// 830FE338: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830FE33C: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830FE340: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830FE344: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830FE348: C01F009C  lfs f0, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE34C: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FE350: 813F0070  lwz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 830FE354: 7D4A49D6  mullw r10, r10, r9
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830FE358: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 830FE35C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830FE360: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FE364: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830FE368: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830FE36C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830FE370: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830FE374: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830FE378: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 830FE37C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830FE380: 419A0010  beq cr6, 0x830fe390
	if ctx.cr[6].eq {
	pc = 0x830FE390; continue 'dispatch;
	}
	// 830FE384: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FE388: 554A04A0  rlwinm r10, r10, 0, 0x12, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830FE38C: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830FE390: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FE394: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830FE398: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 830FE39C: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830FE3A0: 4BFFFCB0  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE3A4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830FE3A8: 4BFFFCA8  b 0x830fe050
	pc = 0x830FE050; continue 'dispatch;
	// 830FE3AC: 2B0B07EE  cmplwi cr6, r11, 0x7ee
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2030 as u32, &mut ctx.xer);
	// 830FE3B0: 41990194  bgt cr6, 0x830fe544
	if ctx.cr[6].gt {
	pc = 0x830FE544; continue 'dispatch;
	}
	// 830FE3B4: 419A0170  beq cr6, 0x830fe524
	if ctx.cr[6].eq {
	pc = 0x830FE524; continue 'dispatch;
	}
	// 830FE3B8: 2B0B07E0  cmplwi cr6, r11, 0x7e0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2016 as u32, &mut ctx.xer);
	// 830FE3BC: 419A0154  beq cr6, 0x830fe510
	if ctx.cr[6].eq {
	pc = 0x830FE510; continue 'dispatch;
	}
	// 830FE3C0: 2B0B07E6  cmplwi cr6, r11, 0x7e6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2022 as u32, &mut ctx.xer);
	// 830FE3C4: 419A00A8  beq cr6, 0x830fe46c
	if ctx.cr[6].eq {
	pc = 0x830FE46C; continue 'dispatch;
	}
	// 830FE3C8: 2B0B07EA  cmplwi cr6, r11, 0x7ea
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2026 as u32, &mut ctx.xer);
	// 830FE3CC: 419A0080  beq cr6, 0x830fe44c
	if ctx.cr[6].eq {
	pc = 0x830FE44C; continue 'dispatch;
	}
	// 830FE3D0: 2B0B07EB  cmplwi cr6, r11, 0x7eb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2027 as u32, &mut ctx.xer);
	// 830FE3D4: 419A005C  beq cr6, 0x830fe430
	if ctx.cr[6].eq {
	pc = 0x830FE430; continue 'dispatch;
	}
	// 830FE3D8: 2B0B07ED  cmplwi cr6, r11, 0x7ed
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2029 as u32, &mut ctx.xer);
	// 830FE3DC: 409A0328  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE3E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE3E4: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE3E8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE3EC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE3F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FE3F4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FE3F8: 0CCB0000  twi 6, r11, 0
	// 830FE3FC: 419A0018  beq cr6, 0x830fe414
	if ctx.cr[6].eq {
	pc = 0x830FE414; continue 'dispatch;
	}
	// 830FE400: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE404: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE408: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FE40C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE410: 48000014  b 0x830fe424
	pc = 0x830FE424; continue 'dispatch;
	// 830FE414: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE418: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE41C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FE420: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE424: 7D695B96  divwu r11, r9, r11
	ctx.r[11].u32 = ctx.r[9].u32 / ctx.r[11].u32;
	// 830FE428: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830FE42C: 480002D8  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE430: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE434: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE43C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE440: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE444: 4BFFB425  bl 0x830f9868
	ctx.lr = 0x830FE448;
	sub_830F9868(ctx, base);
	// 830FE448: 480002CC  b 0x830fe714
	pc = 0x830FE714; continue 'dispatch;
	// 830FE44C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE450: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE454: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE458: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FE45C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 830FE460: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FE464: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830FE468: 4800029C  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE46C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FE470: C01F00A8  lfs f0, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE474: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FE478: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830FE47C: 4098003C  bge cr6, 0x830fe4b8
	if !ctx.cr[6].lt {
	pc = 0x830FE4B8; continue 'dispatch;
	}
	// 830FE480: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE484: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FE488: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE48C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FE490: 0CCB0000  twi 6, r11, 0
	// 830FE494: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE498: 7D4A5B96  divwu r10, r10, r11
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 830FE49C: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 830FE4A0: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830FE4A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830FE4A8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FE4AC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830FE4B0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830FE4B4: 48000054  b 0x830fe508
	pc = 0x830FE508; continue 'dispatch;
	// 830FE4B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830FE4BC: 40990248  ble cr6, 0x830fe704
	if !ctx.cr[6].gt {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE4C0: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE4C4: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FE4C8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE4CC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FE4D0: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE4D4: 0CCA0000  twi 6, r10, 0
	// 830FE4D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE4DC: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 830FE4E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830FE4E4: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830FE4E8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830FE4EC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830FE4F0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FE4F4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830FE4F8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830FE4FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830FE500: 41980008  blt cr6, 0x830fe508
	if ctx.cr[6].lt {
	pc = 0x830FE508; continue 'dispatch;
	}
	// 830FE504: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830FE508: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830FE50C: 480001F8  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE510: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE518: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FE51C: 4BFFA05D  bl 0x830f8578
	ctx.lr = 0x830FE520;
	sub_830F8578(ctx, base);
	// 830FE520: 4BFFFB28  b 0x830fe048
	pc = 0x830FE048; continue 'dispatch;
	// 830FE524: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE528: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE530: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE534: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE538: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE53C: 4BFF987D  bl 0x830f7db8
	ctx.lr = 0x830FE540;
	sub_830F7DB8(ctx, base);
	// 830FE540: 480001D4  b 0x830fe714
	pc = 0x830FE714; continue 'dispatch;
	// 830FE544: 2B0B07EF  cmplwi cr6, r11, 0x7ef
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2031 as u32, &mut ctx.xer);
	// 830FE548: 419A00E4  beq cr6, 0x830fe62c
	if ctx.cr[6].eq {
	pc = 0x830FE62C; continue 'dispatch;
	}
	// 830FE54C: 2B0B07F2  cmplwi cr6, r11, 0x7f2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2034 as u32, &mut ctx.xer);
	// 830FE550: 419A0094  beq cr6, 0x830fe5e4
	if ctx.cr[6].eq {
	pc = 0x830FE5E4; continue 'dispatch;
	}
	// 830FE554: 2B0B07F3  cmplwi cr6, r11, 0x7f3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2035 as u32, &mut ctx.xer);
	// 830FE558: 419A0020  beq cr6, 0x830fe578
	if ctx.cr[6].eq {
	pc = 0x830FE578; continue 'dispatch;
	}
	// 830FE55C: 2B0B080D  cmplwi cr6, r11, 0x80d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2061 as u32, &mut ctx.xer);
	// 830FE560: 409A01A4  bne cr6, 0x830fe704
	if !ctx.cr[6].eq {
	pc = 0x830FE704; continue 'dispatch;
	}
	// 830FE564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE568: 4BFF6251  bl 0x830f47b8
	ctx.lr = 0x830FE56C;
	sub_830F47B8(ctx, base);
	// 830FE56C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE570: 4BFF5F29  bl 0x830f4498
	ctx.lr = 0x830FE574;
	sub_830F4498(ctx, base);
	// 830FE574: 48000190  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE57C: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE580: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE584: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE588: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FE58C: 409A0180  bne cr6, 0x830fe70c
	if !ctx.cr[6].eq {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE590: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FE594: C1BD0010  lfs f13, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FE598: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE59C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830FE5A0: 4099016C  ble cr6, 0x830fe70c
	if !ctx.cr[6].gt {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE5A4: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FE5A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830FE5AC: 40990160  ble cr6, 0x830fe70c
	if !ctx.cr[6].gt {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE5B0: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830FE5B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830FE5B8: 41980154  blt cr6, 0x830fe70c
	if ctx.cr[6].lt {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE5C0: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE5C4: 4BFF9595  bl 0x830f7b58
	ctx.lr = 0x830FE5C8;
	sub_830F7B58(ctx, base);
	// 830FE5C8: C01D0010  lfs f0, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE5CC: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830FE5D0: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE5D4: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830FE5D8: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE5DC: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830FE5E0: 48000124  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE5E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FE5E8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE5EC: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FE5F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE5F4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FE5F8: 409A0114  bne cr6, 0x830fe70c
	if !ctx.cr[6].eq {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE5FC: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830FE600: 554AF7FE  rlwinm r10, r10, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 830FE604: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830FE608: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE60C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830FE610: C01F00AC  lfs f0, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE614: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830FE618: C01F00B0  lfs f0, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE61C: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830FE620: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE624: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830FE628: 480000DC  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE62C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FE630: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FE634: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FE638: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE63C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FE640: 409A000C  bne cr6, 0x830fe64c
	if !ctx.cr[6].eq {
	pc = 0x830FE64C; continue 'dispatch;
	}
	// 830FE644: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830FE648: 48000084  b 0x830fe6cc
	pc = 0x830FE6CC; continue 'dispatch;
	// 830FE64C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FE650: 409A0084  bne cr6, 0x830fe6d4
	if !ctx.cr[6].eq {
	pc = 0x830FE6D4; continue 'dispatch;
	}
	// 830FE654: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FE658: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE65C: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FE660: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830FE664: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FE668: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 830FE66C: 0CCB0000  twi 6, r11, 0
	// 830FE670: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FE674: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830FE678: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830FE67C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FE680: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE684: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FE688: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE68C: 419A0018  beq cr6, 0x830fe6a4
	if ctx.cr[6].eq {
	pc = 0x830FE6A4; continue 'dispatch;
	}
	// 830FE690: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE694: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE698: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FE69C: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE6A0: 48000014  b 0x830fe6b4
	pc = 0x830FE6B4; continue 'dispatch;
	// 830FE6A4: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE6A8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE6AC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830FE6B0: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE6B4: 7D685B96  divwu r11, r8, r11
	ctx.r[11].u32 = ctx.r[8].u32 / ctx.r[11].u32;
	// 830FE6B8: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830FE6BC: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 830FE6C0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FE6C4: 40980008  bge cr6, 0x830fe6cc
	if !ctx.cr[6].lt {
	pc = 0x830FE6CC; continue 'dispatch;
	}
	// 830FE6C8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830FE6CC: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FE6D0: 48000034  b 0x830fe704
	pc = 0x830FE704; continue 'dispatch;
	// 830FE6D4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FE6D8: 409A0034  bne cr6, 0x830fe70c
	if !ctx.cr[6].eq {
	pc = 0x830FE70C; continue 'dispatch;
	}
	// 830FE6DC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830FE6E0: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FE6E4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830FE6E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830FE6EC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FE6F0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830FE6F4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830FE6F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830FE6FC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830FE700: 7C0957AE  stfiwx f0, r9, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 830FE704: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FE708: 4800000C  b 0x830fe714
	pc = 0x830FE714; continue 'dispatch;
	// 830FE70C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830FE710: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830FE714: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830FE718: 480A9AA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FE720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FE720 size=84
    let mut pc: u32 = 0x830FE720;
    'dispatch: loop {
        match pc {
            0x830FE720 => {
    //   block [0x830FE720..0x830FE774)
	// 830FE720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FE724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FE728: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FE72C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FE730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FE734: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830FE738: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830FE73C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830FE740: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830FE744: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FE748: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830FE74C: 4BFFB20D  bl 0x830f9958
	ctx.lr = 0x830FE750;
	sub_830F9958(ctx, base);
	// 830FE750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FE754: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FE758: 4BFDED81  bl 0x830dd4d8
	ctx.lr = 0x830FE75C;
	sub_830DD4D8(ctx, base);
	// 830FE75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FE760: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FE764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FE768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FE76C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FE770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FE778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FE778 size=184
    let mut pc: u32 = 0x830FE778;
    'dispatch: loop {
        match pc {
            0x830FE778 => {
    //   block [0x830FE778..0x830FE830)
	// 830FE778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FE77C: 480A99E9  bl 0x831a8164
	ctx.lr = 0x830FE780;
	sub_831A8130(ctx, base);
	// 830FE780: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FE784: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830FE788: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FE78C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FE790: 4BFDCE69  bl 0x830db5f8
	ctx.lr = 0x830FE794;
	sub_830DB5F8(ctx, base);
	// 830FE794: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830FE798: 419A0090  beq cr6, 0x830fe828
	if ctx.cr[6].eq {
	pc = 0x830FE828; continue 'dispatch;
	}
	// 830FE79C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FE7A0: 480AA929  bl 0x831a90c8
	ctx.lr = 0x830FE7A4;
	sub_831A90C8(ctx, base);
	// 830FE7A4: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 830FE7A8: 5563083C  slwi r3, r11, 1
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830FE7AC: 4BFDED05  bl 0x830dd4b0
	ctx.lr = 0x830FE7B0;
	sub_830DD4B0(ctx, base);
	// 830FE7B0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FE7B4: 41820074  beq 0x830fe828
	if ctx.cr[0].eq {
	pc = 0x830FE828; continue 'dispatch;
	}
	// 830FE7B8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830FE7BC: 3B8B9768  addi r28, r11, -0x6898
	ctx.r[28].s64 = ctx.r[11].s64 + -26776;
	// 830FE7C0: 4800004C  b 0x830fe80c
	pc = 0x830FE80C; continue 'dispatch;
	// 830FE7C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FE7C8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830FE7CC: 419A0024  beq cr6, 0x830fe7f0
	if ctx.cr[6].eq {
	pc = 0x830FE7F0; continue 'dispatch;
	}
	// 830FE7D0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 830FE7D4: A13E0000  lhz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE7D8: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 830FE7DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830FE7E0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830FE7E4: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 830FE7E8: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830FE7EC: 409AFFE8  bne cr6, 0x830fe7d4
	if !ctx.cr[6].eq {
	pc = 0x830FE7D4; continue 'dispatch;
	}
	// 830FE7F0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FE7F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830FE7F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830FE7FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FE800: 7D4BEB2E  sthx r10, r11, r29
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[10].u16) };
	// 830FE804: 4BFE6285  bl 0x830e4a88
	ctx.lr = 0x830FE808;
	sub_830E4A88(ctx, base);
	// 830FE808: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 830FE80C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830FE810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FE814: 480B389D  bl 0x831b20b0
	ctx.lr = 0x830FE818;
	sub_831B20B0(ctx, base);
	// 830FE818: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FE81C: 4082FFA8  bne 0x830fe7c4
	if !ctx.cr[0].eq {
	pc = 0x830FE7C4; continue 'dispatch;
	}
	// 830FE820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FE824: 4BFDECB5  bl 0x830dd4d8
	ctx.lr = 0x830FE828;
	sub_830DD4D8(ctx, base);
	// 830FE828: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830FE82C: 480A9988  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FE830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FE830 size=572
    let mut pc: u32 = 0x830FE830;
    'dispatch: loop {
        match pc {
            0x830FE830 => {
    //   block [0x830FE830..0x830FEA6C)
	// 830FE830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FE834: 480A9925  bl 0x831a8158
	ctx.lr = 0x830FE838;
	sub_831A8130(ctx, base);
	// 830FE838: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FE83C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830FE840: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830FE844: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 830FE848: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830FE84C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 830FE850: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830FE854: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FE858: 4BFFFF21  bl 0x830fe778
	ctx.lr = 0x830FE85C;
	sub_830FE778(ctx, base);
	// 830FE85C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 830FE860: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 830FE864: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FE868: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 830FE86C: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FE870: 4BFFFF09  bl 0x830fe778
	ctx.lr = 0x830FE874;
	sub_830FE778(ctx, base);
	// 830FE874: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830FE878: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830FE87C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FE880: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 830FE884: 807C000C  lwz r3, 0xc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FE888: 4BFFFEF1  bl 0x830fe778
	ctx.lr = 0x830FE88C;
	sub_830FE778(ctx, base);
	// 830FE88C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE890: 4BFE9211  bl 0x830e7aa0
	ctx.lr = 0x830FE894;
	sub_830E7AA0(ctx, base);
	// 830FE894: 83610074  lwz r27, 0x74(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830FE898: 83210064  lwz r25, 0x64(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830FE89C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830FE8A0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830FE8A4: 7F1BC800  cmpw cr6, r27, r25
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830FE8A8: 41990008  bgt cr6, 0x830fe8b0
	if ctx.cr[6].gt {
	pc = 0x830FE8B0; continue 'dispatch;
	}
	// 830FE8AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 830FE8B0: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830FE8B4: 7F0BC000  cmpw cr6, r11, r24
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830FE8B8: 4099001C  ble cr6, 0x830fe8d4
	if !ctx.cr[6].gt {
	pc = 0x830FE8D4; continue 'dispatch;
	}
	// 830FE8BC: 7F1BC800  cmpw cr6, r27, r25
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830FE8C0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830FE8C4: 41990008  bgt cr6, 0x830fe8cc
	if ctx.cr[6].gt {
	pc = 0x830FE8CC; continue 'dispatch;
	}
	// 830FE8C8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 830FE8CC: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 830FE8D0: 48000008  b 0x830fe8d8
	pc = 0x830FE8D8; continue 'dispatch;
	// 830FE8D4: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 830FE8D8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE8DC: 7F1A2000  cmpw cr6, r26, r4
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830FE8E0: 40990010  ble cr6, 0x830fe8f0
	if !ctx.cr[6].gt {
	pc = 0x830FE8F0; continue 'dispatch;
	}
	// 830FE8E4: 7CA4D050  subf r5, r4, r26
	ctx.r[5].s64 = ctx.r[26].s64 - ctx.r[4].s64;
	// 830FE8E8: 4BFE9601  bl 0x830e7ee8
	ctx.lr = 0x830FE8EC;
	sub_830E7EE8(ctx, base);
	// 830FE8EC: 48000010  b 0x830fe8fc
	pc = 0x830FE8FC; continue 'dispatch;
	// 830FE8F0: 7CBA2050  subf r5, r26, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 830FE8F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830FE8F8: 4BFE9639  bl 0x830e7f30
	ctx.lr = 0x830FE8FC;
	sub_830E7F30(ctx, base);
	// 830FE8FC: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE900: 4BFD0311  bl 0x830cec10
	ctx.lr = 0x830FE904;
	sub_830CEC10(ctx, base);
	// 830FE904: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FE908: 4BFE90B9  bl 0x830e79c0
	ctx.lr = 0x830FE90C;
	sub_830E79C0(ctx, base);
	// 830FE90C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FE910: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE914: 4BFE904D  bl 0x830e7960
	ctx.lr = 0x830FE918;
	sub_830E7960(ctx, base);
	// 830FE918: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FE91C: 40820014  bne 0x830fe930
	if !ctx.cr[0].eq {
	pc = 0x830FE930; continue 'dispatch;
	}
	// 830FE920: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE924: 4BFD02ED  bl 0x830cec10
	ctx.lr = 0x830FE928;
	sub_830CEC10(ctx, base);
	// 830FE928: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830FE92C: 4BFE9285  bl 0x830e7bb0
	ctx.lr = 0x830FE930;
	sub_830E7BB0(ctx, base);
	// 830FE930: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830FE934: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FE938: 40990028  ble cr6, 0x830fe960
	if !ctx.cr[6].gt {
	pc = 0x830FE960; continue 'dispatch;
	}
	// 830FE93C: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830FE940: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE944: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE948: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE94C: 4BFE96BD  bl 0x830e8008
	ctx.lr = 0x830FE950;
	sub_830E8008(ctx, base);
	// 830FE950: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830FE954: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 830FE958: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830FE95C: 4198FFE4  blt cr6, 0x830fe940
	if ctx.cr[6].lt {
	pc = 0x830FE940; continue 'dispatch;
	}
	// 830FE960: 7F1BD000  cmpw cr6, r27, r26
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830FE964: 40980024  bge cr6, 0x830fe988
	if !ctx.cr[6].lt {
	pc = 0x830FE988; continue 'dispatch;
	}
	// 830FE968: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830FE96C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FE970: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE974: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE978: 4BFE9691  bl 0x830e8008
	ctx.lr = 0x830FE97C;
	sub_830E8008(ctx, base);
	// 830FE97C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830FE980: 7F1ED000  cmpw cr6, r30, r26
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830FE984: 4198FFE8  blt cr6, 0x830fe96c
	if ctx.cr[6].lt {
	pc = 0x830FE96C; continue 'dispatch;
	}
	// 830FE988: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830FE98C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830FE990: 40990028  ble cr6, 0x830fe9b8
	if !ctx.cr[6].gt {
	pc = 0x830FE9B8; continue 'dispatch;
	}
	// 830FE994: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830FE998: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE99C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE9A0: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE9A4: 4BFE9715  bl 0x830e80b8
	ctx.lr = 0x830FE9A8;
	sub_830E80B8(ctx, base);
	// 830FE9A8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830FE9AC: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 830FE9B0: 7F1EC800  cmpw cr6, r30, r25
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830FE9B4: 4198FFE4  blt cr6, 0x830fe998
	if ctx.cr[6].lt {
	pc = 0x830FE998; continue 'dispatch;
	}
	// 830FE9B8: 7F19D000  cmpw cr6, r25, r26
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830FE9BC: 40980024  bge cr6, 0x830fe9e0
	if !ctx.cr[6].lt {
	pc = 0x830FE9E0; continue 'dispatch;
	}
	// 830FE9C0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 830FE9C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FE9C8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE9CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830FE9D0: 4BFE96E9  bl 0x830e80b8
	ctx.lr = 0x830FE9D4;
	sub_830E80B8(ctx, base);
	// 830FE9D4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830FE9D8: 7F1ED000  cmpw cr6, r30, r26
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830FE9DC: 4198FFE8  blt cr6, 0x830fe9c4
	if ctx.cr[6].lt {
	pc = 0x830FE9C4; continue 'dispatch;
	}
	// 830FE9E0: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830FE9E4: 40990034  ble cr6, 0x830fea18
	if !ctx.cr[6].gt {
	pc = 0x830FEA18; continue 'dispatch;
	}
	// 830FE9E8: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830FE9EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830FE9F0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE9F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FE9F8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FE9FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830FEA00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830FEA04: 4BFE989D  bl 0x830e82a0
	ctx.lr = 0x830FEA08;
	sub_830E82A0(ctx, base);
	// 830FEA08: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830FEA0C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830FEA10: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830FEA14: 4198FFD8  blt cr6, 0x830fe9ec
	if ctx.cr[6].lt {
	pc = 0x830FE9EC; continue 'dispatch;
	}
	// 830FEA18: 7F18D000  cmpw cr6, r24, r26
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830FEA1C: 40980030  bge cr6, 0x830fea4c
	if !ctx.cr[6].lt {
	pc = 0x830FEA4C; continue 'dispatch;
	}
	// 830FEA20: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 830FEA24: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830FEA28: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEA2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830FEA30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830FEA34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830FEA38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830FEA3C: 4BFE9865  bl 0x830e82a0
	ctx.lr = 0x830FEA40;
	sub_830E82A0(ctx, base);
	// 830FEA40: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830FEA44: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830FEA48: 4198FFDC  blt cr6, 0x830fea24
	if ctx.cr[6].lt {
	pc = 0x830FEA24; continue 'dispatch;
	}
	// 830FEA4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830FEA50: 4BFDCBA9  bl 0x830db5f8
	ctx.lr = 0x830FEA54;
	sub_830DB5F8(ctx, base);
	// 830FEA54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FEA58: 4BFDCBA1  bl 0x830db5f8
	ctx.lr = 0x830FEA5C;
	sub_830DB5F8(ctx, base);
	// 830FEA5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830FEA60: 4BFDCB99  bl 0x830db5f8
	ctx.lr = 0x830FEA64;
	sub_830DB5F8(ctx, base);
	// 830FEA64: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830FEA68: 480A9740  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FEA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FEA70 size=1520
    let mut pc: u32 = 0x830FEA70;
    'dispatch: loop {
        match pc {
            0x830FEA70 => {
    //   block [0x830FEA70..0x830FF060)
	// 830FEA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FEA74: 480A96E9  bl 0x831a815c
	ctx.lr = 0x830FEA78;
	sub_831A8130(ctx, base);
	// 830FEA78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FEA7C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEA80: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830FEA84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FEA88: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 830FEA8C: 2B0B0803  cmplwi cr6, r11, 0x803
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2051 as u32, &mut ctx.xer);
	// 830FEA90: 41990518  bgt cr6, 0x830fefa8
	if ctx.cr[6].gt {
	pc = 0x830FEFA8; continue 'dispatch;
	}
	// 830FEA94: 419A04A4  beq cr6, 0x830fef38
	if ctx.cr[6].eq {
	pc = 0x830FEF38; continue 'dispatch;
	}
	// 830FEA98: 396BF824  addi r11, r11, -0x7dc
	ctx.r[11].s64 = ctx.r[11].s64 + -2012;
	// 830FEA9C: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830FEAA0: 419905B4  bgt cr6, 0x830ff054
	if ctx.cr[6].gt {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FEAA4: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 830FEAA8: 398C92E8  addi r12, r12, -0x6d18
	ctx.r[12].s64 = ctx.r[12].s64 + -27928;
	// 830FEAAC: 5560083C  slwi r0, r11, 1
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830FEAB0: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830FEAB4: 3D808310  lis r12, -0x7cf0
	ctx.r[12].s64 = -2096103424;
	// 830FEAB8: 398CEACC  addi r12, r12, -0x1534
	ctx.r[12].s64 = ctx.r[12].s64 + -5428;
	// 830FEABC: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 830FEAC0: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 830FEAC4: 60000000  nop
	// 830FEAC8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 830FEACC: 83E40010  lwz r31, 0x10(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEAD0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEAD4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830FEAD8: 40990574  ble cr6, 0x830ff04c
	if !ctx.cr[6].gt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEADC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEAE0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830FEAE4: 41980568  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEAE8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FEAEC: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FEAF0: 4199055C  bgt cr6, 0x830ff04c
	if ctx.cr[6].gt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEAF4: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 830FEAF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FEAFC: 4BFFFC25  bl 0x830fe720
	ctx.lr = 0x830FEB00;
	sub_830FE720(ctx, base);
	// 830FEB00: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FEB04: 418200C0  beq 0x830febc4
	if ctx.cr[0].eq {
	pc = 0x830FEBC4; continue 'dispatch;
	}
	// 830FEB08: 3B7E001C  addi r27, r30, 0x1c
	ctx.r[27].s64 = ctx.r[30].s64 + 28;
	// 830FEB0C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEB10: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEB14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FEB18: 4BFFFC09  bl 0x830fe720
	ctx.lr = 0x830FEB1C;
	sub_830FE720(ctx, base);
	// 830FEB1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FEB20: 41820094  beq 0x830febb4
	if ctx.cr[0].eq {
	pc = 0x830FEBB4; continue 'dispatch;
	}
	// 830FEB24: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830FEB28: 3BBE0034  addi r29, r30, 0x34
	ctx.r[29].s64 = ctx.r[30].s64 + 52;
	// 830FEB2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FEB30: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEB34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FEB38: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEB3C: 4BFF6AF5  bl 0x830f5630
	ctx.lr = 0x830FEB40;
	sub_830F5630(ctx, base);
	// 830FEB40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FEB44: 41820058  beq 0x830feb9c
	if ctx.cr[0].eq {
	pc = 0x830FEB9C; continue 'dispatch;
	}
	// 830FEB48: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830FEB4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FEB50: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 830FEB54: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEB58: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEB5C: 4BFF6AD5  bl 0x830f5630
	ctx.lr = 0x830FEB60;
	sub_830F5630(ctx, base);
	// 830FEB60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FEB64: 408204F0  bne 0x830ff054
	if !ctx.cr[0].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FEB68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FEB6C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEB70: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEB74: 4BFFA415  bl 0x830f8f88
	ctx.lr = 0x830FEB78;
	sub_830F8F88(ctx, base);
	// 830FEB78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FEB7C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEB80: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEB84: 4BFFA405  bl 0x830f8f88
	ctx.lr = 0x830FEB88;
	sub_830F8F88(ctx, base);
	// 830FEB88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FEB8C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEB90: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEB94: 4BFE7B5D  bl 0x830e66f0
	ctx.lr = 0x830FEB98;
	sub_830E66F0(ctx, base);
	// 830FEB98: 4800002C  b 0x830febc4
	pc = 0x830FEBC4; continue 'dispatch;
	// 830FEB9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FEBA0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEBA4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEBA8: 4BFFA3E1  bl 0x830f8f88
	ctx.lr = 0x830FEBAC;
	sub_830F8F88(ctx, base);
	// 830FEBAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FEBB0: 48000008  b 0x830febb8
	pc = 0x830FEBB8; continue 'dispatch;
	// 830FEBB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830FEBB8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEBBC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEBC0: 4BFFA3C9  bl 0x830f8f88
	ctx.lr = 0x830FEBC4;
	sub_830F8F88(ctx, base);
	// 830FEBC4: 3F208007  lis r25, -0x7ff9
	ctx.r[25].s64 = -2147024896;
	// 830FEBC8: 6339000E  ori r25, r25, 0xe
	ctx.r[25].u64 = ctx.r[25].u64 | 14;
	// 830FEBCC: 48000488  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEBD0: 83A40010  lwz r29, 0x10(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEBD4: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEBD8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830FEBDC: 4099004C  ble cr6, 0x830fec28
	if !ctx.cr[6].gt {
	pc = 0x830FEC28; continue 'dispatch;
	}
	// 830FEBE0: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEBE4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830FEBE8: 41980040  blt cr6, 0x830fec28
	if ctx.cr[6].lt {
	pc = 0x830FEC28; continue 'dispatch;
	}
	// 830FEBEC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FEBF0: 7D442A14  add r10, r4, r5
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 830FEBF4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FEBF8: 41990030  bgt cr6, 0x830fec28
	if ctx.cr[6].gt {
	pc = 0x830FEC28; continue 'dispatch;
	}
	// 830FEBFC: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 830FEC00: 4BFFA389  bl 0x830f8f88
	ctx.lr = 0x830FEC04;
	sub_830F8F88(ctx, base);
	// 830FEC04: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 830FEC08: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEC0C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEC10: 4BFFA379  bl 0x830f8f88
	ctx.lr = 0x830FEC14;
	sub_830F8F88(ctx, base);
	// 830FEC14: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 830FEC18: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEC1C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEC20: 4BFE7AD1  bl 0x830e66f0
	ctx.lr = 0x830FEC24;
	sub_830E66F0(ctx, base);
	// 830FEC24: 4800000C  b 0x830fec30
	pc = 0x830FEC30; continue 'dispatch;
	// 830FEC28: 3F208007  lis r25, -0x7ff9
	ctx.r[25].s64 = -2147024896;
	// 830FEC2C: 63390057  ori r25, r25, 0x57
	ctx.r[25].u64 = ctx.r[25].u64 | 87;
	// 830FEC30: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEC34: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FEC38: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FEC3C: 4098004C  bge cr6, 0x830fec88
	if !ctx.cr[6].lt {
	pc = 0x830FEC88; continue 'dispatch;
	}
	// 830FEC40: 579F103A  slwi r31, r28, 2
	ctx.r[31].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 830FEC44: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FEC48: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830FEC4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830FEC50: 419A0024  beq cr6, 0x830fec74
	if ctx.cr[6].eq {
	pc = 0x830FEC74; continue 'dispatch;
	}
	// 830FEC54: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FEC58: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEC5C: 4BFDE87D  bl 0x830dd4d8
	ctx.lr = 0x830FEC60;
	sub_830DD4D8(ctx, base);
	// 830FEC60: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FEC64: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830FEC68: 4BFDE871  bl 0x830dd4d8
	ctx.lr = 0x830FEC6C;
	sub_830DD4D8(ctx, base);
	// 830FEC6C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FEC70: 7F4BF92E  stwx r26, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[26].u32) };
	// 830FEC74: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FEC78: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830FEC7C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 830FEC80: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FEC84: 4198FFC0  blt cr6, 0x830fec44
	if ctx.cr[6].lt {
	pc = 0x830FEC44; continue 'dispatch;
	}
	// 830FEC88: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 830FEC8C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEC90: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEC94: 4BFE7A5D  bl 0x830e66f0
	ctx.lr = 0x830FEC98;
	sub_830E66F0(ctx, base);
	// 830FEC98: 480003BC  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEC9C: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FECA0: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FECA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FECA8: 419A03AC  beq cr6, 0x830ff054
	if ctx.cr[6].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FECAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FECB0: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FECB4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FECB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FECBC: 41980390  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FECC0: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FECC4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FECC8: 40980384  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FECCC: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FECD0: 80890010  lwz r4, 0x10(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FECD4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 830FECD8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FECDC: 4BFCE27D  bl 0x830ccf58
	ctx.lr = 0x830FECE0;
	sub_830CCF58(ctx, base);
	// 830FECE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FECE4: 40820370  bne 0x830ff054
	if !ctx.cr[0].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FECE8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830FECEC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830FECF0: 48000368  b 0x830ff058
	pc = 0x830FF058; continue 'dispatch;
	// 830FECF4: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FECF8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FECFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FED00: 419A0354  beq cr6, 0x830ff054
	if ctx.cr[6].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FED04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FED08: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FED0C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FED10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FED14: 41980338  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FED18: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FED1C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FED20: 4098032C  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FED24: 813E001C  lwz r9, 0x1c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FED28: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 830FED2C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FED30: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830FED34: 48000320  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FED38: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FED3C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FED40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FED44: 419A0310  beq cr6, 0x830ff054
	if ctx.cr[6].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FED48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FED4C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FED50: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FED54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FED58: 419802F4  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FED5C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FED60: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FED64: 409802E8  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FED68: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FED6C: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FED70: 4BFFFF64  b 0x830fecd4
	pc = 0x830FECD4; continue 'dispatch;
	// 830FED74: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FED78: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FED7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FED80: 419A02D4  beq cr6, 0x830ff054
	if ctx.cr[6].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FED84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FED88: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830FED8C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FED90: C0099534  lfs f0, -0x6acc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FED94: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830FED98: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FED9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEDA0: 419802AC  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEDA4: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FEDA8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FEDAC: 409802A0  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEDB0: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEDB4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 830FEDB8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FEDBC: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830FEDC0: 48000294  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEDC4: 81040010  lwz r8, 0x10(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEDC8: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEDCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEDD0: 409A0018  bne cr6, 0x830fede8
	if !ctx.cr[6].eq {
	pc = 0x830FEDE8; continue 'dispatch;
	}
	// 830FEDD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FEDD8: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FEDDC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FEDE0: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FEDE4: 48000270  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEDE8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FEDEC: 409A0268  bne cr6, 0x830ff054
	if !ctx.cr[6].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FEDF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FEDF4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 830FEDF8: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FEDFC: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FEE00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEE04: 40990028  ble cr6, 0x830fee2c
	if !ctx.cr[6].gt {
	pc = 0x830FEE2C; continue 'dispatch;
	}
	// 830FEE08: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FEE0C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEE10: 54E707BC  rlwinm r7, r7, 0, 0x1e, 0x1e
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 830FEE14: 2B070002  cmplwi cr6, r7, 2
	ctx.cr[6].compare_u32(ctx.r[7].u32, 2 as u32, &mut ctx.xer);
	// 830FEE18: 409A0008  bne cr6, 0x830fee20
	if !ctx.cr[6].eq {
	pc = 0x830FEE20; continue 'dispatch;
	}
	// 830FEE1C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830FEE20: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEE24: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830FEE28: 4082FFE4  bne 0x830fee0c
	if !ctx.cr[0].eq {
	pc = 0x830FEE0C; continue 'dispatch;
	}
	// 830FEE2C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830FEE30: 48000224  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEE34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FEE38: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEE3C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FEE40: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEE44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEE48: 41980204  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEE4C: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FEE50: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FEE54: 409801F8  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEE58: 813E0028  lwz r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FEE5C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FEE60: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FEE64: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 830FEE68: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FEE6C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FEE70: 480001E4  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEE74: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEE78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEE7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEE80: 419801CC  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEE84: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FEE88: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FEE8C: 409801C0  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEE90: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEE94: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FEE98: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FEE9C: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FEEA0: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FEEA4: 409A0010  bne cr6, 0x830feeb4
	if !ctx.cr[6].eq {
	pc = 0x830FEEB4; continue 'dispatch;
	}
	// 830FEEA8: 61290001  ori r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u64 | 1;
	// 830FEEAC: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 830FEEB0: 480001A4  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEEB4: 5529003C  rlwinm r9, r9, 0, 0, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 830FEEB8: 4BFFFFF4  b 0x830feeac
	pc = 0x830FEEAC; continue 'dispatch;
	// 830FEEBC: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEEC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FEEC4: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FEEC8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEECC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEED0: 4198017C  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEED4: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FEED8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FEEDC: 40980170  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEEE0: 813E0028  lwz r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FEEE4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FEEE8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FEEEC: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830FEEF0: 4BFFFF7C  b 0x830fee6c
	pc = 0x830FEE6C; continue 'dispatch;
	// 830FEEF4: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEEF8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEEFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEF00: 4198014C  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEF04: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FEF08: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FEF0C: 40980140  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEF10: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEF14: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FEF18: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FEF1C: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FEF20: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FEF24: 419A000C  beq cr6, 0x830fef30
	if ctx.cr[6].eq {
	pc = 0x830FEF30; continue 'dispatch;
	}
	// 830FEF28: 61290002  ori r9, r9, 2
	ctx.r[9].u64 = ctx.r[9].u64 | 2;
	// 830FEF2C: 4BFFFF80  b 0x830feeac
	pc = 0x830FEEAC; continue 'dispatch;
	// 830FEF30: 552907FA  rlwinm r9, r9, 0, 0x1f, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 830FEF34: 4BFFFF78  b 0x830feeac
	pc = 0x830FEEAC; continue 'dispatch;
	// 830FEF38: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEF3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FEF40: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830FEF44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEF48: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830FEF4C: 41980100  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEF50: 813E0038  lwz r9, 0x38(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FEF54: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830FEF58: 409800F4  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEF5C: 813E0034  lwz r9, 0x34(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FEF60: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830FEF64: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830FEF68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830FEF6C: 419A0028  beq cr6, 0x830fef94
	if ctx.cr[6].eq {
	pc = 0x830FEF94; continue 'dispatch;
	}
	// 830FEF70: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FEF74: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830FEF78: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FEF7C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830FEF80: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FEF84: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830FEF88: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEF8C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830FEF90: 480000C4  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEF94: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 830FEF98: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830FEF9C: 934B000C  stw r26, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830FEFA0: 934B0010  stw r26, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 830FEFA4: 480000B0  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FEFA8: 2B0B0804  cmplwi cr6, r11, 0x804
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2052 as u32, &mut ctx.xer);
	// 830FEFAC: 409A00A8  bne cr6, 0x830ff054
	if !ctx.cr[6].eq {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FEFB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FEFB4: 83A40010  lwz r29, 0x10(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FEFB8: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FEFBC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FEFC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FEFC4: 41980088  blt cr6, 0x830ff04c
	if ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEFC8: 815E0038  lwz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FEFCC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FEFD0: 4098007C  bge cr6, 0x830ff04c
	if !ctx.cr[6].lt {
	pc = 0x830FF04C; continue 'dispatch;
	}
	// 830FEFD4: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FEFD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FEFDC: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FEFE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830FEFE4: 409A0038  bne cr6, 0x830ff01c
	if !ctx.cr[6].eq {
	pc = 0x830FF01C; continue 'dispatch;
	}
	// 830FEFE8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 830FEFEC: 4BFDE4C5  bl 0x830dd4b0
	ctx.lr = 0x830FEFF0;
	sub_830DD4B0(ctx, base);
	// 830FEFF0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FEFF4: 4182FCF4  beq 0x830fece8
	if ctx.cr[0].eq {
	pc = 0x830FECE8; continue 'dispatch;
	}
	// 830FEFF8: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 830FEFFC: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 830FF000: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830FF004: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830FF008: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 830FF00C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FF010: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF014: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830FF018: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 830FF01C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830FF020: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FF024: 4BFCFC65  bl 0x830cec88
	ctx.lr = 0x830FF028;
	sub_830CEC88(ctx, base);
	// 830FF028: 7C791B79  or. r25, r3, r3
	ctx.r[25].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830FF02C: 41800028  blt 0x830ff054
	if ctx.cr[0].lt {
	pc = 0x830FF054; continue 'dispatch;
	}
	// 830FF030: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FF034: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830FF038: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FF03C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830FF040: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FF044: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830FF048: 4800000C  b 0x830ff054
	pc = 0x830FF054; continue 'dispatch;
	// 830FF04C: 3F208007  lis r25, -0x7ff9
	ctx.r[25].s64 = -2147024896;
	// 830FF050: 63390057  ori r25, r25, 0x57
	ctx.r[25].u64 = ctx.r[25].u64 | 87;
	// 830FF054: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830FF058: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830FF05C: 480A9150  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FF060 size=132
    let mut pc: u32 = 0x830FF060;
    'dispatch: loop {
        match pc {
            0x830FF060 => {
    //   block [0x830FF060..0x830FF0E4)
	// 830FF060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FF068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830FF06C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FF070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FF078: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FF07C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830FF080: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830FF084: 48007C4D  bl 0x83106cd0
	ctx.lr = 0x830FF088;
	sub_83106CD0(ctx, base);
	// 830FF088: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FF08C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830FF090: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830FF094: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 830FF098: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830FF09C: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830FF0A0: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 830FF0A4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FF0A8: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 830FF0AC: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830FF0B0: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 830FF0B4: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 830FF0B8: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 830FF0BC: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 830FF0C0: 913F0040  stw r9, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 830FF0C4: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 830FF0C8: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 830FF0CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FF0D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FF0D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FF0D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830FF0DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FF0E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FF0E8 size=12
    let mut pc: u32 = 0x830FF0E8;
    'dispatch: loop {
        match pc {
            0x830FF0E8 => {
    //   block [0x830FF0E8..0x830FF0F4)
	// 830FF0E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FF0EC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FF0F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FF0F8 size=184
    let mut pc: u32 = 0x830FF0F8;
    'dispatch: loop {
        match pc {
            0x830FF0F8 => {
    //   block [0x830FF0F8..0x830FF1B0)
	// 830FF0F8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 830FF0FC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830FF100: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 830FF104: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830FF108: 90C3000C  stw r6, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 830FF10C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830FF110: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830FF114: 419A000C  beq cr6, 0x830ff120
	if ctx.cr[6].eq {
	pc = 0x830FF120; continue 'dispatch;
	}
	// 830FF118: 90830014  stw r4, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 830FF11C: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 830FF120: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830FF124: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FF128: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830FF12C: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 830FF130: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830FF134: 91230038  stw r9, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 830FF138: 7CA42850  subf r5, r4, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 830FF13C: 91430044  stw r10, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 830FF140: 93C30040  stw r30, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 830FF144: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 830FF148: 90A3003C  stw r5, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[5].u32 ) };
	// 830FF14C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF150: 91430048  stw r10, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 830FF154: 40990050  ble cr6, 0x830ff1a4
	if !ctx.cr[6].gt {
	pc = 0x830FF1A4; continue 'dispatch;
	}
	// 830FF158: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FF15C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830FF160: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FF164: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830FF168: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 830FF16C: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 830FF170: 419A000C  beq cr6, 0x830ff17c
	if ctx.cr[6].eq {
	pc = 0x830FF17C; continue 'dispatch;
	}
	// 830FF174: 908B0010  stw r4, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 830FF178: 90CB0014  stw r6, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 830FF17C: 83CB0028  lwz r30, 0x28(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830FF180: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830FF184: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 830FF188: 394A0044  addi r10, r10, 0x44
	ctx.r[10].s64 = ctx.r[10].s64 + 68;
	// 830FF18C: 63DE0001  ori r30, r30, 1
	ctx.r[30].u64 = ctx.r[30].u64 | 1;
	// 830FF190: 90AB002C  stw r5, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[5].u32 ) };
	// 830FF194: 93CB0028  stw r30, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 830FF198: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FF19C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FF1A0: 4198FFB8  blt cr6, 0x830ff158
	if ctx.cr[6].lt {
	pc = 0x830FF158; continue 'dispatch;
	}
	// 830FF1A4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FF1A8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830FF1AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FF1B0 size=80
    let mut pc: u32 = 0x830FF1B0;
    'dispatch: loop {
        match pc {
            0x830FF1B0 => {
    //   block [0x830FF1B0..0x830FF200)
	// 830FF1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF1B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FF1B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830FF1BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FF1C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF1C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830FF1C8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830FF1CC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830FF1D0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830FF1D4: 48002E1D  bl 0x83101ff0
	ctx.lr = 0x830FF1D8;
	sub_83101FF0(ctx, base);
	// 830FF1D8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830FF1DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830FF1E0: 480048B9  bl 0x83103a98
	ctx.lr = 0x830FF1E4;
	sub_83103A98(ctx, base);
	// 830FF1E4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830FF1E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FF1EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FF1F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FF1F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830FF1F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FF1FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FF200 size=12
    let mut pc: u32 = 0x830FF200;
    'dispatch: loop {
        match pc {
            0x830FF200 => {
    //   block [0x830FF200..0x830FF20C)
	// 830FF200: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FF204: 386BD964  addi r3, r11, -0x269c
	ctx.r[3].s64 = ctx.r[11].s64 + -9884;
	// 830FF208: 4BFE7708  b 0x830e6910
	sub_830E6910(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FF210 size=112
    let mut pc: u32 = 0x830FF210;
    'dispatch: loop {
        match pc {
            0x830FF210 => {
    //   block [0x830FF210..0x830FF280)
	// 830FF210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FF218: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830FF21C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FF220: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF224: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FF228: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FF22C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830FF230: 93FE002C  stw r31, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 830FF234: 917E0028  stw r11, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830FF238: 48007A99  bl 0x83106cd0
	ctx.lr = 0x830FF23C;
	sub_83106CD0(ctx, base);
	// 830FF23C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830FF240: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 830FF244: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 830FF248: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 830FF24C: 93FE0024  stw r31, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 830FF250: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FF254: 93FE0038  stw r31, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 830FF258: D01E0030  stfs f0, 0x30(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830FF25C: 93FE0034  stw r31, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 830FF260: 93FE003C  stw r31, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 830FF264: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 830FF268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FF26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FF270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FF274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830FF278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FF27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FF280 size=156
    let mut pc: u32 = 0x830FF280;
    'dispatch: loop {
        match pc {
            0x830FF280 => {
    //   block [0x830FF280..0x830FF31C)
	// 830FF280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF284: 480A8EDD  bl 0x831a8160
	ctx.lr = 0x830FF288;
	sub_831A8130(ctx, base);
	// 830FF288: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF28C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FF290: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830FF294: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830FF298: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830FF29C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830FF2A0: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830FF2A4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830FF2A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF2AC: 409A0018  bne cr6, 0x830ff2c4
	if !ctx.cr[6].eq {
	pc = 0x830FF2C4; continue 'dispatch;
	}
	// 830FF2B0: 80BF0034  lwz r5, 0x34(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FF2B4: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FF2B8: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FF2BC: 48007CFD  bl 0x83106fb8
	ctx.lr = 0x830FF2C0;
	sub_83106FB8(ctx, base);
	// 830FF2C0: 48000010  b 0x830ff2d0
	pc = 0x830FF2D0; continue 'dispatch;
	// 830FF2C4: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 830FF2C8: 48003CB9  bl 0x83102f80
	ctx.lr = 0x830FF2CC;
	sub_83102F80(ctx, base);
	// 830FF2CC: 935F0040  stw r26, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[26].u32 ) };
	// 830FF2D0: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 830FF2D4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830FF2D8: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830FF2DC: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 830FF2E0: 419A0018  beq cr6, 0x830ff2f8
	if ctx.cr[6].eq {
	pc = 0x830FF2F8; continue 'dispatch;
	}
	// 830FF2E4: 937F0040  stw r27, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[27].u32 ) };
	// 830FF2E8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830FF2EC: 419A000C  beq cr6, 0x830ff2f8
	if ctx.cr[6].eq {
	pc = 0x830FF2F8; continue 'dispatch;
	}
	// 830FF2F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FF2F4: 48003B55  bl 0x83102e48
	ctx.lr = 0x830FF2F8;
	sub_83102E48(ctx, base);
	// 830FF2F8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FF2FC: 935F0024  stw r26, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	// 830FF300: 40990014  ble cr6, 0x830ff314
	if !ctx.cr[6].gt {
	pc = 0x830FF314; continue 'dispatch;
	}
	// 830FF304: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 * 28;
	// 830FF308: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830FF30C: 816BFFE4  lwz r11, -0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 830FF310: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830FF314: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830FF318: 480A8E98  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FF320 size=828
    let mut pc: u32 = 0x830FF320;
    'dispatch: loop {
        match pc {
            0x830FF320 => {
    //   block [0x830FF320..0x830FF65C)
	// 830FF320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF324: 480A8E41  bl 0x831a8164
	ctx.lr = 0x830FF328;
	sub_831A8130(ctx, base);
	// 830FF328: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF32C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF330: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FF334: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FF338: 419A02CC  beq cr6, 0x830ff604
	if ctx.cr[6].eq {
	pc = 0x830FF604; continue 'dispatch;
	}
	// 830FF33C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830FF340: 419A02A8  beq cr6, 0x830ff5e8
	if ctx.cr[6].eq {
	pc = 0x830FF5E8; continue 'dispatch;
	}
	// 830FF344: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 830FF348: 419A00C4  beq cr6, 0x830ff40c
	if ctx.cr[6].eq {
	pc = 0x830FF40C; continue 'dispatch;
	}
	// 830FF34C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 830FF350: 419A0034  beq cr6, 0x830ff384
	if ctx.cr[6].eq {
	pc = 0x830FF384; continue 'dispatch;
	}
	// 830FF354: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 830FF358: 419A000C  beq cr6, 0x830ff364
	if ctx.cr[6].eq {
	pc = 0x830FF364; continue 'dispatch;
	}
	// 830FF35C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FF360: 480002F4  b 0x830ff654
	pc = 0x830FF654; continue 'dispatch;
	// 830FF364: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 830FF368: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 830FF36C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830FF370: 48018F59  bl 0x831182c8
	ctx.lr = 0x830FF374;
	sub_831182C8(ctx, base);
	// 830FF374: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830FF378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FF37C: 48003745  bl 0x83102ac0
	ctx.lr = 0x830FF380;
	sub_83102AC0(ctx, base);
	// 830FF380: 480002D0  b 0x830ff650
	pc = 0x830FF650; continue 'dispatch;
	// 830FF384: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 830FF388: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830FF38C: 3920000B  li r9, 0xb
	ctx.r[9].s64 = 11;
	// 830FF390: D0210088  stfs f1, 0x88(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830FF394: 39450004  addi r10, r5, 4
	ctx.r[10].s64 = ctx.r[5].s64 + 4;
	// 830FF398: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830FF39C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 830FF3A0: D0210080  stfs f1, 0x80(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830FF3A4: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 830FF3A8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 830FF3AC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830FF3B0: 13AB48C7  vcmpequd (lvx128) v29, v11, v9
	tmp.u32 = ctx.r[11].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 830FF3B4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830FF3B8: 7C00580C  lvsl v0, 0, r11
	tmp.u32 = ctx.r[11].u32;
	// ctx.v[0] = VectorShiftTableL[(tmp.u32 & 0xF)]
	// 830FF3BC: 3BC10090  addi r30, r1, 0x90
	ctx.r[30].s64 = ctx.r[1].s64 + 144;
	// 830FF3C0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FF660 size=148
    let mut pc: u32 = 0x830FF660;
    'dispatch: loop {
        match pc {
            0x830FF660 => {
    //   block [0x830FF660..0x830FF6F4)
	// 830FF660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FF668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830FF66C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FF670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FF678: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FF67C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830FF680: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF684: 409A0018  bne cr6, 0x830ff69c
	if !ctx.cr[6].eq {
	pc = 0x830FF69C; continue 'dispatch;
	}
	// 830FF688: 80BF0034  lwz r5, 0x34(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FF68C: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FF690: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FF694: 48007925  bl 0x83106fb8
	ctx.lr = 0x830FF698;
	sub_83106FB8(ctx, base);
	// 830FF698: 48000010  b 0x830ff6a8
	pc = 0x830FF6A8; continue 'dispatch;
	// 830FF69C: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 830FF6A0: 480038E1  bl 0x83102f80
	ctx.lr = 0x830FF6A4;
	sub_83102F80(ctx, base);
	// 830FF6A4: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 830FF6A8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830FF6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FF6B0: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830FF6B4: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 830FF6B8: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 830FF6BC: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830FF6C0: 48007611  bl 0x83106cd0
	ctx.lr = 0x830FF6C4;
	sub_83106CD0(ctx, base);
	// 830FF6C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FF6C8: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FF6CC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830FF6D0: 4BFDDE09  bl 0x830dd4d8
	ctx.lr = 0x830FF6D4;
	sub_830DD4D8(ctx, base);
	// 830FF6D4: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 830FF6D8: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 830FF6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FF6E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FF6E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FF6E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830FF6EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FF6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FF6F8 size=80
    let mut pc: u32 = 0x830FF6F8;
    'dispatch: loop {
        match pc {
            0x830FF6F8 => {
    //   block [0x830FF6F8..0x830FF748)
	// 830FF6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF6FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FF700: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FF704: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF708: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FF70C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830FF710: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FF714: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 830FF718: 419A001C  beq cr6, 0x830ff734
	if ctx.cr[6].eq {
	pc = 0x830FF734; continue 'dispatch;
	}
	// 830FF71C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FF720: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FF724: 4BFFFA8D  bl 0x830ff1b0
	ctx.lr = 0x830FF728;
	sub_830FF1B0(ctx, base);
	// 830FF728: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FF72C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FF730: 4BFD6499  bl 0x830d5bc8
	ctx.lr = 0x830FF734;
	sub_830D5BC8(ctx, base);
	// 830FF734: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830FF738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FF73C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FF740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FF744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FF748 size=20
    let mut pc: u32 = 0x830FF748;
    'dispatch: loop {
        match pc {
            0x830FF748 => {
    //   block [0x830FF748..0x830FF75C)
	// 830FF748: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FF74C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830FF750: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF754: 91230034  stw r9, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 830FF758: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF75C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FF75C size=52
    let mut pc: u32 = 0x830FF75C;
    'dispatch: loop {
        match pc {
            0x830FF75C => {
    //   block [0x830FF75C..0x830FF790)
	// 830FF75C: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FF760: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 830FF764: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF768: 81030034  lwz r8, 0x34(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FF76C: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830FF770: 40990008  ble cr6, 0x830ff778
	if !ctx.cr[6].gt {
	pc = 0x830FF778; continue 'dispatch;
	}
	// 830FF774: 91430034  stw r10, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 830FF778: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FF77C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830FF780: 396B0044  addi r11, r11, 0x44
	ctx.r[11].s64 = ctx.r[11].s64 + 68;
	// 830FF784: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830FF788: 4198FFDC  blt cr6, 0x830ff764
	if ctx.cr[6].lt {
	pc = 0x830FF764; continue 'dispatch;
	}
	// 830FF78C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FF790 size=80
    let mut pc: u32 = 0x830FF790;
    'dispatch: loop {
        match pc {
            0x830FF790 => {
    //   block [0x830FF790..0x830FF7E0)
	// 830FF790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FF798: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FF79C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF7A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FF7A4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830FF7A8: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF7AC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 830FF7B0: 419A001C  beq cr6, 0x830ff7cc
	if ctx.cr[6].eq {
	pc = 0x830FF7CC; continue 'dispatch;
	}
	// 830FF7B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830FF7B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FF7BC: 4BFFF9F5  bl 0x830ff1b0
	ctx.lr = 0x830FF7C0;
	sub_830FF1B0(ctx, base);
	// 830FF7C0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830FF7C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF7C8: 4BFD6591  bl 0x830d5d58
	ctx.lr = 0x830FF7CC;
	sub_830D5D58(ctx, base);
	// 830FF7CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830FF7D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FF7D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FF7D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FF7DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FF7E0 size=144
    let mut pc: u32 = 0x830FF7E0;
    'dispatch: loop {
        match pc {
            0x830FF7E0 => {
    //   block [0x830FF7E0..0x830FF870)
	// 830FF7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF7E4: 480A8989  bl 0x831a816c
	ctx.lr = 0x830FF7E8;
	sub_831A8130(ctx, base);
	// 830FF7E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF7EC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FF7F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FF7F4: 3BABD948  addi r29, r11, -0x26b8
	ctx.r[29].s64 = ctx.r[11].s64 + -9912;
	// 830FF7F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FF7FC: 48143171  bl 0x8324296c
	ctx.lr = 0x830FF800;
	// extern call 0x8324296C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830FF800: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FF804: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830FF808: 386BD964  addi r3, r11, -0x269c
	ctx.r[3].s64 = ctx.r[11].s64 + -9884;
	// 830FF80C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FF810: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF814: 40990048  ble cr6, 0x830ff85c
	if !ctx.cr[6].gt {
	pc = 0x830FF85C; continue 'dispatch;
	}
	// 830FF818: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF81C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF820: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830FF824: 419A0018  beq cr6, 0x830ff83c
	if ctx.cr[6].eq {
	pc = 0x830FF83C; continue 'dispatch;
	}
	// 830FF828: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830FF82C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830FF830: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FF834: 4198FFE8  blt cr6, 0x830ff81c
	if ctx.cr[6].lt {
	pc = 0x830FF81C; continue 'dispatch;
	}
	// 830FF838: 48000024  b 0x830ff85c
	pc = 0x830FF85C; continue 'dispatch;
	// 830FF83C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830FF840: 4BFE6FC9  bl 0x830e6808
	ctx.lr = 0x830FF844;
	sub_830E6808(ctx, base);
	// 830FF844: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 830FF848: 816A571C  lwz r11, 0x571c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22300 as u32) ) } as u64;
	// 830FF84C: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830FF850: 4198000C  blt cr6, 0x830ff85c
	if ctx.cr[6].lt {
	pc = 0x830FF85C; continue 'dispatch;
	}
	// 830FF854: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830FF858: 916A571C  stw r11, 0x571c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(22300 as u32), ctx.r[11].u32 ) };
	// 830FF85C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FF860: 481430FD  bl 0x8324295c
	ctx.lr = 0x830FF864;
	// extern call 0x8324295C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830FF864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FF868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FF86C: 480A8950  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FF870 size=4
    let mut pc: u32 = 0x830FF870;
    'dispatch: loop {
        match pc {
            0x830FF870 => {
    //   block [0x830FF870..0x830FF874)
	// 830FF870: 4BFFF9A0  b 0x830ff210
	sub_830FF210(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FF878 size=4
    let mut pc: u32 = 0x830FF878;
    'dispatch: loop {
        match pc {
            0x830FF878 => {
    //   block [0x830FF878..0x830FF87C)
	// 830FF878: 4BFFFDE8  b 0x830ff660
	sub_830FF660(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FF880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830FF880 size=760
    let mut pc: u32 = 0x830FF880;
    'dispatch: loop {
        match pc {
            0x830FF880 => {
    //   block [0x830FF880..0x830FFB78)
	// 830FF880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FF884: 480A88D1  bl 0x831a8154
	ctx.lr = 0x830FF888;
	sub_831A8130(ctx, base);
	// 830FF888: DBA1FF98  stfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[29].u64 ) };
	// 830FF88C: DBC1FFA0  stfd f30, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 830FF890: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 830FF894: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FF898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FF89C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 830FF8A0: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FF8A4: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 830FF8A8: 419802BC  blt cr6, 0x830ffb64
	if ctx.cr[6].lt {
	pc = 0x830FFB64; continue 'dispatch;
	}
	// 830FF8AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FF8B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FF8B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF8B8: 40980008  bge cr6, 0x830ff8c0
	if !ctx.cr[6].lt {
	pc = 0x830FF8C0; continue 'dispatch;
	}
	// 830FF8BC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FF8C0: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830FF8C4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830FF8C8: 419A003C  beq cr6, 0x830ff904
	if ctx.cr[6].eq {
	pc = 0x830FF904; continue 'dispatch;
	}
	// 830FF8CC: 7D6A5851  subf. r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF8D0: 4181000C  bgt 0x830ff8dc
	if ctx.cr[0].gt {
	pc = 0x830FF8DC; continue 'dispatch;
	}
	// 830FF8D4: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 830FF8D8: 4800002C  b 0x830ff904
	pc = 0x830FF904; continue 'dispatch;
	// 830FF8DC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 830FF8E0: 56EB083E  rotlwi r11, r23, 1
	ctx.r[11].u64 = ((ctx.r[23].u32).rotate_left(1)) as u64;
	// 830FF8E4: 7CD74BD6  divw r6, r23, r9
	ctx.r[6].s32 = ctx.r[23].s32 / ctx.r[9].s32;
	// 830FF8E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830FF8EC: 7CC649D6  mullw r6, r6, r9
	ctx.r[6].s64 = (ctx.r[6].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830FF8F0: 0CC90000  twi 6, r9, 0
	// 830FF8F4: 7D295878  andc r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 830FF8F8: 7D66B850  subf r11, r6, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[6].s64;
	// 830FF8FC: 0CA9FFFF  twi 5, r9, -1
	// 830FF900: 7EEB5214  add r23, r11, r10
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FF904: 3528FFFF  addic. r9, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830FF908: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 830FF90C: 41800258  blt 0x830ffb64
	if ctx.cr[0].lt {
	pc = 0x830FFB64; continue 'dispatch;
	}
	// 830FF910: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FF914: 1D79001C  mulli r11, r25, 0x1c
	ctx.r[11].s64 = ctx.r[25].s64 * 28;
	// 830FF918: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830FF91C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF920: 7F06B840  cmplw cr6, r6, r23
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[23].u32, &mut ctx.xer);
	// 830FF924: 40990014  ble cr6, 0x830ff938
	if !ctx.cr[6].gt {
	pc = 0x830FF938; continue 'dispatch;
	}
	// 830FF928: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830FF92C: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 830FF930: 4080FFEC  bge 0x830ff91c
	if !ctx.cr[0].lt {
	pc = 0x830FF91C; continue 'dispatch;
	}
	// 830FF934: 48000230  b 0x830ffb64
	pc = 0x830FFB64; continue 'dispatch;
	// 830FF938: 3B790001  addi r27, r25, 1
	ctx.r[27].s64 = ctx.r[25].s64 + 1;
	// 830FF93C: 7F1B4000  cmpw cr6, r27, r8
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830FF940: 41980014  blt cr6, 0x830ff954
	if ctx.cr[6].lt {
	pc = 0x830FF954; continue 'dispatch;
	}
	// 830FF944: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830FF948: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830FF94C: 409A0008  bne cr6, 0x830ff954
	if !ctx.cr[6].eq {
	pc = 0x830FF954; continue 'dispatch;
	}
	// 830FF950: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 830FF954: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830FF958: 4198020C  blt cr6, 0x830ffb64
	if ctx.cr[6].lt {
	pc = 0x830FFB64; continue 'dispatch;
	}
	// 830FF95C: 7F194000  cmpw cr6, r25, r8
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830FF960: 40980204  bge cr6, 0x830ffb64
	if !ctx.cr[6].lt {
	pc = 0x830FFB64; continue 'dispatch;
	}
	// 830FF964: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830FF968: 419801FC  blt cr6, 0x830ffb64
	if ctx.cr[6].lt {
	pc = 0x830FFB64; continue 'dispatch;
	}
	// 830FF96C: 7F1B4000  cmpw cr6, r27, r8
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830FF970: 409801F4  bge cr6, 0x830ffb64
	if !ctx.cr[6].lt {
	pc = 0x830FFB64; continue 'dispatch;
	}
	// 830FF974: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FF978: 1FD9001C  mulli r30, r25, 0x1c
	ctx.r[30].s64 = ctx.r[25].s64 * 28;
	// 830FF97C: 7F0AF214  add r24, r10, r30
	ctx.r[24].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830FF980: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830FF984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF988: 40990194  ble cr6, 0x830ffb1c
	if !ctx.cr[6].gt {
	pc = 0x830FFB1C; continue 'dispatch;
	}
	// 830FF98C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830FF990: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830FF994: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830FF998: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FF99C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830FF9A0: C3CBA1C4  lfs f30, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830FF9A4: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830FF9A8: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830FF9AC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FF9B0: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830FF9B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FF9B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FF9BC: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FF9C0: 41820014  beq 0x830ff9d4
	if ctx.cr[0].eq {
	pc = 0x830FF9D4; continue 'dispatch;
	}
	// 830FF9C4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FF9C8: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FF9CC: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FF9D0: 409A0134  bne cr6, 0x830ffb04
	if !ctx.cr[6].eq {
	pc = 0x830FFB04; continue 'dispatch;
	}
	// 830FF9D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FF9D8: 48002AE1  bl 0x831024b8
	ctx.lr = 0x830FF9DC;
	sub_831024B8(ctx, base);
	// 830FF9DC: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FF9E0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830FF9E4: 419A00C0  beq cr6, 0x830ffaa4
	if ctx.cr[6].eq {
	pc = 0x830FFAA4; continue 'dispatch;
	}
	// 830FF9E8: 7F1BC800  cmpw cr6, r27, r25
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830FF9EC: 419A004C  beq cr6, 0x830ffa38
	if ctx.cr[6].eq {
	pc = 0x830FFA38; continue 'dispatch;
	}
	// 830FF9F0: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FF9F4: 1D3B001C  mulli r9, r27, 0x1c
	ctx.r[9].s64 = ctx.r[27].s64 * 28;
	// 830FF9F8: 7D0AF02E  lwzx r8, r10, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830FF9FC: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830FFA00: 7D28B850  subf r9, r8, r23
	ctx.r[9].s64 = ctx.r[23].s64 - ctx.r[8].s64;
	// 830FFA04: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 830FFA08: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 830FFA0C: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 830FFA10: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 830FFA14: C9A10058  lfd f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830FFA18: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 830FFA1C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830FFA20: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830FFA24: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830FFA28: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830FFA2C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830FFA30: EC2D0024  fdivs f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 830FFA34: 48000008  b 0x830ffa3c
	pc = 0x830FFA3C; continue 'dispatch;
	// 830FFA38: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 830FFA3C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830FFA40: 409A002C  bne cr6, 0x830ffa6c
	if !ctx.cr[6].eq {
	pc = 0x830FFA6C; continue 'dispatch;
	}
	// 830FFA44: C0180014  lfs f0, 0x14(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830FFA48: EDBF0828  fsubs f13, f31, f1
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 830FFA4C: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830FFA50: C198000C  lfs f12, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830FFA54: ED610072  fmuls f11, f1, f1
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 830FFA58: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830FFA5C: ED8B0072  fmuls f12, f11, f1
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 830FFA60: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830FFA64: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830FFA68: EC2067BA  fmadds f1, f0, f30, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[12].f64) as f32) as f64);
	// 830FFA6C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FFA70: 1D5B001C  mulli r10, r27, 0x1c
	ctx.r[10].s64 = ctx.r[27].s64 * 28;
	// 830FFA74: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830FFA78: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FFA7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FFA80: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FFA84: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FFA88: 7CAAEA14  add r5, r10, r29
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 830FFA8C: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830FFA90: 4BFFF891  bl 0x830ff320
	ctx.lr = 0x830FFA94;
	sub_830FF320(ctx, base);
	// 830FFA94: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830FFA98: 4182000C  beq 0x830ffaa4
	if ctx.cr[0].eq {
	pc = 0x830FFAA4; continue 'dispatch;
	}
	// 830FFA9C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830FFAA0: 48000014  b 0x830ffab4
	pc = 0x830FFAB4; continue 'dispatch;
	// 830FFAA4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FFAA8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FFAAC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FFAB0: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830FFAB4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830FFAB8: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830FFABC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFAC0: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FFAC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830FFAC8: 419A0024  beq cr6, 0x830ffaec
	if ctx.cr[6].eq {
	pc = 0x830FFAEC; continue 'dispatch;
	}
	// 830FFACC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFAD0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFAD4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFAD8: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFADC: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FFAE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830FFAE4: 4E800421  bctrl
	ctx.lr = 0x830FFAE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830FFAE8: 48000014  b 0x830ffafc
	pc = 0x830FFAFC; continue 'dispatch;
	// 830FFAEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFAF0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830FFAF4: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFAF8: 4BFD2901  bl 0x830d23f8
	ctx.lr = 0x830FFAFC;
	sub_830D23F8(ctx, base);
	// 830FFAFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830FFB00: 48002F89  bl 0x83102a88
	ctx.lr = 0x830FFB04;
	sub_83102A88(ctx, base);
	// 830FFB04: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830FFB08: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830FFB0C: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 830FFB10: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 830FFB14: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FFB18: 4198FE94  blt cr6, 0x830ff9ac
	if ctx.cr[6].lt {
	pc = 0x830FF9AC; continue 'dispatch;
	}
	// 830FFB1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFB20: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FFB24: 41820028  beq 0x830ffb4c
	if ctx.cr[0].eq {
	pc = 0x830FFB4C; continue 'dispatch;
	}
	// 830FFB28: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FFB2C: 7F175800  cmpw cr6, r23, r11
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FFB30: 409A0010  bne cr6, 0x830ffb40
	if !ctx.cr[6].eq {
	pc = 0x830FFB40; continue 'dispatch;
	}
	// 830FFB34: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 830FFB38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFB3C: 4BFFFBBD  bl 0x830ff6f8
	ctx.lr = 0x830FFB40;
	sub_830FF6F8(ctx, base);
	// 830FFB40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFB44: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830FFB48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830FFB4C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FFB50: 7F175800  cmpw cr6, r23, r11
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FFB54: 409A0010  bne cr6, 0x830ffb64
	if !ctx.cr[6].eq {
	pc = 0x830FFB64; continue 'dispatch;
	}
	// 830FFB58: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 830FFB5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFB60: 4BFFFB99  bl 0x830ff6f8
	ctx.lr = 0x830FFB64;
	sub_830FF6F8(ctx, base);
	// 830FFB64: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830FFB68: CBA1FF98  lfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 830FFB6C: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 830FFB70: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 830FFB74: 480A8630  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFB78 size=84
    let mut pc: u32 = 0x830FFB78;
    'dispatch: loop {
        match pc {
            0x830FFB78 => {
    //   block [0x830FFB78..0x830FFBCC)
	// 830FFB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFB7C: 480A85ED  bl 0x831a8168
	ctx.lr = 0x830FFB80;
	sub_831A8130(ctx, base);
	// 830FFB80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFB84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FFB88: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830FFB8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830FFB90: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FFB94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FFB98: 4099002C  ble cr6, 0x830ffbc4
	if !ctx.cr[6].gt {
	pc = 0x830FFBC4; continue 'dispatch;
	}
	// 830FFB9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FFBA0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FFBA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830FFBA8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830FFBAC: 4BFFFCD5  bl 0x830ff880
	ctx.lr = 0x830FFBB0;
	sub_830FF880(ctx, base);
	// 830FFBB0: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FFBB4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830FFBB8: 3BDE0044  addi r30, r30, 0x44
	ctx.r[30].s64 = ctx.r[30].s64 + 68;
	// 830FFBBC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FFBC0: 4198FFE0  blt cr6, 0x830ffba0
	if ctx.cr[6].lt {
	pc = 0x830FFBA0; continue 'dispatch;
	}
	// 830FFBC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830FFBC8: 480A85F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFBD0 size=164
    let mut pc: u32 = 0x830FFBD0;
    'dispatch: loop {
        match pc {
            0x830FFBD0 => {
    //   block [0x830FFBD0..0x830FFC74)
	// 830FFBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFBD4: 480A8599  bl 0x831a816c
	ctx.lr = 0x830FFBD8;
	sub_831A8130(ctx, base);
	// 830FFBD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFBDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FFBE0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830FFBE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830FFBE8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFBEC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FFBF0: 409A0050  bne cr6, 0x830ffc40
	if !ctx.cr[6].eq {
	pc = 0x830FFC40; continue 'dispatch;
	}
	// 830FFBF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FFBF8: 409A000C  bne cr6, 0x830ffc04
	if !ctx.cr[6].eq {
	pc = 0x830FFC04; continue 'dispatch;
	}
	// 830FFBFC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830FFC00: 4800001C  b 0x830ffc1c
	pc = 0x830FFC1C; continue 'dispatch;
	// 830FFC04: 557E083D  rlwinm. r30, r11, 1, 0, 0x1e
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830FFC08: 40810028  ble 0x830ffc30
	if !ctx.cr[0].gt {
	pc = 0x830FFC30; continue 'dispatch;
	}
	// 830FFC0C: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 830FFC10: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830FFC14: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830FFC18: 40980018  bge cr6, 0x830ffc30
	if !ctx.cr[6].lt {
	pc = 0x830FFC30; continue 'dispatch;
	}
	// 830FFC1C: 57C4103A  slwi r4, r30, 2
	ctx.r[4].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830FFC20: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFC24: 4BFDD8CD  bl 0x830dd4f0
	ctx.lr = 0x830FFC28;
	sub_830DD4F0(ctx, base);
	// 830FFC28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FFC2C: 4082000C  bne 0x830ffc38
	if !ctx.cr[0].eq {
	pc = 0x830FFC38; continue 'dispatch;
	}
	// 830FFC30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FFC34: 48000038  b 0x830ffc6c
	pc = 0x830FFC6C; continue 'dispatch;
	// 830FFC38: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830FFC3C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830FFC40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFC44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFC48: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830FFC4C: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FFC50: 4182000C  beq 0x830ffc5c
	if ctx.cr[0].eq {
	pc = 0x830FFC5C; continue 'dispatch;
	}
	// 830FFC54: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFC58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830FFC5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFC60: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830FFC64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830FFC68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830FFC6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FFC70: 480A854C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFC78 size=84
    let mut pc: u32 = 0x830FFC78;
    'dispatch: loop {
        match pc {
            0x830FFC78 => {
    //   block [0x830FFC78..0x830FFCCC)
	// 830FFC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FFC80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FFC84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFC88: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FFC8C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 830FFC90: 3BEBD948  addi r31, r11, -0x26b8
	ctx.r[31].s64 = ctx.r[11].s64 + -9912;
	// 830FFC94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFC98: 48142CD5  bl 0x8324296c
	ctx.lr = 0x830FFC9C;
	// extern call 0x8324296C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830FFC9C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FFCA0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 830FFCA4: 386BD964  addi r3, r11, -0x269c
	ctx.r[3].s64 = ctx.r[11].s64 + -9884;
	// 830FFCA8: 4BFFFF29  bl 0x830ffbd0
	ctx.lr = 0x830FFCAC;
	sub_830FFBD0(ctx, base);
	// 830FFCAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFCB0: 48142CAD  bl 0x8324295c
	ctx.lr = 0x830FFCB4;
	// extern call 0x8324295C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830FFCB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830FFCB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830FFCBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FFCC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FFCC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FFCC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFCD0 size=120
    let mut pc: u32 = 0x830FFCD0;
    'dispatch: loop {
        match pc {
            0x830FFCD0 => {
    //   block [0x830FFCD0..0x830FFD48)
	// 830FFCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFCD4: 480A8495  bl 0x831a8168
	ctx.lr = 0x830FFCD8;
	sub_831A8130(ctx, base);
	// 830FFCD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFCDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FFCE0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830FFCE4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 830FFCE8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FFCEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FFCF0: 40990028  ble cr6, 0x830ffd18
	if !ctx.cr[6].gt {
	pc = 0x830FFD18; continue 'dispatch;
	}
	// 830FFCF4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 830FFCF8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FFCFC: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830FFD00: 4BFFF961  bl 0x830ff660
	ctx.lr = 0x830FFD04;
	sub_830FF660(ctx, base);
	// 830FFD04: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830FFD08: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830FFD0C: 3BDE0044  addi r30, r30, 0x44
	ctx.r[30].s64 = ctx.r[30].s64 + 68;
	// 830FFD10: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830FFD14: 4198FFE4  blt cr6, 0x830ffcf8
	if ctx.cr[6].lt {
	pc = 0x830FFCF8; continue 'dispatch;
	}
	// 830FFD18: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830FFD1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FFD20: 419A000C  beq cr6, 0x830ffd2c
	if ctx.cr[6].eq {
	pc = 0x830FFD2C; continue 'dispatch;
	}
	// 830FFD24: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830FFD28: 4BFE1441  bl 0x830e1168
	ctx.lr = 0x830FFD2C;
	sub_830E1168(ctx, base);
	// 830FFD2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830FFD30: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 830FFD34: 939F001C  stw r28, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 830FFD38: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830FFD3C: 939F0034  stw r28, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
	// 830FFD40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830FFD44: 480A8474  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFD48 size=52
    let mut pc: u32 = 0x830FFD48;
    'dispatch: loop {
        match pc {
            0x830FFD48 => {
    //   block [0x830FFD48..0x830FFD7C)
	// 830FFD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFD4C: 480A8421  bl 0x831a816c
	ctx.lr = 0x830FFD50;
	sub_831A8130(ctx, base);
	// 830FFD50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFD54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FFD58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830FFD5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830FFD60: 4BFFFF71  bl 0x830ffcd0
	ctx.lr = 0x830FFD64;
	sub_830FFCD0(ctx, base);
	// 830FFD64: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830FFD68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFD6C: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 830FFD70: 4BFFF9D9  bl 0x830ff748
	ctx.lr = 0x830FFD74;
	sub_830FF748(ctx, base);
	// 830FFD74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FFD78: 480A8444  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFD80 size=132
    let mut pc: u32 = 0x830FFD80;
    'dispatch: loop {
        match pc {
            0x830FFD80 => {
    //   block [0x830FFD80..0x830FFE04)
	// 830FFD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FFD88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830FFD8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FFD90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFD94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FFD98: 4BFFFF39  bl 0x830ffcd0
	ctx.lr = 0x830FFD9C;
	sub_830FFCD0(ctx, base);
	// 830FFD9C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830FFDA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FFDA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830FFDA8: 409A001C  bne cr6, 0x830ffdc4
	if !ctx.cr[6].eq {
	pc = 0x830FFDC4; continue 'dispatch;
	}
	// 830FFDAC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830FFDB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830FFDB4: 419A001C  beq cr6, 0x830ffdd0
	if ctx.cr[6].eq {
	pc = 0x830FFDD0; continue 'dispatch;
	}
	// 830FFDB8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830FFDBC: 4BFE1D3D  bl 0x830e1af8
	ctx.lr = 0x830FFDC0;
	sub_830E1AF8(ctx, base);
	// 830FFDC0: 48000010  b 0x830ffdd0
	pc = 0x830FFDD0; continue 'dispatch;
	// 830FFDC4: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830FFDC8: 480031B9  bl 0x83102f80
	ctx.lr = 0x830FFDCC;
	sub_83102F80(ctx, base);
	// 830FFDCC: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 830FFDD0: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830FFDD4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830FFDD8: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 830FFDDC: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 830FFDE0: 48006EF1  bl 0x83106cd0
	ctx.lr = 0x830FFDE4;
	sub_83106CD0(ctx, base);
	// 830FFDE4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830FFDE8: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 830FFDEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FFDF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FFDF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FFDF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830FFDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FFE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FFE08 size=4
    let mut pc: u32 = 0x830FFE08;
    'dispatch: loop {
        match pc {
            0x830FFE08 => {
    //   block [0x830FFE08..0x830FFE0C)
	// 830FFE08: 4BFFFF78  b 0x830ffd80
	sub_830FFD80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830FFE10 size=16
    let mut pc: u32 = 0x830FFE10;
    'dispatch: loop {
        match pc {
            0x830FFE10 => {
    //   block [0x830FFE10..0x830FFE20)
	// 830FFE10: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830FFE14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FFE18: 916AD98C  stw r11, -0x2674(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-9844 as u32), ctx.r[11].u32 ) };
	// 830FFE1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFE20 size=88
    let mut pc: u32 = 0x830FFE20;
    'dispatch: loop {
        match pc {
            0x830FFE20 => {
    //   block [0x830FFE20..0x830FFE78)
	// 830FFE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFE24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FFE28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830FFE2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FFE30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFE34: 3FC08339  lis r30, -0x7cc7
	ctx.r[30].s64 = -2093416448;
	// 830FFE38: 807ED98C  lwz r3, -0x2674(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9844 as u32) ) } as u64;
	// 830FFE3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FFE40: 41820018  beq 0x830ffe58
	if ctx.cr[0].eq {
	pc = 0x830FFE58; continue 'dispatch;
	}
	// 830FFE44: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FFE48: 4BFDD691  bl 0x830dd4d8
	ctx.lr = 0x830FFE4C;
	sub_830DD4D8(ctx, base);
	// 830FFE4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFE50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830FFE54: 409AFFF0  bne cr6, 0x830ffe44
	if !ctx.cr[6].eq {
	pc = 0x830FFE44; continue 'dispatch;
	}
	// 830FFE58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830FFE5C: 917ED98C  stw r11, -0x2674(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-9844 as u32), ctx.r[11].u32 ) };
	// 830FFE60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FFE64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FFE68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FFE6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830FFE70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FFE74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFE78 size=124
    let mut pc: u32 = 0x830FFE78;
    'dispatch: loop {
        match pc {
            0x830FFE78 => {
    //   block [0x830FFE78..0x830FFEF4)
	// 830FFE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830FFE80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830FFE84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830FFE88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFE8C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FFE90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830FFE94: 3BEBD970  addi r31, r11, -0x2690
	ctx.r[31].s64 = ctx.r[11].s64 + -9872;
	// 830FFE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFE9C: 48142AD1  bl 0x8324296c
	ctx.lr = 0x830FFEA0;
	// extern call 0x8324296C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830FFEA0: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FFEA4: 816BD98C  lwz r11, -0x2674(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9844 as u32) ) } as u64;
	// 830FFEA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FFEAC: 41820028  beq 0x830ffed4
	if ctx.cr[0].eq {
	pc = 0x830FFED4; continue 'dispatch;
	}
	// 830FFEB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFEB4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830FFEB8: 409A0010  bne cr6, 0x830ffec8
	if !ctx.cr[6].eq {
	pc = 0x830FFEC8; continue 'dispatch;
	}
	// 830FFEBC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830FFEC0: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 830FFEC4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830FFEC8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FFECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FFED0: 409AFFE0  bne cr6, 0x830ffeb0
	if !ctx.cr[6].eq {
	pc = 0x830FFEB0; continue 'dispatch;
	}
	// 830FFED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830FFED8: 48142A85  bl 0x8324295c
	ctx.lr = 0x830FFEDC;
	// extern call 0x8324295C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830FFEDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830FFEE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830FFEE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830FFEE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830FFEEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830FFEF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFEF8 size=192
    let mut pc: u32 = 0x830FFEF8;
    'dispatch: loop {
        match pc {
            0x830FFEF8 => {
    //   block [0x830FFEF8..0x830FFFB8)
	// 830FFEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFEFC: 480A8265  bl 0x831a8160
	ctx.lr = 0x830FFF00;
	sub_831A8130(ctx, base);
	// 830FFF00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFF04: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FFF08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830FFF0C: 3B6BD970  addi r27, r11, -0x2690
	ctx.r[27].s64 = ctx.r[11].s64 + -9872;
	// 830FFF10: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830FFF14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FFF18: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830FFF1C: 48142A51  bl 0x8324296c
	ctx.lr = 0x830FFF20;
	// extern call 0x8324296C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830FFF20: 3FC08339  lis r30, -0x7cc7
	ctx.r[30].s64 = -2093416448;
	// 830FFF24: 817ED98C  lwz r11, -0x2674(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9844 as u32) ) } as u64;
	// 830FFF28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FFF2C: 41820028  beq 0x830fff54
	if ctx.cr[0].eq {
	pc = 0x830FFF54; continue 'dispatch;
	}
	// 830FFF30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFF34: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830FFF38: 409A0010  bne cr6, 0x830fff48
	if !ctx.cr[6].eq {
	pc = 0x830FFF48; continue 'dispatch;
	}
	// 830FFF3C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFF40: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830FFF44: 419A0010  beq cr6, 0x830fff54
	if ctx.cr[6].eq {
	pc = 0x830FFF54; continue 'dispatch;
	}
	// 830FFF48: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830FFF4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FFF50: 409AFFE0  bne cr6, 0x830fff30
	if !ctx.cr[6].eq {
	pc = 0x830FFF30; continue 'dispatch;
	}
	// 830FFF54: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830FFF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830FFF5C: 409A0044  bne cr6, 0x830fffa0
	if !ctx.cr[6].eq {
	pc = 0x830FFFA0; continue 'dispatch;
	}
	// 830FFF60: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 830FFF64: 4BFDD54D  bl 0x830dd4b0
	ctx.lr = 0x830FFF68;
	sub_830DD4B0(ctx, base);
	// 830FFF68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830FFF6C: 40820020  bne 0x830fff8c
	if !ctx.cr[0].eq {
	pc = 0x830FFF8C; continue 'dispatch;
	}
	// 830FFF70: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 830FFF74: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 830FFF78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830FFF7C: 481429E1  bl 0x8324295c
	ctx.lr = 0x830FFF80;
	// extern call 0x8324295C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830FFF80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830FFF84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830FFF88: 480A8228  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 830FFF8C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830FFF90: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830FFF94: 817ED98C  lwz r11, -0x2674(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9844 as u32) ) } as u64;
	// 830FFF98: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830FFF9C: 93FED98C  stw r31, -0x2674(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-9844 as u32), ctx.r[31].u32 ) };
	// 830FFFA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830FFFA4: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 830FFFA8: 480C50B9  bl 0x831c5060
	ctx.lr = 0x830FFFAC;
	sub_831C5060(ctx, base);
	// 830FFFAC: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 830FFFB0: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830FFFB4: 4BFFFFC4  b 0x830fff78
	pc = 0x830FFF78; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830FFFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830FFFB8 size=144
    let mut pc: u32 = 0x830FFFB8;
    'dispatch: loop {
        match pc {
            0x830FFFB8 => {
    //   block [0x830FFFB8..0x83100048)
	// 830FFFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830FFFBC: 480A81B1  bl 0x831a816c
	ctx.lr = 0x830FFFC0;
	sub_831A8130(ctx, base);
	// 830FFFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830FFFC4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FFFC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830FFFCC: 3BABD970  addi r29, r11, -0x2690
	ctx.r[29].s64 = ctx.r[11].s64 + -9872;
	// 830FFFD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830FFFD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830FFFD8: 48142995  bl 0x8324296c
	ctx.lr = 0x830FFFDC;
	// extern call 0x8324296C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830FFFDC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830FFFE0: 816BD98C  lwz r11, -0x2674(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9844 as u32) ) } as u64;
	// 830FFFE4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830FFFE8: 41820030  beq 0x83100018
	if ctx.cr[0].eq {
	pc = 0x83100018; continue 'dispatch;
	}
	// 830FFFEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830FFFF0: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830FFFF4: 409A0010  bne cr6, 0x83100004
	if !ctx.cr[6].eq {
	pc = 0x83100004; continue 'dispatch;
	}
	// 830FFFF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830FFFFC: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 83100000: 419A0010  beq cr6, 0x83100010
	if ctx.cr[6].eq {
	pc = 0x83100010; continue 'dispatch;
	}
	// 83100004: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83100008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8310000C: 409AFFE0  bne cr6, 0x830fffec
	if !ctx.cr[6].eq {
	pc = 0x830FFFEC; continue 'dispatch;
	}
	// 83100010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83100014: 409A0020  bne cr6, 0x83100034
	if !ctx.cr[6].eq {
	pc = 0x83100034; continue 'dispatch;
	}
	// 83100018: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 8310001C: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 83100020: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83100024: 48142939  bl 0x8324295c
	ctx.lr = 0x83100028;
	// extern call 0x8324295C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 83100028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8310002C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83100030: 480A818C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 83100034: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83100038: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8310003C: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 83100040: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 83100044: 4BFFFFDC  b 0x83100020
	pc = 0x83100020; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100048 size=340
    let mut pc: u32 = 0x83100048;
    'dispatch: loop {
        match pc {
            0x83100048 => {
    //   block [0x83100048..0x8310019C)
	// 83100048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310004C: 480A8121  bl 0x831a816c
	ctx.lr = 0x83100050;
	sub_831A8130(ctx, base);
	// 83100050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83100054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83100058: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310005C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83100060: 4199012C  bgt cr6, 0x8310018c
	if ctx.cr[6].gt {
	pc = 0x8310018C; continue 'dispatch;
	}
	// 83100064: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8310006C: 409A0120  bne cr6, 0x8310018c
	if !ctx.cr[6].eq {
	pc = 0x8310018C; continue 'dispatch;
	}
	// 83100070: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83100074: 409A0010  bne cr6, 0x83100084
	if !ctx.cr[6].eq {
	pc = 0x83100084; continue 'dispatch;
	}
	// 83100078: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8310007C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 83100080: 48000114  b 0x83100194
	pc = 0x83100194; continue 'dispatch;
	// 83100084: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 83100088: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8310008C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 83100090: 419A002C  beq cr6, 0x831000bc
	if ctx.cr[6].eq {
	pc = 0x831000BC; continue 'dispatch;
	}
	// 83100094: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100098: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310009C: 556B0C3C  rlwinm r11, r11, 1, 0x10, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 831000A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 831000A4: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 831000A8: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 831000AC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 831000B0: 34A9FFFE  addic. r5, r9, -2
	ctx.xer.ca = (ctx.r[9].u32 > (!(-2 as u32)));
	ctx.r[5].s64 = ctx.r[9].s64 + -2;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 831000B4: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 831000B8: 4082FFDC  bne 0x83100094
	if !ctx.cr[0].eq {
	pc = 0x83100094; continue 'dispatch;
	}
	// 831000BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831000C0: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 831000C4: 4BFDD3ED  bl 0x830dd4b0
	ctx.lr = 0x831000C8;
	sub_830DD4B0(ctx, base);
	// 831000C8: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 831000CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 831000D0: 40820018  bne 0x831000e8
	if !ctx.cr[0].eq {
	pc = 0x831000E8; continue 'dispatch;
	}
	// 831000D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 831000D8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 831000DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831000E0: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 831000E4: 480000B0  b 0x83100194
	pc = 0x83100194; continue 'dispatch;
	// 831000E8: 387E0002  addi r3, r30, 2
	ctx.r[3].s64 = ctx.r[30].s64 + 2;
	// 831000EC: 4BFDD3C5  bl 0x830dd4b0
	ctx.lr = 0x831000F0;
	sub_830DD4B0(ctx, base);
	// 831000F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 831000F4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 831000F8: 40820024  bne 0x8310011c
	if !ctx.cr[0].eq {
	pc = 0x8310011C; continue 'dispatch;
	}
	// 831000FC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100100: 4BFDD3D9  bl 0x830dd4d8
	ctx.lr = 0x83100104;
	sub_830DD4D8(ctx, base);
	// 83100104: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 83100108: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8310010C: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 83100110: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 83100114: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 83100118: 4800007C  b 0x83100194
	pc = 0x83100194; continue 'dispatch;
	// 8310011C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 83100120: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83100124: 480A83ED  bl 0x831a8510
	ctx.lr = 0x83100128;
	sub_831A8510(ctx, base);
	// 83100128: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310012C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 83100130: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83100138: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 8310013C: 40990044  ble cr6, 0x83100180
	if !ctx.cr[6].gt {
	pc = 0x83100180; continue 'dispatch;
	}
	// 83100140: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 83100144: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100148: 38CB0002  addi r6, r11, 2
	ctx.r[6].s64 = ctx.r[11].s64 + 2;
	// 8310014C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 83100150: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 83100154: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100158: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310015C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 83100160: 7CC6502E  lwzx r6, r6, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 83100164: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83100168: B0E6FFFE  sth r7, -2(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(-2 as u32), ctx.r[7].u16 ) };
	// 8310016C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 83100170: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100174: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 83100178: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8310017C: 4198FFC8  blt cr6, 0x83100144
	if ctx.cr[6].lt {
	pc = 0x83100144; continue 'dispatch;
	}
	// 83100180: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100184: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 83100188: 4800000C  b 0x83100194
	pc = 0x83100194; continue 'dispatch;
	// 8310018C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 83100190: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 83100194: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83100198: 480A8024  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831001A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x831001A0 size=140
    let mut pc: u32 = 0x831001A0;
    'dispatch: loop {
        match pc {
            0x831001A0 => {
    //   block [0x831001A0..0x8310022C)
	// 831001A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831001A4: 480A7FC9  bl 0x831a816c
	ctx.lr = 0x831001A8;
	sub_831A8130(ctx, base);
	// 831001A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831001AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 831001B0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 831001B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 831001B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 831001BC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 831001C0: 7D5F5B96  divwu r10, r31, r11
	ctx.r[10].u32 = ctx.r[31].u32 / ctx.r[11].u32;
	// 831001C4: 0CCB0000  twi 6, r11, 0
	// 831001C8: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 831001CC: 7D6BF851  subf. r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 831001D0: 41820010  beq 0x831001e0
	if ctx.cr[0].eq {
	pc = 0x831001E0; continue 'dispatch;
	}
	// 831001D4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 831001D8: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 831001DC: 48000048  b 0x83100224
	pc = 0x83100224; continue 'dispatch;
	// 831001E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 831001E4: 4BFDD2CD  bl 0x830dd4b0
	ctx.lr = 0x831001E8;
	sub_830DD4B0(ctx, base);
	// 831001E8: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 831001EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 831001F0: 40820010  bne 0x83100200
	if !ctx.cr[0].eq {
	pc = 0x83100200; continue 'dispatch;
	}
	// 831001F4: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 831001F8: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 831001FC: 48000028  b 0x83100224
	pc = 0x83100224; continue 'dispatch;
	// 83100200: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 83100204: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83100208: 480A8309  bl 0x831a8510
	ctx.lr = 0x8310020C;
	sub_831A8510(ctx, base);
	// 8310020C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100210: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100214: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83100218: 0CCB0000  twi 6, r11, 0
	// 8310021C: 7D7F5B96  divwu r11, r31, r11
	ctx.r[11].u32 = ctx.r[31].u32 / ctx.r[11].u32;
	// 83100220: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83100224: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83100228: 480A7F94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100230 size=100
    let mut pc: u32 = 0x83100230;
    'dispatch: loop {
        match pc {
            0x83100230 => {
    //   block [0x83100230..0x83100294)
	// 83100230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83100234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83100238: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8310023C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 83100240: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 83100244: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100248: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8310024C: 7F064840  cmplw cr6, r6, r9
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83100250: 419A000C  beq cr6, 0x8310025c
	if ctx.cr[6].eq {
	pc = 0x8310025C; continue 'dispatch;
	}
	// 83100254: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100258: 4800002C  b 0x83100284
	pc = 0x83100284; continue 'dispatch;
	// 8310025C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100260: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83100264: 4098FFF0  bge cr6, 0x83100254
	if !ctx.cr[6].lt {
	pc = 0x83100254; continue 'dispatch;
	}
	// 83100268: 7D2A21D6  mullw r9, r10, r4
	ctx.r[9].s64 = (ctx.r[10].s32 as i64) * (ctx.r[4].s32 as i64);
	// 8310026C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100270: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83100274: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 83100278: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8310027C: 480A8295  bl 0x831a8510
	ctx.lr = 0x83100280;
	sub_831A8510(ctx, base);
	// 83100280: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 83100284: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83100288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8310028C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83100290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100298 size=96
    let mut pc: u32 = 0x83100298;
    'dispatch: loop {
        match pc {
            0x83100298 => {
    //   block [0x83100298..0x831002F8)
	// 83100298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310029C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 831002A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 831002A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831002A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 831002AC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 831002B0: 4BFDD229  bl 0x830dd4d8
	ctx.lr = 0x831002B4;
	sub_830DD4D8(ctx, base);
	// 831002B4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 831002B8: 4BFDD221  bl 0x830dd4d8
	ctx.lr = 0x831002BC;
	sub_830DD4D8(ctx, base);
	// 831002BC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 831002C0: 4BFDD219  bl 0x830dd4d8
	ctx.lr = 0x831002C4;
	sub_830DD4D8(ctx, base);
	// 831002C4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 831002C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 831002CC: 419A0008  beq cr6, 0x831002d4
	if ctx.cr[6].eq {
	pc = 0x831002D4; continue 'dispatch;
	}
	// 831002D0: 4BFDD209  bl 0x830dd4d8
	ctx.lr = 0x831002D4;
	sub_830DD4D8(ctx, base);
	// 831002D4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 831002D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 831002DC: 419A0008  beq cr6, 0x831002e4
	if ctx.cr[6].eq {
	pc = 0x831002E4; continue 'dispatch;
	}
	// 831002E0: 4BFDD1F9  bl 0x830dd4d8
	ctx.lr = 0x831002E4;
	sub_830DD4D8(ctx, base);
	// 831002E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 831002E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 831002EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 831002F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 831002F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831002F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x831002F8 size=40
    let mut pc: u32 = 0x831002F8;
    'dispatch: loop {
        match pc {
            0x831002F8 => {
    //   block [0x831002F8..0x83100320)
	// 831002F8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 831002FC: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 83100300: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 83100304: 419A0038  beq cr6, 0x8310033c
	if ctx.cr[6].eq {
		sub_8310033C(ctx, base);
		return;
	}
	// 83100308: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8310030C: 419A0028  beq cr6, 0x83100334
	if ctx.cr[6].eq {
		sub_83100334(ctx, base);
		return;
	}
	// 83100310: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83100314: 419A000C  beq cr6, 0x83100320
	if ctx.cr[6].eq {
		sub_83100320(ctx, base);
		return;
	}
	// 83100318: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8310031C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100320 size=20
    let mut pc: u32 = 0x83100320;
    'dispatch: loop {
        match pc {
            0x83100320 => {
    //   block [0x83100320..0x83100334)
	// 83100320: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 83100324: 81430001  lwz r10, 1(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 83100328: 7D6B2030  slw r11, r11, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 8310032C: 7D635038  and r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 83100330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100334(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100334 size=8
    let mut pc: u32 = 0x83100334;
    'dispatch: loop {
        match pc {
            0x83100334 => {
    //   block [0x83100334..0x8310033C)
	// 83100334: A1430001  lhz r10, 1(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 83100338: 48000008  b 0x83100340
	sub_8310033C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8310033C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8310033C size=20
    let mut pc: u32 = 0x8310033C;
    'dispatch: loop {
        match pc {
            0x8310033C => {
    //   block [0x8310033C..0x83100350)
	// 8310033C: 89430001  lbz r10, 1(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 83100340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 83100344: 7D6B2030  slw r11, r11, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 83100348: 7D435838  and r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 8310034C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100350 size=48
    let mut pc: u32 = 0x83100350;
    'dispatch: loop {
        match pc {
            0x83100350 => {
    //   block [0x83100350..0x83100380)
	// 83100350: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100354: 556A0031  rlwinm. r10, r11, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83100358: 41820040  beq 0x83100398
	if ctx.cr[0].eq {
		sub_83100398(ctx, base);
		return;
	}
	// 8310035C: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 83100360: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 83100364: 419A002C  beq cr6, 0x83100390
	if ctx.cr[6].eq {
		sub_83100390(ctx, base);
		return;
	}
	// 83100368: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8310036C: 419A001C  beq cr6, 0x83100388
	if ctx.cr[6].eq {
		sub_83100388(ctx, base);
		return;
	}
	// 83100370: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83100374: 419A000C  beq cr6, 0x83100380
	if ctx.cr[6].eq {
		sub_83100380(ctx, base);
		return;
	}
	// 83100378: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8310037C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100380 size=8
    let mut pc: u32 = 0x83100380;
    'dispatch: loop {
        match pc {
            0x83100380 => {
    //   block [0x83100380..0x83100388)
	// 83100380: 80630001  lwz r3, 1(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 83100384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100388 size=8
    let mut pc: u32 = 0x83100388;
    'dispatch: loop {
        match pc {
            0x83100388 => {
    //   block [0x83100388..0x83100390)
	// 83100388: A0630001  lhz r3, 1(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 8310038C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100390 size=8
    let mut pc: u32 = 0x83100390;
    'dispatch: loop {
        match pc {
            0x83100390 => {
    //   block [0x83100390..0x83100398)
	// 83100390: 88630001  lbz r3, 1(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 83100394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100398 size=8
    let mut pc: u32 = 0x83100398;
    'dispatch: loop {
        match pc {
            0x83100398 => {
    //   block [0x83100398..0x831003A0)
	// 83100398: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8310039C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831003A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x831003A0 size=216
    let mut pc: u32 = 0x831003A0;
    'dispatch: loop {
        match pc {
            0x831003A0 => {
    //   block [0x831003A0..0x83100478)
	// 831003A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831003A4: 480A7DC5  bl 0x831a8168
	ctx.lr = 0x831003A8;
	sub_831A8130(ctx, base);
	// 831003A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831003AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 831003B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 831003B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 831003B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 831003BC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 831003C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 831003C4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831003C8: 409A0010  bne cr6, 0x831003d8
	if !ctx.cr[6].eq {
	pc = 0x831003D8; continue 'dispatch;
	}
	// 831003CC: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 831003D0: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 831003D4: 48000090  b 0x83100464
	pc = 0x83100464; continue 'dispatch;
	// 831003D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 831003DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 831003E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 831003E4: 4BFCE42D  bl 0x830ce810
	ctx.lr = 0x831003E8;
	sub_830CE810(ctx, base);
	// 831003E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 831003EC: 41800078  blt 0x83100464
	if ctx.cr[0].lt {
	pc = 0x83100464; continue 'dispatch;
	}
	// 831003F0: 57DE063F  clrlwi. r30, r30, 0x18
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 831003F4: 4182004C  beq 0x83100440
	if ctx.cr[0].eq {
	pc = 0x83100440; continue 'dispatch;
	}
	// 831003F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 831003FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83100400: 4BFCE041  bl 0x830ce440
	ctx.lr = 0x83100404;
	sub_830CE440(ctx, base);
	// 83100404: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83100408: 4180005C  blt 0x83100464
	if ctx.cr[0].lt {
	pc = 0x83100464; continue 'dispatch;
	}
	// 8310040C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83100410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83100414: 419A0058  beq cr6, 0x8310046c
	if ctx.cr[6].eq {
	pc = 0x8310046C; continue 'dispatch;
	}
	// 83100418: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8310041C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 83100420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83100424: 4BFCE3ED  bl 0x830ce810
	ctx.lr = 0x83100428;
	sub_830CE810(ctx, base);
	// 83100428: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8310042C: 41800038  blt 0x83100464
	if ctx.cr[0].lt {
	pc = 0x83100464; continue 'dispatch;
	}
	// 83100430: 397E00FF  addi r11, r30, 0xff
	ctx.r[11].s64 = ctx.r[30].s64 + 255;
	// 83100434: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83100438: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8310043C: 4082FFBC  bne 0x831003f8
	if !ctx.cr[0].eq {
	pc = 0x831003F8; continue 'dispatch;
	}
	// 83100440: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83100444: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 83100448: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8310044C: 40980020  bge cr6, 0x8310046c
	if !ctx.cr[6].lt {
	pc = 0x8310046C; continue 'dispatch;
	}
	// 83100450: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83100454: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 * 48;
	// 83100458: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8310045C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100460: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100464: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 83100468: 480A7D50  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 8310046C: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 83100470: 60630007  ori r3, r3, 7
	ctx.r[3].u64 = ctx.r[3].u64 | 7;
	// 83100474: 4BFFFFF0  b 0x83100464
	pc = 0x83100464; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100478 size=92
    let mut pc: u32 = 0x83100478;
    'dispatch: loop {
        match pc {
            0x83100478 => {
    //   block [0x83100478..0x831004D4)
	// 83100478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310047C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83100480: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83100484: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83100488: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8310048C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83100490: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83100494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83100498: 4BFDD019  bl 0x830dd4b0
	ctx.lr = 0x8310049C;
	sub_830DD4B0(ctx, base);
	// 8310049C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 831004A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 831004A4: 40820010  bne 0x831004b4
	if !ctx.cr[0].eq {
	pc = 0x831004B4; continue 'dispatch;
	}
	// 831004A8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 831004AC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 831004B0: 4800000C  b 0x831004bc
	pc = 0x831004BC; continue 'dispatch;
	// 831004B4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 831004B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 831004BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 831004C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 831004C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 831004C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 831004CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 831004D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831004D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x831004D8 size=160
    let mut pc: u32 = 0x831004D8;
    'dispatch: loop {
        match pc {
            0x831004D8 => {
    //   block [0x831004D8..0x83100578)
	// 831004D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831004DC: 480A7C89  bl 0x831a8164
	ctx.lr = 0x831004E0;
	sub_831A8130(ctx, base);
	// 831004E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831004E4: 3D6005D1  lis r11, 0x5d1
	ctx.r[11].s64 = 97583104;
	// 831004E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 831004EC: 616B745D  ori r11, r11, 0x745d
	ctx.r[11].u64 = ctx.r[11].u64 | 29789;
	// 831004F0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 831004F4: 40980078  bge cr6, 0x8310056c
	if !ctx.cr[6].lt {
	pc = 0x8310056C; continue 'dispatch;
	}
	// 831004F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 831004FC: 1F64002C  mulli r27, r4, 0x2c
	ctx.r[27].s64 = ctx.r[4].s64 * 44;
	// 83100500: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 83100504: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100508: 41980064  blt cr6, 0x8310056c
	if ctx.cr[6].lt {
	pc = 0x8310056C; continue 'dispatch;
	}
	// 8310050C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 83100510: 4198005C  blt cr6, 0x8310056c
	if ctx.cr[6].lt {
	pc = 0x8310056C; continue 'dispatch;
	}
	// 83100514: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100518: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8310051C: 41990050  bgt cr6, 0x8310056c
	if ctx.cr[6].gt {
	pc = 0x8310056C; continue 'dispatch;
	}
	// 83100520: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100524: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83100528: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8310052C: 419A002C  beq cr6, 0x83100558
	if ctx.cr[6].eq {
	pc = 0x83100558; continue 'dispatch;
	}
	// 83100530: 3BFD0024  addi r31, r29, 0x24
	ctx.r[31].s64 = ctx.r[29].s64 + 36;
	// 83100534: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 83100538: 387FFFDC  addi r3, r31, -0x24
	ctx.r[3].s64 = ctx.r[31].s64 + -36;
	// 8310053C: 480028D5  bl 0x83102e10
	ctx.lr = 0x83100540;
	sub_83102E10(ctx, base);
	// 83100540: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100544: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 83100548: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 8310054C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100550: 3BFF002C  addi r31, r31, 0x2c
	ctx.r[31].s64 = ctx.r[31].s64 + 44;
	// 83100554: 4082FFE4  bne 0x83100538
	if !ctx.cr[0].eq {
	pc = 0x83100538; continue 'dispatch;
	}
	// 83100558: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8310055C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83100560: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 83100564: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83100568: 48000008  b 0x83100570
	pc = 0x83100570; continue 'dispatch;
	// 8310056C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100570: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83100574: 480A7C40  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100578 size=148
    let mut pc: u32 = 0x83100578;
    'dispatch: loop {
        match pc {
            0x83100578 => {
    //   block [0x83100578..0x8310060C)
	// 83100578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310057C: 480A7BE9  bl 0x831a8164
	ctx.lr = 0x83100580;
	sub_831A8130(ctx, base);
	// 83100580: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83100584: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 83100588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8310058C: 616BCCCC  ori r11, r11, 0xcccc
	ctx.r[11].u64 = ctx.r[11].u64 | 52428;
	// 83100590: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100594: 4098006C  bge cr6, 0x83100600
	if !ctx.cr[6].lt {
	pc = 0x83100600; continue 'dispatch;
	}
	// 83100598: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8310059C: 1F640014  mulli r27, r4, 0x14
	ctx.r[27].s64 = ctx.r[4].s64 * 20;
	// 831005A0: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 831005A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 831005A8: 41980058  blt cr6, 0x83100600
	if ctx.cr[6].lt {
	pc = 0x83100600; continue 'dispatch;
	}
	// 831005AC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 831005B0: 41980050  blt cr6, 0x83100600
	if ctx.cr[6].lt {
	pc = 0x83100600; continue 'dispatch;
	}
	// 831005B4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 831005B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 831005BC: 41990044  bgt cr6, 0x83100600
	if ctx.cr[6].gt {
	pc = 0x83100600; continue 'dispatch;
	}
	// 831005C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831005C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 831005C8: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 831005CC: 419A0020  beq cr6, 0x831005ec
	if ctx.cr[6].eq {
	pc = 0x831005EC; continue 'dispatch;
	}
	// 831005D0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 831005D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 831005D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 831005DC: 48001EDD  bl 0x831024b8
	ctx.lr = 0x831005E0;
	sub_831024B8(ctx, base);
	// 831005E0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 831005E4: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 831005E8: 4082FFF0  bne 0x831005d8
	if !ctx.cr[0].eq {
	pc = 0x831005D8; continue 'dispatch;
	}
	// 831005EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 831005F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 831005F4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 831005F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 831005FC: 48000008  b 0x83100604
	pc = 0x83100604; continue 'dispatch;
	// 83100600: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100604: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83100608: 480A7BAC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100610 size=80
    let mut pc: u32 = 0x83100610;
    'dispatch: loop {
        match pc {
            0x83100610 => {
    //   block [0x83100610..0x83100660)
	// 83100610: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 83100614: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 83100618: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 8310061C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100620: 40980040  bge cr6, 0x83100660
	if !ctx.cr[6].lt {
		sub_83100660(ctx, base);
		return;
	}
	// 83100624: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100628: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8310062C: 7D0B4A14  add r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 83100630: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100634: 4198002C  blt cr6, 0x83100660
	if ctx.cr[6].lt {
		sub_83100660(ctx, base);
		return;
	}
	// 83100638: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8310063C: 41980024  blt cr6, 0x83100660
	if ctx.cr[6].lt {
		sub_83100660(ctx, base);
		return;
	}
	// 83100640: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100644: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 83100648: 41990018  bgt cr6, 0x83100660
	if ctx.cr[6].gt {
		sub_83100660(ctx, base);
		return;
	}
	// 8310064C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100650: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 83100654: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 83100658: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8310065C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83100660 size=8
    let mut pc: u32 = 0x83100660;
    'dispatch: loop {
        match pc {
            0x83100660 => {
    //   block [0x83100660..0x83100668)
	// 83100660: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100668 size=148
    let mut pc: u32 = 0x83100668;
    'dispatch: loop {
        match pc {
            0x83100668 => {
    //   block [0x83100668..0x831006FC)
	// 83100668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310066C: 480A7AF9  bl 0x831a8164
	ctx.lr = 0x83100670;
	sub_831A8130(ctx, base);
	// 83100670: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83100674: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 83100678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8310067C: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 83100680: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100684: 4098006C  bge cr6, 0x831006f0
	if !ctx.cr[6].lt {
	pc = 0x831006F0; continue 'dispatch;
	}
	// 83100688: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8310068C: 1F64000C  mulli r27, r4, 0xc
	ctx.r[27].s64 = ctx.r[4].s64 * 12;
	// 83100690: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 83100694: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100698: 41980058  blt cr6, 0x831006f0
	if ctx.cr[6].lt {
	pc = 0x831006F0; continue 'dispatch;
	}
	// 8310069C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 831006A0: 41980050  blt cr6, 0x831006f0
	if ctx.cr[6].lt {
	pc = 0x831006F0; continue 'dispatch;
	}
	// 831006A4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 831006A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 831006AC: 41990044  bgt cr6, 0x831006f0
	if ctx.cr[6].gt {
	pc = 0x831006F0; continue 'dispatch;
	}
	// 831006B0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831006B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 831006B8: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 831006BC: 419A0020  beq cr6, 0x831006dc
	if ctx.cr[6].eq {
	pc = 0x831006DC; continue 'dispatch;
	}
	// 831006C0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 831006C4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 831006C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 831006CC: 48002B9D  bl 0x83103268
	ctx.lr = 0x831006D0;
	sub_83103268(ctx, base);
	// 831006D0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 831006D4: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 831006D8: 4082FFF0  bne 0x831006c8
	if !ctx.cr[0].eq {
	pc = 0x831006C8; continue 'dispatch;
	}
	// 831006DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 831006E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 831006E4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 831006E8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 831006EC: 48000008  b 0x831006f4
	pc = 0x831006F4; continue 'dispatch;
	// 831006F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 831006F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 831006F8: 480A7ABC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100700 size=148
    let mut pc: u32 = 0x83100700;
    'dispatch: loop {
        match pc {
            0x83100700 => {
    //   block [0x83100700..0x83100794)
	// 83100700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83100704: 480A7A61  bl 0x831a8164
	ctx.lr = 0x83100708;
	sub_831A8130(ctx, base);
	// 83100708: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8310070C: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 83100710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83100714: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 83100718: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8310071C: 4098006C  bge cr6, 0x83100788
	if !ctx.cr[6].lt {
	pc = 0x83100788; continue 'dispatch;
	}
	// 83100720: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100724: 549B2036  slwi r27, r4, 4
	ctx.r[27].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 83100728: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8310072C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100730: 41980058  blt cr6, 0x83100788
	if ctx.cr[6].lt {
	pc = 0x83100788; continue 'dispatch;
	}
	// 83100734: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 83100738: 41980050  blt cr6, 0x83100788
	if ctx.cr[6].lt {
	pc = 0x83100788; continue 'dispatch;
	}
	// 8310073C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100740: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83100744: 41990044  bgt cr6, 0x83100788
	if ctx.cr[6].gt {
	pc = 0x83100788; continue 'dispatch;
	}
	// 83100748: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310074C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83100750: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83100754: 419A0020  beq cr6, 0x83100774
	if ctx.cr[6].eq {
	pc = 0x83100774; continue 'dispatch;
	}
	// 83100758: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 8310075C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 83100760: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83100764: 48006B0D  bl 0x83107270
	ctx.lr = 0x83100768;
	sub_83107270(ctx, base);
	// 83100768: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8310076C: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 83100770: 4082FFF0  bne 0x83100760
	if !ctx.cr[0].eq {
	pc = 0x83100760; continue 'dispatch;
	}
	// 83100774: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8310077C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 83100780: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83100784: 48000008  b 0x8310078c
	pc = 0x8310078C; continue 'dispatch;
	// 83100788: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8310078C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83100790: 480A7A24  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100798 size=148
    let mut pc: u32 = 0x83100798;
    'dispatch: loop {
        match pc {
            0x83100798 => {
    //   block [0x83100798..0x8310082C)
	// 83100798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310079C: 480A79C9  bl 0x831a8164
	ctx.lr = 0x831007A0;
	sub_831A8130(ctx, base);
	// 831007A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831007A4: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 831007A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 831007AC: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 831007B0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 831007B4: 4098006C  bge cr6, 0x83100820
	if !ctx.cr[6].lt {
	pc = 0x83100820; continue 'dispatch;
	}
	// 831007B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 831007BC: 549B2834  slwi r27, r4, 5
	ctx.r[27].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 831007C0: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 831007C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 831007C8: 41980058  blt cr6, 0x83100820
	if ctx.cr[6].lt {
	pc = 0x83100820; continue 'dispatch;
	}
	// 831007CC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 831007D0: 41980050  blt cr6, 0x83100820
	if ctx.cr[6].lt {
	pc = 0x83100820; continue 'dispatch;
	}
	// 831007D4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 831007D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 831007DC: 41990044  bgt cr6, 0x83100820
	if ctx.cr[6].gt {
	pc = 0x83100820; continue 'dispatch;
	}
	// 831007E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831007E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 831007E8: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 831007EC: 419A0020  beq cr6, 0x8310080c
	if ctx.cr[6].eq {
	pc = 0x8310080C; continue 'dispatch;
	}
	// 831007F0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 831007F4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 831007F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 831007FC: 48006B0D  bl 0x83107308
	ctx.lr = 0x83100800;
	sub_83107308(ctx, base);
	// 83100800: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 83100804: 3B9C0020  addi r28, r28, 0x20
	ctx.r[28].s64 = ctx.r[28].s64 + 32;
	// 83100808: 4082FFF0  bne 0x831007f8
	if !ctx.cr[0].eq {
	pc = 0x831007F8; continue 'dispatch;
	}
	// 8310080C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83100814: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 83100818: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8310081C: 48000008  b 0x83100824
	pc = 0x83100824; continue 'dispatch;
	// 83100820: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100824: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83100828: 480A798C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100830 size=148
    let mut pc: u32 = 0x83100830;
    'dispatch: loop {
        match pc {
            0x83100830 => {
    //   block [0x83100830..0x831008C4)
	// 83100830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83100834: 480A7931  bl 0x831a8164
	ctx.lr = 0x83100838;
	sub_831A8130(ctx, base);
	// 83100838: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8310083C: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 83100840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83100844: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 83100848: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8310084C: 4098006C  bge cr6, 0x831008b8
	if !ctx.cr[6].lt {
	pc = 0x831008B8; continue 'dispatch;
	}
	// 83100850: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100854: 549B2036  slwi r27, r4, 4
	ctx.r[27].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 83100858: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8310085C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100860: 41980058  blt cr6, 0x831008b8
	if ctx.cr[6].lt {
	pc = 0x831008B8; continue 'dispatch;
	}
	// 83100864: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 83100868: 41980050  blt cr6, 0x831008b8
	if ctx.cr[6].lt {
	pc = 0x831008B8; continue 'dispatch;
	}
	// 8310086C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100870: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83100874: 41990044  bgt cr6, 0x831008b8
	if ctx.cr[6].gt {
	pc = 0x831008B8; continue 'dispatch;
	}
	// 83100878: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310087C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83100880: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83100884: 419A0020  beq cr6, 0x831008a4
	if ctx.cr[6].eq {
	pc = 0x831008A4; continue 'dispatch;
	}
	// 83100888: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 8310088C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 83100890: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83100894: 4800641D  bl 0x83106cb0
	ctx.lr = 0x83100898;
	sub_83106CB0(ctx, base);
	// 83100898: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8310089C: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 831008A0: 4082FFF0  bne 0x83100890
	if !ctx.cr[0].eq {
	pc = 0x83100890; continue 'dispatch;
	}
	// 831008A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 831008A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 831008AC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 831008B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 831008B4: 48000008  b 0x831008bc
	pc = 0x831008BC; continue 'dispatch;
	// 831008B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 831008BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 831008C0: 480A78F4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831008C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x831008C8 size=272
    let mut pc: u32 = 0x831008C8;
    'dispatch: loop {
        match pc {
            0x831008C8 => {
    //   block [0x831008C8..0x831009D8)
	// 831008C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831008CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 831008D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 831008D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 831008D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831008DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 831008E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 831008E4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 831008E8: 2F050005  cmpwi cr6, r5, 5
	ctx.cr[6].compare_i32(ctx.r[5].s32, 5, &mut ctx.xer);
	// 831008EC: 409A0060  bne cr6, 0x8310094c
	if !ctx.cr[6].eq {
	pc = 0x8310094C; continue 'dispatch;
	}
	// 831008F0: A1430000  lhz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 831008F4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 831008F8: 40820028  bne 0x83100920
	if !ctx.cr[0].eq {
	pc = 0x83100920; continue 'dispatch;
	}
	// 831008FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 83100900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83100904: 48001DD5  bl 0x831026d8
	ctx.lr = 0x83100908;
	sub_831026D8(ctx, base);
	// 83100908: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8310090C: 418000B4  blt 0x831009c0
	if ctx.cr[0].lt {
	pc = 0x831009C0; continue 'dispatch;
	}
	// 83100910: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 83100914: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100918: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8310091C: 480000A4  b 0x831009c0
	pc = 0x831009C0; continue 'dispatch;
	// 83100920: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100924: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83100928: 41990018  bgt cr6, 0x83100940
	if ctx.cr[6].gt {
	pc = 0x83100940; continue 'dispatch;
	}
	// 8310092C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100930: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 83100934: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83100938: 808BFFFC  lwz r4, -4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8310093C: 4BFFFFC4  b 0x83100900
	pc = 0x83100900; continue 'dispatch;
	// 83100940: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 83100944: 6063000D  ori r3, r3, 0xd
	ctx.r[3].u64 = ctx.r[3].u64 | 13;
	// 83100948: 48000078  b 0x831009c0
	pc = 0x831009C0; continue 'dispatch;
	// 8310094C: 2F050007  cmpwi cr6, r5, 7
	ctx.cr[6].compare_i32(ctx.r[5].s32, 7, &mut ctx.xer);
	// 83100950: 409A0038  bne cr6, 0x83100988
	if !ctx.cr[6].eq {
	pc = 0x83100988; continue 'dispatch;
	}
	// 83100954: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100958: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 8310095C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 83100960: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 83100964: 4BFFF8CD  bl 0x83100230
	ctx.lr = 0x83100968;
	sub_83100230(ctx, base);
	// 83100968: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8310096C: 4182FFD4  beq 0x83100940
	if ctx.cr[0].eq {
	pc = 0x83100940; continue 'dispatch;
	}
	// 83100970: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 83100974: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 83100978: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8310097C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100980: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100984: 4800003C  b 0x831009c0
	pc = 0x831009C0; continue 'dispatch;
	// 83100988: 2F050008  cmpwi cr6, r5, 8
	ctx.cr[6].compare_i32(ctx.r[5].s32, 8, &mut ctx.xer);
	// 8310098C: 409A0028  bne cr6, 0x831009b4
	if !ctx.cr[6].eq {
	pc = 0x831009B4; continue 'dispatch;
	}
	// 83100990: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100994: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 83100998: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 8310099C: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 831009A0: 4BFFF891  bl 0x83100230
	ctx.lr = 0x831009A4;
	sub_83100230(ctx, base);
	// 831009A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 831009A8: 4182FF98  beq 0x83100940
	if ctx.cr[0].eq {
	pc = 0x83100940; continue 'dispatch;
	}
	// 831009AC: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 831009B0: 4BFFFFC4  b 0x83100974
	pc = 0x83100974; continue 'dispatch;
	// 831009B4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 831009B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 831009BC: 4BFD1DDD  bl 0x830d2798
	ctx.lr = 0x831009C0;
	sub_830D2798(ctx, base);
	// 831009C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 831009C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 831009C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 831009CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 831009D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 831009D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831009D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x831009D8 size=604
    let mut pc: u32 = 0x831009D8;
    'dispatch: loop {
        match pc {
            0x831009D8 => {
    //   block [0x831009D8..0x83100C34)
	// 831009D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831009DC: 480A7769  bl 0x831a8144
	ctx.lr = 0x831009E0;
	sub_831A8130(ctx, base);
	// 831009E0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831009E4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 831009E8: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 831009EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 831009F0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 831009F4: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 831009F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831009FC: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 83100A00: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 83100A04: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 83100A08: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100A0C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100A10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100A14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100A18: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100A1C: 5524067E  clrlwi r4, r9, 0x19
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 83100A20: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100A24: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 83100A28: 909C0004  stw r4, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 83100A2C: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 83100A30: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100A34: 55330030  rlwinm r19, r9, 0, 0, 0x18
	ctx.r[19].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 83100A38: 4BFFFBD9  bl 0x83100610
	ctx.lr = 0x83100A3C;
	sub_83100610(ctx, base);
	// 83100A3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83100A40: 907C0008  stw r3, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 83100A44: 40820010  bne 0x83100a54
	if !ctx.cr[0].eq {
	pc = 0x83100A54; continue 'dispatch;
	}
	// 83100A48: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 83100A4C: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 83100A50: 480001DC  b 0x83100c2c
	pc = 0x83100C2C; continue 'dispatch;
	// 83100A54: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 83100A58: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 83100A5C: 3B0B8910  addi r24, r11, -0x76f0
	ctx.r[24].s64 = ctx.r[11].s64 + -30448;
	// 83100A60: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100A64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83100A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83100A6C: 419A0008  beq cr6, 0x83100a74
	if ctx.cr[6].eq {
	pc = 0x83100A74; continue 'dispatch;
	}
	// 83100A70: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100A74: 7F195000  cmpw cr6, r25, r10
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[10].s32, &mut ctx.xer);
	// 83100A78: 4098008C  bge cr6, 0x83100b04
	if !ctx.cr[6].lt {
	pc = 0x83100B04; continue 'dispatch;
	}
	// 83100A7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100A80: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 83100A84: 7D4AC9D6  mullw r10, r10, r25
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[25].s32 as i64);
	// 83100A88: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83100A8C: 3B4B0008  addi r26, r11, 8
	ctx.r[26].s64 = ctx.r[11].s64 + 8;
	// 83100A90: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100A94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83100A98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83100A9C: 419A0008  beq cr6, 0x83100aa4
	if ctx.cr[6].eq {
	pc = 0x83100AA4; continue 'dispatch;
	}
	// 83100AA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100AA4: 7F1B5000  cmpw cr6, r27, r10
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[10].s32, &mut ctx.xer);
	// 83100AA8: 40980054  bge cr6, 0x83100afc
	if !ctx.cr[6].lt {
	pc = 0x83100AFC; continue 'dispatch;
	}
	// 83100AAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100AB0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 83100AB4: 7D4AD9D6  mullw r10, r10, r27
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[27].s32 as i64);
	// 83100AB8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83100ABC: 3BAB0008  addi r29, r11, 8
	ctx.r[29].s64 = ctx.r[11].s64 + 8;
	// 83100AC0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83100AC4: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83100AC8: 480B1369  bl 0x831b1e30
	ctx.lr = 0x83100ACC;
	sub_831B1E30(ctx, base);
	// 83100ACC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83100AD0: 40820024  bne 0x83100af4
	if !ctx.cr[0].eq {
	pc = 0x83100AF4; continue 'dispatch;
	}
	// 83100AD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83100AD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83100ADC: 48006235  bl 0x83106d10
	ctx.lr = 0x83100AE0;
	sub_83106D10(ctx, base);
	// 83100AE0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 83100AE4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83100AE8: 480B1349  bl 0x831b1e30
	ctx.lr = 0x83100AEC;
	sub_831B1E30(ctx, base);
	// 83100AEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83100AF0: 41820020  beq 0x83100b10
	if ctx.cr[0].eq {
	pc = 0x83100B10; continue 'dispatch;
	}
	// 83100AF4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 83100AF8: 4BFFFF98  b 0x83100a90
	pc = 0x83100A90; continue 'dispatch;
	// 83100AFC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 83100B00: 4BFFFF60  b 0x83100a60
	pc = 0x83100A60; continue 'dispatch;
	// 83100B04: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 83100B08: 6063000D  ori r3, r3, 0xd
	ctx.r[3].u64 = ctx.r[3].u64 | 13;
	// 83100B0C: 48000120  b 0x83100c2c
	pc = 0x83100C2C; continue 'dispatch;
	// 83100B10: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100B14: 4BFD4F55  bl 0x830d5a68
	ctx.lr = 0x83100B18;
	sub_830D5A68(ctx, base);
	// 83100B18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83100B1C: 40820010  bne 0x83100b2c
	if !ctx.cr[0].eq {
	pc = 0x83100B2C; continue 'dispatch;
	}
	// 83100B20: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 83100B24: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 83100B28: 48000104  b 0x83100c2c
	pc = 0x83100C2C; continue 'dispatch;
	// 83100B2C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 83100B30: 419A0058  beq cr6, 0x83100b88
	if ctx.cr[6].eq {
	pc = 0x83100B88; continue 'dispatch;
	}
	// 83100B34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100B38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83100B3C: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 83100B40: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100B44: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100B48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100B4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100B50: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100B54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100B58: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 83100B5C: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100B60: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100B64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100B68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100B6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100B70: 4BFFF831  bl 0x831003a0
	ctx.lr = 0x83100B74;
	sub_831003A0(ctx, base);
	// 83100B74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83100B78: 418000B4  blt 0x83100c2c
	if ctx.cr[0].lt {
	pc = 0x83100C2C; continue 'dispatch;
	}
	// 83100B7C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100B80: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83100B84: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100B88: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 83100B8C: 2F150001  cmpwi cr6, r21, 1
	ctx.cr[6].compare_i32(ctx.r[21].s32, 1, &mut ctx.xer);
	// 83100B90: 4099006C  ble cr6, 0x83100bfc
	if !ctx.cr[6].gt {
	pc = 0x83100BFC; continue 'dispatch;
	}
	// 83100B94: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 83100B98: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100B9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83100BA0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 83100BA4: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 83100BA8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 83100BAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 83100BB0: 4E800421  bctrl
	ctx.lr = 0x83100BB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83100BB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100BB8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83100BBC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 83100BC0: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100BC4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100BC8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100BCC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83100BD0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83100BD4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100BD8: 4098FF2C  bge cr6, 0x83100b04
	if !ctx.cr[6].lt {
	pc = 0x83100B04; continue 'dispatch;
	}
	// 83100BDC: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100BE0: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 * 48;
	// 83100BE4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 83100BE8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 83100BEC: 7D7D512E  stwx r11, r29, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 83100BF0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 83100BF4: 7F1BA800  cmpw cr6, r27, r21
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[21].s32, &mut ctx.xer);
	// 83100BF8: 4198FFA0  blt cr6, 0x83100b98
	if ctx.cr[6].lt {
	pc = 0x83100B98; continue 'dispatch;
	}
	// 83100BFC: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 83100C00: 419A0028  beq cr6, 0x83100c28
	if ctx.cr[6].eq {
	pc = 0x83100C28; continue 'dispatch;
	}
	// 83100C04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C0C: 91740000  stw r11, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100C10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 83100C18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100C1C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C20: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83100C24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100C28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100C2C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 83100C30: 480A7564  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100C38 size=468
    let mut pc: u32 = 0x83100C38;
    'dispatch: loop {
        match pc {
            0x83100C38 => {
    //   block [0x83100C38..0x83100E0C)
	// 83100C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83100C3C: 480A7515  bl 0x831a8150
	ctx.lr = 0x83100C40;
	sub_831A8130(ctx, base);
	// 83100C40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83100C44: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 83100C48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 83100C4C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 83100C50: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 83100C54: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 83100C58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C5C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 83100C60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C64: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100C68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 83100C70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100C74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C78: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83100C7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100C80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C84: 895D0004  lbz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100C88: 714A00F9  andi. r10, r10, 0xf9
	ctx.r[10].u64 = ctx.r[10].u64 & 249;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83100C8C: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100C90: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 83100C94: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 83100C98: 997D0004  stb r11, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 83100C9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83100CA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100CA8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100CB0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100CB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CB8: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CBC: 997D0005  stb r11, 5(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(5 as u32), ctx.r[11].u8 ) };
	// 83100CC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83100CC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100CCC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100CD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100CD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CDC: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CE0: 997D0006  stb r11, 6(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[11].u8 ) };
	// 83100CE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83100CEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100CF0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100CF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100CF8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100CFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100D00: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100D04: 997D0007  stb r11, 7(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(7 as u32), ctx.r[11].u8 ) };
	// 83100D08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100D0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83100D10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100D14: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100D18: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100D1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100D20: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100D24: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 83100D28: 409900D8  ble cr6, 0x83100e00
	if !ctx.cr[6].gt {
	pc = 0x83100E00; continue 'dispatch;
	}
	// 83100D2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 83100D30: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 83100D34: 4BFFF845  bl 0x83100578
	ctx.lr = 0x83100D38;
	sub_83100578(ctx, base);
	// 83100D38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83100D3C: 907D000C  stw r3, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 83100D40: 40820010  bne 0x83100d50
	if !ctx.cr[0].eq {
	pc = 0x83100D50; continue 'dispatch;
	}
	// 83100D44: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 83100D48: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 83100D4C: 480000B8  b 0x83100e04
	pc = 0x83100E04; continue 'dispatch;
	// 83100D50: 897D0004  lbz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100D54: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 83100D58: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 83100D5C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 83100D60: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 83100D64: 997D0004  stb r11, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 83100D68: 40990098  ble cr6, 0x83100e00
	if !ctx.cr[6].gt {
	pc = 0x83100E00; continue 'dispatch;
	}
	// 83100D6C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 83100D70: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 83100D74: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 83100D78: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 83100D7C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83100D80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100D84: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83100D88: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83100D8C: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 83100D90: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83100D94: 2F05000A  cmpwi cr6, r5, 0xa
	ctx.cr[6].compare_i32(ctx.r[5].s32, 10, &mut ctx.xer);
	// 83100D98: 419A0054  beq cr6, 0x83100dec
	if ctx.cr[6].eq {
	pc = 0x83100DEC; continue 'dispatch;
	}
	// 83100D9C: 2F050009  cmpwi cr6, r5, 9
	ctx.cr[6].compare_i32(ctx.r[5].s32, 9, &mut ctx.xer);
	// 83100DA0: 419A004C  beq cr6, 0x83100dec
	if ctx.cr[6].eq {
	pc = 0x83100DEC; continue 'dispatch;
	}
	// 83100DA4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100DA8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 83100DAC: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83100DB0: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 83100DB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83100DB8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100DBC: 7CFA5A14  add r7, r26, r11
	ctx.r[7].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 83100DC0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 83100DC4: 4BFFFB05  bl 0x831008c8
	ctx.lr = 0x83100DC8;
	sub_831008C8(ctx, base);
	// 83100DC8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83100DCC: 41800038  blt 0x83100e04
	if ctx.cr[0].lt {
	pc = 0x83100E04; continue 'dispatch;
	}
	// 83100DD0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100DD4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83100DD8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83100DDC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100DE0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100DE4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83100DE8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100DEC: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 83100DF0: 3B18000C  addi r24, r24, 0xc
	ctx.r[24].s64 = ctx.r[24].s64 + 12;
	// 83100DF4: 3B5A0014  addi r26, r26, 0x14
	ctx.r[26].s64 = ctx.r[26].s64 + 20;
	// 83100DF8: 7F16E000  cmpw cr6, r22, r28
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[28].s32, &mut ctx.xer);
	// 83100DFC: 4198FF78  blt cr6, 0x83100d74
	if ctx.cr[6].lt {
	pc = 0x83100D74; continue 'dispatch;
	}
	// 83100E00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83100E04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 83100E08: 480A7398  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83100E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83100E10 size=1064
    let mut pc: u32 = 0x83100E10;
    'dispatch: loop {
        match pc {
            0x83100E10 => {
    //   block [0x83100E10..0x83101238)
	// 83100E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83100E14: 480A7335  bl 0x831a8148
	ctx.lr = 0x83100E18;
	sub_831A8130(ctx, base);
	// 83100E18: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83100E1C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 83100E20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83100E24: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 83100E28: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 83100E2C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 83100E30: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100E34: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 83100E38: 419803EC  blt cr6, 0x83101224
	if ctx.cr[6].lt {
	pc = 0x83101224; continue 'dispatch;
	}
	// 83100E3C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100E40: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 83100E44: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100E48: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100E4C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100E50: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83100E54: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83100E58: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100E5C: 4099015C  ble cr6, 0x83100fb8
	if !ctx.cr[6].gt {
	pc = 0x83100FB8; continue 'dispatch;
	}
	// 83100E60: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 83100E64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83100E68: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 83100E6C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 83100E70: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 83100E74: 4BFFF9BD  bl 0x83100830
	ctx.lr = 0x83100E78;
	sub_83100830(ctx, base);
	// 83100E78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83100E7C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 83100E80: 40820010  bne 0x83100e90
	if !ctx.cr[0].eq {
	pc = 0x83100E90; continue 'dispatch;
	}
	// 83100E84: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 83100E88: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 83100E8C: 4800039C  b 0x83101228
	pc = 0x83101228; continue 'dispatch;
	// 83100E90: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 83100E94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 83100E98: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83100E9C: 4099011C  ble cr6, 0x83100fb8
	if !ctx.cr[6].gt {
	pc = 0x83100FB8; continue 'dispatch;
	}
	// 83100EA0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83100EA4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EA8: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 83100EAC: 41980198  blt cr6, 0x83101044
	if ctx.cr[6].lt {
	pc = 0x83101044; continue 'dispatch;
	}
	// 83100EB0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EB4: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 83100EB8: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EBC: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100EC0: 7D0A4379  or. r10, r8, r8
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[8].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83100EC4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EC8: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 83100ECC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100ED0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100ED4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 83100ED8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EDC: 911C0000  stw r8, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 83100EE0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EE4: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83100EE8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100EEC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EF0: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 83100EF4: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100EF8: 911C0000  stw r8, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 83100EFC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100F00: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83100F04: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100F08: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100F0C: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 83100F10: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100F14: 909C0000  stw r4, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 83100F18: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100F1C: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 83100F20: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100F24: 4082000C  bne 0x83100f30
	if !ctx.cr[0].eq {
	pc = 0x83100F30; continue 'dispatch;
	}
	// 83100F28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83100F2C: 48000020  b 0x83100f4c
	pc = 0x83100F4C; continue 'dispatch;
	// 83100F30: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100F34: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83100F38: 4199010C  bgt cr6, 0x83101044
	if ctx.cr[6].gt {
	pc = 0x83101044; continue 'dispatch;
	}
	// 83100F3C: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100F40: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 83100F44: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83100F48: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 83100F4C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83100F50: 550B043F  clrlwi. r11, r8, 0x10
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83100F54: 7D49212E  stwx r10, r9, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 83100F58: 4082000C  bne 0x83100f64
	if !ctx.cr[0].eq {
	pc = 0x83100F64; continue 'dispatch;
	}
	// 83100F5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83100F60: 48000020  b 0x83100f80
	pc = 0x83100F80; continue 'dispatch;
	// 83100F64: 81540000  lwz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100F68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83100F6C: 419900D8  bgt cr6, 0x83101044
	if ctx.cr[6].gt {
	pc = 0x83101044; continue 'dispatch;
	}
	// 83100F70: 81540008  lwz r10, 8(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100F74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83100F78: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83100F7C: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 83100F80: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83100F84: 54C8063E  clrlwi r8, r6, 0x18
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 83100F88: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 83100F8C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 83100F90: 7F05F000  cmpw cr6, r5, r30
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[30].s32, &mut ctx.xer);
	// 83100F94: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 83100F98: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83100F9C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 83100FA0: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 83100FA4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83100FA8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 83100FAC: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 83100FB0: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 83100FB4: 4198FEF0  blt cr6, 0x83100ea4
	if ctx.cr[6].lt {
	pc = 0x83100EA4; continue 'dispatch;
	}
	// 83100FB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83100FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83100FC0: 419A0264  beq cr6, 0x83101224
	if ctx.cr[6].eq {
	pc = 0x83101224; continue 'dispatch;
	}
	// 83100FC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100FC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83100FCC: 419A0258  beq cr6, 0x83101224
	if ctx.cr[6].eq {
	pc = 0x83101224; continue 'dispatch;
	}
	// 83100FD0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100FD4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 83100FD8: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 83100FDC: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100FE0: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83100FE4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 83100FE8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83100FEC: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83100FF0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83100FF4: 4BFFF7A5  bl 0x83100798
	ctx.lr = 0x83100FF8;
	sub_83100798(ctx, base);
	// 83100FF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83100FFC: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 83101000: 4182FE84  beq 0x83100e84
	if ctx.cr[0].eq {
	pc = 0x83100E84; continue 'dispatch;
	}
	// 83101004: 92DF001C  stw r22, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[22].u32 ) };
	// 83101008: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8310100C: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 83101010: 40990214  ble cr6, 0x83101224
	if !ctx.cr[6].gt {
	pc = 0x83101224; continue 'dispatch;
	}
	// 83101014: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 83101018: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310101C: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 83101020: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101024: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83101028: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310102C: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 83101030: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83101034: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83101038: 40820018  bne 0x83101050
	if !ctx.cr[0].eq {
	pc = 0x83101050; continue 'dispatch;
	}
	// 8310103C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83101040: 4800002C  b 0x8310106c
	pc = 0x8310106C; continue 'dispatch;
	// 83101044: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 83101048: 6063000D  ori r3, r3, 0xd
	ctx.r[3].u64 = ctx.r[3].u64 | 13;
	// 8310104C: 480001DC  b 0x83101228
	pc = 0x83101228; continue 'dispatch;
	// 83101050: 81540000  lwz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101054: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83101058: 419901D8  bgt cr6, 0x83101230
	if ctx.cr[6].gt {
	pc = 0x83101230; continue 'dispatch;
	}
	// 8310105C: 81540008  lwz r10, 8(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101060: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83101064: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101068: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8310106C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 83101070: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 83101074: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 83101078: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8310107C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101080: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 83101084: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101088: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8310108C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101090: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83101094: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101098: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8310109C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831010A0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831010A4: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 831010A8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831010AC: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 831010B0: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 831010B4: 7D5E592E  stwx r10, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 831010B8: 4BFFF559  bl 0x83100610
	ctx.lr = 0x831010BC;
	sub_83100610(ctx, base);
	// 831010BC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831010C0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831010C4: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 831010C8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 831010CC: 4BFFF59D  bl 0x83100668
	ctx.lr = 0x831010D0;
	sub_83100668(ctx, base);
	// 831010D0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831010D4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831010D8: 906B000C  stw r3, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 831010DC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831010E0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831010E4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 831010E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 831010EC: 419AFD98  beq cr6, 0x83100e84
	if ctx.cr[6].eq {
	pc = 0x83100E84; continue 'dispatch;
	}
	// 831010F0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 831010F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 831010F8: 419AFD8C  beq cr6, 0x83100e84
	if ctx.cr[6].eq {
	pc = 0x83100E84; continue 'dispatch;
	}
	// 831010FC: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 83101100: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 83101104: 40990070  ble cr6, 0x83101174
	if !ctx.cr[6].gt {
	pc = 0x83101174; continue 'dispatch;
	}
	// 83101108: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8310110C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 83101110: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 83101114: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83101118: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 8310111C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 83101120: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 83101124: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 83101128: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8310112C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 83101130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83101134: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83101138: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8310113C: 7C6AD214  add r3, r10, r26
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 83101140: 4BFFF899  bl 0x831009d8
	ctx.lr = 0x83101144;
	sub_831009D8(ctx, base);
	// 83101144: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 83101148: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8310114C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83101150: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 83101154: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83101158: 7D4BC92E  stwx r10, r11, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[10].u32) };
	// 8310115C: 418000CC  blt 0x83101228
	if ctx.cr[0].lt {
	pc = 0x83101228; continue 'dispatch;
	}
	// 83101160: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 83101164: 3B5A000C  addi r26, r26, 0xc
	ctx.r[26].s64 = ctx.r[26].s64 + 12;
	// 83101168: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 8310116C: 7F18D800  cmpw cr6, r24, r27
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[27].s32, &mut ctx.xer);
	// 83101170: 4198FFA0  blt cr6, 0x83101110
	if ctx.cr[6].lt {
	pc = 0x83101110; continue 'dispatch;
	}
	// 83101174: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101178: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8310117C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 83101180: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101184: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83101188: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8310118C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101190: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83101194: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101198: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8310119C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831011A0: 936B0014  stw r27, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 831011A4: 4BFFF55D  bl 0x83100700
	ctx.lr = 0x831011A8;
	sub_83100700(ctx, base);
	// 831011A8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831011AC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831011B0: 906B0018  stw r3, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 831011B4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831011B8: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831011BC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 831011C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 831011C4: 419AFCC0  beq cr6, 0x83100e84
	if ctx.cr[6].eq {
	pc = 0x83100E84; continue 'dispatch;
	}
	// 831011C8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 831011CC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 831011D0: 40990044  ble cr6, 0x83101214
	if !ctx.cr[6].gt {
	pc = 0x83101214; continue 'dispatch;
	}
	// 831011D4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 831011D8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 831011DC: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 831011E0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 831011E4: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 831011E8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 831011EC: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 831011F0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 831011F4: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 831011F8: 4BFFFA41  bl 0x83100c38
	ctx.lr = 0x831011FC;
	sub_83100C38(ctx, base);
	// 831011FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83101200: 41800028  blt 0x83101228
	if ctx.cr[0].lt {
	pc = 0x83101228; continue 'dispatch;
	}
	// 83101204: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 83101208: 3B5A0010  addi r26, r26, 0x10
	ctx.r[26].s64 = ctx.r[26].s64 + 16;
	// 8310120C: 7F19D800  cmpw cr6, r25, r27
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[27].s32, &mut ctx.xer);
	// 83101210: 4198FFC8  blt cr6, 0x831011d8
	if ctx.cr[6].lt {
	pc = 0x831011D8; continue 'dispatch;
	}
	// 83101214: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 83101218: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 8310121C: 7F15B000  cmpw cr6, r21, r22
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[22].s32, &mut ctx.xer);
	// 83101220: 4198FDF8  blt cr6, 0x83101018
	if ctx.cr[6].lt {
	pc = 0x83101018; continue 'dispatch;
	}
	// 83101224: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83101228: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8310122C: 480A6F6C  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
	// 83101230: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 83101234: 4BFFFC54  b 0x83100e88
	pc = 0x83100E88; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83101238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83101238 size=188
    let mut pc: u32 = 0x83101238;
    'dispatch: loop {
        match pc {
            0x83101238 => {
    //   block [0x83101238..0x831012F4)
	// 83101238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310123C: 480A6F31  bl 0x831a816c
	ctx.lr = 0x83101240;
	sub_831A8130(ctx, base);
	// 83101240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83101244: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101248: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8310124C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83101250: 419A0098  beq cr6, 0x831012e8
	if ctx.cr[6].eq {
	pc = 0x831012E8; continue 'dispatch;
	}
	// 83101254: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 83101258: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 8310125C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83101260: 40980088  bge cr6, 0x831012e8
	if !ctx.cr[6].lt {
	pc = 0x831012E8; continue 'dispatch;
	}
	// 83101264: 57AA2036  slwi r10, r29, 4
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 83101268: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8310126C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 83101270: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83101274: 41980074  blt cr6, 0x831012e8
	if ctx.cr[6].lt {
	pc = 0x831012E8; continue 'dispatch;
	}
	// 83101278: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 8310127C: 4198006C  blt cr6, 0x831012e8
	if ctx.cr[6].lt {
	pc = 0x831012E8; continue 'dispatch;
	}
	// 83101280: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83101284: 41980064  blt cr6, 0x831012e8
	if ctx.cr[6].lt {
	pc = 0x831012E8; continue 'dispatch;
	}
	// 83101288: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8310128C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83101290: 41990058  bgt cr6, 0x831012e8
	if ctx.cr[6].gt {
	pc = 0x831012E8; continue 'dispatch;
	}
	// 83101294: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101298: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8310129C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 831012A0: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 831012A4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 831012A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 831012AC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 831012B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 831012B4: 7FAB492E  stwx r29, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[29].u32) };
	// 831012B8: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 831012BC: 419A0024  beq cr6, 0x831012e0
	if ctx.cr[6].eq {
	pc = 0x831012E0; continue 'dispatch;
	}
	// 831012C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 831012C4: 7D6BF1D6  mullw r11, r11, r30
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[30].s32 as i64);
	// 831012C8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 831012CC: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 831012D0: 48005A21  bl 0x83106cf0
	ctx.lr = 0x831012D4;
	sub_83106CF0(ctx, base);
	// 831012D4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 831012D8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 831012DC: 4198FFE4  blt cr6, 0x831012c0
	if ctx.cr[6].lt {
	pc = 0x831012C0; continue 'dispatch;
	}
	// 831012E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 831012E4: 48000008  b 0x831012ec
	pc = 0x831012EC; continue 'dispatch;
	// 831012E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 831012EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 831012F0: 480A6ECC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831012F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x831012F8 size=200
    let mut pc: u32 = 0x831012F8;
    'dispatch: loop {
        match pc {
            0x831012F8 => {
    //   block [0x831012F8..0x831013C0)
	// 831012F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831012FC: 480A6E6D  bl 0x831a8168
	ctx.lr = 0x83101300;
	sub_831A8130(ctx, base);
	// 83101300: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83101304: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101308: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8310130C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83101310: 419A00A4  beq cr6, 0x831013b4
	if ctx.cr[6].eq {
	pc = 0x831013B4; continue 'dispatch;
	}
	// 83101314: 3D4005D1  lis r10, 0x5d1
	ctx.r[10].s64 = 97583104;
	// 83101318: 614A745D  ori r10, r10, 0x745d
	ctx.r[10].u64 = ctx.r[10].u64 | 29789;
	// 8310131C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83101320: 40980094  bge cr6, 0x831013b4
	if !ctx.cr[6].lt {
	pc = 0x831013B4; continue 'dispatch;
	}
	// 83101324: 1D5D002C  mulli r10, r29, 0x2c
	ctx.r[10].s64 = ctx.r[29].s64 * 44;
	// 83101328: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8310132C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 83101330: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83101334: 41980080  blt cr6, 0x831013b4
	if ctx.cr[6].lt {
	pc = 0x831013B4; continue 'dispatch;
	}
	// 83101338: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 8310133C: 41980078  blt cr6, 0x831013b4
	if ctx.cr[6].lt {
	pc = 0x831013B4; continue 'dispatch;
	}
	// 83101340: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83101344: 41980070  blt cr6, 0x831013b4
	if ctx.cr[6].lt {
	pc = 0x831013B4; continue 'dispatch;
	}
	// 83101348: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8310134C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83101350: 41990064  bgt cr6, 0x831013b4
	if ctx.cr[6].gt {
	pc = 0x831013B4; continue 'dispatch;
	}
	// 83101354: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101358: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8310135C: 3900002C  li r8, 0x2c
	ctx.r[8].s64 = 44;
	// 83101360: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 83101364: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 83101368: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8310136C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83101370: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 83101374: 7FAB492E  stwx r29, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[29].u32) };
	// 83101378: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8310137C: 419A0030  beq cr6, 0x831013ac
	if ctx.cr[6].eq {
	pc = 0x831013AC; continue 'dispatch;
	}
	// 83101380: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101384: 7D6BF1D6  mullw r11, r11, r30
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[30].s32 as i64);
	// 83101388: 7F8BFA14  add r28, r11, r31
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8310138C: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 83101390: 48001A81  bl 0x83102e10
	ctx.lr = 0x83101394;
	sub_83102E10(ctx, base);
	// 83101394: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 83101398: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8310139C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 831013A0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 831013A4: 917C002C  stw r11, 0x2c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 831013A8: 4198FFD8  blt cr6, 0x83101380
	if ctx.cr[6].lt {
	pc = 0x83101380; continue 'dispatch;
	}
	// 831013AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 831013B0: 48000008  b 0x831013b8
	pc = 0x831013B8; continue 'dispatch;
	// 831013B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 831013B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 831013BC: 480A6DFC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831013C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x831013C0 size=868
    //   switch @ 0x83101644: r10 with 8 label(s)
    //       case  0  0x83101688
    //       case  1  0x83101670
    //       case  2  0x83101670
    //       case  3  0x831016A4
    //       case  4  0x83101654
    //       case  5  0x83101670
    //       case  6  0x83101670
    //       case  7  0x83101670
    let mut pc: u32 = 0x831013C0;
    'dispatch: loop {
        match pc {
            0x831013C0 => {
    //   block [0x831013C0..0x83101654)
	// 831013C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831013C4: 480A6D71  bl 0x831a8134
	ctx.lr = 0x831013C8;
	sub_831A8130(ctx, base);
	// 831013C8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831013CC: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 831013D0: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 831013D4: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 831013D8: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 831013DC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 831013E0: 92760000  stw r19, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 831013E4: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 831013E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 831013EC: 7D6F5B78  mr r15, r11
	ctx.r[15].u64 = ctx.r[11].u64;
	// 831013F0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 831013F4: 554A077E  clrlwi r10, r10, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 831013F8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 831013FC: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 83101400: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83101404: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 83101408: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8310140C: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 83101410: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101414: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101418: 5529077E  clrlwi r9, r9, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 8310141C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 83101420: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83101424: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83101428: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310142C: 556B077F  clrlwi. r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83101430: 418202DC  beq 0x8310170c
	if ctx.cr[0].eq {
	pc = 0x8310170C; continue 'dispatch;
	}
	// 83101434: 7E709B78  mr r16, r19
	ctx.r[16].u64 = ctx.r[19].u64;
	// 83101438: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 8310143C: 419A02D0  beq cr6, 0x8310170c
	if ctx.cr[6].eq {
	pc = 0x8310170C; continue 'dispatch;
	}
	// 83101440: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 83101444: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 83101448: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8310144C: 4BFFEEAD  bl 0x831002f8
	ctx.lr = 0x83101450;
	sub_831002F8(ctx, base);
	// 83101450: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83101454: 418202A8  beq 0x831016fc
	if ctx.cr[0].eq {
	pc = 0x831016FC; continue 'dispatch;
	}
	// 83101458: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310145C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 83101460: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83101464: 4182005C  beq 0x831014c0
	if ctx.cr[0].eq {
	pc = 0x831014C0; continue 'dispatch;
	}
	// 83101468: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310146C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101470: 556A0031  rlwinm. r10, r11, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83101474: 41820010  beq 0x83101484
	if ctx.cr[0].eq {
	pc = 0x83101484; continue 'dispatch;
	}
	// 83101478: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8310147C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83101480: 48000008  b 0x83101488
	pc = 0x83101488; continue 'dispatch;
	// 83101484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 83101488: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 8310148C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101490: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101494: 556A0031  rlwinm. r10, r11, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83101498: 41820010  beq 0x831014a8
	if ctx.cr[0].eq {
	pc = 0x831014A8; continue 'dispatch;
	}
	// 8310149C: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 831014A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 831014A4: 48000008  b 0x831014ac
	pc = 0x831014AC; continue 'dispatch;
	// 831014A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 831014AC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 831014B0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 831014B4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831014B8: 4BFFEE99  bl 0x83100350
	ctx.lr = 0x831014BC;
	sub_83100350(ctx, base);
	// 831014BC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 831014C0: 7E7A9B78  mr r26, r19
	ctx.r[26].u64 = ctx.r[19].u64;
	// 831014C4: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 831014C8: 419A0234  beq cr6, 0x831016fc
	if ctx.cr[6].eq {
	pc = 0x831016FC; continue 'dispatch;
	}
	// 831014CC: 56AB2036  slwi r11, r21, 4
	ctx.r[11].u32 = ctx.r[21].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 831014D0: 7D6B9214  add r11, r11, r18
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 831014D4: 3B6B0004  addi r27, r11, 4
	ctx.r[27].s64 = ctx.r[11].s64 + 4;
	// 831014D8: 7E7F9B78  mr r31, r19
	ctx.r[31].u64 = ctx.r[19].u64;
	// 831014DC: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 831014E0: 419A0014  beq cr6, 0x831014f4
	if ctx.cr[6].eq {
	pc = 0x831014F4; continue 'dispatch;
	}
	// 831014E4: 92FB0000  stw r23, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 831014E8: 3BFBFFFC  addi r31, r27, -4
	ctx.r[31].s64 = ctx.r[27].s64 + -4;
	// 831014EC: 933B0008  stw r25, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 831014F0: B35BFFFE  sth r26, -2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(-2 as u32), ctx.r[26].u16 ) };
	// 831014F4: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 831014F8: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 831014FC: 409A00C4  bne cr6, 0x831015c0
	if !ctx.cr[6].eq {
	pc = 0x831015C0; continue 'dispatch;
	}
	// 83101500: 81770028  lwz r11, 0x28(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(40 as u32) ) } as u64;
	// 83101504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83101508: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8310150C: 4E800421  bctrl
	ctx.lr = 0x83101510;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83101510: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101514: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83101518: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8310151C: 392B0002  addi r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 2;
	// 83101520: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83101524: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101528: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8310152C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101530: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 83101534: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101538: 419A0030  beq cr6, 0x83101568
	if ctx.cr[6].eq {
	pc = 0x83101568; continue 'dispatch;
	}
	// 8310153C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83101540: 419A0028  beq cr6, 0x83101568
	if ctx.cr[6].eq {
	pc = 0x83101568; continue 'dispatch;
	}
	// 83101544: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101548: 5544043E  clrlwi r4, r10, 0x10
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 8310154C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 83101550: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 83101554: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 83101558: 4BFFFCE1  bl 0x83101238
	ctx.lr = 0x8310155C;
	sub_83101238(ctx, base);
	// 8310155C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 83101560: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83101564: 418201B4  beq 0x83101718
	if ctx.cr[0].eq {
	pc = 0x83101718; continue 'dispatch;
	}
	// 83101568: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8310156C: 92610054  stw r19, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[19].u32 ) };
	// 83101570: 419A0010  beq cr6, 0x83101580
	if ctx.cr[6].eq {
	pc = 0x83101580; continue 'dispatch;
	}
	// 83101574: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101578: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 8310157C: 48000008  b 0x83101584
	pc = 0x83101584; continue 'dispatch;
	// 83101580: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 83101584: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 83101588: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8310158C: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 83101590: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 83101594: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 83101598: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 8310159C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 831015A0: 4BFFFE21  bl 0x831013c0
	ctx.lr = 0x831015A4;
	sub_831013C0(ctx, base);
	// 831015A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 831015A8: 41800168  blt 0x83101710
	if ctx.cr[0].lt {
	pc = 0x83101710; continue 'dispatch;
	}
	// 831015AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 831015B0: 419A012C  beq cr6, 0x831016dc
	if ctx.cr[6].eq {
	pc = 0x831016DC; continue 'dispatch;
	}
	// 831015B4: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831015B8: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 831015BC: 48000058  b 0x83101614
	pc = 0x83101614; continue 'dispatch;
	// 831015C0: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 831015C4: 409A0058  bne cr6, 0x8310161c
	if !ctx.cr[6].eq {
	pc = 0x8310161C; continue 'dispatch;
	}
	// 831015C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 831015CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 831015D0: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 831015D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 831015D8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 831015DC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 831015E0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 831015E4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831015E8: 419A00F4  beq cr6, 0x831016dc
	if ctx.cr[6].eq {
	pc = 0x831016DC; continue 'dispatch;
	}
	// 831015EC: 81790028  lwz r11, 0x28(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 831015F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 831015F4: 91790028  stw r11, 0x28(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 831015F8: A13F0000  lhz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831015FC: 933F000C  stw r25, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 83101600: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 83101604: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101608: 712AFFE8  andi. r10, r9, 0xffe8
	ctx.r[10].u64 = ctx.r[9].u64 & 65512;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8310160C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83101610: 614B0012  ori r11, r10, 0x12
	ctx.r[11].u64 = ctx.r[10].u64 | 18;
	// 83101614: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 83101618: 480000C4  b 0x831016dc
	pc = 0x831016DC; continue 'dispatch;
	// 8310161C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 83101620: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 83101624: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 83101628: 4199009C  bgt cr6, 0x831016c4
	if ctx.cr[6].gt {
	pc = 0x831016C4; continue 'dispatch;
	}
	// 8310162C: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 83101630: 398C9770  addi r12, r12, -0x6890
	ctx.r[12].s64 = ctx.r[12].s64 + -26768;
	// 83101634: 7C0C50AE  lbzx r0, r12, r10
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 83101638: 3D808310  lis r12, -0x7cf0
	ctx.r[12].s64 = -2096103424;
	// 8310163C: 398C1654  addi r12, r12, 0x1654
	ctx.r[12].s64 = ctx.r[12].s64 + 5716;
	// 83101640: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 83101644: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 83101648: 60000000  nop
	// 8310164C: 60000000  nop
	// 83101650: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x83101654 => {
    //   block [0x83101654..0x83101670)
	// 83101654: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83101658: 419A0010  beq cr6, 0x83101668
	if ctx.cr[6].eq {
	pc = 0x83101668; continue 'dispatch;
	}
	// 8310165C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101660: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101664: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83101668: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8310166C: 48000058  b 0x831016c4
	pc = 0x831016C4; continue 'dispatch;
            }
            0x83101670 => {
    //   block [0x83101670..0x83101688)
	// 83101670: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83101674: 419A004C  beq cr6, 0x831016c0
	if ctx.cr[6].eq {
	pc = 0x831016C0; continue 'dispatch;
	}
	// 83101678: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310167C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101680: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83101684: 4800003C  b 0x831016c0
	pc = 0x831016C0; continue 'dispatch;
            }
            0x83101688 => {
    //   block [0x83101688..0x831016A4)
	// 83101688: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8310168C: 419A0010  beq cr6, 0x8310169c
	if ctx.cr[6].eq {
	pc = 0x8310169C; continue 'dispatch;
	}
	// 83101690: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101694: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101698: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8310169C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 831016A0: 48000024  b 0x831016c4
	pc = 0x831016C4; continue 'dispatch;
            }
            0x831016A4 => {
    //   block [0x831016A4..0x83101724)
	// 831016A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 831016A8: 419A0018  beq cr6, 0x831016c0
	if ctx.cr[6].eq {
	pc = 0x831016C0; continue 'dispatch;
	}
	// 831016AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 831016B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 831016B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 831016B8: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 831016BC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 831016C0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 831016C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 831016C8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 831016CC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 831016D0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 831016D4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 831016D8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831016DC: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 831016E0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 831016E4: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 831016E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 831016EC: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 831016F0: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831016F4: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 831016F8: 4198FDE0  blt cr6, 0x831014d8
	if ctx.cr[6].lt {
	pc = 0x831014D8; continue 'dispatch;
	}
	// 831016FC: 3A100001  addi r16, r16, 1
	ctx.r[16].s64 = ctx.r[16].s64 + 1;
	// 83101700: 3AF70030  addi r23, r23, 0x30
	ctx.r[23].s64 = ctx.r[23].s64 + 48;
	// 83101704: 7F108840  cmplw cr6, r16, r17
	ctx.cr[6].compare_u32(ctx.r[16].u32, ctx.r[17].u32, &mut ctx.xer);
	// 83101708: 4198FD3C  blt cr6, 0x83101444
	if ctx.cr[6].lt {
	pc = 0x83101444; continue 'dispatch;
	}
	// 8310170C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83101710: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 83101714: 480A6A70  b 0x831a8184
	sub_831A8180(ctx, base);
	return;
	// 83101718: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8310171C: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 83101720: 4BFFFFF0  b 0x83101710
	pc = 0x83101710; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83101728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83101728 size=244
    let mut pc: u32 = 0x83101728;
    'dispatch: loop {
        match pc {
            0x83101728 => {
    //   block [0x83101728..0x8310181C)
	// 83101728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310172C: 480A6A2D  bl 0x831a8158
	ctx.lr = 0x83101730;
	sub_831A8130(ctx, base);
	// 83101730: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83101734: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 83101738: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8310173C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83101740: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 83101744: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 83101748: 931A0000  stw r24, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 8310174C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 83101750: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 83101754: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 83101758: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 8310175C: 4BFCCCE5  bl 0x830ce440
	ctx.lr = 0x83101760;
	sub_830CE440(ctx, base);
	// 83101760: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83101764: 418000B0  blt 0x83101814
	if ctx.cr[0].lt {
	pc = 0x83101814; continue 'dispatch;
	}
	// 83101768: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8310176C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83101770: 419A0048  beq cr6, 0x831017b8
	if ctx.cr[6].eq {
	pc = 0x831017B8; continue 'dispatch;
	}
	// 83101774: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 83101778: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 8310177C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 83101780: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 83101784: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 83101788: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8310178C: 4BFFFF9D  bl 0x83101728
	ctx.lr = 0x83101790;
	sub_83101728(ctx, base);
	// 83101790: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83101794: 41800080  blt 0x83101814
	if ctx.cr[0].lt {
	pc = 0x83101814; continue 'dispatch;
	}
	// 83101798: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8310179C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 831017A0: 419A000C  beq cr6, 0x831017ac
	if ctx.cr[6].eq {
	pc = 0x831017AC; continue 'dispatch;
	}
	// 831017A4: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 831017A8: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 831017AC: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 831017B0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 831017B4: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831017B8: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 831017BC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 831017C0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 831017C4: 4BFCD04D  bl 0x830ce810
	ctx.lr = 0x831017C8;
	sub_830CE810(ctx, base);
	// 831017C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 831017CC: 41800048  blt 0x83101814
	if ctx.cr[0].lt {
	pc = 0x83101814; continue 'dispatch;
	}
	// 831017D0: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 831017D4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 831017D8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 831017DC: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 831017E0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 831017E4: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 831017E8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 831017EC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 831017F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 831017F4: 4BFFFBCD  bl 0x831013c0
	ctx.lr = 0x831017F8;
	sub_831013C0(ctx, base);
	// 831017F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 831017FC: 41800018  blt 0x83101814
	if ctx.cr[0].lt {
	pc = 0x83101814; continue 'dispatch;
	}
	// 83101800: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101804: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83101808: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8310180C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101810: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101814: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 83101818: 480A6990  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83101820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83101820 size=112
    let mut pc: u32 = 0x83101820;
    'dispatch: loop {
        match pc {
            0x83101820 => {
    //   block [0x83101820..0x83101890)
	// 83101820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83101824: 480A6945  bl 0x831a8168
	ctx.lr = 0x83101828;
	sub_831A8130(ctx, base);
	// 83101828: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8310182C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83101830: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 83101834: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8310183C: 419A0044  beq cr6, 0x83101880
	if ctx.cr[6].eq {
	pc = 0x83101880; continue 'dispatch;
	}
	// 83101840: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101844: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 83101848: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8310184C: 40990028  ble cr6, 0x83101874
	if !ctx.cr[6].gt {
	pc = 0x83101874; continue 'dispatch;
	}
	// 83101850: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 83101854: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101858: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 8310185C: 4800565D  bl 0x83106eb8
	ctx.lr = 0x83101860;
	sub_83106EB8(ctx, base);
	// 83101860: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101864: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 83101868: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8310186C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 83101870: 4198FFE4  blt cr6, 0x83101854
	if ctx.cr[6].lt {
	pc = 0x83101854; continue 'dispatch;
	}
	// 83101874: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101878: 4BFDBC61  bl 0x830dd4d8
	ctx.lr = 0x8310187C;
	sub_830DD4D8(ctx, base);
	// 8310187C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 83101880: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 83101884: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 83101888: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8310188C: 480A692C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83101890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83101890 size=656
    let mut pc: u32 = 0x83101890;
    'dispatch: loop {
        match pc {
            0x83101890 => {
    //   block [0x83101890..0x83101B20)
	// 83101890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83101894: 480A68C1  bl 0x831a8154
	ctx.lr = 0x83101898;
	sub_831A8130(ctx, base);
	// 83101898: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8310189C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 831018A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 831018A4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 831018A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 831018AC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 831018B0: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 831018B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 831018B8: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 831018BC: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 831018C0: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 831018C4: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 831018C8: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 831018CC: 9B61006C  stb r27, 0x6c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u8 ) };
	// 831018D0: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 831018D4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 831018D8: 7D2A4B79  or. r10, r9, r9
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 831018DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831018E0: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 831018E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831018E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 831018EC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 831018F0: 8AEB0000  lbz r23, 0(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 831018F4: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 831018F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831018FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83101900: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101904: 41820028  beq 0x8310192c
	if ctx.cr[0].eq {
	pc = 0x8310192C; continue 'dispatch;
	}
	// 83101908: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8310190C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83101910: 41990038  bgt cr6, 0x83101948
	if ctx.cr[6].gt {
	pc = 0x83101948; continue 'dispatch;
	}
	// 83101914: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101918: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8310191C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83101920: 832BFFFC  lwz r25, -4(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 83101924: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 83101928: 409A0034  bne cr6, 0x8310195c
	if !ctx.cr[6].eq {
	pc = 0x8310195C; continue 'dispatch;
	}
	// 8310192C: 3F808030  lis r28, -0x7fd0
	ctx.r[28].s64 = -2144337920;
	// 83101930: 639C000E  ori r28, r28, 0xe
	ctx.r[28].u64 = ctx.r[28].u64 | 14;
	// 83101934: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83101938: 4BFFFEE9  bl 0x83101820
	ctx.lr = 0x8310193C;
	sub_83101820(ctx, base);
	// 8310193C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83101940: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 83101944: 480A6860  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
	// 83101948: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8310194C: 4BFFFED5  bl 0x83101820
	ctx.lr = 0x83101950;
	sub_83101820(ctx, base);
	// 83101950: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 83101954: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 83101958: 4BFFFFE8  b 0x83101940
	pc = 0x83101940; continue 'dispatch;
	// 8310195C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 83101960: 4BFD4109  bl 0x830d5a68
	ctx.lr = 0x83101964;
	sub_830D5A68(ctx, base);
	// 83101964: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 83101968: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8310196C: 4082004C  bne 0x831019b8
	if !ctx.cr[0].eq {
	pc = 0x831019B8; continue 'dispatch;
	}
	// 83101970: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 83101974: 806BC18C  lwz r3, -0x3e74(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15988 as u32) ) } as u64;
	// 83101978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8310197C: 419A0030  beq cr6, 0x831019ac
	if ctx.cr[6].eq {
	pc = 0x831019AC; continue 'dispatch;
	}
	// 83101980: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101984: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83101988: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8310198C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 83101994: 4E800421  bctrl
	ctx.lr = 0x83101998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83101998: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8310199C: 41800010  blt 0x831019ac
	if ctx.cr[0].lt {
	pc = 0x831019AC; continue 'dispatch;
	}
	// 831019A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 831019A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 831019A8: 409A0010  bne cr6, 0x831019b8
	if !ctx.cr[6].eq {
	pc = 0x831019B8; continue 'dispatch;
	}
	// 831019AC: 3F808030  lis r28, -0x7fd0
	ctx.r[28].s64 = -2144337920;
	// 831019B0: 639C0004  ori r28, r28, 4
	ctx.r[28].u64 = ctx.r[28].u64 | 4;
	// 831019B4: 4BFFFF80  b 0x83101934
	pc = 0x83101934; continue 'dispatch;
	// 831019B8: 56EB07FF  clrlwi. r11, r23, 0x1f
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 831019BC: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 831019C0: 56F7063E  clrlwi r23, r23, 0x18
	ctx.r[23].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 831019C4: 41820084  beq 0x83101a48
	if ctx.cr[0].eq {
	pc = 0x83101A48; continue 'dispatch;
	}
	// 831019C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 831019CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 831019D0: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 831019D4: A32B0000  lhz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 831019D8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 831019DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 831019E0: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 831019E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 831019E8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 831019EC: 4BFFF84D  bl 0x83101238
	ctx.lr = 0x831019F0;
	sub_83101238(ctx, base);
	// 831019F0: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 831019F4: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 831019F8: 4082000C  bne 0x83101a04
	if !ctx.cr[0].eq {
	pc = 0x83101A04; continue 'dispatch;
	}
	// 831019FC: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 83101A00: 4BFFFF30  b 0x83101930
	pc = 0x83101930; continue 'dispatch;
	// 83101A04: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 83101A08: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 83101A0C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 83101A10: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101A14: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 83101A18: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 83101A1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 83101A20: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 83101A24: 4BFFFD05  bl 0x83101728
	ctx.lr = 0x83101A28;
	sub_83101728(ctx, base);
	// 83101A28: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 83101A2C: 4180FF08  blt 0x83101934
	if ctx.cr[0].lt {
	pc = 0x83101934; continue 'dispatch;
	}
	// 83101A30: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83101A34: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 83101A38: 419A0010  beq cr6, 0x83101a48
	if ctx.cr[6].eq {
	pc = 0x83101A48; continue 'dispatch;
	}
	// 83101A3C: 3F808030  lis r28, -0x7fd0
	ctx.r[28].s64 = -2144337920;
	// 83101A40: 639C000D  ori r28, r28, 0xd
	ctx.r[28].u64 = ctx.r[28].u64 | 13;
	// 83101A44: 4BFFFEF0  b 0x83101934
	pc = 0x83101934; continue 'dispatch;
	// 83101A48: 56EB07BD  rlwinm. r11, r23, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83101A4C: 418200AC  beq 0x83101af8
	if ctx.cr[0].eq {
	pc = 0x83101AF8; continue 'dispatch;
	}
	// 83101A50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101A54: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 83101A58: 4198FFE4  blt cr6, 0x83101a3c
	if ctx.cr[6].lt {
	pc = 0x83101A3C; continue 'dispatch;
	}
	// 83101A5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101A60: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 83101A64: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101A68: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83101A6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101A70: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 83101A74: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 83101A78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101A7C: 419A007C  beq cr6, 0x83101af8
	if ctx.cr[6].eq {
	pc = 0x83101AF8; continue 'dispatch;
	}
	// 83101A80: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 83101A84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 83101A88: 4BFFF871  bl 0x831012f8
	ctx.lr = 0x83101A8C;
	sub_831012F8(ctx, base);
	// 83101A8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83101A90: 90780008  stw r3, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 83101A94: 4182FF68  beq 0x831019fc
	if ctx.cr[0].eq {
	pc = 0x831019FC; continue 'dispatch;
	}
	// 83101A98: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 83101A9C: 419A005C  beq cr6, 0x83101af8
	if ctx.cr[6].eq {
	pc = 0x83101AF8; continue 'dispatch;
	}
	// 83101AA0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101AA4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 83101AA8: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 83101AAC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 83101AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83101AB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83101AB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83101ABC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101AC0: 915D0028  stw r10, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 83101AC4: 7D49D9D6  mullw r10, r9, r27
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[27].s32 as i64);
	// 83101AC8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83101ACC: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 83101AD0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 83101AD4: 614A0004  ori r10, r10, 4
	ctx.r[10].u64 = ctx.r[10].u64 | 4;
	// 83101AD8: 93AB0030  stw r29, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 83101ADC: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 83101AE0: 4BFFFDB1  bl 0x83101890
	ctx.lr = 0x83101AE4;
	sub_83101890(ctx, base);
	// 83101AE4: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 83101AE8: 4180FE4C  blt 0x83101934
	if ctx.cr[0].lt {
	pc = 0x83101934; continue 'dispatch;
	}
	// 83101AEC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 83101AF0: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	// 83101AF4: 4198FFAC  blt cr6, 0x83101aa0
	if ctx.cr[6].lt {
	pc = 0x83101AA0; continue 'dispatch;
	}
	// 83101AF8: 56EB077B  rlwinm. r11, r23, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83101AFC: 4182FE38  beq 0x83101934
	if ctx.cr[0].eq {
	pc = 0x83101934; continue 'dispatch;
	}
	// 83101B00: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 83101B04: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 83101B08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 83101B0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83101B10: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 83101B14: 4BFFF2FD  bl 0x83100e10
	ctx.lr = 0x83101B18;
	sub_83100E10(ctx, base);
	// 83101B18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83101B1C: 4BFFFE18  b 0x83101934
	pc = 0x83101934; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83101B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83101B20 size=1140
    let mut pc: u32 = 0x83101B20;
    'dispatch: loop {
        match pc {
            0x83101B20 => {
    //   block [0x83101B20..0x83101F94)
	// 83101B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83101B24: 480A6631  bl 0x831a8154
	ctx.lr = 0x83101B28;
	sub_831A8130(ctx, base);
	// 83101B28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83101B2C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 83101B30: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 83101B34: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 83101B38: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 83101B3C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 83101B40: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 83101B44: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 83101B48: 93170000  stw r24, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 83101B4C: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 83101B50: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 83101B54: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 83101B58: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 83101B5C: 9301006C  stw r24, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[24].u32 ) };
	// 83101B60: 93010070  stw r24, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[24].u32 ) };
	// 83101B64: 4BFDCAA5  bl 0x830de608
	ctx.lr = 0x83101B68;
	sub_830DE608(ctx, base);
	// 83101B68: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101B6C: 41800398  blt 0x83101f04
	if ctx.cr[0].lt {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101B70: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83101B74: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83101B78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83101B7C: 419A0024  beq cr6, 0x83101ba0
	if ctx.cr[6].eq {
	pc = 0x83101BA0; continue 'dispatch;
	}
	// 83101B80: 4BFDBD79  bl 0x830dd8f8
	ctx.lr = 0x83101B84;
	sub_830DD8F8(ctx, base);
	// 83101B84: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 83101B88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83101B8C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83101B90: 4BFDBC99  bl 0x830dd828
	ctx.lr = 0x83101B94;
	sub_830DD828(ctx, base);
	// 83101B94: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101B98: 4180036C  blt 0x83101f04
	if ctx.cr[0].lt {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101B9C: 48000024  b 0x83101bc0
	pc = 0x83101BC0; continue 'dispatch;
	// 83101BA0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 83101BA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83101BA8: 4BFDBE01  bl 0x830dd9a8
	ctx.lr = 0x83101BAC;
	sub_830DD9A8(ctx, base);
	// 83101BAC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101BB0: 41800354  blt 0x83101f04
	if ctx.cr[0].lt {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101BB4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83101BB8: 4BFDBD89  bl 0x830dd940
	ctx.lr = 0x83101BBC;
	sub_830DD940(ctx, base);
	// 83101BBC: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 83101BC0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101BC4: 3D405855  lis r10, 0x5855
	ctx.r[10].s64 = 1481965568;
	// 83101BC8: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 83101BCC: 39640014  addi r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 + 20;
	// 83101BD0: 614A4942  ori r10, r10, 0x4942
	ctx.r[10].u64 = ctx.r[10].u64 | 18754;
	// 83101BD4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83101BD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83101BDC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101BE0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83101BE4: 419A0010  beq cr6, 0x83101bf4
	if ctx.cr[6].eq {
	pc = 0x83101BF4; continue 'dispatch;
	}
	// 83101BE8: 3FC08030  lis r30, -0x7fd0
	ctx.r[30].s64 = -2144337920;
	// 83101BEC: 63DE000D  ori r30, r30, 0xd
	ctx.r[30].u64 = ctx.r[30].u64 | 13;
	// 83101BF0: 48000318  b 0x83101f08
	pc = 0x83101F08; continue 'dispatch;
	// 83101BF4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101BF8: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 83101BFC: 409AFFEC  bne cr6, 0x83101be8
	if !ctx.cr[6].eq {
	pc = 0x83101BE8; continue 'dispatch;
	}
	// 83101C00: A144000C  lhz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 83101C04: 2B0A000C  cmplwi cr6, r10, 0xc
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12 as u32, &mut ctx.xer);
	// 83101C08: 409AFFE0  bne cr6, 0x83101be8
	if !ctx.cr[6].eq {
	pc = 0x83101BE8; continue 'dispatch;
	}
	// 83101C0C: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101C10: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83101C14: 41820078  beq 0x83101c8c
	if ctx.cr[0].eq {
	pc = 0x83101C8C; continue 'dispatch;
	}
	// 83101C18: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 83101C1C: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 83101C20: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83101C24: 80A90018  lwz r5, 0x18(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 83101C28: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 83101C2C: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101C30: 80C90024  lwz r6, 0x24(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 83101C34: 80E90008  lwz r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101C38: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 83101C3C: 1D080005  mulli r8, r8, 5
	ctx.r[8].s64 = ctx.r[8].s64 * 5;
	// 83101C40: 81490010  lwz r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 83101C44: 81690020  lwz r11, 0x20(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 83101C48: 83C90000  lwz r30, 0(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101C4C: 8129001C  lwz r9, 0x1c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 83101C50: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83101C54: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 83101C58: 1D3E000B  mulli r9, r30, 0xb
	ctx.r[9].s64 = ctx.r[30].s64 * 11;
	// 83101C5C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 83101C60: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 83101C64: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 83101C68: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83101C6C: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 83101C70: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 83101C74: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83101C78: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 83101C7C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 83101C80: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101C84: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 83101C88: 48000008  b 0x83101c90
	pc = 0x83101C90; continue 'dispatch;
	// 83101C8C: 38804000  li r4, 0x4000
	ctx.r[4].s64 = 16384;
	// 83101C90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 83101C94: 4BFFE7E5  bl 0x83100478
	ctx.lr = 0x83101C98;
	sub_83100478(ctx, base);
	// 83101C98: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101C9C: 41800268  blt 0x83101f04
	if ctx.cr[0].lt {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101CA0: 817F000E  lwz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 83101CA4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 83101CA8: 409A0254  bne cr6, 0x83101efc
	if !ctx.cr[6].eq {
	pc = 0x83101EFC; continue 'dispatch;
	}
	// 83101CAC: A15F0012  lhz r10, 0x12(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 83101CB0: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 83101CB4: 41980248  blt cr6, 0x83101efc
	if ctx.cr[6].lt {
	pc = 0x83101EFC; continue 'dispatch;
	}
	// 83101CB8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83101CBC: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 83101CC0: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 83101CC4: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 83101CC8: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 83101CCC: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 83101CD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83101CD4: 419A0230  beq cr6, 0x83101f04
	if ctx.cr[6].eq {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101CD8: 3D004355  lis r8, 0x4355
	ctx.r[8].s64 = 1129644032;
	// 83101CDC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101CE0: 61085354  ori r8, r8, 0x5354
	ctx.r[8].u64 = ctx.r[8].u64 | 21332;
	// 83101CE4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83101CE8: 419A0064  beq cr6, 0x83101d4c
	if ctx.cr[6].eq {
	pc = 0x83101D4C; continue 'dispatch;
	}
	// 83101CEC: 3D004441  lis r8, 0x4441
	ctx.r[8].s64 = 1145110528;
	// 83101CF0: 61085441  ori r8, r8, 0x5441
	ctx.r[8].u64 = ctx.r[8].u64 | 21569;
	// 83101CF4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83101CF8: 419A004C  beq cr6, 0x83101d44
	if ctx.cr[6].eq {
	pc = 0x83101D44; continue 'dispatch;
	}
	// 83101CFC: 3D005155  lis r8, 0x5155
	ctx.r[8].s64 = 1364525056;
	// 83101D00: 61084154  ori r8, r8, 0x4154
	ctx.r[8].u64 = ctx.r[8].u64 | 16724;
	// 83101D04: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83101D08: 419A0034  beq cr6, 0x83101d3c
	if ctx.cr[6].eq {
	pc = 0x83101D3C; continue 'dispatch;
	}
	// 83101D0C: 3D005354  lis r8, 0x5354
	ctx.r[8].s64 = 1398013952;
	// 83101D10: 6108524E  ori r8, r8, 0x524e
	ctx.r[8].u64 = ctx.r[8].u64 | 21070;
	// 83101D14: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83101D18: 419A001C  beq cr6, 0x83101d34
	if ctx.cr[6].eq {
	pc = 0x83101D34; continue 'dispatch;
	}
	// 83101D1C: 3D005645  lis r8, 0x5645
	ctx.r[8].s64 = 1447362560;
	// 83101D20: 61084354  ori r8, r8, 0x4354
	ctx.r[8].u64 = ctx.r[8].u64 | 17236;
	// 83101D24: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83101D28: 409A0028  bne cr6, 0x83101d50
	if !ctx.cr[6].eq {
	pc = 0x83101D50; continue 'dispatch;
	}
	// 83101D2C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 83101D30: 48000020  b 0x83101d50
	pc = 0x83101D50; continue 'dispatch;
	// 83101D34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83101D38: 48000018  b 0x83101d50
	pc = 0x83101D50; continue 'dispatch;
	// 83101D3C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 83101D40: 48000010  b 0x83101d50
	pc = 0x83101D50; continue 'dispatch;
	// 83101D44: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 83101D48: 48000008  b 0x83101d50
	pc = 0x83101D50; continue 'dispatch;
	// 83101D4C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 83101D50: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83101D54: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 83101D58: 4082FF80  bne 0x83101cd8
	if !ctx.cr[0].eq {
	pc = 0x83101CD8; continue 'dispatch;
	}
	// 83101D5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83101D60: 419A01A4  beq cr6, 0x83101f04
	if ctx.cr[6].eq {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101D64: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 83101D68: 419A019C  beq cr6, 0x83101f04
	if ctx.cr[6].eq {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101D6C: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 83101D70: 4BFDB741  bl 0x830dd4b0
	ctx.lr = 0x83101D74;
	sub_830DD4B0(ctx, base);
	// 83101D74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83101D78: 41820044  beq 0x83101dbc
	if ctx.cr[0].eq {
	pc = 0x83101DBC; continue 'dispatch;
	}
	// 83101D7C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 83101D80: 93030000  stw r24, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 83101D84: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 83101D88: 93030004  stw r24, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 83101D8C: 93030008  stw r24, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 83101D90: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 83101D94: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 83101D98: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 83101D9C: 9303000C  stw r24, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 83101DA0: 93030014  stw r24, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[24].u32 ) };
	// 83101DA4: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 83101DA8: 93030018  stw r24, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 83101DAC: 93030020  stw r24, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[24].u32 ) };
	// 83101DB0: 93030024  stw r24, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[24].u32 ) };
	// 83101DB4: 91230028  stw r9, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 83101DB8: 48000008  b 0x83101dc0
	pc = 0x83101DC0; continue 'dispatch;
	// 83101DBC: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 83101DC0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 83101DC4: 409A0010  bne cr6, 0x83101dd4
	if !ctx.cr[6].eq {
	pc = 0x83101DD4; continue 'dispatch;
	}
	// 83101DC8: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 83101DCC: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 83101DD0: 48000134  b 0x83101f04
	pc = 0x83101F04; continue 'dispatch;
	// 83101DD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101DD8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 83101DDC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101DE0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101DE4: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101DE8: 4BFFE261  bl 0x83100048
	ctx.lr = 0x83101DEC;
	sub_83100048(ctx, base);
	// 83101DEC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101DF0: 41800114  blt 0x83101f04
	if ctx.cr[0].lt {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101DF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 83101DF8: 419A0024  beq cr6, 0x83101e1c
	if ctx.cr[6].eq {
	pc = 0x83101E1C; continue 'dispatch;
	}
	// 83101DFC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101E00: 3879000C  addi r3, r25, 0xc
	ctx.r[3].s64 = ctx.r[25].s64 + 12;
	// 83101E04: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101E08: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101E0C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101E10: 4BFFE391  bl 0x831001a0
	ctx.lr = 0x83101E14;
	sub_831001A0(ctx, base);
	// 83101E14: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101E18: 418000EC  blt 0x83101f04
	if ctx.cr[0].lt {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101E1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 83101E20: 419A0024  beq cr6, 0x83101e44
	if ctx.cr[6].eq {
	pc = 0x83101E44; continue 'dispatch;
	}
	// 83101E24: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101E28: 38790018  addi r3, r25, 0x18
	ctx.r[3].s64 = ctx.r[25].s64 + 24;
	// 83101E2C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101E30: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101E34: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101E38: 4BFFE369  bl 0x831001a0
	ctx.lr = 0x83101E3C;
	sub_831001A0(ctx, base);
	// 83101E3C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101E40: 418000C4  blt 0x83101f04
	if ctx.cr[0].lt {
	pc = 0x83101F04; continue 'dispatch;
	}
	// 83101E44: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 83101E48: 419A0034  beq cr6, 0x83101e7c
	if ctx.cr[6].eq {
	pc = 0x83101E7C; continue 'dispatch;
	}
	// 83101E4C: 83FB0008  lwz r31, 8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101E50: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101E54: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83101E5C: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101E60: 4BFDB651  bl 0x830dd4b0
	ctx.lr = 0x83101E64;
	sub_830DD4B0(ctx, base);
	// 83101E64: 90790024  stw r3, 0x24(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 83101E68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 83101E6C: 4182FF5C  beq 0x83101dc8
	if ctx.cr[0].eq {
	pc = 0x83101DC8; continue 'dispatch;
	}
	// 83101E70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 83101E74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83101E78: 480A6699  bl 0x831a8510
	ctx.lr = 0x83101E7C;
	sub_831A8510(ctx, base);
	// 83101E7C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 83101E80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 83101E84: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101E88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 83101E8C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83101E90: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83101E94: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101E98: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 83101E9C: 4BFFE63D  bl 0x831004d8
	ctx.lr = 0x83101EA0;
	sub_831004D8(ctx, base);
	// 83101EA0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83101EA4: 4182FF24  beq 0x83101dc8
	if ctx.cr[0].eq {
	pc = 0x83101DC8; continue 'dispatch;
	}
	// 83101EA8: 933F0028  stw r25, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[25].u32 ) };
	// 83101EAC: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 83101EB0: 81790028  lwz r11, 0x28(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 83101EB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83101EB8: 91790028  stw r11, 0x28(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 83101EBC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 83101EC0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 83101EC4: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 83101EC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83101ECC: 4BFFF9C5  bl 0x83101890
	ctx.lr = 0x83101ED0;
	sub_83101890(ctx, base);
	// 83101ED0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83101ED4: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 83101ED8: 9301006C  stw r24, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[24].u32 ) };
	// 83101EDC: 40800018  bge 0x83101ef4
	if !ctx.cr[0].lt {
	pc = 0x83101EF4; continue 'dispatch;
	}
	// 83101EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83101EE4: 48001125  bl 0x83103008
	ctx.lr = 0x83101EE8;
	sub_83103008(ctx, base);
	// 83101EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83101EEC: 4BFDB5ED  bl 0x830dd4d8
	ctx.lr = 0x83101EF0;
	sub_830DD4D8(ctx, base);
	// 83101EF0: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 83101EF4: 93F70000  stw r31, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 83101EF8: 4800000C  b 0x83101f04
	pc = 0x83101F04; continue 'dispatch;
	// 83101EFC: 3FC08030  lis r30, -0x7fd0
	ctx.r[30].s64 = -2144337920;
	// 83101F00: 63DE000D  ori r30, r30, 0xd
	ctx.r[30].u64 = ctx.r[30].u64 | 13;
	// 83101F04: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83101F08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83101F0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83101F10: 419A0020  beq cr6, 0x83101f30
	if ctx.cr[6].eq {
	pc = 0x83101F30; continue 'dispatch;
	}
	// 83101F14: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83101F18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83101F1C: 419A0014  beq cr6, 0x83101f30
	if ctx.cr[6].eq {
	pc = 0x83101F30; continue 'dispatch;
	}
	// 83101F20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83101F24: 419A001C  beq cr6, 0x83101f40
	if ctx.cr[6].eq {
	pc = 0x83101F40; continue 'dispatch;
	}
	// 83101F28: 4BFDB931  bl 0x830dd858
	ctx.lr = 0x83101F2C;
	sub_830DD858(ctx, base);
	// 83101F2C: 48000014  b 0x83101f40
	pc = 0x83101F40; continue 'dispatch;
	// 83101F30: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83101F34: 419A000C  beq cr6, 0x83101f40
	if ctx.cr[6].eq {
	pc = 0x83101F40; continue 'dispatch;
	}
	// 83101F38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 83101F3C: 4BFDB59D  bl 0x830dd4d8
	ctx.lr = 0x83101F40;
	sub_830DD4D8(ctx, base);
	// 83101F40: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83101F44: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 83101F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83101F4C: 419A000C  beq cr6, 0x83101f58
	if ctx.cr[6].eq {
	pc = 0x83101F58; continue 'dispatch;
	}
	// 83101F50: 4BFDB9F1  bl 0x830dd940
	ctx.lr = 0x83101F54;
	sub_830DD940(ctx, base);
	// 83101F54: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 83101F58: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 83101F5C: 419A0024  beq cr6, 0x83101f80
	if ctx.cr[6].eq {
	pc = 0x83101F80; continue 'dispatch;
	}
	// 83101F60: 81790028  lwz r11, 0x28(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 83101F64: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83101F68: 91790028  stw r11, 0x28(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 83101F6C: 40820014  bne 0x83101f80
	if !ctx.cr[0].eq {
	pc = 0x83101F80; continue 'dispatch;
	}
	// 83101F70: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 83101F74: 4BFFE325  bl 0x83100298
	ctx.lr = 0x83101F78;
	sub_83100298(ctx, base);
	// 83101F78: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 83101F7C: 4BFDB55D  bl 0x830dd4d8
	ctx.lr = 0x83101F80;
	sub_830DD4D8(ctx, base);
	// 83101F80: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 83101F84: 4BFDB555  bl 0x830dd4d8
	ctx.lr = 0x83101F88;
	sub_830DD4D8(ctx, base);
	// 83101F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83101F8C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 83101F90: 480A6214  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83101F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83101F98 size=88
    let mut pc: u32 = 0x83101F98;
    'dispatch: loop {
        match pc {
            0x83101F98 => {
    //   block [0x83101F98..0x83101FF0)
	// 83101F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83101F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83101FA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83101FA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83101FA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83101FAC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101FB0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 83101FB4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 83101FB8: 419A0024  beq cr6, 0x83101fdc
	if ctx.cr[6].eq {
	pc = 0x83101FDC; continue 'dispatch;
	}
	// 83101FBC: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 83101FC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83101FC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 83101FC8: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 83101FCC: 4BFFDF2D  bl 0x830ffef8
	ctx.lr = 0x83101FD0;
	sub_830FFEF8(ctx, base);
	// 83101FD0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83101FD4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 83101FD8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83101FDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83101FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83101FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83101FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83101FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83101FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83101FF0 size=40
    let mut pc: u32 = 0x83101FF0;
    'dispatch: loop {
        match pc {
            0x83101FF0 => {
    //   block [0x83101FF0..0x83102018)
	// 83101FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83101FF4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 83101FF8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83101FFC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83102000: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83102004: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 83102008: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8310200C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83102010: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 83102014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83102018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83102018 size=56
    let mut pc: u32 = 0x83102018;
    'dispatch: loop {
        match pc {
            0x83102018 => {
    //   block [0x83102018..0x83102050)
	// 83102018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310201C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83102020: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83102024: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 83102028: 388007F6  li r4, 0x7f6
	ctx.r[4].s64 = 2038;
	// 8310202C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 83102030: 4BFFFFC1  bl 0x83101ff0
	ctx.lr = 0x83102034;
	sub_83101FF0(ctx, base);
	// 83102034: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83102038: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 8310203C: 48001A5D  bl 0x83103a98
	ctx.lr = 0x83102040;
	sub_83103A98(ctx, base);
	// 83102040: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83102044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83102048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8310204C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83102050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83102050 size=72
    let mut pc: u32 = 0x83102050;
    'dispatch: loop {
        match pc {
            0x83102050 => {
    //   block [0x83102050..0x83102098)
	// 83102050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83102054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83102058: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8310205C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83102060: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 83102064: 388007F4  li r4, 0x7f4
	ctx.r[4].s64 = 2036;
	// 83102068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8310206C: 4BFFFF85  bl 0x83101ff0
	ctx.lr = 0x83102070;
	sub_83101FF0(ctx, base);
	// 83102070: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 83102074: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 83102078: 4BFCCB99  bl 0x830cec10
	ctx.lr = 0x8310207C;
	sub_830CEC10(ctx, base);
	// 8310207C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83102080: 4BFD3B49  bl 0x830d5bc8
	ctx.lr = 0x83102084;
	sub_830D5BC8(ctx, base);
	// 83102084: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83102088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8310208C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83102090: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83102094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83102098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83102098 size=72
    let mut pc: u32 = 0x83102098;
    'dispatch: loop {
        match pc {
            0x83102098 => {
    //   block [0x83102098..0x831020E0)
	// 83102098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8310209C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 831020A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 831020A4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831020A8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 831020AC: 388007F5  li r4, 0x7f5
	ctx.r[4].s64 = 2037;
	// 831020B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 831020B4: 4BFFFF3D  bl 0x83101ff0
	ctx.lr = 0x831020B8;
	sub_83101FF0(ctx, base);
	// 831020B8: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 831020BC: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 831020C0: 4BFCCB51  bl 0x830cec10
	ctx.lr = 0x831020C4;
	sub_830CEC10(ctx, base);
	// 831020C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 831020C8: 4BFD3B01  bl 0x830d5bc8
	ctx.lr = 0x831020CC;
	sub_830D5BC8(ctx, base);
	// 831020CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 831020D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 831020D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 831020D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 831020DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_831020E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x831020E0 size=128
    let mut pc: u32 = 0x831020E0;
    'dispatch: loop {
        match pc {
            0x831020E0 => {
    //   block [0x831020E0..0x83102160)
	// 831020E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 831020E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 831020E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 831020EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 831020F0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 831020F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 831020F8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 831020FC: 4BFCC375  bl 0x830ce470
	ctx.lr = 0x83102100;
	sub_830CE470(ctx, base);
	// 83102100: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83102104: 41800048  blt 0x8310214c
	if ctx.cr[0].lt {
	pc = 0x8310214C; continue 'dispatch;
	}
	// 83102108: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8310210C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83102110: 419A0034  beq cr6, 0x83102144
	if ctx.cr[6].eq {
	pc = 0x83102144; continue 'dispatch;
	}
	// 83102114: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83102118: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8310211C: 409A0028  bne cr6, 0x83102144
	if !ctx.cr[6].eq {
	pc = 0x83102144; continue 'dispatch;
	}
	// 83102120: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83102124: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83102128: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8310212C: 419A0010  beq cr6, 0x8310213c
	if ctx.cr[6].eq {
	pc = 0x8310213C; continue 'dispatch;
	}
	// 83102130: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83102134: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83102138: 4BFFFE61  bl 0x83101f98
	ctx.lr = 0x8310213C;
	sub_83101F98(ctx, base);
	// 8310213C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83102140: 4800000C  b 0x8310214c
	pc = 0x8310214C; continue 'dispatch;
	// 83102144: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 83102148: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 8310214C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83102150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83102154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83102158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8310215C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83102160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83102160 size=68
    let mut pc: u32 = 0x83102160;
    'dispatch: loop {
        match pc {
            0x83102160 => {
    //   block [0x83102160..0x831021A4)
	// 83102160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83102164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83102168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8310216C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83102170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83102174: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83102178: 4BFFFED9  bl 0x83102050
	ctx.lr = 0x8310217C;
	sub_83102050(ctx, base);
	// 8310217C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 83102180: 41800010  blt 0x83102190
	if ctx.cr[0].lt {
	pc = 0x83102190; continue 'dispatch;
	}
	// 83102184: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83102188: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 8310218C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83102190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83102194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83102198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8310219C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 831021A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


