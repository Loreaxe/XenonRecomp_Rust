pub fn sub_829A3F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A3F58 size=196
    let mut pc: u32 = 0x829A3F58;
    'dispatch: loop {
        match pc {
            0x829A3F58 => {
    //   block [0x829A3F58..0x829A401C)
	// 829A3F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A3F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A3F60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A3F64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A3F68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A3F6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A3F70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A3F74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A3F78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A3F7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A3F80: 4B91C9B9  bl 0x822c0938
	ctx.lr = 0x829A3F84;
	sub_822C0938(ctx, base);
	// 829A3F84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A3F88: 41820028  beq 0x829a3fb0
	if ctx.cr[0].eq {
	pc = 0x829A3FB0; continue 'dispatch;
	}
	// 829A3F8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A3F90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A3F94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A3F98: 392B14C4  addi r9, r11, 0x14c4
	ctx.r[9].s64 = ctx.r[11].s64 + 5316;
	// 829A3F9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A3FA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A3FA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A3FA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A3FAC: 48000008  b 0x829a3fb4
	pc = 0x829A3FB4; continue 'dispatch;
	// 829A3FB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A3FB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A3FB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A3FBC: 409A0044  bne cr6, 0x829a4000
	if !ctx.cr[6].eq {
	pc = 0x829A4000; continue 'dispatch;
	}
	// 829A3FC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A3FC4: 419A001C  beq cr6, 0x829a3fe0
	if ctx.cr[6].eq {
	pc = 0x829A3FE0; continue 'dispatch;
	}
	// 829A3FC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A3FCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A3FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A3FD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A3FD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A3FDC: 4E800421  bctrl
	ctx.lr = 0x829A3FE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A3FE0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A3FE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A3FE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A3FEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A3FF0: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A3FF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A3FF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A3FFC: 4B91C005  bl 0x822c0000
	ctx.lr = 0x829A4000;
	sub_822C0000(ctx, base);
	// 829A4000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A400C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4010: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4020 size=196
    let mut pc: u32 = 0x829A4020;
    'dispatch: loop {
        match pc {
            0x829A4020 => {
    //   block [0x829A4020..0x829A40E4)
	// 829A4020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A402C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A403C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4040: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4044: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4048: 4B91C8F1  bl 0x822c0938
	ctx.lr = 0x829A404C;
	sub_822C0938(ctx, base);
	// 829A404C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4050: 41820028  beq 0x829a4078
	if ctx.cr[0].eq {
	pc = 0x829A4078; continue 'dispatch;
	}
	// 829A4054: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4058: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A405C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4060: 392B14D8  addi r9, r11, 0x14d8
	ctx.r[9].s64 = ctx.r[11].s64 + 5336;
	// 829A4064: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4068: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A406C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4070: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4074: 48000008  b 0x829a407c
	pc = 0x829A407C; continue 'dispatch;
	// 829A4078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A407C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4084: 409A0044  bne cr6, 0x829a40c8
	if !ctx.cr[6].eq {
	pc = 0x829A40C8; continue 'dispatch;
	}
	// 829A4088: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A408C: 419A001C  beq cr6, 0x829a40a8
	if ctx.cr[6].eq {
	pc = 0x829A40A8; continue 'dispatch;
	}
	// 829A4090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4094: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A409C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A40A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A40A4: 4E800421  bctrl
	ctx.lr = 0x829A40A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A40A8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A40AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A40B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A40B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A40B8: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A40BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A40C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A40C4: 4B91BF3D  bl 0x822c0000
	ctx.lr = 0x829A40C8;
	sub_822C0000(ctx, base);
	// 829A40C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A40CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A40D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A40D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A40D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A40DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A40E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A40E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A40E8 size=196
    let mut pc: u32 = 0x829A40E8;
    'dispatch: loop {
        match pc {
            0x829A40E8 => {
    //   block [0x829A40E8..0x829A41AC)
	// 829A40E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A40EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A40F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A40F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A40F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A40FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4104: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4108: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A410C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4110: 4B91C829  bl 0x822c0938
	ctx.lr = 0x829A4114;
	sub_822C0938(ctx, base);
	// 829A4114: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4118: 41820028  beq 0x829a4140
	if ctx.cr[0].eq {
	pc = 0x829A4140; continue 'dispatch;
	}
	// 829A411C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4120: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A4124: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4128: 392B14EC  addi r9, r11, 0x14ec
	ctx.r[9].s64 = ctx.r[11].s64 + 5356;
	// 829A412C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4130: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4134: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4138: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A413C: 48000008  b 0x829a4144
	pc = 0x829A4144; continue 'dispatch;
	// 829A4140: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4144: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A414C: 409A0044  bne cr6, 0x829a4190
	if !ctx.cr[6].eq {
	pc = 0x829A4190; continue 'dispatch;
	}
	// 829A4150: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4154: 419A001C  beq cr6, 0x829a4170
	if ctx.cr[6].eq {
	pc = 0x829A4170; continue 'dispatch;
	}
	// 829A4158: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A415C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4164: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A416C: 4E800421  bctrl
	ctx.lr = 0x829A4170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4170: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4174: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A417C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4180: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4184: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4188: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A418C: 4B91BE75  bl 0x822c0000
	ctx.lr = 0x829A4190;
	sub_822C0000(ctx, base);
	// 829A4190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4194: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A419C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A41A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A41A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A41A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A41B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A41B0 size=196
    let mut pc: u32 = 0x829A41B0;
    'dispatch: loop {
        match pc {
            0x829A41B0 => {
    //   block [0x829A41B0..0x829A4274)
	// 829A41B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A41B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A41B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A41BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A41C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A41C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A41C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A41CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A41D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A41D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A41D8: 4B91C761  bl 0x822c0938
	ctx.lr = 0x829A41DC;
	sub_822C0938(ctx, base);
	// 829A41DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A41E0: 41820028  beq 0x829a4208
	if ctx.cr[0].eq {
	pc = 0x829A4208; continue 'dispatch;
	}
	// 829A41E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A41E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A41EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A41F0: 392B1500  addi r9, r11, 0x1500
	ctx.r[9].s64 = ctx.r[11].s64 + 5376;
	// 829A41F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A41F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A41FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4200: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4204: 48000008  b 0x829a420c
	pc = 0x829A420C; continue 'dispatch;
	// 829A4208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A420C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4214: 409A0044  bne cr6, 0x829a4258
	if !ctx.cr[6].eq {
	pc = 0x829A4258; continue 'dispatch;
	}
	// 829A4218: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A421C: 419A001C  beq cr6, 0x829a4238
	if ctx.cr[6].eq {
	pc = 0x829A4238; continue 'dispatch;
	}
	// 829A4220: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4224: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A422C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4234: 4E800421  bctrl
	ctx.lr = 0x829A4238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4238: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A423C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4244: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4248: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A424C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4250: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4254: 4B91BDAD  bl 0x822c0000
	ctx.lr = 0x829A4258;
	sub_822C0000(ctx, base);
	// 829A4258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A425C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4268: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A426C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4278 size=196
    let mut pc: u32 = 0x829A4278;
    'dispatch: loop {
        match pc {
            0x829A4278 => {
    //   block [0x829A4278..0x829A433C)
	// 829A4278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A427C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A428C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4294: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4298: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A429C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A42A0: 4B91C699  bl 0x822c0938
	ctx.lr = 0x829A42A4;
	sub_822C0938(ctx, base);
	// 829A42A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A42A8: 41820028  beq 0x829a42d0
	if ctx.cr[0].eq {
	pc = 0x829A42D0; continue 'dispatch;
	}
	// 829A42AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A42B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A42B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A42B8: 392B1514  addi r9, r11, 0x1514
	ctx.r[9].s64 = ctx.r[11].s64 + 5396;
	// 829A42BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A42C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A42C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A42C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A42CC: 48000008  b 0x829a42d4
	pc = 0x829A42D4; continue 'dispatch;
	// 829A42D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A42D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A42D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A42DC: 409A0044  bne cr6, 0x829a4320
	if !ctx.cr[6].eq {
	pc = 0x829A4320; continue 'dispatch;
	}
	// 829A42E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A42E4: 419A001C  beq cr6, 0x829a4300
	if ctx.cr[6].eq {
	pc = 0x829A4300; continue 'dispatch;
	}
	// 829A42E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A42EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A42F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A42F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A42F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A42FC: 4E800421  bctrl
	ctx.lr = 0x829A4300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4300: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4304: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A430C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4310: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4314: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4318: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A431C: 4B91BCE5  bl 0x822c0000
	ctx.lr = 0x829A4320;
	sub_822C0000(ctx, base);
	// 829A4320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4324: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A432C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4330: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4340 size=196
    let mut pc: u32 = 0x829A4340;
    'dispatch: loop {
        match pc {
            0x829A4340 => {
    //   block [0x829A4340..0x829A4404)
	// 829A4340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A434C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A435C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4360: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4364: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4368: 4B91C5D1  bl 0x822c0938
	ctx.lr = 0x829A436C;
	sub_822C0938(ctx, base);
	// 829A436C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4370: 41820028  beq 0x829a4398
	if ctx.cr[0].eq {
	pc = 0x829A4398; continue 'dispatch;
	}
	// 829A4374: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4378: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A437C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4380: 392B1528  addi r9, r11, 0x1528
	ctx.r[9].s64 = ctx.r[11].s64 + 5416;
	// 829A4384: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A438C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4390: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4394: 48000008  b 0x829a439c
	pc = 0x829A439C; continue 'dispatch;
	// 829A4398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A439C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A43A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A43A4: 409A0044  bne cr6, 0x829a43e8
	if !ctx.cr[6].eq {
	pc = 0x829A43E8; continue 'dispatch;
	}
	// 829A43A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A43AC: 419A001C  beq cr6, 0x829a43c8
	if ctx.cr[6].eq {
	pc = 0x829A43C8; continue 'dispatch;
	}
	// 829A43B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A43B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A43B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A43BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A43C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A43C4: 4E800421  bctrl
	ctx.lr = 0x829A43C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A43C8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A43CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A43D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A43D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A43D8: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A43DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A43E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A43E4: 4B91BC1D  bl 0x822c0000
	ctx.lr = 0x829A43E8;
	sub_822C0000(ctx, base);
	// 829A43E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A43EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A43F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A43F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A43F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A43FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4408 size=196
    let mut pc: u32 = 0x829A4408;
    'dispatch: loop {
        match pc {
            0x829A4408 => {
    //   block [0x829A4408..0x829A44CC)
	// 829A4408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A440C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A441C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4424: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4428: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A442C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4430: 4B91C509  bl 0x822c0938
	ctx.lr = 0x829A4434;
	sub_822C0938(ctx, base);
	// 829A4434: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4438: 41820028  beq 0x829a4460
	if ctx.cr[0].eq {
	pc = 0x829A4460; continue 'dispatch;
	}
	// 829A443C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4440: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A4444: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4448: 392B153C  addi r9, r11, 0x153c
	ctx.r[9].s64 = ctx.r[11].s64 + 5436;
	// 829A444C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4450: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4454: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4458: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A445C: 48000008  b 0x829a4464
	pc = 0x829A4464; continue 'dispatch;
	// 829A4460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4464: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A446C: 409A0044  bne cr6, 0x829a44b0
	if !ctx.cr[6].eq {
	pc = 0x829A44B0; continue 'dispatch;
	}
	// 829A4470: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4474: 419A001C  beq cr6, 0x829a4490
	if ctx.cr[6].eq {
	pc = 0x829A4490; continue 'dispatch;
	}
	// 829A4478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A447C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4484: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A448C: 4E800421  bctrl
	ctx.lr = 0x829A4490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4490: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4494: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A449C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A44A0: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A44A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A44A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A44AC: 4B91BB55  bl 0x822c0000
	ctx.lr = 0x829A44B0;
	sub_822C0000(ctx, base);
	// 829A44B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A44B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A44B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A44BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A44C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A44C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A44C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A44D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A44D0 size=196
    let mut pc: u32 = 0x829A44D0;
    'dispatch: loop {
        match pc {
            0x829A44D0 => {
    //   block [0x829A44D0..0x829A4594)
	// 829A44D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A44D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A44D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A44DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A44E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A44E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A44E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A44EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A44F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A44F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A44F8: 4B91C441  bl 0x822c0938
	ctx.lr = 0x829A44FC;
	sub_822C0938(ctx, base);
	// 829A44FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4500: 41820028  beq 0x829a4528
	if ctx.cr[0].eq {
	pc = 0x829A4528; continue 'dispatch;
	}
	// 829A4504: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4508: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A450C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4510: 392B1550  addi r9, r11, 0x1550
	ctx.r[9].s64 = ctx.r[11].s64 + 5456;
	// 829A4514: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A451C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4520: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4524: 48000008  b 0x829a452c
	pc = 0x829A452C; continue 'dispatch;
	// 829A4528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A452C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4534: 409A0044  bne cr6, 0x829a4578
	if !ctx.cr[6].eq {
	pc = 0x829A4578; continue 'dispatch;
	}
	// 829A4538: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A453C: 419A001C  beq cr6, 0x829a4558
	if ctx.cr[6].eq {
	pc = 0x829A4558; continue 'dispatch;
	}
	// 829A4540: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4544: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A454C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4554: 4E800421  bctrl
	ctx.lr = 0x829A4558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4558: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A455C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4564: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4568: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A456C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4570: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4574: 4B91BA8D  bl 0x822c0000
	ctx.lr = 0x829A4578;
	sub_822C0000(ctx, base);
	// 829A4578: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A457C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4588: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A458C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4598 size=196
    let mut pc: u32 = 0x829A4598;
    'dispatch: loop {
        match pc {
            0x829A4598 => {
    //   block [0x829A4598..0x829A465C)
	// 829A4598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A459C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A45A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A45A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A45A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A45AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A45B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A45B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A45B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A45BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A45C0: 4B91C379  bl 0x822c0938
	ctx.lr = 0x829A45C4;
	sub_822C0938(ctx, base);
	// 829A45C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A45C8: 41820028  beq 0x829a45f0
	if ctx.cr[0].eq {
	pc = 0x829A45F0; continue 'dispatch;
	}
	// 829A45CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A45D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A45D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A45D8: 392B1564  addi r9, r11, 0x1564
	ctx.r[9].s64 = ctx.r[11].s64 + 5476;
	// 829A45DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A45E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A45E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A45E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A45EC: 48000008  b 0x829a45f4
	pc = 0x829A45F4; continue 'dispatch;
	// 829A45F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A45F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A45F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A45FC: 409A0044  bne cr6, 0x829a4640
	if !ctx.cr[6].eq {
	pc = 0x829A4640; continue 'dispatch;
	}
	// 829A4600: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4604: 419A001C  beq cr6, 0x829a4620
	if ctx.cr[6].eq {
	pc = 0x829A4620; continue 'dispatch;
	}
	// 829A4608: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A460C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4614: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A461C: 4E800421  bctrl
	ctx.lr = 0x829A4620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4620: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4624: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A462C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4630: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4634: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4638: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A463C: 4B91B9C5  bl 0x822c0000
	ctx.lr = 0x829A4640;
	sub_822C0000(ctx, base);
	// 829A4640: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A464C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4650: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4654: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4660 size=196
    let mut pc: u32 = 0x829A4660;
    'dispatch: loop {
        match pc {
            0x829A4660 => {
    //   block [0x829A4660..0x829A4724)
	// 829A4660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A466C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4674: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A467C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4680: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4684: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4688: 4B91C2B1  bl 0x822c0938
	ctx.lr = 0x829A468C;
	sub_822C0938(ctx, base);
	// 829A468C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4690: 41820028  beq 0x829a46b8
	if ctx.cr[0].eq {
	pc = 0x829A46B8; continue 'dispatch;
	}
	// 829A4694: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4698: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A469C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A46A0: 392B1578  addi r9, r11, 0x1578
	ctx.r[9].s64 = ctx.r[11].s64 + 5496;
	// 829A46A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A46A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A46AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A46B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A46B4: 48000008  b 0x829a46bc
	pc = 0x829A46BC; continue 'dispatch;
	// 829A46B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A46BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A46C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A46C4: 409A0044  bne cr6, 0x829a4708
	if !ctx.cr[6].eq {
	pc = 0x829A4708; continue 'dispatch;
	}
	// 829A46C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A46CC: 419A001C  beq cr6, 0x829a46e8
	if ctx.cr[6].eq {
	pc = 0x829A46E8; continue 'dispatch;
	}
	// 829A46D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A46D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A46D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A46DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A46E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A46E4: 4E800421  bctrl
	ctx.lr = 0x829A46E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A46E8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A46EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A46F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A46F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A46F8: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A46FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4700: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4704: 4B91B8FD  bl 0x822c0000
	ctx.lr = 0x829A4708;
	sub_822C0000(ctx, base);
	// 829A4708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A470C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4718: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A471C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4728 size=196
    let mut pc: u32 = 0x829A4728;
    'dispatch: loop {
        match pc {
            0x829A4728 => {
    //   block [0x829A4728..0x829A47EC)
	// 829A4728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A472C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A473C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4744: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4748: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A474C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4750: 4B91C1E9  bl 0x822c0938
	ctx.lr = 0x829A4754;
	sub_822C0938(ctx, base);
	// 829A4754: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4758: 41820028  beq 0x829a4780
	if ctx.cr[0].eq {
	pc = 0x829A4780; continue 'dispatch;
	}
	// 829A475C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4760: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A4764: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4768: 392B158C  addi r9, r11, 0x158c
	ctx.r[9].s64 = ctx.r[11].s64 + 5516;
	// 829A476C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4770: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4774: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4778: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A477C: 48000008  b 0x829a4784
	pc = 0x829A4784; continue 'dispatch;
	// 829A4780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4784: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A478C: 409A0044  bne cr6, 0x829a47d0
	if !ctx.cr[6].eq {
	pc = 0x829A47D0; continue 'dispatch;
	}
	// 829A4790: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4794: 419A001C  beq cr6, 0x829a47b0
	if ctx.cr[6].eq {
	pc = 0x829A47B0; continue 'dispatch;
	}
	// 829A4798: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A479C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A47A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A47A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A47A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A47AC: 4E800421  bctrl
	ctx.lr = 0x829A47B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A47B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A47B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A47B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A47BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A47C0: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A47C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A47C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A47CC: 4B91B835  bl 0x822c0000
	ctx.lr = 0x829A47D0;
	sub_822C0000(ctx, base);
	// 829A47D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A47D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A47D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A47DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A47E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A47E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A47E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A47F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A47F0 size=196
    let mut pc: u32 = 0x829A47F0;
    'dispatch: loop {
        match pc {
            0x829A47F0 => {
    //   block [0x829A47F0..0x829A48B4)
	// 829A47F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A47F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A47F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A47FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4804: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A480C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4810: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4814: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4818: 4B91C121  bl 0x822c0938
	ctx.lr = 0x829A481C;
	sub_822C0938(ctx, base);
	// 829A481C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4820: 41820028  beq 0x829a4848
	if ctx.cr[0].eq {
	pc = 0x829A4848; continue 'dispatch;
	}
	// 829A4824: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4828: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A482C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4830: 392B15A0  addi r9, r11, 0x15a0
	ctx.r[9].s64 = ctx.r[11].s64 + 5536;
	// 829A4834: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4838: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A483C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4840: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4844: 48000008  b 0x829a484c
	pc = 0x829A484C; continue 'dispatch;
	// 829A4848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A484C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4854: 409A0044  bne cr6, 0x829a4898
	if !ctx.cr[6].eq {
	pc = 0x829A4898; continue 'dispatch;
	}
	// 829A4858: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A485C: 419A001C  beq cr6, 0x829a4878
	if ctx.cr[6].eq {
	pc = 0x829A4878; continue 'dispatch;
	}
	// 829A4860: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4864: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A486C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4874: 4E800421  bctrl
	ctx.lr = 0x829A4878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4878: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A487C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4884: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4888: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A488C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4890: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4894: 4B91B76D  bl 0x822c0000
	ctx.lr = 0x829A4898;
	sub_822C0000(ctx, base);
	// 829A4898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A489C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A48A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A48A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A48A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A48AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A48B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A48B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A48B8 size=196
    let mut pc: u32 = 0x829A48B8;
    'dispatch: loop {
        match pc {
            0x829A48B8 => {
    //   block [0x829A48B8..0x829A497C)
	// 829A48B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A48BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A48C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A48C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A48C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A48CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A48D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A48D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A48D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A48DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A48E0: 4B91C059  bl 0x822c0938
	ctx.lr = 0x829A48E4;
	sub_822C0938(ctx, base);
	// 829A48E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A48E8: 41820028  beq 0x829a4910
	if ctx.cr[0].eq {
	pc = 0x829A4910; continue 'dispatch;
	}
	// 829A48EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A48F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A48F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A48F8: 392B15B4  addi r9, r11, 0x15b4
	ctx.r[9].s64 = ctx.r[11].s64 + 5556;
	// 829A48FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4900: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4904: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4908: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A490C: 48000008  b 0x829a4914
	pc = 0x829A4914; continue 'dispatch;
	// 829A4910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4914: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A491C: 409A0044  bne cr6, 0x829a4960
	if !ctx.cr[6].eq {
	pc = 0x829A4960; continue 'dispatch;
	}
	// 829A4920: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4924: 419A001C  beq cr6, 0x829a4940
	if ctx.cr[6].eq {
	pc = 0x829A4940; continue 'dispatch;
	}
	// 829A4928: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A492C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4934: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A493C: 4E800421  bctrl
	ctx.lr = 0x829A4940;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4940: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4944: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A494C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4950: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4954: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4958: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A495C: 4B91B6A5  bl 0x822c0000
	ctx.lr = 0x829A4960;
	sub_822C0000(ctx, base);
	// 829A4960: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4964: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A496C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4970: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4980 size=196
    let mut pc: u32 = 0x829A4980;
    'dispatch: loop {
        match pc {
            0x829A4980 => {
    //   block [0x829A4980..0x829A4A44)
	// 829A4980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A498C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4994: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A499C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A49A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A49A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A49A8: 4B91BF91  bl 0x822c0938
	ctx.lr = 0x829A49AC;
	sub_822C0938(ctx, base);
	// 829A49AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A49B0: 41820028  beq 0x829a49d8
	if ctx.cr[0].eq {
	pc = 0x829A49D8; continue 'dispatch;
	}
	// 829A49B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A49B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A49BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A49C0: 392B15C8  addi r9, r11, 0x15c8
	ctx.r[9].s64 = ctx.r[11].s64 + 5576;
	// 829A49C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A49C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A49CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A49D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A49D4: 48000008  b 0x829a49dc
	pc = 0x829A49DC; continue 'dispatch;
	// 829A49D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A49DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A49E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A49E4: 409A0044  bne cr6, 0x829a4a28
	if !ctx.cr[6].eq {
	pc = 0x829A4A28; continue 'dispatch;
	}
	// 829A49E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A49EC: 419A001C  beq cr6, 0x829a4a08
	if ctx.cr[6].eq {
	pc = 0x829A4A08; continue 'dispatch;
	}
	// 829A49F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A49F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A49F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A49FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4A00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4A04: 4E800421  bctrl
	ctx.lr = 0x829A4A08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4A08: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4A0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4A14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4A18: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4A1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4A20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4A24: 4B91B5DD  bl 0x822c0000
	ctx.lr = 0x829A4A28;
	sub_822C0000(ctx, base);
	// 829A4A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4A38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4A48 size=196
    let mut pc: u32 = 0x829A4A48;
    'dispatch: loop {
        match pc {
            0x829A4A48 => {
    //   block [0x829A4A48..0x829A4B0C)
	// 829A4A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4A5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4A64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4A68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4A6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4A70: 4B91BEC9  bl 0x822c0938
	ctx.lr = 0x829A4A74;
	sub_822C0938(ctx, base);
	// 829A4A74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4A78: 41820028  beq 0x829a4aa0
	if ctx.cr[0].eq {
	pc = 0x829A4AA0; continue 'dispatch;
	}
	// 829A4A7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4A80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A4A84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4A88: 392B15DC  addi r9, r11, 0x15dc
	ctx.r[9].s64 = ctx.r[11].s64 + 5596;
	// 829A4A8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4A90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4A94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4A98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4A9C: 48000008  b 0x829a4aa4
	pc = 0x829A4AA4; continue 'dispatch;
	// 829A4AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4AA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4AAC: 409A0044  bne cr6, 0x829a4af0
	if !ctx.cr[6].eq {
	pc = 0x829A4AF0; continue 'dispatch;
	}
	// 829A4AB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4AB4: 419A001C  beq cr6, 0x829a4ad0
	if ctx.cr[6].eq {
	pc = 0x829A4AD0; continue 'dispatch;
	}
	// 829A4AB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4ABC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4AC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A4AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4ACC: 4E800421  bctrl
	ctx.lr = 0x829A4AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4AD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4AD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4ADC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4AE0: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4AE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4AE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4AEC: 4B91B515  bl 0x822c0000
	ctx.lr = 0x829A4AF0;
	sub_822C0000(ctx, base);
	// 829A4AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4AF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4AFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4B00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4B10 size=196
    let mut pc: u32 = 0x829A4B10;
    'dispatch: loop {
        match pc {
            0x829A4B10 => {
    //   block [0x829A4B10..0x829A4BD4)
	// 829A4B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4B18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4B1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4B20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4B24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4B28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4B2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4B30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4B34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4B38: 4B91BE01  bl 0x822c0938
	ctx.lr = 0x829A4B3C;
	sub_822C0938(ctx, base);
	// 829A4B3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4B40: 41820028  beq 0x829a4b68
	if ctx.cr[0].eq {
	pc = 0x829A4B68; continue 'dispatch;
	}
	// 829A4B44: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4B48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A4B4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4B50: 392B15F0  addi r9, r11, 0x15f0
	ctx.r[9].s64 = ctx.r[11].s64 + 5616;
	// 829A4B54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4B58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4B5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4B60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4B64: 48000008  b 0x829a4b6c
	pc = 0x829A4B6C; continue 'dispatch;
	// 829A4B68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4B6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4B70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4B74: 409A0044  bne cr6, 0x829a4bb8
	if !ctx.cr[6].eq {
	pc = 0x829A4BB8; continue 'dispatch;
	}
	// 829A4B78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4B7C: 419A001C  beq cr6, 0x829a4b98
	if ctx.cr[6].eq {
	pc = 0x829A4B98; continue 'dispatch;
	}
	// 829A4B80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4B84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4B8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4B94: 4E800421  bctrl
	ctx.lr = 0x829A4B98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4B98: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4B9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4BA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4BA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4BA8: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4BAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4BB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4BB4: 4B91B44D  bl 0x822c0000
	ctx.lr = 0x829A4BB8;
	sub_822C0000(ctx, base);
	// 829A4BB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4BBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4BC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4BC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4BC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4BCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4BD8 size=196
    let mut pc: u32 = 0x829A4BD8;
    'dispatch: loop {
        match pc {
            0x829A4BD8 => {
    //   block [0x829A4BD8..0x829A4C9C)
	// 829A4BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4BE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4BE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4BF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4BF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4BF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4BFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4C00: 4B91BD39  bl 0x822c0938
	ctx.lr = 0x829A4C04;
	sub_822C0938(ctx, base);
	// 829A4C04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4C08: 41820028  beq 0x829a4c30
	if ctx.cr[0].eq {
	pc = 0x829A4C30; continue 'dispatch;
	}
	// 829A4C0C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4C10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A4C14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4C18: 392B1604  addi r9, r11, 0x1604
	ctx.r[9].s64 = ctx.r[11].s64 + 5636;
	// 829A4C1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4C20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4C24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4C28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4C2C: 48000008  b 0x829a4c34
	pc = 0x829A4C34; continue 'dispatch;
	// 829A4C30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4C34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4C3C: 409A0044  bne cr6, 0x829a4c80
	if !ctx.cr[6].eq {
	pc = 0x829A4C80; continue 'dispatch;
	}
	// 829A4C40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4C44: 419A001C  beq cr6, 0x829a4c60
	if ctx.cr[6].eq {
	pc = 0x829A4C60; continue 'dispatch;
	}
	// 829A4C48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4C4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4C54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4C58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4C5C: 4E800421  bctrl
	ctx.lr = 0x829A4C60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4C60: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4C64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4C68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4C6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4C70: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4C74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4C78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4C7C: 4B91B385  bl 0x822c0000
	ctx.lr = 0x829A4C80;
	sub_822C0000(ctx, base);
	// 829A4C80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4C84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4C88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4C8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4C90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4C94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4C98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4CA0 size=196
    let mut pc: u32 = 0x829A4CA0;
    'dispatch: loop {
        match pc {
            0x829A4CA0 => {
    //   block [0x829A4CA0..0x829A4D64)
	// 829A4CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4CA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4CAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4CB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4CB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A4CB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4CBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829A4CC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A4CC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4CC8: 4B91BC71  bl 0x822c0938
	ctx.lr = 0x829A4CCC;
	sub_822C0938(ctx, base);
	// 829A4CCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A4CD0: 41820028  beq 0x829a4cf8
	if ctx.cr[0].eq {
	pc = 0x829A4CF8; continue 'dispatch;
	}
	// 829A4CD4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4CD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829A4CDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A4CE0: 392B1618  addi r9, r11, 0x1618
	ctx.r[9].s64 = ctx.r[11].s64 + 5656;
	// 829A4CE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829A4CE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A4CEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829A4CF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829A4CF4: 48000008  b 0x829a4cfc
	pc = 0x829A4CFC; continue 'dispatch;
	// 829A4CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A4CFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A4D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4D04: 409A0044  bne cr6, 0x829a4d48
	if !ctx.cr[6].eq {
	pc = 0x829A4D48; continue 'dispatch;
	}
	// 829A4D08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A4D0C: 419A001C  beq cr6, 0x829a4d28
	if ctx.cr[6].eq {
	pc = 0x829A4D28; continue 'dispatch;
	}
	// 829A4D10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4D14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A4D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4D1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4D20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4D24: 4E800421  bctrl
	ctx.lr = 0x829A4D28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4D28: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A4D2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A4D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4D34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829A4D38: 816B7F84  lwz r11, 0x7f84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32644 as u32) ) } as u64;
	// 829A4D3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4D40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4D44: 4B91B2BD  bl 0x822c0000
	ctx.lr = 0x829A4D48;
	sub_822C0000(ctx, base);
	// 829A4D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A4D4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4D50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4D54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4D58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4D5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4D68 size=364
    let mut pc: u32 = 0x829A4D68;
    'dispatch: loop {
        match pc {
            0x829A4D68 => {
    //   block [0x829A4D68..0x829A4ED4)
	// 829A4D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4D78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A4D80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A4D84: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 829A4D88: 895F03A8  lbz r10, 0x3a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 829A4D8C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829A4D90: 419A0128  beq cr6, 0x829a4eb8
	if ctx.cr[6].eq {
	pc = 0x829A4EB8; continue 'dispatch;
	}
	// 829A4D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4D98: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 829A4D9C: 815F038C  lwz r10, 0x38c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 829A4DA0: 419A00B4  beq cr6, 0x829a4e54
	if ctx.cr[6].eq {
	pc = 0x829A4E54; continue 'dispatch;
	}
	// 829A4DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4DA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A4DAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829A4DB0: 419A0024  beq cr6, 0x829a4dd4
	if ctx.cr[6].eq {
	pc = 0x829A4DD4; continue 'dispatch;
	}
	// 829A4DB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A4DB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A4DBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A4DC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A4DC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A4DC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A4DCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A4DD0: 4082FFE8  bne 0x829a4db8
	if !ctx.cr[0].eq {
	pc = 0x829A4DB8; continue 'dispatch;
	}
	// 829A4DD4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829A4DD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A4DDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829A4DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4DE4: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 829A4DE8: 4BB6BC11  bl 0x825109f8
	ctx.lr = 0x829A4DEC;
	sub_825109F8(ctx, base);
	// 829A4DEC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829A4DF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A4DF4: 419A0008  beq cr6, 0x829a4dfc
	if ctx.cr[6].eq {
	pc = 0x829A4DFC; continue 'dispatch;
	}
	// 829A4DF8: 4B91BA99  bl 0x822c0890
	ctx.lr = 0x829A4DFC;
	sub_822C0890(ctx, base);
	// 829A4DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4E00: 809F03B0  lwz r4, 0x3b0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 829A4E04: 4BB6CEBD  bl 0x82511cc0
	ctx.lr = 0x829A4E08;
	sub_82511CC0(ctx, base);
	// 829A4E08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A4E10: 38AB1650  addi r5, r11, 0x1650
	ctx.r[5].s64 = ctx.r[11].s64 + 5712;
	// 829A4E14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829A4E18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4E1C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829A4E20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4E24: 4E800421  bctrl
	ctx.lr = 0x829A4E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4E28: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A4E2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A4E30: 419A0008  beq cr6, 0x829a4e38
	if ctx.cr[6].eq {
	pc = 0x829A4E38; continue 'dispatch;
	}
	// 829A4E34: 4B91BA5D  bl 0x822c0890
	ctx.lr = 0x829A4E38;
	sub_822C0890(ctx, base);
	// 829A4E38: 807F0344  lwz r3, 0x344(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(836 as u32) ) } as u64;
	// 829A4E3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A4E40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A4E44: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829A4E48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A4E4C: 4E800421  bctrl
	ctx.lr = 0x829A4E50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A4E50: 48000068  b 0x829a4eb8
	pc = 0x829A4EB8; continue 'dispatch;
	// 829A4E54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A4E58: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829A4E5C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 829A4E60: 419A0024  beq cr6, 0x829a4e84
	if ctx.cr[6].eq {
	pc = 0x829A4E84; continue 'dispatch;
	}
	// 829A4E64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A4E68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A4E6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A4E70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A4E74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A4E78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A4E7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A4E80: 4082FFE8  bne 0x829a4e68
	if !ctx.cr[0].eq {
	pc = 0x829A4E68; continue 'dispatch;
	}
	// 829A4E84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829A4E88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A4E8C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829A4E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4E94: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 829A4E98: 4BB6B229  bl 0x825100c0
	ctx.lr = 0x829A4E9C;
	sub_825100C0(ctx, base);
	// 829A4E9C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A4EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A4EA4: 419A0008  beq cr6, 0x829a4eac
	if ctx.cr[6].eq {
	pc = 0x829A4EAC; continue 'dispatch;
	}
	// 829A4EA8: 4B91B9E9  bl 0x822c0890
	ctx.lr = 0x829A4EAC;
	sub_822C0890(ctx, base);
	// 829A4EAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4EB0: 809F03B0  lwz r4, 0x3b0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 829A4EB4: 4BB6CDED  bl 0x82511ca0
	ctx.lr = 0x829A4EB8;
	sub_82511CA0(ctx, base);
	// 829A4EB8: 9BDF03A8  stb r30, 0x3a8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[30].u8 ) };
	// 829A4EBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829A4EC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4EC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4EC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A4ED8 size=200
    let mut pc: u32 = 0x829A4ED8;
    'dispatch: loop {
        match pc {
            0x829A4ED8 => {
    //   block [0x829A4ED8..0x829A4FA0)
	// 829A4ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4EE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4EE4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4EE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A4EEC: 7C8B0775  extsb. r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A4EF0: 4082009C  bne 0x829a4f8c
	if !ctx.cr[0].eq {
	pc = 0x829A4F8C; continue 'dispatch;
	}
	// 829A4EF4: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829A4EF8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829A4EFC: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 829A4F00: 41980048  blt cr6, 0x829a4f48
	if ctx.cr[6].lt {
	pc = 0x829A4F48; continue 'dispatch;
	}
	// 829A4F04: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829A4F08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4F0C: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829A4F10: 4844EAF9  bl 0x82df3a08
	ctx.lr = 0x829A4F14;
	sub_82DF3A08(ctx, base);
	// 829A4F14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A4F18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829A4F1C: 809F0170  lwz r4, 0x170(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 829A4F20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829A4F24: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829A4F28: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829A4F2C: 4820E44D  bl 0x82bb3378
	ctx.lr = 0x829A4F30;
	sub_82BB3378(ctx, base);
	// 829A4F30: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A4F34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A4F38: 419A0008  beq cr6, 0x829a4f40
	if ctx.cr[6].eq {
	pc = 0x829A4F40; continue 'dispatch;
	}
	// 829A4F3C: 4B91B955  bl 0x822c0890
	ctx.lr = 0x829A4F40;
	sub_822C0890(ctx, base);
	// 829A4F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A4F44: 48000044  b 0x829a4f88
	pc = 0x829A4F88; continue 'dispatch;
	// 829A4F48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A4F4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829A4F50: 388B1668  addi r4, r11, 0x1668
	ctx.r[4].s64 = ctx.r[11].s64 + 5736;
	// 829A4F54: 4844EAB5  bl 0x82df3a08
	ctx.lr = 0x829A4F58;
	sub_82DF3A08(ctx, base);
	// 829A4F58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A4F5C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829A4F60: 809F0170  lwz r4, 0x170(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 829A4F64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829A4F68: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829A4F6C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829A4F70: 4820E409  bl 0x82bb3378
	ctx.lr = 0x829A4F74;
	sub_82BB3378(ctx, base);
	// 829A4F74: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A4F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A4F7C: 419A0008  beq cr6, 0x829a4f84
	if ctx.cr[6].eq {
	pc = 0x829A4F84; continue 'dispatch;
	}
	// 829A4F80: 4B91B911  bl 0x822c0890
	ctx.lr = 0x829A4F84;
	sub_822C0890(ctx, base);
	// 829A4F84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829A4F88: 4844E4A1  bl 0x82df3428
	ctx.lr = 0x829A4F8C;
	sub_82DF3428(ctx, base);
	// 829A4F8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829A4F90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4F94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4F98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4F9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A4FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A4FA0 size=96
    let mut pc: u32 = 0x829A4FA0;
    'dispatch: loop {
        match pc {
            0x829A4FA0 => {
    //   block [0x829A4FA0..0x829A5000)
	// 829A4FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A4FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A4FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A4FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A4FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A4FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A4FB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A4FBC: 807F01B4  lwz r3, 0x1b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 829A4FC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A4FC4: 419A0008  beq cr6, 0x829a4fcc
	if ctx.cr[6].eq {
	pc = 0x829A4FCC; continue 'dispatch;
	}
	// 829A4FC8: 4B91B8C9  bl 0x822c0890
	ctx.lr = 0x829A4FCC;
	sub_822C0890(ctx, base);
	// 829A4FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4FD0: 484B75B9  bl 0x82e5c588
	ctx.lr = 0x829A4FD4;
	sub_82E5C588(ctx, base);
	// 829A4FD4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A4FD8: 4182000C  beq 0x829a4fe4
	if ctx.cr[0].eq {
	pc = 0x829A4FE4; continue 'dispatch;
	}
	// 829A4FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4FE0: 4844D3F9  bl 0x82df23d8
	ctx.lr = 0x829A4FE4;
	sub_82DF23D8(ctx, base);
	// 829A4FE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A4FE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A4FEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A4FF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A4FF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A4FF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A4FFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A5000 size=96
    let mut pc: u32 = 0x829A5000;
    'dispatch: loop {
        match pc {
            0x829A5000 => {
    //   block [0x829A5000..0x829A5060)
	// 829A5000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A5008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A500C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A5010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A5018: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A501C: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 829A5020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5024: 419A0008  beq cr6, 0x829a502c
	if ctx.cr[6].eq {
	pc = 0x829A502C; continue 'dispatch;
	}
	// 829A5028: 4B91B869  bl 0x822c0890
	ctx.lr = 0x829A502C;
	sub_822C0890(ctx, base);
	// 829A502C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A5030: 484B7559  bl 0x82e5c588
	ctx.lr = 0x829A5034;
	sub_82E5C588(ctx, base);
	// 829A5034: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A5038: 4182000C  beq 0x829a5044
	if ctx.cr[0].eq {
	pc = 0x829A5044; continue 'dispatch;
	}
	// 829A503C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A5040: 4844D399  bl 0x82df23d8
	ctx.lr = 0x829A5044;
	sub_82DF23D8(ctx, base);
	// 829A5044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A5048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A504C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A5050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A5054: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A5058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A505C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A5060 size=256
    let mut pc: u32 = 0x829A5060;
    'dispatch: loop {
        match pc {
            0x829A5060 => {
    //   block [0x829A5060..0x829A5160)
	// 829A5060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5064: 48803109  bl 0x831a816c
	ctx.lr = 0x829A5068;
	sub_831A8130(ctx, base);
	// 829A5068: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829A506C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A5074: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829A5078: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829A507C: 397F0224  addi r11, r31, 0x224
	ctx.r[11].s64 = ctx.r[31].s64 + 548;
	// 829A5080: 3BDF021C  addi r30, r31, 0x21c
	ctx.r[30].s64 = ctx.r[31].s64 + 540;
	// 829A5084: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 829A5088: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 829A508C: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 829A5090: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 829A5094: 4B91F3CD  bl 0x822c4460
	ctx.lr = 0x829A5098;
	sub_822C4460(ctx, base);
	// 829A5098: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A509C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 829A50A0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829A50A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829A50A8: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 829A50AC: 4B91F3B5  bl 0x822c4460
	ctx.lr = 0x829A50B0;
	sub_822C4460(ctx, base);
	// 829A50B0: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829A50B4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829A50B8: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 829A50BC: 4098000C  bge cr6, 0x829a50c8
	if !ctx.cr[6].lt {
	pc = 0x829A50C8; continue 'dispatch;
	}
	// 829A50C0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829A50C4: 48000014  b 0x829a50d8
	pc = 0x829A50D8; continue 'dispatch;
	// 829A50C8: 2F0B0046  cmpwi cr6, r11, 0x46
	ctx.cr[6].compare_i32(ctx.r[11].s32, 70, &mut ctx.xer);
	// 829A50CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829A50D0: 41980008  blt cr6, 0x829a50d8
	if ctx.cr[6].lt {
	pc = 0x829A50D8; continue 'dispatch;
	}
	// 829A50D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A50D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A50DC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A50E0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829A50E4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A50E8: 99690010  stb r11, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 829A50EC: D01F022C  stfs f0, 0x22c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), tmp.u32 ) };
	// 829A50F0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829A50F4: C00808A8  lfs f0, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A50F8: D3FF0230  stfs f31, 0x230(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 829A50FC: 4199000C  bgt cr6, 0x829a5108
	if ctx.cr[6].gt {
	pc = 0x829A5108; continue 'dispatch;
	}
	// 829A5100: D01F0230  stfs f0, 0x230(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 829A5104: D01F022C  stfs f0, 0x22c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), tmp.u32 ) };
	// 829A5108: C1BF0364  lfs f13, 0x364(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A510C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829A5110: 41980034  blt cr6, 0x829a5144
	if ctx.cr[6].lt {
	pc = 0x829A5144; continue 'dispatch;
	}
	// 829A5114: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5118: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829A511C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5120: 38AA196C  addi r5, r10, 0x196c
	ctx.r[5].s64 = ctx.r[10].s64 + 6508;
	// 829A5124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A5128: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829A512C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A5130: 4E800421  bctrl
	ctx.lr = 0x829A5134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A5134: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829A5138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A513C: 419A0008  beq cr6, 0x829a5144
	if ctx.cr[6].eq {
	pc = 0x829A5144; continue 'dispatch;
	}
	// 829A5140: 4B91B751  bl 0x822c0890
	ctx.lr = 0x829A5144;
	sub_822C0890(ctx, base);
	// 829A5144: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A514C: 419A0008  beq cr6, 0x829a5154
	if ctx.cr[6].eq {
	pc = 0x829A5154; continue 'dispatch;
	}
	// 829A5150: 4B91B741  bl 0x822c0890
	ctx.lr = 0x829A5154;
	sub_822C0890(ctx, base);
	// 829A5154: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829A5158: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829A515C: 48803060  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A5160 size=576
    let mut pc: u32 = 0x829A5160;
    'dispatch: loop {
        match pc {
            0x829A5160 => {
    //   block [0x829A5160..0x829A53A0)
	// 829A5160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5164: 48803001  bl 0x831a8164
	ctx.lr = 0x829A5168;
	sub_831A8130(ctx, base);
	// 829A5168: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829A516C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829A5170: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5174: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A5178: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829A517C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A5180: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829A5184: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829A5188: 809F021C  lwz r4, 0x21c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 829A518C: 839F0224  lwz r28, 0x224(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 829A5190: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5194: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5198: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A519C: 4E800421  bctrl
	ctx.lr = 0x829A51A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A51A0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A51A4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829A51A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829A51AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A51B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A51B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A51B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A51BC: 4E800421  bctrl
	ctx.lr = 0x829A51C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A51C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A51C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A51C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A51CC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829A51D0: 484D80F9  bl 0x82e7d2c8
	ctx.lr = 0x829A51D4;
	sub_82E7D2C8(ctx, base);
	// 829A51D4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 829A51D8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A51DC: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A51E0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829A51E4: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A51E8: C163000C  lfs f11, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829A51EC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829A51F0: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829A51F4: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829A51F8: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829A51FC: 40980030  bge cr6, 0x829a522c
	if !ctx.cr[6].lt {
	pc = 0x829A522C; continue 'dispatch;
	}
	// 829A5200: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829A5204: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829A5208: C00BBA80  lfs f0, -0x4580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A520C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829A5210: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A5214: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A5218: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A521C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829A5220: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829A5224: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829A5228: 48000100  b 0x829a5328
	pc = 0x829A5328; continue 'dispatch;
	// 829A522C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829A5230: C1BF0234  lfs f13, 0x234(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A5234: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 829A5238: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829A523C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829A5240: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 829A5244: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A5248: C00A7F44  lfs f0, 0x7f44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A524C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829A5250: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829A5254: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A5258: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829A525C: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 829A5260: 48806DE1  bl 0x831ac040
	ctx.lr = 0x829A5264;
	sub_831AC040(ctx, base);
	// 829A5264: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829A5268: 3FE08212  lis r31, -0x7dee
	ctx.r[31].s64 = -2112749568;
	// 829A526C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829A5270: C01FDFAC  lfs f0, -0x2054(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A5274: C1ABE830  lfs f13, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A5278: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 829A527C: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829A5280: 48803B49  bl 0x831a8dc8
	ctx.lr = 0x829A5284;
	sub_831A8DC8(ctx, base);
	// 829A5284: C01FDFAC  lfs f0, -0x2054(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A5288: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A528C: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 829A5290: FFC00818  frsp f30, f1
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829A5294: C00BA1C4  lfs f0, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A5298: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829A529C: 48803B2D  bl 0x831a8dc8
	ctx.lr = 0x829A52A0;
	sub_831A8DC8(ctx, base);
	// 829A52A0: C01FDFAC  lfs f0, -0x2054(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A52A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A52A8: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 829A52AC: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829A52B0: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A52B4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829A52B8: 48803B11  bl 0x831a8dc8
	ctx.lr = 0x829A52BC;
	sub_831A8DC8(ctx, base);
	// 829A52BC: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829A52C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A52C4: ED5EF828  fsubs f10, f30, f31
	ctx.f[10].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 829A52C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A52CC: C19FDFAC  lfs f12, -0x2054(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A52D0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829A52D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829A52D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A52DC: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A52E0: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829A52E4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A52E8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829A52EC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829A52F0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829A52F4: EDAA582A  fadds f13, f10, f11
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 829A52F8: C009C664  lfs f0, -0x399c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A52FC: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 829A5300: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829A5304: 484D793D  bl 0x82e7cc40
	ctx.lr = 0x829A5308;
	sub_82E7CC40(ctx, base);
	// 829A5308: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A530C: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A5310: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A5314: C163000C  lfs f11, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829A5318: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829A531C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829A5320: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829A5324: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A53A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829A53A0 size=20
    let mut pc: u32 = 0x829A53A0;
    'dispatch: loop {
        match pc {
            0x829A53A0 => {
    //   block [0x829A53A0..0x829A53B4)
	// 829A53A0: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 829A53A4: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 829A53A8: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 829A53AC: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 829A53B0: 4BB6C9E8  b 0x82511d98
	sub_82511D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A53B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A53B8 size=216
    let mut pc: u32 = 0x829A53B8;
    'dispatch: loop {
        match pc {
            0x829A53B8 => {
    //   block [0x829A53B8..0x829A5490)
	// 829A53B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A53BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A53C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A53C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A53C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A53CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A53D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A53D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A53D8: C1BF03C8  lfs f13, 0x3c8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A53DC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A53E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829A53E4: 41990088  bgt cr6, 0x829a546c
	if ctx.cr[6].gt {
	pc = 0x829A546C; continue 'dispatch;
	}
	// 829A53E8: 897F03CC  lbz r11, 0x3cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 829A53EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A53F0: 4082007C  bne 0x829a546c
	if !ctx.cr[0].eq {
	pc = 0x829A546C; continue 'dispatch;
	}
	// 829A53F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A53F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A53FC: 4BFFE255  bl 0x829a3650
	ctx.lr = 0x829A5400;
	sub_829A3650(ctx, base);
	// 829A5400: 396003E0  li r11, 0x3e0
	ctx.r[11].s64 = 992;
	// 829A5404: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A5490 size=64
    let mut pc: u32 = 0x829A5490;
    'dispatch: loop {
        match pc {
            0x829A5490 => {
    //   block [0x829A5490..0x829A54D0)
	// 829A5490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A5498: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A549C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A54A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A54A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A54A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A54AC: 4BFFE1A5  bl 0x829a3650
	ctx.lr = 0x829A54B0;
	sub_829A3650(ctx, base);
	// 829A54B0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 829A54B4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A54D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A54D0 size=72
    let mut pc: u32 = 0x829A54D0;
    'dispatch: loop {
        match pc {
            0x829A54D0 => {
    //   block [0x829A54D0..0x829A5518)
	// 829A54D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A54D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A54D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A54DC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829A54E0: 419A001C  beq cr6, 0x829a54fc
	if ctx.cr[6].eq {
	pc = 0x829A54FC; continue 'dispatch;
	}
	// 829A54E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829A54E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829A54EC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829A54F0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A54F4: 4BFFDDB5  bl 0x829a32a8
	ctx.lr = 0x829A54F8;
	sub_829A32A8(ctx, base);
	// 829A54F8: 48000010  b 0x829a5508
	pc = 0x829A5508; continue 'dispatch;
	// 829A54FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829A5500: 396B8B08  addi r11, r11, -0x74f8
	ctx.r[11].s64 = ctx.r[11].s64 + -29944;
	// 829A5504: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5508: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829A550C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A5510: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A5514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A5518 size=72
    let mut pc: u32 = 0x829A5518;
    'dispatch: loop {
        match pc {
            0x829A5518 => {
    //   block [0x829A5518..0x829A5560)
	// 829A5518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A551C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A5520: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5524: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829A5528: 419A001C  beq cr6, 0x829a5544
	if ctx.cr[6].eq {
	pc = 0x829A5544; continue 'dispatch;
	}
	// 829A552C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829A5530: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829A5534: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829A5538: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A553C: 4BFFDDF5  bl 0x829a3330
	ctx.lr = 0x829A5540;
	sub_829A3330(ctx, base);
	// 829A5540: 48000010  b 0x829a5550
	pc = 0x829A5550; continue 'dispatch;
	// 829A5544: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829A5548: 396B8BC8  addi r11, r11, -0x7438
	ctx.r[11].s64 = ctx.r[11].s64 + -29752;
	// 829A554C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5550: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829A5554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A5558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A555C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A5560 size=924
    let mut pc: u32 = 0x829A5560;
    'dispatch: loop {
        match pc {
            0x829A5560 => {
    //   block [0x829A5560..0x829A58FC)
	// 829A5560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A5568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A556C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A5570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5574: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829A5578: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829A557C: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 829A5580: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 829A5584: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829A5588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A558C: 4BB6CCD5  bl 0x82512260
	ctx.lr = 0x829A5590;
	sub_82512260(ctx, base);
	// 829A5590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829A5594: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829A5598: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 829A559C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829A55A0: 484B8331  bl 0x82e5d8d0
	ctx.lr = 0x829A55A4;
	sub_82E5D8D0(ctx, base);
	// 829A55A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A55A8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829A55AC: 396B13C0  addi r11, r11, 0x13c0
	ctx.r[11].s64 = ctx.r[11].s64 + 5056;
	// 829A55B0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829A55B4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829A55B8: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829A55BC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829A55C0: 396819EC  addi r11, r8, 0x19ec
	ctx.r[11].s64 = ctx.r[8].s64 + 6636;
	// 829A55C4: 394A19AC  addi r10, r10, 0x19ac
	ctx.r[10].s64 = ctx.r[10].s64 + 6572;
	// 829A55C8: 39291998  addi r9, r9, 0x1998
	ctx.r[9].s64 = ctx.r[9].s64 + 6552;
	// 829A55CC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829A55D0: 39071988  addi r8, r7, 0x1988
	ctx.r[8].s64 = ctx.r[7].s64 + 6536;
	// 829A55D4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829A55D8: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829A55DC: 395F0148  addi r10, r31, 0x148
	ctx.r[10].s64 = ctx.r[31].s64 + 328;
	// 829A55E0: 911F00E8  stw r8, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 829A55E4: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 829A55E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A55EC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A55F0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A55F4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A55F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A55FC: 4080FFF0  bge 0x829a55ec
	if !ctx.cr[0].lt {
	pc = 0x829A55EC; continue 'dispatch;
	}
	// 829A5600: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 829A5604: 395F01BC  addi r10, r31, 0x1bc
	ctx.r[10].s64 = ctx.r[31].s64 + 444;
	// 829A5608: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 829A560C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 829A5610: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 829A5614: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 829A5618: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 829A561C: 917F017C  stw r11, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 829A5620: 917F0180  stw r11, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 829A5624: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 829A5628: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 829A562C: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 829A5630: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 829A5634: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 829A5638: 917F019C  stw r11, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 829A563C: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 829A5640: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 829A5644: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 829A5648: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 829A564C: 917F01B4  stw r11, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 829A5650: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5654: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A5658: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A565C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A5660: 4080FFF0  bge 0x829a5650
	if !ctx.cr[0].lt {
	pc = 0x829A5650; continue 'dispatch;
	}
	// 829A5664: 395F01D4  addi r10, r31, 0x1d4
	ctx.r[10].s64 = ctx.r[31].s64 + 468;
	// 829A5668: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 829A566C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5670: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A5674: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A5678: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A567C: 4080FFF0  bge 0x829a566c
	if !ctx.cr[0].lt {
	pc = 0x829A566C; continue 'dispatch;
	}
	// 829A5680: 395F01EC  addi r10, r31, 0x1ec
	ctx.r[10].s64 = ctx.r[31].s64 + 492;
	// 829A5684: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 829A5688: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A568C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A5690: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A5694: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A5698: 4080FFF0  bge 0x829a5688
	if !ctx.cr[0].lt {
	pc = 0x829A5688; continue 'dispatch;
	}
	// 829A569C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829A56A0: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 829A56A4: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829A56A8: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 829A56AC: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 829A56B0: 395F0254  addi r10, r31, 0x254
	ctx.r[10].s64 = ctx.r[31].s64 + 596;
	// 829A56B4: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 829A56B8: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 829A56BC: C00808A4  lfs f0, 0x8a4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A56C0: C1A79534  lfs f13, -0x6acc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A56C4: D01F0234  stfs f0, 0x234(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 829A56C8: D1BF0238  stfs f13, 0x238(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 829A56CC: 917F023C  stw r11, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 829A56D0: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 829A56D4: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 829A56D8: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 829A56DC: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	// 829A56E0: 917F0250  stw r11, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 829A56E4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A56E8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A56EC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A56F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A56F4: 4080FFF0  bge 0x829a56e4
	if !ctx.cr[0].lt {
	pc = 0x829A56E4; continue 'dispatch;
	}
	// 829A56F8: 395F0294  addi r10, r31, 0x294
	ctx.r[10].s64 = ctx.r[31].s64 + 660;
	// 829A56FC: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 829A5700: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5704: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A5708: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A570C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A5710: 4080FFF0  bge 0x829a5700
	if !ctx.cr[0].lt {
	pc = 0x829A5700; continue 'dispatch;
	}
	// 829A5714: 917F02D4  stw r11, 0x2d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(724 as u32), ctx.r[11].u32 ) };
	// 829A5718: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 829A571C: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 829A5720: 395F02F4  addi r10, r31, 0x2f4
	ctx.r[10].s64 = ctx.r[31].s64 + 756;
	// 829A5724: 917F02DC  stw r11, 0x2dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(732 as u32), ctx.r[11].u32 ) };
	// 829A5728: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 829A572C: 917F02E0  stw r11, 0x2e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(736 as u32), ctx.r[11].u32 ) };
	// 829A5730: 917F02E4  stw r11, 0x2e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(740 as u32), ctx.r[11].u32 ) };
	// 829A5734: 917F02E8  stw r11, 0x2e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(744 as u32), ctx.r[11].u32 ) };
	// 829A5738: 917F02EC  stw r11, 0x2ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(748 as u32), ctx.r[11].u32 ) };
	// 829A573C: 917F02F0  stw r11, 0x2f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 829A5740: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5744: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A5748: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A574C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A5750: 4080FFF0  bge 0x829a5740
	if !ctx.cr[0].lt {
	pc = 0x829A5740; continue 'dispatch;
	}
	// 829A5754: 395F0304  addi r10, r31, 0x304
	ctx.r[10].s64 = ctx.r[31].s64 + 772;
	// 829A5758: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 829A575C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5760: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829A5764: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829A5768: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829A576C: 4080FFF0  bge 0x829a575c
	if !ctx.cr[0].lt {
	pc = 0x829A575C; continue 'dispatch;
	}
	// 829A5770: 917F0314  stw r11, 0x314(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(788 as u32), ctx.r[11].u32 ) };
	// 829A5774: 39200064  li r9, 0x64
	ctx.r[9].s64 = 100;
	// 829A5778: 917F0318  stw r11, 0x318(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(792 as u32), ctx.r[11].u32 ) };
	// 829A577C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 829A5780: 917F031C  stw r11, 0x31c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(796 as u32), ctx.r[11].u32 ) };
	// 829A5784: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829A5788: 917F0320  stw r11, 0x320(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(800 as u32), ctx.r[11].u32 ) };
	// 829A578C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 829A5790: 917F0324  stw r11, 0x324(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(804 as u32), ctx.r[11].u32 ) };
	// 829A5794: 3CA0832D  lis r5, -0x7cd3
	ctx.r[5].s64 = -2094202880;
	// 829A5798: 917F0328  stw r11, 0x328(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(808 as u32), ctx.r[11].u32 ) };
	// 829A579C: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 829A57A0: 917F032C  stw r11, 0x32c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(812 as u32), ctx.r[11].u32 ) };
	// 829A57A4: D01F0330  stfs f0, 0x330(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(816 as u32), tmp.u32 ) };
	// 829A57A8: 917F0334  stw r11, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[11].u32 ) };
	// 829A57AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A57B0: 917F0338  stw r11, 0x338(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(824 as u32), ctx.r[11].u32 ) };
	// 829A57B4: C1861338  lfs f12, 0x1338(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4920 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A57B8: 917F033C  stw r11, 0x33c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(828 as u32), ctx.r[11].u32 ) };
	// 829A57BC: 917F0340  stw r11, 0x340(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(832 as u32), ctx.r[11].u32 ) };
	// 829A57C0: 917F0344  stw r11, 0x344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(836 as u32), ctx.r[11].u32 ) };
	// 829A57C4: 917F0348  stw r11, 0x348(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(840 as u32), ctx.r[11].u32 ) };
	// 829A57C8: 917F034C  stw r11, 0x34c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(844 as u32), ctx.r[11].u32 ) };
	// 829A57CC: 917F0350  stw r11, 0x350(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(848 as u32), ctx.r[11].u32 ) };
	// 829A57D0: 917F0354  stw r11, 0x354(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(852 as u32), ctx.r[11].u32 ) };
	// 829A57D4: 917F0358  stw r11, 0x358(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(856 as u32), ctx.r[11].u32 ) };
	// 829A57D8: 917F035C  stw r11, 0x35c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(860 as u32), ctx.r[11].u32 ) };
	// 829A57DC: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 829A57E0: D01F0364  stfs f0, 0x364(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(868 as u32), tmp.u32 ) };
	// 829A57E4: D01F0368  stfs f0, 0x368(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(872 as u32), tmp.u32 ) };
	// 829A57E8: 814ACAD8  lwz r10, -0x3528(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13608 as u32) ) } as u64;
	// 829A57EC: D01F036C  stfs f0, 0x36c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(876 as u32), tmp.u32 ) };
	// 829A57F0: 917F0370  stw r11, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[11].u32 ) };
	// 829A57F4: 917F0374  stw r11, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[11].u32 ) };
	// 829A57F8: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	// 829A57FC: 917F037C  stw r11, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[11].u32 ) };
	// 829A5800: 917F0380  stw r11, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 829A5804: 917F0384  stw r11, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 829A5808: 991F0388  stb r8, 0x388(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[8].u8 ) };
	// 829A580C: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 829A5810: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 829A5814: 917F0394  stw r11, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 829A5818: 917F0398  stw r11, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 829A581C: 917F039C  stw r11, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 829A5820: 917F03A0  stw r11, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	// 829A5824: D01F03A4  stfs f0, 0x3a4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), tmp.u32 ) };
	// 829A5828: D01F03AC  stfs f0, 0x3ac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 829A582C: 997F03A8  stb r11, 0x3a8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[11].u8 ) };
	// 829A5830: D01F03C0  stfs f0, 0x3c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), tmp.u32 ) };
	// 829A5834: 991F03A9  stb r8, 0x3a9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(937 as u32), ctx.r[8].u8 ) };
	// 829A5838: D01F03C8  stfs f0, 0x3c8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(968 as u32), tmp.u32 ) };
	// 829A583C: 993F03B4  stb r9, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[9].u8 ) };
	// 829A5840: D01F03D0  stfs f0, 0x3d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), tmp.u32 ) };
	// 829A5844: 917F03B8  stw r11, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[11].u32 ) };
	// 829A5848: D01F03D4  stfs f0, 0x3d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), tmp.u32 ) };
	// 829A584C: B17F03BC  sth r11, 0x3bc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[11].u16 ) };
	// 829A5850: 997F03C4  stb r11, 0x3c4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[11].u8 ) };
	// 829A5854: 997F03CC  stb r11, 0x3cc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(972 as u32), ctx.r[11].u8 ) };
	// 829A5858: 98FF03D9  stb r7, 0x3d9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(985 as u32), ctx.r[7].u8 ) };
	// 829A585C: 917F03F0  stw r11, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[11].u32 ) };
	// 829A5860: 917F03F4  stw r11, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 829A5864: 917F03F8  stw r11, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	// 829A5868: 917F03FC  stw r11, 0x3fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1020 as u32), ctx.r[11].u32 ) };
	// 829A586C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 829A5870: 917F0404  stw r11, 0x404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), ctx.r[11].u32 ) };
	// 829A5874: 917F0408  stw r11, 0x408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	// 829A5878: 917F040C  stw r11, 0x40c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), ctx.r[11].u32 ) };
	// 829A587C: D01F0410  stfs f0, 0x410(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829A5880: D01F0414  stfs f0, 0x414(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1044 as u32), tmp.u32 ) };
	// 829A5884: D01F0420  stfs f0, 0x420(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), tmp.u32 ) };
	// 829A5888: D01F0424  stfs f0, 0x424(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 829A588C: D01F0428  stfs f0, 0x428(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 829A5890: D01F042C  stfs f0, 0x42c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), tmp.u32 ) };
	// 829A5894: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A5898: D1BF0430  stfs f13, 0x430(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 829A589C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A58A0: D1BF0434  stfs f13, 0x434(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1076 as u32), tmp.u32 ) };
	// 829A58A4: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A58A8: D1BF0438  stfs f13, 0x438(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 829A58AC: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A58B0: D1BF043C  stfs f13, 0x43c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1084 as u32), tmp.u32 ) };
	// 829A58B4: C1A57F4C  lfs f13, 0x7f4c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32588 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A58B8: 997F046C  stb r11, 0x46c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1132 as u32), ctx.r[11].u8 ) };
	// 829A58BC: C1641980  lfs f11, 0x1980(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(6528 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829A58C0: 915F0470  stw r10, 0x470(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1136 as u32), ctx.r[10].u32 ) };
	// 829A58C4: D01F0440  stfs f0, 0x440(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1088 as u32), tmp.u32 ) };
	// 829A58C8: 915F0474  stw r10, 0x474(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1140 as u32), ctx.r[10].u32 ) };
	// 829A58CC: D19F0444  stfs f12, 0x444(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1092 as u32), tmp.u32 ) };
	// 829A58D0: D01F0468  stfs f0, 0x468(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1128 as u32), tmp.u32 ) };
	// 829A58D4: D01F0478  stfs f0, 0x478(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1144 as u32), tmp.u32 ) };
	// 829A58D8: D01F047C  stfs f0, 0x47c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1148 as u32), tmp.u32 ) };
	// 829A58DC: D1BF0480  stfs f13, 0x480(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1152 as u32), tmp.u32 ) };
	// 829A58E0: D17F0484  stfs f11, 0x484(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1156 as u32), tmp.u32 ) };
	// 829A58E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A58E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A58EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A58F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A58F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A58F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829A5900 size=8
    let mut pc: u32 = 0x829A5900;
    'dispatch: loop {
        match pc {
            0x829A5900 => {
    //   block [0x829A5900..0x829A5908)
	// 829A5900: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 829A5904: 4800115C  b 0x829a6a60
	sub_829A6A60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829A5908 size=8
    let mut pc: u32 = 0x829A5908;
    'dispatch: loop {
        match pc {
            0x829A5908 => {
    //   block [0x829A5908..0x829A5910)
	// 829A5908: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 829A590C: 48001154  b 0x829a6a60
	sub_829A6A60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829A5910 size=8
    let mut pc: u32 = 0x829A5910;
    'dispatch: loop {
        match pc {
            0x829A5910 => {
    //   block [0x829A5910..0x829A5918)
	// 829A5910: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829A5914: 4800114C  b 0x829a6a60
	sub_829A6A60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A5918 size=1028
    let mut pc: u32 = 0x829A5918;
    'dispatch: loop {
        match pc {
            0x829A5918 => {
    //   block [0x829A5918..0x829A5D1C)
	// 829A5918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A591C: 48802845  bl 0x831a8160
	ctx.lr = 0x829A5920;
	sub_831A8130(ctx, base);
	// 829A5920: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A5928: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A592C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829A5930: 396B19AC  addi r11, r11, 0x19ac
	ctx.r[11].s64 = ctx.r[11].s64 + 6572;
	// 829A5934: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829A5938: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829A593C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A5940: 394A1998  addi r10, r10, 0x1998
	ctx.r[10].s64 = ctx.r[10].s64 + 6552;
	// 829A5944: 392919EC  addi r9, r9, 0x19ec
	ctx.r[9].s64 = ctx.r[9].s64 + 6636;
	// 829A5948: 39681988  addi r11, r8, 0x1988
	ctx.r[11].s64 = ctx.r[8].s64 + 6536;
	// 829A594C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829A5950: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 829A5954: 3B7F00E4  addi r27, r31, 0xe4
	ctx.r[27].s64 = ctx.r[31].s64 + 228;
	// 829A5958: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829A595C: 3B5F00E8  addi r26, r31, 0xe8
	ctx.r[26].s64 = ctx.r[31].s64 + 232;
	// 829A5960: 807F040C  lwz r3, 0x40c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 829A5964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5968: 419A0008  beq cr6, 0x829a5970
	if ctx.cr[6].eq {
	pc = 0x829A5970; continue 'dispatch;
	}
	// 829A596C: 4B91AF25  bl 0x822c0890
	ctx.lr = 0x829A5970;
	sub_822C0890(ctx, base);
	// 829A5970: 807F0404  lwz r3, 0x404(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 829A5974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5978: 419A0008  beq cr6, 0x829a5980
	if ctx.cr[6].eq {
	pc = 0x829A5980; continue 'dispatch;
	}
	// 829A597C: 4B91AF15  bl 0x822c0890
	ctx.lr = 0x829A5980;
	sub_822C0890(ctx, base);
	// 829A5980: 807F03FC  lwz r3, 0x3fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 829A5984: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5988: 419A0008  beq cr6, 0x829a5990
	if ctx.cr[6].eq {
	pc = 0x829A5990; continue 'dispatch;
	}
	// 829A598C: 4B91AF05  bl 0x822c0890
	ctx.lr = 0x829A5990;
	sub_822C0890(ctx, base);
	// 829A5990: 807F03F4  lwz r3, 0x3f4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 829A5994: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5998: 419A0008  beq cr6, 0x829a59a0
	if ctx.cr[6].eq {
	pc = 0x829A59A0; continue 'dispatch;
	}
	// 829A599C: 4B91AEF5  bl 0x822c0890
	ctx.lr = 0x829A59A0;
	sub_822C0890(ctx, base);
	// 829A59A0: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 829A59A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A59A8: 419A0008  beq cr6, 0x829a59b0
	if ctx.cr[6].eq {
	pc = 0x829A59B0; continue 'dispatch;
	}
	// 829A59AC: 4B91AEE5  bl 0x822c0890
	ctx.lr = 0x829A59B0;
	sub_822C0890(ctx, base);
	// 829A59B0: 807F0398  lwz r3, 0x398(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 829A59B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A59B8: 419A0008  beq cr6, 0x829a59c0
	if ctx.cr[6].eq {
	pc = 0x829A59C0; continue 'dispatch;
	}
	// 829A59BC: 4B91AED5  bl 0x822c0890
	ctx.lr = 0x829A59C0;
	sub_822C0890(ctx, base);
	// 829A59C0: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 829A59C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A59C8: 419A0008  beq cr6, 0x829a59d0
	if ctx.cr[6].eq {
	pc = 0x829A59D0; continue 'dispatch;
	}
	// 829A59CC: 4B91AEC5  bl 0x822c0890
	ctx.lr = 0x829A59D0;
	sub_822C0890(ctx, base);
	// 829A59D0: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 829A59D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A59D8: 419A0008  beq cr6, 0x829a59e0
	if ctx.cr[6].eq {
	pc = 0x829A59E0; continue 'dispatch;
	}
	// 829A59DC: 4B91AEB5  bl 0x822c0890
	ctx.lr = 0x829A59E0;
	sub_822C0890(ctx, base);
	// 829A59E0: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 829A59E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A59E8: 419A0008  beq cr6, 0x829a59f0
	if ctx.cr[6].eq {
	pc = 0x829A59F0; continue 'dispatch;
	}
	// 829A59EC: 4B91AEA5  bl 0x822c0890
	ctx.lr = 0x829A59F0;
	sub_822C0890(ctx, base);
	// 829A59F0: 807F0374  lwz r3, 0x374(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 829A59F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A59F8: 419A0008  beq cr6, 0x829a5a00
	if ctx.cr[6].eq {
	pc = 0x829A5A00; continue 'dispatch;
	}
	// 829A59FC: 4B91AE95  bl 0x822c0890
	ctx.lr = 0x829A5A00;
	sub_822C0890(ctx, base);
	// 829A5A00: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 829A5A04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A08: 419A0008  beq cr6, 0x829a5a10
	if ctx.cr[6].eq {
	pc = 0x829A5A10; continue 'dispatch;
	}
	// 829A5A0C: 4B91AE85  bl 0x822c0890
	ctx.lr = 0x829A5A10;
	sub_822C0890(ctx, base);
	// 829A5A10: 807F0358  lwz r3, 0x358(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(856 as u32) ) } as u64;
	// 829A5A14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A18: 419A0008  beq cr6, 0x829a5a20
	if ctx.cr[6].eq {
	pc = 0x829A5A20; continue 'dispatch;
	}
	// 829A5A1C: 4B91AE75  bl 0x822c0890
	ctx.lr = 0x829A5A20;
	sub_822C0890(ctx, base);
	// 829A5A20: 807F0350  lwz r3, 0x350(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(848 as u32) ) } as u64;
	// 829A5A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A28: 419A0008  beq cr6, 0x829a5a30
	if ctx.cr[6].eq {
	pc = 0x829A5A30; continue 'dispatch;
	}
	// 829A5A2C: 4B91AE65  bl 0x822c0890
	ctx.lr = 0x829A5A30;
	sub_822C0890(ctx, base);
	// 829A5A30: 807F0348  lwz r3, 0x348(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(840 as u32) ) } as u64;
	// 829A5A34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A38: 419A0008  beq cr6, 0x829a5a40
	if ctx.cr[6].eq {
	pc = 0x829A5A40; continue 'dispatch;
	}
	// 829A5A3C: 4B91AE55  bl 0x822c0890
	ctx.lr = 0x829A5A40;
	sub_822C0890(ctx, base);
	// 829A5A40: 807F0340  lwz r3, 0x340(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) } as u64;
	// 829A5A44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A48: 419A0008  beq cr6, 0x829a5a50
	if ctx.cr[6].eq {
	pc = 0x829A5A50; continue 'dispatch;
	}
	// 829A5A4C: 4B91AE45  bl 0x822c0890
	ctx.lr = 0x829A5A50;
	sub_822C0890(ctx, base);
	// 829A5A50: 807F0338  lwz r3, 0x338(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) } as u64;
	// 829A5A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A58: 419A0008  beq cr6, 0x829a5a60
	if ctx.cr[6].eq {
	pc = 0x829A5A60; continue 'dispatch;
	}
	// 829A5A5C: 4B91AE35  bl 0x822c0890
	ctx.lr = 0x829A5A60;
	sub_822C0890(ctx, base);
	// 829A5A60: 807F032C  lwz r3, 0x32c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(812 as u32) ) } as u64;
	// 829A5A64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A68: 419A0008  beq cr6, 0x829a5a70
	if ctx.cr[6].eq {
	pc = 0x829A5A70; continue 'dispatch;
	}
	// 829A5A6C: 4B91AE25  bl 0x822c0890
	ctx.lr = 0x829A5A70;
	sub_822C0890(ctx, base);
	// 829A5A70: 807F0324  lwz r3, 0x324(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(804 as u32) ) } as u64;
	// 829A5A74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A78: 419A0008  beq cr6, 0x829a5a80
	if ctx.cr[6].eq {
	pc = 0x829A5A80; continue 'dispatch;
	}
	// 829A5A7C: 4B91AE15  bl 0x822c0890
	ctx.lr = 0x829A5A80;
	sub_822C0890(ctx, base);
	// 829A5A80: 807F031C  lwz r3, 0x31c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(796 as u32) ) } as u64;
	// 829A5A84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5A88: 419A0008  beq cr6, 0x829a5a90
	if ctx.cr[6].eq {
	pc = 0x829A5A90; continue 'dispatch;
	}
	// 829A5A8C: 4B91AE05  bl 0x822c0890
	ctx.lr = 0x829A5A90;
	sub_822C0890(ctx, base);
	// 829A5A90: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 829A5A94: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829A5A98: 397E0304  addi r11, r30, 0x304
	ctx.r[11].s64 = ctx.r[30].s64 + 772;
	// 829A5A9C: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 829A5AA0: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 829A5AA4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5AA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5AAC: 419A0008  beq cr6, 0x829a5ab4
	if ctx.cr[6].eq {
	pc = 0x829A5AB4; continue 'dispatch;
	}
	// 829A5AB0: 4B91ADE1  bl 0x822c0890
	ctx.lr = 0x829A5AB4;
	sub_822C0890(ctx, base);
	// 829A5AB4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829A5AB8: 4080FFE8  bge 0x829a5aa0
	if !ctx.cr[0].lt {
	pc = 0x829A5AA0; continue 'dispatch;
	}
	// 829A5ABC: 397E02F4  addi r11, r30, 0x2f4
	ctx.r[11].s64 = ctx.r[30].s64 + 756;
	// 829A5AC0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 829A5AC4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829A5AC8: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829A5ACC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5AD4: 419A0008  beq cr6, 0x829a5adc
	if ctx.cr[6].eq {
	pc = 0x829A5ADC; continue 'dispatch;
	}
	// 829A5AD8: 4B91ADB9  bl 0x822c0890
	ctx.lr = 0x829A5ADC;
	sub_822C0890(ctx, base);
	// 829A5ADC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829A5AE0: 4080FFE8  bge 0x829a5ac8
	if !ctx.cr[0].lt {
	pc = 0x829A5AC8; continue 'dispatch;
	}
	// 829A5AE4: 807F02F0  lwz r3, 0x2f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 829A5AE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5AEC: 419A0008  beq cr6, 0x829a5af4
	if ctx.cr[6].eq {
	pc = 0x829A5AF4; continue 'dispatch;
	}
	// 829A5AF0: 4B91ADA1  bl 0x822c0890
	ctx.lr = 0x829A5AF4;
	sub_822C0890(ctx, base);
	// 829A5AF4: 807F02E8  lwz r3, 0x2e8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 829A5AF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5AFC: 419A0008  beq cr6, 0x829a5b04
	if ctx.cr[6].eq {
	pc = 0x829A5B04; continue 'dispatch;
	}
	// 829A5B00: 4B91AD91  bl 0x822c0890
	ctx.lr = 0x829A5B04;
	sub_822C0890(ctx, base);
	// 829A5B04: 807F02E0  lwz r3, 0x2e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) } as u64;
	// 829A5B08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5B0C: 419A0008  beq cr6, 0x829a5b14
	if ctx.cr[6].eq {
	pc = 0x829A5B14; continue 'dispatch;
	}
	// 829A5B10: 4B91AD81  bl 0x822c0890
	ctx.lr = 0x829A5B14;
	sub_822C0890(ctx, base);
	// 829A5B14: 807F02D8  lwz r3, 0x2d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(728 as u32) ) } as u64;
	// 829A5B18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5B1C: 419A0008  beq cr6, 0x829a5b24
	if ctx.cr[6].eq {
	pc = 0x829A5B24; continue 'dispatch;
	}
	// 829A5B20: 4B91AD71  bl 0x822c0890
	ctx.lr = 0x829A5B24;
	sub_822C0890(ctx, base);
	// 829A5B24: 3BDF0040  addi r30, r31, 0x40
	ctx.r[30].s64 = ctx.r[31].s64 + 64;
	// 829A5B28: 3B800007  li r28, 7
	ctx.r[28].s64 = 7;
	// 829A5B2C: 397E0294  addi r11, r30, 0x294
	ctx.r[11].s64 = ctx.r[30].s64 + 660;
	// 829A5B30: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 829A5B34: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 829A5B38: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5B3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5B40: 419A0008  beq cr6, 0x829a5b48
	if ctx.cr[6].eq {
	pc = 0x829A5B48; continue 'dispatch;
	}
	// 829A5B44: 4B91AD4D  bl 0x822c0890
	ctx.lr = 0x829A5B48;
	sub_822C0890(ctx, base);
	// 829A5B48: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829A5B4C: 4080FFE8  bge 0x829a5b34
	if !ctx.cr[0].lt {
	pc = 0x829A5B34; continue 'dispatch;
	}
	// 829A5B50: 397E0254  addi r11, r30, 0x254
	ctx.r[11].s64 = ctx.r[30].s64 + 596;
	// 829A5B54: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 829A5B58: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829A5B5C: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829A5B60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5B64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5B68: 419A0008  beq cr6, 0x829a5b70
	if ctx.cr[6].eq {
	pc = 0x829A5B70; continue 'dispatch;
	}
	// 829A5B6C: 4B91AD25  bl 0x822c0890
	ctx.lr = 0x829A5B70;
	sub_822C0890(ctx, base);
	// 829A5B70: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829A5B74: 4080FFE8  bge 0x829a5b5c
	if !ctx.cr[0].lt {
	pc = 0x829A5B5C; continue 'dispatch;
	}
	// 829A5B78: 807F0250  lwz r3, 0x250(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 829A5B7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5B80: 419A0008  beq cr6, 0x829a5b88
	if ctx.cr[6].eq {
	pc = 0x829A5B88; continue 'dispatch;
	}
	// 829A5B84: 4B91AD0D  bl 0x822c0890
	ctx.lr = 0x829A5B88;
	sub_822C0890(ctx, base);
	// 829A5B88: 807F0248  lwz r3, 0x248(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 829A5B8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5B90: 419A0008  beq cr6, 0x829a5b98
	if ctx.cr[6].eq {
	pc = 0x829A5B98; continue 'dispatch;
	}
	// 829A5B94: 4B91ACFD  bl 0x822c0890
	ctx.lr = 0x829A5B98;
	sub_822C0890(ctx, base);
	// 829A5B98: 807F0240  lwz r3, 0x240(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 829A5B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5BA0: 419A0008  beq cr6, 0x829a5ba8
	if ctx.cr[6].eq {
	pc = 0x829A5BA8; continue 'dispatch;
	}
	// 829A5BA4: 4B91ACED  bl 0x822c0890
	ctx.lr = 0x829A5BA8;
	sub_822C0890(ctx, base);
	// 829A5BA8: 807F0228  lwz r3, 0x228(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 829A5BAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5BB0: 419A0008  beq cr6, 0x829a5bb8
	if ctx.cr[6].eq {
	pc = 0x829A5BB8; continue 'dispatch;
	}
	// 829A5BB4: 4B91ACDD  bl 0x822c0890
	ctx.lr = 0x829A5BB8;
	sub_822C0890(ctx, base);
	// 829A5BB8: 807F0220  lwz r3, 0x220(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 829A5BBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5BC0: 419A0008  beq cr6, 0x829a5bc8
	if ctx.cr[6].eq {
	pc = 0x829A5BC8; continue 'dispatch;
	}
	// 829A5BC4: 4B91ACCD  bl 0x822c0890
	ctx.lr = 0x829A5BC8;
	sub_822C0890(ctx, base);
	// 829A5BC8: 397F021C  addi r11, r31, 0x21c
	ctx.r[11].s64 = ctx.r[31].s64 + 540;
	// 829A5BCC: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 829A5BD0: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829A5BD4: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829A5BD8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5BDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5BE0: 419A0008  beq cr6, 0x829a5be8
	if ctx.cr[6].eq {
	pc = 0x829A5BE8; continue 'dispatch;
	}
	// 829A5BE4: 4B91ACAD  bl 0x822c0890
	ctx.lr = 0x829A5BE8;
	sub_822C0890(ctx, base);
	// 829A5BE8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829A5BEC: 4080FFE8  bge 0x829a5bd4
	if !ctx.cr[0].lt {
	pc = 0x829A5BD4; continue 'dispatch;
	}
	// 829A5BF0: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 829A5BF4: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 829A5BF8: 397E01D4  addi r11, r30, 0x1d4
	ctx.r[11].s64 = ctx.r[30].s64 + 468;
	// 829A5BFC: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 829A5C00: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 829A5C04: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C0C: 419A0008  beq cr6, 0x829a5c14
	if ctx.cr[6].eq {
	pc = 0x829A5C14; continue 'dispatch;
	}
	// 829A5C10: 4B91AC81  bl 0x822c0890
	ctx.lr = 0x829A5C14;
	sub_822C0890(ctx, base);
	// 829A5C14: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829A5C18: 4080FFE8  bge 0x829a5c00
	if !ctx.cr[0].lt {
	pc = 0x829A5C00; continue 'dispatch;
	}
	// 829A5C1C: 397E01BC  addi r11, r30, 0x1bc
	ctx.r[11].s64 = ctx.r[30].s64 + 444;
	// 829A5C20: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 829A5C24: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829A5C28: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829A5C2C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C34: 419A0008  beq cr6, 0x829a5c3c
	if ctx.cr[6].eq {
	pc = 0x829A5C3C; continue 'dispatch;
	}
	// 829A5C38: 4B91AC59  bl 0x822c0890
	ctx.lr = 0x829A5C3C;
	sub_822C0890(ctx, base);
	// 829A5C3C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829A5C40: 4080FFE8  bge 0x829a5c28
	if !ctx.cr[0].lt {
	pc = 0x829A5C28; continue 'dispatch;
	}
	// 829A5C44: 807F01B4  lwz r3, 0x1b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 829A5C48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C4C: 419A0008  beq cr6, 0x829a5c54
	if ctx.cr[6].eq {
	pc = 0x829A5C54; continue 'dispatch;
	}
	// 829A5C50: 4B91AC41  bl 0x822c0890
	ctx.lr = 0x829A5C54;
	sub_822C0890(ctx, base);
	// 829A5C54: 807F01AC  lwz r3, 0x1ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 829A5C58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C5C: 419A0008  beq cr6, 0x829a5c64
	if ctx.cr[6].eq {
	pc = 0x829A5C64; continue 'dispatch;
	}
	// 829A5C60: 4B91AC31  bl 0x822c0890
	ctx.lr = 0x829A5C64;
	sub_822C0890(ctx, base);
	// 829A5C64: 807F01A0  lwz r3, 0x1a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 829A5C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C6C: 419A0008  beq cr6, 0x829a5c74
	if ctx.cr[6].eq {
	pc = 0x829A5C74; continue 'dispatch;
	}
	// 829A5C70: 4B91AC21  bl 0x822c0890
	ctx.lr = 0x829A5C74;
	sub_822C0890(ctx, base);
	// 829A5C74: 807F0198  lwz r3, 0x198(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 829A5C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C7C: 419A0008  beq cr6, 0x829a5c84
	if ctx.cr[6].eq {
	pc = 0x829A5C84; continue 'dispatch;
	}
	// 829A5C80: 4B91AC11  bl 0x822c0890
	ctx.lr = 0x829A5C84;
	sub_822C0890(ctx, base);
	// 829A5C84: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 829A5C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C8C: 419A0008  beq cr6, 0x829a5c94
	if ctx.cr[6].eq {
	pc = 0x829A5C94; continue 'dispatch;
	}
	// 829A5C90: 4B91AC01  bl 0x822c0890
	ctx.lr = 0x829A5C94;
	sub_822C0890(ctx, base);
	// 829A5C94: 807F0184  lwz r3, 0x184(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 829A5C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5C9C: 419A0008  beq cr6, 0x829a5ca4
	if ctx.cr[6].eq {
	pc = 0x829A5CA4; continue 'dispatch;
	}
	// 829A5CA0: 4B91ABF1  bl 0x822c0890
	ctx.lr = 0x829A5CA4;
	sub_822C0890(ctx, base);
	// 829A5CA4: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 829A5CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5CAC: 419A0008  beq cr6, 0x829a5cb4
	if ctx.cr[6].eq {
	pc = 0x829A5CB4; continue 'dispatch;
	}
	// 829A5CB0: 4B91ABE1  bl 0x822c0890
	ctx.lr = 0x829A5CB4;
	sub_822C0890(ctx, base);
	// 829A5CB4: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 829A5CB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5CBC: 419A0008  beq cr6, 0x829a5cc4
	if ctx.cr[6].eq {
	pc = 0x829A5CC4; continue 'dispatch;
	}
	// 829A5CC0: 4B91ABD1  bl 0x822c0890
	ctx.lr = 0x829A5CC4;
	sub_822C0890(ctx, base);
	// 829A5CC4: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 829A5CC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5CCC: 419A0008  beq cr6, 0x829a5cd4
	if ctx.cr[6].eq {
	pc = 0x829A5CD4; continue 'dispatch;
	}
	// 829A5CD0: 4B91ABC1  bl 0x822c0890
	ctx.lr = 0x829A5CD4;
	sub_822C0890(ctx, base);
	// 829A5CD4: 397F0168  addi r11, r31, 0x168
	ctx.r[11].s64 = ctx.r[31].s64 + 360;
	// 829A5CD8: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 829A5CDC: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829A5CE0: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829A5CE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5CE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5CEC: 419A0008  beq cr6, 0x829a5cf4
	if ctx.cr[6].eq {
	pc = 0x829A5CF4; continue 'dispatch;
	}
	// 829A5CF0: 4B91ABA1  bl 0x822c0890
	ctx.lr = 0x829A5CF4;
	sub_822C0890(ctx, base);
	// 829A5CF4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829A5CF8: 4080FFE8  bge 0x829a5ce0
	if !ctx.cr[0].lt {
	pc = 0x829A5CE0; continue 'dispatch;
	}
	// 829A5CFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A5D00: 484B7B49  bl 0x82e5d848
	ctx.lr = 0x829A5D04;
	sub_82E5D848(ctx, base);
	// 829A5D04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829A5D08: 4BE01951  bl 0x827a7658
	ctx.lr = 0x829A5D0C;
	sub_827A7658(ctx, base);
	// 829A5D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A5D10: 4B9A9641  bl 0x8234f350
	ctx.lr = 0x829A5D14;
	sub_8234F350(ctx, base);
	// 829A5D14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829A5D18: 48802498  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A5D20 size=104
    let mut pc: u32 = 0x829A5D20;
    'dispatch: loop {
        match pc {
            0x829A5D20 => {
    //   block [0x829A5D20..0x829A5D88)
	// 829A5D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A5D28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A5D2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A5D34: 484B6BF5  bl 0x82e5c928
	ctx.lr = 0x829A5D38;
	sub_82E5C928(ctx, base);
	// 829A5D38: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829A5D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A5D40: 394A1A38  addi r10, r10, 0x1a38
	ctx.r[10].s64 = ctx.r[10].s64 + 6712;
	// 829A5D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A5D48: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829A5D4C: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829A5D50: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 829A5D54: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 829A5D58: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 829A5D5C: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 829A5D60: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 829A5D64: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 829A5D68: 917F019C  stw r11, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 829A5D6C: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 829A5D70: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 829A5D74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829A5D78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A5D7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A5D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A5D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A5D88 size=76
    let mut pc: u32 = 0x829A5D88;
    'dispatch: loop {
        match pc {
            0x829A5D88 => {
    //   block [0x829A5D88..0x829A5DD4)
	// 829A5D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A5D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A5D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A5D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5D9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A5DA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A5DA4: 4801592D  bl 0x829bb6d0
	ctx.lr = 0x829A5DA8;
	sub_829BB6D0(ctx, base);
	// 829A5DA8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A5DAC: 4182000C  beq 0x829a5db8
	if ctx.cr[0].eq {
	pc = 0x829A5DB8; continue 'dispatch;
	}
	// 829A5DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A5DB4: 4844C625  bl 0x82df23d8
	ctx.lr = 0x829A5DB8;
	sub_82DF23D8(ctx, base);
	// 829A5DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A5DBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A5DC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A5DC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A5DC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A5DCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A5DD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A5DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A5DD8 size=812
    let mut pc: u32 = 0x829A5DD8;
    'dispatch: loop {
        match pc {
            0x829A5DD8 => {
    //   block [0x829A5DD8..0x829A6104)
	// 829A5DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A5DDC: 4880238D  bl 0x831a8168
	ctx.lr = 0x829A5DE0;
	sub_831A8130(ctx, base);
	// 829A5DE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A5DE4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829A5DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A5DEC: 4BB64B65  bl 0x8250a950
	ctx.lr = 0x829A5DF0;
	sub_8250A950(ctx, base);
	// 829A5DF0: 817C023C  lwz r11, 0x23c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(572 as u32) ) } as u64;
	// 829A5DF4: 3BFC023C  addi r31, r28, 0x23c
	ctx.r[31].s64 = ctx.r[28].s64 + 572;
	// 829A5DF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829A5DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5E00: 419A0038  beq cr6, 0x829a5e38
	if ctx.cr[6].eq {
	pc = 0x829A5E38; continue 'dispatch;
	}
	// 829A5E04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A5E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5E0C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A5E10: 409A0008  bne cr6, 0x829a5e18
	if !ctx.cr[6].eq {
	pc = 0x829A5E18; continue 'dispatch;
	}
	// 829A5E14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A5E18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5E1C: 4BE2DBE5  bl 0x827d3a00
	ctx.lr = 0x829A5E20;
	sub_827D3A00(ctx, base);
	// 829A5E20: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A5E24: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5E2C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A5E30: 419A0008  beq cr6, 0x829a5e38
	if ctx.cr[6].eq {
	pc = 0x829A5E38; continue 'dispatch;
	}
	// 829A5E34: 4B91AA5D  bl 0x822c0890
	ctx.lr = 0x829A5E38;
	sub_822C0890(ctx, base);
	// 829A5E38: 817C0244  lwz r11, 0x244(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(580 as u32) ) } as u64;
	// 829A5E3C: 3BFC0244  addi r31, r28, 0x244
	ctx.r[31].s64 = ctx.r[28].s64 + 580;
	// 829A5E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5E44: 419A0038  beq cr6, 0x829a5e7c
	if ctx.cr[6].eq {
	pc = 0x829A5E7C; continue 'dispatch;
	}
	// 829A5E48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A5E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5E50: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A5E54: 409A0008  bne cr6, 0x829a5e5c
	if !ctx.cr[6].eq {
	pc = 0x829A5E5C; continue 'dispatch;
	}
	// 829A5E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A5E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5E60: 4BE2DBA1  bl 0x827d3a00
	ctx.lr = 0x829A5E64;
	sub_827D3A00(ctx, base);
	// 829A5E64: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A5E68: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5E6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5E70: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A5E74: 419A0008  beq cr6, 0x829a5e7c
	if ctx.cr[6].eq {
	pc = 0x829A5E7C; continue 'dispatch;
	}
	// 829A5E78: 4B91AA19  bl 0x822c0890
	ctx.lr = 0x829A5E7C;
	sub_822C0890(ctx, base);
	// 829A5E7C: 817C024C  lwz r11, 0x24c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(588 as u32) ) } as u64;
	// 829A5E80: 3BFC024C  addi r31, r28, 0x24c
	ctx.r[31].s64 = ctx.r[28].s64 + 588;
	// 829A5E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5E88: 419A0038  beq cr6, 0x829a5ec0
	if ctx.cr[6].eq {
	pc = 0x829A5EC0; continue 'dispatch;
	}
	// 829A5E8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A5E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5E94: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A5E98: 409A0008  bne cr6, 0x829a5ea0
	if !ctx.cr[6].eq {
	pc = 0x829A5EA0; continue 'dispatch;
	}
	// 829A5E9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A5EA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5EA4: 4BE2DB5D  bl 0x827d3a00
	ctx.lr = 0x829A5EA8;
	sub_827D3A00(ctx, base);
	// 829A5EA8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A5EAC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5EB0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A5EB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5EB8: 419A0008  beq cr6, 0x829a5ec0
	if ctx.cr[6].eq {
	pc = 0x829A5EC0; continue 'dispatch;
	}
	// 829A5EBC: 4B91A9D5  bl 0x822c0890
	ctx.lr = 0x829A5EC0;
	sub_822C0890(ctx, base);
	// 829A5EC0: 3BFC0254  addi r31, r28, 0x254
	ctx.r[31].s64 = ctx.r[28].s64 + 596;
	// 829A5EC4: 3BA00008  li r29, 8
	ctx.r[29].s64 = 8;
	// 829A5EC8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5ECC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5ED0: 419A0040  beq cr6, 0x829a5f10
	if ctx.cr[6].eq {
	pc = 0x829A5F10; continue 'dispatch;
	}
	// 829A5ED4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A5ED8: 484DB869  bl 0x82e81740
	ctx.lr = 0x829A5EDC;
	sub_82E81740(ctx, base);
	// 829A5EDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A5EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5EE4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A5EE8: 409A0008  bne cr6, 0x829a5ef0
	if !ctx.cr[6].eq {
	pc = 0x829A5EF0; continue 'dispatch;
	}
	// 829A5EEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A5EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5EF4: 4BE2DB0D  bl 0x827d3a00
	ctx.lr = 0x829A5EF8;
	sub_827D3A00(ctx, base);
	// 829A5EF8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A5EFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5F00: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A5F04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5F08: 419A0008  beq cr6, 0x829a5f10
	if ctx.cr[6].eq {
	pc = 0x829A5F10; continue 'dispatch;
	}
	// 829A5F0C: 4B91A985  bl 0x822c0890
	ctx.lr = 0x829A5F10;
	sub_822C0890(ctx, base);
	// 829A5F10: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829A5F14: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829A5F18: 4082FFB0  bne 0x829a5ec8
	if !ctx.cr[0].eq {
	pc = 0x829A5EC8; continue 'dispatch;
	}
	// 829A5F1C: 817C02E4  lwz r11, 0x2e4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(740 as u32) ) } as u64;
	// 829A5F20: 3BFC02E4  addi r31, r28, 0x2e4
	ctx.r[31].s64 = ctx.r[28].s64 + 740;
	// 829A5F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5F28: 419A0038  beq cr6, 0x829a5f60
	if ctx.cr[6].eq {
	pc = 0x829A5F60; continue 'dispatch;
	}
	// 829A5F2C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A5F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5F34: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A5F38: 409A0008  bne cr6, 0x829a5f40
	if !ctx.cr[6].eq {
	pc = 0x829A5F40; continue 'dispatch;
	}
	// 829A5F3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A5F40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5F44: 4BE2DABD  bl 0x827d3a00
	ctx.lr = 0x829A5F48;
	sub_827D3A00(ctx, base);
	// 829A5F48: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A5F4C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5F50: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A5F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5F58: 419A0008  beq cr6, 0x829a5f60
	if ctx.cr[6].eq {
	pc = 0x829A5F60; continue 'dispatch;
	}
	// 829A5F5C: 4B91A935  bl 0x822c0890
	ctx.lr = 0x829A5F60;
	sub_822C0890(ctx, base);
	// 829A5F60: 817C02EC  lwz r11, 0x2ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(748 as u32) ) } as u64;
	// 829A5F64: 3BFC02EC  addi r31, r28, 0x2ec
	ctx.r[31].s64 = ctx.r[28].s64 + 748;
	// 829A5F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5F6C: 419A0038  beq cr6, 0x829a5fa4
	if ctx.cr[6].eq {
	pc = 0x829A5FA4; continue 'dispatch;
	}
	// 829A5F70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A5F74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5F78: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A5F7C: 409A0008  bne cr6, 0x829a5f84
	if !ctx.cr[6].eq {
	pc = 0x829A5F84; continue 'dispatch;
	}
	// 829A5F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A5F84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5F88: 4BE2DA79  bl 0x827d3a00
	ctx.lr = 0x829A5F8C;
	sub_827D3A00(ctx, base);
	// 829A5F8C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A5F90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5F94: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A5F98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5F9C: 419A0008  beq cr6, 0x829a5fa4
	if ctx.cr[6].eq {
	pc = 0x829A5FA4; continue 'dispatch;
	}
	// 829A5FA0: 4B91A8F1  bl 0x822c0890
	ctx.lr = 0x829A5FA4;
	sub_822C0890(ctx, base);
	// 829A5FA4: 817C0370  lwz r11, 0x370(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(880 as u32) ) } as u64;
	// 829A5FA8: 3BFC0370  addi r31, r28, 0x370
	ctx.r[31].s64 = ctx.r[28].s64 + 880;
	// 829A5FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5FB0: 419A0038  beq cr6, 0x829a5fe8
	if ctx.cr[6].eq {
	pc = 0x829A5FE8; continue 'dispatch;
	}
	// 829A5FB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A5FB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5FBC: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A5FC0: 409A0008  bne cr6, 0x829a5fc8
	if !ctx.cr[6].eq {
	pc = 0x829A5FC8; continue 'dispatch;
	}
	// 829A5FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A5FC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A5FCC: 4BE2DA35  bl 0x827d3a00
	ctx.lr = 0x829A5FD0;
	sub_827D3A00(ctx, base);
	// 829A5FD0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A5FD4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A5FD8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A5FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A5FE0: 419A0008  beq cr6, 0x829a5fe8
	if ctx.cr[6].eq {
	pc = 0x829A5FE8; continue 'dispatch;
	}
	// 829A5FE4: 4B91A8AD  bl 0x822c0890
	ctx.lr = 0x829A5FE8;
	sub_822C0890(ctx, base);
	// 829A5FE8: 3BFC0304  addi r31, r28, 0x304
	ctx.r[31].s64 = ctx.r[28].s64 + 772;
	// 829A5FEC: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 829A5FF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A5FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A5FF8: 419A0038  beq cr6, 0x829a6030
	if ctx.cr[6].eq {
	pc = 0x829A6030; continue 'dispatch;
	}
	// 829A5FFC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A6000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6004: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A6008: 409A0008  bne cr6, 0x829a6010
	if !ctx.cr[6].eq {
	pc = 0x829A6010; continue 'dispatch;
	}
	// 829A600C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6014: 4BE2D9ED  bl 0x827d3a00
	ctx.lr = 0x829A6018;
	sub_827D3A00(ctx, base);
	// 829A6018: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A601C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A6020: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A6024: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6028: 419A0008  beq cr6, 0x829a6030
	if ctx.cr[6].eq {
	pc = 0x829A6030; continue 'dispatch;
	}
	// 829A602C: 4B91A865  bl 0x822c0890
	ctx.lr = 0x829A6030;
	sub_822C0890(ctx, base);
	// 829A6030: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829A6034: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829A6038: 4082FFB8  bne 0x829a5ff0
	if !ctx.cr[0].eq {
	pc = 0x829A5FF0; continue 'dispatch;
	}
	// 829A603C: 817C0318  lwz r11, 0x318(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(792 as u32) ) } as u64;
	// 829A6040: 3BFC0318  addi r31, r28, 0x318
	ctx.r[31].s64 = ctx.r[28].s64 + 792;
	// 829A6044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6048: 419A0038  beq cr6, 0x829a6080
	if ctx.cr[6].eq {
	pc = 0x829A6080; continue 'dispatch;
	}
	// 829A604C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A6050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6054: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A6058: 409A0008  bne cr6, 0x829a6060
	if !ctx.cr[6].eq {
	pc = 0x829A6060; continue 'dispatch;
	}
	// 829A605C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6064: 4BE2D99D  bl 0x827d3a00
	ctx.lr = 0x829A6068;
	sub_827D3A00(ctx, base);
	// 829A6068: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A606C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A6070: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A6074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6078: 419A0008  beq cr6, 0x829a6080
	if ctx.cr[6].eq {
	pc = 0x829A6080; continue 'dispatch;
	}
	// 829A607C: 4B91A815  bl 0x822c0890
	ctx.lr = 0x829A6080;
	sub_822C0890(ctx, base);
	// 829A6080: 817C0320  lwz r11, 0x320(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(800 as u32) ) } as u64;
	// 829A6084: 3BFC0320  addi r31, r28, 0x320
	ctx.r[31].s64 = ctx.r[28].s64 + 800;
	// 829A6088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A608C: 419A0038  beq cr6, 0x829a60c4
	if ctx.cr[6].eq {
	pc = 0x829A60C4; continue 'dispatch;
	}
	// 829A6090: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A6094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6098: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A609C: 409A0008  bne cr6, 0x829a60a4
	if !ctx.cr[6].eq {
	pc = 0x829A60A4; continue 'dispatch;
	}
	// 829A60A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A60A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A60A8: 4BE2D959  bl 0x827d3a00
	ctx.lr = 0x829A60AC;
	sub_827D3A00(ctx, base);
	// 829A60AC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829A60B0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A60B4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829A60B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A60BC: 419A0008  beq cr6, 0x829a60c4
	if ctx.cr[6].eq {
	pc = 0x829A60C4; continue 'dispatch;
	}
	// 829A60C0: 4B91A7D1  bl 0x822c0890
	ctx.lr = 0x829A60C4;
	sub_822C0890(ctx, base);
	// 829A60C4: 807C0334  lwz r3, 0x334(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(820 as u32) ) } as u64;
	// 829A60C8: 481A0601  bl 0x82b466c8
	ctx.lr = 0x829A60CC;
	sub_82B466C8(ctx, base);
	// 829A60CC: 807C033C  lwz r3, 0x33c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(828 as u32) ) } as u64;
	// 829A60D0: 481A05F9  bl 0x82b466c8
	ctx.lr = 0x829A60D4;
	sub_82B466C8(ctx, base);
	// 829A60D4: 807C0344  lwz r3, 0x344(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(836 as u32) ) } as u64;
	// 829A60D8: 481A05F1  bl 0x82b466c8
	ctx.lr = 0x829A60DC;
	sub_82B466C8(ctx, base);
	// 829A60DC: 807C034C  lwz r3, 0x34c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(844 as u32) ) } as u64;
	// 829A60E0: 481A05E9  bl 0x82b466c8
	ctx.lr = 0x829A60E4;
	sub_82B466C8(ctx, base);
	// 829A60E4: 807C0354  lwz r3, 0x354(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(852 as u32) ) } as u64;
	// 829A60E8: 481A05E1  bl 0x82b466c8
	ctx.lr = 0x829A60EC;
	sub_82B466C8(ctx, base);
	// 829A60EC: 807C035C  lwz r3, 0x35c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(860 as u32) ) } as u64;
	// 829A60F0: 481A05D9  bl 0x82b466c8
	ctx.lr = 0x829A60F4;
	sub_82B466C8(ctx, base);
	// 829A60F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A60F8: 4844BB99  bl 0x82df1c90
	ctx.lr = 0x829A60FC;
	sub_82DF1C90(ctx, base);
	// 829A60FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829A6100: 488020B8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A6108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A6108 size=480
    let mut pc: u32 = 0x829A6108;
    'dispatch: loop {
        match pc {
            0x829A6108 => {
    //   block [0x829A6108..0x829A62E8)
	// 829A6108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A610C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A6110: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A6114: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A6118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A611C: 817F0474  lwz r11, 0x474(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1140 as u32) ) } as u64;
	// 829A6120: 815F0470  lwz r10, 0x470(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1136 as u32) ) } as u64;
	// 829A6124: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 829A6128: 419A01AC  beq cr6, 0x829a62d4
	if ctx.cr[6].eq {
	pc = 0x829A62D4; continue 'dispatch;
	}
	// 829A612C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A6130: 419800C8  blt cr6, 0x829a61f8
	if ctx.cr[6].lt {
	pc = 0x829A61F8; continue 'dispatch;
	}
	// 829A6134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6138: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829A613C: 4BB6942D  bl 0x8250f568
	ctx.lr = 0x829A6140;
	sub_8250F568(ctx, base);
	// 829A6140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6148: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829A614C: 409A0008  bne cr6, 0x829a6154
	if !ctx.cr[6].eq {
	pc = 0x829A6154; continue 'dispatch;
	}
	// 829A6150: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A6154: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829A6158: 4BE04D89  bl 0x827aaee0
	ctx.lr = 0x829A615C;
	sub_827AAEE0(ctx, base);
	// 829A615C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A6160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A6164: 80BF0474  lwz r5, 0x474(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1140 as u32) ) } as u64;
	// 829A6168: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A616C: 4BE016FD  bl 0x827a7868
	ctx.lr = 0x829A6170;
	sub_827A7868(ctx, base);
	// 829A6170: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A6174: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6178: 419A0008  beq cr6, 0x829a6180
	if ctx.cr[6].eq {
	pc = 0x829A6180; continue 'dispatch;
	}
	// 829A617C: 4B91A715  bl 0x822c0890
	ctx.lr = 0x829A6180;
	sub_822C0890(ctx, base);
	// 829A6180: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829A6184: 4844BB0D  bl 0x82df1c90
	ctx.lr = 0x829A6188;
	sub_82DF1C90(ctx, base);
	// 829A6188: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A618C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6190: 419A0058  beq cr6, 0x829a61e8
	if ctx.cr[6].eq {
	pc = 0x829A61E8; continue 'dispatch;
	}
	// 829A6194: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829A6198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A619C: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 829A61A0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829A61A4: 4BB693C5  bl 0x8250f568
	ctx.lr = 0x829A61A8;
	sub_8250F568(ctx, base);
	// 829A61A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A61AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A61B0: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829A61B4: 409A0008  bne cr6, 0x829a61bc
	if !ctx.cr[6].eq {
	pc = 0x829A61BC; continue 'dispatch;
	}
	// 829A61B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A61BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829A61C0: 4BE04CA1  bl 0x827aae60
	ctx.lr = 0x829A61C4;
	sub_827AAE60(ctx, base);
	// 829A61C4: 809F0474  lwz r4, 0x474(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1140 as u32) ) } as u64;
	// 829A61C8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A61CC: 4BE113ED  bl 0x827b75b8
	ctx.lr = 0x829A61D0;
	sub_827B75B8(ctx, base);
	// 829A61D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829A61D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A61D8: 419A0008  beq cr6, 0x829a61e0
	if ctx.cr[6].eq {
	pc = 0x829A61E0; continue 'dispatch;
	}
	// 829A61DC: 4B91A6B5  bl 0x822c0890
	ctx.lr = 0x829A61E0;
	sub_822C0890(ctx, base);
	// 829A61E0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829A61E4: 4844BAAD  bl 0x82df1c90
	ctx.lr = 0x829A61E8;
	sub_82DF1C90(ctx, base);
	// 829A61E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829A61EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A61F0: 419A0008  beq cr6, 0x829a61f8
	if ctx.cr[6].eq {
	pc = 0x829A61F8; continue 'dispatch;
	}
	// 829A61F4: 4B91A69D  bl 0x822c0890
	ctx.lr = 0x829A61F8;
	sub_822C0890(ctx, base);
	// 829A61F8: 817F0470  lwz r11, 0x470(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1136 as u32) ) } as u64;
	// 829A61FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A6200: 419800CC  blt cr6, 0x829a62cc
	if ctx.cr[6].lt {
	pc = 0x829A62CC; continue 'dispatch;
	}
	// 829A6204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6208: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A620C: 4BB6935D  bl 0x8250f568
	ctx.lr = 0x829A6210;
	sub_8250F568(ctx, base);
	// 829A6210: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6218: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829A621C: 409A0008  bne cr6, 0x829a6224
	if !ctx.cr[6].eq {
	pc = 0x829A6224; continue 'dispatch;
	}
	// 829A6220: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A6224: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A6228: 4BE04CB9  bl 0x827aaee0
	ctx.lr = 0x829A622C;
	sub_827AAEE0(ctx, base);
	// 829A622C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A6230: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829A6234: 80BF0470  lwz r5, 0x470(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1136 as u32) ) } as u64;
	// 829A6238: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A623C: 4BE0162D  bl 0x827a7868
	ctx.lr = 0x829A6240;
	sub_827A7868(ctx, base);
	// 829A6240: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829A6244: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6248: 419A0008  beq cr6, 0x829a6250
	if ctx.cr[6].eq {
	pc = 0x829A6250; continue 'dispatch;
	}
	// 829A624C: 4B91A645  bl 0x822c0890
	ctx.lr = 0x829A6250;
	sub_822C0890(ctx, base);
	// 829A6250: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A6254: 4844BA3D  bl 0x82df1c90
	ctx.lr = 0x829A6258;
	sub_82DF1C90(ctx, base);
	// 829A6258: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829A625C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6260: 419A005C  beq cr6, 0x829a62bc
	if ctx.cr[6].eq {
	pc = 0x829A62BC; continue 'dispatch;
	}
	// 829A6264: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A6268: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A626C: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 829A6270: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A6274: 4BB692F5  bl 0x8250f568
	ctx.lr = 0x829A6278;
	sub_8250F568(ctx, base);
	// 829A6278: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A627C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6280: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829A6284: 409A0008  bne cr6, 0x829a628c
	if !ctx.cr[6].eq {
	pc = 0x829A628C; continue 'dispatch;
	}
	// 829A6288: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A628C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A6290: 4BE04BD1  bl 0x827aae60
	ctx.lr = 0x829A6294;
	sub_827AAE60(ctx, base);
	// 829A6294: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829A6298: 809F0470  lwz r4, 0x470(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1136 as u32) ) } as u64;
	// 829A629C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A62A0: 4BE11809  bl 0x827b7aa8
	ctx.lr = 0x829A62A4;
	sub_827B7AA8(ctx, base);
	// 829A62A4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829A62A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A62AC: 419A0008  beq cr6, 0x829a62b4
	if ctx.cr[6].eq {
	pc = 0x829A62B4; continue 'dispatch;
	}
	// 829A62B0: 4B91A5E1  bl 0x822c0890
	ctx.lr = 0x829A62B4;
	sub_822C0890(ctx, base);
	// 829A62B4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A62B8: 4844B9D9  bl 0x82df1c90
	ctx.lr = 0x829A62BC;
	sub_82DF1C90(ctx, base);
	// 829A62BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A62C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A62C4: 419A0008  beq cr6, 0x829a62cc
	if ctx.cr[6].eq {
	pc = 0x829A62CC; continue 'dispatch;
	}
	// 829A62C8: 4B91A5C9  bl 0x822c0890
	ctx.lr = 0x829A62CC;
	sub_822C0890(ctx, base);
	// 829A62CC: 817F0470  lwz r11, 0x470(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1136 as u32) ) } as u64;
	// 829A62D0: 917F0474  stw r11, 0x474(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1140 as u32), ctx.r[11].u32 ) };
	// 829A62D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829A62D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A62DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A62E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A62E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A62E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829A62E8 size=500
    let mut pc: u32 = 0x829A62E8;
    'dispatch: loop {
        match pc {
            0x829A62E8 => {
    //   block [0x829A62E8..0x829A64DC)
	// 829A62E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A62EC: 48801E81  bl 0x831a816c
	ctx.lr = 0x829A62F0;
	sub_831A8130(ctx, base);
	// 829A62F0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 829A62F4: 48802785  bl 0x831a8a78
	ctx.lr = 0x829A62F8;
	sub_831A8A40(ctx, base);
	// 829A62F8: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A64E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A64E0 size=96
    let mut pc: u32 = 0x829A64E0;
    'dispatch: loop {
        match pc {
            0x829A64E0 => {
    //   block [0x829A64E0..0x829A6540)
	// 829A64E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A64E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A64E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A64EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A64F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A64F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A64F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A64FC: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829A6500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6504: 419A0008  beq cr6, 0x829a650c
	if ctx.cr[6].eq {
	pc = 0x829A650C; continue 'dispatch;
	}
	// 829A6508: 4B91A389  bl 0x822c0890
	ctx.lr = 0x829A650C;
	sub_822C0890(ctx, base);
	// 829A650C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A6510: 484B6079  bl 0x82e5c588
	ctx.lr = 0x829A6514;
	sub_82E5C588(ctx, base);
	// 829A6514: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A6518: 4182000C  beq 0x829a6524
	if ctx.cr[0].eq {
	pc = 0x829A6524; continue 'dispatch;
	}
	// 829A651C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A6520: 4844BEB9  bl 0x82df23d8
	ctx.lr = 0x829A6524;
	sub_82DF23D8(ctx, base);
	// 829A6524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A6528: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A652C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A6530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A6534: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A6538: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A653C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A6540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A6540 size=616
    let mut pc: u32 = 0x829A6540;
    'dispatch: loop {
        match pc {
            0x829A6540 => {
    //   block [0x829A6540..0x829A67A8)
	// 829A6540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A6544: 48801C25  bl 0x831a8168
	ctx.lr = 0x829A6548;
	sub_831A8130(ctx, base);
	// 829A6548: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 829A654C: 48802525  bl 0x831a8a70
	ctx.lr = 0x829A6550;
	sub_831A8A40(ctx, base);
	// 829A6550: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A6554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A6558: C01F022C  lfs f0, 0x22c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A655C: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829A6560: C01F0230  lfs f0, 0x230(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A6564: D1BF022C  stfs f13, 0x22c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), tmp.u32 ) };
	// 829A6568: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829A656C: 40990008  ble cr6, 0x829a6574
	if !ctx.cr[6].gt {
	pc = 0x829A6574; continue 'dispatch;
	}
	// 829A6570: D01F022C  stfs f0, 0x22c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), tmp.u32 ) };
	// 829A6574: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 829A6578: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A657C: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 829A6580: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A6584: D02B0004  stfs f1, 4(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829A6588: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829A658C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829A6590: 4198000C  blt cr6, 0x829a659c
	if ctx.cr[6].lt {
	pc = 0x829A659C; continue 'dispatch;
	}
	// 829A6594: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829A6598: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829A659C: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 829A65A0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A65A4: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 829A65A8: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A65AC: D02B0004  stfs f1, 4(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829A65B0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829A65B4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829A65B8: 4198000C  blt cr6, 0x829a65c4
	if ctx.cr[6].lt {
	pc = 0x829A65C4; continue 'dispatch;
	}
	// 829A65BC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829A65C0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829A65C4: 807F021C  lwz r3, 0x21c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 829A65C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A65CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829A65D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A65D4: 4E800421  bctrl
	ctx.lr = 0x829A65D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A65D8: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 829A65DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A65E0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829A65E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A65E8: 4E800421  bctrl
	ctx.lr = 0x829A65EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A65EC: C1BF022C  lfs f13, 0x22c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A65F0: C19F0230  lfs f12, 0x230(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A65F4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829A65F8: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 829A65FC: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A6600: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829A6604: 488028A5  bl 0x831a8ea8
	ctx.lr = 0x829A6608;
	sub_831A8EA8(ctx, base);
	// 829A6608: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A660C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829A6610: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829A6614: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829A6618: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829A661C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829A6620: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A6624: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829A6628: C34A1A68  lfs f26, 0x1a68(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6760 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 829A662C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829A6630: C3691A64  lfs f27, 0x1a64(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6756 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 829A6634: 3BDF01EC  addi r30, r31, 0x1ec
	ctx.r[30].s64 = ctx.r[31].s64 + 492;
	// 829A6638: C3881A60  lfs f28, 0x1a60(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6752 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829A663C: C3E71A5C  lfs f31, 0x1a5c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(6748 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829A6640: C3CBACFC  lfs f30, -0x5304(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829A6644: EFAD003C  fnmsubs f29, f13, f0, f0
	ctx.f[29].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[0].f64) as f32) as f64);
	// 829A6648: 579D063E  clrlwi r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829A664C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829A6650: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6654: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829A6658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A665C: 4BFFCF4D  bl 0x829a35a8
	ctx.lr = 0x829A6660;
	sub_829A35A8(ctx, base);
	// 829A6660: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829A6664: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 829A6668: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829A666C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829A6670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6674: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829A6678: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A67A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A67A8 size=300
    let mut pc: u32 = 0x829A67A8;
    'dispatch: loop {
        match pc {
            0x829A67A8 => {
    //   block [0x829A67A8..0x829A68D4)
	// 829A67A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A67AC: 488019C1  bl 0x831a816c
	ctx.lr = 0x829A67B0;
	sub_831A8130(ctx, base);
	// 829A67B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A67B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829A67B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829A67BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A67C0: 997D046C  stb r11, 0x46c(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1132 as u32), ctx.r[11].u8 ) };
	// 829A67C4: 4BB6937D  bl 0x8250fb40
	ctx.lr = 0x829A67C8;
	sub_8250FB40(ctx, base);
	// 829A67C8: 3BDD01EC  addi r30, r29, 0x1ec
	ctx.r[30].s64 = ctx.r[29].s64 + 492;
	// 829A67CC: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 829A67D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A67D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A67D8: 4BB69369  bl 0x8250fb40
	ctx.lr = 0x829A67DC;
	sub_8250FB40(ctx, base);
	// 829A67DC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A67E0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829A67E4: 4082FFEC  bne 0x829a67d0
	if !ctx.cr[0].eq {
	pc = 0x829A67D0; continue 'dispatch;
	}
	// 829A67E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A67EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A67F0: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829A67F4: 38A010E4  li r5, 0x10e4
	ctx.r[5].s64 = 4324;
	// 829A67F8: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 829A67FC: 4844BBED  bl 0x82df23e8
	ctx.lr = 0x829A6800;
	sub_82DF23E8(ctx, base);
	// 829A6800: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A6804: 4182001C  beq 0x829a6820
	if ctx.cr[0].eq {
	pc = 0x829A6820; continue 'dispatch;
	}
	// 829A6808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A680C: 484B611D  bl 0x82e5c928
	ctx.lr = 0x829A6810;
	sub_82E5C928(ctx, base);
	// 829A6810: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A6814: 396B1678  addi r11, r11, 0x1678
	ctx.r[11].s64 = ctx.r[11].s64 + 5752;
	// 829A6818: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A681C: 48000008  b 0x829a6824
	pc = 0x829A6824; continue 'dispatch;
	// 829A6820: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829A6824: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829A6828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A682C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829A6830: 4BFFD1B1  bl 0x829a39e0
	ctx.lr = 0x829A6834;
	sub_829A39E0(ctx, base);
	// 829A6834: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A6838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A683C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829A6840: 4B9197C1  bl 0x822c0000
	ctx.lr = 0x829A6844;
	sub_822C0000(ctx, base);
	// 829A6844: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829A6848: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A684C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A6850: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829A6854: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829A6858: 419A0024  beq cr6, 0x829a687c
	if ctx.cr[6].eq {
	pc = 0x829A687C; continue 'dispatch;
	}
	// 829A685C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829A6860: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A6864: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6868: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A686C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A6870: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A6874: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6878: 4082FFE8  bne 0x829a6860
	if !ctx.cr[0].eq {
	pc = 0x829A6860; continue 'dispatch;
	}
	// 829A687C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A6880: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829A6884: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A6888: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829A688C: 389D00E8  addi r4, r29, 0xe8
	ctx.r[4].s64 = ctx.r[29].s64 + 232;
	// 829A6890: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829A6894: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829A6898: 484B7E11  bl 0x82e5e6a8
	ctx.lr = 0x829A689C;
	sub_82E5E6A8(ctx, base);
	// 829A689C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A68A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A68A4: 419A0008  beq cr6, 0x829a68ac
	if ctx.cr[6].eq {
	pc = 0x829A68AC; continue 'dispatch;
	}
	// 829A68A8: 4B919FE9  bl 0x822c0890
	ctx.lr = 0x829A68AC;
	sub_822C0890(ctx, base);
	// 829A68AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A68B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A68B4: 419A0008  beq cr6, 0x829a68bc
	if ctx.cr[6].eq {
	pc = 0x829A68BC; continue 'dispatch;
	}
	// 829A68B8: 4B919FD9  bl 0x822c0890
	ctx.lr = 0x829A68BC;
	sub_822C0890(ctx, base);
	// 829A68BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A68C0: 419A000C  beq cr6, 0x829a68cc
	if ctx.cr[6].eq {
	pc = 0x829A68CC; continue 'dispatch;
	}
	// 829A68C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A68C8: 4B919FC9  bl 0x822c0890
	ctx.lr = 0x829A68CC;
	sub_822C0890(ctx, base);
	// 829A68CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829A68D0: 488018EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A68D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A68D8 size=124
    let mut pc: u32 = 0x829A68D8;
    'dispatch: loop {
        match pc {
            0x829A68D8 => {
    //   block [0x829A68D8..0x829A6954)
	// 829A68D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A68DC: 48801891  bl 0x831a816c
	ctx.lr = 0x829A68E0;
	sub_831A8130(ctx, base);
	// 829A68E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A68E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A68E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829A68EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A68F0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829A68F4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 829A68F8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829A68FC: 4844BAED  bl 0x82df23e8
	ctx.lr = 0x829A6900;
	sub_82DF23E8(ctx, base);
	// 829A6900: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A6904: 4182001C  beq 0x829a6920
	if ctx.cr[0].eq {
	pc = 0x829A6920; continue 'dispatch;
	}
	// 829A6908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A690C: 484B2D75  bl 0x82e59680
	ctx.lr = 0x829A6910;
	sub_82E59680(ctx, base);
	// 829A6910: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A6914: 396B13D8  addi r11, r11, 0x13d8
	ctx.r[11].s64 = ctx.r[11].s64 + 5080;
	// 829A6918: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A691C: 48000008  b 0x829a6924
	pc = 0x829A6924; continue 'dispatch;
	// 829A6920: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829A6924: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829A6928: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829A692C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6934: 4BFFE1DD  bl 0x829a4b10
	ctx.lr = 0x829A6938;
	sub_829A4B10(ctx, base);
	// 829A6938: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A693C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6944: 4B9196BD  bl 0x822c0000
	ctx.lr = 0x829A6948;
	sub_822C0000(ctx, base);
	// 829A6948: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A694C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A6950: 4880186C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A6958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A6958 size=124
    let mut pc: u32 = 0x829A6958;
    'dispatch: loop {
        match pc {
            0x829A6958 => {
    //   block [0x829A6958..0x829A69D4)
	// 829A6958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A695C: 48801811  bl 0x831a816c
	ctx.lr = 0x829A6960;
	sub_831A8130(ctx, base);
	// 829A6960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A6964: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A6968: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829A696C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A6970: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829A6974: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 829A6978: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829A697C: 4844BA6D  bl 0x82df23e8
	ctx.lr = 0x829A6980;
	sub_82DF23E8(ctx, base);
	// 829A6980: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A6984: 4182001C  beq 0x829a69a0
	if ctx.cr[0].eq {
	pc = 0x829A69A0; continue 'dispatch;
	}
	// 829A6988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A698C: 484B2CF5  bl 0x82e59680
	ctx.lr = 0x829A6990;
	sub_82E59680(ctx, base);
	// 829A6990: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A6994: 396B13E0  addi r11, r11, 0x13e0
	ctx.r[11].s64 = ctx.r[11].s64 + 5088;
	// 829A6998: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829A699C: 48000008  b 0x829a69a4
	pc = 0x829A69A4; continue 'dispatch;
	// 829A69A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829A69A4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829A69A8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829A69AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A69B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A69B4: 4BFFE225  bl 0x829a4bd8
	ctx.lr = 0x829A69B8;
	sub_829A4BD8(ctx, base);
	// 829A69B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A69BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A69C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A69C4: 4B91963D  bl 0x822c0000
	ctx.lr = 0x829A69C8;
	sub_822C0000(ctx, base);
	// 829A69C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A69CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A69D0: 488017EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A69D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A69D8 size=136
    let mut pc: u32 = 0x829A69D8;
    'dispatch: loop {
        match pc {
            0x829A69D8 => {
    //   block [0x829A69D8..0x829A6A60)
	// 829A69D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A69DC: 4880178D  bl 0x831a8168
	ctx.lr = 0x829A69E0;
	sub_831A8130(ctx, base);
	// 829A69E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A69E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A69E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829A69EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829A69F0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829A69F4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829A69F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A69FC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829A6A00: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829A6A04: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 829A6A08: 4844B9E1  bl 0x82df23e8
	ctx.lr = 0x829A6A0C;
	sub_82DF23E8(ctx, base);
	// 829A6A0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A6A10: 4182001C  beq 0x829a6a2c
	if ctx.cr[0].eq {
	pc = 0x829A6A2C; continue 'dispatch;
	}
	// 829A6A14: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829A6A18: 88BE0000  lbz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6A1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6A20: 481B16D9  bl 0x82b580f8
	ctx.lr = 0x829A6A24;
	sub_82B580F8(ctx, base);
	// 829A6A24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A6A28: 48000008  b 0x829a6a30
	pc = 0x829A6A30; continue 'dispatch;
	// 829A6A2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829A6A30: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829A6A34: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 829A6A38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6A3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6A40: 4BFFE261  bl 0x829a4ca0
	ctx.lr = 0x829A6A44;
	sub_829A4CA0(ctx, base);
	// 829A6A44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A6A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6A50: 4B9195B1  bl 0x822c0000
	ctx.lr = 0x829A6A54;
	sub_822C0000(ctx, base);
	// 829A6A54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829A6A58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829A6A5C: 4880175C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A6A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A6A60 size=76
    let mut pc: u32 = 0x829A6A60;
    'dispatch: loop {
        match pc {
            0x829A6A60 => {
    //   block [0x829A6A60..0x829A6AAC)
	// 829A6A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A6A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A6A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829A6A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A6A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A6A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A6A78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A6A7C: 4BFFEE9D  bl 0x829a5918
	ctx.lr = 0x829A6A80;
	sub_829A5918(ctx, base);
	// 829A6A80: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A6A84: 4182000C  beq 0x829a6a90
	if ctx.cr[0].eq {
	pc = 0x829A6A90; continue 'dispatch;
	}
	// 829A6A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A6A8C: 4844B94D  bl 0x82df23d8
	ctx.lr = 0x829A6A90;
	sub_82DF23D8(ctx, base);
	// 829A6A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A6A94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829A6A98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A6A9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A6AA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829A6AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A6AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A6AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A6AB0 size=960
    let mut pc: u32 = 0x829A6AB0;
    'dispatch: loop {
        match pc {
            0x829A6AB0 => {
    //   block [0x829A6AB0..0x829A6E70)
	// 829A6AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A6AB4: 488016A9  bl 0x831a815c
	ctx.lr = 0x829A6AB8;
	sub_831A8130(ctx, base);
	// 829A6AB8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829A6ABC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A6AC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A6AC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A6AC8: 3B4B1A70  addi r26, r11, 0x1a70
	ctx.r[26].s64 = ctx.r[11].s64 + 6768;
	// 829A6ACC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829A6AD0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829A6AD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A6AD8: 38A00530  li r5, 0x530
	ctx.r[5].s64 = 1328;
	// 829A6ADC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829A6AE0: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 829A6AE4: 4844B905  bl 0x82df23e8
	ctx.lr = 0x829A6AE8;
	sub_82DF23E8(ctx, base);
	// 829A6AE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A6AEC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829A6AF0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829A6AF4: 41820028  beq 0x829a6b1c
	if ctx.cr[0].eq {
	pc = 0x829A6B1C; continue 'dispatch;
	}
	// 829A6AF8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829A6AFC: 486624BD  bl 0x83008fb8
	ctx.lr = 0x829A6B00;
	sub_83008FB8(ctx, base);
	// 829A6B00: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A6B04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A6B08: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A6B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6B10: 4BFDFE81  bl 0x82986990
	ctx.lr = 0x829A6B14;
	sub_82986990(ctx, base);
	// 829A6B14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A6B18: 48000008  b 0x829a6b20
	pc = 0x829A6B20; continue 'dispatch;
	// 829A6B1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829A6B20: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829A6B24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A6B28: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A6B2C: 4BFE0DDD  bl 0x82987908
	ctx.lr = 0x829A6B30;
	sub_82987908(ctx, base);
	// 829A6B30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829A6B34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A6B38: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A6B3C: 4B9194C5  bl 0x822c0000
	ctx.lr = 0x829A6B40;
	sub_822C0000(ctx, base);
	// 829A6B40: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A6B44: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829A6B48: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829A6B4C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 829A6B50: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829A6B54: 419A0024  beq cr6, 0x829a6b78
	if ctx.cr[6].eq {
	pc = 0x829A6B78; continue 'dispatch;
	}
	// 829A6B58: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829A6B5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A6B60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6B64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A6B68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A6B6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A6B70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6B74: 4082FFE8  bne 0x829a6b5c
	if !ctx.cr[0].eq {
	pc = 0x829A6B5C; continue 'dispatch;
	}
	// 829A6B78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6B7C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A6B80: 4BB68949  bl 0x8250f4c8
	ctx.lr = 0x829A6B84;
	sub_8250F4C8(ctx, base);
	// 829A6B84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6B8C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 829A6B90: 409A0008  bne cr6, 0x829a6b98
	if !ctx.cr[6].eq {
	pc = 0x829A6B98; continue 'dispatch;
	}
	// 829A6B94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829A6B98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6B9C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A6BA0: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 829A6BA4: 4BB68975  bl 0x8250f518
	ctx.lr = 0x829A6BA8;
	sub_8250F518(ctx, base);
	// 829A6BA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A6BAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6BB0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 829A6BB4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 829A6BB8: 4BB66951  bl 0x8250d508
	ctx.lr = 0x829A6BBC;
	sub_8250D508(ctx, base);
	// 829A6BBC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A6BC0: 4844B0D1  bl 0x82df1c90
	ctx.lr = 0x829A6BC4;
	sub_82DF1C90(ctx, base);
	// 829A6BC4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A6BC8: 4844B0C9  bl 0x82df1c90
	ctx.lr = 0x829A6BCC;
	sub_82DF1C90(ctx, base);
	// 829A6BCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829A6BD0: 419A000C  beq cr6, 0x829a6bdc
	if ctx.cr[6].eq {
	pc = 0x829A6BDC; continue 'dispatch;
	}
	// 829A6BD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A6BD8: 4B919CB9  bl 0x822c0890
	ctx.lr = 0x829A6BDC;
	sub_822C0890(ctx, base);
	// 829A6BDC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829A6BE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A6BE4: 38A0053A  li r5, 0x53a
	ctx.r[5].s64 = 1338;
	// 829A6BE8: 38600118  li r3, 0x118
	ctx.r[3].s64 = 280;
	// 829A6BEC: 4844B7FD  bl 0x82df23e8
	ctx.lr = 0x829A6BF0;
	sub_82DF23E8(ctx, base);
	// 829A6BF0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829A6BF4: 41820020  beq 0x829a6c14
	if ctx.cr[0].eq {
	pc = 0x829A6C14; continue 'dispatch;
	}
	// 829A6BF8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829A6BFC: 486623BD  bl 0x83008fb8
	ctx.lr = 0x829A6C00;
	sub_83008FB8(ctx, base);
	// 829A6C00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A6C04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6C08: 4BFDEE49  bl 0x82985a50
	ctx.lr = 0x829A6C0C;
	sub_82985A50(ctx, base);
	// 829A6C0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A6C10: 48000008  b 0x829a6c18
	pc = 0x829A6C18; continue 'dispatch;
	// 829A6C14: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829A6C18: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829A6C1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A6C20: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A6C24: 4BFE0DAD  bl 0x829879d0
	ctx.lr = 0x829A6C28;
	sub_829879D0(ctx, base);
	// 829A6C28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829A6C2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A6C30: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A6C34: 4B9193CD  bl 0x822c0000
	ctx.lr = 0x829A6C38;
	sub_822C0000(ctx, base);
	// 829A6C38: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A6C3C: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829A6C40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829A6C44: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 829A6C48: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829A6C4C: 419A0024  beq cr6, 0x829a6c70
	if ctx.cr[6].eq {
	pc = 0x829A6C70; continue 'dispatch;
	}
	// 829A6C50: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829A6C54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A6C58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6C5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A6C60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A6C64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A6C68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6C6C: 4082FFE8  bne 0x829a6c54
	if !ctx.cr[0].eq {
	pc = 0x829A6C54; continue 'dispatch;
	}
	// 829A6C70: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 829A6C74: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829A6C78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A6C7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829A6C80: 4BB66889  bl 0x8250d508
	ctx.lr = 0x829A6C84;
	sub_8250D508(ctx, base);
	// 829A6C84: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 829A6C88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6C8C: 4866232D  bl 0x83008fb8
	ctx.lr = 0x829A6C90;
	sub_83008FB8(ctx, base);
	// 829A6C90: 907F03B8  stw r3, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[3].u32 ) };
	// 829A6C94: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A6C98: 4BFE4121  bl 0x8298adb8
	ctx.lr = 0x829A6C9C;
	sub_8298ADB8(ctx, base);
	// 829A6C9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6CA0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829A6CA4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A6CA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6CAC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829A6CB0: 419A0024  beq cr6, 0x829a6cd4
	if ctx.cr[6].eq {
	pc = 0x829A6CD4; continue 'dispatch;
	}
	// 829A6CB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A6CB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A6CBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6CC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A6CC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A6CC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A6CCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6CD0: 4082FFE8  bne 0x829a6cb8
	if !ctx.cr[0].eq {
	pc = 0x829A6CB8; continue 'dispatch;
	}
	// 829A6CD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6CD8: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 829A6CDC: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 829A6CE0: 486622D9  bl 0x83008fb8
	ctx.lr = 0x829A6CE4;
	sub_83008FB8(ctx, base);
	// 829A6CE4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A6CE8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A6CEC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829A6CF0: 38A0053F  li r5, 0x53f
	ctx.r[5].s64 = 1343;
	// 829A6CF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6CF8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829A6CFC: 484B1D45  bl 0x82e58a40
	ctx.lr = 0x829A6D00;
	sub_82E58A40(ctx, base);
	// 829A6D00: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829A6D04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6D08: 419A0008  beq cr6, 0x829a6d10
	if ctx.cr[6].eq {
	pc = 0x829A6D10; continue 'dispatch;
	}
	// 829A6D0C: 4B919B85  bl 0x822c0890
	ctx.lr = 0x829A6D10;
	sub_822C0890(ctx, base);
	// 829A6D10: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829A6D14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6D18: 419A0008  beq cr6, 0x829a6d20
	if ctx.cr[6].eq {
	pc = 0x829A6D20; continue 'dispatch;
	}
	// 829A6D1C: 4B919B75  bl 0x822c0890
	ctx.lr = 0x829A6D20;
	sub_822C0890(ctx, base);
	// 829A6D20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829A6D24: 419A000C  beq cr6, 0x829a6d30
	if ctx.cr[6].eq {
	pc = 0x829A6D30; continue 'dispatch;
	}
	// 829A6D28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A6D2C: 4B919B65  bl 0x822c0890
	ctx.lr = 0x829A6D30;
	sub_822C0890(ctx, base);
	// 829A6D30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A6D34: 807F0178  lwz r3, 0x178(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 829A6D38: 4BAE8611  bl 0x8248f348
	ctx.lr = 0x829A6D3C;
	sub_8248F348(ctx, base);
	// 829A6D3C: 807F0334  lwz r3, 0x334(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(820 as u32) ) } as u64;
	// 829A6D40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A6D44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829A6D48: 388B1AB8  addi r4, r11, 0x1ab8
	ctx.r[4].s64 = ctx.r[11].s64 + 6840;
	// 829A6D4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6D50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A6D54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A6D58: 4E800421  bctrl
	ctx.lr = 0x829A6D5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A6D5C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829A6D60: 809F03F8  lwz r4, 0x3f8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 829A6D64: 4B92AEB5  bl 0x822d1c18
	ctx.lr = 0x829A6D68;
	sub_822D1C18(ctx, base);
	// 829A6D68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A6D6C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 829A6D70: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829A6D74: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 829A6D78: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 829A6D7C: C1AB08AC  lfs f13, 0x8ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A6D80: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 829A6D84: C18A6150  lfs f12, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A6D88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829A6D8C: C009964C  lfs f0, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A6D90: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 829A6D94: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829A6D98: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829A6D9C: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829A6DA0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829A6DA4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829A6DA8: 4BCCADF9  bl 0x82671ba0
	ctx.lr = 0x829A6DAC;
	sub_82671BA0(ctx, base);
	// 829A6DAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6DB0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829A6DB4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A6DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6DBC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829A6DC0: 419A0024  beq cr6, 0x829a6de4
	if ctx.cr[6].eq {
	pc = 0x829A6DE4; continue 'dispatch;
	}
	// 829A6DC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A6DC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A6DCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6DD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A6DD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A6DD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A6DDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6DE0: 4082FFE8  bne 0x829a6dc8
	if !ctx.cr[0].eq {
	pc = 0x829A6DC8; continue 'dispatch;
	}
	// 829A6DE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A6DE8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A6DEC: 4BB686DD  bl 0x8250f4c8
	ctx.lr = 0x829A6DF0;
	sub_8250F4C8(ctx, base);
	// 829A6DF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6DF8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A6DFC: 409A0008  bne cr6, 0x829a6e04
	if !ctx.cr[6].eq {
	pc = 0x829A6E04; continue 'dispatch;
	}
	// 829A6E00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829A6E04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A6E08: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 829A6E0C: 4BB61C0D  bl 0x82508a18
	ctx.lr = 0x829A6E10;
	sub_82508A18(ctx, base);
	// 829A6E10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A6E14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829A6E18: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A6E1C: 38A00559  li r5, 0x559
	ctx.r[5].s64 = 1369;
	// 829A6E20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A6E24: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A6E28: 484B1C19  bl 0x82e58a40
	ctx.lr = 0x829A6E2C;
	sub_82E58A40(ctx, base);
	// 829A6E2C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A6E30: 4844AE61  bl 0x82df1c90
	ctx.lr = 0x829A6E34;
	sub_82DF1C90(ctx, base);
	// 829A6E34: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829A6E38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6E3C: 419A0008  beq cr6, 0x829a6e44
	if ctx.cr[6].eq {
	pc = 0x829A6E44; continue 'dispatch;
	}
	// 829A6E40: 4B919A51  bl 0x822c0890
	ctx.lr = 0x829A6E44;
	sub_822C0890(ctx, base);
	// 829A6E44: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829A6E48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6E4C: 419A0008  beq cr6, 0x829a6e54
	if ctx.cr[6].eq {
	pc = 0x829A6E54; continue 'dispatch;
	}
	// 829A6E50: 4B919A41  bl 0x822c0890
	ctx.lr = 0x829A6E54;
	sub_822C0890(ctx, base);
	// 829A6E54: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829A6E58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6E5C: 419A0008  beq cr6, 0x829a6e64
	if ctx.cr[6].eq {
	pc = 0x829A6E64; continue 'dispatch;
	}
	// 829A6E60: 4B919A31  bl 0x822c0890
	ctx.lr = 0x829A6E64;
	sub_822C0890(ctx, base);
	// 829A6E64: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 829A6E68: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 829A6E6C: 48801340  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A6E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A6E70 size=684
    let mut pc: u32 = 0x829A6E70;
    'dispatch: loop {
        match pc {
            0x829A6E70 => {
    //   block [0x829A6E70..0x829A711C)
	// 829A6E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A6E74: 488012F5  bl 0x831a8168
	ctx.lr = 0x829A6E78;
	sub_831A8130(ctx, base);
	// 829A6E78: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A6E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829A6E80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829A6E84: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 829A6E88: 895E0388  lbz r10, 0x388(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(904 as u32) ) } as u64;
	// 829A6E8C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829A6E90: 419A0280  beq cr6, 0x829a7110
	if ctx.cr[6].eq {
	pc = 0x829A7110; continue 'dispatch;
	}
	// 829A6E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6E98: 419A01A8  beq cr6, 0x829a7040
	if ctx.cr[6].eq {
	pc = 0x829A7040; continue 'dispatch;
	}
	// 829A6E9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829A6EA0: 4BFFFA39  bl 0x829a68d8
	ctx.lr = 0x829A6EA4;
	sub_829A68D8(ctx, base);
	// 829A6EA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6EA8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829A6EAC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A6EB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6EB4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829A6EB8: 419A0024  beq cr6, 0x829a6edc
	if ctx.cr[6].eq {
	pc = 0x829A6EDC; continue 'dispatch;
	}
	// 829A6EBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A6EC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A6EC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6EC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A6ECC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A6ED0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A6ED4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6ED8: 4082FFE8  bne 0x829a6ec0
	if !ctx.cr[0].eq {
	pc = 0x829A6EC0; continue 'dispatch;
	}
	// 829A6EDC: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 829A6EE0: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 829A6EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A6EE8: 486620D1  bl 0x83008fb8
	ctx.lr = 0x829A6EEC;
	sub_83008FB8(ctx, base);
	// 829A6EEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829A6EF0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829A6EF4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A6EF8: 388A1A70  addi r4, r10, 0x1a70
	ctx.r[4].s64 = ctx.r[10].s64 + 6768;
	// 829A6EFC: 38A005F3  li r5, 0x5f3
	ctx.r[5].s64 = 1523;
	// 829A6F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A6F04: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829A6F08: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829A6F0C: 484B1B35  bl 0x82e58a40
	ctx.lr = 0x829A6F10;
	sub_82E58A40(ctx, base);
	// 829A6F10: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A6F14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6F18: 419A0008  beq cr6, 0x829a6f20
	if ctx.cr[6].eq {
	pc = 0x829A6F20; continue 'dispatch;
	}
	// 829A6F1C: 4B919975  bl 0x822c0890
	ctx.lr = 0x829A6F20;
	sub_822C0890(ctx, base);
	// 829A6F20: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829A6F24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6F28: 419A0008  beq cr6, 0x829a6f30
	if ctx.cr[6].eq {
	pc = 0x829A6F30; continue 'dispatch;
	}
	// 829A6F2C: 4B919965  bl 0x822c0890
	ctx.lr = 0x829A6F30;
	sub_822C0890(ctx, base);
	// 829A6F30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A6F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A6F38: 388B1AF8  addi r4, r11, 0x1af8
	ctx.r[4].s64 = ctx.r[11].s64 + 6904;
	// 829A6F3C: 4844CACD  bl 0x82df3a08
	ctx.lr = 0x829A6F40;
	sub_82DF3A08(ctx, base);
	// 829A6F40: 817E037C  lwz r11, 0x37c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 829A6F44: 815E0378  lwz r10, 0x378(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(888 as u32) ) } as u64;
	// 829A6F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6F4C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829A6F50: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829A6F54: 419A0024  beq cr6, 0x829a6f78
	if ctx.cr[6].eq {
	pc = 0x829A6F78; continue 'dispatch;
	}
	// 829A6F58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A6F5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A6F60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6F64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A6F68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A6F6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A6F70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A6F74: 4082FFE8  bne 0x829a6f5c
	if !ctx.cr[0].eq {
	pc = 0x829A6F5C; continue 'dispatch;
	}
	// 829A6F78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A6F7C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A6F80: 4BB68549  bl 0x8250f4c8
	ctx.lr = 0x829A6F84;
	sub_8250F4C8(ctx, base);
	// 829A6F84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6F8C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829A6F90: 409A0008  bne cr6, 0x829a6f98
	if !ctx.cr[6].eq {
	pc = 0x829A6F98; continue 'dispatch;
	}
	// 829A6F94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A6F98: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829A6F9C: 4BB639B5  bl 0x8250a950
	ctx.lr = 0x829A6FA0;
	sub_8250A950(ctx, base);
	// 829A6FA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A6FA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A6FA8: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A6FAC: 409A0008  bne cr6, 0x829a6fb4
	if !ctx.cr[6].eq {
	pc = 0x829A6FB4; continue 'dispatch;
	}
	// 829A6FB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829A6FB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A6FB8: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 829A6FBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829A6FC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829A6FC4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829A6FC8: 4BE2D1D9  bl 0x827d41a0
	ctx.lr = 0x829A6FCC;
	sub_827D41A0(ctx, base);
	// 829A6FCC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829A6FD0: 4844ACC1  bl 0x82df1c90
	ctx.lr = 0x829A6FD4;
	sub_82DF1C90(ctx, base);
	// 829A6FD4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A6FD8: 4844ACB9  bl 0x82df1c90
	ctx.lr = 0x829A6FDC;
	sub_82DF1C90(ctx, base);
	// 829A6FDC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A6FE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A6FE4: 419A0008  beq cr6, 0x829a6fec
	if ctx.cr[6].eq {
	pc = 0x829A6FEC; continue 'dispatch;
	}
	// 829A6FE8: 4B9198A9  bl 0x822c0890
	ctx.lr = 0x829A6FEC;
	sub_822C0890(ctx, base);
	// 829A6FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A6FF0: 4844C439  bl 0x82df3428
	ctx.lr = 0x829A6FF4;
	sub_82DF3428(ctx, base);
	// 829A6FF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A6FF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A6FFC: 38AB1ADC  addi r5, r11, 0x1adc
	ctx.r[5].s64 = ctx.r[11].s64 + 6876;
	// 829A7000: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A7004: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A7008: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829A700C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A7010: 4E800421  bctrl
	ctx.lr = 0x829A7014;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A7014: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829A7018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A701C: 419A0008  beq cr6, 0x829a7024
	if ctx.cr[6].eq {
	pc = 0x829A7024; continue 'dispatch;
	}
	// 829A7020: 4B919871  bl 0x822c0890
	ctx.lr = 0x829A7024;
	sub_822C0890(ctx, base);
	// 829A7024: 807E033C  lwz r3, 0x33c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(828 as u32) ) } as u64;
	// 829A7028: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A702C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A7030: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829A7034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A7038: 4E800421  bctrl
	ctx.lr = 0x829A703C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A703C: 480000D4  b 0x829a7110
	pc = 0x829A7110; continue 'dispatch;
	// 829A7040: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829A7044: 807E0370  lwz r3, 0x370(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(880 as u32) ) } as u64;
	// 829A7048: 484DA6F9  bl 0x82e81740
	ctx.lr = 0x829A704C;
	sub_82E81740(ctx, base);
	// 829A704C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A7050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A7054: 388B1AC8  addi r4, r11, 0x1ac8
	ctx.r[4].s64 = ctx.r[11].s64 + 6856;
	// 829A7058: 4844C9B1  bl 0x82df3a08
	ctx.lr = 0x829A705C;
	sub_82DF3A08(ctx, base);
	// 829A705C: 817E037C  lwz r11, 0x37c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 829A7060: 815E0378  lwz r10, 0x378(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(888 as u32) ) } as u64;
	// 829A7064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A7068: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829A706C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 829A7070: 419A0024  beq cr6, 0x829a7094
	if ctx.cr[6].eq {
	pc = 0x829A7094; continue 'dispatch;
	}
	// 829A7074: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A7078: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A707C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A7080: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A7084: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A7088: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A708C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A7090: 4082FFE8  bne 0x829a7078
	if !ctx.cr[0].eq {
	pc = 0x829A7078; continue 'dispatch;
	}
	// 829A7094: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A7098: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A709C: 4BB6842D  bl 0x8250f4c8
	ctx.lr = 0x829A70A0;
	sub_8250F4C8(ctx, base);
	// 829A70A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A70A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A70A8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829A70AC: 409A0008  bne cr6, 0x829a70b4
	if !ctx.cr[6].eq {
	pc = 0x829A70B4; continue 'dispatch;
	}
	// 829A70B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A70B4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A70B8: 4BB63899  bl 0x8250a950
	ctx.lr = 0x829A70BC;
	sub_8250A950(ctx, base);
	// 829A70BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A70C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A70C4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829A70C8: 409A0008  bne cr6, 0x829a70d0
	if !ctx.cr[6].eq {
	pc = 0x829A70D0; continue 'dispatch;
	}
	// 829A70CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829A70D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A70D4: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 829A70D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829A70DC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 829A70E0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829A70E4: 4BE2D0BD  bl 0x827d41a0
	ctx.lr = 0x829A70E8;
	sub_827D41A0(ctx, base);
	// 829A70E8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A70EC: 4844ABA5  bl 0x82df1c90
	ctx.lr = 0x829A70F0;
	sub_82DF1C90(ctx, base);
	// 829A70F0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A70F4: 4844AB9D  bl 0x82df1c90
	ctx.lr = 0x829A70F8;
	sub_82DF1C90(ctx, base);
	// 829A70F8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829A70FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A7100: 419A0008  beq cr6, 0x829a7108
	if ctx.cr[6].eq {
	pc = 0x829A7108; continue 'dispatch;
	}
	// 829A7104: 4B91978D  bl 0x822c0890
	ctx.lr = 0x829A7108;
	sub_822C0890(ctx, base);
	// 829A7108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A710C: 4844C31D  bl 0x82df3428
	ctx.lr = 0x829A7110;
	sub_82DF3428(ctx, base);
	// 829A7110: 9BBE0388  stb r29, 0x388(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(904 as u32), ctx.r[29].u8 ) };
	// 829A7114: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829A7118: 488010A0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A7120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A7120 size=6160
    let mut pc: u32 = 0x829A7120;
    'dispatch: loop {
        match pc {
            0x829A7120 => {
    //   block [0x829A7120..0x829A8930)
	// 829A7120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A7124: 48801021  bl 0x831a8144
	ctx.lr = 0x829A7128;
	sub_831A8130(ctx, base);
	// 829A7128: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 829A712C: 48801945  bl 0x831a8a70
	ctx.lr = 0x829A7130;
	sub_831A8A40(ctx, base);
	// 829A7130: 3981FF60  addi r12, r1, -0xa0
	ctx.r[12].s64 = ctx.r[1].s64 + -160;
	// 829A7134: 48803AE1  bl 0x831aac14
	ctx.lr = 0x829A7138;
	sub_831AA9A0(ctx, base);
	// 829A7138: 9421FBE0  stwu r1, -0x420(r1)
	ea = ctx.r[1].u32.wrapping_add(-1056 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A713C: 39610240  addi r11, r1, 0x240
	ctx.r[11].s64 = ctx.r[1].s64 + 576;
	// 829A7140: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 829A7144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A7148: D381043C  stfs f28, 0x43c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1084 as u32), tmp.u32 ) };
	// 829A714C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A7150: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829A7154: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 829A7158: 4B976079  bl 0x8231d1d0
	ctx.lr = 0x829A715C;
	sub_8231D1D0(ctx, base);
	// 829A715C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A7160: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 829A7164: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A7168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A716C: 916100E4  stw r11, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829A7170: 419A0024  beq cr6, 0x829a7194
	if ctx.cr[6].eq {
	pc = 0x829A7194; continue 'dispatch;
	}
	// 829A7174: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A7178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A717C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A7180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A7184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A7188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A718C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A7190: 4082FFE8  bne 0x829a7178
	if !ctx.cr[0].eq {
	pc = 0x829A7178; continue 'dispatch;
	}
	// 829A7194: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A7198: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 829A719C: 4BB6832D  bl 0x8250f4c8
	ctx.lr = 0x829A71A0;
	sub_8250F4C8(ctx, base);
	// 829A71A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A71A4: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 829A71A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A71AC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A71B0: 409A0008  bne cr6, 0x829a71b8
	if !ctx.cr[6].eq {
	pc = 0x829A71B8; continue 'dispatch;
	}
	// 829A71B4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 829A71B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A71BC: 3ADF0028  addi r22, r31, 0x28
	ctx.r[22].s64 = ctx.r[31].s64 + 40;
	// 829A71C0: 3BC100E0  addi r30, r1, 0xe0
	ctx.r[30].s64 = ctx.r[1].s64 + 224;
	// 829A71C4: 4BB61855  bl 0x82508a18
	ctx.lr = 0x829A71C8;
	sub_82508A18(ctx, base);
	// 829A71C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A71CC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A71D0: 3AEB1A70  addi r23, r11, 0x1a70
	ctx.r[23].s64 = ctx.r[11].s64 + 6768;
	// 829A71D4: 38A006CC  li r5, 0x6cc
	ctx.r[5].s64 = 1740;
	// 829A71D8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829A71DC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829A71E0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829A71E4: 484AFE05  bl 0x82e56fe8
	ctx.lr = 0x829A71E8;
	sub_82E56FE8(ctx, base);
	// 829A71E8: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 829A71EC: 4844AAA5  bl 0x82df1c90
	ctx.lr = 0x829A71F0;
	sub_82DF1C90(ctx, base);
	// 829A71F0: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 829A71F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A71F8: 419A0008  beq cr6, 0x829a7200
	if ctx.cr[6].eq {
	pc = 0x829A7200; continue 'dispatch;
	}
	// 829A71FC: 4B919695  bl 0x822c0890
	ctx.lr = 0x829A7200;
	sub_822C0890(ctx, base);
	// 829A7200: 806101A4  lwz r3, 0x1a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 829A7204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A7208: 419A0008  beq cr6, 0x829a7210
	if ctx.cr[6].eq {
	pc = 0x829A7210; continue 'dispatch;
	}
	// 829A720C: 4B919685  bl 0x822c0890
	ctx.lr = 0x829A7210;
	sub_822C0890(ctx, base);
	// 829A7210: 39610260  addi r11, r1, 0x260
	ctx.r[11].s64 = ctx.r[1].s64 + 608;
	// 829A7214: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829A7218: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A721C: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 829A7220: 4B9F8069  bl 0x8239f288
	ctx.lr = 0x829A7224;
	sub_8239F288(ctx, base);
	// 829A7224: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A7228: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 829A722C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A7230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A7234: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 829A7238: 419A0024  beq cr6, 0x829a725c
	if ctx.cr[6].eq {
	pc = 0x829A725C; continue 'dispatch;
	}
	// 829A723C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A7240: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A7244: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A7248: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A724C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A7250: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A7254: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A7258: 4082FFE8  bne 0x829a7240
	if !ctx.cr[0].eq {
	pc = 0x829A7240; continue 'dispatch;
	}
	// 829A725C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A7260: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 829A7264: 4BB68265  bl 0x8250f4c8
	ctx.lr = 0x829A7268;
	sub_8250F4C8(ctx, base);
	// 829A7268: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A726C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A7270: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A7274: 409A0008  bne cr6, 0x829a727c
	if !ctx.cr[6].eq {
	pc = 0x829A727C; continue 'dispatch;
	}
	// 829A7278: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 829A727C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A7280: 3BC100D0  addi r30, r1, 0xd0
	ctx.r[30].s64 = ctx.r[1].s64 + 208;
	// 829A7284: 4BB61795  bl 0x82508a18
	ctx.lr = 0x829A7288;
	sub_82508A18(ctx, base);
	// 829A7288: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A728C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829A7290: 38A006CF  li r5, 0x6cf
	ctx.r[5].s64 = 1743;
	// 829A7294: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829A7298: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829A729C: 484AFD4D  bl 0x82e56fe8
	ctx.lr = 0x829A72A0;
	sub_82E56FE8(ctx, base);
	// 829A72A0: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 829A72A4: 4844A9ED  bl 0x82df1c90
	ctx.lr = 0x829A72A8;
	sub_82DF1C90(ctx, base);
	// 829A72A8: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 829A72AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A72B0: 419A0008  beq cr6, 0x829a72b8
	if ctx.cr[6].eq {
	pc = 0x829A72B8; continue 'dispatch;
	}
	// 829A72B4: 4B9195DD  bl 0x822c0890
	ctx.lr = 0x829A72B8;
	sub_822C0890(ctx, base);
	// 829A72B8: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 829A72BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A72C0: 419A0008  beq cr6, 0x829a72c8
	if ctx.cr[6].eq {
	pc = 0x829A72C8; continue 'dispatch;
	}
	// 829A72C4: 4B9195CD  bl 0x822c0890
	ctx.lr = 0x829A72C8;
	sub_822C0890(ctx, base);
	// 829A72C8: 3961043C  addi r11, r1, 0x43c
	ctx.r[11].s64 = ctx.r[1].s64 + 1084;
	// 829A72CC: 39410240  addi r10, r1, 0x240
	ctx.r[10].s64 = ctx.r[1].s64 + 576;
	// 829A72D0: 39210260  addi r9, r1, 0x260
	ctx.r[9].s64 = ctx.r[1].s64 + 608;
	// 829A72D4: 3B1F03E0  addi r24, r31, 0x3e0
	ctx.r[24].s64 = ctx.r[31].s64 + 992;
	// 829A72D8: 3A7F0168  addi r19, r31, 0x168
	ctx.r[19].s64 = ctx.r[31].s64 + 360;
	// 829A72DC: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A8930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A8930 size=1416
    let mut pc: u32 = 0x829A8930;
    'dispatch: loop {
        match pc {
            0x829A8930 => {
    //   block [0x829A8930..0x829A8EB8)
	// 829A8930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A8934: 487FF81D  bl 0x831a8150
	ctx.lr = 0x829A8938;
	sub_831A8130(ctx, base);
	// 829A8938: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 829A893C: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A8940: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829A8944: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829A8948: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A894C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829A8950: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 829A8954: 4BB66B75  bl 0x8250f4c8
	ctx.lr = 0x829A8958;
	sub_8250F4C8(ctx, base);
	// 829A8958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A895C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A8960: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A8964: 409A0008  bne cr6, 0x829a896c
	if !ctx.cr[6].eq {
	pc = 0x829A896C; continue 'dispatch;
	}
	// 829A8968: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829A896C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A8970: 4BB600A9  bl 0x82508a18
	ctx.lr = 0x829A8974;
	sub_82508A18(ctx, base);
	// 829A8974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A8978: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A897C: 4865F7AD  bl 0x83008128
	ctx.lr = 0x829A8980;
	sub_83008128(ctx, base);
	// 829A8980: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 829A8984: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 829A8988: 419A0024  beq cr6, 0x829a89ac
	if ctx.cr[6].eq {
	pc = 0x829A89AC; continue 'dispatch;
	}
	// 829A898C: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 829A8990: 48660629  bl 0x83008fb8
	ctx.lr = 0x829A8994;
	sub_83008FB8(ctx, base);
	// 829A8994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A8998: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A899C: 4865F78D  bl 0x83008128
	ctx.lr = 0x829A89A0;
	sub_83008128(ctx, base);
	// 829A89A0: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 829A89A4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 829A89A8: 409A0008  bne cr6, 0x829a89b0
	if !ctx.cr[6].eq {
	pc = 0x829A89B0; continue 'dispatch;
	}
	// 829A89AC: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 829A89B0: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829A89B4: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829A89B8: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 829A89BC: 484492D5  bl 0x82df1c90
	ctx.lr = 0x829A89C0;
	sub_82DF1C90(ctx, base);
	// 829A89C0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829A89C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A89C8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 829A89CC: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 829A89D0: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A89D4: C3E808A4  lfs f31, 0x8a4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829A89D8: 3B0B1A70  addi r24, r11, 0x1a70
	ctx.r[24].s64 = ctx.r[11].s64 + 6768;
	// 829A89DC: 3BAA8614  addi r29, r10, -0x79ec
	ctx.r[29].s64 = ctx.r[10].s64 + -31212;
	// 829A89E0: 3B896910  addi r28, r9, 0x6910
	ctx.r[28].s64 = ctx.r[9].s64 + 26896;
	// 829A89E4: 41820204  beq 0x829a8be8
	if ctx.cr[0].eq {
	pc = 0x829A8BE8; continue 'dispatch;
	}
	// 829A89E8: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 829A89EC: 807B03F0  lwz r3, 0x3f0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829A89F0: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 829A89F4: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 829A89F8: 4B927661  bl 0x822d0058
	ctx.lr = 0x829A89FC;
	sub_822D0058(ctx, base);
	// 829A89FC: 897B03B4  lbz r11, 0x3b4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(948 as u32) ) } as u64;
	// 829A8A00: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A8A04: 408100E0  ble 0x829a8ae4
	if !ctx.cr[0].gt {
	pc = 0x829A8AE4; continue 'dispatch;
	}
	// 829A8A08: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 829A8A0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829A8A10: 484D4A41  bl 0x82e7d450
	ctx.lr = 0x829A8A14;
	sub_82E7D450(ctx, base);
	// 829A8A14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A8A18: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829A8A1C: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829A8A20: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 829A8A24: 891A001C  lbz r8, 0x1c(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 829A8A28: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 829A8A2C: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829A8A30: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A8A34: C00B9664  lfs f0, -0x699c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A8A38: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829A8A3C: 13A05407  vcmpneb. (lvlx128) v29, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A8EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A8EB8 size=896
    let mut pc: u32 = 0x829A8EB8;
    'dispatch: loop {
        match pc {
            0x829A8EB8 => {
    //   block [0x829A8EB8..0x829A9238)
	// 829A8EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A8EBC: 487FF2A9  bl 0x831a8164
	ctx.lr = 0x829A8EC0;
	sub_831A8130(ctx, base);
	// 829A8EC0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829A8EC4: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A8EC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A8ECC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A8ED0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829A8ED4: C01F03D4  lfs f0, 0x3d4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A8ED8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829A8EDC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829A8EE0: 4199034C  bgt cr6, 0x829a922c
	if ctx.cr[6].gt {
	pc = 0x829A922C; continue 'dispatch;
	}
	// 829A8EE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A8EE8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829A8EEC: 4BB665DD  bl 0x8250f4c8
	ctx.lr = 0x829A8EF0;
	sub_8250F4C8(ctx, base);
	// 829A8EF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A8EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A8EF8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A8EFC: 409A0008  bne cr6, 0x829a8f04
	if !ctx.cr[6].eq {
	pc = 0x829A8F04; continue 'dispatch;
	}
	// 829A8F00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829A8F04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A8F08: 4BB5FB11  bl 0x82508a18
	ctx.lr = 0x829A8F0C;
	sub_82508A18(ctx, base);
	// 829A8F0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829A8F10: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829A8F14: 48448D7D  bl 0x82df1c90
	ctx.lr = 0x829A8F18;
	sub_82DF1C90(ctx, base);
	// 829A8F18: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 829A8F1C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829A8F20: 41980260  blt cr6, 0x829a9180
	if ctx.cr[6].lt {
	pc = 0x829A9180; continue 'dispatch;
	}
	// 829A8F24: 409A0308  bne cr6, 0x829a922c
	if !ctx.cr[6].eq {
	pc = 0x829A922C; continue 'dispatch;
	}
	// 829A8F28: C01F022C  lfs f0, 0x22c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A8F2C: C1BF0230  lfs f13, 0x230(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A8F30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829A8F34: 419802F8  blt cr6, 0x829a922c
	if ctx.cr[6].lt {
	pc = 0x829A922C; continue 'dispatch;
	}
	// 829A8F38: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829A8F3C: 897F03D9  lbz r11, 0x3d9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A8F40: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829A8F44: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829A8F48: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A8F4C: D01F03D4  stfs f0, 0x3d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), tmp.u32 ) };
	// 829A8F50: 41980010  blt cr6, 0x829a8f60
	if ctx.cr[6].lt {
	pc = 0x829A8F60; continue 'dispatch;
	}
	// 829A8F54: 419A011C  beq cr6, 0x829a9070
	if ctx.cr[6].eq {
	pc = 0x829A9070; continue 'dispatch;
	}
	// 829A8F58: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829A8F5C: 409802D0  bge cr6, 0x829a922c
	if !ctx.cr[6].lt {
	pc = 0x829A922C; continue 'dispatch;
	}
	// 829A8F60: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A8F64: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829A8F68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829A8F6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A8F70: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829A8F74: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 829A8F78: C00B7F58  lfs f0, 0x7f58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A8F7C: D01F0414  stfs f0, 0x414(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1044 as u32), tmp.u32 ) };
	// 829A8F80: 4BB69199  bl 0x82512118
	ctx.lr = 0x829A8F84;
	sub_82512118(ctx, base);
	// 829A8F84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A8F88: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A8F8C: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829A8F90: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829A8F94: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829A8F98: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829A8F9C: 3B810054  addi r28, r1, 0x54
	ctx.r[28].s64 = ctx.r[1].s64 + 84;
	// 829A8FA0: 3B610070  addi r27, r1, 0x70
	ctx.r[27].s64 = ctx.r[1].s64 + 112;
	// 829A8FA4: C00BD0B0  lfs f0, -0x2f50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A8FA8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829A8FAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A8FB0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829A8FB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A8FB8: 4E800421  bctrl
	ctx.lr = 0x829A8FBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A8FBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A8FC0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829A8FC4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829A8FC8: 484D2D81  bl 0x82e7bd48
	ctx.lr = 0x829A8FCC;
	sub_82E7BD48(ctx, base);
	// 829A8FCC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829A8FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A8FD4: 4BB68B15  bl 0x82511ae8
	ctx.lr = 0x829A8FD8;
	sub_82511AE8(ctx, base);
	// 829A8FD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A8FDC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829A8FE0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829A8FE4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 829A8FE8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829A8FEC: 4BDC46A5  bl 0x8276d690
	ctx.lr = 0x829A8FF0;
	sub_8276D690(ctx, base);
	// 829A8FF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A8FF4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829A8FF8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A8FFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9000: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829A9004: 419A0024  beq cr6, 0x829a9028
	if ctx.cr[6].eq {
	pc = 0x829A9028; continue 'dispatch;
	}
	// 829A9008: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A900C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9010: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9014: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9018: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A901C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9020: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9024: 4082FFE8  bne 0x829a900c
	if !ctx.cr[0].eq {
	pc = 0x829A900C; continue 'dispatch;
	}
	// 829A9028: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A902C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A9030: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 829A9034: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829A9038: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829A903C: 38A00F50  li r5, 0xf50
	ctx.r[5].s64 = 3920;
	// 829A9040: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829A9044: 484AF9FD  bl 0x82e58a40
	ctx.lr = 0x829A9048;
	sub_82E58A40(ctx, base);
	// 829A9048: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A904C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9050: 419A0008  beq cr6, 0x829a9058
	if ctx.cr[6].eq {
	pc = 0x829A9058; continue 'dispatch;
	}
	// 829A9054: 4B91783D  bl 0x822c0890
	ctx.lr = 0x829A9058;
	sub_822C0890(ctx, base);
	// 829A9058: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829A905C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9060: 419A0008  beq cr6, 0x829a9068
	if ctx.cr[6].eq {
	pc = 0x829A9068; continue 'dispatch;
	}
	// 829A9064: 4B91782D  bl 0x822c0890
	ctx.lr = 0x829A9068;
	sub_822C0890(ctx, base);
	// 829A9068: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829A906C: 48000104  b 0x829a9170
	pc = 0x829A9170; continue 'dispatch;
	// 829A9070: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829A9074: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829A9078: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A907C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A9080: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 829A9084: 4BB69095  bl 0x82512118
	ctx.lr = 0x829A9088;
	sub_82512118(ctx, base);
	// 829A9088: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A908C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9090: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829A9094: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829A9098: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829A909C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829A90A0: 3B810054  addi r28, r1, 0x54
	ctx.r[28].s64 = ctx.r[1].s64 + 84;
	// 829A90A4: 3B610080  addi r27, r1, 0x80
	ctx.r[27].s64 = ctx.r[1].s64 + 128;
	// 829A90A8: C00BD0B0  lfs f0, -0x2f50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A90AC: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829A90B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A90B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829A90B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829A90BC: 4E800421  bctrl
	ctx.lr = 0x829A90C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829A90C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A90C4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829A90C8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829A90CC: 484D2C7D  bl 0x82e7bd48
	ctx.lr = 0x829A90D0;
	sub_82E7BD48(ctx, base);
	// 829A90D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829A90D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A90D8: 4BB68A11  bl 0x82511ae8
	ctx.lr = 0x829A90DC;
	sub_82511AE8(ctx, base);
	// 829A90DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A90E0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A90E4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829A90E8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 829A90EC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829A90F0: 4BDC45A1  bl 0x8276d690
	ctx.lr = 0x829A90F4;
	sub_8276D690(ctx, base);
	// 829A90F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A90F8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829A90FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A9100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9104: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829A9108: 419A0024  beq cr6, 0x829a912c
	if ctx.cr[6].eq {
	pc = 0x829A912C; continue 'dispatch;
	}
	// 829A910C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A9110: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9114: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9118: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A911C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9120: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9124: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9128: 4082FFE8  bne 0x829a9110
	if !ctx.cr[0].eq {
	pc = 0x829A9110; continue 'dispatch;
	}
	// 829A912C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A9130: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A9134: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 829A9138: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829A913C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829A9140: 38A00F3F  li r5, 0xf3f
	ctx.r[5].s64 = 3903;
	// 829A9144: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829A9148: 484AF8F9  bl 0x82e58a40
	ctx.lr = 0x829A914C;
	sub_82E58A40(ctx, base);
	// 829A914C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829A9150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9154: 419A0008  beq cr6, 0x829a915c
	if ctx.cr[6].eq {
	pc = 0x829A915C; continue 'dispatch;
	}
	// 829A9158: 4B917739  bl 0x822c0890
	ctx.lr = 0x829A915C;
	sub_822C0890(ctx, base);
	// 829A915C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829A9160: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9164: 419A0008  beq cr6, 0x829a916c
	if ctx.cr[6].eq {
	pc = 0x829A916C; continue 'dispatch;
	}
	// 829A9168: 4B917729  bl 0x822c0890
	ctx.lr = 0x829A916C;
	sub_822C0890(ctx, base);
	// 829A916C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829A9170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9174: 419A00B8  beq cr6, 0x829a922c
	if ctx.cr[6].eq {
	pc = 0x829A922C; continue 'dispatch;
	}
	// 829A9178: 4B917719  bl 0x822c0890
	ctx.lr = 0x829A917C;
	sub_822C0890(ctx, base);
	// 829A917C: 480000B0  b 0x829a922c
	pc = 0x829A922C; continue 'dispatch;
	// 829A9180: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829A9184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A9188: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 829A918C: 4BB6895D  bl 0x82511ae8
	ctx.lr = 0x829A9190;
	sub_82511AE8(ctx, base);
	// 829A9190: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829A9194: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829A9198: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829A919C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829A91A0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829A91A4: 4BE62CED  bl 0x8280be90
	ctx.lr = 0x829A91A8;
	sub_8280BE90(ctx, base);
	// 829A91A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A91AC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829A91B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A91B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A91B8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829A91BC: 419A0024  beq cr6, 0x829a91e0
	if ctx.cr[6].eq {
	pc = 0x829A91E0; continue 'dispatch;
	}
	// 829A91C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A91C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A91C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A91CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A91D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A91D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A91D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A91DC: 4082FFE8  bne 0x829a91c4
	if !ctx.cr[0].eq {
	pc = 0x829A91C4; continue 'dispatch;
	}
	// 829A91E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A91E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A91E8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 829A91EC: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829A91F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829A91F4: 38A00F27  li r5, 0xf27
	ctx.r[5].s64 = 3879;
	// 829A91F8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829A91FC: 484AF845  bl 0x82e58a40
	ctx.lr = 0x829A9200;
	sub_82E58A40(ctx, base);
	// 829A9200: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A9204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9208: 419A0008  beq cr6, 0x829a9210
	if ctx.cr[6].eq {
	pc = 0x829A9210; continue 'dispatch;
	}
	// 829A920C: 4B917685  bl 0x822c0890
	ctx.lr = 0x829A9210;
	sub_822C0890(ctx, base);
	// 829A9210: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 829A9214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9218: 419A0008  beq cr6, 0x829a9220
	if ctx.cr[6].eq {
	pc = 0x829A9220; continue 'dispatch;
	}
	// 829A921C: 4B917675  bl 0x822c0890
	ctx.lr = 0x829A9220;
	sub_822C0890(ctx, base);
	// 829A9220: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A9224: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A9228: D01F03D4  stfs f0, 0x3d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), tmp.u32 ) };
	// 829A922C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829A9230: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829A9234: 487FEF80  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A9238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A9238 size=196
    let mut pc: u32 = 0x829A9238;
    'dispatch: loop {
        match pc {
            0x829A9238 => {
    //   block [0x829A9238..0x829A92FC)
	// 829A9238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A923C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829A9240: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829A9244: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A9248: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A924C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829A9250: 4BFE1F19  bl 0x8298b168
	ctx.lr = 0x829A9254;
	sub_8298B168(ctx, base);
	// 829A9254: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9258: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829A925C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A9260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9264: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829A9268: 419A0024  beq cr6, 0x829a928c
	if ctx.cr[6].eq {
	pc = 0x829A928C; continue 'dispatch;
	}
	// 829A926C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A9270: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9274: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9278: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A927C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9280: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9284: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9288: 4082FFE8  bne 0x829a9270
	if !ctx.cr[0].eq {
	pc = 0x829A9270; continue 'dispatch;
	}
	// 829A928C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A9290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A9294: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 829A9298: 4844A771  bl 0x82df3a08
	ctx.lr = 0x829A929C;
	sub_82DF3A08(ctx, base);
	// 829A929C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A92A0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829A92A4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 829A92A8: 388A1A70  addi r4, r10, 0x1a70
	ctx.r[4].s64 = ctx.r[10].s64 + 6768;
	// 829A92AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829A92B0: 38A010CA  li r5, 0x10ca
	ctx.r[5].s64 = 4298;
	// 829A92B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829A92B8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829A92BC: 484AF8F5  bl 0x82e58bb0
	ctx.lr = 0x829A92C0;
	sub_82E58BB0(ctx, base);
	// 829A92C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829A92C4: 4844A165  bl 0x82df3428
	ctx.lr = 0x829A92C8;
	sub_82DF3428(ctx, base);
	// 829A92C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A92CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A92D0: 419A0008  beq cr6, 0x829a92d8
	if ctx.cr[6].eq {
	pc = 0x829A92D8; continue 'dispatch;
	}
	// 829A92D4: 4B9175BD  bl 0x822c0890
	ctx.lr = 0x829A92D8;
	sub_822C0890(ctx, base);
	// 829A92D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A92DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A92E0: 419A0008  beq cr6, 0x829a92e8
	if ctx.cr[6].eq {
	pc = 0x829A92E8; continue 'dispatch;
	}
	// 829A92E4: 4B9175AD  bl 0x822c0890
	ctx.lr = 0x829A92E8;
	sub_822C0890(ctx, base);
	// 829A92E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829A92EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829A92F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829A92F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829A92F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A9300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A9300 size=616
    let mut pc: u32 = 0x829A9300;
    'dispatch: loop {
        match pc {
            0x829A9300 => {
    //   block [0x829A9300..0x829A9568)
	// 829A9300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A9304: 487FEE61  bl 0x831a8164
	ctx.lr = 0x829A9308;
	sub_831A8130(ctx, base);
	// 829A9308: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829A930C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A9310: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829A9314: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A9318: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829A931C: 895C03D9  lbz r10, 0x3d9(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A9320: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829A9324: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829A9328: 419A0218  beq cr6, 0x829a9540
	if ctx.cr[6].eq {
	pc = 0x829A9540; continue 'dispatch;
	}
	// 829A932C: 4BFFFF0D  bl 0x829a9238
	ctx.lr = 0x829A9330;
	sub_829A9238(ctx, base);
	// 829A9330: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 829A9334: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829A9338: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A933C: 4BFE1DB5  bl 0x8298b0f0
	ctx.lr = 0x829A9340;
	sub_8298B0F0(ctx, base);
	// 829A9340: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9344: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829A9348: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A934C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9350: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829A9354: 419A0024  beq cr6, 0x829a9378
	if ctx.cr[6].eq {
	pc = 0x829A9378; continue 'dispatch;
	}
	// 829A9358: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A935C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9360: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9364: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9368: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A936C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9370: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9374: 4082FFE8  bne 0x829a935c
	if !ctx.cr[0].eq {
	pc = 0x829A935C; continue 'dispatch;
	}
	// 829A9378: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A937C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829A9380: 4BB66149  bl 0x8250f4c8
	ctx.lr = 0x829A9384;
	sub_8250F4C8(ctx, base);
	// 829A9384: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A938C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A9390: 409A0008  bne cr6, 0x829a9398
	if !ctx.cr[6].eq {
	pc = 0x829A9398; continue 'dispatch;
	}
	// 829A9394: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829A9398: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A939C: 3BDC0028  addi r30, r28, 0x28
	ctx.r[30].s64 = ctx.r[28].s64 + 40;
	// 829A93A0: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 829A93A4: 4BB5F675  bl 0x82508a18
	ctx.lr = 0x829A93A8;
	sub_82508A18(ctx, base);
	// 829A93A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A93AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A93B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A93B4: 3BAB1A70  addi r29, r11, 0x1a70
	ctx.r[29].s64 = ctx.r[11].s64 + 6768;
	// 829A93B8: 38A00FC5  li r5, 0xfc5
	ctx.r[5].s64 = 4037;
	// 829A93BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829A93C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A93C4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A93C8: 484AF679  bl 0x82e58a40
	ctx.lr = 0x829A93CC;
	sub_82E58A40(ctx, base);
	// 829A93CC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829A93D0: 484488C1  bl 0x82df1c90
	ctx.lr = 0x829A93D4;
	sub_82DF1C90(ctx, base);
	// 829A93D4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829A93D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A93DC: 419A0008  beq cr6, 0x829a93e4
	if ctx.cr[6].eq {
	pc = 0x829A93E4; continue 'dispatch;
	}
	// 829A93E0: 4B9174B1  bl 0x822c0890
	ctx.lr = 0x829A93E4;
	sub_822C0890(ctx, base);
	// 829A93E4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829A93E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A93EC: 419A0008  beq cr6, 0x829a93f4
	if ctx.cr[6].eq {
	pc = 0x829A93F4; continue 'dispatch;
	}
	// 829A93F0: 4B9174A1  bl 0x822c0890
	ctx.lr = 0x829A93F4;
	sub_822C0890(ctx, base);
	// 829A93F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A93F8: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 829A93FC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829A9400: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829A9404: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A9408: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829A940C: 38A00FD1  li r5, 0xfd1
	ctx.r[5].s64 = 4049;
	// 829A9410: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 829A9414: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A9418: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829A941C: 48448FCD  bl 0x82df23e8
	ctx.lr = 0x829A9420;
	sub_82DF23E8(ctx, base);
	// 829A9420: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A9424: 41820020  beq 0x829a9444
	if ctx.cr[0].eq {
	pc = 0x829A9444; continue 'dispatch;
	}
	// 829A9428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A942C: 4865FB8D  bl 0x83008fb8
	ctx.lr = 0x829A9430;
	sub_83008FB8(ctx, base);
	// 829A9430: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A9434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A9438: 4BAC8521  bl 0x82471958
	ctx.lr = 0x829A943C;
	sub_82471958(ctx, base);
	// 829A943C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A9440: 48000008  b 0x829a9448
	pc = 0x829A9448; continue 'dispatch;
	// 829A9444: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829A9448: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 829A944C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9450: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A9454: 4BABC105  bl 0x82465558
	ctx.lr = 0x829A9458;
	sub_82465558(ctx, base);
	// 829A9458: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A945C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9460: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A9464: 4B916B9D  bl 0x822c0000
	ctx.lr = 0x829A9468;
	sub_822C0000(ctx, base);
	// 829A9468: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 829A946C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829A9470: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829A9474: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829A9478: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A947C: 4BFE1BDD  bl 0x8298b058
	ctx.lr = 0x829A9480;
	sub_8298B058(ctx, base);
	// 829A9480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9484: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829A9488: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A948C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9490: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829A9494: 419A0024  beq cr6, 0x829a94b8
	if ctx.cr[6].eq {
	pc = 0x829A94B8; continue 'dispatch;
	}
	// 829A9498: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A949C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A94A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A94A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A94A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A94AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A94B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A94B4: 4082FFE8  bne 0x829a949c
	if !ctx.cr[0].eq {
	pc = 0x829A949C; continue 'dispatch;
	}
	// 829A94B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A94BC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A94C0: 4BB66059  bl 0x8250f518
	ctx.lr = 0x829A94C4;
	sub_8250F518(ctx, base);
	// 829A94C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A94C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A94CC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829A94D0: 409A0008  bne cr6, 0x829a94d8
	if !ctx.cr[6].eq {
	pc = 0x829A94D8; continue 'dispatch;
	}
	// 829A94D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829A94D8: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 829A94DC: 4BB7EB75  bl 0x82528050
	ctx.lr = 0x829A94E0;
	sub_82528050(ctx, base);
	// 829A94E0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A94E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A94E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829A94EC: 38A00FD1  li r5, 0xfd1
	ctx.r[5].s64 = 4049;
	// 829A94F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A94F4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A94F8: 484AF549  bl 0x82e58a40
	ctx.lr = 0x829A94FC;
	sub_82E58A40(ctx, base);
	// 829A94FC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A9500: 48448791  bl 0x82df1c90
	ctx.lr = 0x829A9504;
	sub_82DF1C90(ctx, base);
	// 829A9504: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829A9508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A950C: 419A0008  beq cr6, 0x829a9514
	if ctx.cr[6].eq {
	pc = 0x829A9514; continue 'dispatch;
	}
	// 829A9510: 4B917381  bl 0x822c0890
	ctx.lr = 0x829A9514;
	sub_822C0890(ctx, base);
	// 829A9514: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829A9518: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A951C: 419A0008  beq cr6, 0x829a9524
	if ctx.cr[6].eq {
	pc = 0x829A9524; continue 'dispatch;
	}
	// 829A9520: 4B917371  bl 0x822c0890
	ctx.lr = 0x829A9524;
	sub_822C0890(ctx, base);
	// 829A9524: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A9528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A952C: 419A0008  beq cr6, 0x829a9534
	if ctx.cr[6].eq {
	pc = 0x829A9534; continue 'dispatch;
	}
	// 829A9530: 4B917361  bl 0x822c0890
	ctx.lr = 0x829A9534;
	sub_822C0890(ctx, base);
	// 829A9534: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A9538: 816B7F68  lwz r11, 0x7f68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32616 as u32) ) } as u64;
	// 829A953C: 917C0470  stw r11, 0x470(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1136 as u32), ctx.r[11].u32 ) };
	// 829A9540: 897C03D9  lbz r11, 0x3d9(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A9544: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A9548: 41820010  beq 0x829a9558
	if ctx.cr[0].eq {
	pc = 0x829A9558; continue 'dispatch;
	}
	// 829A954C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 829A9550: 419A0008  beq cr6, 0x829a9558
	if ctx.cr[6].eq {
	pc = 0x829A9558; continue 'dispatch;
	}
	// 829A9554: D3FC0484  stfs f31, 0x484(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1156 as u32), tmp.u32 ) };
	// 829A9558: 9B7C03D9  stb r27, 0x3d9(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(985 as u32), ctx.r[27].u8 ) };
	// 829A955C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829A9560: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829A9564: 487FEC50  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A9568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A9568 size=1300
    let mut pc: u32 = 0x829A9568;
    'dispatch: loop {
        match pc {
            0x829A9568 => {
    //   block [0x829A9568..0x829A9A7C)
	// 829A9568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A956C: 487FEBED  bl 0x831a8158
	ctx.lr = 0x829A9570;
	sub_831A8130(ctx, base);
	// 829A9570: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 829A9574: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A9578: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829A957C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A9580: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A9584: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829A9588: 3B6B1A70  addi r27, r11, 0x1a70
	ctx.r[27].s64 = ctx.r[11].s64 + 6768;
	// 829A958C: 893C03D9  lbz r9, 0x3d9(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A9590: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829A9594: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 829A9598: 409A00B4  bne cr6, 0x829a964c
	if !ctx.cr[6].eq {
	pc = 0x829A964C; continue 'dispatch;
	}
	// 829A959C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829A95A0: 4BFFD3B9  bl 0x829a6958
	ctx.lr = 0x829A95A4;
	sub_829A6958(ctx, base);
	// 829A95A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A95A8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 829A95AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A95B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A95B4: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 829A95B8: 419A0024  beq cr6, 0x829a95dc
	if ctx.cr[6].eq {
	pc = 0x829A95DC; continue 'dispatch;
	}
	// 829A95BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A95C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A95C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A95C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A95CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A95D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A95D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A95D8: 4082FFE8  bne 0x829a95c0
	if !ctx.cr[0].eq {
	pc = 0x829A95C0; continue 'dispatch;
	}
	// 829A95DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A95E0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829A95E4: 4BB65EE5  bl 0x8250f4c8
	ctx.lr = 0x829A95E8;
	sub_8250F4C8(ctx, base);
	// 829A95E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A95EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A95F0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A95F4: 409A0008  bne cr6, 0x829a95fc
	if !ctx.cr[6].eq {
	pc = 0x829A95FC; continue 'dispatch;
	}
	// 829A95F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A95FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A9600: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	// 829A9604: 4BB5F415  bl 0x82508a18
	ctx.lr = 0x829A9608;
	sub_82508A18(ctx, base);
	// 829A9608: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A960C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A9610: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A9614: 38A01013  li r5, 0x1013
	ctx.r[5].s64 = 4115;
	// 829A9618: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 829A961C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A9620: 484AF421  bl 0x82e58a40
	ctx.lr = 0x829A9624;
	sub_82E58A40(ctx, base);
	// 829A9624: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829A9628: 48448669  bl 0x82df1c90
	ctx.lr = 0x829A962C;
	sub_82DF1C90(ctx, base);
	// 829A962C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829A9630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9634: 419A0008  beq cr6, 0x829a963c
	if ctx.cr[6].eq {
	pc = 0x829A963C; continue 'dispatch;
	}
	// 829A9638: 4B917259  bl 0x822c0890
	ctx.lr = 0x829A963C;
	sub_822C0890(ctx, base);
	// 829A963C: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829A9640: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9644: 419A0008  beq cr6, 0x829a964c
	if ctx.cr[6].eq {
	pc = 0x829A964C; continue 'dispatch;
	}
	// 829A9648: 4B917249  bl 0x822c0890
	ctx.lr = 0x829A964C;
	sub_822C0890(ctx, base);
	// 829A964C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 829A9650: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829A9654: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 829A9658: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829A965C: 388B7F64  addi r4, r11, 0x7f64
	ctx.r[4].s64 = ctx.r[11].s64 + 32612;
	// 829A9660: 38BC0400  addi r5, r28, 0x400
	ctx.r[5].s64 = ctx.r[28].s64 + 1024;
	// 829A9664: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829A9668: 4BFE15C9  bl 0x8298ac30
	ctx.lr = 0x829A966C;
	sub_8298AC30(ctx, base);
	// 829A966C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9670: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829A9674: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A9678: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A967C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 829A9680: 419A0024  beq cr6, 0x829a96a4
	if ctx.cr[6].eq {
	pc = 0x829A96A4; continue 'dispatch;
	}
	// 829A9684: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A9688: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A968C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9690: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9694: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9698: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A969C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A96A0: 4082FFE8  bne 0x829a9688
	if !ctx.cr[0].eq {
	pc = 0x829A9688; continue 'dispatch;
	}
	// 829A96A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A96A8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A96AC: 4BB65E1D  bl 0x8250f4c8
	ctx.lr = 0x829A96B0;
	sub_8250F4C8(ctx, base);
	// 829A96B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A96B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A96B8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A96BC: 409A0008  bne cr6, 0x829a96c4
	if !ctx.cr[6].eq {
	pc = 0x829A96C4; continue 'dispatch;
	}
	// 829A96C0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A96C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A96C8: 3BDC0028  addi r30, r28, 0x28
	ctx.r[30].s64 = ctx.r[28].s64 + 40;
	// 829A96CC: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 829A96D0: 4BB5F349  bl 0x82508a18
	ctx.lr = 0x829A96D4;
	sub_82508A18(ctx, base);
	// 829A96D4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A96D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A96DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A96E0: 38A0101E  li r5, 0x101e
	ctx.r[5].s64 = 4126;
	// 829A96E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A96E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A96EC: 484AF355  bl 0x82e58a40
	ctx.lr = 0x829A96F0;
	sub_82E58A40(ctx, base);
	// 829A96F0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A96F4: 4844859D  bl 0x82df1c90
	ctx.lr = 0x829A96F8;
	sub_82DF1C90(ctx, base);
	// 829A96F8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829A96FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9700: 419A0008  beq cr6, 0x829a9708
	if ctx.cr[6].eq {
	pc = 0x829A9708; continue 'dispatch;
	}
	// 829A9704: 4B91718D  bl 0x822c0890
	ctx.lr = 0x829A9708;
	sub_822C0890(ctx, base);
	// 829A9708: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829A970C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9710: 419A0008  beq cr6, 0x829a9718
	if ctx.cr[6].eq {
	pc = 0x829A9718; continue 'dispatch;
	}
	// 829A9714: 4B91717D  bl 0x822c0890
	ctx.lr = 0x829A9718;
	sub_822C0890(ctx, base);
	// 829A9718: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 829A971C: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 829A9720: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829A9724: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829A9728: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829A972C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829A9730: 4BEAA109  bl 0x82853838
	ctx.lr = 0x829A9734;
	sub_82853838(ctx, base);
	// 829A9734: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9738: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829A973C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A9740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9744: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829A9748: 419A0024  beq cr6, 0x829a976c
	if ctx.cr[6].eq {
	pc = 0x829A976C; continue 'dispatch;
	}
	// 829A974C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A9750: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9754: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9758: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A975C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9760: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9764: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9768: 4082FFE8  bne 0x829a9750
	if !ctx.cr[0].eq {
	pc = 0x829A9750; continue 'dispatch;
	}
	// 829A976C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A9770: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A9774: 4BB65D55  bl 0x8250f4c8
	ctx.lr = 0x829A9778;
	sub_8250F4C8(ctx, base);
	// 829A9778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A977C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9780: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A9784: 409A0008  bne cr6, 0x829a978c
	if !ctx.cr[6].eq {
	pc = 0x829A978C; continue 'dispatch;
	}
	// 829A9788: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A978C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A9790: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 829A9794: 4BB5F285  bl 0x82508a18
	ctx.lr = 0x829A9798;
	sub_82508A18(ctx, base);
	// 829A9798: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A979C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A97A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A97A4: 38A01021  li r5, 0x1021
	ctx.r[5].s64 = 4129;
	// 829A97A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A97AC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A97B0: 484AF291  bl 0x82e58a40
	ctx.lr = 0x829A97B4;
	sub_82E58A40(ctx, base);
	// 829A97B4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A97B8: 484484D9  bl 0x82df1c90
	ctx.lr = 0x829A97BC;
	sub_82DF1C90(ctx, base);
	// 829A97BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829A97C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A97C4: 419A0008  beq cr6, 0x829a97cc
	if ctx.cr[6].eq {
	pc = 0x829A97CC; continue 'dispatch;
	}
	// 829A97C8: 4B9170C9  bl 0x822c0890
	ctx.lr = 0x829A97CC;
	sub_822C0890(ctx, base);
	// 829A97CC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829A97D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A97D4: 419A0008  beq cr6, 0x829a97dc
	if ctx.cr[6].eq {
	pc = 0x829A97DC; continue 'dispatch;
	}
	// 829A97D8: 4B9170B9  bl 0x822c0890
	ctx.lr = 0x829A97DC;
	sub_822C0890(ctx, base);
	// 829A97DC: 897C03D9  lbz r11, 0x3d9(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A97E0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829A97E4: 419A026C  beq cr6, 0x829a9a50
	if ctx.cr[6].eq {
	pc = 0x829A9A50; continue 'dispatch;
	}
	// 829A97E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829A97EC: 4BFFFA4D  bl 0x829a9238
	ctx.lr = 0x829A97F0;
	sub_829A9238(ctx, base);
	// 829A97F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A97F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A97F8: 38A0102B  li r5, 0x102b
	ctx.r[5].s64 = 4139;
	// 829A97FC: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 829A9800: 48448BE9  bl 0x82df23e8
	ctx.lr = 0x829A9804;
	sub_82DF23E8(ctx, base);
	// 829A9804: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A9808: 41820010  beq 0x829a9818
	if ctx.cr[0].eq {
	pc = 0x829A9818; continue 'dispatch;
	}
	// 829A980C: 481AF44D  bl 0x82b58c58
	ctx.lr = 0x829A9810;
	sub_82B58C58(ctx, base);
	// 829A9810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A9814: 48000008  b 0x829a981c
	pc = 0x829A981C; continue 'dispatch;
	// 829A9818: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829A981C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829A9820: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9824: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829A9828: 4BC467B1  bl 0x825effd8
	ctx.lr = 0x829A982C;
	sub_825EFFD8(ctx, base);
	// 829A982C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A9830: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9834: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829A9838: 4B9167C9  bl 0x822c0000
	ctx.lr = 0x829A983C;
	sub_822C0000(ctx, base);
	// 829A983C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829A9840: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A9844: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A9848: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829A984C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A9850: 9B2B0019  stb r25, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[25].u8 ) };
	// 829A9854: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A9858: 9B4B002C  stb r26, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[26].u8 ) };
	// 829A985C: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 829A9860: C1A9FD2C  lfs f13, -0x2d4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-724 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A9864: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829A9868: D1AB0028  stfs f13, 0x28(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 829A986C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829A9870: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 829A9874: 419A0024  beq cr6, 0x829a9898
	if ctx.cr[6].eq {
	pc = 0x829A9898; continue 'dispatch;
	}
	// 829A9878: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829A987C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9880: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9884: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9888: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A988C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9890: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9894: 4082FFE8  bne 0x829a987c
	if !ctx.cr[0].eq {
	pc = 0x829A987C; continue 'dispatch;
	}
	// 829A9898: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A989C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829A98A0: 4BB65C29  bl 0x8250f4c8
	ctx.lr = 0x829A98A4;
	sub_8250F4C8(ctx, base);
	// 829A98A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A98A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A98AC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A98B0: 409A0008  bne cr6, 0x829a98b8
	if !ctx.cr[6].eq {
	pc = 0x829A98B8; continue 'dispatch;
	}
	// 829A98B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A98B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A98BC: 3B010078  addi r24, r1, 0x78
	ctx.r[24].s64 = ctx.r[1].s64 + 120;
	// 829A98C0: 4BB5F159  bl 0x82508a18
	ctx.lr = 0x829A98C4;
	sub_82508A18(ctx, base);
	// 829A98C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A98C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A98CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A98D0: 38A01037  li r5, 0x1037
	ctx.r[5].s64 = 4151;
	// 829A98D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A98D8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 829A98DC: 484AF165  bl 0x82e58a40
	ctx.lr = 0x829A98E0;
	sub_82E58A40(ctx, base);
	// 829A98E0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829A98E4: 484483AD  bl 0x82df1c90
	ctx.lr = 0x829A98E8;
	sub_82DF1C90(ctx, base);
	// 829A98E8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829A98EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A98F0: 419A0008  beq cr6, 0x829a98f8
	if ctx.cr[6].eq {
	pc = 0x829A98F8; continue 'dispatch;
	}
	// 829A98F4: 4B916F9D  bl 0x822c0890
	ctx.lr = 0x829A98F8;
	sub_822C0890(ctx, base);
	// 829A98F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A98FC: 419A000C  beq cr6, 0x829a9908
	if ctx.cr[6].eq {
	pc = 0x829A9908; continue 'dispatch;
	}
	// 829A9900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A9904: 4B916F8D  bl 0x822c0890
	ctx.lr = 0x829A9908;
	sub_822C0890(ctx, base);
	// 829A9908: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A990C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829A9910: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A9914: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 829A9918: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A991C: 38A01044  li r5, 0x1044
	ctx.r[5].s64 = 4164;
	// 829A9920: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 829A9924: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A9928: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829A992C: 48448ABD  bl 0x82df23e8
	ctx.lr = 0x829A9930;
	sub_82DF23E8(ctx, base);
	// 829A9930: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A9934: 41820020  beq 0x829a9954
	if ctx.cr[0].eq {
	pc = 0x829A9954; continue 'dispatch;
	}
	// 829A9938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A993C: 4865F67D  bl 0x83008fb8
	ctx.lr = 0x829A9940;
	sub_83008FB8(ctx, base);
	// 829A9940: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A9944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A9948: 4BACAE71  bl 0x824747b8
	ctx.lr = 0x829A994C;
	sub_824747B8(ctx, base);
	// 829A994C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A9950: 48000008  b 0x829a9958
	pc = 0x829A9958; continue 'dispatch;
	// 829A9954: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829A9958: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 829A995C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9960: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A9964: 4BFDEC25  bl 0x82988588
	ctx.lr = 0x829A9968;
	sub_82988588(ctx, base);
	// 829A9968: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A996C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9970: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A9974: 4B91668D  bl 0x822c0000
	ctx.lr = 0x829A9978;
	sub_822C0000(ctx, base);
	// 829A9978: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 829A997C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829A9980: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829A9984: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829A9988: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829A998C: 4BFE16CD  bl 0x8298b058
	ctx.lr = 0x829A9990;
	sub_8298B058(ctx, base);
	// 829A9990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9994: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829A9998: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A999C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A99A0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829A99A4: 419A0024  beq cr6, 0x829a99c8
	if ctx.cr[6].eq {
	pc = 0x829A99C8; continue 'dispatch;
	}
	// 829A99A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A99AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A99B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A99B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A99B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A99BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A99C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A99C4: 4082FFE8  bne 0x829a99ac
	if !ctx.cr[0].eq {
	pc = 0x829A99AC; continue 'dispatch;
	}
	// 829A99C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A99CC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829A99D0: 4BB65B49  bl 0x8250f518
	ctx.lr = 0x829A99D4;
	sub_8250F518(ctx, base);
	// 829A99D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A99D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A99DC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829A99E0: 409A0008  bne cr6, 0x829a99e8
	if !ctx.cr[6].eq {
	pc = 0x829A99E8; continue 'dispatch;
	}
	// 829A99E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A99E8: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 829A99EC: 4BB7E665  bl 0x82528050
	ctx.lr = 0x829A99F0;
	sub_82528050(ctx, base);
	// 829A99F0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A99F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829A99F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A99FC: 38A01044  li r5, 0x1044
	ctx.r[5].s64 = 4164;
	// 829A9A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A9A04: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A9A08: 484AF039  bl 0x82e58a40
	ctx.lr = 0x829A9A0C;
	sub_82E58A40(ctx, base);
	// 829A9A0C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829A9A10: 48448281  bl 0x82df1c90
	ctx.lr = 0x829A9A14;
	sub_82DF1C90(ctx, base);
	// 829A9A14: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829A9A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9A1C: 419A0008  beq cr6, 0x829a9a24
	if ctx.cr[6].eq {
	pc = 0x829A9A24; continue 'dispatch;
	}
	// 829A9A20: 4B916E71  bl 0x822c0890
	ctx.lr = 0x829A9A24;
	sub_822C0890(ctx, base);
	// 829A9A24: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 829A9A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9A2C: 419A0008  beq cr6, 0x829a9a34
	if ctx.cr[6].eq {
	pc = 0x829A9A34; continue 'dispatch;
	}
	// 829A9A30: 4B916E61  bl 0x822c0890
	ctx.lr = 0x829A9A34;
	sub_822C0890(ctx, base);
	// 829A9A34: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A9A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9A3C: 419A0008  beq cr6, 0x829a9a44
	if ctx.cr[6].eq {
	pc = 0x829A9A44; continue 'dispatch;
	}
	// 829A9A40: 4B916E51  bl 0x822c0890
	ctx.lr = 0x829A9A44;
	sub_822C0890(ctx, base);
	// 829A9A44: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829A9A48: 816BCAD8  lwz r11, -0x3528(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13608 as u32) ) } as u64;
	// 829A9A4C: 917C0470  stw r11, 0x470(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1136 as u32), ctx.r[11].u32 ) };
	// 829A9A50: 897C03D9  lbz r11, 0x3d9(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A9A54: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829A9A58: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829A9A5C: 419A0010  beq cr6, 0x829a9a6c
	if ctx.cr[6].eq {
	pc = 0x829A9A6C; continue 'dispatch;
	}
	// 829A9A60: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 829A9A64: 419A0008  beq cr6, 0x829a9a6c
	if ctx.cr[6].eq {
	pc = 0x829A9A6C; continue 'dispatch;
	}
	// 829A9A68: D3FC0484  stfs f31, 0x484(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1156 as u32), tmp.u32 ) };
	// 829A9A6C: 9B3C03D9  stb r25, 0x3d9(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(985 as u32), ctx.r[25].u8 ) };
	// 829A9A70: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 829A9A74: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 829A9A78: 487FE730  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A9A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A9A80 size=968
    let mut pc: u32 = 0x829A9A80;
    'dispatch: loop {
        match pc {
            0x829A9A80 => {
    //   block [0x829A9A80..0x829A9E48)
	// 829A9A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A9A84: 487FE6D9  bl 0x831a815c
	ctx.lr = 0x829A9A88;
	sub_831A8130(ctx, base);
	// 829A9A88: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 829A9A8C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829A9A90: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A9A94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829A9A98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A9A9C: 895B03D9  lbz r10, 0x3d9(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A9AA0: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829A9AA4: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 829A9AA8: 419A036C  beq cr6, 0x829a9e14
	if ctx.cr[6].eq {
	pc = 0x829A9E14; continue 'dispatch;
	}
	// 829A9AAC: 4BFFF78D  bl 0x829a9238
	ctx.lr = 0x829A9AB0;
	sub_829A9238(ctx, base);
	// 829A9AB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A9AB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A9AB8: 3B8B1A70  addi r28, r11, 0x1a70
	ctx.r[28].s64 = ctx.r[11].s64 + 6768;
	// 829A9ABC: 38A01073  li r5, 0x1073
	ctx.r[5].s64 = 4211;
	// 829A9AC0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A9AC4: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 829A9AC8: 48448921  bl 0x82df23e8
	ctx.lr = 0x829A9ACC;
	sub_82DF23E8(ctx, base);
	// 829A9ACC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829A9AD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A9AD4: 41820010  beq 0x829a9ae4
	if ctx.cr[0].eq {
	pc = 0x829A9AE4; continue 'dispatch;
	}
	// 829A9AD8: 481AF181  bl 0x82b58c58
	ctx.lr = 0x829A9ADC;
	sub_82B58C58(ctx, base);
	// 829A9ADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A9AE0: 48000008  b 0x829a9ae8
	pc = 0x829A9AE8; continue 'dispatch;
	// 829A9AE4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829A9AE8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829A9AEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9AF0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829A9AF4: 4BC464E5  bl 0x825effd8
	ctx.lr = 0x829A9AF8;
	sub_825EFFD8(ctx, base);
	// 829A9AF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A9AFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9B00: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829A9B04: 4B9164FD  bl 0x822c0000
	ctx.lr = 0x829A9B08;
	sub_822C0000(ctx, base);
	// 829A9B08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829A9B0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829A9B10: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829A9B14: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829A9B18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A9B1C: 9BCB0019  stb r30, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[30].u8 ) };
	// 829A9B20: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A9B24: 9B4B002C  stb r26, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[26].u8 ) };
	// 829A9B28: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 829A9B2C: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829A9B30: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829A9B34: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 829A9B38: 419A0024  beq cr6, 0x829a9b5c
	if ctx.cr[6].eq {
	pc = 0x829A9B5C; continue 'dispatch;
	}
	// 829A9B3C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829A9B40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9B44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9B48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9B4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9B50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9B54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9B58: 4082FFE8  bne 0x829a9b40
	if !ctx.cr[0].eq {
	pc = 0x829A9B40; continue 'dispatch;
	}
	// 829A9B5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A9B60: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A9B64: 4BB65965  bl 0x8250f4c8
	ctx.lr = 0x829A9B68;
	sub_8250F4C8(ctx, base);
	// 829A9B68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9B70: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A9B74: 409A0008  bne cr6, 0x829a9b7c
	if !ctx.cr[6].eq {
	pc = 0x829A9B7C; continue 'dispatch;
	}
	// 829A9B78: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A9B7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A9B80: 3BBB0028  addi r29, r27, 0x28
	ctx.r[29].s64 = ctx.r[27].s64 + 40;
	// 829A9B84: 3B210068  addi r25, r1, 0x68
	ctx.r[25].s64 = ctx.r[1].s64 + 104;
	// 829A9B88: 4BB5EE91  bl 0x82508a18
	ctx.lr = 0x829A9B8C;
	sub_82508A18(ctx, base);
	// 829A9B8C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A9B90: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829A9B94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A9B98: 38A0107C  li r5, 0x107c
	ctx.r[5].s64 = 4220;
	// 829A9B9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A9BA0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 829A9BA4: 484AEE9D  bl 0x82e58a40
	ctx.lr = 0x829A9BA8;
	sub_82E58A40(ctx, base);
	// 829A9BA8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829A9BAC: 484480E5  bl 0x82df1c90
	ctx.lr = 0x829A9BB0;
	sub_82DF1C90(ctx, base);
	// 829A9BB0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829A9BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9BB8: 419A0008  beq cr6, 0x829a9bc0
	if ctx.cr[6].eq {
	pc = 0x829A9BC0; continue 'dispatch;
	}
	// 829A9BBC: 4B916CD5  bl 0x822c0890
	ctx.lr = 0x829A9BC0;
	sub_822C0890(ctx, base);
	// 829A9BC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829A9BC4: 419A000C  beq cr6, 0x829a9bd0
	if ctx.cr[6].eq {
	pc = 0x829A9BD0; continue 'dispatch;
	}
	// 829A9BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A9BCC: 4B916CC5  bl 0x822c0890
	ctx.lr = 0x829A9BD0;
	sub_822C0890(ctx, base);
	// 829A9BD0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829A9BD4: 4B91642D  bl 0x822c0000
	ctx.lr = 0x829A9BD8;
	sub_822C0000(ctx, base);
	// 829A9BD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829A9BDC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829A9BE0: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 829A9BE4: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 829A9BE8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829A9BEC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 829A9BF0: C1AB9584  lfs f13, -0x6a7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829A9BF4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829A9BF8: C3EA9450  lfs f31, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829A9BFC: 389B0400  addi r4, r27, 0x400
	ctx.r[4].s64 = ctx.r[27].s64 + 1024;
	// 829A9C00: C00989AC  lfs f0, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829A9C04: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829A9C08: C188D0B0  lfs f12, -0x2f50(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829A9C0C: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 829A9C10: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 829A9C14: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829A9C18: D18100BC  stfs f12, 0xbc(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 829A9C1C: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 829A9C20: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 829A9C24: 4BFFCDB5  bl 0x829a69d8
	ctx.lr = 0x829A9C28;
	sub_829A69D8(ctx, base);
	// 829A9C28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9C2C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829A9C30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A9C34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9C38: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829A9C3C: 419A0024  beq cr6, 0x829a9c60
	if ctx.cr[6].eq {
	pc = 0x829A9C60; continue 'dispatch;
	}
	// 829A9C40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A9C44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9C48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9C4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9C50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9C54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9C58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9C5C: 4082FFE8  bne 0x829a9c44
	if !ctx.cr[0].eq {
	pc = 0x829A9C44; continue 'dispatch;
	}
	// 829A9C60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A9C64: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A9C68: 4BB65861  bl 0x8250f4c8
	ctx.lr = 0x829A9C6C;
	sub_8250F4C8(ctx, base);
	// 829A9C6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9C70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9C74: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829A9C78: 409A0008  bne cr6, 0x829a9c80
	if !ctx.cr[6].eq {
	pc = 0x829A9C80; continue 'dispatch;
	}
	// 829A9C7C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A9C80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829A9C84: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 829A9C88: 4BB5ED91  bl 0x82508a18
	ctx.lr = 0x829A9C8C;
	sub_82508A18(ctx, base);
	// 829A9C8C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A9C90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A9C94: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829A9C98: 38A01094  li r5, 0x1094
	ctx.r[5].s64 = 4244;
	// 829A9C9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A9CA0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A9CA4: 484AED9D  bl 0x82e58a40
	ctx.lr = 0x829A9CA8;
	sub_82E58A40(ctx, base);
	// 829A9CA8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829A9CAC: 48447FE5  bl 0x82df1c90
	ctx.lr = 0x829A9CB0;
	sub_82DF1C90(ctx, base);
	// 829A9CB0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829A9CB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9CB8: 419A0008  beq cr6, 0x829a9cc0
	if ctx.cr[6].eq {
	pc = 0x829A9CC0; continue 'dispatch;
	}
	// 829A9CBC: 4B916BD5  bl 0x822c0890
	ctx.lr = 0x829A9CC0;
	sub_822C0890(ctx, base);
	// 829A9CC0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829A9CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9CC8: 419A0008  beq cr6, 0x829a9cd0
	if ctx.cr[6].eq {
	pc = 0x829A9CD0; continue 'dispatch;
	}
	// 829A9CCC: 4B916BC5  bl 0x822c0890
	ctx.lr = 0x829A9CD0;
	sub_822C0890(ctx, base);
	// 829A9CD0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829A9CD4: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829A9CD8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A9CDC: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 829A9CE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A9CE4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829A9CE8: 38A010A0  li r5, 0x10a0
	ctx.r[5].s64 = 4256;
	// 829A9CEC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 829A9CF0: 484486F9  bl 0x82df23e8
	ctx.lr = 0x829A9CF4;
	sub_82DF23E8(ctx, base);
	// 829A9CF4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A9CF8: 41820020  beq 0x829a9d18
	if ctx.cr[0].eq {
	pc = 0x829A9D18; continue 'dispatch;
	}
	// 829A9CFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A9D00: 4865F2B9  bl 0x83008fb8
	ctx.lr = 0x829A9D04;
	sub_83008FB8(ctx, base);
	// 829A9D04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A9D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A9D0C: 4BAD653D  bl 0x82480248
	ctx.lr = 0x829A9D10;
	sub_82480248(ctx, base);
	// 829A9D10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A9D14: 48000008  b 0x829a9d1c
	pc = 0x829A9D1C; continue 'dispatch;
	// 829A9D18: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829A9D1C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 829A9D20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9D24: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A9D28: 4BABB769  bl 0x82465490
	ctx.lr = 0x829A9D2C;
	sub_82465490(ctx, base);
	// 829A9D2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A9D30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9D34: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829A9D38: 4B9162C9  bl 0x822c0000
	ctx.lr = 0x829A9D3C;
	sub_822C0000(ctx, base);
	// 829A9D3C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 829A9D40: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829A9D44: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829A9D48: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829A9D4C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829A9D50: 4BFE1309  bl 0x8298b058
	ctx.lr = 0x829A9D54;
	sub_8298B058(ctx, base);
	// 829A9D54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9D58: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829A9D5C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829A9D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9D64: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 829A9D68: 419A0024  beq cr6, 0x829a9d8c
	if ctx.cr[6].eq {
	pc = 0x829A9D8C; continue 'dispatch;
	}
	// 829A9D6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829A9D70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9D74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9D78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9D7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9D80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9D84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9D88: 4082FFE8  bne 0x829a9d70
	if !ctx.cr[0].eq {
	pc = 0x829A9D70; continue 'dispatch;
	}
	// 829A9D8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829A9D90: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A9D94: 4BB65785  bl 0x8250f518
	ctx.lr = 0x829A9D98;
	sub_8250F518(ctx, base);
	// 829A9D98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829A9D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829A9DA0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829A9DA4: 409A0008  bne cr6, 0x829a9dac
	if !ctx.cr[6].eq {
	pc = 0x829A9DAC; continue 'dispatch;
	}
	// 829A9DA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829A9DAC: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 829A9DB0: 4BB7E2A1  bl 0x82528050
	ctx.lr = 0x829A9DB4;
	sub_82528050(ctx, base);
	// 829A9DB4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829A9DB8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829A9DBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829A9DC0: 38A010A0  li r5, 0x10a0
	ctx.r[5].s64 = 4256;
	// 829A9DC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A9DC8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829A9DCC: 484AEC75  bl 0x82e58a40
	ctx.lr = 0x829A9DD0;
	sub_82E58A40(ctx, base);
	// 829A9DD0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829A9DD4: 48447EBD  bl 0x82df1c90
	ctx.lr = 0x829A9DD8;
	sub_82DF1C90(ctx, base);
	// 829A9DD8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829A9DDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9DE0: 419A0008  beq cr6, 0x829a9de8
	if ctx.cr[6].eq {
	pc = 0x829A9DE8; continue 'dispatch;
	}
	// 829A9DE4: 4B916AAD  bl 0x822c0890
	ctx.lr = 0x829A9DE8;
	sub_822C0890(ctx, base);
	// 829A9DE8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829A9DEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9DF0: 419A0008  beq cr6, 0x829a9df8
	if ctx.cr[6].eq {
	pc = 0x829A9DF8; continue 'dispatch;
	}
	// 829A9DF4: 4B916A9D  bl 0x822c0890
	ctx.lr = 0x829A9DF8;
	sub_822C0890(ctx, base);
	// 829A9DF8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829A9DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9E00: 419A0008  beq cr6, 0x829a9e08
	if ctx.cr[6].eq {
	pc = 0x829A9E08; continue 'dispatch;
	}
	// 829A9E04: 4B916A8D  bl 0x822c0890
	ctx.lr = 0x829A9E08;
	sub_822C0890(ctx, base);
	// 829A9E08: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829A9E0C: 816BCAD8  lwz r11, -0x3528(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13608 as u32) ) } as u64;
	// 829A9E10: 917B0470  stw r11, 0x470(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(1136 as u32), ctx.r[11].u32 ) };
	// 829A9E14: 897B03D9  lbz r11, 0x3d9(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(985 as u32) ) } as u64;
	// 829A9E18: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829A9E1C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829A9E20: 419A0010  beq cr6, 0x829a9e30
	if ctx.cr[6].eq {
	pc = 0x829A9E30; continue 'dispatch;
	}
	// 829A9E24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 829A9E28: 419A0008  beq cr6, 0x829a9e30
	if ctx.cr[6].eq {
	pc = 0x829A9E30; continue 'dispatch;
	}
	// 829A9E2C: D3DB0484  stfs f30, 0x484(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(1156 as u32), tmp.u32 ) };
	// 829A9E30: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829A9E34: 997B03D9  stb r11, 0x3d9(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(985 as u32), ctx.r[11].u8 ) };
	// 829A9E38: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829A9E3C: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 829A9E40: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 829A9E44: 487FE368  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A9E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829A9E48 size=424
    let mut pc: u32 = 0x829A9E48;
    'dispatch: loop {
        match pc {
            0x829A9E48 => {
    //   block [0x829A9E48..0x829A9FF0)
	// 829A9E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A9E4C: 487FE319  bl 0x831a8164
	ctx.lr = 0x829A9E50;
	sub_831A8130(ctx, base);
	// 829A9E50: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A9E54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829A9E58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829A9E5C: 3BCB1A70  addi r30, r11, 0x1a70
	ctx.r[30].s64 = ctx.r[11].s64 + 6768;
	// 829A9E60: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829A9E64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A9E68: 38A0017E  li r5, 0x17e
	ctx.r[5].s64 = 382;
	// 829A9E6C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829A9E70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A9E74: 38600490  li r3, 0x490
	ctx.r[3].s64 = 1168;
	// 829A9E78: 48448571  bl 0x82df23e8
	ctx.lr = 0x829A9E7C;
	sub_82DF23E8(ctx, base);
	// 829A9E7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829A9E80: 41820010  beq 0x829a9e90
	if ctx.cr[0].eq {
	pc = 0x829A9E90; continue 'dispatch;
	}
	// 829A9E84: 4BFFB6DD  bl 0x829a5560
	ctx.lr = 0x829A9E88;
	sub_829A5560(ctx, base);
	// 829A9E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A9E8C: 48000008  b 0x829a9e94
	pc = 0x829A9E94; continue 'dispatch;
	// 829A9E90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829A9E94: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829A9E98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9E9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829A9EA0: 4BFF9839  bl 0x829a36d8
	ctx.lr = 0x829A9EA4;
	sub_829A36D8(ctx, base);
	// 829A9EA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A9EA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9EAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829A9EB0: 4B916151  bl 0x822c0000
	ctx.lr = 0x829A9EB4;
	sub_822C0000(ctx, base);
	// 829A9EB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829A9EB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829A9EBC: 38A0017F  li r5, 0x17f
	ctx.r[5].s64 = 383;
	// 829A9EC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829A9EC4: 4B916515  bl 0x822c03d8
	ctx.lr = 0x829A9EC8;
	sub_822C03D8(ctx, base);
	// 829A9EC8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829A9ECC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829A9ED0: 418200B4  beq 0x829a9f84
	if ctx.cr[0].eq {
	pc = 0x829A9F84; continue 'dispatch;
	}
	// 829A9ED4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829A9ED8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829A9EDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829A9EE0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 829A9EE4: 409A0008  bne cr6, 0x829a9eec
	if !ctx.cr[6].eq {
	pc = 0x829A9EEC; continue 'dispatch;
	}
	// 829A9EE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829A9EEC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829A9EF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829A9EF4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 829A9EF8: 419A0024  beq cr6, 0x829a9f1c
	if ctx.cr[6].eq {
	pc = 0x829A9F1C; continue 'dispatch;
	}
	// 829A9EFC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829A9F00: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 829A9F04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9F08: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 829A9F0C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 829A9F10: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9F14: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9F18: 4082FFE8  bne 0x829a9f00
	if !ctx.cr[0].eq {
	pc = 0x829A9F00; continue 'dispatch;
	}
	// 829A9F1C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829A9F20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829A9F24: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 829A9F28: 419A0024  beq cr6, 0x829a9f4c
	if ctx.cr[6].eq {
	pc = 0x829A9F4C; continue 'dispatch;
	}
	// 829A9F2C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829A9F30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829A9F34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9F38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829A9F3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829A9F40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829A9F44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829A9F48: 4082FFE8  bne 0x829a9f30
	if !ctx.cr[0].eq {
	pc = 0x829A9F30; continue 'dispatch;
	}
	// 829A9F4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829A9F50: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 829A9F54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829A9F58: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 829A9F5C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829A9F60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829A9F64: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829A9F68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829A9F6C: 4BDEEFC5  bl 0x82798f30
	ctx.lr = 0x829A9F70;
	sub_82798F30(ctx, base);
	// 829A9F70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829A9F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829A9F78: 4BDF16F1  bl 0x8279b668
	ctx.lr = 0x829A9F7C;
	sub_8279B668(ctx, base);
	// 829A9F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829A9F80: 48000008  b 0x829a9f88
	pc = 0x829A9F88; continue 'dispatch;
	// 829A9F84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829A9F88: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829A9F8C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 829A9F90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A9F98: 4BBEDCB9  bl 0x82597c50
	ctx.lr = 0x829A9F9C;
	sub_82597C50(ctx, base);
	// 829A9F9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829A9FA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829A9FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829A9FA8: 4B916059  bl 0x822c0000
	ctx.lr = 0x829A9FAC;
	sub_822C0000(ctx, base);
	// 829A9FAC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829A9FB0: 41820024  beq 0x829a9fd4
	if ctx.cr[0].eq {
	pc = 0x829A9FD4; continue 'dispatch;
	}
	// 829A9FB4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829A9FB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9FBC: 419A0008  beq cr6, 0x829a9fc4
	if ctx.cr[6].eq {
	pc = 0x829A9FC4; continue 'dispatch;
	}
	// 829A9FC0: 4B9168D1  bl 0x822c0890
	ctx.lr = 0x829A9FC4;
	sub_822C0890(ctx, base);
	// 829A9FC4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829A9FC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829A9FCC: 419A0008  beq cr6, 0x829a9fd4
	if ctx.cr[6].eq {
	pc = 0x829A9FD4; continue 'dispatch;
	}
	// 829A9FD0: 4B9168C1  bl 0x822c0890
	ctx.lr = 0x829A9FD4;
	sub_822C0890(ctx, base);
	// 829A9FD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829A9FD8: 419A000C  beq cr6, 0x829a9fe4
	if ctx.cr[6].eq {
	pc = 0x829A9FE4; continue 'dispatch;
	}
	// 829A9FDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829A9FE0: 4B9168B1  bl 0x822c0890
	ctx.lr = 0x829A9FE4;
	sub_822C0890(ctx, base);
	// 829A9FE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829A9FE8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829A9FEC: 487FE1C8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829A9FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829A9FF0 size=128
    let mut pc: u32 = 0x829A9FF0;
    'dispatch: loop {
        match pc {
            0x829A9FF0 => {
    //   block [0x829A9FF0..0x829AA070)
	// 829A9FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829A9FF4: 487FE179  bl 0x831a816c
	ctx.lr = 0x829A9FF8;
	sub_831A8130(ctx, base);
	// 829A9FF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829A9FFC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829AA000: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829AA004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829AA008: 3BEBCB0C  addi r31, r11, -0x34f4
	ctx.r[31].s64 = ctx.r[11].s64 + -13556;
	// 829AA00C: 816ACB14  lwz r11, -0x34ec(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13548 as u32) ) } as u64;
	// 829AA010: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829AA014: 40820024  bne 0x829aa038
	if !ctx.cr[0].eq {
	pc = 0x829AA038; continue 'dispatch;
	}
	// 829AA018: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829AA01C: 3D00829A  lis r8, -0x7d66
	ctx.r[8].s64 = -2103836672;
	// 829AA020: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829AA024: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829AA028: 390854D0  addi r8, r8, 0x54d0
	ctx.r[8].s64 = ctx.r[8].s64 + 21712;
	// 829AA02C: 916ACB14  stw r11, -0x34ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13548 as u32), ctx.r[11].u32 ) };
	// 829AA030: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829AA034: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829AA038: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829AA03C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829AA040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA044: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829AA048: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829AA04C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AA050: 4BCAA571  bl 0x826545c0
	ctx.lr = 0x829AA054;
	sub_826545C0(ctx, base);
	// 829AA054: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AA058: 4182000C  beq 0x829aa064
	if ctx.cr[0].eq {
	pc = 0x829AA064; continue 'dispatch;
	}
	// 829AA05C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829AA060: 48000008  b 0x829aa068
	pc = 0x829AA068; continue 'dispatch;
	// 829AA064: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829AA068: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829AA06C: 487FE150  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829AA070 size=128
    let mut pc: u32 = 0x829AA070;
    'dispatch: loop {
        match pc {
            0x829AA070 => {
    //   block [0x829AA070..0x829AA0F0)
	// 829AA070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA074: 487FE0F9  bl 0x831a816c
	ctx.lr = 0x829AA078;
	sub_831A8130(ctx, base);
	// 829AA078: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA07C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829AA080: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829AA084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829AA088: 3BEBCB18  addi r31, r11, -0x34e8
	ctx.r[31].s64 = ctx.r[11].s64 + -13544;
	// 829AA08C: 816ACB20  lwz r11, -0x34e0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13536 as u32) ) } as u64;
	// 829AA090: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829AA094: 40820024  bne 0x829aa0b8
	if !ctx.cr[0].eq {
	pc = 0x829AA0B8; continue 'dispatch;
	}
	// 829AA098: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829AA09C: 3D00829A  lis r8, -0x7d66
	ctx.r[8].s64 = -2103836672;
	// 829AA0A0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829AA0A4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829AA0A8: 39085518  addi r8, r8, 0x5518
	ctx.r[8].s64 = ctx.r[8].s64 + 21784;
	// 829AA0AC: 916ACB20  stw r11, -0x34e0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13536 as u32), ctx.r[11].u32 ) };
	// 829AA0B0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829AA0B4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829AA0B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829AA0BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829AA0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA0C4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829AA0C8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829AA0CC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AA0D0: 4BCAA4F1  bl 0x826545c0
	ctx.lr = 0x829AA0D4;
	sub_826545C0(ctx, base);
	// 829AA0D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AA0D8: 4182000C  beq 0x829aa0e4
	if ctx.cr[0].eq {
	pc = 0x829AA0E4; continue 'dispatch;
	}
	// 829AA0DC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829AA0E0: 48000008  b 0x829aa0e8
	pc = 0x829AA0E8; continue 'dispatch;
	// 829AA0E4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829AA0E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829AA0EC: 487FE0D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829AA0F0 size=176
    let mut pc: u32 = 0x829AA0F0;
    'dispatch: loop {
        match pc {
            0x829AA0F0 => {
    //   block [0x829AA0F0..0x829AA1A0)
	// 829AA0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA0F4: 487FE079  bl 0x831a816c
	ctx.lr = 0x829AA0F8;
	sub_831A8130(ctx, base);
	// 829AA0F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA0FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AA100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AA104: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829AA108: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AA10C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AA110: 38A00570  li r5, 0x570
	ctx.r[5].s64 = 1392;
	// 829AA114: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829AA118: 484482D1  bl 0x82df23e8
	ctx.lr = 0x829AA11C;
	sub_82DF23E8(ctx, base);
	// 829AA11C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA120: 41820010  beq 0x829aa130
	if ctx.cr[0].eq {
	pc = 0x829AA130; continue 'dispatch;
	}
	// 829AA124: 4BC52E4D  bl 0x825fcf70
	ctx.lr = 0x829AA128;
	sub_825FCF70(ctx, base);
	// 829AA128: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA12C: 48000008  b 0x829aa134
	pc = 0x829AA134; continue 'dispatch;
	// 829AA130: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AA134: 3BDF0194  addi r30, r31, 0x194
	ctx.r[30].s64 = ctx.r[31].s64 + 404;
	// 829AA138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA13C: 4BC516BD  bl 0x825fb7f8
	ctx.lr = 0x829AA140;
	sub_825FB7F8(ctx, base);
	// 829AA140: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AA144: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA148: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829AA14C: 4846C6F5  bl 0x82e16840
	ctx.lr = 0x829AA150;
	sub_82E16840(ctx, base);
	// 829AA150: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA154: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 829AA158: 4846D209  bl 0x82e17360
	ctx.lr = 0x829AA15C;
	sub_82E17360(ctx, base);
	// 829AA15C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829AA164: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 829AA168: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 829AA16C: 4844F3C5  bl 0x82df9530
	ctx.lr = 0x829AA170;
	sub_82DF9530(ctx, base);
	// 829AA170: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AA174: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829AA178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA17C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA180: 4846D5C9  bl 0x82e17748
	ctx.lr = 0x829AA184;
	sub_82E17748(ctx, base);
	// 829AA184: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AA188: 809F019C  lwz r4, 0x19c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 829AA18C: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 829AA190: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AA194: 484946A5  bl 0x82e3e838
	ctx.lr = 0x829AA198;
	sub_82E3E838(ctx, base);
	// 829AA198: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829AA19C: 487FE020  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829AA1A0 size=176
    let mut pc: u32 = 0x829AA1A0;
    'dispatch: loop {
        match pc {
            0x829AA1A0 => {
    //   block [0x829AA1A0..0x829AA250)
	// 829AA1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA1A4: 487FDFC9  bl 0x831a816c
	ctx.lr = 0x829AA1A8;
	sub_831A8130(ctx, base);
	// 829AA1A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA1AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AA1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AA1B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829AA1B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AA1BC: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AA1C0: 38A0057E  li r5, 0x57e
	ctx.r[5].s64 = 1406;
	// 829AA1C4: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829AA1C8: 48448221  bl 0x82df23e8
	ctx.lr = 0x829AA1CC;
	sub_82DF23E8(ctx, base);
	// 829AA1CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA1D0: 41820010  beq 0x829aa1e0
	if ctx.cr[0].eq {
	pc = 0x829AA1E0; continue 'dispatch;
	}
	// 829AA1D4: 4BC52D9D  bl 0x825fcf70
	ctx.lr = 0x829AA1D8;
	sub_825FCF70(ctx, base);
	// 829AA1D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA1DC: 48000008  b 0x829aa1e4
	pc = 0x829AA1E4; continue 'dispatch;
	// 829AA1E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AA1E4: 3BDF01A8  addi r30, r31, 0x1a8
	ctx.r[30].s64 = ctx.r[31].s64 + 424;
	// 829AA1E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA1EC: 4BC5160D  bl 0x825fb7f8
	ctx.lr = 0x829AA1F0;
	sub_825FB7F8(ctx, base);
	// 829AA1F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AA1F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA1F8: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829AA1FC: 4846C645  bl 0x82e16840
	ctx.lr = 0x829AA200;
	sub_82E16840(ctx, base);
	// 829AA200: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA204: 807F01A8  lwz r3, 0x1a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 829AA208: 4846D159  bl 0x82e17360
	ctx.lr = 0x829AA20C;
	sub_82E17360(ctx, base);
	// 829AA20C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829AA214: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 829AA218: 83DF01A8  lwz r30, 0x1a8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 829AA21C: 4844F315  bl 0x82df9530
	ctx.lr = 0x829AA220;
	sub_82DF9530(ctx, base);
	// 829AA220: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AA224: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829AA228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA22C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA230: 4846D519  bl 0x82e17748
	ctx.lr = 0x829AA234;
	sub_82E17748(ctx, base);
	// 829AA234: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AA238: 809F01B0  lwz r4, 0x1b0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 829AA23C: 807F01A8  lwz r3, 0x1a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 829AA240: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AA244: 484945F5  bl 0x82e3e838
	ctx.lr = 0x829AA248;
	sub_82E3E838(ctx, base);
	// 829AA248: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829AA24C: 487FDF70  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829AA250 size=176
    let mut pc: u32 = 0x829AA250;
    'dispatch: loop {
        match pc {
            0x829AA250 => {
    //   block [0x829AA250..0x829AA300)
	// 829AA250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA254: 487FDF19  bl 0x831a816c
	ctx.lr = 0x829AA258;
	sub_831A8130(ctx, base);
	// 829AA258: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA25C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AA260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AA264: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829AA268: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AA26C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AA270: 38A0058C  li r5, 0x58c
	ctx.r[5].s64 = 1420;
	// 829AA274: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829AA278: 48448171  bl 0x82df23e8
	ctx.lr = 0x829AA27C;
	sub_82DF23E8(ctx, base);
	// 829AA27C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA280: 41820010  beq 0x829aa290
	if ctx.cr[0].eq {
	pc = 0x829AA290; continue 'dispatch;
	}
	// 829AA284: 4BC52CED  bl 0x825fcf70
	ctx.lr = 0x829AA288;
	sub_825FCF70(ctx, base);
	// 829AA288: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA28C: 48000008  b 0x829aa294
	pc = 0x829AA294; continue 'dispatch;
	// 829AA290: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AA294: 3BDF039C  addi r30, r31, 0x39c
	ctx.r[30].s64 = ctx.r[31].s64 + 924;
	// 829AA298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA29C: 4BC5155D  bl 0x825fb7f8
	ctx.lr = 0x829AA2A0;
	sub_825FB7F8(ctx, base);
	// 829AA2A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AA2A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA2A8: 807F038C  lwz r3, 0x38c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 829AA2AC: 4846C595  bl 0x82e16840
	ctx.lr = 0x829AA2B0;
	sub_82E16840(ctx, base);
	// 829AA2B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA2B4: 807F039C  lwz r3, 0x39c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 829AA2B8: 4846D0A9  bl 0x82e17360
	ctx.lr = 0x829AA2BC;
	sub_82E17360(ctx, base);
	// 829AA2BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA2C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829AA2C4: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 829AA2C8: 83DF039C  lwz r30, 0x39c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 829AA2CC: 4844F265  bl 0x82df9530
	ctx.lr = 0x829AA2D0;
	sub_82DF9530(ctx, base);
	// 829AA2D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AA2D4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829AA2D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA2DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA2E0: 4846D469  bl 0x82e17748
	ctx.lr = 0x829AA2E4;
	sub_82E17748(ctx, base);
	// 829AA2E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AA2E8: 809F0394  lwz r4, 0x394(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 829AA2EC: 807F039C  lwz r3, 0x39c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 829AA2F0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AA2F4: 48494545  bl 0x82e3e838
	ctx.lr = 0x829AA2F8;
	sub_82E3E838(ctx, base);
	// 829AA2F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829AA2FC: 487FDEC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829AA300 size=176
    let mut pc: u32 = 0x829AA300;
    'dispatch: loop {
        match pc {
            0x829AA300 => {
    //   block [0x829AA300..0x829AA3B0)
	// 829AA300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA304: 487FDE69  bl 0x831a816c
	ctx.lr = 0x829AA308;
	sub_831A8130(ctx, base);
	// 829AA308: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA30C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AA310: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AA314: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829AA318: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AA31C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AA320: 38A00562  li r5, 0x562
	ctx.r[5].s64 = 1378;
	// 829AA324: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829AA328: 484480C1  bl 0x82df23e8
	ctx.lr = 0x829AA32C;
	sub_82DF23E8(ctx, base);
	// 829AA32C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA330: 41820010  beq 0x829aa340
	if ctx.cr[0].eq {
	pc = 0x829AA340; continue 'dispatch;
	}
	// 829AA334: 4BC52C3D  bl 0x825fcf70
	ctx.lr = 0x829AA338;
	sub_825FCF70(ctx, base);
	// 829AA338: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA33C: 48000008  b 0x829aa344
	pc = 0x829AA344; continue 'dispatch;
	// 829AA340: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AA344: 3BDF0180  addi r30, r31, 0x180
	ctx.r[30].s64 = ctx.r[31].s64 + 384;
	// 829AA348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA34C: 4BC514AD  bl 0x825fb7f8
	ctx.lr = 0x829AA350;
	sub_825FB7F8(ctx, base);
	// 829AA350: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AA354: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA358: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829AA35C: 4846C4E5  bl 0x82e16840
	ctx.lr = 0x829AA360;
	sub_82E16840(ctx, base);
	// 829AA360: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829AA364: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 829AA368: 4846CFF9  bl 0x82e17360
	ctx.lr = 0x829AA36C;
	sub_82E17360(ctx, base);
	// 829AA36C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829AA374: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 829AA378: 83DF0180  lwz r30, 0x180(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 829AA37C: 4844F1B5  bl 0x82df9530
	ctx.lr = 0x829AA380;
	sub_82DF9530(ctx, base);
	// 829AA380: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AA384: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829AA388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA38C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA390: 4846D3B9  bl 0x82e17748
	ctx.lr = 0x829AA394;
	sub_82E17748(ctx, base);
	// 829AA394: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AA398: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 829AA39C: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 829AA3A0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AA3A4: 48494495  bl 0x82e3e838
	ctx.lr = 0x829AA3A8;
	sub_82E3E838(ctx, base);
	// 829AA3A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829AA3AC: 487FDE10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829AA3B0 size=84
    let mut pc: u32 = 0x829AA3B0;
    'dispatch: loop {
        match pc {
            0x829AA3B0 => {
    //   block [0x829AA3B0..0x829AA404)
	// 829AA3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829AA3B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829AA3BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA3C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AA3C4: 48014195  bl 0x829be558
	ctx.lr = 0x829AA3C8;
	sub_829BE558(ctx, base);
	// 829AA3C8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AA3CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829AA3D0: 394A1BB8  addi r10, r10, 0x1bb8
	ctx.r[10].s64 = ctx.r[10].s64 + 7096;
	// 829AA3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA3D8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829AA3DC: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 829AA3E0: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 829AA3E4: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 829AA3E8: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 829AA3EC: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 829AA3F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829AA3F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829AA3F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829AA3FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829AA400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829AA408 size=104
    let mut pc: u32 = 0x829AA408;
    'dispatch: loop {
        match pc {
            0x829AA408 => {
    //   block [0x829AA408..0x829AA470)
	// 829AA408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA40C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829AA410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829AA414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829AA418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AA420: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829AA424: 807F01D4  lwz r3, 0x1d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 829AA428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA42C: 419A0008  beq cr6, 0x829aa434
	if ctx.cr[6].eq {
	pc = 0x829AA434; continue 'dispatch;
	}
	// 829AA430: 4B916461  bl 0x822c0890
	ctx.lr = 0x829AA434;
	sub_822C0890(ctx, base);
	// 829AA434: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 829AA438: 4BB06E69  bl 0x824b12a0
	ctx.lr = 0x829AA43C;
	sub_824B12A0(ctx, base);
	// 829AA43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA440: 484B2149  bl 0x82e5c588
	ctx.lr = 0x829AA444;
	sub_82E5C588(ctx, base);
	// 829AA444: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AA448: 4182000C  beq 0x829aa454
	if ctx.cr[0].eq {
	pc = 0x829AA454; continue 'dispatch;
	}
	// 829AA44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA450: 48447F89  bl 0x82df23d8
	ctx.lr = 0x829AA454;
	sub_82DF23D8(ctx, base);
	// 829AA454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA458: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829AA45C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829AA460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829AA464: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829AA468: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829AA46C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AA470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829AA470 size=3364
    let mut pc: u32 = 0x829AA470;
    'dispatch: loop {
        match pc {
            0x829AA470 => {
    //   block [0x829AA470..0x829AB194)
	// 829AA470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AA474: 487FDCE9  bl 0x831a815c
	ctx.lr = 0x829AA478;
	sub_831A8130(ctx, base);
	// 829AA478: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 829AA47C: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 829AA480: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829AA484: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AA488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AA48C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AA490: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 829AA494: C01F03D0  lfs f0, 0x3d0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AA498: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829AA49C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829AA4A0: 41990CE0  bgt cr6, 0x829ab180
	if ctx.cr[6].gt {
	pc = 0x829AB180; continue 'dispatch;
	}
	// 829AA4A4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829AA4A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829AA4AC: 808B8640  lwz r4, -0x79c0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31168 as u32) ) } as u64;
	// 829AA4B0: 4B982279  bl 0x8232c728
	ctx.lr = 0x829AA4B4;
	sub_8232C728(ctx, base);
	// 829AA4B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AA4B8: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829AA4BC: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 829AA4C0: 4BE0FEB1  bl 0x827ba370
	ctx.lr = 0x829AA4C4;
	sub_827BA370(ctx, base);
	// 829AA4C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA4C8: 80790018  lwz r3, 0x18(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 829AA4CC: 4BE0FA6D  bl 0x827b9f38
	ctx.lr = 0x829AA4D0;
	sub_827B9F38(ctx, base);
	// 829AA4D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AA4D4: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829AA4D8: 3B4B1A70  addi r26, r11, 0x1a70
	ctx.r[26].s64 = ctx.r[11].s64 + 6768;
	// 829AA4DC: 418207F0  beq 0x829aaccc
	if ctx.cr[0].eq {
	pc = 0x829AACCC; continue 'dispatch;
	}
	// 829AA4E0: 897F03A8  lbz r11, 0x3a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 829AA4E4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829AA4E8: 895F03B4  lbz r10, 0x3b4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AA4EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA4F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829AA4F4: 3BAB7F41  addi r29, r11, 0x7f41
	ctx.r[29].s64 = ctx.r[11].s64 + 32577;
	// 829AA4F8: 897DFFFF  lbz r11, -1(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(-1 as u32) ) } as u64;
	// 829AA4FC: 41820480  beq 0x829aa97c
	if ctx.cr[0].eq {
	pc = 0x829AA97C; continue 'dispatch;
	}
	// 829AA500: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829AA504: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829AA508: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 829AA50C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829AA510: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AA514: 997F03B4  stb r11, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[11].u8 ) };
	// 829AA518: 418100F8  bgt 0x829aa610
	if ctx.cr[0].gt {
	pc = 0x829AA610; continue 'dispatch;
	}
	// 829AA51C: A17F03BC  lhz r11, 0x3bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 829AA520: 9B7F03B4  stb r27, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[27].u8 ) };
	// 829AA524: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 829AA528: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA52C: B15F03BC  sth r10, 0x3bc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[10].u16 ) };
	// 829AA530: 408200E0  bne 0x829aa610
	if !ctx.cr[0].eq {
	pc = 0x829AA610; continue 'dispatch;
	}
	// 829AA534: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AA538: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AA53C: 38A00E52  li r5, 0xe52
	ctx.r[5].s64 = 3666;
	// 829AA540: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829AA544: 48447EA5  bl 0x82df23e8
	ctx.lr = 0x829AA548;
	sub_82DF23E8(ctx, base);
	// 829AA548: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829AA54C: 4182001C  beq 0x829aa568
	if ctx.cr[0].eq {
	pc = 0x829AA568; continue 'dispatch;
	}
	// 829AA550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA554: 484B23D5  bl 0x82e5c928
	ctx.lr = 0x829AA558;
	sub_82E5C928(ctx, base);
	// 829AA558: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AA55C: 396B162C  addi r11, r11, 0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + 5676;
	// 829AA560: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AA564: 48000008  b 0x829aa56c
	pc = 0x829AA56C; continue 'dispatch;
	// 829AA568: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829AA56C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829AA570: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AA574: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AA578: 4BFFA409  bl 0x829a4980
	ctx.lr = 0x829AA57C;
	sub_829A4980(ctx, base);
	// 829AA57C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AA580: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AA584: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AA588: 4B915A79  bl 0x822c0000
	ctx.lr = 0x829AA58C;
	sub_822C0000(ctx, base);
	// 829AA58C: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829AA590: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829AA594: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AA598: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 829AA59C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 829AA5A0: 419A0024  beq cr6, 0x829aa5c4
	if ctx.cr[6].eq {
	pc = 0x829AA5C4; continue 'dispatch;
	}
	// 829AA5A4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829AA5A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AA5AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AA5B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AA5B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AA5B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AA5BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AA5C0: 4082FFE8  bne 0x829aa5a8
	if !ctx.cr[0].eq {
	pc = 0x829AA5A8; continue 'dispatch;
	}
	// 829AA5C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AA5C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829AA5CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AA5D0: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 829AA5D4: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 829AA5D8: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 829AA5DC: 484B40CD  bl 0x82e5e6a8
	ctx.lr = 0x829AA5E0;
	sub_82E5E6A8(ctx, base);
	// 829AA5E0: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 829AA5E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA5E8: 419A0008  beq cr6, 0x829aa5f0
	if ctx.cr[6].eq {
	pc = 0x829AA5F0; continue 'dispatch;
	}
	// 829AA5EC: 4B9162A5  bl 0x822c0890
	ctx.lr = 0x829AA5F0;
	sub_822C0890(ctx, base);
	// 829AA5F0: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829AA5F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA5F8: 419A0008  beq cr6, 0x829aa600
	if ctx.cr[6].eq {
	pc = 0x829AA600; continue 'dispatch;
	}
	// 829AA5FC: 4B916295  bl 0x822c0890
	ctx.lr = 0x829AA600;
	sub_822C0890(ctx, base);
	// 829AA600: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AA604: 419A000C  beq cr6, 0x829aa610
	if ctx.cr[6].eq {
	pc = 0x829AA610; continue 'dispatch;
	}
	// 829AA608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA60C: 4B916285  bl 0x822c0890
	ctx.lr = 0x829AA610;
	sub_822C0890(ctx, base);
	// 829AA610: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AA614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA618: 4BFFA751  bl 0x829a4d68
	ctx.lr = 0x829AA61C;
	sub_829A4D68(ctx, base);
	// 829AA61C: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AA620: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829AA624: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829AA628: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 829AA62C: 4098000C  bge cr6, 0x829aa638
	if !ctx.cr[6].lt {
	pc = 0x829AA638; continue 'dispatch;
	}
	// 829AA630: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 829AA634: 4800001C  b 0x829aa650
	pc = 0x829AA650; continue 'dispatch;
	// 829AA638: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AA63C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829AA640: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829AA644: 2F0B0046  cmpwi cr6, r11, 0x46
	ctx.cr[6].compare_i32(ctx.r[11].s32, 70, &mut ctx.xer);
	// 829AA648: 41980008  blt cr6, 0x829aa650
	if ctx.cr[6].lt {
	pc = 0x829AA650; continue 'dispatch;
	}
	// 829AA64C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 829AA650: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829AA654: C01F03C0  lfs f0, 0x3c0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AA658: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA65C: 3929133C  addi r9, r9, 0x133c
	ctx.r[9].s64 = ctx.r[9].s64 + 4924;
	// 829AA660: 396B9450  addi r11, r11, -0x6bb0
	ctx.r[11].s64 = ctx.r[11].s64 + -27568;
	// 829AA664: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 829AA668: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829AA66C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829AA670: C3AB0000  lfs f29, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829AA674: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 829AA678: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829AA67C: C3C808A8  lfs f30, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829AA680: D1BF03AC  stfs f13, 0x3ac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 829AA684: 41980010  blt cr6, 0x829aa694
	if ctx.cr[6].lt {
	pc = 0x829AA694; continue 'dispatch;
	}
	// 829AA688: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 829AA68C: D01F03C0  stfs f0, 0x3c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), tmp.u32 ) };
	// 829AA690: 48000008  b 0x829aa698
	pc = 0x829AA698; continue 'dispatch;
	// 829AA694: D3FF03C0  stfs f31, 0x3c0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), tmp.u32 ) };
	// 829AA698: 9B9F03C4  stb r28, 0x3c4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[28].u8 ) };
	// 829AA69C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AA6A0: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 829AA6A4: 4BB64E25  bl 0x8250f4c8
	ctx.lr = 0x829AA6A8;
	sub_8250F4C8(ctx, base);
	// 829AA6A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA6AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829AA6B0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829AA6B4: 409A0008  bne cr6, 0x829aa6bc
	if !ctx.cr[6].eq {
	pc = 0x829AA6BC; continue 'dispatch;
	}
	// 829AA6B8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829AA6BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AA6C0: 4BB5E359  bl 0x82508a18
	ctx.lr = 0x829AA6C4;
	sub_82508A18(ctx, base);
	// 829AA6C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829AA6C8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829AA6CC: 4865DA5D  bl 0x83008128
	ctx.lr = 0x829AA6D0;
	sub_83008128(ctx, base);
	// 829AA6D0: 7D7E1850  subf r11, r30, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 829AA6D4: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 829AA6D8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829AA6DC: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829AA6E0: 484475B1  bl 0x82df1c90
	ctx.lr = 0x829AA6E4;
	sub_82DF1C90(ctx, base);
	// 829AA6E4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA6E8: 41820140  beq 0x829aa828
	if ctx.cr[0].eq {
	pc = 0x829AA828; continue 'dispatch;
	}
	// 829AA6EC: 897F03D9  lbz r11, 0x3d9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(985 as u32) ) } as u64;
	// 829AA6F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829AA6F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829AA6F8: 41980010  blt cr6, 0x829aa708
	if ctx.cr[6].lt {
	pc = 0x829AA708; continue 'dispatch;
	}
	// 829AA6FC: 419A0178  beq cr6, 0x829aa874
	if ctx.cr[6].eq {
	pc = 0x829AA874; continue 'dispatch;
	}
	// 829AA700: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829AA704: 40980124  bge cr6, 0x829aa828
	if !ctx.cr[6].lt {
	pc = 0x829AA828; continue 'dispatch;
	}
	// 829AA708: 817D001B  lwz r11, 0x1b(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27 as u32) ) } as u64;
	// 829AA70C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AA710: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 829AA714: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829AA718: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 829AA71C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829AA720: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AA724: D01F0414  stfs f0, 0x414(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1044 as u32), tmp.u32 ) };
	// 829AA728: 4BB679F1  bl 0x82512118
	ctx.lr = 0x829AA72C;
	sub_82512118(ctx, base);
	// 829AA72C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA730: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA734: D3E100E0  stfs f31, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 829AA738: D3E100E4  stfs f31, 0xe4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 829AA73C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829AA740: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 829AA744: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 829AA748: 3B8100E0  addi r28, r1, 0xe0
	ctx.r[28].s64 = ctx.r[1].s64 + 224;
	// 829AA74C: C00BD0B0  lfs f0, -0x2f50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AA750: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 829AA754: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA758: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829AA75C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829AA760: 4E800421  bctrl
	ctx.lr = 0x829AA764;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829AA764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA768: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 829AA76C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829AA770: 484D15D9  bl 0x82e7bd48
	ctx.lr = 0x829AA774;
	sub_82E7BD48(ctx, base);
	// 829AA774: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829AA778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA77C: 4BB6736D  bl 0x82511ae8
	ctx.lr = 0x829AA780;
	sub_82511AE8(ctx, base);
	// 829AA780: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA784: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 829AA788: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829AA78C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829AA790: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829AA794: 4BDC2EFD  bl 0x8276d690
	ctx.lr = 0x829AA798;
	sub_8276D690(ctx, base);
	// 829AA798: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA79C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 829AA7A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829AA7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829AA7A8: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 829AA7AC: 419A0024  beq cr6, 0x829aa7d0
	if ctx.cr[6].eq {
	pc = 0x829AA7D0; continue 'dispatch;
	}
	// 829AA7B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829AA7B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AA7B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AA7BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AA7C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AA7C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AA7C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AA7CC: 4082FFE8  bne 0x829aa7b4
	if !ctx.cr[0].eq {
	pc = 0x829AA7B4; continue 'dispatch;
	}
	// 829AA7D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829AA7D4: 3BC100A0  addi r30, r1, 0xa0
	ctx.r[30].s64 = ctx.r[1].s64 + 160;
	// 829AA7D8: 4865D951  bl 0x83008128
	ctx.lr = 0x829AA7DC;
	sub_83008128(ctx, base);
	// 829AA7DC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829AA7E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AA7E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829AA7E8: 38A00E84  li r5, 0xe84
	ctx.r[5].s64 = 3716;
	// 829AA7EC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829AA7F0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829AA7F4: 484AE24D  bl 0x82e58a40
	ctx.lr = 0x829AA7F8;
	sub_82E58A40(ctx, base);
	// 829AA7F8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829AA7FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA800: 419A0008  beq cr6, 0x829aa808
	if ctx.cr[6].eq {
	pc = 0x829AA808; continue 'dispatch;
	}
	// 829AA804: 4B91608D  bl 0x822c0890
	ctx.lr = 0x829AA808;
	sub_822C0890(ctx, base);
	// 829AA808: 8061016C  lwz r3, 0x16c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 829AA80C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA810: 419A0008  beq cr6, 0x829aa818
	if ctx.cr[6].eq {
	pc = 0x829AA818; continue 'dispatch;
	}
	// 829AA814: 4B91607D  bl 0x822c0890
	ctx.lr = 0x829AA818;
	sub_822C0890(ctx, base);
	// 829AA818: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 829AA81C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA820: 419A0008  beq cr6, 0x829aa828
	if ctx.cr[6].eq {
	pc = 0x829AA828; continue 'dispatch;
	}
	// 829AA824: 4B91606D  bl 0x822c0890
	ctx.lr = 0x829AA828;
	sub_822C0890(ctx, base);
	// 829AA828: D3DF0468  stfs f30, 0x468(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1128 as u32), tmp.u32 ) };
	// 829AA82C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829AA830: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829AA834: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829AA838: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 829AA83C: 484473BD  bl 0x82df1bf8
	ctx.lr = 0x829AA840;
	sub_82DF1BF8(ctx, base);
	// 829AA840: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829AA848: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 829AA84C: 388B13BC  addi r4, r11, 0x13bc
	ctx.r[4].s64 = ctx.r[11].s64 + 5052;
	// 829AA850: 4844ECE1  bl 0x82df9530
	ctx.lr = 0x829AA854;
	sub_82DF9530(ctx, base);
	// 829AA854: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829AA858: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA85C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA860: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA864: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AA868: 4BB7BBE9  bl 0x82526450
	ctx.lr = 0x829AA86C;
	sub_82526450(ctx, base);
	// 829AA86C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829AA870: 48000450  b 0x829aacc0
	pc = 0x829AACC0; continue 'dispatch;
	// 829AA874: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AA878: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829AA87C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 829AA880: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 829AA884: 4BB67895  bl 0x82512118
	ctx.lr = 0x829AA888;
	sub_82512118(ctx, base);
	// 829AA888: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AA88C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA890: D3E100D0  stfs f31, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 829AA894: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 829AA898: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829AA89C: D3E100DC  stfs f31, 0xdc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 829AA8A0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 829AA8A4: 3B8100D0  addi r28, r1, 0xd0
	ctx.r[28].s64 = ctx.r[1].s64 + 208;
	// 829AA8A8: C00BD0B0  lfs f0, -0x2f50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AA8AC: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 829AA8B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA8B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829AA8B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829AA8BC: 4E800421  bctrl
	ctx.lr = 0x829AA8C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829AA8C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA8C4: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 829AA8C8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829AA8CC: 484D147D  bl 0x82e7bd48
	ctx.lr = 0x829AA8D0;
	sub_82E7BD48(ctx, base);
	// 829AA8D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829AA8D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AA8D8: 4BB67211  bl 0x82511ae8
	ctx.lr = 0x829AA8DC;
	sub_82511AE8(ctx, base);
	// 829AA8DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AA8E0: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 829AA8E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829AA8E8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829AA8EC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829AA8F0: 4BDC2DA1  bl 0x8276d690
	ctx.lr = 0x829AA8F4;
	sub_8276D690(ctx, base);
	// 829AA8F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AA8F8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 829AA8FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829AA900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829AA904: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 829AA908: 419A0024  beq cr6, 0x829aa92c
	if ctx.cr[6].eq {
	pc = 0x829AA92C; continue 'dispatch;
	}
	// 829AA90C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829AA910: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AA914: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AA918: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AA91C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AA920: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AA924: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AA928: 4082FFE8  bne 0x829aa910
	if !ctx.cr[0].eq {
	pc = 0x829AA910; continue 'dispatch;
	}
	// 829AA92C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829AA930: 3BC10088  addi r30, r1, 0x88
	ctx.r[30].s64 = ctx.r[1].s64 + 136;
	// 829AA934: 4865D7F5  bl 0x83008128
	ctx.lr = 0x829AA938;
	sub_83008128(ctx, base);
	// 829AA938: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829AA93C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AA940: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829AA944: 38A00E73  li r5, 0xe73
	ctx.r[5].s64 = 3699;
	// 829AA948: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829AA94C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829AA950: 484AE0F1  bl 0x82e58a40
	ctx.lr = 0x829AA954;
	sub_82E58A40(ctx, base);
	// 829AA954: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829AA958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA95C: 419A0008  beq cr6, 0x829aa964
	if ctx.cr[6].eq {
	pc = 0x829AA964; continue 'dispatch;
	}
	// 829AA960: 4B915F31  bl 0x822c0890
	ctx.lr = 0x829AA964;
	sub_822C0890(ctx, base);
	// 829AA964: 8061014C  lwz r3, 0x14c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 829AA968: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AA96C: 419A0008  beq cr6, 0x829aa974
	if ctx.cr[6].eq {
	pc = 0x829AA974; continue 'dispatch;
	}
	// 829AA970: 4B915F21  bl 0x822c0890
	ctx.lr = 0x829AA974;
	sub_822C0890(ctx, base);
	// 829AA974: 8061015C  lwz r3, 0x15c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 829AA978: 4BFFFEA4  b 0x829aa81c
	pc = 0x829AA81C; continue 'dispatch;
	// 829AA97C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829AA980: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AA984: 997F03B4  stb r11, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[11].u8 ) };
	// 829AA988: 41810008  bgt 0x829aa990
	if ctx.cr[0].gt {
	pc = 0x829AA990; continue 'dispatch;
	}
	// 829AA98C: 9B7F03B4  stb r27, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[27].u8 ) };
	// 829AA990: D3FF03AC  stfs f31, 0x3ac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 829AA994: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829AA998: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 829AA99C: 484D6DA5  bl 0x82e81740
	ctx.lr = 0x829AA9A0;
	sub_82E81740(ctx, base);
	// 829AA9A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829AA9A4: 807F0244  lwz r3, 0x244(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 829AA9A8: 484D6D99  bl 0x82e81740
	ctx.lr = 0x829AA9AC;
	sub_82E81740(ctx, base);
	// 829AA9AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829AA9B0: 807F024C  lwz r3, 0x24c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 829AA9B4: 484D6D8D  bl 0x82e81740
	ctx.lr = 0x829AA9B8;
	sub_82E81740(ctx, base);
	// 829AA9B8: A17F03BC  lhz r11, 0x3bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 829AA9BC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 829AA9C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AA9C4: B15F03BC  sth r10, 0x3bc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[10].u16 ) };
	// 829AA9C8: 408200E0  bne 0x829aaaa8
	if !ctx.cr[0].eq {
	pc = 0x829AAAA8; continue 'dispatch;
	}
	// 829AA9CC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AA9D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AA9D4: 38A00EA7  li r5, 0xea7
	ctx.r[5].s64 = 3751;
	// 829AA9D8: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829AA9DC: 48447A0D  bl 0x82df23e8
	ctx.lr = 0x829AA9E0;
	sub_82DF23E8(ctx, base);
	// 829AA9E0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829AA9E4: 4182001C  beq 0x829aaa00
	if ctx.cr[0].eq {
	pc = 0x829AAA00; continue 'dispatch;
	}
	// 829AA9E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AA9EC: 484B1F3D  bl 0x82e5c928
	ctx.lr = 0x829AA9F0;
	sub_82E5C928(ctx, base);
	// 829AA9F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AA9F4: 396B162C  addi r11, r11, 0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + 5676;
	// 829AA9F8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AA9FC: 48000008  b 0x829aaa04
	pc = 0x829AAA04; continue 'dispatch;
	// 829AAA00: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829AAA04: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829AAA08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AAA0C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AAA10: 4BFF9F71  bl 0x829a4980
	ctx.lr = 0x829AAA14;
	sub_829A4980(ctx, base);
	// 829AAA14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AAA18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AAA1C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AAA20: 4B9155E1  bl 0x822c0000
	ctx.lr = 0x829AAA24;
	sub_822C0000(ctx, base);
	// 829AAA24: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829AAA28: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829AAA2C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AAA30: 93C100B4  stw r30, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 829AAA34: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 829AAA38: 419A0024  beq cr6, 0x829aaa5c
	if ctx.cr[6].eq {
	pc = 0x829AAA5C; continue 'dispatch;
	}
	// 829AAA3C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829AAA40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AAA44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AAA48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AAA4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AAA50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AAA54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AAA58: 4082FFE8  bne 0x829aaa40
	if !ctx.cr[0].eq {
	pc = 0x829AAA40; continue 'dispatch;
	}
	// 829AAA5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AAA60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829AAA64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AAA68: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829AAA6C: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 829AAA70: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 829AAA74: 484B3C35  bl 0x82e5e6a8
	ctx.lr = 0x829AAA78;
	sub_82E5E6A8(ctx, base);
	// 829AAA78: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 829AAA7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AAA80: 419A0008  beq cr6, 0x829aaa88
	if ctx.cr[6].eq {
	pc = 0x829AAA88; continue 'dispatch;
	}
	// 829AAA84: 4B915E0D  bl 0x822c0890
	ctx.lr = 0x829AAA88;
	sub_822C0890(ctx, base);
	// 829AAA88: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 829AAA8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AAA90: 419A0008  beq cr6, 0x829aaa98
	if ctx.cr[6].eq {
	pc = 0x829AAA98; continue 'dispatch;
	}
	// 829AAA94: 4B915DFD  bl 0x822c0890
	ctx.lr = 0x829AAA98;
	sub_822C0890(ctx, base);
	// 829AAA98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AAA9C: 419A000C  beq cr6, 0x829aaaa8
	if ctx.cr[6].eq {
	pc = 0x829AAAA8; continue 'dispatch;
	}
	// 829AAAA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AAAA4: 4B915DED  bl 0x822c0890
	ctx.lr = 0x829AAAA8;
	sub_822C0890(ctx, base);
	// 829AAAA8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 829AAAAC: 4BB3FFDD  bl 0x824eaa88
	ctx.lr = 0x829AAAB0;
	sub_824EAA88(ctx, base);
	// 829AAAB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AAAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AAAB8: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AAABC: 4BB6490D  bl 0x8250f3c8
	ctx.lr = 0x829AAAC0;
	sub_8250F3C8(ctx, base);
	// 829AAAC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AAAC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AAAC8: 4BB40549  bl 0x824eb010
	ctx.lr = 0x829AAACC;
	sub_824EB010(ctx, base);
	// 829AAACC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AAAD0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829AAAD4: 396B9450  addi r11, r11, -0x6bb0
	ctx.r[11].s64 = ctx.r[11].s64 + -27568;
	// 829AAAD8: C3AB0000  lfs f29, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829AAADC: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 829AAAE0: 41980008  blt cr6, 0x829aaae8
	if ctx.cr[6].lt {
	pc = 0x829AAAE8; continue 'dispatch;
	}
	// 829AAAE4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829AAAE8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 829AAAEC: 484471A5  bl 0x82df1c90
	ctx.lr = 0x829AAAF0;
	sub_82DF1C90(ctx, base);
	// 829AAAF0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AAAF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AAAF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AAAFC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829AAB00: 41820020  beq 0x829aab20
	if ctx.cr[0].eq {
	pc = 0x829AAB20; continue 'dispatch;
	}
	// 829AAB04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AAB08: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 829AAB0C: 38AA1C14  addi r5, r10, 0x1c14
	ctx.r[5].s64 = ctx.r[10].s64 + 7188;
	// 829AAB10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829AAB14: 4E800421  bctrl
	ctx.lr = 0x829AAB18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829AAB18: 80610194  lwz r3, 0x194(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 829AAB1C: 4800001C  b 0x829aab38
	pc = 0x829AAB38; continue 'dispatch;
	// 829AAB20: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AAB24: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 829AAB28: 38AA1C04  addi r5, r10, 0x1c04
	ctx.r[5].s64 = ctx.r[10].s64 + 7172;
	// 829AAB2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829AAB30: 4E800421  bctrl
	ctx.lr = 0x829AAB34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829AAB34: 80610144  lwz r3, 0x144(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 829AAB38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AAB3C: 419A0008  beq cr6, 0x829aab44
	if ctx.cr[6].eq {
	pc = 0x829AAB44; continue 'dispatch;
	}
	// 829AAB40: 4B915D51  bl 0x822c0890
	ctx.lr = 0x829AAB44;
	sub_822C0890(ctx, base);
	// 829AAB44: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AAB48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AAB4C: 38A00EB3  li r5, 0xeb3
	ctx.r[5].s64 = 3763;
	// 829AAB50: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829AAB54: 48447895  bl 0x82df23e8
	ctx.lr = 0x829AAB58;
	sub_82DF23E8(ctx, base);
	// 829AAB58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AAB5C: 41820058  beq 0x829aabb4
	if ctx.cr[0].eq {
	pc = 0x829AABB4; continue 'dispatch;
	}
	// 829AAB60: 815D003B  lwz r10, 0x3b(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(59 as u32) ) } as u64;
	// 829AAB64: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829AAB68: 811D0037  lwz r8, 0x37(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(55 as u32) ) } as u64;
	// 829AAB6C: D3E10100  stfs f31, 0x100(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829AAB70: D3E10108  stfs f31, 0x108(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829AAB74: 80DD003F  lwz r6, 0x3f(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(63 as u32) ) } as u64;
	// 829AAB78: D3E1010C  stfs f31, 0x10c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 829AAB7C: 897D0001  lbz r11, 1(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(1 as u32) ) } as u64;
	// 829AAB80: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 829AAB84: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829AAB88: C0410060  lfs f2, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829AAB8C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 829AAB90: C0210060  lfs f1, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AAB94: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AAB98: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 829AAB9C: D0010104  stfs f0, 0x104(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 829AABA0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 829AABA4: C0610060  lfs f3, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829AABA8: 481A68E1  bl 0x82b51488
	ctx.lr = 0x829AABAC;
	sub_82B51488(ctx, base);
	// 829AABAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829AABB0: 48000008  b 0x829aabb8
	pc = 0x829AABB8; continue 'dispatch;
	// 829AABB4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829AABB8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829AABBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AABC0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AABC4: 4B9C4F55  bl 0x8236fb18
	ctx.lr = 0x829AABC8;
	sub_8236FB18(ctx, base);
	// 829AABC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AABCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AABD0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AABD4: 4B91542D  bl 0x822c0000
	ctx.lr = 0x829AABD8;
	sub_822C0000(ctx, base);
	// 829AABD8: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829AABDC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829AABE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AABE4: 93C100AC  stw r30, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 829AABE8: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 829AABEC: 419A0024  beq cr6, 0x829aac10
	if ctx.cr[6].eq {
	pc = 0x829AAC10; continue 'dispatch;
	}
	// 829AABF0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829AABF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AABF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AABFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AAC00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AAC04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AAC08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AAC0C: 4082FFE8  bne 0x829aabf4
	if !ctx.cr[0].eq {
	pc = 0x829AABF4; continue 'dispatch;
	}
	// 829AAC10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AAC14: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 829AAC18: 4BB64901  bl 0x8250f518
	ctx.lr = 0x829AAC1C;
	sub_8250F518(ctx, base);
	// 829AAC1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AAC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829AAC24: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829AAC28: 409A0008  bne cr6, 0x829aac30
	if !ctx.cr[6].eq {
	pc = 0x829AAC30; continue 'dispatch;
	}
	// 829AAC2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829AAC30: 3BA100A8  addi r29, r1, 0xa8
	ctx.r[29].s64 = ctx.r[1].s64 + 168;
	// 829AAC34: 4BB7D41D  bl 0x82528050
	ctx.lr = 0x829AAC38;
	sub_82528050(ctx, base);
	// 829AAC38: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829AAC3C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829AAC40: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AAC44: 38A00EBA  li r5, 0xeba
	ctx.r[5].s64 = 3770;
	// 829AAC48: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829AAC4C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829AAC50: 484ADDF1  bl 0x82e58a40
	ctx.lr = 0x829AAC54;
	sub_82E58A40(ctx, base);
	// 829AAC54: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 829AAC58: 48447039  bl 0x82df1c90
	ctx.lr = 0x829AAC5C;
	sub_82DF1C90(ctx, base);
	// 829AAC5C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829AAC60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AAC64: 419A0008  beq cr6, 0x829aac6c
	if ctx.cr[6].eq {
	pc = 0x829AAC6C; continue 'dispatch;
	}
	// 829AAC68: 4B915C29  bl 0x822c0890
	ctx.lr = 0x829AAC6C;
	sub_822C0890(ctx, base);
	// 829AAC6C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AAC70: 419A000C  beq cr6, 0x829aac7c
	if ctx.cr[6].eq {
	pc = 0x829AAC7C; continue 'dispatch;
	}
	// 829AAC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AAC78: 4B915C19  bl 0x822c0890
	ctx.lr = 0x829AAC7C;
	sub_822C0890(ctx, base);
	// 829AAC7C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829AAC80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829AAC84: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829AAC88: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 829AAC8C: 48446F6D  bl 0x82df1bf8
	ctx.lr = 0x829AAC90;
	sub_82DF1BF8(ctx, base);
	// 829AAC90: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829AAC94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829AAC98: 388B9F98  addi r4, r11, -0x6068
	ctx.r[4].s64 = ctx.r[11].s64 + -24680;
	// 829AAC9C: 83C100C0  lwz r30, 0xc0(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 829AACA0: 4844E891  bl 0x82df9530
	ctx.lr = 0x829AACA4;
	sub_82DF9530(ctx, base);
	// 829AACA4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829AACA8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829AACAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AACB0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AACB4: C02B7BC8  lfs f1, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AACB8: 4BB7B799  bl 0x82526450
	ctx.lr = 0x829AACBC;
	sub_82526450(ctx, base);
	// 829AACBC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829AACC0: 48446FD1  bl 0x82df1c90
	ctx.lr = 0x829AACC4;
	sub_82DF1C90(ctx, base);
	// 829AACC4: D3BF03D0  stfs f29, 0x3d0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), tmp.u32 ) };
	// 829AACC8: 480003B0  b 0x829ab078
	pc = 0x829AB078; continue 'dispatch;
	// 829AACCC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829AACD0: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 829AACD4: 808B8638  lwz r4, -0x79c8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31176 as u32) ) } as u64;
	// 829AACD8: 4B981A51  bl 0x8232c728
	ctx.lr = 0x829AACDC;
	sub_8232C728(ctx, base);
	// 829AACDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AACE0: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 829AACE4: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 829AACE8: 4BE0F689  bl 0x827ba370
	ctx.lr = 0x829AACEC;
	sub_827BA370(ctx, base);
	// 829AACEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AACF0: 80790018  lwz r3, 0x18(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 829AACF4: 4BE0F245  bl 0x827b9f38
	ctx.lr = 0x829AACF8;
	sub_827B9F38(ctx, base);
	// 829AACF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AACFC: 41820294  beq 0x829aaf90
	if ctx.cr[0].eq {
	pc = 0x829AAF90; continue 'dispatch;
	}
	// 829AAD00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AAD04: C01F03C0  lfs f0, 0x3c0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AAD08: C3CB9450  lfs f30, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829AAD0C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829AAD10: 41980018  blt cr6, 0x829aad28
	if ctx.cr[6].lt {
	pc = 0x829AAD28; continue 'dispatch;
	}
	// 829AAD14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AAD18: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829AAD1C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829AAD20: D01F03C0  stfs f0, 0x3c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), tmp.u32 ) };
	// 829AAD24: 48000008  b 0x829aad2c
	pc = 0x829AAD2C; continue 'dispatch;
	// 829AAD28: D3FF03C0  stfs f31, 0x3c0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), tmp.u32 ) };
	// 829AAD2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AAD30: 895F03A8  lbz r10, 0x3a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 829AAD34: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829AAD38: 3BAB133C  addi r29, r11, 0x133c
	ctx.r[29].s64 = ctx.r[11].s64 + 4924;
	// 829AAD3C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829AAD40: 9B9F03C4  stb r28, 0x3c4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[28].u8 ) };
	// 829AAD44: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829AAD48: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AAD4C: 896B7F41  lbz r11, 0x7f41(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32577 as u32) ) } as u64;
	// 829AAD50: 41820088  beq 0x829aadd8
	if ctx.cr[0].eq {
	pc = 0x829AADD8; continue 'dispatch;
	}
	// 829AAD54: 895F03A9  lbz r10, 0x3a9(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(937 as u32) ) } as u64;
	// 829AAD58: 7D680774  extsb r8, r11
	ctx.r[8].s64 = ctx.r[11].s8 as i64;
	// 829AAD5C: 893F03B4  lbz r9, 0x3b4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AAD60: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 829AAD64: 7D0A0E70  srawi r10, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 829AAD68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829AAD6C: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 829AAD70: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AAD74: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 829AAD78: 997F03A9  stb r11, 0x3a9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(937 as u32), ctx.r[11].u8 ) };
	// 829AAD7C: 995F03B4  stb r10, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[10].u8 ) };
	// 829AAD80: 41810064  bgt 0x829aade4
	if ctx.cr[0].gt {
	pc = 0x829AADE4; continue 'dispatch;
	}
	// 829AAD84: 9B7F03A9  stb r27, 0x3a9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(937 as u32), ctx.r[27].u8 ) };
	// 829AAD88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AAD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AAD90: 4BFF9FD9  bl 0x829a4d68
	ctx.lr = 0x829AAD94;
	sub_829A4D68(ctx, base);
	// 829AAD94: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AAD98: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829AAD9C: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 829AADA0: 4098000C  bge cr6, 0x829aadac
	if !ctx.cr[6].lt {
	pc = 0x829AADAC; continue 'dispatch;
	}
	// 829AADA4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829AADA8: 4800001C  b 0x829aadc4
	pc = 0x829AADC4; continue 'dispatch;
	// 829AADAC: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AADB0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829AADB4: 2F0B0046  cmpwi cr6, r11, 0x46
	ctx.cr[6].compare_i32(ctx.r[11].s32, 70, &mut ctx.xer);
	// 829AADB8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829AADBC: 41980008  blt cr6, 0x829aadc4
	if ctx.cr[6].lt {
	pc = 0x829AADC4; continue 'dispatch;
	}
	// 829AADC0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 829AADC4: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 829AADC8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829AADCC: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AADD0: D01F03AC  stfs f0, 0x3ac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 829AADD4: 48000010  b 0x829aade4
	pc = 0x829AADE4; continue 'dispatch;
	// 829AADD8: 895F03B4  lbz r10, 0x3b4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AADDC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829AADE0: 997F03B4  stb r11, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[11].u8 ) };
	// 829AADE4: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AADE8: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AADEC: 41810104  bgt 0x829aaef0
	if ctx.cr[0].gt {
	pc = 0x829AAEF0; continue 'dispatch;
	}
	// 829AADF0: 9B7F03B4  stb r27, 0x3b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[27].u8 ) };
	// 829AADF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AADF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AADFC: 4BFF9F6D  bl 0x829a4d68
	ctx.lr = 0x829AAE00;
	sub_829A4D68(ctx, base);
	// 829AAE00: A17F03BC  lhz r11, 0x3bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 829AAE04: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 829AAE08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AAE0C: B15F03BC  sth r10, 0x3bc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[10].u16 ) };
	// 829AAE10: 408200E0  bne 0x829aaef0
	if !ctx.cr[0].eq {
	pc = 0x829AAEF0; continue 'dispatch;
	}
	// 829AAE14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AAE18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AAE1C: 38A00EE6  li r5, 0xee6
	ctx.r[5].s64 = 3814;
	// 829AAE20: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829AAE24: 484475C5  bl 0x82df23e8
	ctx.lr = 0x829AAE28;
	sub_82DF23E8(ctx, base);
	// 829AAE28: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829AAE2C: 4182001C  beq 0x829aae48
	if ctx.cr[0].eq {
	pc = 0x829AAE48; continue 'dispatch;
	}
	// 829AAE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AAE34: 484B1AF5  bl 0x82e5c928
	ctx.lr = 0x829AAE38;
	sub_82E5C928(ctx, base);
	// 829AAE38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AAE3C: 396B162C  addi r11, r11, 0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + 5676;
	// 829AAE40: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AAE44: 48000008  b 0x829aae4c
	pc = 0x829AAE4C; continue 'dispatch;
	// 829AAE48: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829AAE4C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829AAE50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AAE54: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AAE58: 4BFF9B29  bl 0x829a4980
	ctx.lr = 0x829AAE5C;
	sub_829A4980(ctx, base);
	// 829AAE5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AAE60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AAE64: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AAE68: 4B915199  bl 0x822c0000
	ctx.lr = 0x829AAE6C;
	sub_822C0000(ctx, base);
	// 829AAE6C: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829AAE70: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829AAE74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AAE78: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 829AAE7C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829AAE80: 419A0024  beq cr6, 0x829aaea4
	if ctx.cr[6].eq {
	pc = 0x829AAEA4; continue 'dispatch;
	}
	// 829AAE84: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829AAE88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AAE8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AAE90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AAE94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AAE98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AAE9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AAEA0: 4082FFE8  bne 0x829aae88
	if !ctx.cr[0].eq {
	pc = 0x829AAE88; continue 'dispatch;
	}
	// 829AAEA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AAEA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829AAEAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AAEB0: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 829AAEB4: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 829AAEB8: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829AAEBC: 484B37ED  bl 0x82e5e6a8
	ctx.lr = 0x829AAEC0;
	sub_82E5E6A8(ctx, base);
	// 829AAEC0: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 829AAEC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AAEC8: 419A0008  beq cr6, 0x829aaed0
	if ctx.cr[6].eq {
	pc = 0x829AAED0; continue 'dispatch;
	}
	// 829AAECC: 4B9159C5  bl 0x822c0890
	ctx.lr = 0x829AAED0;
	sub_822C0890(ctx, base);
	// 829AAED0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829AAED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AAED8: 419A0008  beq cr6, 0x829aaee0
	if ctx.cr[6].eq {
	pc = 0x829AAEE0; continue 'dispatch;
	}
	// 829AAEDC: 4B9159B5  bl 0x822c0890
	ctx.lr = 0x829AAEE0;
	sub_822C0890(ctx, base);
	// 829AAEE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AAEE4: 419A000C  beq cr6, 0x829aaef0
	if ctx.cr[6].eq {
	pc = 0x829AAEF0; continue 'dispatch;
	}
	// 829AAEE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AAEEC: 4B9159A5  bl 0x822c0890
	ctx.lr = 0x829AAEF0;
	sub_822C0890(ctx, base);
	// 829AAEF0: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 829AAEF4: 4BB3FB95  bl 0x824eaa88
	ctx.lr = 0x829AAEF8;
	sub_824EAA88(ctx, base);
	// 829AAEF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829AAEFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AAF00: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AAF04: 4BB644C5  bl 0x8250f3c8
	ctx.lr = 0x829AAF08;
	sub_8250F3C8(ctx, base);
	// 829AAF08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AAF0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AAF10: 4BB40101  bl 0x824eb010
	ctx.lr = 0x829AAF14;
	sub_824EB010(ctx, base);
	// 829AAF14: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 829AAF18: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 829AAF1C: 41980008  blt cr6, 0x829aaf24
	if ctx.cr[6].lt {
	pc = 0x829AAF24; continue 'dispatch;
	}
	// 829AAF20: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829AAF24: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 829AAF28: 48446D69  bl 0x82df1c90
	ctx.lr = 0x829AAF2C;
	sub_82DF1C90(ctx, base);
	// 829AAF2C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AAF30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AAF34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AAF38: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829AAF3C: 41820020  beq 0x829aaf5c
	if ctx.cr[0].eq {
	pc = 0x829AAF5C; continue 'dispatch;
	}
	// 829AAF40: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AAF44: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 829AAF48: 38AA1BF0  addi r5, r10, 0x1bf0
	ctx.r[5].s64 = ctx.r[10].s64 + 7152;
	// 829AAF4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829AAF50: 4E800421  bctrl
	ctx.lr = 0x829AAF54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829AAF54: 80610164  lwz r3, 0x164(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 829AAF58: 4800001C  b 0x829aaf74
	pc = 0x829AAF74; continue 'dispatch;
	// 829AAF5C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AAF60: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 829AAF64: 38AA1BDC  addi r5, r10, 0x1bdc
	ctx.r[5].s64 = ctx.r[10].s64 + 7132;
	// 829AAF68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829AAF6C: 4E800421  bctrl
	ctx.lr = 0x829AAF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829AAF70: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 829AAF74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AAF78: 419A0008  beq cr6, 0x829aaf80
	if ctx.cr[6].eq {
	pc = 0x829AAF80; continue 'dispatch;
	}
	// 829AAF7C: 4B915915  bl 0x822c0890
	ctx.lr = 0x829AAF80;
	sub_822C0890(ctx, base);
	// 829AAF80: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AAF84: D3DF03D0  stfs f30, 0x3d0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), tmp.u32 ) };
	// 829AAF88: D01F03C8  stfs f0, 0x3c8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(968 as u32), tmp.u32 ) };
	// 829AAF8C: 480000EC  b 0x829ab078
	pc = 0x829AB078; continue 'dispatch;
	// 829AAF90: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AAF94: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AAF98: 418100E0  bgt 0x829ab078
	if ctx.cr[0].gt {
	pc = 0x829AB078; continue 'dispatch;
	}
	// 829AAF9C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829AAFA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AAFA4: 38A00F00  li r5, 0xf00
	ctx.r[5].s64 = 3840;
	// 829AAFA8: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829AAFAC: 4844743D  bl 0x82df23e8
	ctx.lr = 0x829AAFB0;
	sub_82DF23E8(ctx, base);
	// 829AAFB0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829AAFB4: 4182001C  beq 0x829aafd0
	if ctx.cr[0].eq {
	pc = 0x829AAFD0; continue 'dispatch;
	}
	// 829AAFB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AAFBC: 484B196D  bl 0x82e5c928
	ctx.lr = 0x829AAFC0;
	sub_82E5C928(ctx, base);
	// 829AAFC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AAFC4: 396B162C  addi r11, r11, 0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + 5676;
	// 829AAFC8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AAFCC: 48000008  b 0x829aafd4
	pc = 0x829AAFD4; continue 'dispatch;
	// 829AAFD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829AAFD4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829AAFD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AAFDC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AAFE0: 4BFF99A1  bl 0x829a4980
	ctx.lr = 0x829AAFE4;
	sub_829A4980(ctx, base);
	// 829AAFE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829AAFE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829AAFEC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829AAFF0: 4B915011  bl 0x822c0000
	ctx.lr = 0x829AAFF4;
	sub_822C0000(ctx, base);
	// 829AAFF4: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829AAFF8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829AAFFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AB000: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 829AB004: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 829AB008: 419A0024  beq cr6, 0x829ab02c
	if ctx.cr[6].eq {
	pc = 0x829AB02C; continue 'dispatch;
	}
	// 829AB00C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829AB010: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AB014: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AB018: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AB01C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AB020: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AB024: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AB028: 4082FFE8  bne 0x829ab010
	if !ctx.cr[0].eq {
	pc = 0x829AB010; continue 'dispatch;
	}
	// 829AB02C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AB030: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829AB034: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AB038: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 829AB03C: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 829AB040: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 829AB044: 484B3665  bl 0x82e5e6a8
	ctx.lr = 0x829AB048;
	sub_82E5E6A8(ctx, base);
	// 829AB048: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 829AB04C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AB050: 419A0008  beq cr6, 0x829ab058
	if ctx.cr[6].eq {
	pc = 0x829AB058; continue 'dispatch;
	}
	// 829AB054: 4B91583D  bl 0x822c0890
	ctx.lr = 0x829AB058;
	sub_822C0890(ctx, base);
	// 829AB058: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829AB05C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AB060: 419A0008  beq cr6, 0x829ab068
	if ctx.cr[6].eq {
	pc = 0x829AB068; continue 'dispatch;
	}
	// 829AB064: 4B91582D  bl 0x822c0890
	ctx.lr = 0x829AB068;
	sub_822C0890(ctx, base);
	// 829AB068: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829AB06C: 419A000C  beq cr6, 0x829ab078
	if ctx.cr[6].eq {
	pc = 0x829AB078; continue 'dispatch;
	}
	// 829AB070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AB074: 4B91581D  bl 0x822c0890
	ctx.lr = 0x829AB078;
	sub_822C0890(ctx, base);
	// 829AB078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB07C: 4BFFE1BD  bl 0x829a9238
	ctx.lr = 0x829AB080;
	sub_829A9238(ctx, base);
	// 829AB080: 3BBF01EC  addi r29, r31, 0x1ec
	ctx.r[29].s64 = ctx.r[31].s64 + 492;
	// 829AB084: 3BC00006  li r30, 6
	ctx.r[30].s64 = 6;
	// 829AB088: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AB08C: 48005F25  bl 0x829b0fb0
	ctx.lr = 0x829AB090;
	sub_829B0FB0(ctx, base);
	// 829AB090: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829AB094: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829AB098: 4082FFF0  bne 0x829ab088
	if !ctx.cr[0].eq {
	pc = 0x829AB088; continue 'dispatch;
	}
	// 829AB09C: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 829AB0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB0A4: 4BB66CF5  bl 0x82511d98
	ctx.lr = 0x829AB0A8;
	sub_82511D98(ctx, base);
	// 829AB0A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829AB0AC: D3E100F0  stfs f31, 0xf0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 829AB0B0: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 829AB0B4: D3E100F4  stfs f31, 0xf4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 829AB0B8: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 829AB0BC: D3E100FC  stfs f31, 0xfc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 829AB0C0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 829AB0C4: C00BA1C4  lfs f0, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829AB0C8: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 829AB0CC: 484D0C7D  bl 0x82e7bd48
	ctx.lr = 0x829AB0D0;
	sub_82E7BD48(ctx, base);
	// 829AB0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB0D4: 4BB66A15  bl 0x82511ae8
	ctx.lr = 0x829AB0D8;
	sub_82511AE8(ctx, base);
	// 829AB0D8: 396101A0  addi r11, r1, 0x1a0
	ctx.r[11].s64 = ctx.r[1].s64 + 416;
	// 829AB0DC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829AB0E0: 392101C0  addi r9, r1, 0x1c0
	ctx.r[9].s64 = ctx.r[1].s64 + 448;
	// 829AB0E4: 388101C0  addi r4, r1, 0x1c0
	ctx.r[4].s64 = ctx.r[1].s64 + 448;
	// 829AB0E8: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 829AB0EC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829AB0F0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AB198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829AB198 size=836
    let mut pc: u32 = 0x829AB198;
    'dispatch: loop {
        match pc {
            0x829AB198 => {
    //   block [0x829AB198..0x829AB4DC)
	// 829AB198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AB19C: 487FCFCD  bl 0x831a8168
	ctx.lr = 0x829AB1A0;
	sub_831A8130(ctx, base);
	// 829AB1A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AB1A4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829AB1A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829AB1AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829AB1B0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829AB1B4: 41820038  beq 0x829ab1ec
	if ctx.cr[0].eq {
	pc = 0x829AB1EC; continue 'dispatch;
	}
	// 829AB1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB1BC: 487FE7CD  bl 0x831a9988
	ctx.lr = 0x829AB1C0;
	sub_831A9988(ctx, base);
	// 829AB1C0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829AB1C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB1C8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829AB1CC: 487FCF2D  bl 0x831a80f8
	ctx.lr = 0x829AB1D0;
	sub_831A80F8(ctx, base);
	// 829AB1D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB1D4: 41820018  beq 0x829ab1ec
	if ctx.cr[0].eq {
	pc = 0x829AB1EC; continue 'dispatch;
	}
	// 829AB1D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB1DC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB1E0: 4BFFD751  bl 0x829a8930
	ctx.lr = 0x829AB1E4;
	sub_829A8930(ctx, base);
	// 829AB1E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829AB1E8: 480002EC  b 0x829ab4d4
	pc = 0x829AB4D4; continue 'dispatch;
	// 829AB1EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB1F0: 419A02D4  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB1F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB1F8: 487FE791  bl 0x831a9988
	ctx.lr = 0x829AB1FC;
	sub_831A9988(ctx, base);
	// 829AB1FC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829AB200: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB204: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 829AB208: 487FCEF1  bl 0x831a80f8
	ctx.lr = 0x829AB20C;
	sub_831A80F8(ctx, base);
	// 829AB20C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB210: 41820014  beq 0x829ab224
	if ctx.cr[0].eq {
	pc = 0x829AB224; continue 'dispatch;
	}
	// 829AB214: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB218: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB21C: 4BFFF255  bl 0x829aa470
	ctx.lr = 0x829AB220;
	sub_829AA470(ctx, base);
	// 829AB220: 4BFFFFC4  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB224: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB228: 419A029C  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB230: 487FE759  bl 0x831a9988
	ctx.lr = 0x829AB234;
	sub_831A9988(ctx, base);
	// 829AB234: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829AB238: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB23C: 386B922C  addi r3, r11, -0x6dd4
	ctx.r[3].s64 = ctx.r[11].s64 + -28116;
	// 829AB240: 487FCEB9  bl 0x831a80f8
	ctx.lr = 0x829AB244;
	sub_831A80F8(ctx, base);
	// 829AB244: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB248: 41820014  beq 0x829ab25c
	if ctx.cr[0].eq {
	pc = 0x829AB25C; continue 'dispatch;
	}
	// 829AB24C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB250: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB254: 4BFFDC65  bl 0x829a8eb8
	ctx.lr = 0x829AB258;
	sub_829A8EB8(ctx, base);
	// 829AB258: 4BFFFF8C  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB25C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB260: 419A0264  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB268: 487FE721  bl 0x831a9988
	ctx.lr = 0x829AB26C;
	sub_831A9988(ctx, base);
	// 829AB26C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 829AB270: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB274: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 829AB278: 487FCE81  bl 0x831a80f8
	ctx.lr = 0x829AB27C;
	sub_831A80F8(ctx, base);
	// 829AB27C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB280: 41820014  beq 0x829ab294
	if ctx.cr[0].eq {
	pc = 0x829AB294; continue 'dispatch;
	}
	// 829AB284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB288: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB28C: 4BFFA12D  bl 0x829a53b8
	ctx.lr = 0x829AB290;
	sub_829A53B8(ctx, base);
	// 829AB290: 4BFFFF54  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB294: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB298: 419A022C  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB29C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB2A0: 487FE6E9  bl 0x831a9988
	ctx.lr = 0x829AB2A4;
	sub_831A9988(ctx, base);
	// 829AB2A4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829AB2A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB2AC: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 829AB2B0: 487FCE49  bl 0x831a80f8
	ctx.lr = 0x829AB2B4;
	sub_831A80F8(ctx, base);
	// 829AB2B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB2B8: 41820014  beq 0x829ab2cc
	if ctx.cr[0].eq {
	pc = 0x829AB2CC; continue 'dispatch;
	}
	// 829AB2BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB2C0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB2C4: 4BFFA1CD  bl 0x829a5490
	ctx.lr = 0x829AB2C8;
	sub_829A5490(ctx, base);
	// 829AB2C8: 4BFFFF1C  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB2CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB2D0: 419A01F4  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB2D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB2D8: 487FE6B1  bl 0x831a9988
	ctx.lr = 0x829AB2DC;
	sub_831A9988(ctx, base);
	// 829AB2DC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829AB2E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB2E4: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 829AB2E8: 487FCE11  bl 0x831a80f8
	ctx.lr = 0x829AB2EC;
	sub_831A80F8(ctx, base);
	// 829AB2EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB2F0: 41820014  beq 0x829ab304
	if ctx.cr[0].eq {
	pc = 0x829AB304; continue 'dispatch;
	}
	// 829AB2F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB2F8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB2FC: 4BCBF9F5  bl 0x8266acf0
	ctx.lr = 0x829AB300;
	sub_8266ACF0(ctx, base);
	// 829AB300: 4BFFFEE4  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB304: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB308: 419A01BC  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB310: 487FE679  bl 0x831a9988
	ctx.lr = 0x829AB314;
	sub_831A9988(ctx, base);
	// 829AB314: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829AB318: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB31C: 386B59D8  addi r3, r11, 0x59d8
	ctx.r[3].s64 = ctx.r[11].s64 + 23000;
	// 829AB320: 487FCDD9  bl 0x831a80f8
	ctx.lr = 0x829AB324;
	sub_831A80F8(ctx, base);
	// 829AB324: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB328: 41820014  beq 0x829ab33c
	if ctx.cr[0].eq {
	pc = 0x829AB33C; continue 'dispatch;
	}
	// 829AB32C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB330: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB334: 4B914CCD  bl 0x822c0000
	ctx.lr = 0x829AB338;
	sub_822C0000(ctx, base);
	// 829AB338: 4BFFFEAC  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB33C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB340: 419A0184  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB348: 487FE641  bl 0x831a9988
	ctx.lr = 0x829AB34C;
	sub_831A9988(ctx, base);
	// 829AB34C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829AB350: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB354: 386B762C  addi r3, r11, 0x762c
	ctx.r[3].s64 = ctx.r[11].s64 + 30252;
	// 829AB358: 487FCDA1  bl 0x831a80f8
	ctx.lr = 0x829AB35C;
	sub_831A80F8(ctx, base);
	// 829AB35C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB360: 41820014  beq 0x829ab374
	if ctx.cr[0].eq {
	pc = 0x829AB374; continue 'dispatch;
	}
	// 829AB364: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB368: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB36C: 480086AD  bl 0x829b3a18
	ctx.lr = 0x829AB370;
	sub_829B3A18(ctx, base);
	// 829AB370: 4BFFFE74  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB374: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB378: 419A014C  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB37C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB380: 487FE609  bl 0x831a9988
	ctx.lr = 0x829AB384;
	sub_831A9988(ctx, base);
	// 829AB384: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829AB388: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB38C: 386B75F8  addi r3, r11, 0x75f8
	ctx.r[3].s64 = ctx.r[11].s64 + 30200;
	// 829AB390: 487FCD69  bl 0x831a80f8
	ctx.lr = 0x829AB394;
	sub_831A80F8(ctx, base);
	// 829AB394: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB398: 41820014  beq 0x829ab3ac
	if ctx.cr[0].eq {
	pc = 0x829AB3AC; continue 'dispatch;
	}
	// 829AB39C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB3A0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB3A4: 4800B445  bl 0x829b67e8
	ctx.lr = 0x829AB3A8;
	sub_829B67E8(ctx, base);
	// 829AB3A8: 4BFFFE3C  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB3AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB3B0: 419A0114  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB3B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB3B8: 487FE5D1  bl 0x831a9988
	ctx.lr = 0x829AB3BC;
	sub_831A9988(ctx, base);
	// 829AB3BC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829AB3C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB3C4: 386B91F4  addi r3, r11, -0x6e0c
	ctx.r[3].s64 = ctx.r[11].s64 + -28172;
	// 829AB3C8: 487FCD31  bl 0x831a80f8
	ctx.lr = 0x829AB3CC;
	sub_831A80F8(ctx, base);
	// 829AB3CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB3D0: 41820014  beq 0x829ab3e4
	if ctx.cr[0].eq {
	pc = 0x829AB3E4; continue 'dispatch;
	}
	// 829AB3D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB3D8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB3DC: 480131FD  bl 0x829be5d8
	ctx.lr = 0x829AB3E0;
	sub_829BE5D8(ctx, base);
	// 829AB3E0: 4BFFFE04  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB3E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB3E8: 419A00DC  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB3F0: 487FE599  bl 0x831a9988
	ctx.lr = 0x829AB3F4;
	sub_831A9988(ctx, base);
	// 829AB3F4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829AB3F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB3FC: 386B80A0  addi r3, r11, -0x7f60
	ctx.r[3].s64 = ctx.r[11].s64 + -32608;
	// 829AB400: 487FCCF9  bl 0x831a80f8
	ctx.lr = 0x829AB404;
	sub_831A80F8(ctx, base);
	// 829AB404: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB408: 41820014  beq 0x829ab41c
	if ctx.cr[0].eq {
	pc = 0x829AB41C; continue 'dispatch;
	}
	// 829AB40C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB410: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB414: 4BFF8215  bl 0x829a3628
	ctx.lr = 0x829AB418;
	sub_829A3628(ctx, base);
	// 829AB418: 4BFFFDCC  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB41C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB420: 419A00A4  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB428: 487FE561  bl 0x831a9988
	ctx.lr = 0x829AB42C;
	sub_831A9988(ctx, base);
	// 829AB42C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 829AB430: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB434: 386B2F78  addi r3, r11, 0x2f78
	ctx.r[3].s64 = ctx.r[11].s64 + 12152;
	// 829AB438: 487FCCC1  bl 0x831a80f8
	ctx.lr = 0x829AB43C;
	sub_831A80F8(ctx, base);
	// 829AB43C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB440: 41820014  beq 0x829ab454
	if ctx.cr[0].eq {
	pc = 0x829AB454; continue 'dispatch;
	}
	// 829AB444: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB448: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB44C: 4BFF7E2D  bl 0x829a3278
	ctx.lr = 0x829AB450;
	sub_829A3278(ctx, base);
	// 829AB450: 4BFFFD94  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB454: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB458: 419A006C  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB45C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB460: 487FE529  bl 0x831a9988
	ctx.lr = 0x829AB464;
	sub_831A9988(ctx, base);
	// 829AB464: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829AB468: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB46C: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 829AB470: 487FCC89  bl 0x831a80f8
	ctx.lr = 0x829AB474;
	sub_831A80F8(ctx, base);
	// 829AB474: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB478: 41820014  beq 0x829ab48c
	if ctx.cr[0].eq {
	pc = 0x829AB48C; continue 'dispatch;
	}
	// 829AB47C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB480: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB484: 4BFFB325  bl 0x829a67a8
	ctx.lr = 0x829AB488;
	sub_829A67A8(ctx, base);
	// 829AB488: 4BFFFD5C  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB48C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829AB490: 419A0034  beq cr6, 0x829ab4c4
	if ctx.cr[6].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB498: 487FE4F1  bl 0x831a9988
	ctx.lr = 0x829AB49C;
	sub_831A9988(ctx, base);
	// 829AB49C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829AB4A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829AB4A4: 386B5984  addi r3, r11, 0x5984
	ctx.r[3].s64 = ctx.r[11].s64 + 22916;
	// 829AB4A8: 487FCC51  bl 0x831a80f8
	ctx.lr = 0x829AB4AC;
	sub_831A80F8(ctx, base);
	// 829AB4AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AB4B0: 41820014  beq 0x829ab4c4
	if ctx.cr[0].eq {
	pc = 0x829AB4C4; continue 'dispatch;
	}
	// 829AB4B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB4B8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829AB4BC: 4B914B45  bl 0x822c0000
	ctx.lr = 0x829AB4C0;
	sub_822C0000(ctx, base);
	// 829AB4C0: 4BFFFD24  b 0x829ab1e4
	pc = 0x829AB1E4; continue 'dispatch;
	// 829AB4C4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829AB4C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AB4CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829AB4D0: 4BB67149  bl 0x82512618
	ctx.lr = 0x829AB4D4;
	sub_82512618(ctx, base);
	// 829AB4D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829AB4D8: 487FCCE0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AB4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829AB4E0 size=15080
    let mut pc: u32 = 0x829AB4E0;
    'dispatch: loop {
        match pc {
            0x829AB4E0 => {
    //   block [0x829AB4E0..0x829AEFC8)
	// 829AB4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AB4E4: 487FCC4D  bl 0x831a8130
	ctx.lr = 0x829AB4E8;
	sub_831A8130(ctx, base);
	// 829AB4E8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 829AB4EC: 487FD581  bl 0x831a8a6c
	ctx.lr = 0x829AB4F0;
	sub_831A8A40(ctx, base);
	// 829AB4F0: 9421F4B0  stwu r1, -0xb50(r1)
	ea = ctx.r[1].u32.wrapping_add(-2896 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AB4F4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829AB4F8: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 829AB4FC: 394ACAD8  addi r10, r10, -0x3528
	ctx.r[10].s64 = ctx.r[10].s64 + -13608;
	// 829AB500: 7E6F9B78  mr r15, r19
	ctx.r[15].u64 = ctx.r[19].u64;
	// 829AB504: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 829AB508: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 829AB50C: 91E10088  stw r15, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[15].u32 ) };
	// 829AB510: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 829AB514: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 829AB518: 996AFFFA  stb r11, -6(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-6 as u32), ctx.r[11].u8 ) };
	// 829AB51C: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 829AB520: 93E10B74  stw r31, 0xb74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2932 as u32), ctx.r[31].u32 ) };
	// 829AB524: 4BB664B5  bl 0x825119d8
	ctx.lr = 0x829AB528;
	sub_825119D8(ctx, base);
	// 829AB528: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829AB52C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829AB530: 4BB63E41  bl 0x8250f370
	ctx.lr = 0x829AB534;
	sub_8250F370(ctx, base);
	// 829AB534: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829AB538: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829AB53C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829AB540: 484484C9  bl 0x82df3a08
	ctx.lr = 0x829AB544;
	sub_82DF3A08(ctx, base);
	// 829AB544: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 829AB548: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829AB54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB550: 4BB5D231  bl 0x82508780
	ctx.lr = 0x829AB554;
	sub_82508780(ctx, base);
	// 829AB554: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829AB558: 48447ED1  bl 0x82df3428
	ctx.lr = 0x829AB55C;
	sub_82DF3428(ctx, base);
	// 829AB55C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 829AB560: 38950028  addi r4, r21, 0x28
	ctx.r[4].s64 = ctx.r[21].s64 + 40;
	// 829AB564: 409A0008  bne cr6, 0x829ab56c
	if !ctx.cr[6].eq {
	pc = 0x829AB56C; continue 'dispatch;
	}
	// 829AB568: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 829AB56C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB570: 4BB5D231  bl 0x825087a0
	ctx.lr = 0x829AB574;
	sub_825087A0(ctx, base);
	// 829AB574: 3B9503E0  addi r28, r21, 0x3e0
	ctx.r[28].s64 = ctx.r[21].s64 + 992;
	// 829AB578: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829AB57C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829AB580: 38610778  addi r3, r1, 0x778
	ctx.r[3].s64 = ctx.r[1].s64 + 1912;
	// 829AB584: 4B971C4D  bl 0x8231d1d0
	ctx.lr = 0x829AB588;
	sub_8231D1D0(ctx, base);
	// 829AB588: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AB58C: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 829AB590: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829AB594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829AB598: 91610124  stw r11, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 829AB59C: 419A0024  beq cr6, 0x829ab5c0
	if ctx.cr[6].eq {
	pc = 0x829AB5C0; continue 'dispatch;
	}
	// 829AB5A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829AB5A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AB5A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AB5AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AB5B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AB5B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AB5B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AB5BC: 4082FFE8  bne 0x829ab5a4
	if !ctx.cr[0].eq {
	pc = 0x829AB5A4; continue 'dispatch;
	}
	// 829AB5C0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829AB5C4: 386108D0  addi r3, r1, 0x8d0
	ctx.r[3].s64 = ctx.r[1].s64 + 2256;
	// 829AB5C8: 4BB63F01  bl 0x8250f4c8
	ctx.lr = 0x829AB5CC;
	sub_8250F4C8(ctx, base);
	// 829AB5CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829AB5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829AB5D4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829AB5D8: 409A0008  bne cr6, 0x829ab5e0
	if !ctx.cr[6].eq {
	pc = 0x829AB5E0; continue 'dispatch;
	}
	// 829AB5DC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 829AB5E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AB5E4: 3BF50028  addi r31, r21, 0x28
	ctx.r[31].s64 = ctx.r[21].s64 + 40;
	// 829AB5E8: 3BC10120  addi r30, r1, 0x120
	ctx.r[30].s64 = ctx.r[1].s64 + 288;
	// 829AB5EC: 4BB5D42D  bl 0x82508a18
	ctx.lr = 0x829AB5F0;
	sub_82508A18(ctx, base);
	// 829AB5F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AB5F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829AB5F8: 3ACB1A70  addi r22, r11, 0x1a70
	ctx.r[22].s64 = ctx.r[11].s64 + 6768;
	// 829AB5FC: 38A001D3  li r5, 0x1d3
	ctx.r[5].s64 = 467;
	// 829AB600: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 829AB604: 92C100A4  stw r22, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[22].u32 ) };
	// 829AB608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AB60C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829AB610: 484AB9D9  bl 0x82e56fe8
	ctx.lr = 0x829AB614;
	sub_82E56FE8(ctx, base);
	// 829AB614: 386108D0  addi r3, r1, 0x8d0
	ctx.r[3].s64 = ctx.r[1].s64 + 2256;
	// 829AB618: 48446679  bl 0x82df1c90
	ctx.lr = 0x829AB61C;
	sub_82DF1C90(ctx, base);
	// 829AB61C: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 829AB620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AB624: 419A0008  beq cr6, 0x829ab62c
	if ctx.cr[6].eq {
	pc = 0x829AB62C; continue 'dispatch;
	}
	// 829AB628: 4B915269  bl 0x822c0890
	ctx.lr = 0x829AB62C;
	sub_822C0890(ctx, base);
	// 829AB62C: 8061077C  lwz r3, 0x77c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1916 as u32) ) } as u64;
	// 829AB630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AB634: 419A0008  beq cr6, 0x829ab63c
	if ctx.cr[6].eq {
	pc = 0x829AB63C; continue 'dispatch;
	}
	// 829AB638: 4B915259  bl 0x822c0890
	ctx.lr = 0x829AB63C;
	sub_822C0890(ctx, base);
	// 829AB63C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829AB640: 4BB664A9  bl 0x82511ae8
	ctx.lr = 0x829AB644;
	sub_82511AE8(ctx, base);
	// 829AB644: 39600450  li r11, 0x450
	ctx.r[11].s64 = 1104;
	// 829AB648: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829AB64C: 3AF50148  addi r23, r21, 0x148
	ctx.r[23].s64 = ctx.r[21].s64 + 328;
	// 829AB650: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 829AB654: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 829AB658: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829AEFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829AEFC8 size=5068
    let mut pc: u32 = 0x829AEFC8;
    'dispatch: loop {
        match pc {
            0x829AEFC8 => {
    //   block [0x829AEFC8..0x829B0394)
	// 829AEFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829AEFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829AEFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829AEFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829AEFD8: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829AEFDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829AEFE0: 897E03B4  lbz r11, 0x3b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(948 as u32) ) } as u64;
	// 829AEFE4: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829AEFE8: 41810010  bgt 0x829aeff8
	if ctx.cr[0].gt {
	pc = 0x829AEFF8; continue 'dispatch;
	}
	// 829AEFEC: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 829AEFF0: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 829AEFF4: 409A1388  bne cr6, 0x829b037c
	if !ctx.cr[6].eq {
	pc = 0x829B037C; continue 'dispatch;
	}
	// 829AEFF8: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 829AEFFC: 2B0B0017  cmplwi cr6, r11, 0x17
	ctx.cr[6].compare_u32(ctx.r[11].u32, 23 as u32, &mut ctx.xer);
	// 829AF000: 4199137C  bgt cr6, 0x829b037c
	if ctx.cr[6].gt {
	pc = 0x829B037C; continue 'dispatch;
	}
	// 829AF004: 3D80820A  lis r12, -0x7df6
	ctx.r[12].s64 = -2113273856;
	// 829AF008: 398C1350  addi r12, r12, 0x1350
	ctx.r[12].s64 = ctx.r[12].s64 + 4944;
	// 829AF00C: 5560083C  slwi r0, r11, 1
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 829AF010: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 829AF014: 3D80829B  lis r12, -0x7d65
	ctx.r[12].s64 = -2103771136;
	// 829AF018: 398CF02C  addi r12, r12, -0xfd4
	ctx.r[12].s64 = ctx.r[12].s64 + -4052;
	// 829AF01C: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 829AF020: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 829AF024: 60000000  nop
	// 829AF028: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 829AF02C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF030: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF034: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF038: 38A00C05  li r5, 0xc05
	ctx.r[5].s64 = 3077;
	// 829AF03C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 829AF040: 484433A9  bl 0x82df23e8
	ctx.lr = 0x829AF044;
	sub_82DF23E8(ctx, base);
	// 829AF044: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF048: 4182001C  beq 0x829af064
	if ctx.cr[0].eq {
	pc = 0x829AF064; continue 'dispatch;
	}
	// 829AF04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF050: 484AD8D9  bl 0x82e5c928
	ctx.lr = 0x829AF054;
	sub_82E5C928(ctx, base);
	// 829AF054: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF058: 396B1678  addi r11, r11, 0x1678
	ctx.r[11].s64 = ctx.r[11].s64 + 5752;
	// 829AF05C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AF060: 48000008  b 0x829af068
	pc = 0x829AF068; continue 'dispatch;
	// 829AF064: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF068: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF06C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF074: 4BFF496D  bl 0x829a39e0
	ctx.lr = 0x829AF078;
	sub_829A39E0(ctx, base);
	// 829AF078: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF07C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF080: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF084: 4B910F7D  bl 0x822c0000
	ctx.lr = 0x829AF088;
	sub_822C0000(ctx, base);
	// 829AF088: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF08C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF090: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF094: 93E10114  stw r31, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[31].u32 ) };
	// 829AF098: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 829AF09C: 419A0024  beq cr6, 0x829af0c0
	if ctx.cr[6].eq {
	pc = 0x829AF0C0; continue 'dispatch;
	}
	// 829AF0A0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF0A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF0A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF0AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF0B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF0B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF0B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF0BC: 4082FFE8  bne 0x829af0a4
	if !ctx.cr[0].eq {
	pc = 0x829AF0A4; continue 'dispatch;
	}
	// 829AF0C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF0C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF0C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF0CC: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 829AF0D0: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF0D4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 829AF0D8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF0DC: 484AF5CD  bl 0x82e5e6a8
	ctx.lr = 0x829AF0E0;
	sub_82E5E6A8(ctx, base);
	// 829AF0E0: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 829AF0E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF0E8: 419A0008  beq cr6, 0x829af0f0
	if ctx.cr[6].eq {
	pc = 0x829AF0F0; continue 'dispatch;
	}
	// 829AF0EC: 4B9117A5  bl 0x822c0890
	ctx.lr = 0x829AF0F0;
	sub_822C0890(ctx, base);
	// 829AF0F0: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 829AF0F4: 4800126C  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF0F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF0FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF100: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF104: 38A00C08  li r5, 0xc08
	ctx.r[5].s64 = 3080;
	// 829AF108: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 829AF10C: 484432DD  bl 0x82df23e8
	ctx.lr = 0x829AF110;
	sub_82DF23E8(ctx, base);
	// 829AF110: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF114: 4182001C  beq 0x829af130
	if ctx.cr[0].eq {
	pc = 0x829AF130; continue 'dispatch;
	}
	// 829AF118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF11C: 484AD80D  bl 0x82e5c928
	ctx.lr = 0x829AF120;
	sub_82E5C928(ctx, base);
	// 829AF120: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF124: 396B16A0  addi r11, r11, 0x16a0
	ctx.r[11].s64 = ctx.r[11].s64 + 5792;
	// 829AF128: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AF12C: 48000008  b 0x829af134
	pc = 0x829AF134; continue 'dispatch;
	// 829AF130: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF134: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF13C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF140: 4BFF4969  bl 0x829a3aa8
	ctx.lr = 0x829AF144;
	sub_829A3AA8(ctx, base);
	// 829AF144: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF148: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF14C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF150: 4B910EB1  bl 0x822c0000
	ctx.lr = 0x829AF154;
	sub_822C0000(ctx, base);
	// 829AF154: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF158: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF15C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF160: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 829AF164: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829AF168: 419A0024  beq cr6, 0x829af18c
	if ctx.cr[6].eq {
	pc = 0x829AF18C; continue 'dispatch;
	}
	// 829AF16C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF170: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF174: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF178: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF17C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF180: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF184: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF188: 4082FFE8  bne 0x829af170
	if !ctx.cr[0].eq {
	pc = 0x829AF170; continue 'dispatch;
	}
	// 829AF18C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF190: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF194: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF198: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 829AF19C: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF1A0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 829AF1A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF1A8: 484AF501  bl 0x82e5e6a8
	ctx.lr = 0x829AF1AC;
	sub_82E5E6A8(ctx, base);
	// 829AF1AC: 8061012C  lwz r3, 0x12c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 829AF1B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF1B4: 419A0008  beq cr6, 0x829af1bc
	if ctx.cr[6].eq {
	pc = 0x829AF1BC; continue 'dispatch;
	}
	// 829AF1B8: 4B9116D9  bl 0x822c0890
	ctx.lr = 0x829AF1BC;
	sub_822C0890(ctx, base);
	// 829AF1BC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829AF1C0: 480011A0  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF1C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF1C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF1CC: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF1D0: 38A00C0B  li r5, 0xc0b
	ctx.r[5].s64 = 3083;
	// 829AF1D4: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829AF1D8: 48443211  bl 0x82df23e8
	ctx.lr = 0x829AF1DC;
	sub_82DF23E8(ctx, base);
	// 829AF1DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF1E0: 41820028  beq 0x829af208
	if ctx.cr[0].eq {
	pc = 0x829AF208; continue 'dispatch;
	}
	// 829AF1E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF1E8: 484AD741  bl 0x82e5c928
	ctx.lr = 0x829AF1EC;
	sub_82E5C928(ctx, base);
	// 829AF1EC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AF1F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829AF1F4: 394A16C8  addi r10, r10, 0x16c8
	ctx.r[10].s64 = ctx.r[10].s64 + 5832;
	// 829AF1F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829AF1FC: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 829AF200: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 829AF204: 48000008  b 0x829af20c
	pc = 0x829AF20C; continue 'dispatch;
	// 829AF208: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF20C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF214: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF218: 4BFF4959  bl 0x829a3b70
	ctx.lr = 0x829AF21C;
	sub_829A3B70(ctx, base);
	// 829AF21C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF224: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF228: 4B910DD9  bl 0x822c0000
	ctx.lr = 0x829AF22C;
	sub_822C0000(ctx, base);
	// 829AF22C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF230: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF234: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF238: 93E100EC  stw r31, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[31].u32 ) };
	// 829AF23C: 916100E8  stw r11, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829AF240: 419A0024  beq cr6, 0x829af264
	if ctx.cr[6].eq {
	pc = 0x829AF264; continue 'dispatch;
	}
	// 829AF244: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF248: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF24C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF250: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF254: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF258: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF25C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF260: 4082FFE8  bne 0x829af248
	if !ctx.cr[0].eq {
	pc = 0x829AF248; continue 'dispatch;
	}
	// 829AF264: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF268: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF26C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF270: 38A100E8  addi r5, r1, 0xe8
	ctx.r[5].s64 = ctx.r[1].s64 + 232;
	// 829AF274: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF278: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 829AF27C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF280: 484AF429  bl 0x82e5e6a8
	ctx.lr = 0x829AF284;
	sub_82E5E6A8(ctx, base);
	// 829AF284: 806101AC  lwz r3, 0x1ac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) } as u64;
	// 829AF288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF28C: 419A0008  beq cr6, 0x829af294
	if ctx.cr[6].eq {
	pc = 0x829AF294; continue 'dispatch;
	}
	// 829AF290: 4B911601  bl 0x822c0890
	ctx.lr = 0x829AF294;
	sub_822C0890(ctx, base);
	// 829AF294: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 829AF298: 480010C8  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF29C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF2A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF2A4: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF2A8: 38A00C0E  li r5, 0xc0e
	ctx.r[5].s64 = 3086;
	// 829AF2AC: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 829AF2B0: 48443139  bl 0x82df23e8
	ctx.lr = 0x829AF2B4;
	sub_82DF23E8(ctx, base);
	// 829AF2B4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF2B8: 41820028  beq 0x829af2e0
	if ctx.cr[0].eq {
	pc = 0x829AF2E0; continue 'dispatch;
	}
	// 829AF2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF2C0: 484AD669  bl 0x82e5c928
	ctx.lr = 0x829AF2C4;
	sub_82E5C928(ctx, base);
	// 829AF2C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AF2C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829AF2CC: 394A16F0  addi r10, r10, 0x16f0
	ctx.r[10].s64 = ctx.r[10].s64 + 5872;
	// 829AF2D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829AF2D4: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829AF2D8: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 829AF2DC: 48000008  b 0x829af2e4
	pc = 0x829AF2E4; continue 'dispatch;
	// 829AF2E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF2E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF2E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF2EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF2F0: 4BFF4949  bl 0x829a3c38
	ctx.lr = 0x829AF2F4;
	sub_829A3C38(ctx, base);
	// 829AF2F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF2F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF2FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF300: 4B910D01  bl 0x822c0000
	ctx.lr = 0x829AF304;
	sub_822C0000(ctx, base);
	// 829AF304: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF308: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF30C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF310: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 829AF314: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829AF318: 419A0024  beq cr6, 0x829af33c
	if ctx.cr[6].eq {
	pc = 0x829AF33C; continue 'dispatch;
	}
	// 829AF31C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF320: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF324: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF328: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF32C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF330: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF334: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF338: 4082FFE8  bne 0x829af320
	if !ctx.cr[0].eq {
	pc = 0x829AF320; continue 'dispatch;
	}
	// 829AF33C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF340: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF344: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF348: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 829AF34C: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF350: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 829AF354: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF358: 484AF351  bl 0x82e5e6a8
	ctx.lr = 0x829AF35C;
	sub_82E5E6A8(ctx, base);
	// 829AF35C: 8061013C  lwz r3, 0x13c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 829AF360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF364: 419A0008  beq cr6, 0x829af36c
	if ctx.cr[6].eq {
	pc = 0x829AF36C; continue 'dispatch;
	}
	// 829AF368: 4B911529  bl 0x822c0890
	ctx.lr = 0x829AF36C;
	sub_822C0890(ctx, base);
	// 829AF36C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829AF370: 48000FF0  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF374: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF378: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF37C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF380: 38A00C11  li r5, 0xc11
	ctx.r[5].s64 = 3089;
	// 829AF384: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829AF388: 48443061  bl 0x82df23e8
	ctx.lr = 0x829AF38C;
	sub_82DF23E8(ctx, base);
	// 829AF38C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF390: 41820028  beq 0x829af3b8
	if ctx.cr[0].eq {
	pc = 0x829AF3B8; continue 'dispatch;
	}
	// 829AF394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF398: 484AD591  bl 0x82e5c928
	ctx.lr = 0x829AF39C;
	sub_82E5C928(ctx, base);
	// 829AF39C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829AF3A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829AF3A4: 394A1718  addi r10, r10, 0x1718
	ctx.r[10].s64 = ctx.r[10].s64 + 5912;
	// 829AF3A8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829AF3AC: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829AF3B0: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 829AF3B4: 48000008  b 0x829af3bc
	pc = 0x829AF3BC; continue 'dispatch;
	// 829AF3B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF3BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF3C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF3C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF3C8: 4BFF4939  bl 0x829a3d00
	ctx.lr = 0x829AF3CC;
	sub_829A3D00(ctx, base);
	// 829AF3CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF3D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF3D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF3D8: 4B910C29  bl 0x822c0000
	ctx.lr = 0x829AF3DC;
	sub_822C0000(ctx, base);
	// 829AF3DC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF3E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF3E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF3E8: 93E100CC  stw r31, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[31].u32 ) };
	// 829AF3EC: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 829AF3F0: 419A0024  beq cr6, 0x829af414
	if ctx.cr[6].eq {
	pc = 0x829AF414; continue 'dispatch;
	}
	// 829AF3F4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF3F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF3FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF400: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF404: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF408: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF40C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF410: 4082FFE8  bne 0x829af3f8
	if !ctx.cr[0].eq {
	pc = 0x829AF3F8; continue 'dispatch;
	}
	// 829AF414: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF418: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF41C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF420: 38A100C8  addi r5, r1, 0xc8
	ctx.r[5].s64 = ctx.r[1].s64 + 200;
	// 829AF424: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF428: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 829AF42C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF430: 484AF279  bl 0x82e5e6a8
	ctx.lr = 0x829AF434;
	sub_82E5E6A8(ctx, base);
	// 829AF434: 8061018C  lwz r3, 0x18c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 829AF438: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF43C: 419A0008  beq cr6, 0x829af444
	if ctx.cr[6].eq {
	pc = 0x829AF444; continue 'dispatch;
	}
	// 829AF440: 4B911451  bl 0x822c0890
	ctx.lr = 0x829AF444;
	sub_822C0890(ctx, base);
	// 829AF444: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829AF448: 48000F18  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF44C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF450: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF454: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF458: 38A00C14  li r5, 0xc14
	ctx.r[5].s64 = 3092;
	// 829AF45C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 829AF460: 48442F89  bl 0x82df23e8
	ctx.lr = 0x829AF464;
	sub_82DF23E8(ctx, base);
	// 829AF464: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF468: 4182001C  beq 0x829af484
	if ctx.cr[0].eq {
	pc = 0x829AF484; continue 'dispatch;
	}
	// 829AF46C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF470: 484AD4B9  bl 0x82e5c928
	ctx.lr = 0x829AF474;
	sub_82E5C928(ctx, base);
	// 829AF474: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF478: 396B1740  addi r11, r11, 0x1740
	ctx.r[11].s64 = ctx.r[11].s64 + 5952;
	// 829AF47C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AF480: 48000008  b 0x829af488
	pc = 0x829AF488; continue 'dispatch;
	// 829AF484: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF488: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF48C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF490: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF494: 4BFF4935  bl 0x829a3dc8
	ctx.lr = 0x829AF498;
	sub_829A3DC8(ctx, base);
	// 829AF498: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF49C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF4A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF4A4: 4B910B5D  bl 0x822c0000
	ctx.lr = 0x829AF4A8;
	sub_822C0000(ctx, base);
	// 829AF4A8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF4AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF4B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF4B4: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 829AF4B8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 829AF4BC: 419A0024  beq cr6, 0x829af4e0
	if ctx.cr[6].eq {
	pc = 0x829AF4E0; continue 'dispatch;
	}
	// 829AF4C0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF4C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF4C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF4CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF4D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF4D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF4D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF4DC: 4082FFE8  bne 0x829af4c4
	if !ctx.cr[0].eq {
	pc = 0x829AF4C4; continue 'dispatch;
	}
	// 829AF4E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF4E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF4E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF4EC: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 829AF4F0: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF4F4: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 829AF4F8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF4FC: 484AF1AD  bl 0x82e5e6a8
	ctx.lr = 0x829AF500;
	sub_82E5E6A8(ctx, base);
	// 829AF500: 8061014C  lwz r3, 0x14c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 829AF504: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF508: 419A0008  beq cr6, 0x829af510
	if ctx.cr[6].eq {
	pc = 0x829AF510; continue 'dispatch;
	}
	// 829AF50C: 4B911385  bl 0x822c0890
	ctx.lr = 0x829AF510;
	sub_822C0890(ctx, base);
	// 829AF510: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829AF514: 48000E4C  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF518: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF51C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF520: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF524: 38A00C17  li r5, 0xc17
	ctx.r[5].s64 = 3095;
	// 829AF528: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 829AF52C: 48442EBD  bl 0x82df23e8
	ctx.lr = 0x829AF530;
	sub_82DF23E8(ctx, base);
	// 829AF530: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF534: 4182001C  beq 0x829af550
	if ctx.cr[0].eq {
	pc = 0x829AF550; continue 'dispatch;
	}
	// 829AF538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF53C: 484AD3ED  bl 0x82e5c928
	ctx.lr = 0x829AF540;
	sub_82E5C928(ctx, base);
	// 829AF540: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF544: 396B1768  addi r11, r11, 0x1768
	ctx.r[11].s64 = ctx.r[11].s64 + 5992;
	// 829AF548: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AF54C: 48000008  b 0x829af554
	pc = 0x829AF554; continue 'dispatch;
	// 829AF550: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF554: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF55C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF560: 4BFF4931  bl 0x829a3e90
	ctx.lr = 0x829AF564;
	sub_829A3E90(ctx, base);
	// 829AF564: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF56C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF570: 4B910A91  bl 0x822c0000
	ctx.lr = 0x829AF574;
	sub_822C0000(ctx, base);
	// 829AF574: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF578: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF57C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF580: 93E1010C  stw r31, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[31].u32 ) };
	// 829AF584: 91610108  stw r11, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 829AF588: 419A0024  beq cr6, 0x829af5ac
	if ctx.cr[6].eq {
	pc = 0x829AF5AC; continue 'dispatch;
	}
	// 829AF58C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF590: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF594: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF598: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF59C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF5A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF5A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF5A8: 4082FFE8  bne 0x829af590
	if !ctx.cr[0].eq {
	pc = 0x829AF590; continue 'dispatch;
	}
	// 829AF5AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF5B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF5B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF5B8: 38A10108  addi r5, r1, 0x108
	ctx.r[5].s64 = ctx.r[1].s64 + 264;
	// 829AF5BC: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF5C0: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 829AF5C4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF5C8: 484AF0E1  bl 0x82e5e6a8
	ctx.lr = 0x829AF5CC;
	sub_82E5E6A8(ctx, base);
	// 829AF5CC: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 829AF5D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF5D4: 419A0008  beq cr6, 0x829af5dc
	if ctx.cr[6].eq {
	pc = 0x829AF5DC; continue 'dispatch;
	}
	// 829AF5D8: 4B9112B9  bl 0x822c0890
	ctx.lr = 0x829AF5DC;
	sub_822C0890(ctx, base);
	// 829AF5DC: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 829AF5E0: 48000D80  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF5E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF5E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF5EC: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF5F0: 38A00C1B  li r5, 0xc1b
	ctx.r[5].s64 = 3099;
	// 829AF5F4: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AF5F8: 48442DF1  bl 0x82df23e8
	ctx.lr = 0x829AF5FC;
	sub_82DF23E8(ctx, base);
	// 829AF5FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF600: 4182001C  beq 0x829af61c
	if ctx.cr[0].eq {
	pc = 0x829AF61C; continue 'dispatch;
	}
	// 829AF604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF608: 48004399  bl 0x829b39a0
	ctx.lr = 0x829AF60C;
	sub_829B39A0(ctx, base);
	// 829AF60C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF610: 396B1790  addi r11, r11, 0x1790
	ctx.r[11].s64 = ctx.r[11].s64 + 6032;
	// 829AF614: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AF618: 48000008  b 0x829af620
	pc = 0x829AF620; continue 'dispatch;
	// 829AF61C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF620: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF624: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF628: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF62C: 4BFF492D  bl 0x829a3f58
	ctx.lr = 0x829AF630;
	sub_829A3F58(ctx, base);
	// 829AF630: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF638: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF63C: 4B9109C5  bl 0x822c0000
	ctx.lr = 0x829AF640;
	sub_822C0000(ctx, base);
	// 829AF640: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF644: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF648: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF64C: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 829AF650: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 829AF654: 419A0024  beq cr6, 0x829af678
	if ctx.cr[6].eq {
	pc = 0x829AF678; continue 'dispatch;
	}
	// 829AF658: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF65C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF660: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF664: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF668: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF66C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF670: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF674: 4082FFE8  bne 0x829af65c
	if !ctx.cr[0].eq {
	pc = 0x829AF65C; continue 'dispatch;
	}
	// 829AF678: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF67C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF680: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF684: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 829AF688: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF68C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 829AF690: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF694: 484AF015  bl 0x82e5e6a8
	ctx.lr = 0x829AF698;
	sub_82E5E6A8(ctx, base);
	// 829AF698: 8061015C  lwz r3, 0x15c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 829AF69C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF6A0: 419A0008  beq cr6, 0x829af6a8
	if ctx.cr[6].eq {
	pc = 0x829AF6A8; continue 'dispatch;
	}
	// 829AF6A4: 4B9111ED  bl 0x822c0890
	ctx.lr = 0x829AF6A8;
	sub_822C0890(ctx, base);
	// 829AF6A8: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829AF6AC: 48000CB4  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF6B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF6B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF6B8: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF6BC: 38A00C21  li r5, 0xc21
	ctx.r[5].s64 = 3105;
	// 829AF6C0: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 829AF6C4: 48442D25  bl 0x82df23e8
	ctx.lr = 0x829AF6C8;
	sub_82DF23E8(ctx, base);
	// 829AF6C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AF6CC: 41820014  beq 0x829af6e0
	if ctx.cr[0].eq {
	pc = 0x829AF6E0; continue 'dispatch;
	}
	// 829AF6D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829AF6D4: 48005A0D  bl 0x829b50e0
	ctx.lr = 0x829AF6D8;
	sub_829B50E0(ctx, base);
	// 829AF6D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AF6DC: 48000008  b 0x829af6e4
	pc = 0x829AF6E4; continue 'dispatch;
	// 829AF6E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF6E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF6E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF6EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF6F0: 4BFF4931  bl 0x829a4020
	ctx.lr = 0x829AF6F4;
	sub_829A4020(ctx, base);
	// 829AF6F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF6F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF6FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF700: 4B910901  bl 0x822c0000
	ctx.lr = 0x829AF704;
	sub_822C0000(ctx, base);
	// 829AF704: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF708: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF70C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF710: 93E100DC  stw r31, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[31].u32 ) };
	// 829AF714: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 829AF718: 419A0024  beq cr6, 0x829af73c
	if ctx.cr[6].eq {
	pc = 0x829AF73C; continue 'dispatch;
	}
	// 829AF71C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF720: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF724: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF728: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF72C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF730: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF734: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF738: 4082FFE8  bne 0x829af720
	if !ctx.cr[0].eq {
	pc = 0x829AF720; continue 'dispatch;
	}
	// 829AF73C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF740: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF744: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF748: 38A100D8  addi r5, r1, 0xd8
	ctx.r[5].s64 = ctx.r[1].s64 + 216;
	// 829AF74C: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF750: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 829AF754: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF758: 484AEF51  bl 0x82e5e6a8
	ctx.lr = 0x829AF75C;
	sub_82E5E6A8(ctx, base);
	// 829AF75C: 8061019C  lwz r3, 0x19c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 829AF760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF764: 419A0008  beq cr6, 0x829af76c
	if ctx.cr[6].eq {
	pc = 0x829AF76C; continue 'dispatch;
	}
	// 829AF768: 4B911129  bl 0x822c0890
	ctx.lr = 0x829AF76C;
	sub_822C0890(ctx, base);
	// 829AF76C: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 829AF770: 48000BF0  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF774: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF778: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF77C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF780: 38A00C24  li r5, 0xc24
	ctx.r[5].s64 = 3108;
	// 829AF784: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 829AF788: 48442C61  bl 0x82df23e8
	ctx.lr = 0x829AF78C;
	sub_82DF23E8(ctx, base);
	// 829AF78C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AF790: 41820014  beq 0x829af7a4
	if ctx.cr[0].eq {
	pc = 0x829AF7A4; continue 'dispatch;
	}
	// 829AF794: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829AF798: 48005949  bl 0x829b50e0
	ctx.lr = 0x829AF79C;
	sub_829B50E0(ctx, base);
	// 829AF79C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AF7A0: 48000008  b 0x829af7a8
	pc = 0x829AF7A8; continue 'dispatch;
	// 829AF7A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF7A8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF7AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF7B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF7B4: 4BFF486D  bl 0x829a4020
	ctx.lr = 0x829AF7B8;
	sub_829A4020(ctx, base);
	// 829AF7B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF7BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF7C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF7C4: 4B91083D  bl 0x822c0000
	ctx.lr = 0x829AF7C8;
	sub_822C0000(ctx, base);
	// 829AF7C8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF7CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF7D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF7D4: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 829AF7D8: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 829AF7DC: 419A0024  beq cr6, 0x829af800
	if ctx.cr[6].eq {
	pc = 0x829AF800; continue 'dispatch;
	}
	// 829AF7E0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF7E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF7E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF7EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF7F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF7F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF7F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF7FC: 4082FFE8  bne 0x829af7e4
	if !ctx.cr[0].eq {
	pc = 0x829AF7E4; continue 'dispatch;
	}
	// 829AF800: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF804: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF808: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF80C: 38A100A8  addi r5, r1, 0xa8
	ctx.r[5].s64 = ctx.r[1].s64 + 168;
	// 829AF810: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF814: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 829AF818: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF81C: 484AEE8D  bl 0x82e5e6a8
	ctx.lr = 0x829AF820;
	sub_82E5E6A8(ctx, base);
	// 829AF820: 8061016C  lwz r3, 0x16c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 829AF824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF828: 419A0008  beq cr6, 0x829af830
	if ctx.cr[6].eq {
	pc = 0x829AF830; continue 'dispatch;
	}
	// 829AF82C: 4B911065  bl 0x822c0890
	ctx.lr = 0x829AF830;
	sub_822C0890(ctx, base);
	// 829AF830: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829AF834: 48000B2C  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF838: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF83C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF840: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF844: 38A00C27  li r5, 0xc27
	ctx.r[5].s64 = 3111;
	// 829AF848: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 829AF84C: 48442B9D  bl 0x82df23e8
	ctx.lr = 0x829AF850;
	sub_82DF23E8(ctx, base);
	// 829AF850: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AF854: 41820014  beq 0x829af868
	if ctx.cr[0].eq {
	pc = 0x829AF868; continue 'dispatch;
	}
	// 829AF858: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829AF85C: 48005885  bl 0x829b50e0
	ctx.lr = 0x829AF860;
	sub_829B50E0(ctx, base);
	// 829AF860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AF864: 48000008  b 0x829af86c
	pc = 0x829AF86C; continue 'dispatch;
	// 829AF868: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF86C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF870: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF874: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF878: 4BFF47A9  bl 0x829a4020
	ctx.lr = 0x829AF87C;
	sub_829A4020(ctx, base);
	// 829AF87C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF884: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF888: 4B910779  bl 0x822c0000
	ctx.lr = 0x829AF88C;
	sub_822C0000(ctx, base);
	// 829AF88C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF890: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF894: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF898: 93E100FC  stw r31, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[31].u32 ) };
	// 829AF89C: 916100F8  stw r11, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 829AF8A0: 419A0024  beq cr6, 0x829af8c4
	if ctx.cr[6].eq {
	pc = 0x829AF8C4; continue 'dispatch;
	}
	// 829AF8A4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF8A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF8AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF8B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF8B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF8B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF8BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF8C0: 4082FFE8  bne 0x829af8a8
	if !ctx.cr[0].eq {
	pc = 0x829AF8A8; continue 'dispatch;
	}
	// 829AF8C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF8C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF8CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF8D0: 38A100F8  addi r5, r1, 0xf8
	ctx.r[5].s64 = ctx.r[1].s64 + 248;
	// 829AF8D4: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF8D8: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 829AF8DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF8E0: 484AEDC9  bl 0x82e5e6a8
	ctx.lr = 0x829AF8E4;
	sub_82E5E6A8(ctx, base);
	// 829AF8E4: 806101BC  lwz r3, 0x1bc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 829AF8E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF8EC: 419A0008  beq cr6, 0x829af8f4
	if ctx.cr[6].eq {
	pc = 0x829AF8F4; continue 'dispatch;
	}
	// 829AF8F0: 4B910FA1  bl 0x822c0890
	ctx.lr = 0x829AF8F4;
	sub_822C0890(ctx, base);
	// 829AF8F4: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 829AF8F8: 48000A68  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF8FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF900: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF904: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF908: 38A00C2B  li r5, 0xc2b
	ctx.r[5].s64 = 3115;
	// 829AF90C: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829AF910: 48442AD9  bl 0x82df23e8
	ctx.lr = 0x829AF914;
	sub_82DF23E8(ctx, base);
	// 829AF914: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF918: 4182001C  beq 0x829af934
	if ctx.cr[0].eq {
	pc = 0x829AF934; continue 'dispatch;
	}
	// 829AF91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF920: 4800EC39  bl 0x829be558
	ctx.lr = 0x829AF924;
	sub_829BE558(ctx, base);
	// 829AF924: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF928: 396B17B8  addi r11, r11, 0x17b8
	ctx.r[11].s64 = ctx.r[11].s64 + 6072;
	// 829AF92C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AF930: 48000008  b 0x829af938
	pc = 0x829AF938; continue 'dispatch;
	// 829AF934: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AF938: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AF93C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF940: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF944: 4BFF47A5  bl 0x829a40e8
	ctx.lr = 0x829AF948;
	sub_829A40E8(ctx, base);
	// 829AF948: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AF94C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AF950: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AF954: 4B9106AD  bl 0x822c0000
	ctx.lr = 0x829AF958;
	sub_822C0000(ctx, base);
	// 829AF958: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AF95C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AF960: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AF964: 93E100BC  stw r31, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u32 ) };
	// 829AF968: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 829AF96C: 419A0024  beq cr6, 0x829af990
	if ctx.cr[6].eq {
	pc = 0x829AF990; continue 'dispatch;
	}
	// 829AF970: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AF974: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AF978: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF97C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AF980: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AF984: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AF988: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AF98C: 4082FFE8  bne 0x829af974
	if !ctx.cr[0].eq {
	pc = 0x829AF974; continue 'dispatch;
	}
	// 829AF990: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AF994: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AF998: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF99C: 38A100B8  addi r5, r1, 0xb8
	ctx.r[5].s64 = ctx.r[1].s64 + 184;
	// 829AF9A0: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AF9A4: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 829AF9A8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AF9AC: 484AECFD  bl 0x82e5e6a8
	ctx.lr = 0x829AF9B0;
	sub_82E5E6A8(ctx, base);
	// 829AF9B0: 8061017C  lwz r3, 0x17c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 829AF9B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AF9B8: 419A0008  beq cr6, 0x829af9c0
	if ctx.cr[6].eq {
	pc = 0x829AF9C0; continue 'dispatch;
	}
	// 829AF9BC: 4B910ED5  bl 0x822c0890
	ctx.lr = 0x829AF9C0;
	sub_822C0890(ctx, base);
	// 829AF9C0: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829AF9C4: 4800099C  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AF9C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF9CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AF9D0: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AF9D4: 38A00C2E  li r5, 0xc2e
	ctx.r[5].s64 = 3118;
	// 829AF9D8: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AF9DC: 48442A0D  bl 0x82df23e8
	ctx.lr = 0x829AF9E0;
	sub_82DF23E8(ctx, base);
	// 829AF9E0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AF9E4: 4182001C  beq 0x829afa00
	if ctx.cr[0].eq {
	pc = 0x829AFA00; continue 'dispatch;
	}
	// 829AF9E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AF9EC: 4800EB6D  bl 0x829be558
	ctx.lr = 0x829AF9F0;
	sub_829BE558(ctx, base);
	// 829AF9F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AF9F4: 396B17E0  addi r11, r11, 0x17e0
	ctx.r[11].s64 = ctx.r[11].s64 + 6112;
	// 829AF9F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AF9FC: 48000008  b 0x829afa04
	pc = 0x829AFA04; continue 'dispatch;
	// 829AFA00: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFA04: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFA08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFA0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFA10: 4BFF47A1  bl 0x829a41b0
	ctx.lr = 0x829AFA14;
	sub_829A41B0(ctx, base);
	// 829AFA14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFA18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFA1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFA20: 4B9105E1  bl 0x822c0000
	ctx.lr = 0x829AFA24;
	sub_822C0000(ctx, base);
	// 829AFA24: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFA28: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFA2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFA30: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 829AFA34: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829AFA38: 419A0024  beq cr6, 0x829afa5c
	if ctx.cr[6].eq {
	pc = 0x829AFA5C; continue 'dispatch;
	}
	// 829AFA3C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFA40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFA44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFA48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFA4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFA50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFA54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFA58: 4082FFE8  bne 0x829afa40
	if !ctx.cr[0].eq {
	pc = 0x829AFA40; continue 'dispatch;
	}
	// 829AFA5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFA60: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFA64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFA68: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829AFA6C: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFA70: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 829AFA74: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AFA78: 484AEC31  bl 0x82e5e6a8
	ctx.lr = 0x829AFA7C;
	sub_82E5E6A8(ctx, base);
	// 829AFA7C: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 829AFA80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AFA84: 419A0008  beq cr6, 0x829afa8c
	if ctx.cr[6].eq {
	pc = 0x829AFA8C; continue 'dispatch;
	}
	// 829AFA88: 4B910E09  bl 0x822c0890
	ctx.lr = 0x829AFA8C;
	sub_822C0890(ctx, base);
	// 829AFA8C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829AFA90: 480008D0  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AFA94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFA98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFA9C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AFAA0: 38A00C31  li r5, 0xc31
	ctx.r[5].s64 = 3121;
	// 829AFAA4: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AFAA8: 48442941  bl 0x82df23e8
	ctx.lr = 0x829AFAAC;
	sub_82DF23E8(ctx, base);
	// 829AFAAC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AFAB0: 4182001C  beq 0x829afacc
	if ctx.cr[0].eq {
	pc = 0x829AFACC; continue 'dispatch;
	}
	// 829AFAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AFAB8: 4800EAA1  bl 0x829be558
	ctx.lr = 0x829AFABC;
	sub_829BE558(ctx, base);
	// 829AFABC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFAC0: 396B1808  addi r11, r11, 0x1808
	ctx.r[11].s64 = ctx.r[11].s64 + 6152;
	// 829AFAC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AFAC8: 48000008  b 0x829afad0
	pc = 0x829AFAD0; continue 'dispatch;
	// 829AFACC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFAD0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFAD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFAD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFADC: 4BFF479D  bl 0x829a4278
	ctx.lr = 0x829AFAE0;
	sub_829A4278(ctx, base);
	// 829AFAE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFAE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFAE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFAEC: 4B910515  bl 0x822c0000
	ctx.lr = 0x829AFAF0;
	sub_822C0000(ctx, base);
	// 829AFAF0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFAF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFAF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFAFC: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 829AFB00: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829AFB04: 419A0024  beq cr6, 0x829afb28
	if ctx.cr[6].eq {
	pc = 0x829AFB28; continue 'dispatch;
	}
	// 829AFB08: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFB0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFB10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFB14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFB18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFB1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFB20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFB24: 4082FFE8  bne 0x829afb0c
	if !ctx.cr[0].eq {
	pc = 0x829AFB0C; continue 'dispatch;
	}
	// 829AFB28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFB2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFB30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFB34: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829AFB38: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFB3C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 829AFB40: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AFB44: 484AEB65  bl 0x82e5e6a8
	ctx.lr = 0x829AFB48;
	sub_82E5E6A8(ctx, base);
	// 829AFB48: 80610134  lwz r3, 0x134(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 829AFB4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AFB50: 419A0008  beq cr6, 0x829afb58
	if ctx.cr[6].eq {
	pc = 0x829AFB58; continue 'dispatch;
	}
	// 829AFB54: 4B910D3D  bl 0x822c0890
	ctx.lr = 0x829AFB58;
	sub_822C0890(ctx, base);
	// 829AFB58: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829AFB5C: 48000804  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AFB60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFB64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFB68: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AFB6C: 38A00C34  li r5, 0xc34
	ctx.r[5].s64 = 3124;
	// 829AFB70: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 829AFB74: 48442875  bl 0x82df23e8
	ctx.lr = 0x829AFB78;
	sub_82DF23E8(ctx, base);
	// 829AFB78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829AFB7C: 41820010  beq 0x829afb8c
	if ctx.cr[0].eq {
	pc = 0x829AFB8C; continue 'dispatch;
	}
	// 829AFB80: 4BFFA831  bl 0x829aa3b0
	ctx.lr = 0x829AFB84;
	sub_829AA3B0(ctx, base);
	// 829AFB84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829AFB88: 48000008  b 0x829afb90
	pc = 0x829AFB90; continue 'dispatch;
	// 829AFB8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFB90: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFB94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFB98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFB9C: 4BFF47A5  bl 0x829a4340
	ctx.lr = 0x829AFBA0;
	sub_829A4340(ctx, base);
	// 829AFBA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFBA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFBA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFBAC: 4B910455  bl 0x822c0000
	ctx.lr = 0x829AFBB0;
	sub_822C0000(ctx, base);
	// 829AFBB0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFBB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFBB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFBBC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 829AFBC0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829AFBC4: 419A0024  beq cr6, 0x829afbe8
	if ctx.cr[6].eq {
	pc = 0x829AFBE8; continue 'dispatch;
	}
	// 829AFBC8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFBCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFBD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFBD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFBD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFBDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFBE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFBE4: 4082FFE8  bne 0x829afbcc
	if !ctx.cr[0].eq {
	pc = 0x829AFBCC; continue 'dispatch;
	}
	// 829AFBE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFBEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFBF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFBF4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 829AFBF8: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFBFC: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 829AFC00: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AFC04: 484AEAA5  bl 0x82e5e6a8
	ctx.lr = 0x829AFC08;
	sub_82E5E6A8(ctx, base);
	// 829AFC08: 80610144  lwz r3, 0x144(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 829AFC0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AFC10: 419A0008  beq cr6, 0x829afc18
	if ctx.cr[6].eq {
	pc = 0x829AFC18; continue 'dispatch;
	}
	// 829AFC14: 4B910C7D  bl 0x822c0890
	ctx.lr = 0x829AFC18;
	sub_822C0890(ctx, base);
	// 829AFC18: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829AFC1C: 48000744  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AFC20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFC24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFC28: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AFC2C: 38A00C37  li r5, 0xc37
	ctx.r[5].s64 = 3127;
	// 829AFC30: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AFC34: 484427B5  bl 0x82df23e8
	ctx.lr = 0x829AFC38;
	sub_82DF23E8(ctx, base);
	// 829AFC38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AFC3C: 4182001C  beq 0x829afc58
	if ctx.cr[0].eq {
	pc = 0x829AFC58; continue 'dispatch;
	}
	// 829AFC40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AFC44: 4800E915  bl 0x829be558
	ctx.lr = 0x829AFC48;
	sub_829BE558(ctx, base);
	// 829AFC48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFC4C: 396B1830  addi r11, r11, 0x1830
	ctx.r[11].s64 = ctx.r[11].s64 + 6192;
	// 829AFC50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AFC54: 48000008  b 0x829afc5c
	pc = 0x829AFC5C; continue 'dispatch;
	// 829AFC58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFC5C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFC60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFC64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFC68: 4BFF47A1  bl 0x829a4408
	ctx.lr = 0x829AFC6C;
	sub_829A4408(ctx, base);
	// 829AFC6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFC70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFC74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFC78: 4B910389  bl 0x822c0000
	ctx.lr = 0x829AFC7C;
	sub_822C0000(ctx, base);
	// 829AFC7C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFC80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFC84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFC88: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 829AFC8C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 829AFC90: 419A0024  beq cr6, 0x829afcb4
	if ctx.cr[6].eq {
	pc = 0x829AFCB4; continue 'dispatch;
	}
	// 829AFC94: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFC98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFC9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFCA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFCA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFCA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFCAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFCB0: 4082FFE8  bne 0x829afc98
	if !ctx.cr[0].eq {
	pc = 0x829AFC98; continue 'dispatch;
	}
	// 829AFCB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFCB8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFCBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFCC0: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 829AFCC4: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFCC8: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829AFCCC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AFCD0: 484AE9D9  bl 0x82e5e6a8
	ctx.lr = 0x829AFCD4;
	sub_82E5E6A8(ctx, base);
	// 829AFCD4: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 829AFCD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AFCDC: 419A0008  beq cr6, 0x829afce4
	if ctx.cr[6].eq {
	pc = 0x829AFCE4; continue 'dispatch;
	}
	// 829AFCE0: 4B910BB1  bl 0x822c0890
	ctx.lr = 0x829AFCE4;
	sub_822C0890(ctx, base);
	// 829AFCE4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829AFCE8: 48000678  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AFCEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFCF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFCF4: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AFCF8: 38A00C3A  li r5, 0xc3a
	ctx.r[5].s64 = 3130;
	// 829AFCFC: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AFD00: 484426E9  bl 0x82df23e8
	ctx.lr = 0x829AFD04;
	sub_82DF23E8(ctx, base);
	// 829AFD04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AFD08: 4182001C  beq 0x829afd24
	if ctx.cr[0].eq {
	pc = 0x829AFD24; continue 'dispatch;
	}
	// 829AFD0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AFD10: 4800E849  bl 0x829be558
	ctx.lr = 0x829AFD14;
	sub_829BE558(ctx, base);
	// 829AFD14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFD18: 396B1858  addi r11, r11, 0x1858
	ctx.r[11].s64 = ctx.r[11].s64 + 6232;
	// 829AFD1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AFD20: 48000008  b 0x829afd28
	pc = 0x829AFD28; continue 'dispatch;
	// 829AFD24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFD28: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFD2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFD30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFD34: 4BFF479D  bl 0x829a44d0
	ctx.lr = 0x829AFD38;
	sub_829A44D0(ctx, base);
	// 829AFD38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFD3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFD40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFD44: 4B9102BD  bl 0x822c0000
	ctx.lr = 0x829AFD48;
	sub_822C0000(ctx, base);
	// 829AFD48: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFD4C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFD50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFD54: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 829AFD58: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 829AFD5C: 419A0024  beq cr6, 0x829afd80
	if ctx.cr[6].eq {
	pc = 0x829AFD80; continue 'dispatch;
	}
	// 829AFD60: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFD64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFD68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFD6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFD70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFD74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFD78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFD7C: 4082FFE8  bne 0x829afd64
	if !ctx.cr[0].eq {
	pc = 0x829AFD64; continue 'dispatch;
	}
	// 829AFD80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFD84: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFD88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFD8C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 829AFD90: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFD94: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 829AFD98: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AFD9C: 484AE90D  bl 0x82e5e6a8
	ctx.lr = 0x829AFDA0;
	sub_82E5E6A8(ctx, base);
	// 829AFDA0: 80610164  lwz r3, 0x164(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 829AFDA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AFDA8: 419A0008  beq cr6, 0x829afdb0
	if ctx.cr[6].eq {
	pc = 0x829AFDB0; continue 'dispatch;
	}
	// 829AFDAC: 4B910AE5  bl 0x822c0890
	ctx.lr = 0x829AFDB0;
	sub_822C0890(ctx, base);
	// 829AFDB0: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829AFDB4: 480005AC  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AFDB8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFDBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFDC0: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AFDC4: 38A00C3D  li r5, 0xc3d
	ctx.r[5].s64 = 3133;
	// 829AFDC8: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AFDCC: 4844261D  bl 0x82df23e8
	ctx.lr = 0x829AFDD0;
	sub_82DF23E8(ctx, base);
	// 829AFDD0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AFDD4: 4182001C  beq 0x829afdf0
	if ctx.cr[0].eq {
	pc = 0x829AFDF0; continue 'dispatch;
	}
	// 829AFDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AFDDC: 4800E77D  bl 0x829be558
	ctx.lr = 0x829AFDE0;
	sub_829BE558(ctx, base);
	// 829AFDE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFDE4: 396B1880  addi r11, r11, 0x1880
	ctx.r[11].s64 = ctx.r[11].s64 + 6272;
	// 829AFDE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AFDEC: 48000008  b 0x829afdf4
	pc = 0x829AFDF4; continue 'dispatch;
	// 829AFDF0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFDF4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFDF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFDFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFE00: 4BFF4799  bl 0x829a4598
	ctx.lr = 0x829AFE04;
	sub_829A4598(ctx, base);
	// 829AFE04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFE08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFE0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFE10: 4B9101F1  bl 0x822c0000
	ctx.lr = 0x829AFE14;
	sub_822C0000(ctx, base);
	// 829AFE14: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFE18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFE1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFE20: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 829AFE24: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 829AFE28: 419A0024  beq cr6, 0x829afe4c
	if ctx.cr[6].eq {
	pc = 0x829AFE4C; continue 'dispatch;
	}
	// 829AFE2C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFE30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFE34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFE38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFE3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFE40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFE44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFE48: 4082FFE8  bne 0x829afe30
	if !ctx.cr[0].eq {
	pc = 0x829AFE30; continue 'dispatch;
	}
	// 829AFE4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFE50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFE54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFE58: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829AFE5C: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFE60: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 829AFE64: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AFE68: 484AE841  bl 0x82e5e6a8
	ctx.lr = 0x829AFE6C;
	sub_82E5E6A8(ctx, base);
	// 829AFE6C: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 829AFE70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AFE74: 419A0008  beq cr6, 0x829afe7c
	if ctx.cr[6].eq {
	pc = 0x829AFE7C; continue 'dispatch;
	}
	// 829AFE78: 4B910A19  bl 0x822c0890
	ctx.lr = 0x829AFE7C;
	sub_822C0890(ctx, base);
	// 829AFE7C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 829AFE80: 480004E0  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AFE84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFE88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFE8C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AFE90: 38A00C40  li r5, 0xc40
	ctx.r[5].s64 = 3136;
	// 829AFE94: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AFE98: 48442551  bl 0x82df23e8
	ctx.lr = 0x829AFE9C;
	sub_82DF23E8(ctx, base);
	// 829AFE9C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AFEA0: 4182001C  beq 0x829afebc
	if ctx.cr[0].eq {
	pc = 0x829AFEBC; continue 'dispatch;
	}
	// 829AFEA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AFEA8: 4800E6B1  bl 0x829be558
	ctx.lr = 0x829AFEAC;
	sub_829BE558(ctx, base);
	// 829AFEAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFEB0: 396B18A8  addi r11, r11, 0x18a8
	ctx.r[11].s64 = ctx.r[11].s64 + 6312;
	// 829AFEB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AFEB8: 48000008  b 0x829afec0
	pc = 0x829AFEC0; continue 'dispatch;
	// 829AFEBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFEC0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFEC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFEC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFECC: 4BFF4795  bl 0x829a4660
	ctx.lr = 0x829AFED0;
	sub_829A4660(ctx, base);
	// 829AFED0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFED4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFED8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFEDC: 4B910125  bl 0x822c0000
	ctx.lr = 0x829AFEE0;
	sub_822C0000(ctx, base);
	// 829AFEE0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFEE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFEE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFEEC: 93E100C4  stw r31, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[31].u32 ) };
	// 829AFEF0: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 829AFEF4: 419A0024  beq cr6, 0x829aff18
	if ctx.cr[6].eq {
	pc = 0x829AFF18; continue 'dispatch;
	}
	// 829AFEF8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFEFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFF00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFF04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFF08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFF0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFF10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFF14: 4082FFE8  bne 0x829afefc
	if !ctx.cr[0].eq {
	pc = 0x829AFEFC; continue 'dispatch;
	}
	// 829AFF18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFF1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFF20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFF24: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 829AFF28: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFF2C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 829AFF30: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829AFF34: 484AE775  bl 0x82e5e6a8
	ctx.lr = 0x829AFF38;
	sub_82E5E6A8(ctx, base);
	// 829AFF38: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 829AFF3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829AFF40: 419A0008  beq cr6, 0x829aff48
	if ctx.cr[6].eq {
	pc = 0x829AFF48; continue 'dispatch;
	}
	// 829AFF44: 4B91094D  bl 0x822c0890
	ctx.lr = 0x829AFF48;
	sub_822C0890(ctx, base);
	// 829AFF48: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 829AFF4C: 48000414  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829AFF50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFF54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFF58: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829AFF5C: 38A00C43  li r5, 0xc43
	ctx.r[5].s64 = 3139;
	// 829AFF60: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829AFF64: 48442485  bl 0x82df23e8
	ctx.lr = 0x829AFF68;
	sub_82DF23E8(ctx, base);
	// 829AFF68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829AFF6C: 4182001C  beq 0x829aff88
	if ctx.cr[0].eq {
	pc = 0x829AFF88; continue 'dispatch;
	}
	// 829AFF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829AFF74: 4800E5E5  bl 0x829be558
	ctx.lr = 0x829AFF78;
	sub_829BE558(ctx, base);
	// 829AFF78: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829AFF7C: 396B18D0  addi r11, r11, 0x18d0
	ctx.r[11].s64 = ctx.r[11].s64 + 6352;
	// 829AFF80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829AFF84: 48000008  b 0x829aff8c
	pc = 0x829AFF8C; continue 'dispatch;
	// 829AFF88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829AFF8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829AFF90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFF94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFF98: 4BFF4791  bl 0x829a4728
	ctx.lr = 0x829AFF9C;
	sub_829A4728(ctx, base);
	// 829AFF9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829AFFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829AFFA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829AFFA8: 4B910059  bl 0x822c0000
	ctx.lr = 0x829AFFAC;
	sub_822C0000(ctx, base);
	// 829AFFAC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829AFFB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829AFFB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829AFFB8: 93E100D4  stw r31, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[31].u32 ) };
	// 829AFFBC: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 829AFFC0: 419A0024  beq cr6, 0x829affe4
	if ctx.cr[6].eq {
	pc = 0x829AFFE4; continue 'dispatch;
	}
	// 829AFFC4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829AFFC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829AFFCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFFD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829AFFD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829AFFD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829AFFDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829AFFE0: 4082FFE8  bne 0x829affc8
	if !ctx.cr[0].eq {
	pc = 0x829AFFC8; continue 'dispatch;
	}
	// 829AFFE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829AFFE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829AFFEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829AFFF0: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 829AFFF4: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829AFFF8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 829AFFFC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B0000: 484AE6A9  bl 0x82e5e6a8
	ctx.lr = 0x829B0004;
	sub_82E5E6A8(ctx, base);
	// 829B0004: 80610194  lwz r3, 0x194(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 829B0008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B000C: 419A0008  beq cr6, 0x829b0014
	if ctx.cr[6].eq {
	pc = 0x829B0014; continue 'dispatch;
	}
	// 829B0010: 4B910881  bl 0x822c0890
	ctx.lr = 0x829B0014;
	sub_822C0890(ctx, base);
	// 829B0014: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 829B0018: 48000348  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829B001C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0020: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B0024: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829B0028: 38A00C46  li r5, 0xc46
	ctx.r[5].s64 = 3142;
	// 829B002C: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 829B0030: 484423B9  bl 0x82df23e8
	ctx.lr = 0x829B0034;
	sub_82DF23E8(ctx, base);
	// 829B0034: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829B0038: 4182001C  beq 0x829b0054
	if ctx.cr[0].eq {
	pc = 0x829B0054; continue 'dispatch;
	}
	// 829B003C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0040: 4800E519  bl 0x829be558
	ctx.lr = 0x829B0044;
	sub_829BE558(ctx, base);
	// 829B0044: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0048: 396B18F8  addi r11, r11, 0x18f8
	ctx.r[11].s64 = ctx.r[11].s64 + 6392;
	// 829B004C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B0050: 48000008  b 0x829b0058
	pc = 0x829B0058; continue 'dispatch;
	// 829B0054: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B0058: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829B005C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0060: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B0064: 4BFF478D  bl 0x829a47f0
	ctx.lr = 0x829B0068;
	sub_829A47F0(ctx, base);
	// 829B0068: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B006C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B0074: 4B90FF8D  bl 0x822c0000
	ctx.lr = 0x829B0078;
	sub_822C0000(ctx, base);
	// 829B0078: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B007C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B0080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B0084: 93E100E4  stw r31, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[31].u32 ) };
	// 829B0088: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 829B008C: 419A0024  beq cr6, 0x829b00b0
	if ctx.cr[6].eq {
	pc = 0x829B00B0; continue 'dispatch;
	}
	// 829B0090: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B0094: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B0098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B009C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B00A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B00A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B00A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B00AC: 4082FFE8  bne 0x829b0094
	if !ctx.cr[0].eq {
	pc = 0x829B0094; continue 'dispatch;
	}
	// 829B00B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B00B4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829B00B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B00BC: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 829B00C0: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829B00C4: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 829B00C8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B00CC: 484AE5DD  bl 0x82e5e6a8
	ctx.lr = 0x829B00D0;
	sub_82E5E6A8(ctx, base);
	// 829B00D0: 806101A4  lwz r3, 0x1a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 829B00D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B00D8: 419A0008  beq cr6, 0x829b00e0
	if ctx.cr[6].eq {
	pc = 0x829B00E0; continue 'dispatch;
	}
	// 829B00DC: 4B9107B5  bl 0x822c0890
	ctx.lr = 0x829B00E0;
	sub_822C0890(ctx, base);
	// 829B00E0: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 829B00E4: 4800027C  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829B00E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B00EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B00F0: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829B00F4: 38A00C49  li r5, 0xc49
	ctx.r[5].s64 = 3145;
	// 829B00F8: 386001C0  li r3, 0x1c0
	ctx.r[3].s64 = 448;
	// 829B00FC: 484422ED  bl 0x82df23e8
	ctx.lr = 0x829B0100;
	sub_82DF23E8(ctx, base);
	// 829B0100: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829B0104: 41820028  beq 0x829b012c
	if ctx.cr[0].eq {
	pc = 0x829B012C; continue 'dispatch;
	}
	// 829B0108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B010C: 4800E44D  bl 0x829be558
	ctx.lr = 0x829B0110;
	sub_829BE558(ctx, base);
	// 829B0110: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B0114: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B0118: 394A1920  addi r10, r10, 0x1920
	ctx.r[10].s64 = ctx.r[10].s64 + 6432;
	// 829B011C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829B0120: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 829B0124: 917F01B4  stw r11, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 829B0128: 48000008  b 0x829b0130
	pc = 0x829B0130; continue 'dispatch;
	// 829B012C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B0130: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829B0134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0138: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B013C: 4BFF477D  bl 0x829a48b8
	ctx.lr = 0x829B0140;
	sub_829A48B8(ctx, base);
	// 829B0140: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B0144: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0148: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B014C: 4B90FEB5  bl 0x822c0000
	ctx.lr = 0x829B0150;
	sub_822C0000(ctx, base);
	// 829B0150: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B0154: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B0158: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B015C: 93E100F4  stw r31, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[31].u32 ) };
	// 829B0160: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 829B0164: 419A0024  beq cr6, 0x829b0188
	if ctx.cr[6].eq {
	pc = 0x829B0188; continue 'dispatch;
	}
	// 829B0168: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B016C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B0170: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0174: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B0178: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B017C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B0180: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0184: 4082FFE8  bne 0x829b016c
	if !ctx.cr[0].eq {
	pc = 0x829B016C; continue 'dispatch;
	}
	// 829B0188: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B018C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829B0190: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B0194: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 829B0198: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829B019C: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 829B01A0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B01A4: 484AE505  bl 0x82e5e6a8
	ctx.lr = 0x829B01A8;
	sub_82E5E6A8(ctx, base);
	// 829B01A8: 806101B4  lwz r3, 0x1b4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 829B01AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B01B0: 419A0008  beq cr6, 0x829b01b8
	if ctx.cr[6].eq {
	pc = 0x829B01B8; continue 'dispatch;
	}
	// 829B01B4: 4B9106DD  bl 0x822c0890
	ctx.lr = 0x829B01B8;
	sub_822C0890(ctx, base);
	// 829B01B8: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 829B01BC: 480001A4  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829B01C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B01C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B01C8: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829B01CC: 38A00C4D  li r5, 0xc4d
	ctx.r[5].s64 = 3149;
	// 829B01D0: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 829B01D4: 48442215  bl 0x82df23e8
	ctx.lr = 0x829B01D8;
	sub_82DF23E8(ctx, base);
	// 829B01D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829B01DC: 4182001C  beq 0x829b01f8
	if ctx.cr[0].eq {
	pc = 0x829B01F8; continue 'dispatch;
	}
	// 829B01E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B01E4: 484AC745  bl 0x82e5c928
	ctx.lr = 0x829B01E8;
	sub_82E5C928(ctx, base);
	// 829B01E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B01EC: 396B162C  addi r11, r11, 0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + 5676;
	// 829B01F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B01F4: 48000008  b 0x829b01fc
	pc = 0x829B01FC; continue 'dispatch;
	// 829B01F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B01FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829B0200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0204: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B0208: 4BFF4779  bl 0x829a4980
	ctx.lr = 0x829B020C;
	sub_829A4980(ctx, base);
	// 829B020C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B0210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0214: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B0218: 4B90FDE9  bl 0x822c0000
	ctx.lr = 0x829B021C;
	sub_822C0000(ctx, base);
	// 829B021C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B0220: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B0224: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B0228: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 829B022C: 91610100  stw r11, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 829B0230: 419A0024  beq cr6, 0x829b0254
	if ctx.cr[6].eq {
	pc = 0x829B0254; continue 'dispatch;
	}
	// 829B0234: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B0238: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B023C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0240: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B0244: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B0248: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B024C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0250: 4082FFE8  bne 0x829b0238
	if !ctx.cr[0].eq {
	pc = 0x829B0238; continue 'dispatch;
	}
	// 829B0254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B0258: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829B025C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B0260: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 829B0264: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829B0268: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 829B026C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B0270: 484AE439  bl 0x82e5e6a8
	ctx.lr = 0x829B0274;
	sub_82E5E6A8(ctx, base);
	// 829B0274: 806101C4  lwz r3, 0x1c4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 829B0278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B027C: 419A0008  beq cr6, 0x829b0284
	if ctx.cr[6].eq {
	pc = 0x829B0284; continue 'dispatch;
	}
	// 829B0280: 4B910611  bl 0x822c0890
	ctx.lr = 0x829B0284;
	sub_822C0890(ctx, base);
	// 829B0284: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 829B0288: 480000D8  b 0x829b0360
	pc = 0x829B0360; continue 'dispatch;
	// 829B028C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0290: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B0294: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 829B0298: 38A00C50  li r5, 0xc50
	ctx.r[5].s64 = 3152;
	// 829B029C: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 829B02A0: 48442149  bl 0x82df23e8
	ctx.lr = 0x829B02A4;
	sub_82DF23E8(ctx, base);
	// 829B02A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829B02A8: 41820028  beq 0x829b02d0
	if ctx.cr[0].eq {
	pc = 0x829B02D0; continue 'dispatch;
	}
	// 829B02AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B02B0: 484AC679  bl 0x82e5c928
	ctx.lr = 0x829B02B4;
	sub_82E5C928(ctx, base);
	// 829B02B4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B02B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B02BC: 394A1948  addi r10, r10, 0x1948
	ctx.r[10].s64 = ctx.r[10].s64 + 6472;
	// 829B02C0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829B02C4: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 829B02C8: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 829B02CC: 48000008  b 0x829b02d4
	pc = 0x829B02D4; continue 'dispatch;
	// 829B02D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B02D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829B02D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B02DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B02E0: 4BFF4769  bl 0x829a4a48
	ctx.lr = 0x829B02E4;
	sub_829A4A48(ctx, base);
	// 829B02E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B02E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B02EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B02F0: 4B90FD11  bl 0x822c0000
	ctx.lr = 0x829B02F4;
	sub_822C0000(ctx, base);
	// 829B02F4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B02F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B02FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B0300: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829B0304: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829B0308: 419A0024  beq cr6, 0x829b032c
	if ctx.cr[6].eq {
	pc = 0x829B032C; continue 'dispatch;
	}
	// 829B030C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B0310: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B0314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0318: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B031C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B0320: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B0324: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0328: 4082FFE8  bne 0x829b0310
	if !ctx.cr[0].eq {
	pc = 0x829B0310; continue 'dispatch;
	}
	// 829B032C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B0330: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829B0334: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B0338: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829B033C: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829B0340: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 829B0344: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B0348: 484AE361  bl 0x82e5e6a8
	ctx.lr = 0x829B034C;
	sub_82E5E6A8(ctx, base);
	// 829B034C: 806101D4  lwz r3, 0x1d4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 829B0350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0354: 419A0008  beq cr6, 0x829b035c
	if ctx.cr[6].eq {
	pc = 0x829B035C; continue 'dispatch;
	}
	// 829B0358: 4B910539  bl 0x822c0890
	ctx.lr = 0x829B035C;
	sub_822C0890(ctx, base);
	// 829B035C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829B0360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0364: 419A0008  beq cr6, 0x829b036c
	if ctx.cr[6].eq {
	pc = 0x829B036C; continue 'dispatch;
	}
	// 829B0368: 4B910529  bl 0x822c0890
	ctx.lr = 0x829B036C;
	sub_822C0890(ctx, base);
	// 829B036C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B0370: 419A000C  beq cr6, 0x829b037c
	if ctx.cr[6].eq {
	pc = 0x829B037C; continue 'dispatch;
	}
	// 829B0374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0378: 4B910519  bl 0x822c0890
	ctx.lr = 0x829B037C;
	sub_822C0890(ctx, base);
	// 829B037C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 829B0380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B0388: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B038C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B0390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0398 size=248
    //   switch @ 0x829B0438: r30 with 12 label(s)
    //       case  0  0x829B0448
    //       case  1  0x829B0448
    //       case  2  0x829B0460
    //       case  3  0x829B0460
    //       case  4  0x829B0460
    //       case  5  0x829B0448
    //       case  6  0x829B0470
    //       case  7  0x829B0470
    //       case  8  0x829B0448
    //       case  9  0x829B0468
    //       case 10  0x829B0468
    //       case 11  0x829B0448
    let mut pc: u32 = 0x829B0398;
    'dispatch: loop {
        match pc {
            0x829B0398 => {
    //   block [0x829B0398..0x829B0448)
	// 829B0398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B039C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B03A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B03A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B03A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B03AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B03B0: 4BFF2CE9  bl 0x829a3098
	ctx.lr = 0x829B03B4;
	sub_829A3098(ctx, base);
	// 829B03B4: 897F046C  lbz r11, 0x46c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1132 as u32) ) } as u64;
	// 829B03B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B03BC: 408200BC  bne 0x829b0478
	if !ctx.cr[0].eq {
	pc = 0x829B0478; continue 'dispatch;
	}
	// 829B03C0: 897F03D8  lbz r11, 0x3d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) } as u64;
	// 829B03C4: 7C7E0774  extsb r30, r3
	ctx.r[30].s64 = ctx.r[3].s8 as i64;
	// 829B03C8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B03CC: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 829B03D0: 409A00A8  bne cr6, 0x829b0478
	if !ctx.cr[6].eq {
	pc = 0x829B0478; continue 'dispatch;
	}
	// 829B03D4: 897F03B4  lbz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 829B03D8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B03DC: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 829B03E0: 4098000C  bge cr6, 0x829b03ec
	if !ctx.cr[6].lt {
	pc = 0x829B03EC; continue 'dispatch;
	}
	// 829B03E4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829B03E8: 48000014  b 0x829b03fc
	pc = 0x829B03FC; continue 'dispatch;
	// 829B03EC: 2F0B0046  cmpwi cr6, r11, 0x46
	ctx.cr[6].compare_i32(ctx.r[11].s32, 70, &mut ctx.xer);
	// 829B03F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B03F4: 41980008  blt cr6, 0x829b03fc
	if ctx.cr[6].lt {
	pc = 0x829B03FC; continue 'dispatch;
	}
	// 829B03F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B03FC: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829B0400: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B0404: 394A9258  addi r10, r10, -0x6da8
	ctx.r[10].s64 = ctx.r[10].s64 + -28072;
	// 829B0408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B040C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829B0410: 7C8BF0AE  lbzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 829B0414: 4BFFEBB5  bl 0x829aefc8
	ctx.lr = 0x829B0418;
	sub_829AEFC8(ctx, base);
	// 829B0418: 2B1E000B  cmplwi cr6, r30, 0xb
	ctx.cr[6].compare_u32(ctx.r[30].u32, 11 as u32, &mut ctx.xer);
	// 829B041C: 4199005C  bgt cr6, 0x829b0478
	if ctx.cr[6].gt {
	pc = 0x829B0478; continue 'dispatch;
	}
	// 829B0420: 3D80820A  lis r12, -0x7df6
	ctx.r[12].s64 = -2113273856;
	// 829B0424: 398C1380  addi r12, r12, 0x1380
	ctx.r[12].s64 = ctx.r[12].s64 + 4992;
	// 829B0428: 7C0CF0AE  lbzx r0, r12, r30
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 829B042C: 3D80829B  lis r12, -0x7d65
	ctx.r[12].s64 = -2103771136;
	// 829B0430: 398C0448  addi r12, r12, 0x448
	ctx.r[12].s64 = ctx.r[12].s64 + 1096;
	// 829B0434: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 829B0438: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 829B043C: 60000000  nop
	// 829B0440: 60000000  nop
	// 829B0444: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x829B0448 => {
    //   block [0x829B0448..0x829B0460)
	// 829B0448: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 829B044C: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 829B0450: 7D4B53D6  divw r10, r11, r10
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 829B0454: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 829B0458: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829B045C: 48000018  b 0x829b0474
	pc = 0x829B0474; continue 'dispatch;
            }
            0x829B0460 => {
    //   block [0x829B0460..0x829B0468)
	// 829B0460: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 829B0464: 48000010  b 0x829b0474
	pc = 0x829B0474; continue 'dispatch;
            }
            0x829B0468 => {
    //   block [0x829B0468..0x829B0470)
	// 829B0468: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 829B046C: 48000008  b 0x829b0474
	pc = 0x829B0474; continue 'dispatch;
            }
            0x829B0470 => {
    //   block [0x829B0470..0x829B0490)
	// 829B0470: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 829B0474: 997F03D8  stb r11, 0x3d8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(984 as u32), ctx.r[11].u8 ) };
	// 829B0478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B047C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B0484: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B0488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B048C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B0490 size=100
    let mut pc: u32 = 0x829B0490;
    'dispatch: loop {
        match pc {
            0x829B0490 => {
    //   block [0x829B0490..0x829B04F4)
	// 829B0490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B049C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B04A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B04A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B04A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B04AC: 4BB6025D  bl 0x82510708
	ctx.lr = 0x829B04B0;
	sub_82510708(ctx, base);
	// 829B04B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B04B4: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B04B8: 4BFF6C69  bl 0x829a7120
	ctx.lr = 0x829B04BC;
	sub_829A7120(ctx, base);
	// 829B04BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B04C0: 4BFFFED9  bl 0x829b0398
	ctx.lr = 0x829B04C4;
	sub_829B0398(ctx, base);
	// 829B04C4: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829B04C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B04CC: 484AC9AD  bl 0x82e5ce78
	ctx.lr = 0x829B04D0;
	sub_82E5CE78(ctx, base);
	// 829B04D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B04D4: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B04D8: 4BFF6069  bl 0x829a6540
	ctx.lr = 0x829B04DC;
	sub_829A6540(ctx, base);
	// 829B04DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B04E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B04E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B04E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B04EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B04F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B04F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B04F8 size=108
    let mut pc: u32 = 0x829B04F8;
    'dispatch: loop {
        match pc {
            0x829B04F8 => {
    //   block [0x829B04F8..0x829B0564)
	// 829B04F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B04FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B0504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B050C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B0510: C01F0124  lfs f0, 0x124(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B0514: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B0518: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B051C: 40990018  ble cr6, 0x829b0534
	if !ctx.cr[6].gt {
	pc = 0x829B0534; continue 'dispatch;
	}
	// 829B0520: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 829B0524: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 829B0528: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B052C: 41990008  bgt cr6, 0x829b0534
	if ctx.cr[6].gt {
	pc = 0x829B0534; continue 'dispatch;
	}
	// 829B0530: 4BB600A1  bl 0x825105d0
	ctx.lr = 0x829B0534;
	sub_825105D0(ctx, base);
	// 829B0534: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0538: C1BF0120  lfs f13, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B053C: C00B2120  lfs f0, 0x2120(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B0540: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B0544: 4198000C  blt cr6, 0x829b0550
	if ctx.cr[6].lt {
	pc = 0x829B0550; continue 'dispatch;
	}
	// 829B0548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B054C: 4BB60085  bl 0x825105d0
	ctx.lr = 0x829B0550;
	sub_825105D0(ctx, base);
	// 829B0550: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B0554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B055C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B0560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B0568 size=16
    let mut pc: u32 = 0x829B0568;
    'dispatch: loop {
        match pc {
            0x829B0568 => {
    //   block [0x829B0568..0x829B0578)
	// 829B0568: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B056C: C00B2124  lfs f0, 0x2124(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8484 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B0570: D0030124  stfs f0, 0x124(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 829B0574: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0578 size=136
    let mut pc: u32 = 0x829B0578;
    'dispatch: loop {
        match pc {
            0x829B0578 => {
    //   block [0x829B0578..0x829B0600)
	// 829B0578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B057C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B0584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B0588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B058C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B0590: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B0594: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829B0598: 409A0020  bne cr6, 0x829b05b8
	if !ctx.cr[6].eq {
	pc = 0x829B05B8; continue 'dispatch;
	}
	// 829B059C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B05A0: 419A0048  beq cr6, 0x829b05e8
	if ctx.cr[6].eq {
	pc = 0x829B05E8; continue 'dispatch;
	}
	// 829B05A4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829B05A8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829B05AC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829B05B0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829B05B4: 48000034  b 0x829b05e8
	pc = 0x829B05E8; continue 'dispatch;
	// 829B05B8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829B05BC: 419A002C  beq cr6, 0x829b05e8
	if ctx.cr[6].eq {
	pc = 0x829B05E8; continue 'dispatch;
	}
	// 829B05C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B05C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B05C8: 388B9278  addi r4, r11, -0x6d88
	ctx.r[4].s64 = ctx.r[11].s64 + -28040;
	// 829B05CC: 487F7B2D  bl 0x831a80f8
	ctx.lr = 0x829B05D0;
	sub_831A80F8(ctx, base);
	// 829B05D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B05D4: 4182000C  beq 0x829b05e0
	if ctx.cr[0].eq {
	pc = 0x829B05E0; continue 'dispatch;
	}
	// 829B05D8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829B05DC: 4800000C  b 0x829b05e8
	pc = 0x829B05E8; continue 'dispatch;
	// 829B05E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B05E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B05E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B05EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B05F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B05F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B05F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B05FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B0600 size=76
    let mut pc: u32 = 0x829B0600;
    'dispatch: loop {
        match pc {
            0x829B0600 => {
    //   block [0x829B0600..0x829B064C)
	// 829B0600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B060C: 39600120  li r11, 0x120
	ctx.r[11].s64 = 288;
	// 829B0610: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 829B0614: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 829B0618: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 829B061C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B0620: 13E35C07  vcmpneb. (lvlx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0650 size=196
    let mut pc: u32 = 0x829B0650;
    'dispatch: loop {
        match pc {
            0x829B0650 => {
    //   block [0x829B0650..0x829B0714)
	// 829B0650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B065C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B0660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0664: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B0668: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B066C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B0670: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B0674: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B0678: 4B9102C1  bl 0x822c0938
	ctx.lr = 0x829B067C;
	sub_822C0938(ctx, base);
	// 829B067C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B0680: 41820028  beq 0x829b06a8
	if ctx.cr[0].eq {
	pc = 0x829B06A8; continue 'dispatch;
	}
	// 829B0684: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0688: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B068C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B0690: 392B212C  addi r9, r11, 0x212c
	ctx.r[9].s64 = ctx.r[11].s64 + 8492;
	// 829B0694: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B0698: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B069C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B06A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B06A4: 48000008  b 0x829b06ac
	pc = 0x829B06AC; continue 'dispatch;
	// 829B06A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B06AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B06B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B06B4: 409A0044  bne cr6, 0x829b06f8
	if !ctx.cr[6].eq {
	pc = 0x829B06F8; continue 'dispatch;
	}
	// 829B06B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B06BC: 419A001C  beq cr6, 0x829b06d8
	if ctx.cr[6].eq {
	pc = 0x829B06D8; continue 'dispatch;
	}
	// 829B06C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B06C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B06C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B06CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B06D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B06D4: 4E800421  bctrl
	ctx.lr = 0x829B06D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B06D8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B06DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B06E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B06E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B06E8: 816B9270  lwz r11, -0x6d90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28048 as u32) ) } as u64;
	// 829B06EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B06F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B06F4: 4B90F90D  bl 0x822c0000
	ctx.lr = 0x829B06F8;
	sub_822C0000(ctx, base);
	// 829B06F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B06FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B0700: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0704: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B0708: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B070C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B0710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0718 size=72
    let mut pc: u32 = 0x829B0718;
    'dispatch: loop {
        match pc {
            0x829B0718 => {
    //   block [0x829B0718..0x829B0760)
	// 829B0718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B071C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0720: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0724: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829B0728: 419A001C  beq cr6, 0x829b0744
	if ctx.cr[6].eq {
	pc = 0x829B0744; continue 'dispatch;
	}
	// 829B072C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829B0730: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829B0734: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829B0738: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B073C: 4BFFFE3D  bl 0x829b0578
	ctx.lr = 0x829B0740;
	sub_829B0578(ctx, base);
	// 829B0740: 48000010  b 0x829b0750
	pc = 0x829B0750; continue 'dispatch;
	// 829B0744: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B0748: 396B9278  addi r11, r11, -0x6d88
	ctx.r[11].s64 = ctx.r[11].s64 + -28040;
	// 829B074C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B0750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B0754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B075C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B0760 size=280
    let mut pc: u32 = 0x829B0760;
    'dispatch: loop {
        match pc {
            0x829B0760 => {
    //   block [0x829B0760..0x829B0878)
	// 829B0760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0764: 487F79F9  bl 0x831a815c
	ctx.lr = 0x829B0768;
	sub_831A8130(ctx, base);
	// 829B0768: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 829B076C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829B0770: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0774: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B0778: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 829B077C: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 829B0780: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 829B0784: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B0788: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829B078C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B0790: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B0794: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B0798: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 829B079C: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829B07A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B07A4: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829B07A8: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 829B07AC: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829B07B0: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 829B07B4: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 829B07B8: 4BB61AA9  bl 0x82512260
	ctx.lr = 0x829B07BC;
	sub_82512260(ctx, base);
	// 829B07BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B07C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B07C4: 392B2154  addi r9, r11, 0x2154
	ctx.r[9].s64 = ctx.r[11].s64 + 8532;
	// 829B07C8: 394A2140  addi r10, r10, 0x2140
	ctx.r[10].s64 = ctx.r[10].s64 + 8512;
	// 829B07CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B07D0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B07D4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829B07D8: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 829B07DC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829B07E0: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 829B07E4: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829B07E8: 397F0110  addi r11, r31, 0x110
	ctx.r[11].s64 = ctx.r[31].s64 + 272;
	// 829B07EC: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 829B07F0: 13E0D0C7  vcmpequd (lvx128) v31, v0, v26
	tmp.u32 = ctx.r[26].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B0878 size=8
    let mut pc: u32 = 0x829B0878;
    'dispatch: loop {
        match pc {
            0x829B0878 => {
    //   block [0x829B0878..0x829B0880)
	// 829B0878: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829B087C: 4800021C  b 0x829b0a98
	sub_829B0A98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0880 size=104
    let mut pc: u32 = 0x829B0880;
    'dispatch: loop {
        match pc {
            0x829B0880 => {
    //   block [0x829B0880..0x829B08E8)
	// 829B0880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0888: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B088C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B0894: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0898: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B089C: 396B2154  addi r11, r11, 0x2154
	ctx.r[11].s64 = ctx.r[11].s64 + 8532;
	// 829B08A0: 394A2140  addi r10, r10, 0x2140
	ctx.r[10].s64 = ctx.r[10].s64 + 8512;
	// 829B08A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B08A8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829B08AC: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B08B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B08B4: 419A0008  beq cr6, 0x829b08bc
	if ctx.cr[6].eq {
	pc = 0x829B08BC; continue 'dispatch;
	}
	// 829B08B8: 4B90FFD9  bl 0x822c0890
	ctx.lr = 0x829B08BC;
	sub_822C0890(ctx, base);
	// 829B08BC: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829B08C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B08C4: 419A0008  beq cr6, 0x829b08cc
	if ctx.cr[6].eq {
	pc = 0x829B08CC; continue 'dispatch;
	}
	// 829B08C8: 4B90FFC9  bl 0x822c0890
	ctx.lr = 0x829B08CC;
	sub_822C0890(ctx, base);
	// 829B08CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B08D0: 4B99EA81  bl 0x8234f350
	ctx.lr = 0x829B08D4;
	sub_8234F350(ctx, base);
	// 829B08D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B08D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B08DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B08E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B08E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B08E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B08E8 size=144
    let mut pc: u32 = 0x829B08E8;
    'dispatch: loop {
        match pc {
            0x829B08E8 => {
    //   block [0x829B08E8..0x829B0978)
	// 829B08E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B08EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B08F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B08F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B08F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B08FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B0900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B0904: 4BB5A04D  bl 0x8250a950
	ctx.lr = 0x829B0908;
	sub_8250A950(ctx, base);
	// 829B0908: 3BFF00E4  addi r31, r31, 0xe4
	ctx.r[31].s64 = ctx.r[31].s64 + 228;
	// 829B090C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0914: 419A0044  beq cr6, 0x829b0958
	if ctx.cr[6].eq {
	pc = 0x829B0958; continue 'dispatch;
	}
	// 829B0918: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B091C: 484D0E25  bl 0x82e81740
	ctx.lr = 0x829B0920;
	sub_82E81740(ctx, base);
	// 829B0920: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B0924: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829B0928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B092C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829B0930: 409A0008  bne cr6, 0x829b0938
	if !ctx.cr[6].eq {
	pc = 0x829B0938; continue 'dispatch;
	}
	// 829B0934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B0938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B093C: 4BE23035  bl 0x827d3970
	ctx.lr = 0x829B0940;
	sub_827D3970(ctx, base);
	// 829B0940: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829B0944: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B0948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B094C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829B0950: 419A0008  beq cr6, 0x829b0958
	if ctx.cr[6].eq {
	pc = 0x829B0958; continue 'dispatch;
	}
	// 829B0954: 4B90FF3D  bl 0x822c0890
	ctx.lr = 0x829B0958;
	sub_822C0890(ctx, base);
	// 829B0958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B095C: 48441335  bl 0x82df1c90
	ctx.lr = 0x829B0960;
	sub_82DF1C90(ctx, base);
	// 829B0960: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B0964: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0968: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B096C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B0970: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B0974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B0978 size=20
    let mut pc: u32 = 0x829B0978;
    'dispatch: loop {
        match pc {
            0x829B0978 => {
    //   block [0x829B0978..0x829B098C)
	// 829B0978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B097C: C0030124  lfs f0, 0x124(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B0980: C12B08A4  lfs f9, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829B0984: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 829B0988: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B098C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B098C size=20
    let mut pc: u32 = 0x829B098C;
    'dispatch: loop {
        match pc {
            0x829B098C => {
    //   block [0x829B098C..0x829B09A0)
	// 829B098C: 8124015C  lwz r9, 0x15c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(348 as u32) ) } as u64;
	// 829B0990: 39440158  addi r10, r4, 0x158
	ctx.r[10].s64 = ctx.r[4].s64 + 344;
	// 829B0994: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0998: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829B099C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B09A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B09A0 size=152
    let mut pc: u32 = 0x829B09A0;
    'dispatch: loop {
        match pc {
            0x829B09A0 => {
    //   block [0x829B09A0..0x829B0A38)
	// 829B09A0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829B09A4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829B09A8: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 829B09AC: 3CC08203  lis r6, -0x7dfd
	ctx.r[6].s64 = -2113732608;
	// 829B09B0: C1499524  lfs f10, -0x6adc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829B09B4: C16808A8  lfs f11, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B09B8: C1872514  lfs f12, 0x2514(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9492 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B09BC: C1A6B41C  lfs f13, -0x4be4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-19428 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B09C0: C0030120  lfs f0, 0x120(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B09C4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B09C8: C1030124  lfs f8, 0x124(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(292 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 829B09CC: ED0802B2  fmuls f8, f8, f10
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 829B09D0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 829B09D4: ECEB0028  fsubs f7, f11, f0
	ctx.f[7].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B09D8: EC07023A  fmadds f0, f7, f8, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 829B09DC: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 829B09E0: 41990008  bgt cr6, 0x829b09e8
	if ctx.cr[6].gt {
	pc = 0x829B09E8; continue 'dispatch;
	}
	// 829B09E4: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 829B09E8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829B09EC: 81090080  lwz r8, 0x80(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) } as u64;
	// 829B09F0: 9101FFE0  stw r8, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u32 ) };
	// 829B09F4: 8901FFE0  lbz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 829B09F8: F901FFE8  std r8, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[8].u64 ) };
	// 829B09FC: C901FFE8  lfd f8, -0x18(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B0A00: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 829B0A04: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 829B0A08: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B0A0C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 829B0A10: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 829B0A14: 8901FFF7  lbz r8, -9(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 829B0A18: 9901FFE0  stb r8, -0x20(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u8 ) };
	// 829B0A1C: 8101FFE0  lwz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 829B0A20: 91090080  stw r8, 0x80(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 829B0A24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0A28: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B0A2C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829B0A30: 409AFF90  bne cr6, 0x829b09c0
	if !ctx.cr[6].eq {
	pc = 0x829B09C0; continue 'dispatch;
	}
	// 829B0A34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B0A38 size=92
    let mut pc: u32 = 0x829B0A38;
    'dispatch: loop {
        match pc {
            0x829B0A38 => {
    //   block [0x829B0A38..0x829B0A94)
	// 829B0A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B0A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B0A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B0A50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B0A54: 4BB5FCB5  bl 0x82510708
	ctx.lr = 0x829B0A58;
	sub_82510708(ctx, base);
	// 829B0A58: C01F0120  lfs f0, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B0A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0A60: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B0A64: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B0A68: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 829B0A6C: 4BFFFB95  bl 0x829b0600
	ctx.lr = 0x829B0A70;
	sub_829B0600(ctx, base);
	// 829B0A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0A74: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B0A78: 4BFFFA81  bl 0x829b04f8
	ctx.lr = 0x829B0A7C;
	sub_829B04F8(ctx, base);
	// 829B0A7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B0A80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0A84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B0A88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B0A8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B0A90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0A98 size=76
    let mut pc: u32 = 0x829B0A98;
    'dispatch: loop {
        match pc {
            0x829B0A98 => {
    //   block [0x829B0A98..0x829B0AE4)
	// 829B0A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B0AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B0AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B0AB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B0AB4: 4BFFFDCD  bl 0x829b0880
	ctx.lr = 0x829B0AB8;
	sub_829B0880(ctx, base);
	// 829B0AB8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B0ABC: 4182000C  beq 0x829b0ac8
	if ctx.cr[0].eq {
	pc = 0x829B0AC8; continue 'dispatch;
	}
	// 829B0AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0AC4: 48441915  bl 0x82df23d8
	ctx.lr = 0x829B0AC8;
	sub_82DF23D8(ctx, base);
	// 829B0AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0ACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B0AD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0AD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B0AD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B0ADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B0AE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0AE8 size=116
    let mut pc: u32 = 0x829B0AE8;
    'dispatch: loop {
        match pc {
            0x829B0AE8 => {
    //   block [0x829B0AE8..0x829B0B5C)
	// 829B0AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0AEC: 487F7681  bl 0x831a816c
	ctx.lr = 0x829B0AF0;
	sub_831A8130(ctx, base);
	// 829B0AF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0AF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B0AF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B0AFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B0B00: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829B0B04: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 829B0B08: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829B0B0C: 484418DD  bl 0x82df23e8
	ctx.lr = 0x829B0B10;
	sub_82DF23E8(ctx, base);
	// 829B0B10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B0B14: 41820014  beq 0x829b0b28
	if ctx.cr[0].eq {
	pc = 0x829B0B28; continue 'dispatch;
	}
	// 829B0B18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B0B1C: 481A06BD  bl 0x82b511d8
	ctx.lr = 0x829B0B20;
	sub_82B511D8(ctx, base);
	// 829B0B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B0B24: 48000008  b 0x829b0b2c
	pc = 0x829B0B2C; continue 'dispatch;
	// 829B0B28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B0B2C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829B0B30: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829B0B34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B0B3C: 4BFFFB15  bl 0x829b0650
	ctx.lr = 0x829B0B40;
	sub_829B0650(ctx, base);
	// 829B0B40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B0B44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B0B4C: 4B90F4B5  bl 0x822c0000
	ctx.lr = 0x829B0B50;
	sub_822C0000(ctx, base);
	// 829B0B50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B0B54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B0B58: 487F7664  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B0B60 size=184
    let mut pc: u32 = 0x829B0B60;
    'dispatch: loop {
        match pc {
            0x829B0B60 => {
    //   block [0x829B0B60..0x829B0C18)
	// 829B0B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B0B6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0B70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B0B74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829B0B78: 4BFFFF71  bl 0x829b0ae8
	ctx.lr = 0x829B0B7C;
	sub_829B0AE8(ctx, base);
	// 829B0B7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0B80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829B0B84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B0B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B0B8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B0B90: 419A0024  beq cr6, 0x829b0bb4
	if ctx.cr[6].eq {
	pc = 0x829B0BB4; continue 'dispatch;
	}
	// 829B0B94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B0B98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B0B9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0BA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B0BA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B0BA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B0BAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B0BB0: 4082FFE8  bne 0x829b0b98
	if !ctx.cr[0].eq {
	pc = 0x829B0B98; continue 'dispatch;
	}
	// 829B0BB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B0BB8: 80DF00EC  lwz r6, 0xec(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829B0BBC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B0BC0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829B0BC4: 388A2190  addi r4, r10, 0x2190
	ctx.r[4].s64 = ctx.r[10].s64 + 8592;
	// 829B0BC8: 38A00116  li r5, 0x116
	ctx.r[5].s64 = 278;
	// 829B0BCC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829B0BD0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B0BD4: 484A7E6D  bl 0x82e58a40
	ctx.lr = 0x829B0BD8;
	sub_82E58A40(ctx, base);
	// 829B0BD8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B0BDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0BE0: 419A0008  beq cr6, 0x829b0be8
	if ctx.cr[6].eq {
	pc = 0x829B0BE8; continue 'dispatch;
	}
	// 829B0BE4: 4B90FCAD  bl 0x822c0890
	ctx.lr = 0x829B0BE8;
	sub_822C0890(ctx, base);
	// 829B0BE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829B0BEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0BF0: 419A0008  beq cr6, 0x829b0bf8
	if ctx.cr[6].eq {
	pc = 0x829B0BF8; continue 'dispatch;
	}
	// 829B0BF4: 4B90FC9D  bl 0x822c0890
	ctx.lr = 0x829B0BF8;
	sub_822C0890(ctx, base);
	// 829B0BF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0BFC: C00B2120  lfs f0, 0x2120(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B0C00: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 829B0C04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B0C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B0C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B0C10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B0C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0C18 size=164
    let mut pc: u32 = 0x829B0C18;
    'dispatch: loop {
        match pc {
            0x829B0C18 => {
    //   block [0x829B0C18..0x829B0CBC)
	// 829B0C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0C1C: 487F754D  bl 0x831a8168
	ctx.lr = 0x829B0C20;
	sub_831A8130(ctx, base);
	// 829B0C20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0C24: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829B0C28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B0C2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B0C30: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829B0C34: 41820038  beq 0x829b0c6c
	if ctx.cr[0].eq {
	pc = 0x829B0C6C; continue 'dispatch;
	}
	// 829B0C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0C3C: 487F8D4D  bl 0x831a9988
	ctx.lr = 0x829B0C40;
	sub_831A9988(ctx, base);
	// 829B0C40: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829B0C44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B0C48: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829B0C4C: 487F74AD  bl 0x831a80f8
	ctx.lr = 0x829B0C50;
	sub_831A80F8(ctx, base);
	// 829B0C50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B0C54: 41820018  beq 0x829b0c6c
	if ctx.cr[0].eq {
	pc = 0x829B0C6C; continue 'dispatch;
	}
	// 829B0C58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0C5C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829B0C60: 4BFFFF01  bl 0x829b0b60
	ctx.lr = 0x829B0C64;
	sub_829B0B60(ctx, base);
	// 829B0C64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829B0C68: 4800004C  b 0x829b0cb4
	pc = 0x829B0CB4; continue 'dispatch;
	// 829B0C6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829B0C70: 419A0034  beq cr6, 0x829b0ca4
	if ctx.cr[6].eq {
	pc = 0x829B0CA4; continue 'dispatch;
	}
	// 829B0C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0C78: 487F8D11  bl 0x831a9988
	ctx.lr = 0x829B0C7C;
	sub_831A9988(ctx, base);
	// 829B0C7C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829B0C80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B0C84: 386B67A0  addi r3, r11, 0x67a0
	ctx.r[3].s64 = ctx.r[11].s64 + 26528;
	// 829B0C88: 487F7471  bl 0x831a80f8
	ctx.lr = 0x829B0C8C;
	sub_831A80F8(ctx, base);
	// 829B0C8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B0C90: 41820014  beq 0x829b0ca4
	if ctx.cr[0].eq {
	pc = 0x829B0CA4; continue 'dispatch;
	}
	// 829B0C94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0C98: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829B0C9C: 4BFFF8CD  bl 0x829b0568
	ctx.lr = 0x829B0CA0;
	sub_829B0568(ctx, base);
	// 829B0CA0: 4BFFFFC4  b 0x829b0c64
	pc = 0x829B0C64; continue 'dispatch;
	// 829B0CA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829B0CA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B0CB0: 4BB61969  bl 0x82512618
	ctx.lr = 0x829B0CB4;
	sub_82512618(ctx, base);
	// 829B0CB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B0CB8: 487F7500  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0CC0 size=128
    let mut pc: u32 = 0x829B0CC0;
    'dispatch: loop {
        match pc {
            0x829B0CC0 => {
    //   block [0x829B0CC0..0x829B0D40)
	// 829B0CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0CC4: 487F74A9  bl 0x831a816c
	ctx.lr = 0x829B0CC8;
	sub_831A8130(ctx, base);
	// 829B0CC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0CCC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829B0CD0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829B0CD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B0CD8: 3BEBCB24  addi r31, r11, -0x34dc
	ctx.r[31].s64 = ctx.r[11].s64 + -13532;
	// 829B0CDC: 816ACB2C  lwz r11, -0x34d4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13524 as u32) ) } as u64;
	// 829B0CE0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829B0CE4: 40820024  bne 0x829b0d08
	if !ctx.cr[0].eq {
	pc = 0x829B0D08; continue 'dispatch;
	}
	// 829B0CE8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829B0CEC: 3D00829B  lis r8, -0x7d65
	ctx.r[8].s64 = -2103771136;
	// 829B0CF0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829B0CF4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829B0CF8: 39080718  addi r8, r8, 0x718
	ctx.r[8].s64 = ctx.r[8].s64 + 1816;
	// 829B0CFC: 916ACB2C  stw r11, -0x34d4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13524 as u32), ctx.r[11].u32 ) };
	// 829B0D00: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829B0D04: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829B0D08: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829B0D0C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829B0D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0D14: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829B0D18: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829B0D1C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B0D20: 4BCA38A1  bl 0x826545c0
	ctx.lr = 0x829B0D24;
	sub_826545C0(ctx, base);
	// 829B0D24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B0D28: 4182000C  beq 0x829b0d34
	if ctx.cr[0].eq {
	pc = 0x829B0D34; continue 'dispatch;
	}
	// 829B0D2C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829B0D30: 48000008  b 0x829b0d38
	pc = 0x829B0D38; continue 'dispatch;
	// 829B0D34: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829B0D38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B0D3C: 487F7480  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B0D40 size=600
    let mut pc: u32 = 0x829B0D40;
    'dispatch: loop {
        match pc {
            0x829B0D40 => {
    //   block [0x829B0D40..0x829B0F98)
	// 829B0D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0D44: 487F741D  bl 0x831a8160
	ctx.lr = 0x829B0D48;
	sub_831A8130(ctx, base);
	// 829B0D48: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829B0D4C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0D50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B0D54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B0D58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B0D5C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 829B0D60: 4BB613B9  bl 0x82512118
	ctx.lr = 0x829B0D64;
	sub_82512118(ctx, base);
	// 829B0D64: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B0D68: 807E0110  lwz r3, 0x110(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 829B0D6C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0D70: 484620C1  bl 0x82e12e30
	ctx.lr = 0x829B0D74;
	sub_82E12E30(ctx, base);
	// 829B0D74: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829B0D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0D7C: 419A0008  beq cr6, 0x829b0d84
	if ctx.cr[6].eq {
	pc = 0x829B0D84; continue 'dispatch;
	}
	// 829B0D80: 4B90FB11  bl 0x822c0890
	ctx.lr = 0x829B0D84;
	sub_822C0890(ctx, base);
	// 829B0D84: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829B0D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B0D8C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829B0D90: 48442C79  bl 0x82df3a08
	ctx.lr = 0x829B0D94;
	sub_82DF3A08(ctx, base);
	// 829B0D94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B0D98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B0D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0DA0: 4BB579E1  bl 0x82508780
	ctx.lr = 0x829B0DA4;
	sub_82508780(ctx, base);
	// 829B0DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B0DA8: 48442681  bl 0x82df3428
	ctx.lr = 0x829B0DAC;
	sub_82DF3428(ctx, base);
	// 829B0DAC: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 829B0DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0DB4: 4BB579ED  bl 0x825087a0
	ctx.lr = 0x829B0DB8;
	sub_825087A0(ctx, base);
	// 829B0DB8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B0DC0: 388B21E8  addi r4, r11, 0x21e8
	ctx.r[4].s64 = ctx.r[11].s64 + 8680;
	// 829B0DC4: 48442C45  bl 0x82df3a08
	ctx.lr = 0x829B0DC8;
	sub_82DF3A08(ctx, base);
	// 829B0DC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0DCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829B0DD0: 4BB59B81  bl 0x8250a950
	ctx.lr = 0x829B0DD4;
	sub_8250A950(ctx, base);
	// 829B0DD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0DD8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829B0DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B0DE0: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 829B0DE4: 409A0008  bne cr6, 0x829b0dec
	if !ctx.cr[6].eq {
	pc = 0x829B0DEC; continue 'dispatch;
	}
	// 829B0DE8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829B0DEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B0DF0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829B0DF4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 829B0DF8: 4BB61321  bl 0x82512118
	ctx.lr = 0x829B0DFC;
	sub_82512118(ctx, base);
	// 829B0DFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829B0E00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B0E04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B0E08: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829B0E0C: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 829B0E10: 4BE23EA1  bl 0x827d4cb0
	ctx.lr = 0x829B0E14;
	sub_827D4CB0(ctx, base);
	// 829B0E14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B0E18: 3BFE00E4  addi r31, r30, 0xe4
	ctx.r[31].s64 = ctx.r[30].s64 + 228;
	// 829B0E1C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829B0E20: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829B0E24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0E28: 917E00E4  stw r11, 0xe4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829B0E2C: 4B913635  bl 0x822c4460
	ctx.lr = 0x829B0E30;
	sub_822C4460(ctx, base);
	// 829B0E30: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829B0E34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0E38: 419A0008  beq cr6, 0x829b0e40
	if ctx.cr[6].eq {
	pc = 0x829B0E40; continue 'dispatch;
	}
	// 829B0E3C: 4B90FA55  bl 0x822c0890
	ctx.lr = 0x829B0E40;
	sub_822C0890(ctx, base);
	// 829B0E40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829B0E44: 48440E4D  bl 0x82df1c90
	ctx.lr = 0x829B0E48;
	sub_82DF1C90(ctx, base);
	// 829B0E48: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829B0E4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0E50: 419A0008  beq cr6, 0x829b0e58
	if ctx.cr[6].eq {
	pc = 0x829B0E58; continue 'dispatch;
	}
	// 829B0E54: 4B90FA3D  bl 0x822c0890
	ctx.lr = 0x829B0E58;
	sub_822C0890(ctx, base);
	// 829B0E58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B0E5C: 484425CD  bl 0x82df3428
	ctx.lr = 0x829B0E60;
	sub_82DF3428(ctx, base);
	// 829B0E60: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0E64: 484CE58D  bl 0x82e7f3f0
	ctx.lr = 0x829B0E68;
	sub_82E7F3F0(ctx, base);
	// 829B0E68: 83630004  lwz r27, 4(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B0E6C: 839B0000  lwz r28, 0(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0E70: 48000064  b 0x829b0ed4
	pc = 0x829B0ED4; continue 'dispatch;
	// 829B0E74: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829B0E78: 3BAB0108  addi r29, r11, 0x108
	ctx.r[29].s64 = ctx.r[11].s64 + 264;
	// 829B0E7C: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 829B0E80: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0E84: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829B0E88: 419A0048  beq cr6, 0x829b0ed0
	if ctx.cr[6].eq {
	pc = 0x829B0ED0; continue 'dispatch;
	}
	// 829B0E8C: 3D60829B  lis r11, -0x7d65
	ctx.r[11].s64 = -2103771136;
	// 829B0E90: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 829B0E94: 396B0978  addi r11, r11, 0x978
	ctx.r[11].s64 = ctx.r[11].s64 + 2424;
	// 829B0E98: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829B0E9C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829B0EA0: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 829B0EA4: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 829B0EA8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829B0EAC: 93410090  stw r26, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[26].u32 ) };
	// 829B0EB0: 4BFFFE11  bl 0x829b0cc0
	ctx.lr = 0x829B0EB4;
	sub_829B0CC0(ctx, base);
	// 829B0EB4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829B0EB8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829B0EBC: 4BCD8F8D  bl 0x82689e48
	ctx.lr = 0x829B0EC0;
	sub_82689E48(ctx, base);
	// 829B0EC0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B0EC4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0EC8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829B0ECC: 409AFFD0  bne cr6, 0x829b0e9c
	if !ctx.cr[6].eq {
	pc = 0x829B0E9C; continue 'dispatch;
	}
	// 829B0ED0: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0ED4: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 829B0ED8: 409AFF9C  bne cr6, 0x829b0e74
	if !ctx.cr[6].eq {
	pc = 0x829B0E74; continue 'dispatch;
	}
	// 829B0EDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B0EE0: 4BB61BB9  bl 0x82512a98
	ctx.lr = 0x829B0EE4;
	sub_82512A98(ctx, base);
	// 829B0EE4: 897E011C  lbz r11, 0x11c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) } as u64;
	// 829B0EE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B0EEC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B0EF0: 41820010  beq 0x829b0f00
	if ctx.cr[0].eq {
	pc = 0x829B0F00; continue 'dispatch;
	}
	// 829B0EF4: 396B9264  addi r11, r11, -0x6d9c
	ctx.r[11].s64 = ctx.r[11].s64 + -28060;
	// 829B0EF8: C3EB0004  lfs f31, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B0EFC: 48000008  b 0x829b0f04
	pc = 0x829B0F04; continue 'dispatch;
	// 829B0F00: C3EB9264  lfs f31, -0x6d9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B0F04: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B0F08: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 829B0F0C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829B0F10: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 829B0F14: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829B0F18: 484EF819  bl 0x82ea0730
	ctx.lr = 0x829B0F1C;
	sub_82EA0730(ctx, base);
	// 829B0F1C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 829B0F20: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B0F24: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 829B0F28: 485692C9  bl 0x82f1a1f0
	ctx.lr = 0x829B0F2C;
	sub_82F1A1F0(ctx, base);
	// 829B0F2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829B0F30: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829B0F34: 4182000C  beq 0x829b0f40
	if ctx.cr[0].eq {
	pc = 0x829B0F40; continue 'dispatch;
	}
	// 829B0F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0F3C: 4B93730D  bl 0x822e8248
	ctx.lr = 0x829B0F40;
	sub_822E8248(ctx, base);
	// 829B0F40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B0F44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B0F48: 388B21E0  addi r4, r11, 0x21e0
	ctx.r[4].s64 = ctx.r[11].s64 + 8672;
	// 829B0F4C: 484485E5  bl 0x82df9530
	ctx.lr = 0x829B0F50;
	sub_82DF9530(ctx, base);
	// 829B0F50: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829B0F54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829B0F58: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829B0F5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B0F60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B0F64: 80CB6734  lwz r6, 0x6734(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 829B0F68: 4BB62181  bl 0x825130e8
	ctx.lr = 0x829B0F6C;
	sub_825130E8(ctx, base);
	// 829B0F6C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829B0F70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B0F74: 419A0008  beq cr6, 0x829b0f7c
	if ctx.cr[6].eq {
	pc = 0x829B0F7C; continue 'dispatch;
	}
	// 829B0F78: 4B9372F1  bl 0x822e8268
	ctx.lr = 0x829B0F7C;
	sub_822E8268(ctx, base);
	// 829B0F7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B0F80: 419A000C  beq cr6, 0x829b0f8c
	if ctx.cr[6].eq {
	pc = 0x829B0F8C; continue 'dispatch;
	}
	// 829B0F84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B0F88: 4B9372E1  bl 0x822e8268
	ctx.lr = 0x829B0F8C;
	sub_822E8268(ctx, base);
	// 829B0F8C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 829B0F90: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829B0F94: 487F721C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B0F98 size=12
    let mut pc: u32 = 0x829B0F98;
    'dispatch: loop {
        match pc {
            0x829B0F98 => {
    //   block [0x829B0F98..0x829B0FA4)
	// 829B0F98: 89630141  lbz r11, 0x141(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(321 as u32) ) } as u64;
	// 829B0F9C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B0FA0: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0FA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B0FA4 size=12
    let mut pc: u32 = 0x829B0FA4;
    'dispatch: loop {
        match pc {
            0x829B0FA4 => {
    //   block [0x829B0FA4..0x829B0FB0)
	// 829B0FA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B0FA8: 99630141  stb r11, 0x141(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(321 as u32), ctx.r[11].u8 ) };
	// 829B0FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B0FB0 size=12
    let mut pc: u32 = 0x829B0FB0;
    'dispatch: loop {
        match pc {
            0x829B0FB0 => {
    //   block [0x829B0FB0..0x829B0FBC)
	// 829B0FB0: 89630141  lbz r11, 0x141(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(321 as u32) ) } as u64;
	// 829B0FB4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B0FB8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0FBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B0FBC size=12
    let mut pc: u32 = 0x829B0FBC;
    'dispatch: loop {
        match pc {
            0x829B0FBC => {
    //   block [0x829B0FBC..0x829B0FC8)
	// 829B0FBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B0FC0: 99630141  stb r11, 0x141(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(321 as u32), ctx.r[11].u8 ) };
	// 829B0FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B0FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B0FC8 size=136
    let mut pc: u32 = 0x829B0FC8;
    'dispatch: loop {
        match pc {
            0x829B0FC8 => {
    //   block [0x829B0FC8..0x829B1050)
	// 829B0FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B0FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B0FD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B0FD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B0FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B0FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B0FE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B0FE4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829B0FE8: 409A0020  bne cr6, 0x829b1008
	if !ctx.cr[6].eq {
	pc = 0x829B1008; continue 'dispatch;
	}
	// 829B0FEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B0FF0: 419A0048  beq cr6, 0x829b1038
	if ctx.cr[6].eq {
	pc = 0x829B1038; continue 'dispatch;
	}
	// 829B0FF4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829B0FF8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829B0FFC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829B1000: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829B1004: 48000034  b 0x829b1038
	pc = 0x829B1038; continue 'dispatch;
	// 829B1008: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829B100C: 419A002C  beq cr6, 0x829b1038
	if ctx.cr[6].eq {
	pc = 0x829B1038; continue 'dispatch;
	}
	// 829B1010: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B1014: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1018: 388B93C8  addi r4, r11, -0x6c38
	ctx.r[4].s64 = ctx.r[11].s64 + -27704;
	// 829B101C: 487F70DD  bl 0x831a80f8
	ctx.lr = 0x829B1020;
	sub_831A80F8(ctx, base);
	// 829B1020: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B1024: 4182000C  beq 0x829b1030
	if ctx.cr[0].eq {
	pc = 0x829B1030; continue 'dispatch;
	}
	// 829B1028: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829B102C: 4800000C  b 0x829b1038
	pc = 0x829B1038; continue 'dispatch;
	// 829B1030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B1034: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B1038: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B103C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B1040: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B1044: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B1048: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B104C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B1050 size=100
    let mut pc: u32 = 0x829B1050;
    'dispatch: loop {
        match pc {
            0x829B1050 => {
    //   block [0x829B1050..0x829B10B4)
	// 829B1050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B1054: 487F7119  bl 0x831a816c
	ctx.lr = 0x829B1058;
	sub_831A8130(ctx, base);
	// 829B1058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B105C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829B1060: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829B1064: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B1068: 3BEBCB30  addi r31, r11, -0x34d0
	ctx.r[31].s64 = ctx.r[11].s64 + -13520;
	// 829B106C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B1070: 816ACB34  lwz r11, -0x34cc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13516 as u32) ) } as u64;
	// 829B1074: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829B1078: 4082001C  bne 0x829b1094
	if !ctx.cr[0].eq {
	pc = 0x829B1094; continue 'dispatch;
	}
	// 829B107C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829B1080: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 829B1084: 916ACB34  stw r11, -0x34cc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13516 as u32), ctx.r[11].u32 ) };
	// 829B1088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B108C: 3889ECC4  addi r4, r9, -0x133c
	ctx.r[4].s64 = ctx.r[9].s64 + -4924;
	// 829B1090: 484484A1  bl 0x82df9530
	ctx.lr = 0x829B1094;
	sub_82DF9530(ctx, base);
	// 829B1094: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 829B1098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B109C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829B10A0: 409A000C  bne cr6, 0x829b10ac
	if !ctx.cr[6].eq {
	pc = 0x829B10AC; continue 'dispatch;
	}
	// 829B10A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B10A8: 917D0248  stw r11, 0x248(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 829B10AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B10B0: 487F710C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B10B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B10B8 size=880
    let mut pc: u32 = 0x829B10B8;
    'dispatch: loop {
        match pc {
            0x829B10B8 => {
    //   block [0x829B10B8..0x829B1428)
	// 829B10B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B10BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B10C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B10C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B10C8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 829B10CC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829B10D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B10D4: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 829B10D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B10DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B10E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B10E4: C01F0244  lfs f0, 0x244(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B10E8: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B10EC: D01F0244  stfs f0, 0x244(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 829B10F0: 4BB61029  bl 0x82512118
	ctx.lr = 0x829B10F4;
	sub_82512118(ctx, base);
	// 829B10F4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B10F8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829B10FC: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 829B1100: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1104: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829B1108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B110C: 4E800421  bctrl
	ctx.lr = 0x829B1110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B1110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B1114: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829B1118: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B111C: 484CABAD  bl 0x82e7bcc8
	ctx.lr = 0x829B1120;
	sub_82E7BCC8(ctx, base);
	// 829B1120: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B1124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1128: 419A0008  beq cr6, 0x829b1130
	if ctx.cr[6].eq {
	pc = 0x829B1130; continue 'dispatch;
	}
	// 829B112C: 4B90F765  bl 0x822c0890
	ctx.lr = 0x829B1130;
	sub_822C0890(ctx, base);
	// 829B1130: 897F0240  lbz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 829B1134: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B1138: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B113C: 41980194  blt cr6, 0x829b12d0
	if ctx.cr[6].lt {
	pc = 0x829B12D0; continue 'dispatch;
	}
	// 829B1140: 419A0058  beq cr6, 0x829b1198
	if ctx.cr[6].eq {
	pc = 0x829B1198; continue 'dispatch;
	}
	// 829B1144: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B1148: 40980250  bge cr6, 0x829b1398
	if !ctx.cr[6].lt {
	pc = 0x829B1398; continue 'dispatch;
	}
	// 829B114C: 897F0141  lbz r11, 0x141(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(321 as u32) ) } as u64;
	// 829B1150: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B1154: 40820244  bne 0x829b1398
	if !ctx.cr[0].eq {
	pc = 0x829B1398; continue 'dispatch;
	}
	// 829B1158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B115C: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 829B1160: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829B1164: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B1168: 9BDF0240  stb r30, 0x240(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[30].u8 ) };
	// 829B116C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B1170: D3FF0244  stfs f31, 0x244(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 829B1174: 484D05CD  bl 0x82e81740
	ctx.lr = 0x829B1178;
	sub_82E81740(ctx, base);
	// 829B1178: D3FF0154  stfs f31, 0x154(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 829B117C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B1180: 809F0144  lwz r4, 0x144(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 829B1184: 4BB60B1D  bl 0x82511ca0
	ctx.lr = 0x829B1188;
	sub_82511CA0(ctx, base);
	// 829B1188: 9BDF0142  stb r30, 0x142(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(322 as u32), ctx.r[30].u8 ) };
	// 829B118C: 807F0238  lwz r3, 0x238(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 829B1190: 48195539  bl 0x82b466c8
	ctx.lr = 0x829B1194;
	sub_82B466C8(ctx, base);
	// 829B1194: 48000204  b 0x829b1398
	pc = 0x829B1398; continue 'dispatch;
	// 829B1198: 897F0141  lbz r11, 0x141(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(321 as u32) ) } as u64;
	// 829B119C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B11A0: 40820038  bne 0x829b11d8
	if !ctx.cr[0].eq {
	pc = 0x829B11D8; continue 'dispatch;
	}
	// 829B11A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B11A8: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829B11AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829B11B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B11B4: 995F0240  stb r10, 0x240(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[10].u8 ) };
	// 829B11B8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B11BC: D3FF0244  stfs f31, 0x244(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 829B11C0: 484D0581  bl 0x82e81740
	ctx.lr = 0x829B11C4;
	sub_82E81740(ctx, base);
	// 829B11C4: D3FF0154  stfs f31, 0x154(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 829B11C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B11CC: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 829B11D0: 484D0571  bl 0x82e81740
	ctx.lr = 0x829B11D4;
	sub_82E81740(ctx, base);
	// 829B11D4: 480001C4  b 0x829b1398
	pc = 0x829B1398; continue 'dispatch;
	// 829B11D8: C01F014C  lfs f0, 0x14c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B11DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B11E0: C1BF0244  lfs f13, 0x244(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B11E4: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829B11E8: C3EB08A8  lfs f31, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B11EC: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 829B11F0: 41980008  blt cr6, 0x829b11f8
	if ctx.cr[6].lt {
	pc = 0x829B11F8; continue 'dispatch;
	}
	// 829B11F4: FD80F890  fmr f12, f31
	ctx.f[12].f64 = ctx.f[31].f64;
	// 829B11F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B11FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B1200: C16B6150  lfs f11, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B1204: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 829B1208: D19F0150  stfs f12, 0x150(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 829B120C: 4198018C  blt cr6, 0x829b1398
	if ctx.cr[6].lt {
	pc = 0x829B1398; continue 'dispatch;
	}
	// 829B1210: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829B1214: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B1218: D01F0244  stfs f0, 0x244(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 829B121C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B1220: 997F0240  stb r11, 0x240(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u8 ) };
	// 829B1224: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829B1228: 484D0519  bl 0x82e81740
	ctx.lr = 0x829B122C;
	sub_82E81740(ctx, base);
	// 829B122C: 897F0110  lbz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 829B1230: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B1234: 4182000C  beq 0x829b1240
	if ctx.cr[0].eq {
	pc = 0x829B1240; continue 'dispatch;
	}
	// 829B1238: D3FF0154  stfs f31, 0x154(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 829B123C: 4800001C  b 0x829b1258
	pc = 0x829B1258; continue 'dispatch;
	// 829B1240: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B1244: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 829B1248: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B124C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B1250: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 829B1254: 484D04ED  bl 0x82e81740
	ctx.lr = 0x829B1258;
	sub_82E81740(ctx, base);
	// 829B1258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B125C: 809F0144  lwz r4, 0x144(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 829B1260: 4BB60A61  bl 0x82511cc0
	ctx.lr = 0x829B1264;
	sub_82511CC0(ctx, base);
	// 829B1264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B1268: 997F0142  stb r11, 0x142(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(322 as u32), ctx.r[11].u8 ) };
	// 829B126C: 897F0110  lbz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 829B1270: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B1274: 41820124  beq 0x829b1398
	if ctx.cr[0].eq {
	pc = 0x829B1398; continue 'dispatch;
	}
	// 829B1278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B127C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B1280: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 829B1284: 38AA2250  addi r5, r10, 0x2250
	ctx.r[5].s64 = ctx.r[10].s64 + 8784;
	// 829B1288: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B128C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829B1290: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 829B1294: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B1298: 4E800421  bctrl
	ctx.lr = 0x829B129C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B129C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829B12A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B12A4: 419A0008  beq cr6, 0x829b12ac
	if ctx.cr[6].eq {
	pc = 0x829B12AC; continue 'dispatch;
	}
	// 829B12A8: 4B90F5E9  bl 0x822c0890
	ctx.lr = 0x829B12AC;
	sub_822C0890(ctx, base);
	// 829B12AC: 807F0238  lwz r3, 0x238(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 829B12B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B12B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829B12B8: 388B2238  addi r4, r11, 0x2238
	ctx.r[4].s64 = ctx.r[11].s64 + 8760;
	// 829B12BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B12C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B12C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B12C8: 4E800421  bctrl
	ctx.lr = 0x829B12CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B12CC: 480000CC  b 0x829b1398
	pc = 0x829B1398; continue 'dispatch;
	// 829B12D0: 897F0141  lbz r11, 0x141(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(321 as u32) ) } as u64;
	// 829B12D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B12D8: 418200C0  beq 0x829b1398
	if ctx.cr[0].eq {
	pc = 0x829B1398; continue 'dispatch;
	}
	// 829B12DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B12E0: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829B12E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B12E8: 995F0240  stb r10, 0x240(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[10].u8 ) };
	// 829B12EC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B12F0: D01F0244  stfs f0, 0x244(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 829B12F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B12F8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829B12FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B1300: 4E800421  bctrl
	ctx.lr = 0x829B1304;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B1304: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B1308: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 829B130C: C00B6150  lfs f0, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B1310: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 829B1314: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1318: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829B131C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B1320: 4E800421  bctrl
	ctx.lr = 0x829B1324;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B1324: 897F0110  lbz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 829B1328: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B132C: 4182006C  beq 0x829b1398
	if ctx.cr[0].eq {
	pc = 0x829B1398; continue 'dispatch;
	}
	// 829B1330: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1334: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B1338: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 829B133C: 38AA2220  addi r5, r10, 0x2220
	ctx.r[5].s64 = ctx.r[10].s64 + 8736;
	// 829B1340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B1344: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B1348: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 829B134C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B1350: 4E800421  bctrl
	ctx.lr = 0x829B1354;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B1354: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829B1358: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B135C: 419A0008  beq cr6, 0x829b1364
	if ctx.cr[6].eq {
	pc = 0x829B1364; continue 'dispatch;
	}
	// 829B1360: 4B90F531  bl 0x822c0890
	ctx.lr = 0x829B1364;
	sub_822C0890(ctx, base);
	// 829B1364: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1368: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B136C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 829B1370: 38AA2208  addi r5, r10, 0x2208
	ctx.r[5].s64 = ctx.r[10].s64 + 8712;
	// 829B1374: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B1378: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B137C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 829B1380: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B1384: 4E800421  bctrl
	ctx.lr = 0x829B1388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B1388: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829B138C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1390: 419A0008  beq cr6, 0x829b1398
	if ctx.cr[6].eq {
	pc = 0x829B1398; continue 'dispatch;
	}
	// 829B1394: 4B90F4FD  bl 0x822c0890
	ctx.lr = 0x829B1398;
	sub_822C0890(ctx, base);
	// 829B1398: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829B139C: 807F0238  lwz r3, 0x238(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 829B13A0: 48195809  bl 0x82b46ba8
	ctx.lr = 0x829B13A4;
	sub_82B46BA8(ctx, base);
	// 829B13A4: C19F0158  lfs f12, 0x158(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B13A8: C01F0150  lfs f0, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B13AC: ED8CF02A  fadds f12, f12, f30
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[30].f64) as f32) as f64;
	// 829B13B0: C1BF0154  lfs f13, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B13B4: D19F0158  stfs f12, 0x158(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 829B13B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B13BC: 40980024  bge cr6, 0x829b13e0
	if !ctx.cr[6].lt {
	pc = 0x829B13E0; continue 'dispatch;
	}
	// 829B13C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B13C4: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B13C8: C18B9524  lfs f12, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B13CC: ED9E0332  fmuls f12, f30, f12
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 829B13D0: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 829B13D4: 41980024  blt cr6, 0x829b13f8
	if ctx.cr[6].lt {
	pc = 0x829B13F8; continue 'dispatch;
	}
	// 829B13D8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 829B13DC: 48000028  b 0x829b1404
	pc = 0x829B1404; continue 'dispatch;
	// 829B13E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829B13E4: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B13E8: C18BD7BC  lfs f12, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B13EC: ED9E0332  fmuls f12, f30, f12
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 829B13F0: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 829B13F4: 4098000C  bge cr6, 0x829b1400
	if !ctx.cr[6].lt {
	pc = 0x829B1400; continue 'dispatch;
	}
	// 829B13F8: D1BF0150  stfs f13, 0x150(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 829B13FC: 4800000C  b 0x829b1408
	pc = 0x829B1408; continue 'dispatch;
	// 829B1400: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 829B1404: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 829B1408: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829B140C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B1410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B1414: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829B1418: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829B141C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B1420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B1424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B1428 size=72
    let mut pc: u32 = 0x829B1428;
    'dispatch: loop {
        match pc {
            0x829B1428 => {
    //   block [0x829B1428..0x829B1470)
	// 829B1428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B142C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B1430: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B1434: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829B1438: 419A001C  beq cr6, 0x829b1454
	if ctx.cr[6].eq {
	pc = 0x829B1454; continue 'dispatch;
	}
	// 829B143C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829B1440: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829B1444: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829B1448: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B144C: 4BFFFB7D  bl 0x829b0fc8
	ctx.lr = 0x829B1450;
	sub_829B0FC8(ctx, base);
	// 829B1450: 48000010  b 0x829b1460
	pc = 0x829B1460; continue 'dispatch;
	// 829B1454: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B1458: 396B93C8  addi r11, r11, -0x6c38
	ctx.r[11].s64 = ctx.r[11].s64 + -27704;
	// 829B145C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B1460: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B1464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B1468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B146C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B1470 size=392
    let mut pc: u32 = 0x829B1470;
    'dispatch: loop {
        match pc {
            0x829B1470 => {
    //   block [0x829B1470..0x829B15F8)
	// 829B1470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B1474: 487F6CF5  bl 0x831a8168
	ctx.lr = 0x829B1478;
	sub_831A8130(ctx, base);
	// 829B1478: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B147C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829B1480: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829B1484: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829B1488: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829B148C: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829B1490: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 829B1494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B1498: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 829B149C: 4BB60DC5  bl 0x82512260
	ctx.lr = 0x829B14A0;
	sub_82512260(ctx, base);
	// 829B14A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B14A4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B14A8: 390B227C  addi r8, r11, 0x227c
	ctx.r[8].s64 = ctx.r[11].s64 + 8828;
	// 829B14AC: 394A2268  addi r10, r10, 0x2268
	ctx.r[10].s64 = ctx.r[10].s64 + 8808;
	// 829B14B0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829B14B4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829B14B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B14BC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829B14C0: 993F0110  stb r9, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[9].u8 ) };
	// 829B14C4: 395F012C  addi r10, r31, 0x12c
	ctx.r[10].s64 = ctx.r[31].s64 + 300;
	// 829B14C8: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 829B14CC: 391E0004  addi r8, r30, 4
	ctx.r[8].s64 = ctx.r[30].s64 + 4;
	// 829B14D0: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 829B14D4: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 829B14D8: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 829B14DC: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 829B14E0: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 829B14E4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B14E8: 915F012C  stw r10, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[10].u32 ) };
	// 829B14EC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B14F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829B14F4: 915F0130  stw r10, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[10].u32 ) };
	// 829B14F8: 419A0024  beq cr6, 0x829b151c
	if ctx.cr[6].eq {
	pc = 0x829B151C; continue 'dispatch;
	}
	// 829B14FC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 829B1500: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 829B1504: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B1508: 7CE05028  lwarx r7, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 829B150C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 829B1510: 7CE0512D  stwcx. r7, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B1514: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B1518: 4082FFE8  bne 0x829b1500
	if !ctx.cr[0].eq {
	pc = 0x829B1500; continue 'dispatch;
	}
	// 829B151C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829B1520: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 829B1524: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 829B1528: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 829B152C: 993F0148  stb r9, 0x148(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[9].u8 ) };
	// 829B1530: 395F016C  addi r10, r31, 0x16c
	ctx.r[10].s64 = ctx.r[31].s64 + 364;
	// 829B1534: 993F0149  stb r9, 0x149(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(329 as u32), ctx.r[9].u8 ) };
	// 829B1538: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 829B153C: 93BF013C  stw r29, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[29].u32 ) };
	// 829B1540: C1A7A9F0  lfs f13, -0x5610(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B1544: 9B9F0140  stb r28, 0x140(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[28].u8 ) };
	// 829B1548: C00608A4  lfs f0, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B154C: 997F0141  stb r11, 0x141(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(321 as u32), ctx.r[11].u8 ) };
	// 829B1550: D1BF014C  stfs f13, 0x14c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 829B1554: 997F0142  stb r11, 0x142(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(322 as u32), ctx.r[11].u8 ) };
	// 829B1558: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 829B155C: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 829B1560: D01F0158  stfs f0, 0x158(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 829B1564: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 829B1568: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829B156C: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 829B1570: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 829B1574: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B1578: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829B157C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829B1580: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829B1584: 4080FFF0  bge 0x829b1574
	if !ctx.cr[0].lt {
	pc = 0x829B1574; continue 'dispatch;
	}
	// 829B1588: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 829B158C: 395F01B4  addi r10, r31, 0x1b4
	ctx.r[10].s64 = ctx.r[31].s64 + 436;
	// 829B1590: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 829B1594: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 829B1598: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B159C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829B15A0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829B15A4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829B15A8: 4080FFF0  bge 0x829b1598
	if !ctx.cr[0].lt {
	pc = 0x829B1598; continue 'dispatch;
	}
	// 829B15AC: 395F01F4  addi r10, r31, 0x1f4
	ctx.r[10].s64 = ctx.r[31].s64 + 500;
	// 829B15B0: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 829B15B4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B15B8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829B15BC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829B15C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829B15C4: 4080FFF0  bge 0x829b15b4
	if !ctx.cr[0].lt {
	pc = 0x829B15B4; continue 'dispatch;
	}
	// 829B15C8: 997F0234  stb r11, 0x234(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u8 ) };
	// 829B15CC: 997F0235  stb r11, 0x235(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(565 as u32), ctx.r[11].u8 ) };
	// 829B15D0: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 829B15D4: 917F023C  stw r11, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 829B15D8: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 829B15DC: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B15E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B15E4: 419A0008  beq cr6, 0x829b15ec
	if ctx.cr[6].eq {
	pc = 0x829B15EC; continue 'dispatch;
	}
	// 829B15E8: 4B90F2A9  bl 0x822c0890
	ctx.lr = 0x829B15EC;
	sub_822C0890(ctx, base);
	// 829B15EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B15F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B15F4: 487F6BC4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B15F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B15F8 size=8
    let mut pc: u32 = 0x829B15F8;
    'dispatch: loop {
        match pc {
            0x829B15F8 => {
    //   block [0x829B15F8..0x829B1600)
	// 829B15F8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829B15FC: 4800060C  b 0x829b1c08
	sub_829B1C08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B1600 size=324
    let mut pc: u32 = 0x829B1600;
    'dispatch: loop {
        match pc {
            0x829B1600 => {
    //   block [0x829B1600..0x829B1744)
	// 829B1600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B1604: 487F6B65  bl 0x831a8168
	ctx.lr = 0x829B1608;
	sub_831A8130(ctx, base);
	// 829B1608: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B160C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829B1610: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B1614: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B1618: 396B227C  addi r11, r11, 0x227c
	ctx.r[11].s64 = ctx.r[11].s64 + 8828;
	// 829B161C: 394A2268  addi r10, r10, 0x2268
	ctx.r[10].s64 = ctx.r[10].s64 + 8808;
	// 829B1620: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B1624: 915C0028  stw r10, 0x28(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829B1628: 807C023C  lwz r3, 0x23c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(572 as u32) ) } as u64;
	// 829B162C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1630: 419A0008  beq cr6, 0x829b1638
	if ctx.cr[6].eq {
	pc = 0x829B1638; continue 'dispatch;
	}
	// 829B1634: 4B90F25D  bl 0x822c0890
	ctx.lr = 0x829B1638;
	sub_822C0890(ctx, base);
	// 829B1638: 3BFC0040  addi r31, r28, 0x40
	ctx.r[31].s64 = ctx.r[28].s64 + 64;
	// 829B163C: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 829B1640: 397F01F4  addi r11, r31, 0x1f4
	ctx.r[11].s64 = ctx.r[31].s64 + 500;
	// 829B1644: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829B1648: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829B164C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1654: 419A0008  beq cr6, 0x829b165c
	if ctx.cr[6].eq {
	pc = 0x829B165C; continue 'dispatch;
	}
	// 829B1658: 4B90F239  bl 0x822c0890
	ctx.lr = 0x829B165C;
	sub_822C0890(ctx, base);
	// 829B165C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829B1660: 4080FFE8  bge 0x829b1648
	if !ctx.cr[0].lt {
	pc = 0x829B1648; continue 'dispatch;
	}
	// 829B1664: 397F01B4  addi r11, r31, 0x1b4
	ctx.r[11].s64 = ctx.r[31].s64 + 436;
	// 829B1668: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 829B166C: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829B1670: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829B1674: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B167C: 419A0008  beq cr6, 0x829b1684
	if ctx.cr[6].eq {
	pc = 0x829B1684; continue 'dispatch;
	}
	// 829B1680: 4B90F211  bl 0x822c0890
	ctx.lr = 0x829B1684;
	sub_822C0890(ctx, base);
	// 829B1684: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829B1688: 4080FFE8  bge 0x829b1670
	if !ctx.cr[0].lt {
	pc = 0x829B1670; continue 'dispatch;
	}
	// 829B168C: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 829B1690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1694: 419A0008  beq cr6, 0x829b169c
	if ctx.cr[6].eq {
	pc = 0x829B169C; continue 'dispatch;
	}
	// 829B1698: 4B90F1F9  bl 0x822c0890
	ctx.lr = 0x829B169C;
	sub_822C0890(ctx, base);
	// 829B169C: 397F016C  addi r11, r31, 0x16c
	ctx.r[11].s64 = ctx.r[31].s64 + 364;
	// 829B16A0: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 829B16A4: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 829B16A8: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 829B16AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B16B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B16B4: 419A0008  beq cr6, 0x829b16bc
	if ctx.cr[6].eq {
	pc = 0x829B16BC; continue 'dispatch;
	}
	// 829B16B8: 4B90F1D9  bl 0x822c0890
	ctx.lr = 0x829B16BC;
	sub_822C0890(ctx, base);
	// 829B16BC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829B16C0: 4080FFE8  bge 0x829b16a8
	if !ctx.cr[0].lt {
	pc = 0x829B16A8; continue 'dispatch;
	}
	// 829B16C4: 807C0168  lwz r3, 0x168(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(360 as u32) ) } as u64;
	// 829B16C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B16CC: 419A0008  beq cr6, 0x829b16d4
	if ctx.cr[6].eq {
	pc = 0x829B16D4; continue 'dispatch;
	}
	// 829B16D0: 4B90F1C1  bl 0x822c0890
	ctx.lr = 0x829B16D4;
	sub_822C0890(ctx, base);
	// 829B16D4: 807C0160  lwz r3, 0x160(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(352 as u32) ) } as u64;
	// 829B16D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B16DC: 419A0008  beq cr6, 0x829b16e4
	if ctx.cr[6].eq {
	pc = 0x829B16E4; continue 'dispatch;
	}
	// 829B16E0: 4B90F1B1  bl 0x822c0890
	ctx.lr = 0x829B16E4;
	sub_822C0890(ctx, base);
	// 829B16E4: 807C0138  lwz r3, 0x138(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(312 as u32) ) } as u64;
	// 829B16E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B16EC: 419A0008  beq cr6, 0x829b16f4
	if ctx.cr[6].eq {
	pc = 0x829B16F4; continue 'dispatch;
	}
	// 829B16F0: 4B90F1A1  bl 0x822c0890
	ctx.lr = 0x829B16F4;
	sub_822C0890(ctx, base);
	// 829B16F4: 807C0130  lwz r3, 0x130(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(304 as u32) ) } as u64;
	// 829B16F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B16FC: 419A0008  beq cr6, 0x829b1704
	if ctx.cr[6].eq {
	pc = 0x829B1704; continue 'dispatch;
	}
	// 829B1700: 4B90F191  bl 0x822c0890
	ctx.lr = 0x829B1704;
	sub_822C0890(ctx, base);
	// 829B1704: 807C0128  lwz r3, 0x128(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(296 as u32) ) } as u64;
	// 829B1708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B170C: 419A0008  beq cr6, 0x829b1714
	if ctx.cr[6].eq {
	pc = 0x829B1714; continue 'dispatch;
	}
	// 829B1710: 4B90F181  bl 0x822c0890
	ctx.lr = 0x829B1714;
	sub_822C0890(ctx, base);
	// 829B1714: 807C0120  lwz r3, 0x120(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(288 as u32) ) } as u64;
	// 829B1718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B171C: 419A0008  beq cr6, 0x829b1724
	if ctx.cr[6].eq {
	pc = 0x829B1724; continue 'dispatch;
	}
	// 829B1720: 4B90F171  bl 0x822c0890
	ctx.lr = 0x829B1724;
	sub_822C0890(ctx, base);
	// 829B1724: 807C0118  lwz r3, 0x118(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(280 as u32) ) } as u64;
	// 829B1728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B172C: 419A0008  beq cr6, 0x829b1734
	if ctx.cr[6].eq {
	pc = 0x829B1734; continue 'dispatch;
	}
	// 829B1730: 4B90F161  bl 0x822c0890
	ctx.lr = 0x829B1734;
	sub_822C0890(ctx, base);
	// 829B1734: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829B1738: 4B99DC19  bl 0x8234f350
	ctx.lr = 0x829B173C;
	sub_8234F350(ctx, base);
	// 829B173C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B1740: 487F6A78  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B1748 size=296
    let mut pc: u32 = 0x829B1748;
    'dispatch: loop {
        match pc {
            0x829B1748 => {
    //   block [0x829B1748..0x829B1870)
	// 829B1748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B174C: 487F6A1D  bl 0x831a8168
	ctx.lr = 0x829B1750;
	sub_831A8130(ctx, base);
	// 829B1750: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B1754: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829B1758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B175C: 4BB591F5  bl 0x8250a950
	ctx.lr = 0x829B1760;
	sub_8250A950(ctx, base);
	// 829B1760: 807C015C  lwz r3, 0x15c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(348 as u32) ) } as u64;
	// 829B1764: 3BFC015C  addi r31, r28, 0x15c
	ctx.r[31].s64 = ctx.r[28].s64 + 348;
	// 829B1768: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829B176C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1770: 419A0040  beq cr6, 0x829b17b0
	if ctx.cr[6].eq {
	pc = 0x829B17B0; continue 'dispatch;
	}
	// 829B1774: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B1778: 484CFFC9  bl 0x82e81740
	ctx.lr = 0x829B177C;
	sub_82E81740(ctx, base);
	// 829B177C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B1780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B1784: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829B1788: 409A0008  bne cr6, 0x829b1790
	if !ctx.cr[6].eq {
	pc = 0x829B1790; continue 'dispatch;
	}
	// 829B178C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B1790: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B1794: 4BE2226D  bl 0x827d3a00
	ctx.lr = 0x829B1798;
	sub_827D3A00(ctx, base);
	// 829B1798: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829B179C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B17A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B17A4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829B17A8: 419A0008  beq cr6, 0x829b17b0
	if ctx.cr[6].eq {
	pc = 0x829B17B0; continue 'dispatch;
	}
	// 829B17AC: 4B90F0E5  bl 0x822c0890
	ctx.lr = 0x829B17B0;
	sub_822C0890(ctx, base);
	// 829B17B0: 3BFC016C  addi r31, r28, 0x16c
	ctx.r[31].s64 = ctx.r[28].s64 + 364;
	// 829B17B4: 3BA00008  li r29, 8
	ctx.r[29].s64 = 8;
	// 829B17B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B17BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B17C0: 419A0040  beq cr6, 0x829b1800
	if ctx.cr[6].eq {
	pc = 0x829B1800; continue 'dispatch;
	}
	// 829B17C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B17C8: 484CFF79  bl 0x82e81740
	ctx.lr = 0x829B17CC;
	sub_82E81740(ctx, base);
	// 829B17CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B17D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B17D4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829B17D8: 409A0008  bne cr6, 0x829b17e0
	if !ctx.cr[6].eq {
	pc = 0x829B17E0; continue 'dispatch;
	}
	// 829B17DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B17E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B17E4: 4BE2221D  bl 0x827d3a00
	ctx.lr = 0x829B17E8;
	sub_827D3A00(ctx, base);
	// 829B17E8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829B17EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B17F0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829B17F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B17F8: 419A0008  beq cr6, 0x829b1800
	if ctx.cr[6].eq {
	pc = 0x829B1800; continue 'dispatch;
	}
	// 829B17FC: 4B90F095  bl 0x822c0890
	ctx.lr = 0x829B1800;
	sub_822C0890(ctx, base);
	// 829B1800: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829B1804: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829B1808: 4082FFB0  bne 0x829b17b8
	if !ctx.cr[0].eq {
	pc = 0x829B17B8; continue 'dispatch;
	}
	// 829B180C: 807C0164  lwz r3, 0x164(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(356 as u32) ) } as u64;
	// 829B1810: 3BFC0164  addi r31, r28, 0x164
	ctx.r[31].s64 = ctx.r[28].s64 + 356;
	// 829B1814: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1818: 419A0040  beq cr6, 0x829b1858
	if ctx.cr[6].eq {
	pc = 0x829B1858; continue 'dispatch;
	}
	// 829B181C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B1820: 484CFF21  bl 0x82e81740
	ctx.lr = 0x829B1824;
	sub_82E81740(ctx, base);
	// 829B1824: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B1828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B182C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829B1830: 409A0008  bne cr6, 0x829b1838
	if !ctx.cr[6].eq {
	pc = 0x829B1838; continue 'dispatch;
	}
	// 829B1834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B1838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B183C: 4BE221C5  bl 0x827d3a00
	ctx.lr = 0x829B1840;
	sub_827D3A00(ctx, base);
	// 829B1840: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829B1844: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B1848: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B184C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829B1850: 419A0008  beq cr6, 0x829b1858
	if ctx.cr[6].eq {
	pc = 0x829B1858; continue 'dispatch;
	}
	// 829B1854: 4B90F03D  bl 0x822c0890
	ctx.lr = 0x829B1858;
	sub_822C0890(ctx, base);
	// 829B1858: 807C0238  lwz r3, 0x238(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(568 as u32) ) } as u64;
	// 829B185C: 48194E6D  bl 0x82b466c8
	ctx.lr = 0x829B1860;
	sub_82B466C8(ctx, base);
	// 829B1860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B1864: 4844042D  bl 0x82df1c90
	ctx.lr = 0x829B1868;
	sub_82DF1C90(ctx, base);
	// 829B1868: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B186C: 487F694C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B1870 size=660
    let mut pc: u32 = 0x829B1870;
    'dispatch: loop {
        match pc {
            0x829B1870 => {
    //   block [0x829B1870..0x829B1B04)
	// 829B1870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B1874: 487F68E9  bl 0x831a815c
	ctx.lr = 0x829B1878;
	sub_831A8130(ctx, base);
	// 829B1878: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829B187C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B1880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B1884: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 829B1888: 4BB5EE81  bl 0x82510708
	ctx.lr = 0x829B188C;
	sub_82510708(ctx, base);
	// 829B188C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B1890: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B1894: 997F0234  stb r11, 0x234(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u8 ) };
	// 829B1898: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B189C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829B18A0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 829B18A4: 3B4B22C0  addi r26, r11, 0x22c0
	ctx.r[26].s64 = ctx.r[11].s64 + 8896;
	// 829B18A8: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B18AC: 897F0142  lbz r11, 0x142(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(322 as u32) ) } as u64;
	// 829B18B0: 7F7EE830  slw r30, r27, r29
	if (ctx.r[29].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[27].u32) << ((ctx.r[29].u8 & 0x1F) as u32)) as u64;
	}
	// 829B18B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B18B8: 897F0235  lbz r11, 0x235(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(565 as u32) ) } as u64;
	// 829B18BC: 41820128  beq 0x829b19e4
	if ctx.cr[0].eq {
	pc = 0x829B19E4; continue 'dispatch;
	}
	// 829B18C0: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B18C4: 897F0234  lbz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 829B18C8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B18CC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 829B18D0: 4182000C  beq 0x829b18dc
	if ctx.cr[0].eq {
	pc = 0x829B18DC; continue 'dispatch;
	}
	// 829B18D4: 41980138  blt cr6, 0x829b1a0c
	if ctx.cr[6].lt {
	pc = 0x829B1A0C; continue 'dispatch;
	}
	// 829B18D8: 48000114  b 0x829b19ec
	pc = 0x829B19EC; continue 'dispatch;
	// 829B18DC: 40980130  bge cr6, 0x829b1a0c
	if !ctx.cr[6].lt {
	pc = 0x829B1A0C; continue 'dispatch;
	}
	// 829B18E0: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B18E4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 829B18E8: 806B016C  lwz r3, 0x16c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(364 as u32) ) } as u64;
	// 829B18EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B18F0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829B18F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B18F8: 4E800421  bctrl
	ctx.lr = 0x829B18FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B18FC: 897F0235  lbz r11, 0x235(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(565 as u32) ) } as u64;
	// 829B1900: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829B1904: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 829B1908: 997F0235  stb r11, 0x235(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(565 as u32), ctx.r[11].u8 ) };
	// 829B190C: 409A0100  bne cr6, 0x829b1a0c
	if !ctx.cr[6].eq {
	pc = 0x829B1A0C; continue 'dispatch;
	}
	// 829B1910: 3BDF01F4  addi r30, r31, 0x1f4
	ctx.r[30].s64 = ctx.r[31].s64 + 500;
	// 829B1914: 3B800008  li r28, 8
	ctx.r[28].s64 = 8;
	// 829B1918: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829B191C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B1920: 484420E9  bl 0x82df3a08
	ctx.lr = 0x829B1924;
	sub_82DF3A08(ctx, base);
	// 829B1924: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B1928: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B192C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B1930: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829B1934: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 829B1938: 419A0024  beq cr6, 0x829b195c
	if ctx.cr[6].eq {
	pc = 0x829B195C; continue 'dispatch;
	}
	// 829B193C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B1940: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B1944: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B1948: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B194C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B1950: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B1954: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B1958: 4082FFE8  bne 0x829b1940
	if !ctx.cr[0].eq {
	pc = 0x829B1940; continue 'dispatch;
	}
	// 829B195C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B1960: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B1964: 4BB5DB65  bl 0x8250f4c8
	ctx.lr = 0x829B1968;
	sub_8250F4C8(ctx, base);
	// 829B1968: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B196C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B1970: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829B1974: 409A0008  bne cr6, 0x829b197c
	if !ctx.cr[6].eq {
	pc = 0x829B197C; continue 'dispatch;
	}
	// 829B1978: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B197C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B1980: 4BB58FD1  bl 0x8250a950
	ctx.lr = 0x829B1984;
	sub_8250A950(ctx, base);
	// 829B1984: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B198C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829B1990: 409A0008  bne cr6, 0x829b1998
	if !ctx.cr[6].eq {
	pc = 0x829B1998; continue 'dispatch;
	}
	// 829B1994: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829B1998: 38C0000B  li r6, 0xb
	ctx.r[6].s64 = 11;
	// 829B199C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B19A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829B19A4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829B19A8: 4BE227F9  bl 0x827d41a0
	ctx.lr = 0x829B19AC;
	sub_827D41A0(ctx, base);
	// 829B19AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B19B0: 484402E1  bl 0x82df1c90
	ctx.lr = 0x829B19B4;
	sub_82DF1C90(ctx, base);
	// 829B19B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B19B8: 484402D9  bl 0x82df1c90
	ctx.lr = 0x829B19BC;
	sub_82DF1C90(ctx, base);
	// 829B19BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829B19C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B19C4: 419A0008  beq cr6, 0x829b19cc
	if ctx.cr[6].eq {
	pc = 0x829B19CC; continue 'dispatch;
	}
	// 829B19C8: 4B90EEC9  bl 0x822c0890
	ctx.lr = 0x829B19CC;
	sub_822C0890(ctx, base);
	// 829B19CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B19D0: 48441A59  bl 0x82df3428
	ctx.lr = 0x829B19D4;
	sub_82DF3428(ctx, base);
	// 829B19D4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829B19D8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829B19DC: 4082FF3C  bne 0x829b1918
	if !ctx.cr[0].eq {
	pc = 0x829B1918; continue 'dispatch;
	}
	// 829B19E0: 4800002C  b 0x829b1a0c
	pc = 0x829B1A0C; continue 'dispatch;
	// 829B19E4: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B19E8: 41820024  beq 0x829b1a0c
	if ctx.cr[0].eq {
	pc = 0x829B1A0C; continue 'dispatch;
	}
	// 829B19EC: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B19F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B19F4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 829B19F8: 806B016C  lwz r3, 0x16c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(364 as u32) ) } as u64;
	// 829B19FC: 484CFD45  bl 0x82e81740
	ctx.lr = 0x829B1A00;
	sub_82E81740(ctx, base);
	// 829B1A00: 897F0235  lbz r11, 0x235(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(565 as u32) ) } as u64;
	// 829B1A04: 7D6BF078  andc r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[30].u64;
	// 829B1A08: 997F0235  stb r11, 0x235(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(565 as u32), ctx.r[11].u8 ) };
	// 829B1A0C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 829B1A10: 2F1D0008  cmpwi cr6, r29, 8
	ctx.cr[6].compare_i32(ctx.r[29].s32, 8, &mut ctx.xer);
	// 829B1A14: 4198FE98  blt cr6, 0x829b18ac
	if ctx.cr[6].lt {
	pc = 0x829B18AC; continue 'dispatch;
	}
	// 829B1A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B1A1C: C0390000  lfs f1, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B1A20: 4BFFF699  bl 0x829b10b8
	ctx.lr = 0x829B1A24;
	sub_829B10B8(ctx, base);
	// 829B1A24: 897F0140  lbz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 829B1A28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B1A2C: 408200AC  bne 0x829b1ad8
	if !ctx.cr[0].eq {
	pc = 0x829B1AD8; continue 'dispatch;
	}
	// 829B1A30: 895F0149  lbz r10, 0x149(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(329 as u32) ) } as u64;
	// 829B1A34: 897F0148  lbz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 829B1A38: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829B1A3C: 419A009C  beq cr6, 0x829b1ad8
	if ctx.cr[6].eq {
	pc = 0x829B1AD8; continue 'dispatch;
	}
	// 829B1A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B1A44: 419A0048  beq cr6, 0x829b1a8c
	if ctx.cr[6].eq {
	pc = 0x829B1A8C; continue 'dispatch;
	}
	// 829B1A48: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 829B1A4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B1A50: 388B0060  addi r4, r11, 0x60
	ctx.r[4].s64 = ctx.r[11].s64 + 96;
	// 829B1A54: 48441FB5  bl 0x82df3a08
	ctx.lr = 0x829B1A58;
	sub_82DF3A08(ctx, base);
	// 829B1A58: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B1A5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829B1A60: 809F011C  lwz r4, 0x11c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 829B1A64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829B1A68: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829B1A6C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829B1A70: 48201909  bl 0x82bb3378
	ctx.lr = 0x829B1A74;
	sub_82BB3378(ctx, base);
	// 829B1A74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829B1A78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1A7C: 419A0008  beq cr6, 0x829b1a84
	if ctx.cr[6].eq {
	pc = 0x829B1A84; continue 'dispatch;
	}
	// 829B1A80: 4B90EE11  bl 0x822c0890
	ctx.lr = 0x829B1A84;
	sub_822C0890(ctx, base);
	// 829B1A84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B1A88: 48000044  b 0x829b1acc
	pc = 0x829B1ACC; continue 'dispatch;
	// 829B1A8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B1A90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B1A94: 388B22B8  addi r4, r11, 0x22b8
	ctx.r[4].s64 = ctx.r[11].s64 + 8888;
	// 829B1A98: 48441F71  bl 0x82df3a08
	ctx.lr = 0x829B1A9C;
	sub_82DF3A08(ctx, base);
	// 829B1A9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B1AA0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829B1AA4: 809F011C  lwz r4, 0x11c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 829B1AA8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829B1AAC: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829B1AB0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829B1AB4: 482018C5  bl 0x82bb3378
	ctx.lr = 0x829B1AB8;
	sub_82BB3378(ctx, base);
	// 829B1AB8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829B1ABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B1AC0: 419A0008  beq cr6, 0x829b1ac8
	if ctx.cr[6].eq {
	pc = 0x829B1AC8; continue 'dispatch;
	}
	// 829B1AC4: 4B90EDCD  bl 0x822c0890
	ctx.lr = 0x829B1AC8;
	sub_822C0890(ctx, base);
	// 829B1AC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B1ACC: 4844195D  bl 0x82df3428
	ctx.lr = 0x829B1AD0;
	sub_82DF3428(ctx, base);
	// 829B1AD0: 897F0148  lbz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 829B1AD4: 997F0149  stb r11, 0x149(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(329 as u32), ctx.r[11].u8 ) };
	// 829B1AD8: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B1ADC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829B1AE0: 4844CD01  bl 0x82dfe7e0
	ctx.lr = 0x829B1AE4;
	sub_82DFE7E0(ctx, base);
	// 829B1AE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B1AE8: 41820010  beq 0x829b1af8
	if ctx.cr[0].eq {
	pc = 0x829B1AF8; continue 'dispatch;
	}
	// 829B1AEC: C0390000  lfs f1, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B1AF0: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 829B1AF4: 482039FD  bl 0x82bb54f0
	ctx.lr = 0x829B1AF8;
	sub_82BB54F0(ctx, base);
	// 829B1AF8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829B1AFC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 829B1B00: 487F66AC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B1B08 size=20
    let mut pc: u32 = 0x829B1B08;
    'dispatch: loop {
        match pc {
            0x829B1B08 => {
    //   block [0x829B1B08..0x829B1B1C)
	// 829B1B08: 8144015C  lwz r10, 0x15c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(348 as u32) ) } as u64;
	// 829B1B0C: 39240158  addi r9, r4, 0x158
	ctx.r[9].s64 = ctx.r[4].s64 + 344;
	// 829B1B10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1B14: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829B1B18: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1B1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B1B1C size=116
    let mut pc: u32 = 0x829B1B1C;
    'dispatch: loop {
        match pc {
            0x829B1B1C => {
    //   block [0x829B1B1C..0x829B1B90)
	// 829B1B1C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B1B20: 3D008212  lis r8, -0x7dee
	ctx.r[8].s64 = -2112749568;
	// 829B1B24: C1AA22D8  lfs f13, 0x22d8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8920 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B1B28: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829B1B2C: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 829B1B30: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 829B1B34: C0030150  lfs f0, 0x150(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B1B38: 394A0060  addi r10, r10, 0x60
	ctx.r[10].s64 = ctx.r[10].s64 + 96;
	// 829B1B3C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B1B90 size=120
    let mut pc: u32 = 0x829B1B90;
    'dispatch: loop {
        match pc {
            0x829B1B90 => {
    //   block [0x829B1B90..0x829B1C08)
	// 829B1B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B1B94: 487F65D9  bl 0x831a816c
	ctx.lr = 0x829B1B98;
	sub_831A8130(ctx, base);
	// 829B1B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B1B9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B1BA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B1BA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B1BA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B1BAC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829B1BB0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829B1BB4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829B1BB8: 48440831  bl 0x82df23e8
	ctx.lr = 0x829B1BBC;
	sub_82DF23E8(ctx, base);
	// 829B1BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B1BC0: 41820014  beq 0x829b1bd4
	if ctx.cr[0].eq {
	pc = 0x829B1BD4; continue 'dispatch;
	}
	// 829B1BC4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B1BC8: 4819F611  bl 0x82b511d8
	ctx.lr = 0x829B1BCC;
	sub_82B511D8(ctx, base);
	// 829B1BCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B1BD0: 48000008  b 0x829b1bd8
	pc = 0x829B1BD8; continue 'dispatch;
	// 829B1BD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B1BD8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829B1BDC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829B1BE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B1BE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B1BE8: 4BFFEA69  bl 0x829b0650
	ctx.lr = 0x829B1BEC;
	sub_829B0650(ctx, base);
	// 829B1BEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B1BF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B1BF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B1BF8: 4B90E409  bl 0x822c0000
	ctx.lr = 0x829B1BFC;
	sub_822C0000(ctx, base);
	// 829B1BFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B1C00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B1C04: 487F65B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B1C08 size=76
    let mut pc: u32 = 0x829B1C08;
    'dispatch: loop {
        match pc {
            0x829B1C08 => {
    //   block [0x829B1C08..0x829B1C54)
	// 829B1C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B1C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B1C10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B1C14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B1C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B1C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B1C20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B1C24: 4BFFF9DD  bl 0x829b1600
	ctx.lr = 0x829B1C28;
	sub_829B1600(ctx, base);
	// 829B1C28: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B1C2C: 4182000C  beq 0x829b1c38
	if ctx.cr[0].eq {
	pc = 0x829B1C38; continue 'dispatch;
	}
	// 829B1C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B1C34: 484407A5  bl 0x82df23d8
	ctx.lr = 0x829B1C38;
	sub_82DF23D8(ctx, base);
	// 829B1C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B1C3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B1C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B1C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B1C48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B1C4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B1C50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B1C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B1C58 size=1396
    let mut pc: u32 = 0x829B1C58;
    'dispatch: loop {
        match pc {
            0x829B1C58 => {
    //   block [0x829B1C58..0x829B21CC)
	// 829B1C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B1C5C: 487F64F1  bl 0x831a814c
	ctx.lr = 0x829B1C60;
	sub_831A8130(ctx, base);
	// 829B1C60: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 829B1C64: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B21D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B21D0 size=164
    let mut pc: u32 = 0x829B21D0;
    'dispatch: loop {
        match pc {
            0x829B21D0 => {
    //   block [0x829B21D0..0x829B2274)
	// 829B21D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B21D4: 487F5F95  bl 0x831a8168
	ctx.lr = 0x829B21D8;
	sub_831A8130(ctx, base);
	// 829B21D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B21DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829B21E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B21E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B21E8: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829B21EC: 41820038  beq 0x829b2224
	if ctx.cr[0].eq {
	pc = 0x829B2224; continue 'dispatch;
	}
	// 829B21F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B21F4: 487F7795  bl 0x831a9988
	ctx.lr = 0x829B21F8;
	sub_831A9988(ctx, base);
	// 829B21F8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829B21FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B2200: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829B2204: 487F5EF5  bl 0x831a80f8
	ctx.lr = 0x829B2208;
	sub_831A80F8(ctx, base);
	// 829B2208: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B220C: 41820018  beq 0x829b2224
	if ctx.cr[0].eq {
	pc = 0x829B2224; continue 'dispatch;
	}
	// 829B2210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B2214: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829B2218: 4BFFFA41  bl 0x829b1c58
	ctx.lr = 0x829B221C;
	sub_829B1C58(ctx, base);
	// 829B221C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829B2220: 4800004C  b 0x829b226c
	pc = 0x829B226C; continue 'dispatch;
	// 829B2224: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829B2228: 419A0034  beq cr6, 0x829b225c
	if ctx.cr[6].eq {
	pc = 0x829B225C; continue 'dispatch;
	}
	// 829B222C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B2230: 487F7759  bl 0x831a9988
	ctx.lr = 0x829B2234;
	sub_831A9988(ctx, base);
	// 829B2234: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 829B2238: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B223C: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 829B2240: 487F5EB9  bl 0x831a80f8
	ctx.lr = 0x829B2244;
	sub_831A80F8(ctx, base);
	// 829B2244: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B2248: 41820014  beq 0x829b225c
	if ctx.cr[0].eq {
	pc = 0x829B225C; continue 'dispatch;
	}
	// 829B224C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B2250: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829B2254: 4BFFEDFD  bl 0x829b1050
	ctx.lr = 0x829B2258;
	sub_829B1050(ctx, base);
	// 829B2258: 4BFFFFC4  b 0x829b221c
	pc = 0x829B221C; continue 'dispatch;
	// 829B225C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829B2260: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B2264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B2268: 4BB603B1  bl 0x82512618
	ctx.lr = 0x829B226C;
	sub_82512618(ctx, base);
	// 829B226C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B2270: 487F5F48  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B2278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B2278 size=128
    let mut pc: u32 = 0x829B2278;
    'dispatch: loop {
        match pc {
            0x829B2278 => {
    //   block [0x829B2278..0x829B22F8)
	// 829B2278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B227C: 487F5EF1  bl 0x831a816c
	ctx.lr = 0x829B2280;
	sub_831A8130(ctx, base);
	// 829B2280: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B2284: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829B2288: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829B228C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B2290: 3BEBCB40  addi r31, r11, -0x34c0
	ctx.r[31].s64 = ctx.r[11].s64 + -13504;
	// 829B2294: 816ACB48  lwz r11, -0x34b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13496 as u32) ) } as u64;
	// 829B2298: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829B229C: 40820024  bne 0x829b22c0
	if !ctx.cr[0].eq {
	pc = 0x829B22C0; continue 'dispatch;
	}
	// 829B22A0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829B22A4: 3D00829B  lis r8, -0x7d65
	ctx.r[8].s64 = -2103771136;
	// 829B22A8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829B22AC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829B22B0: 39081428  addi r8, r8, 0x1428
	ctx.r[8].s64 = ctx.r[8].s64 + 5160;
	// 829B22B4: 916ACB48  stw r11, -0x34b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13496 as u32), ctx.r[11].u32 ) };
	// 829B22B8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829B22BC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829B22C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829B22C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829B22C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B22CC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829B22D0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829B22D4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B22D8: 4BCA22E9  bl 0x826545c0
	ctx.lr = 0x829B22DC;
	sub_826545C0(ctx, base);
	// 829B22DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B22E0: 4182000C  beq 0x829b22ec
	if ctx.cr[0].eq {
	pc = 0x829B22EC; continue 'dispatch;
	}
	// 829B22E4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829B22E8: 48000008  b 0x829b22f0
	pc = 0x829B22F0; continue 'dispatch;
	// 829B22EC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829B22F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B22F4: 487F5EC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B22F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B22F8 size=5628
    let mut pc: u32 = 0x829B22F8;
    'dispatch: loop {
        match pc {
            0x829B22F8 => {
    //   block [0x829B22F8..0x829B38F4)
	// 829B22F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B22FC: 487F5E39  bl 0x831a8134
	ctx.lr = 0x829B2300;
	sub_831A8130(ctx, base);
	// 829B2300: DBA1FF58  stfd f29, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[29].u64 ) };
	// 829B2304: DBC1FF60  stfd f30, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 829B2308: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 829B230C: 9421FBF0  stwu r1, -0x410(r1)
	ea = ctx.r[1].u32.wrapping_add(-1040 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B2310: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 829B2314: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 829B2318: 7E4F9378  mr r15, r18
	ctx.r[15].u64 = ctx.r[18].u64;
	// 829B231C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829B2320: 91E10080  stw r15, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[15].u32 ) };
	// 829B2324: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 829B2328: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 829B232C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 829B2330: 4BB5FDE9  bl 0x82512118
	ctx.lr = 0x829B2334;
	sub_82512118(ctx, base);
	// 829B2334: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B2338: 8075012C  lwz r3, 0x12c(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(300 as u32) ) } as u64;
	// 829B233C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2340: 48460AF1  bl 0x82e12e30
	ctx.lr = 0x829B2344;
	sub_82E12E30(ctx, base);
	// 829B2344: 80610234  lwz r3, 0x234(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 829B2348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B234C: 419A0008  beq cr6, 0x829b2354
	if ctx.cr[6].eq {
	pc = 0x829B2354; continue 'dispatch;
	}
	// 829B2350: 4B90E541  bl 0x822c0890
	ctx.lr = 0x829B2354;
	sub_822C0890(ctx, base);
	// 829B2354: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829B2358: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B235C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829B2360: 484416A9  bl 0x82df3a08
	ctx.lr = 0x829B2364;
	sub_82DF3A08(ctx, base);
	// 829B2364: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 829B2368: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829B236C: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 829B2370: 4BB56411  bl 0x82508780
	ctx.lr = 0x829B2374;
	sub_82508780(ctx, base);
	// 829B2374: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B2378: 484410B1  bl 0x82df3428
	ctx.lr = 0x829B237C;
	sub_82DF3428(ctx, base);
	// 829B237C: 3A950028  addi r20, r21, 0x28
	ctx.r[20].s64 = ctx.r[21].s64 + 40;
	// 829B2380: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 829B2384: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 829B2388: 4BB56419  bl 0x825087a0
	ctx.lr = 0x829B238C;
	sub_825087A0(ctx, base);
	// 829B238C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829B2390: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2394: 48478755  bl 0x82e2aae8
	ctx.lr = 0x829B2398;
	sub_82E2AAE8(ctx, base);
	// 829B2398: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B239C: 92410078  stw r18, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[18].u32 ) };
	// 829B23A0: 3A2B22E0  addi r17, r11, 0x22e0
	ctx.r[17].s64 = ctx.r[11].s64 + 8928;
	// 829B23A4: 9241007C  stw r18, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[18].u32 ) };
	// 829B23A8: 89750140  lbz r11, 0x140(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(320 as u32) ) } as u64;
	// 829B23AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B23B0: 4198005C  blt cr6, 0x829b240c
	if ctx.cr[6].lt {
	pc = 0x829B240C; continue 'dispatch;
	}
	// 829B23B4: 409A0180  bne cr6, 0x829b2534
	if !ctx.cr[6].eq {
	pc = 0x829B2534; continue 'dispatch;
	}
	// 829B23B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B23BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B23C0: 388B2488  addi r4, r11, 0x2488
	ctx.r[4].s64 = ctx.r[11].s64 + 9352;
	// 829B23C4: 48441645  bl 0x82df3a08
	ctx.lr = 0x829B23C8;
	sub_82DF3A08(ctx, base);
	// 829B23C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B23CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829B23D0: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 829B23D4: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 829B23D8: 4847CA99  bl 0x82e2ee70
	ctx.lr = 0x829B23DC;
	sub_82E2EE70(ctx, base);
	// 829B23DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B23E0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 829B23E4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829B23E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B23EC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829B23F0: 4B912071  bl 0x822c4460
	ctx.lr = 0x829B23F4;
	sub_822C4460(ctx, base);
	// 829B23F4: 80610254  lwz r3, 0x254(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(596 as u32) ) } as u64;
	// 829B23F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B23FC: 419A0008  beq cr6, 0x829b2404
	if ctx.cr[6].eq {
	pc = 0x829B2404; continue 'dispatch;
	}
	// 829B2400: 4B90E491  bl 0x822c0890
	ctx.lr = 0x829B2404;
	sub_822C0890(ctx, base);
	// 829B2404: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B2408: 48000054  b 0x829b245c
	pc = 0x829B245C; continue 'dispatch;
	// 829B240C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B2410: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B2414: 388B2478  addi r4, r11, 0x2478
	ctx.r[4].s64 = ctx.r[11].s64 + 9336;
	// 829B2418: 484415F1  bl 0x82df3a08
	ctx.lr = 0x829B241C;
	sub_82DF3A08(ctx, base);
	// 829B241C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B2420: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 829B2424: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 829B2428: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 829B242C: 4847CA45  bl 0x82e2ee70
	ctx.lr = 0x829B2430;
	sub_82E2EE70(ctx, base);
	// 829B2430: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B2434: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 829B2438: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829B243C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2440: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829B2444: 4B91201D  bl 0x822c4460
	ctx.lr = 0x829B2448;
	sub_822C4460(ctx, base);
	// 829B2448: 8061025C  lwz r3, 0x25c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(604 as u32) ) } as u64;
	// 829B244C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B2450: 419A0008  beq cr6, 0x829b2458
	if ctx.cr[6].eq {
	pc = 0x829B2458; continue 'dispatch;
	}
	// 829B2454: 4B90E43D  bl 0x822c0890
	ctx.lr = 0x829B2458;
	sub_822C0890(ctx, base);
	// 829B2458: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B245C: 48440FCD  bl 0x82df3428
	ctx.lr = 0x829B2460;
	sub_82DF3428(ctx, base);
	// 829B2460: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829B2464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B2468: 419A00CC  beq cr6, 0x829b2534
	if ctx.cr[6].eq {
	pc = 0x829B2534; continue 'dispatch;
	}
	// 829B246C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 829B2470: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B2474: 38A00097  li r5, 0x97
	ctx.r[5].s64 = 151;
	// 829B2478: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 829B247C: 4843FF6D  bl 0x82df23e8
	ctx.lr = 0x829B2480;
	sub_82DF23E8(ctx, base);
	// 829B2480: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B2484: 41820014  beq 0x829b2498
	if ctx.cr[0].eq {
	pc = 0x829B2498; continue 'dispatch;
	}
	// 829B2488: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 829B248C: 48464405  bl 0x82e16890
	ctx.lr = 0x829B2490;
	sub_82E16890(ctx, base);
	// 829B2490: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B2494: 48000008  b 0x829b249c
	pc = 0x829B249C; continue 'dispatch;
	// 829B2498: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 829B249C: 38750114  addi r3, r21, 0x114
	ctx.r[3].s64 = ctx.r[21].s64 + 276;
	// 829B24A0: 4B9AAED1  bl 0x8235d370
	ctx.lr = 0x829B24A4;
	sub_8235D370(ctx, base);
	// 829B24A4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829B24A8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829B24AC: 83F50114  lwz r31, 0x114(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B24B0: 4BB5FC69  bl 0x82512118
	ctx.lr = 0x829B24B4;
	sub_82512118(ctx, base);
	// 829B24B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B24B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B24BC: 48462BF5  bl 0x82e150b0
	ctx.lr = 0x829B24C0;
	sub_82E150B0(ctx, base);
	// 829B24C0: 81750114  lwz r11, 0x114(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B24C4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829B24C8: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 829B24CC: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 829B24D0: 4BB5F8C9  bl 0x82511d98
	ctx.lr = 0x829B24D4;
	sub_82511D98(ctx, base);
	// 829B24D4: 81750118  lwz r11, 0x118(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(280 as u32) ) } as u64;
	// 829B24D8: 81550114  lwz r10, 0x114(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B24DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B24E0: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 829B24E4: 914100B8  stw r10, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 829B24E8: 419A0024  beq cr6, 0x829b250c
	if ctx.cr[6].eq {
	pc = 0x829B250C; continue 'dispatch;
	}
	// 829B24EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B24F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B24F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B24F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B24FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B2500: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B2504: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B2508: 4082FFE8  bne 0x829b24f0
	if !ctx.cr[0].eq {
	pc = 0x829B24F0; continue 'dispatch;
	}
	// 829B250C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829B2510: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829B2514: 38A100B8  addi r5, r1, 0xb8
	ctx.r[5].s64 = ctx.r[1].s64 + 184;
	// 829B2518: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829B251C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 829B2520: 4BB5E4D9  bl 0x825109f8
	ctx.lr = 0x829B2524;
	sub_825109F8(ctx, base);
	// 829B2524: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829B2528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B252C: 419A0008  beq cr6, 0x829b2534
	if ctx.cr[6].eq {
	pc = 0x829B2534; continue 'dispatch;
	}
	// 829B2530: 4B90E361  bl 0x822c0890
	ctx.lr = 0x829B2534;
	sub_822C0890(ctx, base);
	// 829B2534: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B2538: 81550114  lwz r10, 0x114(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B253C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829B2540: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B2544: 419A047C  beq cr6, 0x829b29c0
	if ctx.cr[6].eq {
	pc = 0x829B29C0; continue 'dispatch;
	}
	// 829B2548: 89750140  lbz r11, 0x140(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(320 as u32) ) } as u64;
	// 829B254C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B2550: 419801D4  blt cr6, 0x829b2724
	if ctx.cr[6].lt {
	pc = 0x829B2724; continue 'dispatch;
	}
	// 829B2554: 409A046C  bne cr6, 0x829b29c0
	if !ctx.cr[6].eq {
	pc = 0x829B29C0; continue 'dispatch;
	}
	// 829B2558: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B255C: D3E10110  stfs f31, 0x110(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829B2560: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829B2564: 9241010C  stw r18, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[18].u32 ) };
	// 829B2568: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829B256C: 9A41011C  stb r18, 0x11c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[18].u8 ) };
	// 829B2570: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829B2574: 3BCBD748  addi r30, r11, -0x28b8
	ctx.r[30].s64 = ctx.r[11].s64 + -10424;
	// 829B2578: 3968246C  addi r11, r8, 0x246c
	ctx.r[11].s64 = ctx.r[8].s64 + 9324;
	// 829B257C: C3AA08A8  lfs f29, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829B2580: C3C99534  lfs f30, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829B2584: 93C10100  stw r30, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 829B2588: D3A10108  stfs f29, 0x108(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829B258C: 91610104  stw r11, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 829B2590: D3C10114  stfs f30, 0x114(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 829B2594: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 829B2598: D3C10118  stfs f30, 0x118(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 829B259C: 4844C32D  bl 0x82dfe8c8
	ctx.lr = 0x829B25A0;
	sub_82DFE8C8(ctx, base);
	// 829B25A0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 829B25A4: 4844C325  bl 0x82dfe8c8
	ctx.lr = 0x829B25A8;
	sub_82DFE8C8(ctx, base);
	// 829B25A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B25AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B25B0: D3A10138  stfs f29, 0x138(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 829B25B4: 396BB1A8  addi r11, r11, -0x4e58
	ctx.r[11].s64 = ctx.r[11].s64 + -20056;
	// 829B25B8: D3E10140  stfs f31, 0x140(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 829B25BC: 394A2460  addi r10, r10, 0x2460
	ctx.r[10].s64 = ctx.r[10].s64 + 9312;
	// 829B25C0: D3C10144  stfs f30, 0x144(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 829B25C4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829B25C8: D3C10148  stfs f30, 0x148(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 829B25CC: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 829B25D0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829B25D4: 91410134  stw r10, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[10].u32 ) };
	// 829B25D8: 9121013C  stw r9, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[9].u32 ) };
	// 829B25DC: 9A41014C  stb r18, 0x14c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[18].u8 ) };
	// 829B25E0: 4844C2E9  bl 0x82dfe8c8
	ctx.lr = 0x829B25E4;
	sub_82DFE8C8(ctx, base);
	// 829B25E4: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 829B25E8: 4844C2E1  bl 0x82dfe8c8
	ctx.lr = 0x829B25EC;
	sub_82DFE8C8(ctx, base);
	// 829B25EC: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 829B25F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B25F4: 38A000CC  li r5, 0xcc
	ctx.r[5].s64 = 204;
	// 829B25F8: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 829B25FC: 4843FDED  bl 0x82df23e8
	ctx.lr = 0x829B2600;
	sub_82DF23E8(ctx, base);
	// 829B2600: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829B2604: 41820040  beq 0x829b2644
	if ctx.cr[0].eq {
	pc = 0x829B2644; continue 'dispatch;
	}
	// 829B2608: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B260C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B2610: 388B2450  addi r4, r11, 0x2450
	ctx.r[4].s64 = ctx.r[11].s64 + 9296;
	// 829B2614: 484413F5  bl 0x82df3a08
	ctx.lr = 0x829B2618;
	sub_82DF3A08(ctx, base);
	// 829B2618: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829B261C: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 829B2620: 39E0000C  li r15, 0xc
	ctx.r[15].s64 = 12;
	// 829B2624: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 829B2628: 4BB5CEA1  bl 0x8250f4c8
	ctx.lr = 0x829B262C;
	sub_8250F4C8(ctx, base);
	// 829B262C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B2630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B2634: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829B2638: 482015C9  bl 0x82bb3c00
	ctx.lr = 0x829B263C;
	sub_82BB3C00(ctx, base);
	// 829B263C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B2640: 48000008  b 0x829b2648
	pc = 0x829B2648; continue 'dispatch;
	// 829B2644: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 829B2648: 3BF5011C  addi r31, r21, 0x11c
	ctx.r[31].s64 = ctx.r[21].s64 + 284;
	// 829B264C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B2650: 4B9AAD91  bl 0x8235d3e0
	ctx.lr = 0x829B2654;
	sub_8235D3E0(ctx, base);
	// 829B2654: 55EB0739  rlwinm. r11, r15, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B2658: 41820010  beq 0x829b2668
	if ctx.cr[0].eq {
	pc = 0x829B2668; continue 'dispatch;
	}
	// 829B265C: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 829B2660: 55EF0776  rlwinm r15, r15, 0, 0x1d, 0x1b
	ctx.r[15].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 829B2664: 4843F62D  bl 0x82df1c90
	ctx.lr = 0x829B2668;
	sub_82DF1C90(ctx, base);
	// 829B2668: 55EB077B  rlwinm. r11, r15, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B266C: 41820010  beq 0x829b267c
	if ctx.cr[0].eq {
	pc = 0x829B267C; continue 'dispatch;
	}
	// 829B2670: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829B2674: 55EF07B8  rlwinm r15, r15, 0, 0x1e, 0x1c
	ctx.r[15].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 829B2678: 48440DB1  bl 0x82df3428
	ctx.lr = 0x829B267C;
	sub_82DF3428(ctx, base);
	// 829B267C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2680: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829B2684: 419A033C  beq cr6, 0x829b29c0
	if ctx.cr[6].eq {
	pc = 0x829B29C0; continue 'dispatch;
	}
	// 829B2688: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829B268C: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 829B2690: 482028D1  bl 0x82bb4f60
	ctx.lr = 0x829B2694;
	sub_82BB4F60(ctx, base);
	// 829B2694: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B2698: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B269C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B26A0: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 829B26A4: 914100C8  stw r10, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 829B26A8: 419A0024  beq cr6, 0x829b26cc
	if ctx.cr[6].eq {
	pc = 0x829B26CC; continue 'dispatch;
	}
	// 829B26AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B26B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B26B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B26B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B26BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B26C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B26C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B26C8: 4082FFE8  bne 0x829b26b0
	if !ctx.cr[0].eq {
	pc = 0x829B26B0; continue 'dispatch;
	}
	// 829B26CC: 388100C8  addi r4, r1, 0xc8
	ctx.r[4].s64 = ctx.r[1].s64 + 200;
	// 829B26D0: 80750114  lwz r3, 0x114(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B26D4: 4846289D  bl 0x82e14f70
	ctx.lr = 0x829B26D8;
	sub_82E14F70(ctx, base);
	// 829B26D8: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829B26DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B26E0: 419A0008  beq cr6, 0x829b26e8
	if ctx.cr[6].eq {
	pc = 0x829B26E8; continue 'dispatch;
	}
	// 829B26E4: 4B90E1AD  bl 0x822c0890
	ctx.lr = 0x829B26E8;
	sub_822C0890(ctx, base);
	// 829B26E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B26EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B26F0: 48441319  bl 0x82df3a08
	ctx.lr = 0x829B26F4;
	sub_82DF3A08(ctx, base);
	// 829B26F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829B26F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829B26FC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2700: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 829B2704: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B2708: 48200519  bl 0x82bb2c20
	ctx.lr = 0x829B270C;
	sub_82BB2C20(ctx, base);
	// 829B270C: 8061027C  lwz r3, 0x27c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(636 as u32) ) } as u64;
	// 829B2710: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B2714: 419A0008  beq cr6, 0x829b271c
	if ctx.cr[6].eq {
	pc = 0x829B271C; continue 'dispatch;
	}
	// 829B2718: 4B90E179  bl 0x822c0890
	ctx.lr = 0x829B271C;
	sub_822C0890(ctx, base);
	// 829B271C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B2720: 4800029C  b 0x829b29bc
	pc = 0x829B29BC; continue 'dispatch;
	// 829B2724: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B2728: D3E10110  stfs f31, 0x110(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829B272C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829B2730: 9241010C  stw r18, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[18].u32 ) };
	// 829B2734: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B2738: 9A41011C  stb r18, 0x11c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[18].u8 ) };
	// 829B273C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829B2740: 3BCB22B8  addi r30, r11, 0x22b8
	ctx.r[30].s64 = ctx.r[11].s64 + 8888;
	// 829B2744: 39682444  addi r11, r8, 0x2444
	ctx.r[11].s64 = ctx.r[8].s64 + 9284;
	// 829B2748: C3AA08A8  lfs f29, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829B274C: C3C99534  lfs f30, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829B2750: 93C10100  stw r30, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 829B2754: D3A10108  stfs f29, 0x108(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829B2758: 91610104  stw r11, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 829B275C: D3C10114  stfs f30, 0x114(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 829B2760: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 829B2764: D3C10118  stfs f30, 0x118(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 829B2768: 4844C161  bl 0x82dfe8c8
	ctx.lr = 0x829B276C;
	sub_82DFE8C8(ctx, base);
	// 829B276C: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 829B2770: 4844C159  bl 0x82dfe8c8
	ctx.lr = 0x829B2774;
	sub_82DFE8C8(ctx, base);
	// 829B2774: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 829B2778: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B277C: D3A10138  stfs f29, 0x138(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 829B2780: 3BAB0060  addi r29, r11, 0x60
	ctx.r[29].s64 = ctx.r[11].s64 + 96;
	// 829B2784: D3E10140  stfs f31, 0x140(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 829B2788: 396A2438  addi r11, r10, 0x2438
	ctx.r[11].s64 = ctx.r[10].s64 + 9272;
	// 829B278C: D3C10144  stfs f30, 0x144(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 829B2790: D3C10148  stfs f30, 0x148(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 829B2794: 93A10130  stw r29, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[29].u32 ) };
	// 829B2798: 91610134  stw r11, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 829B279C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829B27A0: 9241013C  stw r18, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[18].u32 ) };
	// 829B27A4: 9A41014C  stb r18, 0x14c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[18].u8 ) };
	// 829B27A8: 4844C121  bl 0x82dfe8c8
	ctx.lr = 0x829B27AC;
	sub_82DFE8C8(ctx, base);
	// 829B27AC: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 829B27B0: 4844C119  bl 0x82dfe8c8
	ctx.lr = 0x829B27B4;
	sub_82DFE8C8(ctx, base);
	// 829B27B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B27B8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B27BC: D3A10168  stfs f29, 0x168(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 829B27C0: 396B242C  addi r11, r11, 0x242c
	ctx.r[11].s64 = ctx.r[11].s64 + 9260;
	// 829B27C4: D3E10170  stfs f31, 0x170(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 829B27C8: 394A241C  addi r10, r10, 0x241c
	ctx.r[10].s64 = ctx.r[10].s64 + 9244;
	// 829B27CC: D3C10174  stfs f30, 0x174(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 829B27D0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829B27D4: D3C10178  stfs f30, 0x178(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829B27D8: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829B27DC: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 829B27E0: 91410164  stw r10, 0x164(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 829B27E4: 93E1016C  stw r31, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[31].u32 ) };
	// 829B27E8: 9A41017C  stb r18, 0x17c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), ctx.r[18].u8 ) };
	// 829B27EC: 4844C0DD  bl 0x82dfe8c8
	ctx.lr = 0x829B27F0;
	sub_82DFE8C8(ctx, base);
	// 829B27F0: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 829B27F4: 4844C0D5  bl 0x82dfe8c8
	ctx.lr = 0x829B27F8;
	sub_82DFE8C8(ctx, base);
	// 829B27F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B27FC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B2800: D3A10198  stfs f29, 0x198(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829B2804: 396B2410  addi r11, r11, 0x2410
	ctx.r[11].s64 = ctx.r[11].s64 + 9232;
	// 829B2808: D3E101A0  stfs f31, 0x1a0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 829B280C: 394A2400  addi r10, r10, 0x2400
	ctx.r[10].s64 = ctx.r[10].s64 + 9216;
	// 829B2810: D3C101A4  stfs f30, 0x1a4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 829B2814: D3C101A8  stfs f30, 0x1a8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 829B2818: 91610190  stw r11, 0x190(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 829B281C: 91410194  stw r10, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 829B2820: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 829B2824: 93E1019C  stw r31, 0x19c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), ctx.r[31].u32 ) };
	// 829B2828: 9A4101AC  stb r18, 0x1ac(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), ctx.r[18].u8 ) };
	// 829B282C: 4844C09D  bl 0x82dfe8c8
	ctx.lr = 0x829B2830;
	sub_82DFE8C8(ctx, base);
	// 829B2830: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 829B2834: 4844C095  bl 0x82dfe8c8
	ctx.lr = 0x829B2838;
	sub_82DFE8C8(ctx, base);
	// 829B2838: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 829B283C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B2840: 38A000B0  li r5, 0xb0
	ctx.r[5].s64 = 176;
	// 829B2844: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 829B2848: 4843FBA1  bl 0x82df23e8
	ctx.lr = 0x829B284C;
	sub_82DF23E8(ctx, base);
	// 829B284C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829B2850: 41820040  beq 0x829b2890
	if ctx.cr[0].eq {
	pc = 0x829B2890; continue 'dispatch;
	}
	// 829B2854: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B2858: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 829B285C: 388B23F0  addi r4, r11, 0x23f0
	ctx.r[4].s64 = ctx.r[11].s64 + 9200;
	// 829B2860: 484411A9  bl 0x82df3a08
	ctx.lr = 0x829B2864;
	sub_82DF3A08(ctx, base);
	// 829B2864: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829B2868: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 829B286C: 39E00003  li r15, 3
	ctx.r[15].s64 = 3;
	// 829B2870: 3B81006C  addi r28, r1, 0x6c
	ctx.r[28].s64 = ctx.r[1].s64 + 108;
	// 829B2874: 4BB5CC55  bl 0x8250f4c8
	ctx.lr = 0x829B2878;
	sub_8250F4C8(ctx, base);
	// 829B2878: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B287C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B2880: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829B2884: 4820137D  bl 0x82bb3c00
	ctx.lr = 0x829B2888;
	sub_82BB3C00(ctx, base);
	// 829B2888: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B288C: 48000008  b 0x829b2894
	pc = 0x829B2894; continue 'dispatch;
	// 829B2890: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 829B2894: 3BF5011C  addi r31, r21, 0x11c
	ctx.r[31].s64 = ctx.r[21].s64 + 284;
	// 829B2898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B289C: 4B9AAB45  bl 0x8235d3e0
	ctx.lr = 0x829B28A0;
	sub_8235D3E0(ctx, base);
	// 829B28A0: 55EB07BD  rlwinm. r11, r15, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B28A4: 41820010  beq 0x829b28b4
	if ctx.cr[0].eq {
	pc = 0x829B28B4; continue 'dispatch;
	}
	// 829B28A8: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 829B28AC: 55EF07FA  rlwinm r15, r15, 0, 0x1f, 0x1d
	ctx.r[15].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 829B28B0: 4843F3E1  bl 0x82df1c90
	ctx.lr = 0x829B28B4;
	sub_82DF1C90(ctx, base);
	// 829B28B4: 55EB07FF  clrlwi. r11, r15, 0x1f
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B28B8: 41820010  beq 0x829b28c8
	if ctx.cr[0].eq {
	pc = 0x829B28C8; continue 'dispatch;
	}
	// 829B28BC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 829B28C0: 55EF003C  rlwinm r15, r15, 0, 0, 0x1e
	ctx.r[15].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 829B28C4: 48440B65  bl 0x82df3428
	ctx.lr = 0x829B28C8;
	sub_82DF3428(ctx, base);
	// 829B28C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B28CC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829B28D0: 419A00F0  beq cr6, 0x829b29c0
	if ctx.cr[6].eq {
	pc = 0x829B29C0; continue 'dispatch;
	}
	// 829B28D4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 829B28D8: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 829B28DC: 48202685  bl 0x82bb4f60
	ctx.lr = 0x829B28E0;
	sub_82BB4F60(ctx, base);
	// 829B28E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B28E4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B28E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B28EC: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 829B28F0: 914100B0  stw r10, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 829B28F4: 419A0024  beq cr6, 0x829b2918
	if ctx.cr[6].eq {
	pc = 0x829B2918; continue 'dispatch;
	}
	// 829B28F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B28FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B2900: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B2904: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B2908: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B290C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B2910: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B2914: 4082FFE8  bne 0x829b28fc
	if !ctx.cr[0].eq {
	pc = 0x829B28FC; continue 'dispatch;
	}
	// 829B2918: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 829B291C: 80750114  lwz r3, 0x114(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B2920: 48462651  bl 0x82e14f70
	ctx.lr = 0x829B2924;
	sub_82E14F70(ctx, base);
	// 829B2924: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 829B2928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B292C: 419A0008  beq cr6, 0x829b2934
	if ctx.cr[6].eq {
	pc = 0x829B2934; continue 'dispatch;
	}
	// 829B2930: 4B90DF61  bl 0x822c0890
	ctx.lr = 0x829B2934;
	sub_822C0890(ctx, base);
	// 829B2934: 89750148  lbz r11, 0x148(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(328 as u32) ) } as u64;
	// 829B2938: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B293C: 41820044  beq 0x829b2980
	if ctx.cr[0].eq {
	pc = 0x829B2980; continue 'dispatch;
	}
	// 829B2940: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829B2944: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829B2948: 484410C1  bl 0x82df3a08
	ctx.lr = 0x829B294C;
	sub_82DF3A08(ctx, base);
	// 829B294C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B2950: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829B2954: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2958: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829B295C: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 829B2960: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B2964: 482002BD  bl 0x82bb2c20
	ctx.lr = 0x829B2968;
	sub_82BB2C20(ctx, base);
	// 829B2968: 8061029C  lwz r3, 0x29c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(668 as u32) ) } as u64;
	// 829B296C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B2970: 419A0008  beq cr6, 0x829b2978
	if ctx.cr[6].eq {
	pc = 0x829B2978; continue 'dispatch;
	}
	// 829B2974: 4B90DF1D  bl 0x822c0890
	ctx.lr = 0x829B2978;
	sub_822C0890(ctx, base);
	// 829B2978: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829B297C: 48000040  b 0x829b29bc
	pc = 0x829B29BC; continue 'dispatch;
	// 829B2980: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B2984: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829B2988: 48441081  bl 0x82df3a08
	ctx.lr = 0x829B298C;
	sub_82DF3A08(ctx, base);
	// 829B298C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B2990: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829B2994: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2998: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829B299C: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 829B29A0: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B29A4: 4820027D  bl 0x82bb2c20
	ctx.lr = 0x829B29A8;
	sub_82BB2C20(ctx, base);
	// 829B29A8: 806102AC  lwz r3, 0x2ac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(684 as u32) ) } as u64;
	// 829B29AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B29B0: 419A0008  beq cr6, 0x829b29b8
	if ctx.cr[6].eq {
	pc = 0x829B29B8; continue 'dispatch;
	}
	// 829B29B4: 4B90DEDD  bl 0x822c0890
	ctx.lr = 0x829B29B8;
	sub_822C0890(ctx, base);
	// 829B29B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829B29BC: 48440A6D  bl 0x82df3428
	ctx.lr = 0x829B29C0;
	sub_82DF3428(ctx, base);
	// 829B29C0: 81750114  lwz r11, 0x114(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(276 as u32) ) } as u64;
	// 829B29C4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829B29C8: 4844BE19  bl 0x82dfe7e0
	ctx.lr = 0x829B29CC;
	sub_82DFE7E0(ctx, base);
	// 829B29CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B29D0: 41820010  beq 0x829b29e0
	if ctx.cr[0].eq {
	pc = 0x829B29E0; continue 'dispatch;
	}
	// 829B29D4: 8075011C  lwz r3, 0x11c(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(284 as u32) ) } as u64;
	// 829B29D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B29DC: 48202B15  bl 0x82bb54f0
	ctx.lr = 0x829B29E0;
	sub_82BB54F0(ctx, base);
	// 829B29E0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829B29E4: 4BB600B5  bl 0x82512a98
	ctx.lr = 0x829B29E8;
	sub_82512A98(ctx, base);
	// 829B29E8: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 829B29EC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829B29F0: 809A6784  lwz r4, 0x6784(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26500 as u32) ) } as u64;
	// 829B29F4: 4B93253D  bl 0x822e4f30
	ctx.lr = 0x829B29F8;
	sub_822E4F30(ctx, base);
	// 829B29F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829B29FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B2A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B2A04: 808B67C0  lwz r4, 0x67c0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26560 as u32) ) } as u64;
	// 829B2A08: 4B932529  bl 0x822e4f30
	ctx.lr = 0x829B2A0C;
	sub_822E4F30(ctx, base);
	// 829B2A0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829B2A10: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 829B2A14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B2A18: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829B2A1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829B2A20: 4BAD9869  bl 0x8248c288
	ctx.lr = 0x829B2A24;
	sub_8248C288(ctx, base);
	// 829B2A24: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 829B2A28: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 829B2A2C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829B2A30: 80996750  lwz r4, 0x6750(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26448 as u32) ) } as u64;
	// 829B2A34: 4B9324FD  bl 0x822e4f30
	ctx.lr = 0x829B2A38;
	sub_822E4F30(ctx, base);
	// 829B2A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B2A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B2A40: 4B932481  bl 0x822e4ec0
	ctx.lr = 0x829B2A44;
	sub_822E4EC0(ctx, base);
	// 829B2A44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829B2A48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B2A4C: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 829B2A50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829B2A54: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829B2A58: 4BAD9831  bl 0x8248c288
	ctx.lr = 0x829B2A5C;
	sub_8248C288(ctx, base);
	// 829B2A5C: 89750140  lbz r11, 0x140(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(320 as u32) ) } as u64;
	// 829B2A60: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 829B2A64: 3AC00040  li r22, 0x40
	ctx.r[22].s64 = 64;
	// 829B2A68: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829B2A6C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 829B2A70: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B2A74: 41980050  blt cr6, 0x829b2ac4
	if ctx.cr[6].lt {
	pc = 0x829B2AC4; continue 'dispatch;
	}
	// 829B2A78: 409A00CC  bne cr6, 0x829b2b44
	if !ctx.cr[6].eq {
	pc = 0x829B2B44; continue 'dispatch;
	}
	// 829B2A7C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B2A80: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 829B2A84: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829B2A88: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 829B2A8C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829B2A90: 484EDCA1  bl 0x82ea0730
	ctx.lr = 0x829B2A94;
	sub_82EA0730(ctx, base);
	// 829B2A94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B2A98: 394102F0  addi r10, r1, 0x2f0
	ctx.r[10].s64 = ctx.r[1].s64 + 752;
	// 829B2A9C: 396B23E0  addi r11, r11, 0x23e0
	ctx.r[11].s64 = ctx.r[11].s64 + 9184;
	// 829B2AA0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 829B2AA4: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 829B2AA8: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 829B2AAC: 388102F0  addi r4, r1, 0x2f0
	ctx.r[4].s64 = ctx.r[1].s64 + 752;
	// 829B2AB0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B38F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B38F8 size=164
    let mut pc: u32 = 0x829B38F8;
    'dispatch: loop {
        match pc {
            0x829B38F8 => {
    //   block [0x829B38F8..0x829B399C)
	// 829B38F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B38FC: 487F4871  bl 0x831a816c
	ctx.lr = 0x829B3900;
	sub_831A8130(ctx, base);
	// 829B3900: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829B3904: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B3908: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B390C: 487A0CF5  bl 0x83154600
	ctx.lr = 0x829B3910;
	sub_83154600(ctx, base);
	// 829B3910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B3914: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B3918: 4800A9A1  bl 0x829be2b8
	ctx.lr = 0x829B391C;
	sub_829BE2B8(ctx, base);
	// 829B391C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B3920: 4BFF59E1  bl 0x829a9300
	ctx.lr = 0x829B3924;
	sub_829A9300(ctx, base);
	// 829B3924: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B3928: 83BF03F8  lwz r29, 0x3f8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 829B392C: 4B91C5F5  bl 0x822cff20
	ctx.lr = 0x829B3930;
	sub_822CFF20(ctx, base);
	// 829B3930: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B3934: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829B3938: 4B91C5E9  bl 0x822cff20
	ctx.lr = 0x829B393C;
	sub_822CFF20(ctx, base);
	// 829B393C: EC1F0828  fsubs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 829B3940: D01F0410  stfs f0, 0x410(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829B3944: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B3948: 4B91C5C9  bl 0x822cff10
	ctx.lr = 0x829B394C;
	sub_822CFF10(ctx, base);
	// 829B394C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B3950: C1BF0410  lfs f13, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B3954: C00B9530  lfs f0, -0x6ad0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B3958: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B395C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B3960: 40980018  bge cr6, 0x829b3978
	if !ctx.cr[6].lt {
	pc = 0x829B3978; continue 'dispatch;
	}
	// 829B3964: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B3968: 4B91C5A9  bl 0x822cff10
	ctx.lr = 0x829B396C;
	sub_822CFF10(ctx, base);
	// 829B396C: C01F0410  lfs f0, 0x410(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B3970: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B3974: D01F0410  stfs f0, 0x410(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829B3978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B397C: C01F0410  lfs f0, 0x410(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B3980: D01E016C  stfs f0, 0x16c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 829B3984: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B3988: D01E0170  stfs f0, 0x170(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 829B398C: D01E0174  stfs f0, 0x174(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 829B3990: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B3994: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829B3998: 487F4824  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B39A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B39A0 size=120
    let mut pc: u32 = 0x829B39A0;
    'dispatch: loop {
        match pc {
            0x829B39A0 => {
    //   block [0x829B39A0..0x829B3A18)
	// 829B39A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B39A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B39A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B39AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B39B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B39B4: 484A8F75  bl 0x82e5c928
	ctx.lr = 0x829B39B8;
	sub_82E5C928(ctx, base);
	// 829B39B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B39BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B39C0: 392B94A8  addi r9, r11, -0x6b58
	ctx.r[9].s64 = ctx.r[11].s64 + -27480;
	// 829B39C4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829B39C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829B39CC: 3908249C  addi r8, r8, 0x249c
	ctx.r[8].s64 = ctx.r[8].s64 + 9372;
	// 829B39D0: C18B94A8  lfs f12, -0x6b58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27480 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B39D4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B39D8: 98FF0180  stb r7, 0x180(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[7].u8 ) };
	// 829B39DC: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829B39E0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829B39E4: D01F017C  stfs f0, 0x17c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 829B39E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B39EC: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B39F0: C1A9002C  lfs f13, 0x2c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B39F4: D1BF0164  stfs f13, 0x164(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 829B39F8: D19F0168  stfs f12, 0x168(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 829B39FC: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B3A00: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B3A04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B3A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B3A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B3A10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B3A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B3A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B3A18 size=404
    let mut pc: u32 = 0x829B3A18;
    'dispatch: loop {
        match pc {
            0x829B3A18 => {
    //   block [0x829B3A18..0x829B3BAC)
	// 829B3A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B3A1C: 487F4751  bl 0x831a816c
	ctx.lr = 0x829B3A20;
	sub_831A8130(ctx, base);
	// 829B3A20: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829B3A24: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829B3A28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B3A2C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829B3A30: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829B3A34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B3A38: 4BB5E361  bl 0x82511d98
	ctx.lr = 0x829B3A3C;
	sub_82511D98(ctx, base);
	// 829B3A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B3A40: 4BB5E0A9  bl 0x82511ae8
	ctx.lr = 0x829B3A44;
	sub_82511AE8(ctx, base);
	// 829B3A44: 396003E0  li r11, 0x3e0
	ctx.r[11].s64 = 992;
	// 829B3A48: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B3BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B3BB0 size=144
    let mut pc: u32 = 0x829B3BB0;
    'dispatch: loop {
        match pc {
            0x829B3BB0 => {
    //   block [0x829B3BB0..0x829B3C40)
	// 829B3BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B3BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B3BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B3BBC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B3BC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B3BC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3BC8: 419A0064  beq cr6, 0x829b3c2c
	if ctx.cr[6].eq {
	pc = 0x829B3C2C; continue 'dispatch;
	}
	// 829B3BCC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B3BD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B3BD4: 388B24C0  addi r4, r11, 0x24c0
	ctx.r[4].s64 = ctx.r[11].s64 + 9408;
	// 829B3BD8: 4843FE31  bl 0x82df3a08
	ctx.lr = 0x829B3BDC;
	sub_82DF3A08(ctx, base);
	// 829B3BDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B3BE0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829B3BE4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829B3BE8: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 829B3BEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B3BF0: 388894B4  addi r4, r8, -0x6b4c
	ctx.r[4].s64 = ctx.r[8].s64 + -27468;
	// 829B3BF4: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829B3BF8: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829B3BFC: C0290790  lfs f1, 0x790(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B3C00: 4BBEF5B1  bl 0x825a31b0
	ctx.lr = 0x829B3C04;
	sub_825A31B0(ctx, base);
	// 829B3C04: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829B3C08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B3C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B3C10: 4BBEDB61  bl 0x825a1770
	ctx.lr = 0x829B3C14;
	sub_825A1770(ctx, base);
	// 829B3C14: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829B3C18: 4843F811  bl 0x82df3428
	ctx.lr = 0x829B3C1C;
	sub_82DF3428(ctx, base);
	// 829B3C1C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829B3C20: 4B915099  bl 0x822c8cb8
	ctx.lr = 0x829B3C24;
	sub_822C8CB8(ctx, base);
	// 829B3C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B3C28: 4843F801  bl 0x82df3428
	ctx.lr = 0x829B3C2C;
	sub_82DF3428(ctx, base);
	// 829B3C2C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829B3C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B3C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B3C38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B3C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B3C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B3C40 size=2172
    let mut pc: u32 = 0x829B3C40;
    'dispatch: loop {
        match pc {
            0x829B3C40 => {
    //   block [0x829B3C40..0x829B44BC)
	// 829B3C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B3C44: 487F4505  bl 0x831a8148
	ctx.lr = 0x829B3C48;
	sub_831A8130(ctx, base);
	// 829B3C48: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 829B3C4C: 487F4E29  bl 0x831a8a74
	ctx.lr = 0x829B3C50;
	sub_831A8A40(ctx, base);
	// 829B3C50: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B3C54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B3C58: 487A09A9  bl 0x83154600
	ctx.lr = 0x829B3C5C;
	sub_83154600(ctx, base);
	// 829B3C5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829B3C60: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 829B3C64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829B3C68: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829B3C6C: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 829B3C70: 4843DF89  bl 0x82df1bf8
	ctx.lr = 0x829B3C74;
	sub_82DF1BF8(ctx, base);
	// 829B3C74: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 829B3C78: 481935C9  bl 0x82b47240
	ctx.lr = 0x829B3C7C;
	sub_82B47240(ctx, base);
	// 829B3C7C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 829B3C80: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829B3C84: 4843E00D  bl 0x82df1c90
	ctx.lr = 0x829B3C88;
	sub_82DF1C90(ctx, base);
	// 829B3C88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B3C8C: 484A5AED  bl 0x82e59778
	ctx.lr = 0x829B3C90;
	sub_82E59778(ctx, base);
	// 829B3C90: C01E0184  lfs f0, 0x184(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B3C94: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B3C98: D01E0184  stfs f0, 0x184(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B3C9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B3CA0: 4BABE659  bl 0x824722f8
	ctx.lr = 0x829B3CA4;
	sub_824722F8(ctx, base);
	// 829B3CA4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B3CA8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B3CAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3CB0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 829B3CB4: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 829B3CB8: 419A0024  beq cr6, 0x829b3cdc
	if ctx.cr[6].eq {
	pc = 0x829B3CDC; continue 'dispatch;
	}
	// 829B3CBC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B3CC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B3CC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3CC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B3CCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B3CD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B3CD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3CD8: 4082FFE8  bne 0x829b3cc0
	if !ctx.cr[0].eq {
	pc = 0x829B3CC0; continue 'dispatch;
	}
	// 829B3CDC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 829B3CE0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829B3CE4: 4BB5B7E5  bl 0x8250f4c8
	ctx.lr = 0x829B3CE8;
	sub_8250F4C8(ctx, base);
	// 829B3CE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B3CEC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 829B3CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B3CF4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829B3CF8: 409A0008  bne cr6, 0x829b3d00
	if !ctx.cr[6].eq {
	pc = 0x829B3D00; continue 'dispatch;
	}
	// 829B3CFC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829B3D00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B3D04: 3B960028  addi r28, r22, 0x28
	ctx.r[28].s64 = ctx.r[22].s64 + 40;
	// 829B3D08: 3B410068  addi r26, r1, 0x68
	ctx.r[26].s64 = ctx.r[1].s64 + 104;
	// 829B3D0C: 4BB54D0D  bl 0x82508a18
	ctx.lr = 0x829B3D10;
	sub_82508A18(ctx, base);
	// 829B3D10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B3D14: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829B3D18: 3B6B24C8  addi r27, r11, 0x24c8
	ctx.r[27].s64 = ctx.r[11].s64 + 9416;
	// 829B3D1C: 38A0009A  li r5, 0x9a
	ctx.r[5].s64 = 154;
	// 829B3D20: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829B3D24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829B3D28: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829B3D2C: 484A32BD  bl 0x82e56fe8
	ctx.lr = 0x829B3D30;
	sub_82E56FE8(ctx, base);
	// 829B3D30: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829B3D34: 4843DF5D  bl 0x82df1c90
	ctx.lr = 0x829B3D38;
	sub_82DF1C90(ctx, base);
	// 829B3D38: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829B3D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B3D40: 419A0008  beq cr6, 0x829b3d48
	if ctx.cr[6].eq {
	pc = 0x829B3D48; continue 'dispatch;
	}
	// 829B3D44: 4B90CB4D  bl 0x822c0890
	ctx.lr = 0x829B3D48;
	sub_822C0890(ctx, base);
	// 829B3D48: 8B1D0034  lbz r24, 0x34(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 829B3D4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3D50: 419A000C  beq cr6, 0x829b3d5c
	if ctx.cr[6].eq {
	pc = 0x829B3D5C; continue 'dispatch;
	}
	// 829B3D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B3D58: 4B90CB39  bl 0x822c0890
	ctx.lr = 0x829B3D5C;
	sub_822C0890(ctx, base);
	// 829B3D5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B3D60: 4BFD7189  bl 0x8298aee8
	ctx.lr = 0x829B3D64;
	sub_8298AEE8(ctx, base);
	// 829B3D64: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B3D68: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B3D6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3D70: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 829B3D74: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 829B3D78: 419A0024  beq cr6, 0x829b3d9c
	if ctx.cr[6].eq {
	pc = 0x829B3D9C; continue 'dispatch;
	}
	// 829B3D7C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B3D80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B3D84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3D88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B3D8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B3D90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B3D94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3D98: 4082FFE8  bne 0x829b3d80
	if !ctx.cr[0].eq {
	pc = 0x829B3D80; continue 'dispatch;
	}
	// 829B3D9C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 829B3DA0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829B3DA4: 4BB5B725  bl 0x8250f4c8
	ctx.lr = 0x829B3DA8;
	sub_8250F4C8(ctx, base);
	// 829B3DA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B3DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B3DB0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829B3DB4: 409A0008  bne cr6, 0x829b3dbc
	if !ctx.cr[6].eq {
	pc = 0x829B3DBC; continue 'dispatch;
	}
	// 829B3DB8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829B3DBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B3DC0: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 829B3DC4: 4BB54C55  bl 0x82508a18
	ctx.lr = 0x829B3DC8;
	sub_82508A18(ctx, base);
	// 829B3DC8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829B3DCC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829B3DD0: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 829B3DD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829B3DD8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829B3DDC: 484A320D  bl 0x82e56fe8
	ctx.lr = 0x829B3DE0;
	sub_82E56FE8(ctx, base);
	// 829B3DE0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829B3DE4: 4843DEAD  bl 0x82df1c90
	ctx.lr = 0x829B3DE8;
	sub_82DF1C90(ctx, base);
	// 829B3DE8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829B3DEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B3DF0: 419A0008  beq cr6, 0x829b3df8
	if ctx.cr[6].eq {
	pc = 0x829B3DF8; continue 'dispatch;
	}
	// 829B3DF4: 4B90CA9D  bl 0x822c0890
	ctx.lr = 0x829B3DF8;
	sub_822C0890(ctx, base);
	// 829B3DF8: 8B3D001C  lbz r25, 0x1c(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 829B3DFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3E00: 419A000C  beq cr6, 0x829b3e0c
	if ctx.cr[6].eq {
	pc = 0x829B3E0C; continue 'dispatch;
	}
	// 829B3E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B3E08: 4B90CA89  bl 0x822c0890
	ctx.lr = 0x829B3E0C;
	sub_822C0890(ctx, base);
	// 829B3E0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B3E10: 4BE545F1  bl 0x82808400
	ctx.lr = 0x829B3E14;
	sub_82808400(ctx, base);
	// 829B3E14: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B3E18: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B3E1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3E20: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 829B3E24: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 829B3E28: 419A0024  beq cr6, 0x829b3e4c
	if ctx.cr[6].eq {
	pc = 0x829B3E4C; continue 'dispatch;
	}
	// 829B3E2C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B3E30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B3E34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3E38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B3E3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B3E40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B3E44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3E48: 4082FFE8  bne 0x829b3e30
	if !ctx.cr[0].eq {
	pc = 0x829B3E30; continue 'dispatch;
	}
	// 829B3E4C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 829B3E50: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829B3E54: 4BB5B675  bl 0x8250f4c8
	ctx.lr = 0x829B3E58;
	sub_8250F4C8(ctx, base);
	// 829B3E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B3E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B3E60: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829B3E64: 409A0008  bne cr6, 0x829b3e6c
	if !ctx.cr[6].eq {
	pc = 0x829B3E6C; continue 'dispatch;
	}
	// 829B3E68: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829B3E6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B3E70: 3B410078  addi r26, r1, 0x78
	ctx.r[26].s64 = ctx.r[1].s64 + 120;
	// 829B3E74: 4BB54BA5  bl 0x82508a18
	ctx.lr = 0x829B3E78;
	sub_82508A18(ctx, base);
	// 829B3E78: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829B3E7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829B3E80: 38A000A8  li r5, 0xa8
	ctx.r[5].s64 = 168;
	// 829B3E84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829B3E88: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829B3E8C: 484A315D  bl 0x82e56fe8
	ctx.lr = 0x829B3E90;
	sub_82E56FE8(ctx, base);
	// 829B3E90: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829B3E94: 4843DDFD  bl 0x82df1c90
	ctx.lr = 0x829B3E98;
	sub_82DF1C90(ctx, base);
	// 829B3E98: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829B3E9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B3EA0: 419A0008  beq cr6, 0x829b3ea8
	if ctx.cr[6].eq {
	pc = 0x829B3EA8; continue 'dispatch;
	}
	// 829B3EA4: 4B90C9ED  bl 0x822c0890
	ctx.lr = 0x829B3EA8;
	sub_822C0890(ctx, base);
	// 829B3EA8: 8B5D0018  lbz r26, 0x18(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 829B3EAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3EB0: 419A000C  beq cr6, 0x829b3ebc
	if ctx.cr[6].eq {
	pc = 0x829B3EBC; continue 'dispatch;
	}
	// 829B3EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B3EB8: 4B90C9D9  bl 0x822c0890
	ctx.lr = 0x829B3EBC;
	sub_822C0890(ctx, base);
	// 829B3EBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B3EC0: 4BE648B9  bl 0x82818778
	ctx.lr = 0x829B3EC4;
	sub_82818778(ctx, base);
	// 829B3EC4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B3EC8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B3ECC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3ED0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 829B3ED4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829B3ED8: 419A0024  beq cr6, 0x829b3efc
	if ctx.cr[6].eq {
	pc = 0x829B3EFC; continue 'dispatch;
	}
	// 829B3EDC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B3EE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B3EE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3EE8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B3EEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B3EF0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B3EF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B3EF8: 4082FFE8  bne 0x829b3ee0
	if !ctx.cr[0].eq {
	pc = 0x829B3EE0; continue 'dispatch;
	}
	// 829B3EFC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 829B3F00: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829B3F04: 4BB5B5C5  bl 0x8250f4c8
	ctx.lr = 0x829B3F08;
	sub_8250F4C8(ctx, base);
	// 829B3F08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B3F0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B3F10: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829B3F14: 409A0008  bne cr6, 0x829b3f1c
	if !ctx.cr[6].eq {
	pc = 0x829B3F1C; continue 'dispatch;
	}
	// 829B3F18: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829B3F1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B3F20: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 829B3F24: 4BB54AF5  bl 0x82508a18
	ctx.lr = 0x829B3F28;
	sub_82508A18(ctx, base);
	// 829B3F28: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829B3F2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829B3F30: 38A000AF  li r5, 0xaf
	ctx.r[5].s64 = 175;
	// 829B3F34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829B3F38: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 829B3F3C: 484A30AD  bl 0x82e56fe8
	ctx.lr = 0x829B3F40;
	sub_82E56FE8(ctx, base);
	// 829B3F40: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829B3F44: 4843DD4D  bl 0x82df1c90
	ctx.lr = 0x829B3F48;
	sub_82DF1C90(ctx, base);
	// 829B3F48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829B3F4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B3F50: 419A0008  beq cr6, 0x829b3f58
	if ctx.cr[6].eq {
	pc = 0x829B3F58; continue 'dispatch;
	}
	// 829B3F54: 4B90C93D  bl 0x822c0890
	ctx.lr = 0x829B3F58;
	sub_822C0890(ctx, base);
	// 829B3F58: 8BBD0018  lbz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 829B3F5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B3F60: 419A000C  beq cr6, 0x829b3f6c
	if ctx.cr[6].eq {
	pc = 0x829B3F6C; continue 'dispatch;
	}
	// 829B3F64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B3F68: 4B90C929  bl 0x822c0890
	ctx.lr = 0x829B3F6C;
	sub_822C0890(ctx, base);
	// 829B3F6C: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B3F70: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B3F74: 41820010  beq 0x829b3f84
	if ctx.cr[0].eq {
	pc = 0x829B3F84; continue 'dispatch;
	}
	// 829B3F78: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B3F7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B3F80: 40820008  bne 0x829b3f88
	if !ctx.cr[0].eq {
	pc = 0x829B3F88; continue 'dispatch;
	}
	// 829B3F84: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 829B3F88: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B3F8C: 893E0180  lbz r9, 0x180(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 829B3F90: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829B3F94: 3BEB94D4  addi r31, r11, -0x6b2c
	ctx.r[31].s64 = ctx.r[11].s64 + -27436;
	// 829B3F98: 7D2B0774  extsb r11, r9
	ctx.r[11].s64 = ctx.r[9].s8 as i64;
	// 829B3F9C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 829B3FA0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B3FA4: C3C808A4  lfs f30, 0x8a4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829B3FA8: 419800B0  blt cr6, 0x829b4058
	if ctx.cr[6].lt {
	pc = 0x829B4058; continue 'dispatch;
	}
	// 829B3FAC: 419A009C  beq cr6, 0x829b4048
	if ctx.cr[6].eq {
	pc = 0x829B4048; continue 'dispatch;
	}
	// 829B3FB0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B3FB4: 4198004C  blt cr6, 0x829b4000
	if ctx.cr[6].lt {
	pc = 0x829B4000; continue 'dispatch;
	}
	// 829B3FB8: 419A0028  beq cr6, 0x829b3fe0
	if ctx.cr[6].eq {
	pc = 0x829B3FE0; continue 'dispatch;
	}
	// 829B3FBC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B3FC0: 41980018  blt cr6, 0x829b3fd8
	if ctx.cr[6].lt {
	pc = 0x829B3FD8; continue 'dispatch;
	}
	// 829B3FC4: 409A00E4  bne cr6, 0x829b40a8
	if !ctx.cr[6].eq {
	pc = 0x829B40A8; continue 'dispatch;
	}
	// 829B3FC8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B3FCC: 408200DC  bne 0x829b40a8
	if !ctx.cr[0].eq {
	pc = 0x829B40A8; continue 'dispatch;
	}
	// 829B3FD0: 9AFE0180  stb r23, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[23].u8 ) };
	// 829B3FD4: 480000D0  b 0x829b40a4
	pc = 0x829B40A4; continue 'dispatch;
	// 829B3FD8: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B3FDC: 4BFFFFF0  b 0x829b3fcc
	pc = 0x829B3FCC; continue 'dispatch;
	// 829B3FE0: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B3FE4: 4182000C  beq 0x829b3ff0
	if ctx.cr[0].eq {
	pc = 0x829B3FF0; continue 'dispatch;
	}
	// 829B3FE8: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B3FEC: 9AFE0180  stb r23, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[23].u8 ) };
	// 829B3FF0: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B3FF4: 4182008C  beq 0x829b4080
	if ctx.cr[0].eq {
	pc = 0x829B4080; continue 'dispatch;
	}
	// 829B3FF8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829B3FFC: 4800007C  b 0x829b4078
	pc = 0x829B4078; continue 'dispatch;
	// 829B4000: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B4004: 408200A4  bne 0x829b40a8
	if !ctx.cr[0].eq {
	pc = 0x829B40A8; continue 'dispatch;
	}
	// 829B4008: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829B400C: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B4010: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829B4014: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829B4018: C0160410  lfs f0, 0x410(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B401C: D01E0178  stfs f0, 0x178(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829B4020: 4BFEF071  bl 0x829a3090
	ctx.lr = 0x829B4024;
	sub_829A3090(ctx, base);
	// 829B4024: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4028: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B402C: 40820014  bne 0x829b4040
	if !ctx.cr[0].eq {
	pc = 0x829B4040; continue 'dispatch;
	}
	// 829B4030: C1BE0178  lfs f13, 0x178(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4034: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B4038: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B403C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 829B4040: D01E017C  stfs f0, 0x17c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 829B4044: 48000064  b 0x829b40a8
	pc = 0x829B40A8; continue 'dispatch;
	// 829B4048: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B404C: 40820034  bne 0x829b4080
	if !ctx.cr[0].eq {
	pc = 0x829B4080; continue 'dispatch;
	}
	// 829B4050: 9AFE0180  stb r23, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[23].u8 ) };
	// 829B4054: 48000028  b 0x829b407c
	pc = 0x829B407C; continue 'dispatch;
	// 829B4058: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B405C: 41820010  beq 0x829b406c
	if ctx.cr[0].eq {
	pc = 0x829B406C; continue 'dispatch;
	}
	// 829B4060: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829B4064: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B4068: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829B406C: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B4070: 41820010  beq 0x829b4080
	if ctx.cr[0].eq {
	pc = 0x829B4080; continue 'dispatch;
	}
	// 829B4074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B4078: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829B407C: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B4080: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B4084: 41820010  beq 0x829b4094
	if ctx.cr[0].eq {
	pc = 0x829B4094; continue 'dispatch;
	}
	// 829B4088: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 829B408C: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B4090: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829B4094: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B4098: 41820010  beq 0x829b40a8
	if ctx.cr[0].eq {
	pc = 0x829B40A8; continue 'dispatch;
	}
	// 829B409C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 829B40A0: 997E0180  stb r11, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 829B40A4: D3DE0184  stfs f30, 0x184(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 829B40A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B40AC: C1B50010  lfs f13, 0x10(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B40B0: C01FFFDC  lfs f0, -0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B40B4: FD80F090  fmr f12, f30
	ctx.f[12].f64 = ctx.f[30].f64;
	// 829B40B8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B40BC: C38B08A8  lfs f28, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829B40C0: 41980010  blt cr6, 0x829b40d0
	if ctx.cr[6].lt {
	pc = 0x829B40D0; continue 'dispatch;
	}
	// 829B40C4: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B40C8: ED7C0028  fsubs f11, f28, f0
	ctx.f[11].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B40CC: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 829B40D0: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B40D4: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 829B40D8: 41990010  bgt cr6, 0x829b40e8
	if ctx.cr[6].gt {
	pc = 0x829B40E8; continue 'dispatch;
	}
	// 829B40DC: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829B40E0: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B40E4: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829B40E8: 897E0180  lbz r11, 0x180(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 829B40EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B40F0: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 829B40F4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B40F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B40FC: C36A9450  lfs f27, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 829B4100: 419800CC  blt cr6, 0x829b41cc
	if ctx.cr[6].lt {
	pc = 0x829B41CC; continue 'dispatch;
	}
	// 829B4104: 419A00B0  beq cr6, 0x829b41b4
	if ctx.cr[6].eq {
	pc = 0x829B41B4; continue 'dispatch;
	}
	// 829B4108: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B410C: 419800A0  blt cr6, 0x829b41ac
	if ctx.cr[6].lt {
	pc = 0x829B41AC; continue 'dispatch;
	}
	// 829B4110: 419A0030  beq cr6, 0x829b4140
	if ctx.cr[6].eq {
	pc = 0x829B4140; continue 'dispatch;
	}
	// 829B4114: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B4118: 41980014  blt cr6, 0x829b412c
	if ctx.cr[6].lt {
	pc = 0x829B412C; continue 'dispatch;
	}
	// 829B411C: 409A00D0  bne cr6, 0x829b41ec
	if !ctx.cr[6].eq {
	pc = 0x829B41EC; continue 'dispatch;
	}
	// 829B4120: C01FFFF4  lfs f0, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4124: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B4128: 480000C4  b 0x829b41ec
	pc = 0x829B41EC; continue 'dispatch;
	// 829B412C: C0160468  lfs f0, 0x468(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4130: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829B4134: 419900B0  bgt cr6, 0x829b41e4
	if ctx.cr[6].gt {
	pc = 0x829B41E4; continue 'dispatch;
	}
	// 829B4138: C3FFFFF0  lfs f31, -0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B413C: 480000B0  b 0x829b41ec
	pc = 0x829B41EC; continue 'dispatch;
	// 829B4140: C01E0184  lfs f0, 0x184(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4144: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4148: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B414C: 4199008C  bgt cr6, 0x829b41d8
	if ctx.cr[6].gt {
	pc = 0x829B41D8; continue 'dispatch;
	}
	// 829B4150: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829B4154: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829B4158: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B415C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B4160: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 829B4164: 487F4C65  bl 0x831a8dc8
	ctx.lr = 0x829B4168;
	sub_831A8DC8(ctx, base);
	// 829B4168: C01E0178  lfs f0, 0x178(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B416C: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4170: C19E017C  lfs f12, 0x17c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B4174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B4178: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B417C: EFEC037A  fmadds f31, f12, f13, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 829B4180: 484A55F9  bl 0x82e59778
	ctx.lr = 0x829B4184;
	sub_82E59778(ctx, base);
	// 829B4184: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 829B4188: 4099001C  ble cr6, 0x829b41a4
	if !ctx.cr[6].gt {
	pc = 0x829B41A4; continue 'dispatch;
	}
	// 829B418C: C0160410  lfs f0, 0x410(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B4194: EFE0F828  fsubs f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 829B4198: 484A55E1  bl 0x82e59778
	ctx.lr = 0x829B419C;
	sub_82E59778(ctx, base);
	// 829B419C: EFFF0824  fdivs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 829B41A0: 4800004C  b 0x829b41ec
	pc = 0x829B41EC; continue 'dispatch;
	// 829B41A4: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 829B41A8: 48000044  b 0x829b41ec
	pc = 0x829B41EC; continue 'dispatch;
	// 829B41AC: C3FFFFE8  lfs f31, -0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B41B0: 4800003C  b 0x829b41ec
	pc = 0x829B41EC; continue 'dispatch;
	// 829B41B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B41B8: 484A55C1  bl 0x82e59778
	ctx.lr = 0x829B41BC;
	sub_82E59778(ctx, base);
	// 829B41BC: C1BE0174  lfs f13, 0x174(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B41C0: C01FFFE4  lfs f0, -0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B41C4: EFE1683C  fnmsubs f31, f1, f0, f13
	ctx.f[31].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B41C8: 48000024  b 0x829b41ec
	pc = 0x829B41EC; continue 'dispatch;
	// 829B41CC: C0160468  lfs f0, 0x468(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B41D0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829B41D4: 41990010  bgt cr6, 0x829b41e4
	if ctx.cr[6].gt {
	pc = 0x829B41E4; continue 'dispatch;
	}
	// 829B41D8: C01FFFE0  lfs f0, -0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B41DC: EFE00332  fmuls f31, f0, f12
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 829B41E0: 4800000C  b 0x829b41ec
	pc = 0x829B41EC; continue 'dispatch;
	// 829B41E4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829B41E8: C3EB2514  lfs f31, 0x2514(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9492 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B41EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B41F0: 484A5589  bl 0x82e59778
	ctx.lr = 0x829B41F4;
	sub_82E59778(ctx, base);
	// 829B41F4: C0160410  lfs f0, 0x410(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B41F8: EC0107FC  fnmsubs f0, f1, f31, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B41FC: D0160410  stfs f0, 0x410(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829B4200: D3FE0174  stfs f31, 0x174(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 829B4204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B4208: 484A5571  bl 0x82e59778
	ctx.lr = 0x829B420C;
	sub_82E59778(ctx, base);
	// 829B420C: C01E0170  lfs f0, 0x170(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4210: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B4214: C01FFFF8  lfs f0, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4218: D1BE0170  stfs f13, 0x170(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 829B421C: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829B4220: FF0CE000  fcmpu cr6, f12, f28
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[28].f64);
	// 829B4224: 40990008  ble cr6, 0x829b422c
	if !ctx.cr[6].gt {
	pc = 0x829B422C; continue 'dispatch;
	}
	// 829B4228: FD80E090  fmr f12, f28
	ctx.f[12].f64 = ctx.f[28].f64;
	// 829B422C: C01E016C  lfs f0, 0x16c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4230: C1BFFFFC  lfs f13, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4234: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B4238: ED6B033A  fmadds f11, f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 829B423C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 829B4240: 40980008  bge cr6, 0x829b4248
	if !ctx.cr[6].lt {
	pc = 0x829B4248; continue 'dispatch;
	}
	// 829B4244: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 829B4248: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B424C: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B4250: EC0A033A  fmadds f0, f10, f12, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 829B4254: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B4258: 40990008  ble cr6, 0x829b4260
	if !ctx.cr[6].gt {
	pc = 0x829B4260; continue 'dispatch;
	}
	// 829B425C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 829B4260: C1B60410  lfs f13, 0x410(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4264: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 829B4268: 40980008  bge cr6, 0x829b4270
	if !ctx.cr[6].lt {
	pc = 0x829B4270; continue 'dispatch;
	}
	// 829B426C: D1760410  stfs f11, 0x410(r22)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829B4270: C1B60410  lfs f13, 0x410(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4274: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B4278: 40990008  ble cr6, 0x829b4280
	if !ctx.cr[6].gt {
	pc = 0x829B4280; continue 'dispatch;
	}
	// 829B427C: D0160410  stfs f0, 0x410(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(1040 as u32), tmp.u32 ) };
	// 829B4280: 807603F8  lwz r3, 0x3f8(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1016 as u32) ) } as u64;
	// 829B4284: 4B91BC9D  bl 0x822cff20
	ctx.lr = 0x829B4288;
	sub_822CFF20(ctx, base);
	// 829B4288: C0160410  lfs f0, 0x410(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1040 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B428C: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B4290: EC21002A  fadds f1, f1, f0
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B4294: 4B91BC9D  bl 0x822cff30
	ctx.lr = 0x829B4298;
	sub_822CFF30(ctx, base);
	// 829B4298: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B429C: 4B91BC85  bl 0x822cff20
	ctx.lr = 0x829B42A0;
	sub_822CFF20(ctx, base);
	// 829B42A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B42A4: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B42A8: C3AB9524  lfs f29, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829B42AC: EFE1E82A  fadds f31, f1, f29
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[29].f64) as f32) as f64;
	// 829B42B0: 4B91BC61  bl 0x822cff10
	ctx.lr = 0x829B42B4;
	sub_822CFF10(ctx, base);
	// 829B42B4: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 829B42B8: 41980010  blt cr6, 0x829b42c8
	if ctx.cr[6].lt {
	pc = 0x829B42C8; continue 'dispatch;
	}
	// 829B42BC: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B42C0: 4B91BC51  bl 0x822cff10
	ctx.lr = 0x829B42C4;
	sub_822CFF10(ctx, base);
	// 829B42C4: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 829B42C8: 38E10190  addi r7, r1, 0x190
	ctx.r[7].s64 = ctx.r[1].s64 + 400;
	// 829B42CC: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B42D0: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 829B42D4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B42D8: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 829B42DC: 4B91BE45  bl 0x822d0120
	ctx.lr = 0x829B42E0;
	sub_822D0120(ctx, base);
	// 829B42E0: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B42E4: 4B91BC3D  bl 0x822cff20
	ctx.lr = 0x829B42E8;
	sub_822CFF20(ctx, base);
	// 829B42E8: EFE1E828  fsubs f31, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[29].f64) as f32) as f64);
	// 829B42EC: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 829B42F0: 40980010  bge cr6, 0x829b4300
	if !ctx.cr[6].lt {
	pc = 0x829B4300; continue 'dispatch;
	}
	// 829B42F4: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B42F8: 4B91BC19  bl 0x822cff10
	ctx.lr = 0x829B42FC;
	sub_822CFF10(ctx, base);
	// 829B42FC: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 829B4300: 38E10160  addi r7, r1, 0x160
	ctx.r[7].s64 = ctx.r[1].s64 + 352;
	// 829B4304: 807603F0  lwz r3, 0x3f0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B4308: 38C10170  addi r6, r1, 0x170
	ctx.r[6].s64 = ctx.r[1].s64 + 368;
	// 829B430C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B4310: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 829B4314: 4B91BE0D  bl 0x822d0120
	ctx.lr = 0x829B4318;
	sub_822D0120(ctx, base);
	// 829B4318: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 829B431C: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 829B4320: FC20D890  fmr f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[27].f64;
	// 829B4324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B4328: 484C9319  bl 0x82e7d640
	ctx.lr = 0x829B432C;
	sub_82E7D640(ctx, base);
	// 829B432C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B4330: 39410150  addi r10, r1, 0x150
	ctx.r[10].s64 = ctx.r[1].s64 + 336;
	// 829B4334: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 829B4338: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829B433C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B44C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B44C0 size=200
    let mut pc: u32 = 0x829B44C0;
    'dispatch: loop {
        match pc {
            0x829B44C0 => {
    //   block [0x829B44C0..0x829B4588)
	// 829B44C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B44C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B44C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B44CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B44D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B44D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B44D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B44DC: 4BFEEB55  bl 0x829a3030
	ctx.lr = 0x829B44E0;
	sub_829A3030(ctx, base);
	// 829B44E0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B44E4: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 829B44E8: 7FCB0774  extsb r11, r30
	ctx.r[11].s64 = ctx.r[30].s8 as i64;
	// 829B44EC: 394A2540  addi r10, r10, 0x2540
	ctx.r[10].s64 = ctx.r[10].s64 + 9536;
	// 829B44F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B44F4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829B44F8: 4198002C  blt cr6, 0x829b4524
	if ctx.cr[6].lt {
	pc = 0x829B4524; continue 'dispatch;
	}
	// 829B44FC: 419A0018  beq cr6, 0x829b4514
	if ctx.cr[6].eq {
	pc = 0x829B4514; continue 'dispatch;
	}
	// 829B4500: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B4504: 4098005C  bge cr6, 0x829b4560
	if !ctx.cr[6].lt {
	pc = 0x829B4560; continue 'dispatch;
	}
	// 829B4508: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B450C: C00B250C  lfs f0, 0x250c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9484 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4510: 4800004C  b 0x829b455c
	pc = 0x829B455C; continue 'dispatch;
	// 829B4514: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B4518: 396B250C  addi r11, r11, 0x250c
	ctx.r[11].s64 = ctx.r[11].s64 + 9484;
	// 829B451C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4520: 4800003C  b 0x829b455c
	pc = 0x829B455C; continue 'dispatch;
	// 829B4524: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B4528: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B452C: 392B9504  addi r9, r11, -0x6afc
	ctx.r[9].s64 = ctx.r[11].s64 + -27388;
	// 829B4530: C14B9504  lfs f10, -0x6afc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27388 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829B4534: C16A9524  lfs f11, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B4538: C0090020  lfs f0, 0x20(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B453C: C1A9001C  lfs f13, 0x1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4540: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B4544: C1890018  lfs f12, 0x18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B4548: C0090014  lfs f0, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B454C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B4550: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B4554: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 829B4558: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 829B455C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B4560: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B4564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4568: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B456C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829B4570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B4574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B4578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B457C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B4580: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B4584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B4588 size=36
    let mut pc: u32 = 0x829B4588;
    'dispatch: loop {
        match pc {
            0x829B4588 => {
    //   block [0x829B4588..0x829B45AC)
	// 829B4588: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B458C: C1A30018  lfs f13, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4590: C00B9500  lfs f0, -0x6b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4594: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B4598: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B459C: 40980008  bge cr6, 0x829b45a4
	if !ctx.cr[6].lt {
	pc = 0x829B45A4; continue 'dispatch;
	}
	// 829B45A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B45A4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B45A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B45B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B45B0 size=96
    let mut pc: u32 = 0x829B45B0;
    'dispatch: loop {
        match pc {
            0x829B45B0 => {
    //   block [0x829B45B0..0x829B4610)
	// 829B45B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B45B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B45B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B45BC: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B45C0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 829B45C4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829B45C8: 419A0034  beq cr6, 0x829b45fc
	if ctx.cr[6].eq {
	pc = 0x829B45FC; continue 'dispatch;
	}
	// 829B45CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B45D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B45D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B45D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B45DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B45E0: 4E800421  bctrl
	ctx.lr = 0x829B45E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B45E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B45E8: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B45EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829B45F0: C00B614C  lfs f0, 0x614c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B45F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B45F8: 40980008  bge cr6, 0x829b4600
	if !ctx.cr[6].lt {
	pc = 0x829B4600; continue 'dispatch;
	}
	// 829B45FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829B4600: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B4604: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B4608: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B460C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B4610 size=820
    let mut pc: u32 = 0x829B4610;
    'dispatch: loop {
        match pc {
            0x829B4610 => {
    //   block [0x829B4610..0x829B4944)
	// 829B4610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B4614: 487F3B55  bl 0x831a8168
	ctx.lr = 0x829B4618;
	sub_831A8130(ctx, base);
	// 829B4618: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 829B461C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 829B4620: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829B4624: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4628: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B462C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4630: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4634: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829B4638: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B463C: ED806824  fdivs f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829B4640: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B4644: 419801B8  blt cr6, 0x829b47fc
	if ctx.cr[6].lt {
	pc = 0x829B47FC; continue 'dispatch;
	}
	// 829B4648: 419A00D4  beq cr6, 0x829b471c
	if ctx.cr[6].eq {
	pc = 0x829B471C; continue 'dispatch;
	}
	// 829B464C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B4650: 41980018  blt cr6, 0x829b4668
	if ctx.cr[6].lt {
	pc = 0x829B4668; continue 'dispatch;
	}
	// 829B4654: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829B4658: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 829B465C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B4948 size=236
    let mut pc: u32 = 0x829B4948;
    'dispatch: loop {
        match pc {
            0x829B4948 => {
    //   block [0x829B4948..0x829B4A34)
	// 829B4948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B494C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B4950: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B4954: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4958: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B495C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B4960: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B4964: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B4968: 4198000C  blt cr6, 0x829b4974
	if ctx.cr[6].lt {
	pc = 0x829B4974; continue 'dispatch;
	}
	// 829B496C: 419A0048  beq cr6, 0x829b49b4
	if ctx.cr[6].eq {
	pc = 0x829B49B4; continue 'dispatch;
	}
	// 829B4970: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B4974: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829B4978: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829B497C: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4980: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B4984: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4988: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B498C: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4990: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B4994: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4998: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B499C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B49A0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829B49A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B49A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B49AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B49B0: 4E800020  blr
	return;
	// 829B49B4: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B49B8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B49BC: 41980050  blt cr6, 0x829b4a0c
	if ctx.cr[6].lt {
	pc = 0x829B4A0C; continue 'dispatch;
	}
	// 829B49C0: 419A0034  beq cr6, 0x829b49f4
	if ctx.cr[6].eq {
	pc = 0x829B49F4; continue 'dispatch;
	}
	// 829B49C4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B49C8: 41980044  blt cr6, 0x829b4a0c
	if ctx.cr[6].lt {
	pc = 0x829B4A0C; continue 'dispatch;
	}
	// 829B49CC: 419A0028  beq cr6, 0x829b49f4
	if ctx.cr[6].eq {
	pc = 0x829B49F4; continue 'dispatch;
	}
	// 829B49D0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B49D4: 41980014  blt cr6, 0x829b49e8
	if ctx.cr[6].lt {
	pc = 0x829B49E8; continue 'dispatch;
	}
	// 829B49D8: 409A0040  bne cr6, 0x829b4a18
	if !ctx.cr[6].eq {
	pc = 0x829B4A18; continue 'dispatch;
	}
	// 829B49DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B49E0: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B49E4: 48000018  b 0x829b49fc
	pc = 0x829B49FC; continue 'dispatch;
	// 829B49E8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829B49EC: C1AA3EB4  lfs f13, 0x3eb4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B49F0: 4800000C  b 0x829b49fc
	pc = 0x829B49FC; continue 'dispatch;
	// 829B49F4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B49F8: C1AA2574  lfs f13, 0x2574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9588 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B49FC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829B4A00: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4A04: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B4A08: 48000014  b 0x829b4a1c
	pc = 0x829B4A1C; continue 'dispatch;
	// 829B4A0C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B4A10: C1AA2570  lfs f13, 0x2570(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4A14: 4BFFFFE8  b 0x829b49fc
	pc = 0x829B49FC; continue 'dispatch;
	// 829B4A18: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B4A1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B4A20: 484C7FC9  bl 0x82e7c9e8
	ctx.lr = 0x829B4A24;
	sub_82E7C9E8(ctx, base);
	// 829B4A24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B4A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4A2C: 484C83DD  bl 0x82e7ce08
	ctx.lr = 0x829B4A30;
	sub_82E7CE08(ctx, base);
	// 829B4A30: 4BFFFF6C  b 0x829b499c
	pc = 0x829B499C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B4A38 size=64
    let mut pc: u32 = 0x829B4A38;
    'dispatch: loop {
        match pc {
            0x829B4A38 => {
    //   block [0x829B4A38..0x829B4A78)
	// 829B4A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B4A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B4A40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B4A44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4A48: 80840014  lwz r4, 0x14(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B4A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B4A50: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B4A54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B4A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B4A5C: 4E800421  bctrl
	ctx.lr = 0x829B4A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B4A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4A64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B4A68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B4A6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B4A70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B4A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B4A78 size=64
    let mut pc: u32 = 0x829B4A78;
    'dispatch: loop {
        match pc {
            0x829B4A78 => {
    //   block [0x829B4A78..0x829B4AB8)
	// 829B4A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B4A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B4A80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B4A84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4A88: 80840014  lwz r4, 0x14(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B4A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B4A90: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B4A94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B4A98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B4A9C: 4E800421  bctrl
	ctx.lr = 0x829B4AA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B4AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4AA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B4AA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B4AAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B4AB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B4AB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B4AB8 size=20
    let mut pc: u32 = 0x829B4AB8;
    'dispatch: loop {
        match pc {
            0x829B4AB8 => {
    //   block [0x829B4AB8..0x829B4ACC)
	// 829B4AB8: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B4ABC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B4AC0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829B4AC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B4AC8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B4AD0 size=160
    let mut pc: u32 = 0x829B4AD0;
    'dispatch: loop {
        match pc {
            0x829B4AD0 => {
    //   block [0x829B4AD0..0x829B4B70)
	// 829B4AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B4AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B4AD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B4ADC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4AE0: 4879FB21  bl 0x83154600
	ctx.lr = 0x829B4AE4;
	sub_83154600(ctx, base);
	// 829B4AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B4AE8: 807F0378  lwz r3, 0x378(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(888 as u32) ) } as u64;
	// 829B4AEC: 4BE408E5  bl 0x827f53d0
	ctx.lr = 0x829B4AF0;
	sub_827F53D0(ctx, base);
	// 829B4AF0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829B4AF4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B4AF8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B4AFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B4B70 size=864
    let mut pc: u32 = 0x829B4B70;
    'dispatch: loop {
        match pc {
            0x829B4B70 => {
    //   block [0x829B4B70..0x829B4ED0)
	// 829B4B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B4B74: 487F35F9  bl 0x831a816c
	ctx.lr = 0x829B4B78;
	sub_831A8130(ctx, base);
	// 829B4B78: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 829B4B7C: 487F3EED  bl 0x831a8a68
	ctx.lr = 0x829B4B80;
	sub_831A8A40(ctx, base);
	// 829B4B80: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B4B88: 4879FA79  bl 0x83154600
	ctx.lr = 0x829B4B8C;
	sub_83154600(ctx, base);
	// 829B4B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4B90: 4BFFF0B1  bl 0x829b3c40
	ctx.lr = 0x829B4B94;
	sub_829B3C40(ctx, base);
	// 829B4B94: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B4B98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B4B9C: 3BCB9540  addi r30, r11, -0x6ac0
	ctx.r[30].s64 = ctx.r[11].s64 + -27328;
	// 829B4BA0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829B4BA4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829B4BA8: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B4BAC: FF60F890  fmr f27, f31
	ctx.f[27].f64 = ctx.f[31].f64;
	// 829B4BB0: C3C92530  lfs f30, 0x2530(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9520 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829B4BB4: C3489524  lfs f26, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 829B4BB8: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 829B4BBC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B4BC0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B4BC4: 41980110  blt cr6, 0x829b4cd4
	if ctx.cr[6].lt {
	pc = 0x829B4CD4; continue 'dispatch;
	}
	// 829B4BC8: 419A009C  beq cr6, 0x829b4c64
	if ctx.cr[6].eq {
	pc = 0x829B4C64; continue 'dispatch;
	}
	// 829B4BCC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B4BD0: 41980034  blt cr6, 0x829b4c04
	if ctx.cr[6].lt {
	pc = 0x829B4C04; continue 'dispatch;
	}
	// 829B4BD4: 409A017C  bne cr6, 0x829b4d50
	if !ctx.cr[6].eq {
	pc = 0x829B4D50; continue 'dispatch;
	}
	// 829B4BD8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829B4BDC: C19EFFF8  lfs f12, -8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B4BE0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B4BE4: C17EFFEC  lfs f11, -0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B4BE8: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4BEC: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4BF0: EF8007F2  fmuls f28, f0, f31
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 829B4BF4: D19F0160  stfs f12, 0x160(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B4BF8: EFA00372  fmuls f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B4BFC: D17F0164  stfs f11, 0x164(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 829B4C00: 48000158  b 0x829b4d58
	pc = 0x829B4D58; continue 'dispatch;
	// 829B4C04: 3FA08212  lis r29, -0x7dee
	ctx.r[29].s64 = -2112749568;
	// 829B4C08: C1BEFFF8  lfs f13, -8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4C0C: C19EFFEC  lfs f12, -0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B4C10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B4C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4C18: C01DDFAC  lfs f0, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4C1C: D1BF0160  stfs f13, 0x160(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B4C20: EF8007F2  fmuls f28, f0, f31
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 829B4C24: D19F0164  stfs f12, 0x164(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 829B4C28: C36B9450  lfs f27, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 829B4C2C: EFA006F2  fmuls f29, f0, f27
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 829B4C30: 484A4B31  bl 0x82e59760
	ctx.lr = 0x829B4C34;
	sub_82E59760(ctx, base);
	// 829B4C34: C01DDFAC  lfs f0, -0x2054(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4C38: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4C3C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829B4C40: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B4C44: EC2006B2  fmuls f1, f0, f26
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 829B4C48: 487F4261  bl 0x831a8ea8
	ctx.lr = 0x829B4C4C;
	sub_831A8EA8(ctx, base);
	// 829B4C4C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4C50: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4C54: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 829B4C58: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 829B4C5C: EF6D0032  fmuls f27, f13, f0
	ctx.f[27].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B4C60: 480000F8  b 0x829b4d58
	pc = 0x829B4D58; continue 'dispatch;
	// 829B4C64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4C68: 484A4AF9  bl 0x82e59760
	ctx.lr = 0x829B4C6C;
	sub_82E59760(ctx, base);
	// 829B4C6C: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4C70: EFA10024  fdivs f29, f1, f0
	ctx.f[29].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 829B4C74: 3FA08212  lis r29, -0x7dee
	ctx.r[29].s64 = -2112749568;
	// 829B4C78: C01DDFAC  lfs f0, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4C7C: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 829B4C80: 487F4229  bl 0x831a8ea8
	ctx.lr = 0x829B4C84;
	sub_831A8EA8(ctx, base);
	// 829B4C84: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4C88: C19E0010  lfs f12, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B4C8C: EF6C0772  fmuls f27, f12, f29
	ctx.f[27].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 829B4C90: C1BDDFAC  lfs f13, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4C94: C19EFFEC  lfs f12, -0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B4C98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B4C9C: D19F0164  stfs f12, 0x164(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 829B4CA0: ED3EE828  fsubs f9, f30, f29
	ctx.f[9].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 829B4CA4: C01EFFF8  lfs f0, -8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4CA8: ED000772  fmuls f8, f0, f29
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 829B4CAC: C17EFFF4  lfs f11, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B4CB0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4CB4: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B4CB8: ED8AF02A  fadds f12, f10, f30
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[30].f64) as f32) as f64;
	// 829B4CBC: ED6942FA  fmadds f11, f9, f11, f8
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 829B4CC0: D17F0160  stfs f11, 0x160(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B4CC4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B4CC8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B4CCC: EF8D0032  fmuls f28, f13, f0
	ctx.f[28].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B4CD0: 48000088  b 0x829b4d58
	pc = 0x829B4D58; continue 'dispatch;
	// 829B4CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4CD8: 484A4A89  bl 0x82e59760
	ctx.lr = 0x829B4CDC;
	sub_82E59760(ctx, base);
	// 829B4CDC: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4CE0: EF210024  fdivs f25, f1, f0
	ctx.f[25].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 829B4CE4: 3FA08212  lis r29, -0x7dee
	ctx.r[29].s64 = -2112749568;
	// 829B4CE8: C01DDFAC  lfs f0, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4CEC: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 829B4CF0: 487F41B9  bl 0x831a8ea8
	ctx.lr = 0x829B4CF4;
	sub_831A8EA8(ctx, base);
	// 829B4CF4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4CF8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B4CFC: C01DDFAC  lfs f0, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4D00: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 829B4D04: C3AB9450  lfs f29, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829B4D08: EDADEF7C  fnmsubs f13, f13, f29, f29
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[29].f64 - ctx.f[29].f64) as f32) as f64);
	// 829B4D0C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B4D10: EF800772  fmuls f28, f0, f29
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 829B4D14: 487F4195  bl 0x831a8ea8
	ctx.lr = 0x829B4D18;
	sub_831A8EA8(ctx, base);
	// 829B4D18: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4D1C: C01EFFEC  lfs f0, -0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4D20: ED600672  fmuls f11, f0, f25
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 829B4D24: C1BDDFAC  lfs f13, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4D28: C01EFFF4  lfs f0, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4D2C: ED5EC828  fsubs f10, f30, f25
	ctx.f[10].f64 = (((ctx.f[30].f64 - ctx.f[25].f64) as f32) as f64);
	// 829B4D30: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B4D34: C13F0194  lfs f9, 0x194(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829B4D38: EC0CEF7C  fnmsubs f0, f12, f29, f29
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[29].f64 - ctx.f[29].f64) as f32) as f64);
	// 829B4D3C: ED8A5A7A  fmadds f12, f10, f9, f11
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[9].f64 + ctx.f[11].f64) as f32) as f64);
	// 829B4D40: D19F0164  stfs f12, 0x164(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 829B4D44: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B4D48: EFA00772  fmuls f29, f0, f29
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 829B4D4C: 4800000C  b 0x829b4d58
	pc = 0x829B4D58; continue 'dispatch;
	// 829B4D50: C3810050  lfs f28, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829B4D54: C3A10050  lfs f29, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829B4D58: FF20E090  fmr f25, f28
	ctx.f[25].f64 = ctx.f[28].f64;
	// 829B4D5C: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 829B4D60: 487F4149  bl 0x831a8ea8
	ctx.lr = 0x829B4D64;
	sub_831A8EA8(ctx, base);
	// 829B4D64: FF000818  frsp f24, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4D68: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 829B4D6C: 487F405D  bl 0x831a8dc8
	ctx.lr = 0x829B4D70;
	sub_831A8DC8(ctx, base);
	// 829B4D70: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4D74: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4D78: ED7EC028  fsubs f11, f30, f24
	ctx.f[11].f64 = (((ctx.f[30].f64 - ctx.f[24].f64) as f32) as f64);
	// 829B4D7C: C1BEFFFC  lfs f13, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4D80: D3610064  stfs f27, 0x64(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829B4D84: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829B4D88: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829B4D8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B4D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4D94: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 829B4D98: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B4D9C: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829B4DA0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B4DA4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829B4DA8: 480095B1  bl 0x829be358
	ctx.lr = 0x829B4DAC;
	sub_829BE358(ctx, base);
	// 829B4DAC: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829B4DB0: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829B4DB4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829B4DB8: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829B4DBC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829B4DC0: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829B4DC4: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 829B4DC8: 484C7E79  bl 0x82e7cc40
	ctx.lr = 0x829B4DCC;
	sub_82E7CC40(ctx, base);
	// 829B4DCC: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829B4DD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B4DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4DD8: 48009599  bl 0x829be370
	ctx.lr = 0x829B4DDC;
	sub_829BE370(ctx, base);
	// 829B4DDC: FF80E890  fmr f28, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[29].f64;
	// 829B4DE0: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 829B4DE4: 487F40C5  bl 0x831a8ea8
	ctx.lr = 0x829B4DE8;
	sub_831A8EA8(ctx, base);
	// 829B4DE8: FF600818  frsp f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4DEC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 829B4DF0: 487F3FD9  bl 0x831a8dc8
	ctx.lr = 0x829B4DF4;
	sub_831A8DC8(ctx, base);
	// 829B4DF4: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B4DF8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4DFC: ED7ED828  fsubs f11, f30, f27
	ctx.f[11].f64 = (((ctx.f[30].f64 - ctx.f[27].f64) as f32) as f64);
	// 829B4E00: C1BEFFFC  lfs f13, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B4E04: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829B4E08: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 829B4E0C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829B4E10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B4E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4E18: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 829B4E1C: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B4E20: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829B4E24: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B4E28: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829B4E2C: 4800952D  bl 0x829be358
	ctx.lr = 0x829B4E30;
	sub_829BE358(ctx, base);
	// 829B4E30: D3E10090  stfs f31, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829B4E34: D3C10094  stfs f30, 0x94(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829B4E38: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829B4E3C: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829B4E40: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829B4E44: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829B4E48: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829B4E4C: 484C7DF5  bl 0x82e7cc40
	ctx.lr = 0x829B4E50;
	sub_82E7CC40(ctx, base);
	// 829B4E50: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829B4E54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B4E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4E5C: 48009515  bl 0x829be370
	ctx.lr = 0x829B4E60;
	sub_829BE370(ctx, base);
	// 829B4E60: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829B4E64: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829B4E68: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 829B4E6C: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 829B4E70: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829B4E74: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 829B4E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4E7C: 480094DD  bl 0x829be358
	ctx.lr = 0x829B4E80;
	sub_829BE358(ctx, base);
	// 829B4E80: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829B4E84: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829B4E88: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829B4E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4E90: 480094E1  bl 0x829be370
	ctx.lr = 0x829B4E94;
	sub_829BE370(ctx, base);
	// 829B4E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4E98: 484A48E1  bl 0x82e59778
	ctx.lr = 0x829B4E9C;
	sub_82E59778(ctx, base);
	// 829B4E9C: C01F0198  lfs f0, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B4EA0: EC0106BA  fmadds f0, f1, f26, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[26].f64 + ctx.f[0].f64) as f32) as f64);
	// 829B4EA4: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829B4EA8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829B4EAC: 40990008  ble cr6, 0x829b4eb4
	if !ctx.cr[6].gt {
	pc = 0x829B4EB4; continue 'dispatch;
	}
	// 829B4EB0: D3DF0198  stfs f30, 0x198(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 829B4EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4EB8: C03F0198  lfs f1, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B4EBC: 480094ED  bl 0x829be3a8
	ctx.lr = 0x829B4EC0;
	sub_829BE3A8(ctx, base);
	// 829B4EC0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829B4EC4: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 829B4EC8: 487F3BED  bl 0x831a8ab4
	ctx.lr = 0x829B4ECC;
	sub_831A8A8C(ctx, base);
	// 829B4ECC: 487F32F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B4ED0 size=172
    let mut pc: u32 = 0x829B4ED0;
    'dispatch: loop {
        match pc {
            0x829B4ED0 => {
    //   block [0x829B4ED0..0x829B4F7C)
	// 829B4ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B4ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B4ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B4EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B4EE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4EE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B4EE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B4EEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B4EF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B4EF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B4EF8: 4B90BA41  bl 0x822c0938
	ctx.lr = 0x829B4EFC;
	sub_822C0938(ctx, base);
	// 829B4EFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B4F00: 41820028  beq 0x829b4f28
	if ctx.cr[0].eq {
	pc = 0x829B4F28; continue 'dispatch;
	}
	// 829B4F04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B4F08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B4F0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B4F10: 392B2590  addi r9, r11, 0x2590
	ctx.r[9].s64 = ctx.r[11].s64 + 9616;
	// 829B4F14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B4F18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B4F1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B4F20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B4F24: 48000008  b 0x829b4f2c
	pc = 0x829B4F2C; continue 'dispatch;
	// 829B4F28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B4F2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B4F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B4F34: 409A002C  bne cr6, 0x829b4f60
	if !ctx.cr[6].eq {
	pc = 0x829B4F60; continue 'dispatch;
	}
	// 829B4F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4F3C: 4B90B32D  bl 0x822c0268
	ctx.lr = 0x829B4F40;
	sub_822C0268(ctx, base);
	// 829B4F40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B4F44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B4F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B4F4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B4F50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B4F54: 816B9568  lwz r11, -0x6a98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27288 as u32) ) } as u64;
	// 829B4F58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B4F5C: 4B90B0A5  bl 0x822c0000
	ctx.lr = 0x829B4F60;
	sub_822C0000(ctx, base);
	// 829B4F60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B4F64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B4F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B4F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B4F70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B4F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B4F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B4F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B4F80 size=196
    let mut pc: u32 = 0x829B4F80;
    'dispatch: loop {
        match pc {
            0x829B4F80 => {
    //   block [0x829B4F80..0x829B5044)
	// 829B4F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B4F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B4F88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B4F8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B4F90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B4F94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B4F98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B4F9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B4FA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B4FA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B4FA8: 4B90B991  bl 0x822c0938
	ctx.lr = 0x829B4FAC;
	sub_822C0938(ctx, base);
	// 829B4FAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B4FB0: 41820028  beq 0x829b4fd8
	if ctx.cr[0].eq {
	pc = 0x829B4FD8; continue 'dispatch;
	}
	// 829B4FB4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B4FB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B4FBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B4FC0: 392B25A4  addi r9, r11, 0x25a4
	ctx.r[9].s64 = ctx.r[11].s64 + 9636;
	// 829B4FC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B4FC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B4FCC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B4FD0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B4FD4: 48000008  b 0x829b4fdc
	pc = 0x829B4FDC; continue 'dispatch;
	// 829B4FD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B4FDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B4FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B4FE4: 409A0044  bne cr6, 0x829b5028
	if !ctx.cr[6].eq {
	pc = 0x829B5028; continue 'dispatch;
	}
	// 829B4FE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B4FEC: 419A001C  beq cr6, 0x829b5008
	if ctx.cr[6].eq {
	pc = 0x829B5008; continue 'dispatch;
	}
	// 829B4FF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B4FF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B4FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B4FFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B5000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B5004: 4E800421  bctrl
	ctx.lr = 0x829B5008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B5008: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B500C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B5010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B5014: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B5018: 816B9568  lwz r11, -0x6a98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27288 as u32) ) } as u64;
	// 829B501C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B5020: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B5024: 4B90AFDD  bl 0x822c0000
	ctx.lr = 0x829B5028;
	sub_822C0000(ctx, base);
	// 829B5028: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B502C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B5030: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B5034: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B5038: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B503C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B5040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B5048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B5048 size=148
    let mut pc: u32 = 0x829B5048;
    'dispatch: loop {
        match pc {
            0x829B5048 => {
    //   block [0x829B5048..0x829B50DC)
	// 829B5048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B504C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B5050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B5054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B5058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B505C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B5060: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B5064: 4BFEDFCD  bl 0x829a3030
	ctx.lr = 0x829B5068;
	sub_829A3030(ctx, base);
	// 829B5068: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B506C: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 829B5070: 396A25B8  addi r11, r10, 0x25b8
	ctx.r[11].s64 = ctx.r[10].s64 + 9656;
	// 829B5074: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B5078: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B507C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 829B5080: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B5084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B5088: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829B508C: 419A0024  beq cr6, 0x829b50b0
	if ctx.cr[6].eq {
	pc = 0x829B50B0; continue 'dispatch;
	}
	// 829B5090: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B5094: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B5098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B509C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B50A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B50A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B50A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B50AC: 4082FFE8  bne 0x829b5094
	if !ctx.cr[0].eq {
	pc = 0x829B5094; continue 'dispatch;
	}
	// 829B50B0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B50B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B50B8: 419A0008  beq cr6, 0x829b50c0
	if ctx.cr[6].eq {
	pc = 0x829B50C0; continue 'dispatch;
	}
	// 829B50BC: 4B90B7D5  bl 0x822c0890
	ctx.lr = 0x829B50C0;
	sub_822C0890(ctx, base);
	// 829B50C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B50C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B50C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B50CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B50D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B50D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B50D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B50E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B50E0 size=76
    let mut pc: u32 = 0x829B50E0;
    'dispatch: loop {
        match pc {
            0x829B50E0 => {
    //   block [0x829B50E0..0x829B512C)
	// 829B50E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B50E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B50E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B50EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B50F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B50F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B50F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B50FC: 4BFFE8A5  bl 0x829b39a0
	ctx.lr = 0x829B5100;
	sub_829B39A0(ctx, base);
	// 829B5100: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B5104: 9BDF0191  stb r30, 0x191(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(401 as u32), ctx.r[30].u8 ) };
	// 829B5108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B510C: 396B25D0  addi r11, r11, 0x25d0
	ctx.r[11].s64 = ctx.r[11].s64 + 9680;
	// 829B5110: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B5114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B5118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B511C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B5120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B5124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B5128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B5130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B5130 size=372
    let mut pc: u32 = 0x829B5130;
    'dispatch: loop {
        match pc {
            0x829B5130 => {
    //   block [0x829B5130..0x829B52A4)
	// 829B5130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B5134: 487F3039  bl 0x831a816c
	ctx.lr = 0x829B5138;
	sub_831A8130(ctx, base);
	// 829B5138: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B513C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B5140: 4879F4C1  bl 0x83154600
	ctx.lr = 0x829B5144;
	sub_83154600(ctx, base);
	// 829B5144: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 829B5148: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B514C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B5150: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B5154: 4198004C  blt cr6, 0x829b51a0
	if ctx.cr[6].lt {
	pc = 0x829B51A0; continue 'dispatch;
	}
	// 829B5158: 409A0144  bne cr6, 0x829b529c
	if !ctx.cr[6].eq {
	pc = 0x829B529C; continue 'dispatch;
	}
	// 829B515C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5160: 484A4601  bl 0x82e59760
	ctx.lr = 0x829B5164;
	sub_82E59760(ctx, base);
	// 829B5164: 3FC0832E  lis r30, -0x7cd2
	ctx.r[30].s64 = -2094137344;
	// 829B5168: C01E9548  lfs f0, -0x6ab8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B516C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829B5170: 4198012C  blt cr6, 0x829b529c
	if ctx.cr[6].lt {
	pc = 0x829B529C; continue 'dispatch;
	}
	// 829B5174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5178: 484A45E9  bl 0x82e59760
	ctx.lr = 0x829B517C;
	sub_82E59760(ctx, base);
	// 829B517C: C01E9548  lfs f0, -0x6ab8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5184: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B5188: 4846CDA1  bl 0x82e21f28
	ctx.lr = 0x829B518C;
	sub_82E21F28(ctx, base);
	// 829B518C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829B5190: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829B5194: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 829B5198: 995D03CC  stb r10, 0x3cc(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(972 as u32), ctx.r[10].u8 ) };
	// 829B519C: 48000100  b 0x829b529c
	pc = 0x829B529C; continue 'dispatch;
	// 829B51A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B51A4: 484A45BD  bl 0x82e59760
	ctx.lr = 0x829B51A8;
	sub_82E59760(ctx, base);
	// 829B51A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B51AC: 3BCB9548  addi r30, r11, -0x6ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -27320;
	// 829B51B0: C01EFFFC  lfs f0, -4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B51B4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829B51B8: 419800E4  blt cr6, 0x829b529c
	if ctx.cr[6].lt {
	pc = 0x829B529C; continue 'dispatch;
	}
	// 829B51BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B51C0: 484A45A1  bl 0x82e59760
	ctx.lr = 0x829B51C4;
	sub_82E59760(ctx, base);
	// 829B51C4: C01EFFFC  lfs f0, -4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B51C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B51CC: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B51D0: 4846CD59  bl 0x82e21f28
	ctx.lr = 0x829B51D4;
	sub_82E21F28(ctx, base);
	// 829B51D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B51D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B51DC: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 829B51E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B51E4: 388A25F8  addi r4, r10, 0x25f8
	ctx.r[4].s64 = ctx.r[10].s64 + 9720;
	// 829B51E8: 38A0039B  li r5, 0x39b
	ctx.r[5].s64 = 923;
	// 829B51EC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829B51F0: 4B90B1E9  bl 0x822c03d8
	ctx.lr = 0x829B51F4;
	sub_822C03D8(ctx, base);
	// 829B51F4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829B51F8: 41820024  beq 0x829b521c
	if ctx.cr[0].eq {
	pc = 0x829B521C; continue 'dispatch;
	}
	// 829B51FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B5200: 4BFEDE61  bl 0x829a3060
	ctx.lr = 0x829B5204;
	sub_829A3060(ctx, base);
	// 829B5204: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829B5208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B520C: 889F0191  lbz r4, 0x191(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(401 as u32) ) } as u64;
	// 829B5210: 4BFFF2B1  bl 0x829b44c0
	ctx.lr = 0x829B5214;
	sub_829B44C0(ctx, base);
	// 829B5214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B5218: 48000008  b 0x829b5220
	pc = 0x829B5220; continue 'dispatch;
	// 829B521C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B5220: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829B5224: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B5228: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B522C: 4BFFFCA5  bl 0x829b4ed0
	ctx.lr = 0x829B5230;
	sub_829B4ED0(ctx, base);
	// 829B5230: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B5234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B5238: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B523C: 4B90ADC5  bl 0x822c0000
	ctx.lr = 0x829B5240;
	sub_822C0000(ctx, base);
	// 829B5240: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B5244: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B5248: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B524C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829B5250: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829B5254: 419A0024  beq cr6, 0x829b5278
	if ctx.cr[6].eq {
	pc = 0x829B5278; continue 'dispatch;
	}
	// 829B5258: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B525C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B5260: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B5264: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B5268: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B526C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B5270: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B5274: 4082FFE8  bne 0x829b525c
	if !ctx.cr[0].eq {
	pc = 0x829B525C; continue 'dispatch;
	}
	// 829B5278: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B527C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829B5280: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B5284: C02B2530  lfs f1, 0x2530(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9520 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B5288: 4BFEFDD9  bl 0x829a5060
	ctx.lr = 0x829B528C;
	sub_829A5060(ctx, base);
	// 829B528C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B5290: 419A000C  beq cr6, 0x829b529c
	if ctx.cr[6].eq {
	pc = 0x829B529C; continue 'dispatch;
	}
	// 829B5294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5298: 4B90B5F9  bl 0x822c0890
	ctx.lr = 0x829B529C;
	sub_822C0890(ctx, base);
	// 829B529C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B52A0: 487F2F1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B52A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B52A8 size=1060
    let mut pc: u32 = 0x829B52A8;
    'dispatch: loop {
        match pc {
            0x829B52A8 => {
    //   block [0x829B52A8..0x829B56CC)
	// 829B52A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B52AC: 487F2E99  bl 0x831a8144
	ctx.lr = 0x829B52B0;
	sub_831A8130(ctx, base);
	// 829B52B0: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 829B52B4: 487F37BD  bl 0x831a8a70
	ctx.lr = 0x829B52B8;
	sub_831A8A40(ctx, base);
	// 829B52B8: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B56D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B56D0 size=60
    let mut pc: u32 = 0x829B56D0;
    'dispatch: loop {
        match pc {
            0x829B56D0 => {
    //   block [0x829B56D0..0x829B570C)
	// 829B56D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B56D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B56D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B56DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B56E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B56E4: 4BFFFA4D  bl 0x829b5130
	ctx.lr = 0x829B56E8;
	sub_829B5130(ctx, base);
	// 829B56E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B56EC: 4BFFF485  bl 0x829b4b70
	ctx.lr = 0x829B56F0;
	sub_829B4B70(ctx, base);
	// 829B56F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B56F4: 4BFFFBB5  bl 0x829b52a8
	ctx.lr = 0x829B56F8;
	sub_829B52A8(ctx, base);
	// 829B56F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B56FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B5700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B5704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B5708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B5710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B5710 size=184
    let mut pc: u32 = 0x829B5710;
    'dispatch: loop {
        match pc {
            0x829B5710 => {
    //   block [0x829B5710..0x829B57C8)
	// 829B5710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B5714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B5718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B571C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B5720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B5724: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B5728: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B572C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B5730: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B5734: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B5738: 4B90B201  bl 0x822c0938
	ctx.lr = 0x829B573C;
	sub_822C0938(ctx, base);
	// 829B573C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B5740: 41820028  beq 0x829b5768
	if ctx.cr[0].eq {
	pc = 0x829B5768; continue 'dispatch;
	}
	// 829B5744: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B5748: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B574C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B5750: 392B257C  addi r9, r11, 0x257c
	ctx.r[9].s64 = ctx.r[11].s64 + 9596;
	// 829B5754: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B5758: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B575C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B5760: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B5764: 48000008  b 0x829b576c
	pc = 0x829B576C; continue 'dispatch;
	// 829B5768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B576C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B5770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B5774: 409A0038  bne cr6, 0x829b57ac
	if !ctx.cr[6].eq {
	pc = 0x829B57AC; continue 'dispatch;
	}
	// 829B5778: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B577C: 419A0010  beq cr6, 0x829b578c
	if ctx.cr[6].eq {
	pc = 0x829B578C; continue 'dispatch;
	}
	// 829B5780: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B5784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5788: 4BE275C1  bl 0x827dcd48
	ctx.lr = 0x829B578C;
	sub_827DCD48(ctx, base);
	// 829B578C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B5790: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B5794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B5798: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B579C: 816B9568  lwz r11, -0x6a98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27288 as u32) ) } as u64;
	// 829B57A0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B57A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B57A8: 4B90A859  bl 0x822c0000
	ctx.lr = 0x829B57AC;
	sub_822C0000(ctx, base);
	// 829B57AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B57B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B57B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B57B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B57BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B57C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B57C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B57C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B57C8 size=628
    let mut pc: u32 = 0x829B57C8;
    'dispatch: loop {
        match pc {
            0x829B57C8 => {
    //   block [0x829B57C8..0x829B5A3C)
	// 829B57C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B57CC: 487F2999  bl 0x831a8164
	ctx.lr = 0x829B57D0;
	sub_831A8130(ctx, base);
	// 829B57D0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829B57D4: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B57D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B57DC: 4879EE25  bl 0x83154600
	ctx.lr = 0x829B57E0;
	sub_83154600(ctx, base);
	// 829B57E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B57E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B57E8: 4BFFE111  bl 0x829b38f8
	ctx.lr = 0x829B57EC;
	sub_829B38F8(ctx, base);
	// 829B57EC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B57F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B57F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829B57F8: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B57FC: D01E0160  stfs f0, 0x160(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B5800: 4BB5C919  bl 0x82512118
	ctx.lr = 0x829B5804;
	sub_82512118(ctx, base);
	// 829B5804: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B5808: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B580C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B5810: 3B8B2510  addi r28, r11, 0x2510
	ctx.r[28].s64 = ctx.r[11].s64 + 9488;
	// 829B5814: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 829B5818: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B581C: C01C0020  lfs f0, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5820: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829B5824: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829B5828: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829B582C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829B5830: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B5834: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829B5838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B583C: 4E800421  bctrl
	ctx.lr = 0x829B5840;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B5840: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B5844: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829B5848: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829B584C: 484C64FD  bl 0x82e7bd48
	ctx.lr = 0x829B5850;
	sub_82E7BD48(ctx, base);
	// 829B5850: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829B5854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B5858: 419A0008  beq cr6, 0x829b5860
	if ctx.cr[6].eq {
	pc = 0x829B5860; continue 'dispatch;
	}
	// 829B585C: 4B90B035  bl 0x822c0890
	ctx.lr = 0x829B5860;
	sub_822C0890(ctx, base);
	// 829B5860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5864: 4BB5C285  bl 0x82511ae8
	ctx.lr = 0x829B5868;
	sub_82511AE8(ctx, base);
	// 829B5868: 396003E0  li r11, 0x3e0
	ctx.r[11].s64 = 992;
	// 829B586C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B5870: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 829B5874: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 829B5878: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829B587C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829B5880: 13DF58C7  vcmpequd (lvx128) v30, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B5884: 9B7E0190  stb r27, 0x190(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(400 as u32), ctx.r[27].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B5A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B5A40 size=40
    let mut pc: u32 = 0x829B5A40;
    'dispatch: loop {
        match pc {
            0x829B5A40 => {
    //   block [0x829B5A40..0x829B5A68)
	// 829B5A40: 39630080  addi r11, r3, 0x80
	ctx.r[11].s64 = ctx.r[3].s64 + 128;
	// 829B5A44: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829B5A48: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5A4C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829B5A50: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5A54: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829B5A58: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B5A5C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B5A60: 4082FFE8  bne 0x829b5a48
	if !ctx.cr[0].eq {
	pc = 0x829B5A48; continue 'dispatch;
	}
	// 829B5A64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B5A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B5A68 size=112
    let mut pc: u32 = 0x829B5A68;
    'dispatch: loop {
        match pc {
            0x829B5A68 => {
    //   block [0x829B5A68..0x829B5AD8)
	// 829B5A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B5A6C: 487F2701  bl 0x831a816c
	ctx.lr = 0x829B5A70;
	sub_831A8130(ctx, base);
	// 829B5A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B5A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B5A78: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 829B5A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B5A80: 409A0050  bne cr6, 0x829b5ad0
	if !ctx.cr[6].eq {
	pc = 0x829B5AD0; continue 'dispatch;
	}
	// 829B5A84: 484A3CDD  bl 0x82e59760
	ctx.lr = 0x829B5A88;
	sub_82E59760(ctx, base);
	// 829B5A88: 3FA0832E  lis r29, -0x7cd2
	ctx.r[29].s64 = -2094137344;
	// 829B5A8C: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 829B5A90: C01D9708  lfs f0, -0x68f8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-26872 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5A94: C1BECB50  lfs f13, -0x34b0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-13488 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5A98: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829B5A9C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829B5AA0: 41980030  blt cr6, 0x829b5ad0
	if ctx.cr[6].lt {
	pc = 0x829B5AD0; continue 'dispatch;
	}
	// 829B5AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5AA8: 484A3CB9  bl 0x82e59760
	ctx.lr = 0x829B5AAC;
	sub_82E59760(ctx, base);
	// 829B5AAC: C01D9708  lfs f0, -0x68f8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-26872 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5AB0: C1BECB50  lfs f13, -0x34b0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-13488 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B5AB8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829B5ABC: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B5AC0: 4846C469  bl 0x82e21f28
	ctx.lr = 0x829B5AC4;
	sub_82E21F28(ctx, base);
	// 829B5AC4: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 829B5AC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B5ACC: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 829B5AD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B5AD4: 487F26E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B5AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B5AD8 size=324
    let mut pc: u32 = 0x829B5AD8;
    'dispatch: loop {
        match pc {
            0x829B5AD8 => {
    //   block [0x829B5AD8..0x829B5C1C)
	// 829B5AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B5ADC: 487F268D  bl 0x831a8168
	ctx.lr = 0x829B5AE0;
	sub_831A8130(ctx, base);
	// 829B5AE0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829B5AE4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B5AE8: 54BD063E  clrlwi r29, r5, 0x18
	ctx.r[29].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B5AEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B5AF0: 397D0020  addi r11, r29, 0x20
	ctx.r[11].s64 = ctx.r[29].s64 + 32;
	// 829B5AF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B5AF8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B5AFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B5B00: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5B04: 7C0BFC2E  lfsx f0, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5B08: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B5B0C: 4098005C  bge cr6, 0x829b5b68
	if !ctx.cr[6].lt {
	pc = 0x829B5B68; continue 'dispatch;
	}
	// 829B5B10: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829B5B14: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B5B18: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829B5B1C: 397D0002  addi r11, r29, 2
	ctx.r[11].s64 = ctx.r[29].s64 + 2;
	// 829B5B20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B5B24: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B5B28: C1AACB50  lfs f13, -0x34b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13488 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5B2C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B5B30: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829B5B34: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5B38: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 829B5B3C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B5B40: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B5B44: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B5B48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B5B4C: 4E800421  bctrl
	ctx.lr = 0x829B5B50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B5B50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B5B54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B5B58: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B5B5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B5B60: 484C7AE1  bl 0x82e7d640
	ctx.lr = 0x829B5B64;
	sub_82E7D640(ctx, base);
	// 829B5B64: 480000A8  b 0x829b5c0c
	pc = 0x829B5C0C; continue 'dispatch;
	// 829B5B68: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B5B6C: 3B8B9710  addi r28, r11, -0x68f0
	ctx.r[28].s64 = ctx.r[11].s64 + -26864;
	// 829B5B70: C1BCFFF8  lfs f13, -8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5B74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B5B78: 4098003C  bge cr6, 0x829b5bb4
	if !ctx.cr[6].lt {
	pc = 0x829B5BB4; continue 'dispatch;
	}
	// 829B5B7C: ED806824  fdivs f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829B5B80: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829B5B84: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829B5B88: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5B8C: C1AA7BC4  lfs f13, 0x7bc4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5B90: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B5B94: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B5B98: 487F3311  bl 0x831a8ea8
	ctx.lr = 0x829B5B9C;
	sub_831A8EA8(ctx, base);
	// 829B5B9C: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B5BA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B5BA4: C1BCFFFC  lfs f13, -4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5BA8: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5BAC: EC0C0038  fmsubs f0, f12, f0, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B5BB0: 48000018  b 0x829b5bc8
	pc = 0x829B5BC8; continue 'dispatch;
	// 829B5BB4: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B5BB8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B5BBC: C01CFFFC  lfs f0, -4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5BC0: C1AB89AC  lfs f13, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5BC4: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B5BC8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B5BCC: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5BD0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B5BD4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B5BD8: 40990008  ble cr6, 0x829b5be0
	if !ctx.cr[6].gt {
	pc = 0x829B5BE0; continue 'dispatch;
	}
	// 829B5BDC: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B5BE0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829B5BE4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B5BE8: 393D0002  addi r9, r29, 2
	ctx.r[9].s64 = ctx.r[29].s64 + 2;
	// 829B5BEC: 394AA2F0  addi r10, r10, -0x5d10
	ctx.r[10].s64 = ctx.r[10].s64 + -23824;
	// 829B5BF0: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 829B5BF4: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B5C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B5C20 size=1044
    let mut pc: u32 = 0x829B5C20;
    'dispatch: loop {
        match pc {
            0x829B5C20 => {
    //   block [0x829B5C20..0x829B6034)
	// 829B5C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B5C24: 487F2549  bl 0x831a816c
	ctx.lr = 0x829B5C28;
	sub_831A8130(ctx, base);
	// 829B5C28: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 829B5C2C: 487F2E4D  bl 0x831a8a78
	ctx.lr = 0x829B5C30;
	sub_831A8A40(ctx, base);
	// 829B5C30: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B5C34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B5C38: 4879E9C9  bl 0x83154600
	ctx.lr = 0x829B5C3C;
	sub_83154600(ctx, base);
	// 829B5C3C: 897D0190  lbz r11, 0x190(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(400 as u32) ) } as u64;
	// 829B5C40: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B5C44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B5C48: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B5C4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B5C50: C3AA08A8  lfs f29, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829B5C54: 419803AC  blt cr6, 0x829b6000
	if ctx.cr[6].lt {
	pc = 0x829B6000; continue 'dispatch;
	}
	// 829B5C58: 409A03B0  bne cr6, 0x829b6008
	if !ctx.cr[6].eq {
	pc = 0x829B6008; continue 'dispatch;
	}
	// 829B5C5C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 829B5C60: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B5C64: 38A10170  addi r5, r1, 0x170
	ctx.r[5].s64 = ctx.r[1].s64 + 368;
	// 829B5C68: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 829B5C6C: 4B91A3ED  bl 0x822d0058
	ctx.lr = 0x829B5C70;
	sub_822D0058(ctx, base);
	// 829B5C70: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 829B5C74: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829B5C78: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B5C7C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829B5C80: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B5C84: C1810098  lfs f12, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B5C88: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 829B5C8C: C161009C  lfs f11, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B5C90: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B5C94: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B5C98: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B5C9C: 13FF50C7  vcmpequd (lvx128) v31, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B5CA0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B6038 size=248
    let mut pc: u32 = 0x829B6038;
    'dispatch: loop {
        match pc {
            0x829B6038 => {
    //   block [0x829B6038..0x829B6130)
	// 829B6038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B603C: 487F2125  bl 0x831a8160
	ctx.lr = 0x829B6040;
	sub_831A8130(ctx, base);
	// 829B6040: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B6048: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829B604C: 4BFECFE5  bl 0x829a3030
	ctx.lr = 0x829B6050;
	sub_829A3030(ctx, base);
	// 829B6050: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B6054: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 829B6058: 396A2670  addi r11, r10, 0x2670
	ctx.r[11].s64 = ctx.r[10].s64 + 9840;
	// 829B605C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B6060: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B6064: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 829B6068: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B606C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B6070: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829B6074: 419A0024  beq cr6, 0x829b6098
	if ctx.cr[6].eq {
	pc = 0x829B6098; continue 'dispatch;
	}
	// 829B6078: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B607C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B6080: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B6084: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B6088: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B608C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B6090: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B6094: 4082FFE8  bne 0x829b607c
	if !ctx.cr[0].eq {
	pc = 0x829B607C; continue 'dispatch;
	}
	// 829B6098: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B609C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829B60A0: 3B9F0020  addi r28, r31, 0x20
	ctx.r[28].s64 = ctx.r[31].s64 + 32;
	// 829B60A4: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 829B60A8: 3F408338  lis r26, -0x7cc8
	ctx.r[26].s64 = -2093481984;
	// 829B60AC: C00B9704  lfs f0, -0x68fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B60B0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B60B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B60B8: 4BB349D1  bl 0x824eaa88
	ctx.lr = 0x829B60BC;
	sub_824EAA88(ctx, base);
	// 829B60BC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B60C0: 4BB33791  bl 0x824e9850
	ctx.lr = 0x829B60C4;
	sub_824E9850(ctx, base);
	// 829B60C4: C01ACB50  lfs f0, -0x34b0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-13488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B60C8: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B60CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B60D0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B60D4: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B60D8: 4843BBB9  bl 0x82df1c90
	ctx.lr = 0x829B60DC;
	sub_82DF1C90(ctx, base);
	// 829B60DC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B60E0: 57C5063E  clrlwi r5, r30, 0x18
	ctx.r[5].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 829B60E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B60E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B60EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B60F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B60F4: 4E800421  bctrl
	ctx.lr = 0x829B60F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B60F8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 829B60FC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6100: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B6130 size=52
    let mut pc: u32 = 0x829B6130;
    'dispatch: loop {
        match pc {
            0x829B6130 => {
    //   block [0x829B6130..0x829B6164)
	// 829B6130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B6134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B6138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B613C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B6144: 4BFFF925  bl 0x829b5a68
	ctx.lr = 0x829B6148;
	sub_829B5A68(ctx, base);
	// 829B6148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B614C: 4BFFFAD5  bl 0x829b5c20
	ctx.lr = 0x829B6150;
	sub_829B5C20(ctx, base);
	// 829B6150: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B6154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B6158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B615C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B6160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B6168 size=184
    let mut pc: u32 = 0x829B6168;
    'dispatch: loop {
        match pc {
            0x829B6168 => {
    //   block [0x829B6168..0x829B6220)
	// 829B6168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B616C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B6170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B6174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B6178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B617C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B6180: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B6184: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B6188: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B618C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B6190: 4B90A7A9  bl 0x822c0938
	ctx.lr = 0x829B6194;
	sub_822C0938(ctx, base);
	// 829B6194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B6198: 41820028  beq 0x829b61c0
	if ctx.cr[0].eq {
	pc = 0x829B61C0; continue 'dispatch;
	}
	// 829B619C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B61A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B61A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B61A8: 392B265C  addi r9, r11, 0x265c
	ctx.r[9].s64 = ctx.r[11].s64 + 9820;
	// 829B61AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B61B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B61B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B61B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B61BC: 48000008  b 0x829b61c4
	pc = 0x829B61C4; continue 'dispatch;
	// 829B61C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B61C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B61C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B61CC: 409A0038  bne cr6, 0x829b6204
	if !ctx.cr[6].eq {
	pc = 0x829B6204; continue 'dispatch;
	}
	// 829B61D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B61D4: 419A0010  beq cr6, 0x829b61e4
	if ctx.cr[6].eq {
	pc = 0x829B61E4; continue 'dispatch;
	}
	// 829B61D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B61DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B61E0: 4BE26B69  bl 0x827dcd48
	ctx.lr = 0x829B61E4;
	sub_827DCD48(ctx, base);
	// 829B61E4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B61E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B61EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B61F0: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B61F4: 816B9724  lwz r11, -0x68dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26844 as u32) ) } as u64;
	// 829B61F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B61FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B6200: 4B909E01  bl 0x822c0000
	ctx.lr = 0x829B6204;
	sub_822C0000(ctx, base);
	// 829B6204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B6208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B620C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B6210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B6214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B6218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B621C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B6220 size=12
    let mut pc: u32 = 0x829B6220;
    'dispatch: loop {
        match pc {
            0x829B6220 => {
    //   block [0x829B6220..0x829B622C)
	// 829B6220: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 829B6224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B6228: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B622C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B622C size=8
    let mut pc: u32 = 0x829B622C;
    'dispatch: loop {
        match pc {
            0x829B622C => {
    //   block [0x829B622C..0x829B6234)
	// 829B622C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B6230: 4BE26B18  b 0x827dcd48
	sub_827DCD48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6234(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B6234 size=4
    let mut pc: u32 = 0x829B6234;
    'dispatch: loop {
        match pc {
            0x829B6234 => {
    //   block [0x829B6234..0x829B6238)
	// 829B6234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B6238 size=416
    let mut pc: u32 = 0x829B6238;
    'dispatch: loop {
        match pc {
            0x829B6238 => {
    //   block [0x829B6238..0x829B63D8)
	// 829B6238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B623C: 487F1F31  bl 0x831a816c
	ctx.lr = 0x829B6240;
	sub_831A8130(ctx, base);
	// 829B6240: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6244: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B6248: 4879E3B9  bl 0x83154600
	ctx.lr = 0x829B624C;
	sub_83154600(ctx, base);
	// 829B624C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B6250: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B6254: 4BFFD6A5  bl 0x829b38f8
	ctx.lr = 0x829B6258;
	sub_829B38F8(ctx, base);
	// 829B6258: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B625C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B6260: 388B2688  addi r4, r11, 0x2688
	ctx.r[4].s64 = ctx.r[11].s64 + 9864;
	// 829B6264: 38A0012B  li r5, 0x12b
	ctx.r[5].s64 = 299;
	// 829B6268: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 829B626C: 4B90A16D  bl 0x822c03d8
	ctx.lr = 0x829B6270;
	sub_822C03D8(ctx, base);
	// 829B6270: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B6274: 4182004C  beq 0x829b62c0
	if ctx.cr[0].eq {
	pc = 0x829B62C0; continue 'dispatch;
	}
	// 829B6278: 817F0220  lwz r11, 0x220(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 829B627C: 815F021C  lwz r10, 0x21c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 829B6280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B6284: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B6288: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B628C: 419A0024  beq cr6, 0x829b62b0
	if ctx.cr[6].eq {
	pc = 0x829B62B0; continue 'dispatch;
	}
	// 829B6290: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B6294: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B6298: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B629C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B62A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B62A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B62A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B62AC: 4082FFE8  bne 0x829b6294
	if !ctx.cr[0].eq {
	pc = 0x829B6294; continue 'dispatch;
	}
	// 829B62B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B62B4: 4BFFFD85  bl 0x829b6038
	ctx.lr = 0x829B62B8;
	sub_829B6038(ctx, base);
	// 829B62B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B62BC: 48000008  b 0x829b62c4
	pc = 0x829B62C4; continue 'dispatch;
	// 829B62C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829B62C4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829B62C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B62CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B62D0: 4BFFFE99  bl 0x829b6168
	ctx.lr = 0x829B62D4;
	sub_829B6168(ctx, base);
	// 829B62D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B62D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B62DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B62E0: 4B909D21  bl 0x822c0000
	ctx.lr = 0x829B62E4;
	sub_822C0000(ctx, base);
	// 829B62E4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B62E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B62EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829B62F0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 829B62F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829B62F8: 419A0024  beq cr6, 0x829b631c
	if ctx.cr[6].eq {
	pc = 0x829B631C; continue 'dispatch;
	}
	// 829B62FC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829B6300: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B6304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B6308: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B630C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B6310: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B6314: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B6318: 4082FFE8  bne 0x829b6300
	if !ctx.cr[0].eq {
	pc = 0x829B6300; continue 'dispatch;
	}
	// 829B631C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829B6320: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829B6324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B6328: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B632C: 4BFEED35  bl 0x829a5060
	ctx.lr = 0x829B6330;
	sub_829A5060(ctx, base);
	// 829B6330: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829B6334: 419A000C  beq cr6, 0x829b6340
	if ctx.cr[6].eq {
	pc = 0x829B6340; continue 'dispatch;
	}
	// 829B6338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B633C: 4B90A555  bl 0x822c0890
	ctx.lr = 0x829B6340;
	sub_822C0890(ctx, base);
	// 829B6340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B6344: 4BFF2EF5  bl 0x829a9238
	ctx.lr = 0x829B6348;
	sub_829A9238(ctx, base);
	// 829B6348: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B634C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B6350: 4BFEEB89  bl 0x829a4ed8
	ctx.lr = 0x829B6354;
	sub_829A4ED8(ctx, base);
	// 829B6354: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 829B6358: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 829B635C: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B6360: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829B6364: 4B919CF5  bl 0x822d0058
	ctx.lr = 0x829B6368;
	sub_822D0058(ctx, base);
	// 829B6368: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 829B636C: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829B6370: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B6374: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 829B6378: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B637C: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B6380: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B6384: C161006C  lfs f11, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B6388: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B638C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6390: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B6394: 13FF50C7  vcmpequd (lvx128) v31, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6398: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B63D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B63D8 size=72
    let mut pc: u32 = 0x829B63D8;
    'dispatch: loop {
        match pc {
            0x829B63D8 => {
    //   block [0x829B63D8..0x829B6420)
	// 829B63D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B63DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B63E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B63E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B63E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B63EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B63F0: 4879E211  bl 0x83154600
	ctx.lr = 0x829B63F4;
	sub_83154600(ctx, base);
	// 829B63F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B63F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B63FC: 48007EBD  bl 0x829be2b8
	ctx.lr = 0x829B6400;
	sub_829BE2B8(ctx, base);
	// 829B6400: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B6404: 4BFF3165  bl 0x829a9568
	ctx.lr = 0x829B6408;
	sub_829A9568(ctx, base);
	// 829B6408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B640C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B6410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B6414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B6418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B641C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B6420 size=964
    let mut pc: u32 = 0x829B6420;
    'dispatch: loop {
        match pc {
            0x829B6420 => {
    //   block [0x829B6420..0x829B67E4)
	// 829B6420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B6424: 487F1D45  bl 0x831a8168
	ctx.lr = 0x829B6428;
	sub_831A8130(ctx, base);
	// 829B6428: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 829B642C: 487F264D  bl 0x831a8a78
	ctx.lr = 0x829B6430;
	sub_831A8A40(ctx, base);
	// 829B6430: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6434: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B6438: 4879E1C9  bl 0x83154600
	ctx.lr = 0x829B643C;
	sub_83154600(ctx, base);
	// 829B643C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B6440: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 829B6444: 38A10160  addi r5, r1, 0x160
	ctx.r[5].s64 = ctx.r[1].s64 + 352;
	// 829B6448: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 829B644C: 807F03F0  lwz r3, 0x3f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B6450: 4B919C09  bl 0x822d0058
	ctx.lr = 0x829B6454;
	sub_822D0058(ctx, base);
	// 829B6454: 39410120  addi r10, r1, 0x120
	ctx.r[10].s64 = ctx.r[1].s64 + 288;
	// 829B6458: C1A10090  lfs f13, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B645C: 392003E0  li r9, 0x3e0
	ctx.r[9].s64 = 992;
	// 829B6460: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B6464: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 829B6468: C1610098  lfs f11, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B646C: C141009C  lfs f10, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829B6470: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829B6474: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B6478: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B647C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6480: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B6484: 13FF48C7  vcmpequd (lvx128) v31, v31, v9
	tmp.u32 = ctx.r[31].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6488: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B67E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B67E8 size=1076
    let mut pc: u32 = 0x829B67E8;
    'dispatch: loop {
        match pc {
            0x829B67E8 => {
    //   block [0x829B67E8..0x829B6C1C)
	// 829B67E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B67EC: 487F1979  bl 0x831a8164
	ctx.lr = 0x829B67F0;
	sub_831A8130(ctx, base);
	// 829B67F0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 829B67F4: 487F227D  bl 0x831a8a70
	ctx.lr = 0x829B67F8;
	sub_831A8A40(ctx, base);
	// 829B67F8: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 829B67FC: 487F4411  bl 0x831aac0c
	ctx.lr = 0x829B6800;
	sub_831AA9A0(ctx, base);
	// 829B6800: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B6808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B680C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829B6810: 4BAC16F1  bl 0x82477f00
	ctx.lr = 0x829B6814;
	sub_82477F00(ctx, base);
	// 829B6814: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B6818: 807F03F8  lwz r3, 0x3f8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 829B681C: 3BCB0040  addi r30, r11, 0x40
	ctx.r[30].s64 = ctx.r[11].s64 + 64;
	// 829B6820: 3BAB0030  addi r29, r11, 0x30
	ctx.r[29].s64 = ctx.r[11].s64 + 48;
	// 829B6824: 3B8B0020  addi r28, r11, 0x20
	ctx.r[28].s64 = ctx.r[11].s64 + 32;
	// 829B6828: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829B682C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829B6830: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829B6834: 4B919825  bl 0x822d0058
	ctx.lr = 0x829B6838;
	sub_822D0058(ctx, base);
	// 829B6838: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 829B683C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 829B6840: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6844: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 829B6848: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 829B684C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B6C20 size=16
    let mut pc: u32 = 0x829B6C20;
    'dispatch: loop {
        match pc {
            0x829B6C20 => {
    //   block [0x829B6C20..0x829B6C30)
	// 829B6C20: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 829B6C24: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 829B6C28: 886B0080  lbz r3, 0x80(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 829B6C2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B6C30 size=332
    let mut pc: u32 = 0x829B6C30;
    'dispatch: loop {
        match pc {
            0x829B6C30 => {
    //   block [0x829B6C30..0x829B6D7C)
	// 829B6C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B6C34: 487F151D  bl 0x831a8150
	ctx.lr = 0x829B6C38;
	sub_831A8130(ctx, base);
	// 829B6C38: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B6C40: 4BFEC3F1  bl 0x829a3030
	ctx.lr = 0x829B6C44;
	sub_829A3030(ctx, base);
	// 829B6C44: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 829B6C48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B6C4C: 38E897DC  addi r7, r8, -0x6824
	ctx.r[7].s64 = ctx.r[8].s64 + -26660;
	// 829B6C50: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829B6C54: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829B6C58: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829B6C5C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B6C60: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829B6C64: 3BC100A0  addi r30, r1, 0xa0
	ctx.r[30].s64 = ctx.r[1].s64 + 160;
	// 829B6C68: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829B6C6C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 829B6C70: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829B6C74: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829B6C78: 3F808203  lis r28, -0x7dfd
	ctx.r[28].s64 = -2113732608;
	// 829B6C7C: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829B6C80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B6C84: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829B6C88: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 829B6C8C: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 829B6C90: 3B400030  li r26, 0x30
	ctx.r[26].s64 = 48;
	// 829B6C94: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829B6C98: 396B26DC  addi r11, r11, 0x26dc
	ctx.r[11].s64 = ctx.r[11].s64 + 9948;
	// 829B6C9C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829B6CA0: 3B200040  li r25, 0x40
	ctx.r[25].s64 = 64;
	// 829B6CA4: C1870008  lfs f12, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B6CA8: 3B000050  li r24, 0x50
	ctx.r[24].s64 = 80;
	// 829B6CAC: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829B6CB0: 3AE00060  li r23, 0x60
	ctx.r[23].s64 = 96;
	// 829B6CB4: C1A7001C  lfs f13, 0x1c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B6CB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B6CBC: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829B6CC0: FD206850  fneg f9, f13
	ctx.f[9].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B6CC4: C0070014  lfs f0, 0x14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B6CC8: 3AC00070  li r22, 0x70
	ctx.r[22].s64 = 112;
	// 829B6CCC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829B6CD0: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 829B6CD4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829B6CD8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829B6CDC: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829B6CE0: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829B6CE4: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829B6CE8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829B6CEC: C0070004  lfs f0, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B6CF0: C1870018  lfs f12, 0x18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B6CF4: C15C7BC4  lfs f10, 0x7bc4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(31684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829B6CF8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B6CFC: ED8C02BA  fmadds f12, f12, f10, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 829B6D00: C1A70010  lfs f13, 0x10(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B6D04: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829B6D08: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829B6D0C: C167000C  lfs f11, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B6D10: D1210070  stfs f9, 0x70(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829B6D14: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6D18: D1610084  stfs f11, 0x84(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829B6D1C: D1210090  stfs f9, 0x90(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829B6D20: D1610094  stfs f11, 0x94(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829B6D24: C18897DC  lfs f12, -0x6824(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-26660 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B6D28: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829B6D2C: 13C030C7  vcmpequd (lvx128) v30, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6D30: 13A028C7  vcmpequd (lvx128) v29, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6D34: D1A100A8  stfs f13, 0xa8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 829B6D38: 138020C7  vcmpequd (lvx128) v28, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6D3C: 136018C7  vcmpequd (lvx128) v27, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[59] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B6D40: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B6D44: 1340F0C7  vcmpequd (lvx128) v26, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[58] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B6D80 size=24
    let mut pc: u32 = 0x829B6D80;
    'dispatch: loop {
        match pc {
            0x829B6D80 => {
    //   block [0x829B6D80..0x829B6D98)
	// 829B6D80: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B6D84: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 829B6D88: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B6D8C: 13EB20C7  vcmpequd (lvx128) v31, v11, v4
	tmp.u32 = ctx.r[11].u32 + ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B6D98 size=308
    let mut pc: u32 = 0x829B6D98;
    'dispatch: loop {
        match pc {
            0x829B6D98 => {
    //   block [0x829B6D98..0x829B6ECC)
	// 829B6D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B6D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B6DA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B6DA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6DA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B6DAC: 4879D855  bl 0x83154600
	ctx.lr = 0x829B6DB0;
	sub_83154600(ctx, base);
	// 829B6DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B6DB4: 484A29C5  bl 0x82e59778
	ctx.lr = 0x829B6DB8;
	sub_82E59778(ctx, base);
	// 829B6DB8: 897F0168  lbz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829B6DBC: C01F0178  lfs f0, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B6DC0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829B6DC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B6DC8: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B6DCC: D1BF0178  stfs f13, 0x178(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829B6DD0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829B6DD4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829B6DD8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829B6DDC: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 829B6DE0: C00A9800  lfs f0, -0x6800(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B6DE4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829B6DE8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B6DEC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 829B6DF0: 419800C8  blt cr6, 0x829b6eb8
	if ctx.cr[6].lt {
	pc = 0x829B6EB8; continue 'dispatch;
	}
	// 829B6DF4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829B6DF8: 897F0168  lbz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829B6DFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B6E00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B6E04: 997F0168  stb r11, 0x168(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u8 ) };
	// 829B6E08: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829B6E0C: 419A005C  beq cr6, 0x829b6e68
	if ctx.cr[6].eq {
	pc = 0x829B6E68; continue 'dispatch;
	}
	// 829B6E10: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829B6E14: 409A0078  bne cr6, 0x829b6e8c
	if !ctx.cr[6].eq {
	pc = 0x829B6E8C; continue 'dispatch;
	}
	// 829B6E18: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 829B6E1C: 813F0160  lwz r9, 0x160(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829B6E20: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B6E24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B6E28: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 829B6E2C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 829B6E30: 990A0080  stb r8, 0x80(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[8].u8 ) };
	// 829B6E34: 4198FFE8  blt cr6, 0x829b6e1c
	if ctx.cr[6].lt {
	pc = 0x829B6E1C; continue 'dispatch;
	}
	// 829B6E38: 897F0168  lbz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829B6E3C: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B6E40: 991F0168  stb r8, 0x168(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[8].u8 ) };
	// 829B6E44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B6E48: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829B6E4C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829B6E50: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829B6E54: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 829B6E58: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829B6E5C: EDAC683C  fnmsubs f13, f12, f0, f13
	ctx.f[13].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B6E60: D1BF0178  stfs f13, 0x178(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829B6E64: 48000028  b 0x829b6e8c
	pc = 0x829B6E8C; continue 'dispatch;
	// 829B6E68: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 829B6E6C: 813F0160  lwz r9, 0x160(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829B6E70: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B6E74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829B6E78: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 829B6E7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B6E80: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 829B6E84: 98EA0080  stb r7, 0x80(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[7].u8 ) };
	// 829B6E88: 4198FFE4  blt cr6, 0x829b6e6c
	if ctx.cr[6].lt {
	pc = 0x829B6E6C; continue 'dispatch;
	}
	// 829B6E8C: 897F0168  lbz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829B6E90: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B6E94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B6E98: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829B6E9C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829B6EA0: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829B6EA4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 829B6EA8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829B6EAC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B6EB0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 829B6EB4: 4098FF44  bge cr6, 0x829b6df8
	if !ctx.cr[6].lt {
	pc = 0x829B6DF8; continue 'dispatch;
	}
	// 829B6EB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B6EBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B6EC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B6EC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B6EC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B6ED0 size=172
    let mut pc: u32 = 0x829B6ED0;
    'dispatch: loop {
        match pc {
            0x829B6ED0 => {
    //   block [0x829B6ED0..0x829B6F7C)
	// 829B6ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B6ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B6ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B6EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B6EE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B6EE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B6EE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B6EEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B6EF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B6EF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B6EF8: 4B909A41  bl 0x822c0938
	ctx.lr = 0x829B6EFC;
	sub_822C0938(ctx, base);
	// 829B6EFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B6F00: 41820028  beq 0x829b6f28
	if ctx.cr[0].eq {
	pc = 0x829B6F28; continue 'dispatch;
	}
	// 829B6F04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B6F08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B6F0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B6F10: 392B26F4  addi r9, r11, 0x26f4
	ctx.r[9].s64 = ctx.r[11].s64 + 9972;
	// 829B6F14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B6F18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B6F1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B6F20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B6F24: 48000008  b 0x829b6f2c
	pc = 0x829B6F2C; continue 'dispatch;
	// 829B6F28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B6F2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B6F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B6F34: 409A002C  bne cr6, 0x829b6f60
	if !ctx.cr[6].eq {
	pc = 0x829B6F60; continue 'dispatch;
	}
	// 829B6F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B6F3C: 4B90932D  bl 0x822c0268
	ctx.lr = 0x829B6F40;
	sub_822C0268(ctx, base);
	// 829B6F40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B6F44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B6F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B6F4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B6F50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B6F54: 816B9820  lwz r11, -0x67e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26592 as u32) ) } as u64;
	// 829B6F58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B6F5C: 4B9090A5  bl 0x822c0000
	ctx.lr = 0x829B6F60;
	sub_822C0000(ctx, base);
	// 829B6F60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B6F64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B6F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B6F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B6F70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B6F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B6F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B6F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B6F80 size=532
    let mut pc: u32 = 0x829B6F80;
    'dispatch: loop {
        match pc {
            0x829B6F80 => {
    //   block [0x829B6F80..0x829B7194)
	// 829B6F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B6F84: 487F11E9  bl 0x831a816c
	ctx.lr = 0x829B6F88;
	sub_831A8130(ctx, base);
	// 829B6F88: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829B6F8C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829B6F90: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B7198 size=340
    let mut pc: u32 = 0x829B7198;
    'dispatch: loop {
        match pc {
            0x829B7198 => {
    //   block [0x829B7198..0x829B72EC)
	// 829B7198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B719C: 487F0FCD  bl 0x831a8168
	ctx.lr = 0x829B71A0;
	sub_831A8130(ctx, base);
	// 829B71A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B71A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B71A8: 4879D459  bl 0x83154600
	ctx.lr = 0x829B71AC;
	sub_83154600(ctx, base);
	// 829B71AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829B71B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B71B4: 4BFFF225  bl 0x829b63d8
	ctx.lr = 0x829B71B8;
	sub_829B63D8(ctx, base);
	// 829B71B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B71BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B71C0: 388B2708  addi r4, r11, 0x2708
	ctx.r[4].s64 = ctx.r[11].s64 + 9992;
	// 829B71C4: 38A000C5  li r5, 0xc5
	ctx.r[5].s64 = 197;
	// 829B71C8: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 829B71CC: 4B90920D  bl 0x822c03d8
	ctx.lr = 0x829B71D0;
	sub_822C03D8(ctx, base);
	// 829B71D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829B71D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B71D8: 41820010  beq 0x829b71e8
	if ctx.cr[0].eq {
	pc = 0x829B71E8; continue 'dispatch;
	}
	// 829B71DC: 4BFFFA55  bl 0x829b6c30
	ctx.lr = 0x829B71E0;
	sub_829B6C30(ctx, base);
	// 829B71E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B71E4: 48000008  b 0x829b71ec
	pc = 0x829B71EC; continue 'dispatch;
	// 829B71E8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 829B71EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829B71F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B71F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B71F8: 4BFFFCD9  bl 0x829b6ed0
	ctx.lr = 0x829B71FC;
	sub_829B6ED0(ctx, base);
	// 829B71FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B7200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B7204: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B7208: 4B908DF9  bl 0x822c0000
	ctx.lr = 0x829B720C;
	sub_822C0000(ctx, base);
	// 829B720C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B7210: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 829B7214: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829B7218: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829B721C: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829B7220: 4B90D241  bl 0x822c4460
	ctx.lr = 0x829B7224;
	sub_822C4460(ctx, base);
	// 829B7224: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B7228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B722C: 419A0008  beq cr6, 0x829b7234
	if ctx.cr[6].eq {
	pc = 0x829B7234; continue 'dispatch;
	}
	// 829B7230: 4B909661  bl 0x822c0890
	ctx.lr = 0x829B7234;
	sub_822C0890(ctx, base);
	// 829B7234: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B7238: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B723C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B7240: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B7244: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B7248: 419A0024  beq cr6, 0x829b726c
	if ctx.cr[6].eq {
	pc = 0x829B726C; continue 'dispatch;
	}
	// 829B724C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B7250: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B7254: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B7258: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B725C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B7260: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B7264: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B7268: 4082FFE8  bne 0x829b7250
	if !ctx.cr[0].eq {
	pc = 0x829B7250; continue 'dispatch;
	}
	// 829B726C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B7270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B7274: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829B7278: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B727C: 4BFEDDE5  bl 0x829a5060
	ctx.lr = 0x829B7280;
	sub_829A5060(ctx, base);
	// 829B7280: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829B7284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B7288: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829B728C: 4843C77D  bl 0x82df3a08
	ctx.lr = 0x829B7290;
	sub_82DF3A08(ctx, base);
	// 829B7290: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B7294: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829B7298: 809C0170  lwz r4, 0x170(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(368 as u32) ) } as u64;
	// 829B729C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829B72A0: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829B72A4: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829B72A8: 481FC0D1  bl 0x82bb3378
	ctx.lr = 0x829B72AC;
	sub_82BB3378(ctx, base);
	// 829B72AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829B72B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B72B4: 419A0008  beq cr6, 0x829b72bc
	if ctx.cr[6].eq {
	pc = 0x829B72BC; continue 'dispatch;
	}
	// 829B72B8: 4B9095D9  bl 0x822c0890
	ctx.lr = 0x829B72BC;
	sub_822C0890(ctx, base);
	// 829B72BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B72C0: 4843C169  bl 0x82df3428
	ctx.lr = 0x829B72C4;
	sub_82DF3428(ctx, base);
	// 829B72C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B72C8: 9BBF0168  stb r29, 0x168(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[29].u8 ) };
	// 829B72CC: 397F016C  addi r11, r31, 0x16c
	ctx.r[11].s64 = ctx.r[31].s64 + 364;
	// 829B72D0: 93BF016C  stw r29, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[29].u32 ) };
	// 829B72D4: 93BF0170  stw r29, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[29].u32 ) };
	// 829B72D8: 93BF0174  stw r29, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[29].u32 ) };
	// 829B72DC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B72E0: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 829B72E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829B72E8: 487F0ED0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B72F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B72F0 size=60
    let mut pc: u32 = 0x829B72F0;
    'dispatch: loop {
        match pc {
            0x829B72F0 => {
    //   block [0x829B72F0..0x829B732C)
	// 829B72F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B72F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B72F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B72FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B7300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B7304: 4BFFFA95  bl 0x829b6d98
	ctx.lr = 0x829B7308;
	sub_829B6D98(ctx, base);
	// 829B7308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B730C: 4BFFFC75  bl 0x829b6f80
	ctx.lr = 0x829B7310;
	sub_829B6F80(ctx, base);
	// 829B7310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B7314: 4879D2ED  bl 0x83154600
	ctx.lr = 0x829B7318;
	sub_83154600(ctx, base);
	// 829B7318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B731C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B7320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B7324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B7328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B7330 size=112
    let mut pc: u32 = 0x829B7330;
    'dispatch: loop {
        match pc {
            0x829B7330 => {
    //   block [0x829B7330..0x829B73A0)
	// 829B7330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B7334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B7338: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B733C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B7340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B7344: 4BFEBCED  bl 0x829a3030
	ctx.lr = 0x829B7348;
	sub_829A3030(ctx, base);
	// 829B7348: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829B734C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829B7350: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 829B7354: 3929275C  addi r9, r9, 0x275c
	ctx.r[9].s64 = ctx.r[9].s64 + 10076;
	// 829B7358: C00A98B0  lfs f0, -0x6750(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B735C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B7360: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7364: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829B7368: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829B736C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829B7370: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B7374: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B7378: 4200FFF8  bdnz 0x829b7370
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829B7370; continue 'dispatch;
	}
	// 829B737C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B7380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B7384: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7388: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829B738C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B7390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B7394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B7398: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B739C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B73A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B73A0 size=48
    let mut pc: u32 = 0x829B73A0;
    'dispatch: loop {
        match pc {
            0x829B73A0 => {
    //   block [0x829B73A0..0x829B73D0)
	// 829B73A0: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 829B73A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B73A8: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 829B73AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B73B0: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B73B4: 7DAB1C2E  lfsx f13, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B73B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B73BC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B73C0: 41990008  bgt cr6, 0x829b73c8
	if ctx.cr[6].gt {
	pc = 0x829B73C8; continue 'dispatch;
	}
	// 829B73C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B73C8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B73CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B73D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B73D0 size=384
    let mut pc: u32 = 0x829B73D0;
    'dispatch: loop {
        match pc {
            0x829B73D0 => {
    //   block [0x829B73D0..0x829B7550)
	// 829B73D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B73D4: 487F0D8D  bl 0x831a8160
	ctx.lr = 0x829B73D8;
	sub_831A8130(ctx, base);
	// 829B73D8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829B73DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B73E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B73E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829B73E8: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 829B73EC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829B73F0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 829B73F4: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B73F8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B73FC: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7400: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B7404: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B7408: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829B740C: 40980008  bge cr6, 0x829b7414
	if !ctx.cr[6].lt {
	pc = 0x829B7414; continue 'dispatch;
	}
	// 829B7410: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B7414: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829B7418: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B741C: 4082FFDC  bne 0x829b73f8
	if !ctx.cr[0].eq {
	pc = 0x829B73F8; continue 'dispatch;
	}
	// 829B7420: C01D002C  lfs f0, 0x2c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7424: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7428: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B742C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829B7430: 3B6B98D4  addi r27, r11, -0x672c
	ctx.r[27].s64 = ctx.r[11].s64 + -26412;
	// 829B7434: D01D002C  stfs f0, 0x2c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829B7438: C1BBFFFC  lfs f13, -4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B743C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B7440: 41980104  blt cr6, 0x829b7544
	if ctx.cr[6].lt {
	pc = 0x829B7544; continue 'dispatch;
	}
	// 829B7444: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B7448: D01D002C  stfs f0, 0x2c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829B744C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B7450: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 829B7454: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 829B7458: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B745C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829B7460: 40990010  ble cr6, 0x829b7470
	if !ctx.cr[6].gt {
	pc = 0x829B7470; continue 'dispatch;
	}
	// 829B7464: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B7468: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B746C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B7470: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829B7474: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 829B7478: 4082FFE0  bne 0x829b7458
	if !ctx.cr[0].eq {
	pc = 0x829B7458; continue 'dispatch;
	}
	// 829B747C: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B7480: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 829B7484: 2B1F0006  cmplwi cr6, r31, 6
	ctx.cr[6].compare_u32(ctx.r[31].u32, 6 as u32, &mut ctx.xer);
	// 829B7488: 409800A0  bge cr6, 0x829b7528
	if !ctx.cr[6].lt {
	pc = 0x829B7528; continue 'dispatch;
	}
	// 829B748C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B7490: 4BB335F9  bl 0x824eaa88
	ctx.lr = 0x829B7494;
	sub_824EAA88(ctx, base);
	// 829B7494: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B7498: 4BB323B9  bl 0x824e9850
	ctx.lr = 0x829B749C;
	sub_824E9850(ctx, base);
	// 829B749C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B74A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B74A4: C00BA2EC  lfs f0, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B74A8: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B74AC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829B74B0: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 829B74B4: 8B41005F  lbz r26, 0x5f(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 829B74B8: 4843A7D9  bl 0x82df1c90
	ctx.lr = 0x829B74BC;
	sub_82DF1C90(ctx, base);
	// 829B74BC: 213F0006  subfic r9, r31, 6
	ctx.xer.ca = ctx.r[31].u32 <= 6 as u32;
	ctx.r[9].s64 = (6 as i64) - ctx.r[31].s64;
	// 829B74C0: 7F4A0774  extsb r10, r26
	ctx.r[10].s64 = ctx.r[26].s8 as i64;
	// 829B74C4: 0CC90000  twi 6, r9, 0
	// 829B74C8: 7D0A4BD6  divw r8, r10, r9
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 829B74CC: 554B083E  rotlwi r11, r10, 1
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 829B74D0: 7D0849D6  mullw r8, r8, r9
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[9].s32 as i64);
	// 829B74D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829B74D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829B74DC: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 829B74E0: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 829B74E4: 0CABFFFF  twi 5, r11, -1
	// 829B74E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B74EC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 829B74F0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B74F4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829B74F8: 41990014  bgt cr6, 0x829b750c
	if ctx.cr[6].gt {
	pc = 0x829B750C; continue 'dispatch;
	}
	// 829B74FC: 7D290775  extsb. r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829B7500: 41820020  beq 0x829b7520
	if ctx.cr[0].eq {
	pc = 0x829B7520; continue 'dispatch;
	}
	// 829B7504: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 829B7508: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 829B750C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B7510: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 829B7514: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 829B7518: 4198FFD8  blt cr6, 0x829b74f0
	if ctx.cr[6].lt {
	pc = 0x829B74F0; continue 'dispatch;
	}
	// 829B751C: 48000010  b 0x829b752c
	pc = 0x829B752C; continue 'dispatch;
	// 829B7520: 7D7C0774  extsb r28, r11
	ctx.r[28].s64 = ctx.r[11].s8 as i64;
	// 829B7524: 48000008  b 0x829b752c
	pc = 0x829B752C; continue 'dispatch;
	// 829B7528: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 829B752C: 7F8B0775  extsb. r11, r28
	ctx.r[11].s64 = ctx.r[28].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B7530: 41800014  blt 0x829b7544
	if ctx.cr[0].lt {
	pc = 0x829B7544; continue 'dispatch;
	}
	// 829B7534: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 829B7538: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B753C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829B7540: 7C0BED2E  stfsx f0, r11, r29
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 829B7544: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829B7548: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829B754C: 487F0C64  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7550 size=64
    let mut pc: u32 = 0x829B7550;
    'dispatch: loop {
        match pc {
            0x829B7550 => {
    //   block [0x829B7550..0x829B7590)
	// 829B7550: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B7554: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B7558: 419800DC  blt cr6, 0x829b7634
	if ctx.cr[6].lt {
		sub_829B7634(ctx, base);
		return;
	}
	// 829B755C: 419A00A4  beq cr6, 0x829b7600
	if ctx.cr[6].eq {
		sub_829B7600(ctx, base);
		return;
	}
	// 829B7560: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B7564: 41980084  blt cr6, 0x829b75e8
	if ctx.cr[6].lt {
		sub_829B75E8(ctx, base);
		return;
	}
	// 829B7568: 419A0068  beq cr6, 0x829b75d0
	if ctx.cr[6].eq {
		sub_829B75D0(ctx, base);
		return;
	}
	// 829B756C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B7570: 41980044  blt cr6, 0x829b75b4
	if ctx.cr[6].lt {
		sub_829B75B4(ctx, base);
		return;
	}
	// 829B7574: 419A001C  beq cr6, 0x829b7590
	if ctx.cr[6].eq {
		sub_829B7590(ctx, base);
		return;
	}
	// 829B7578: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B757C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7580: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B7584: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B7588: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B758C: 480000D0  b 0x829b765c
	sub_829B7634(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7590 size=36
    let mut pc: u32 = 0x829B7590;
    'dispatch: loop {
        match pc {
            0x829B7590 => {
    //   block [0x829B7590..0x829B75B4)
	// 829B7590: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7594: 392B98C4  addi r9, r11, -0x673c
	ctx.r[9].s64 = ctx.r[11].s64 + -26428;
	// 829B7598: C00B98C4  lfs f0, -0x673c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B759C: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B75A0: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B75A4: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B75A8: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B75AC: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B75B0: 48000070  b 0x829b7620
	sub_829B7600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B75B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B75B4 size=28
    let mut pc: u32 = 0x829B75B4;
    'dispatch: loop {
        match pc {
            0x829B75B4 => {
    //   block [0x829B75B4..0x829B75D0)
	// 829B75B4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B75B8: 396B98C4  addi r11, r11, -0x673c
	ctx.r[11].s64 = ctx.r[11].s64 + -26428;
	// 829B75BC: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B75C0: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B75C4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B75C8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B75CC: 4800004C  b 0x829b7618
	sub_829B7600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B75D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B75D0 size=24
    let mut pc: u32 = 0x829B75D0;
    'dispatch: loop {
        match pc {
            0x829B75D0 => {
    //   block [0x829B75D0..0x829B75E8)
	// 829B75D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B75D4: 392B98C4  addi r9, r11, -0x673c
	ctx.r[9].s64 = ctx.r[11].s64 + -26428;
	// 829B75D8: C00B98C4  lfs f0, -0x673c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B75DC: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B75E0: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B75E4: 48000064  b 0x829b7648
	sub_829B7634(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B75E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B75E8 size=24
    let mut pc: u32 = 0x829B75E8;
    'dispatch: loop {
        match pc {
            0x829B75E8 => {
    //   block [0x829B75E8..0x829B7600)
	// 829B75E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B75EC: 396B98C4  addi r11, r11, -0x673c
	ctx.r[11].s64 = ctx.r[11].s64 + -26428;
	// 829B75F0: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B75F4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B75F8: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B75FC: 4800004C  b 0x829b7648
	sub_829B7634(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7600 size=52
    let mut pc: u32 = 0x829B7600;
    'dispatch: loop {
        match pc {
            0x829B7600 => {
    //   block [0x829B7600..0x829B7634)
	// 829B7600: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7604: 396B98C4  addi r11, r11, -0x673c
	ctx.r[11].s64 = ctx.r[11].s64 + -26428;
	// 829B7608: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B760C: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B7610: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7614: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7618: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B761C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B7620: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B7624: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B7628: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B762C: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7634(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7634 size=48
    let mut pc: u32 = 0x829B7634;
    'dispatch: loop {
        match pc {
            0x829B7634 => {
    //   block [0x829B7634..0x829B7664)
	// 829B7634: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7638: 396B98C4  addi r11, r11, -0x673c
	ctx.r[11].s64 = ctx.r[11].s64 + -26428;
	// 829B763C: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7640: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7644: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7648: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B764C: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B7650: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B7654: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B7658: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B765C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B7660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7668 size=44
    let mut pc: u32 = 0x829B7668;
    'dispatch: loop {
        match pc {
            0x829B7668 => {
    //   block [0x829B7668..0x829B7694)
	// 829B7668: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829B766C: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 829B7670: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7674: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B7678: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B767C: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7680: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7684: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B7688: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B768C: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B7698 size=284
    let mut pc: u32 = 0x829B7698;
    'dispatch: loop {
        match pc {
            0x829B7698 => {
    //   block [0x829B7698..0x829B77B4)
	// 829B7698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B769C: 487F0AD1  bl 0x831a816c
	ctx.lr = 0x829B76A0;
	sub_831A8130(ctx, base);
	// 829B76A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B76A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B76A8: 4879CF59  bl 0x83154600
	ctx.lr = 0x829B76AC;
	sub_83154600(ctx, base);
	// 829B76AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B76B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B76B4: 4BFFED6D  bl 0x829b6420
	ctx.lr = 0x829B76B8;
	sub_829B6420(ctx, base);
	// 829B76B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B76BC: 484A20A5  bl 0x82e59760
	ctx.lr = 0x829B76C0;
	sub_82E59760(ctx, base);
	// 829B76C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B76C4: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829B76C8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829B76CC: 3BAB98DC  addi r29, r11, -0x6724
	ctx.r[29].s64 = ctx.r[11].s64 + -26404;
	// 829B76D0: C1AB98DC  lfs f13, -0x6724(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B76D4: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B76D8: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829B76DC: C0099524  lfs f0, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B76E0: EDA10372  fmuls f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 829B76E4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B76E8: 487F16E1  bl 0x831a8dc8
	ctx.lr = 0x829B76EC;
	sub_831A8DC8(ctx, base);
	// 829B76EC: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829B76F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B76F4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829B76F8: C1BDFFFC  lfs f13, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B76FC: 3BDE0420  addi r30, r30, 0x420
	ctx.r[30].s64 = ctx.r[30].s64 + 1056;
	// 829B7700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B7704: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B7708: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B770C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B7710: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829B7714: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829B7718: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829B771C: EC0D0332  fmuls f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 829B7720: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B7724: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B77B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B77B8 size=172
    let mut pc: u32 = 0x829B77B8;
    'dispatch: loop {
        match pc {
            0x829B77B8 => {
    //   block [0x829B77B8..0x829B7864)
	// 829B77B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B77BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B77C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B77C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B77C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B77CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B77D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B77D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B77D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B77DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B77E0: 4B909159  bl 0x822c0938
	ctx.lr = 0x829B77E4;
	sub_822C0938(ctx, base);
	// 829B77E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B77E8: 41820028  beq 0x829b7810
	if ctx.cr[0].eq {
	pc = 0x829B7810; continue 'dispatch;
	}
	// 829B77EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B77F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B77F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B77F8: 392B2774  addi r9, r11, 0x2774
	ctx.r[9].s64 = ctx.r[11].s64 + 10100;
	// 829B77FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B7800: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B7804: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B7808: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B780C: 48000008  b 0x829b7814
	pc = 0x829B7814; continue 'dispatch;
	// 829B7810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B7814: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B7818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B781C: 409A002C  bne cr6, 0x829b7848
	if !ctx.cr[6].eq {
	pc = 0x829B7848; continue 'dispatch;
	}
	// 829B7820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B7824: 4B908A45  bl 0x822c0268
	ctx.lr = 0x829B7828;
	sub_822C0268(ctx, base);
	// 829B7828: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B782C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B7830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B7834: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B7838: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B783C: 816B98FC  lwz r11, -0x6704(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26372 as u32) ) } as u64;
	// 829B7840: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B7844: 4B9087BD  bl 0x822c0000
	ctx.lr = 0x829B7848;
	sub_822C0000(ctx, base);
	// 829B7848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B784C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B7850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B7854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B7858: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B785C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B7860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B7868 size=312
    let mut pc: u32 = 0x829B7868;
    'dispatch: loop {
        match pc {
            0x829B7868 => {
    //   block [0x829B7868..0x829B79A0)
	// 829B7868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B786C: 487F0901  bl 0x831a816c
	ctx.lr = 0x829B7870;
	sub_831A8130(ctx, base);
	// 829B7870: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B7874: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B7878: 4879CD89  bl 0x83154600
	ctx.lr = 0x829B787C;
	sub_83154600(ctx, base);
	// 829B787C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B7880: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B7884: 4BFFEB55  bl 0x829b63d8
	ctx.lr = 0x829B7888;
	sub_829B63D8(ctx, base);
	// 829B7888: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B788C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B7890: 388B2788  addi r4, r11, 0x2788
	ctx.r[4].s64 = ctx.r[11].s64 + 10120;
	// 829B7894: 38A0010B  li r5, 0x10b
	ctx.r[5].s64 = 267;
	// 829B7898: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 829B789C: 4B908B3D  bl 0x822c03d8
	ctx.lr = 0x829B78A0;
	sub_822C03D8(ctx, base);
	// 829B78A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B78A4: 41820010  beq 0x829b78b4
	if ctx.cr[0].eq {
	pc = 0x829B78B4; continue 'dispatch;
	}
	// 829B78A8: 4BFFFA89  bl 0x829b7330
	ctx.lr = 0x829B78AC;
	sub_829B7330(ctx, base);
	// 829B78AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B78B0: 48000008  b 0x829b78b8
	pc = 0x829B78B8; continue 'dispatch;
	// 829B78B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B78B8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829B78BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B78C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B78C4: 4BFFFEF5  bl 0x829b77b8
	ctx.lr = 0x829B78C8;
	sub_829B77B8(ctx, base);
	// 829B78C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B78CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B78D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B78D4: 4B90872D  bl 0x822c0000
	ctx.lr = 0x829B78D8;
	sub_822C0000(ctx, base);
	// 829B78D8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B78DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B78E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B78E4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829B78E8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829B78EC: 419A0024  beq cr6, 0x829b7910
	if ctx.cr[6].eq {
	pc = 0x829B7910; continue 'dispatch;
	}
	// 829B78F0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B78F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B78F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B78FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B7900: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B7904: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B7908: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B790C: 4082FFE8  bne 0x829b78f4
	if !ctx.cr[0].eq {
	pc = 0x829B78F4; continue 'dispatch;
	}
	// 829B7910: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B7914: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829B7918: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B791C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B7920: 4BFED741  bl 0x829a5060
	ctx.lr = 0x829B7924;
	sub_829A5060(ctx, base);
	// 829B7924: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B7928: 419A000C  beq cr6, 0x829b7934
	if ctx.cr[6].eq {
	pc = 0x829B7934; continue 'dispatch;
	}
	// 829B792C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B7930: 4B908F61  bl 0x822c0890
	ctx.lr = 0x829B7934;
	sub_822C0890(ctx, base);
	// 829B7934: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829B7938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B793C: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829B7940: 4843C0C9  bl 0x82df3a08
	ctx.lr = 0x829B7944;
	sub_82DF3A08(ctx, base);
	// 829B7944: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B7948: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829B794C: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829B7950: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B7954: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829B7958: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829B795C: 481FBA1D  bl 0x82bb3378
	ctx.lr = 0x829B7960;
	sub_82BB3378(ctx, base);
	// 829B7960: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829B7964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B7968: 419A0008  beq cr6, 0x829b7970
	if ctx.cr[6].eq {
	pc = 0x829B7970; continue 'dispatch;
	}
	// 829B796C: 4B908F25  bl 0x822c0890
	ctx.lr = 0x829B7970;
	sub_822C0890(ctx, base);
	// 829B7970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B7974: 4843BAB5  bl 0x82df3428
	ctx.lr = 0x829B7978;
	sub_82DF3428(ctx, base);
	// 829B7978: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B797C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B7980: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829B7984: 993E0164  stb r9, 0x164(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(356 as u32), ctx.r[9].u8 ) };
	// 829B7988: C00B2960  lfs f0, 0x2960(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B798C: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7990: D01E0160  stfs f0, 0x160(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B7994: D1BE0168  stfs f13, 0x168(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 829B7998: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829B799C: 487F0820  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B79A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B79A0 size=816
    let mut pc: u32 = 0x829B79A0;
    'dispatch: loop {
        match pc {
            0x829B79A0 => {
    //   block [0x829B79A0..0x829B7CD0)
	// 829B79A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B79A4: 487F079D  bl 0x831a8140
	ctx.lr = 0x829B79A8;
	sub_831A8130(ctx, base);
	// 829B79A8: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 829B79AC: 487F10C9  bl 0x831a8a74
	ctx.lr = 0x829B79B0;
	sub_831A8A40(ctx, base);
	// 829B79B0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B79B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829B79B8: 4879CC49  bl 0x83154600
	ctx.lr = 0x829B79BC;
	sub_83154600(ctx, base);
	// 829B79BC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829B79C0: 4BFEB6A1  bl 0x829a3060
	ctx.lr = 0x829B79C4;
	sub_829A3060(ctx, base);
	// 829B79C4: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 829B79C8: 419802F8  blt cr6, 0x829b7cc0
	if ctx.cr[6].lt {
	pc = 0x829B7CC0; continue 'dispatch;
	}
	// 829B79CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829B79D0: 484A1DA9  bl 0x82e59778
	ctx.lr = 0x829B79D4;
	sub_82E59778(ctx, base);
	// 829B79D4: C01C0160  lfs f0, 0x160(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B79D8: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B79DC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B79E0: D01C0160  stfs f0, 0x160(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B79E4: 3BCB98E8  addi r30, r11, -0x6718
	ctx.r[30].s64 = ctx.r[11].s64 + -26392;
	// 829B79E8: C19EFFF8  lfs f12, -8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B79EC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 829B79F0: 419802D0  blt cr6, 0x829b7cc0
	if ctx.cr[6].lt {
	pc = 0x829B7CC0; continue 'dispatch;
	}
	// 829B79F4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 829B79F8: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B79FC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829B7A00: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7A04: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 829B7A08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B7A0C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B7A10: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829B7A14: C3A8ACFC  lfs f29, -0x5304(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829B7A18: C3C79524  lfs f30, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829B7A1C: 3EE08212  lis r23, -0x7dee
	ctx.r[23].s64 = -2112749568;
	// 829B7A20: C38608A4  lfs f28, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829B7A24: 3ACB27F0  addi r22, r11, 0x27f0
	ctx.r[22].s64 = ctx.r[11].s64 + 10224;
	// 829B7A28: 3AAA27E0  addi r21, r10, 0x27e0
	ctx.r[21].s64 = ctx.r[10].s64 + 10208;
	// 829B7A2C: 3B092788  addi r24, r9, 0x2788
	ctx.r[24].s64 = ctx.r[9].s64 + 10120;
	// 829B7A30: 897C0164  lbz r11, 0x164(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(356 as u32) ) } as u64;
	// 829B7A34: C17C0160  lfs f11, 0x160(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(352 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B7A38: ED6B6028  fsubs f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 829B7A3C: D17C0160  stfs f11, 0x160(r28)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B7A40: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 829B7A44: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829B7A48: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 829B7A4C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 829B7A50: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 829B7A54: 40980224  bge cr6, 0x829b7c78
	if !ctx.cr[6].lt {
	pc = 0x829B7C78; continue 'dispatch;
	}
	// 829B7A58: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 829B7A5C: FF0DE000  fcmpu cr6, f13, f28
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[28].f64);
	// 829B7A60: 40990218  ble cr6, 0x829b7c78
	if !ctx.cr[6].gt {
	pc = 0x829B7C78; continue 'dispatch;
	}
	// 829B7A64: D381009C  stfs f28, 0x9c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829B7A68: 3B5B0420  addi r26, r27, 0x420
	ctx.r[26].s64 = ctx.r[27].s64 + 1056;
	// 829B7A6C: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 829B7A70: 897C0164  lbz r11, 0x164(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(356 as u32) ) } as u64;
	// 829B7A74: 13E0D0C7  vcmpequd (lvx128) v31, v0, v26
	tmp.u32 = ctx.r[26].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B7A78: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829B7A7C: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 829B7A80: 4182000C  beq 0x829b7a8c
	if ctx.cr[0].eq {
	pc = 0x829B7A8C; continue 'dispatch;
	}
	// 829B7A84: 13C0A8C7  vcmpequd (lvx128) v30, v0, v21
	tmp.u32 = ctx.r[21].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B7A88: 48000008  b 0x829b7a90
	pc = 0x829B7A90; continue 'dispatch;
	// 829B7A8C: 13C0B0C7  vcmpequd (lvx128) v30, v0, v22
	tmp.u32 = ctx.r[22].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B7A90: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B7CD0 size=52
    let mut pc: u32 = 0x829B7CD0;
    'dispatch: loop {
        match pc {
            0x829B7CD0 => {
    //   block [0x829B7CD0..0x829B7D04)
	// 829B7CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B7CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B7CD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B7CDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B7CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B7CE4: 4BFFF9B5  bl 0x829b7698
	ctx.lr = 0x829B7CE8;
	sub_829B7698(ctx, base);
	// 829B7CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B7CEC: 4BFFFCB5  bl 0x829b79a0
	ctx.lr = 0x829B7CF0;
	sub_829B79A0(ctx, base);
	// 829B7CF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B7CF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B7CF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B7CFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B7D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B7D08 size=96
    let mut pc: u32 = 0x829B7D08;
    'dispatch: loop {
        match pc {
            0x829B7D08 => {
    //   block [0x829B7D08..0x829B7D68)
	// 829B7D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B7D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B7D10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B7D14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B7D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B7D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B7D20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B7D24: 4BFEB30D  bl 0x829a3030
	ctx.lr = 0x829B7D28;
	sub_829A3030(ctx, base);
	// 829B7D28: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7D2C: 9BDF0015  stb r30, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 829B7D30: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B7D34: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829B7D38: 394A2804  addi r10, r10, 0x2804
	ctx.r[10].s64 = ctx.r[10].s64 + 10244;
	// 829B7D3C: 993F0014  stb r9, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 829B7D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B7D44: C00B9990  lfs f0, -0x6670(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7D48: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829B7D4C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7D50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B7D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B7D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B7D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B7D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B7D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B7D68 size=8
    let mut pc: u32 = 0x829B7D68;
    'dispatch: loop {
        match pc {
            0x829B7D68 => {
    //   block [0x829B7D68..0x829B7D70)
	// 829B7D68: 88630014  lbz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B7D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7D70 size=100
    let mut pc: u32 = 0x829B7D70;
    'dispatch: loop {
        match pc {
            0x829B7D70 => {
    //   block [0x829B7D70..0x829B7DD4)
	// 829B7D70: 89640015  lbz r11, 0x15(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(21 as u32) ) } as u64;
	// 829B7D74: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B7D78: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829B7D7C: 419800AC  blt cr6, 0x829b7e28
	if ctx.cr[6].lt {
		sub_829B7E28(ctx, base);
		return;
	}
	// 829B7D80: 409A00D0  bne cr6, 0x829b7e50
	if !ctx.cr[6].eq {
		sub_829B7E28(ctx, base);
		return;
	}
	// 829B7D84: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B7D88: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B7D8C: 41980090  blt cr6, 0x829b7e1c
	if ctx.cr[6].lt {
		sub_829B7E1C(ctx, base);
		return;
	}
	// 829B7D90: 419A0068  beq cr6, 0x829b7df8
	if ctx.cr[6].eq {
		sub_829B7DF8(ctx, base);
		return;
	}
	// 829B7D94: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B7D98: 41980054  blt cr6, 0x829b7dec
	if ctx.cr[6].lt {
		sub_829B7DEC(ctx, base);
		return;
	}
	// 829B7D9C: 419A0044  beq cr6, 0x829b7de0
	if ctx.cr[6].eq {
		sub_829B7DE0(ctx, base);
		return;
	}
	// 829B7DA0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B7DA4: 41980030  blt cr6, 0x829b7dd4
	if ctx.cr[6].lt {
		sub_829B7DD4(ctx, base);
		return;
	}
	// 829B7DA8: 409A00A8  bne cr6, 0x829b7e50
	if !ctx.cr[6].eq {
		sub_829B7E28(ctx, base);
		return;
	}
	// 829B7DAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B7DB0: C00A2818  lfs f0, 0x2818(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7DB4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7DB8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829B7DBC: 396B99A8  addi r11, r11, -0x6658
	ctx.r[11].s64 = ctx.r[11].s64 + -26200;
	// 829B7DC0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829B7DC4: C16808A4  lfs f11, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B7DC8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7DCC: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7DD0: 48000154  b 0x829b7f24
	sub_829B7F08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7DD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7DD4 size=12
    let mut pc: u32 = 0x829B7DD4;
    'dispatch: loop {
        match pc {
            0x829B7DD4 => {
    //   block [0x829B7DD4..0x829B7DE0)
	// 829B7DD4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829B7DD8: C00A2E54  lfs f0, 0x2e54(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11860 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7DDC: 4BFFFFD8  b 0x829b7db4
	sub_829B7D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7DE0 size=12
    let mut pc: u32 = 0x829B7DE0;
    'dispatch: loop {
        match pc {
            0x829B7DE0 => {
    //   block [0x829B7DE0..0x829B7DEC)
	// 829B7DE0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B7DE4: C00A9648  lfs f0, -0x69b8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7DE8: 4BFFFFCC  b 0x829b7db4
	sub_829B7D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7DEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7DEC size=12
    let mut pc: u32 = 0x829B7DEC;
    'dispatch: loop {
        match pc {
            0x829B7DEC => {
    //   block [0x829B7DEC..0x829B7DF8)
	// 829B7DEC: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829B7DF0: C00A7BC4  lfs f0, 0x7bc4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7DF4: 4BFFFFC0  b 0x829b7db4
	sub_829B7D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7DF8 size=36
    let mut pc: u32 = 0x829B7DF8;
    'dispatch: loop {
        match pc {
            0x829B7DF8 => {
    //   block [0x829B7DF8..0x829B7E1C)
	// 829B7DF8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829B7DFC: C00A2514  lfs f0, 0x2514(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7E00: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829B7E04: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 829B7E08: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7E0C: 396B99A8  addi r11, r11, -0x6658
	ctx.r[11].s64 = ctx.r[11].s64 + -26200;
	// 829B7E10: C16808A4  lfs f11, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B7E14: C1A97BC4  lfs f13, 0x7bc4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7E18: 48000108  b 0x829b7f20
	sub_829B7F08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7E1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7E1C size=12
    let mut pc: u32 = 0x829B7E1C;
    'dispatch: loop {
        match pc {
            0x829B7E1C => {
    //   block [0x829B7E1C..0x829B7E28)
	// 829B7E1C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B7E20: C00AA1C4  lfs f0, -0x5e3c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7E24: 4BFFFFDC  b 0x829b7e00
	sub_829B7DF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7E28 size=64
    let mut pc: u32 = 0x829B7E28;
    'dispatch: loop {
        match pc {
            0x829B7E28 => {
    //   block [0x829B7E28..0x829B7E68)
	// 829B7E28: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B7E2C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B7E30: 419800D8  blt cr6, 0x829b7f08
	if ctx.cr[6].lt {
		sub_829B7F08(ctx, base);
		return;
	}
	// 829B7E34: 419A00A0  beq cr6, 0x829b7ed4
	if ctx.cr[6].eq {
		sub_829B7ED4(ctx, base);
		return;
	}
	// 829B7E38: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B7E3C: 41980084  blt cr6, 0x829b7ec0
	if ctx.cr[6].lt {
		sub_829B7EC0(ctx, base);
		return;
	}
	// 829B7E40: 419A0060  beq cr6, 0x829b7ea0
	if ctx.cr[6].eq {
		sub_829B7EA0(ctx, base);
		return;
	}
	// 829B7E44: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B7E48: 41980038  blt cr6, 0x829b7e80
	if ctx.cr[6].lt {
		sub_829B7E80(ctx, base);
		return;
	}
	// 829B7E4C: 419A001C  beq cr6, 0x829b7e68
	if ctx.cr[6].eq {
		sub_829B7E68(ctx, base);
		return;
	}
	// 829B7E50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B7E54: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7E58: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B7E5C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B7E60: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7E64: 480000CC  b 0x829b7f30
	sub_829B7F08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7E68 size=24
    let mut pc: u32 = 0x829B7E68;
    'dispatch: loop {
        match pc {
            0x829B7E68 => {
    //   block [0x829B7E68..0x829B7E80)
	// 829B7E68: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7E6C: 396B99A8  addi r11, r11, -0x6658
	ctx.r[11].s64 = ctx.r[11].s64 + -26200;
	// 829B7E70: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7E74: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B7E78: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7E7C: 4800006C  b 0x829b7ee8
	sub_829B7ED4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7E80 size=32
    let mut pc: u32 = 0x829B7E80;
    'dispatch: loop {
        match pc {
            0x829B7E80 => {
    //   block [0x829B7E80..0x829B7EA0)
	// 829B7E80: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7E84: 392B99A8  addi r9, r11, -0x6658
	ctx.r[9].s64 = ctx.r[11].s64 + -26200;
	// 829B7E88: C1AB99A8  lfs f13, -0x6658(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7E8C: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7E90: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B7E94: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7E98: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7E9C: 4800008C  b 0x829b7f28
	sub_829B7F08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7EA0 size=32
    let mut pc: u32 = 0x829B7EA0;
    'dispatch: loop {
        match pc {
            0x829B7EA0 => {
    //   block [0x829B7EA0..0x829B7EC0)
	// 829B7EA0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7EA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B7EA8: 396B99A8  addi r11, r11, -0x6658
	ctx.r[11].s64 = ctx.r[11].s64 + -26200;
	// 829B7EAC: C16A08A4  lfs f11, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B7EB0: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7EB4: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7EB8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7EBC: 48000068  b 0x829b7f24
	sub_829B7F08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7EC0 size=20
    let mut pc: u32 = 0x829B7EC0;
    'dispatch: loop {
        match pc {
            0x829B7EC0 => {
    //   block [0x829B7EC0..0x829B7ED4)
	// 829B7EC0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7EC4: 396B99A8  addi r11, r11, -0x6658
	ctx.r[11].s64 = ctx.r[11].s64 + -26200;
	// 829B7EC8: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7ECC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7ED0: 4BFFFFC0  b 0x829b7e90
	sub_829B7E80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7ED4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7ED4 size=52
    let mut pc: u32 = 0x829B7ED4;
    'dispatch: loop {
        match pc {
            0x829B7ED4 => {
    //   block [0x829B7ED4..0x829B7F08)
	// 829B7ED4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7ED8: 396B99A8  addi r11, r11, -0x6658
	ctx.r[11].s64 = ctx.r[11].s64 + -26200;
	// 829B7EDC: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7EE0: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B7EE4: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7EE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B7EEC: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7EF0: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B7EF4: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B7EF8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B7EFC: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7F00: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7F04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B7F08 size=48
    let mut pc: u32 = 0x829B7F08;
    'dispatch: loop {
        match pc {
            0x829B7F08 => {
    //   block [0x829B7F08..0x829B7F38)
	// 829B7F08: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B7F0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B7F10: 396B99A8  addi r11, r11, -0x6658
	ctx.r[11].s64 = ctx.r[11].s64 + -26200;
	// 829B7F14: C16A08A4  lfs f11, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B7F18: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B7F1C: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B7F20: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B7F24: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B7F28: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B7F2C: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B7F30: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B7F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B7F38 size=120
    let mut pc: u32 = 0x829B7F38;
    'dispatch: loop {
        match pc {
            0x829B7F38 => {
    //   block [0x829B7F38..0x829B7FB0)
	// 829B7F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B7F3C: 487F0231  bl 0x831a816c
	ctx.lr = 0x829B7F40;
	sub_831A8130(ctx, base);
	// 829B7F40: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829B7F44: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B7F48: 4879C6B9  bl 0x83154600
	ctx.lr = 0x829B7F4C;
	sub_83154600(ctx, base);
	// 829B7F4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B7F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B7F54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B7F58: C3EB9534  lfs f31, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B7F5C: D3FF0238  stfs f31, 0x238(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 829B7F60: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 829B7F64: 484C97DD  bl 0x82e81740
	ctx.lr = 0x829B7F68;
	sub_82E81740(ctx, base);
	// 829B7F68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B7F6C: 807F0244  lwz r3, 0x244(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 829B7F70: 484C97D1  bl 0x82e81740
	ctx.lr = 0x829B7F74;
	sub_82E81740(ctx, base);
	// 829B7F74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B7F78: 807F024C  lwz r3, 0x24c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 829B7F7C: 484C97C5  bl 0x82e81740
	ctx.lr = 0x829B7F80;
	sub_82E81740(ctx, base);
	// 829B7F80: 3BBF0254  addi r29, r31, 0x254
	ctx.r[29].s64 = ctx.r[31].s64 + 596;
	// 829B7F84: 3BC00008  li r30, 8
	ctx.r[30].s64 = 8;
	// 829B7F88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B7F8C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B7F90: 484C97B1  bl 0x82e81740
	ctx.lr = 0x829B7F94;
	sub_82E81740(ctx, base);
	// 829B7F94: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829B7F98: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829B7F9C: 4082FFEC  bne 0x829b7f88
	if !ctx.cr[0].eq {
	pc = 0x829B7F88; continue 'dispatch;
	}
	// 829B7FA0: D3FF036C  stfs f31, 0x36c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(876 as u32), tmp.u32 ) };
	// 829B7FA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829B7FA8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829B7FAC: 487F0210  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B7FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B7FB0 size=280
    let mut pc: u32 = 0x829B7FB0;
    'dispatch: loop {
        match pc {
            0x829B7FB0 => {
    //   block [0x829B7FB0..0x829B80C8)
	// 829B7FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B7FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B7FB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B7FBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B7FC0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829B7FC4: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B80C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B80C8 size=172
    let mut pc: u32 = 0x829B80C8;
    'dispatch: loop {
        match pc {
            0x829B80C8 => {
    //   block [0x829B80C8..0x829B8174)
	// 829B80C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B80CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B80D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B80D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B80D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B80DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B80E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B80E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B80E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B80EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B80F0: 4B908849  bl 0x822c0938
	ctx.lr = 0x829B80F4;
	sub_822C0938(ctx, base);
	// 829B80F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B80F8: 41820028  beq 0x829b8120
	if ctx.cr[0].eq {
	pc = 0x829B8120; continue 'dispatch;
	}
	// 829B80FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B8100: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B8104: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B8108: 392B2820  addi r9, r11, 0x2820
	ctx.r[9].s64 = ctx.r[11].s64 + 10272;
	// 829B810C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B8110: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B8114: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B8118: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B811C: 48000008  b 0x829b8124
	pc = 0x829B8124; continue 'dispatch;
	// 829B8120: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B8124: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B8128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B812C: 409A002C  bne cr6, 0x829b8158
	if !ctx.cr[6].eq {
	pc = 0x829B8158; continue 'dispatch;
	}
	// 829B8130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B8134: 4B908135  bl 0x822c0268
	ctx.lr = 0x829B8138;
	sub_822C0268(ctx, base);
	// 829B8138: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B813C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B8140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B8144: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B8148: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B814C: 816B99E0  lwz r11, -0x6620(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26144 as u32) ) } as u64;
	// 829B8150: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B8154: 4B907EAD  bl 0x822c0000
	ctx.lr = 0x829B8158;
	sub_822C0000(ctx, base);
	// 829B8158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B815C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B8160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B8164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B8168: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B816C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B8170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B8178 size=648
    let mut pc: u32 = 0x829B8178;
    'dispatch: loop {
        match pc {
            0x829B8178 => {
    //   block [0x829B8178..0x829B8400)
	// 829B8178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B817C: 487EFFF1  bl 0x831a816c
	ctx.lr = 0x829B8180;
	sub_831A8130(ctx, base);
	// 829B8180: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829B8184: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829B8188: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B8400 size=1932
    let mut pc: u32 = 0x829B8400;
    'dispatch: loop {
        match pc {
            0x829B8400 => {
    //   block [0x829B8400..0x829B8B8C)
	// 829B8400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B8404: 487EFD5D  bl 0x831a8160
	ctx.lr = 0x829B8408;
	sub_831A8130(ctx, base);
	// 829B8408: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 829B840C: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 829B8410: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829B8414: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B8B90 size=4
    let mut pc: u32 = 0x829B8B90;
    'dispatch: loop {
        match pc {
            0x829B8B90 => {
    //   block [0x829B8B90..0x829B8B94)
	// 829B8B90: 4BFFF870  b 0x829b8400
	sub_829B8400(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B8B98 size=72
    let mut pc: u32 = 0x829B8B98;
    'dispatch: loop {
        match pc {
            0x829B8B98 => {
    //   block [0x829B8B98..0x829B8BE0)
	// 829B8B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B8B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B8BA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B8BA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B8BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B8BAC: 4BFEA485  bl 0x829a3030
	ctx.lr = 0x829B8BB0;
	sub_829A3030(ctx, base);
	// 829B8BB0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B8BB4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B8BB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B8BBC: 394A28D4  addi r10, r10, 0x28d4
	ctx.r[10].s64 = ctx.r[10].s64 + 10452;
	// 829B8BC0: C00B9A70  lfs f0, -0x6590(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26000 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8BC4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829B8BC8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B8BCC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B8BD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B8BD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B8BD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B8BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B8BE0 size=64
    let mut pc: u32 = 0x829B8BE0;
    'dispatch: loop {
        match pc {
            0x829B8BE0 => {
    //   block [0x829B8BE0..0x829B8C20)
	// 829B8BE0: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B8BE4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B8BE8: 419800DC  blt cr6, 0x829b8cc4
	if ctx.cr[6].lt {
		sub_829B8CC4(ctx, base);
		return;
	}
	// 829B8BEC: 419A00A4  beq cr6, 0x829b8c90
	if ctx.cr[6].eq {
		sub_829B8C90(ctx, base);
		return;
	}
	// 829B8BF0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B8BF4: 41980084  blt cr6, 0x829b8c78
	if ctx.cr[6].lt {
		sub_829B8C78(ctx, base);
		return;
	}
	// 829B8BF8: 419A0068  beq cr6, 0x829b8c60
	if ctx.cr[6].eq {
		sub_829B8C60(ctx, base);
		return;
	}
	// 829B8BFC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B8C00: 41980044  blt cr6, 0x829b8c44
	if ctx.cr[6].lt {
		sub_829B8C44(ctx, base);
		return;
	}
	// 829B8C04: 419A001C  beq cr6, 0x829b8c20
	if ctx.cr[6].eq {
		sub_829B8C20(ctx, base);
		return;
	}
	// 829B8C08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B8C0C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C10: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B8C14: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B8C18: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B8C1C: 480000D0  b 0x829b8cec
	sub_829B8CC4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B8C20 size=36
    let mut pc: u32 = 0x829B8C20;
    'dispatch: loop {
        match pc {
            0x829B8C20 => {
    //   block [0x829B8C20..0x829B8C44)
	// 829B8C20: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B8C24: 392B9A84  addi r9, r11, -0x657c
	ctx.r[9].s64 = ctx.r[11].s64 + -25980;
	// 829B8C28: C00B9A84  lfs f0, -0x657c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C2C: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B8C30: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C34: C1A9000C  lfs f13, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B8C38: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B8C3C: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B8C40: 48000070  b 0x829b8cb0
	sub_829B8C90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8C44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B8C44 size=28
    let mut pc: u32 = 0x829B8C44;
    'dispatch: loop {
        match pc {
            0x829B8C44 => {
    //   block [0x829B8C44..0x829B8C60)
	// 829B8C44: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B8C48: 396B9A84  addi r11, r11, -0x657c
	ctx.r[11].s64 = ctx.r[11].s64 + -25980;
	// 829B8C4C: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C50: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B8C54: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B8C58: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C5C: 4800004C  b 0x829b8ca8
	sub_829B8C90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B8C60 size=24
    let mut pc: u32 = 0x829B8C60;
    'dispatch: loop {
        match pc {
            0x829B8C60 => {
    //   block [0x829B8C60..0x829B8C78)
	// 829B8C60: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B8C64: 392B9A84  addi r9, r11, -0x657c
	ctx.r[9].s64 = ctx.r[11].s64 + -25980;
	// 829B8C68: C00B9A84  lfs f0, -0x657c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C6C: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B8C70: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B8C74: 48000064  b 0x829b8cd8
	sub_829B8CC4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B8C78 size=24
    let mut pc: u32 = 0x829B8C78;
    'dispatch: loop {
        match pc {
            0x829B8C78 => {
    //   block [0x829B8C78..0x829B8C90)
	// 829B8C78: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B8C7C: 396B9A84  addi r11, r11, -0x657c
	ctx.r[11].s64 = ctx.r[11].s64 + -25980;
	// 829B8C80: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C84: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B8C88: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B8C8C: 4800004C  b 0x829b8cd8
	sub_829B8CC4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B8C90 size=52
    let mut pc: u32 = 0x829B8C90;
    'dispatch: loop {
        match pc {
            0x829B8C90 => {
    //   block [0x829B8C90..0x829B8CC4)
	// 829B8C90: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B8C94: 396B9A84  addi r11, r11, -0x657c
	ctx.r[11].s64 = ctx.r[11].s64 + -25980;
	// 829B8C98: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8C9C: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B8CA0: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B8CA4: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8CA8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B8CAC: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B8CB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B8CB4: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B8CB8: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B8CBC: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B8CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8CC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B8CC4 size=48
    let mut pc: u32 = 0x829B8CC4;
    'dispatch: loop {
        match pc {
            0x829B8CC4 => {
    //   block [0x829B8CC4..0x829B8CF4)
	// 829B8CC4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B8CC8: 396B9A84  addi r11, r11, -0x657c
	ctx.r[11].s64 = ctx.r[11].s64 + -25980;
	// 829B8CCC: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8CD0: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B8CD4: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B8CD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B8CDC: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B8CE0: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B8CE4: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B8CE8: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B8CEC: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B8CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B8CF8 size=36
    let mut pc: u32 = 0x829B8CF8;
    'dispatch: loop {
        match pc {
            0x829B8CF8 => {
    //   block [0x829B8CF8..0x829B8D1C)
	// 829B8CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B8CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B8D00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B8D04: 4879B8FD  bl 0x83154600
	ctx.lr = 0x829B8D08;
	sub_83154600(ctx, base);
	// 829B8D08: 4BFF0531  bl 0x829a9238
	ctx.lr = 0x829B8D0C;
	sub_829A9238(ctx, base);
	// 829B8D0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B8D10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B8D14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B8D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B8D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B8D20 size=1180
    let mut pc: u32 = 0x829B8D20;
    'dispatch: loop {
        match pc {
            0x829B8D20 => {
    //   block [0x829B8D20..0x829B91BC)
	// 829B8D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B8D24: 487EF449  bl 0x831a816c
	ctx.lr = 0x829B8D28;
	sub_831A8130(ctx, base);
	// 829B8D28: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 829B8D2C: 487EFD4D  bl 0x831a8a78
	ctx.lr = 0x829B8D30;
	sub_831A8A40(ctx, base);
	// 829B8D30: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B8D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B8D38: 4879B8C9  bl 0x83154600
	ctx.lr = 0x829B8D3C;
	sub_83154600(ctx, base);
	// 829B8D3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B8D40: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 829B8D44: 38A101A0  addi r5, r1, 0x1a0
	ctx.r[5].s64 = ctx.r[1].s64 + 416;
	// 829B8D48: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 829B8D4C: 807D03F0  lwz r3, 0x3f0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B8D50: 4B917309  bl 0x822d0058
	ctx.lr = 0x829B8D54;
	sub_822D0058(ctx, base);
	// 829B8D54: 39610150  addi r11, r1, 0x150
	ctx.r[11].s64 = ctx.r[1].s64 + 336;
	// 829B8D58: C00100D0  lfs f0, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B8D5C: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829B8D60: C1A100D4  lfs f13, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B8D64: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829B8D68: C18100D8  lfs f12, 0xd8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B8D6C: C16100DC  lfs f11, 0xdc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B8D70: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 829B8D74: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B8D78: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B8D7C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B8D80: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B8D84: 13FD50C7  vcmpequd (lvx128) v31, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B8D88: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B91C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B91C0 size=172
    let mut pc: u32 = 0x829B91C0;
    'dispatch: loop {
        match pc {
            0x829B91C0 => {
    //   block [0x829B91C0..0x829B926C)
	// 829B91C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B91C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B91C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B91CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B91D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B91D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B91D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B91DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B91E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B91E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B91E8: 4B907751  bl 0x822c0938
	ctx.lr = 0x829B91EC;
	sub_822C0938(ctx, base);
	// 829B91EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B91F0: 41820028  beq 0x829b9218
	if ctx.cr[0].eq {
	pc = 0x829B9218; continue 'dispatch;
	}
	// 829B91F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B91F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B91FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B9200: 392B28EC  addi r9, r11, 0x28ec
	ctx.r[9].s64 = ctx.r[11].s64 + 10476;
	// 829B9204: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B9208: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B920C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B9210: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B9214: 48000008  b 0x829b921c
	pc = 0x829B921C; continue 'dispatch;
	// 829B9218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B921C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B9220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B9224: 409A002C  bne cr6, 0x829b9250
	if !ctx.cr[6].eq {
	pc = 0x829B9250; continue 'dispatch;
	}
	// 829B9228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B922C: 4B90703D  bl 0x822c0268
	ctx.lr = 0x829B9230;
	sub_822C0268(ctx, base);
	// 829B9230: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9234: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B9238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B923C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B9240: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B9244: 816B9AA4  lwz r11, -0x655c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25948 as u32) ) } as u64;
	// 829B9248: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B924C: 4B906DB5  bl 0x822c0000
	ctx.lr = 0x829B9250;
	sub_822C0000(ctx, base);
	// 829B9250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B9254: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B9258: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B925C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9260: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B9264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B9268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B9270 size=64
    let mut pc: u32 = 0x829B9270;
    'dispatch: loop {
        match pc {
            0x829B9270 => {
    //   block [0x829B9270..0x829B92B0)
	// 829B9270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9278: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B927C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B9284: 4879B37D  bl 0x83154600
	ctx.lr = 0x829B9288;
	sub_83154600(ctx, base);
	// 829B9288: 8963046C  lbz r11, 0x46c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1132 as u32) ) } as u64;
	// 829B928C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B9290: 4082000C  bne 0x829b929c
	if !ctx.cr[0].eq {
	pc = 0x829B929C; continue 'dispatch;
	}
	// 829B9294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9298: 4BFFFA89  bl 0x829b8d20
	ctx.lr = 0x829B929C;
	sub_829B8D20(ctx, base);
	// 829B929C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B92A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B92A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B92A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B92AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B92B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B92B0 size=340
    let mut pc: u32 = 0x829B92B0;
    'dispatch: loop {
        match pc {
            0x829B92B0 => {
    //   block [0x829B92B0..0x829B9404)
	// 829B92B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B92B4: 487EEEB9  bl 0x831a816c
	ctx.lr = 0x829B92B8;
	sub_831A8130(ctx, base);
	// 829B92B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B92BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B92C0: 4879B341  bl 0x83154600
	ctx.lr = 0x829B92C4;
	sub_83154600(ctx, base);
	// 829B92C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B92C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B92CC: 4BFFD10D  bl 0x829b63d8
	ctx.lr = 0x829B92D0;
	sub_829B63D8(ctx, base);
	// 829B92D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B92D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B92D8: 388B2900  addi r4, r11, 0x2900
	ctx.r[4].s64 = ctx.r[11].s64 + 10496;
	// 829B92DC: 38A000B2  li r5, 0xb2
	ctx.r[5].s64 = 178;
	// 829B92E0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 829B92E4: 4B9070F5  bl 0x822c03d8
	ctx.lr = 0x829B92E8;
	sub_822C03D8(ctx, base);
	// 829B92E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B92EC: 41820010  beq 0x829b92fc
	if ctx.cr[0].eq {
	pc = 0x829B92FC; continue 'dispatch;
	}
	// 829B92F0: 4BFFF8A9  bl 0x829b8b98
	ctx.lr = 0x829B92F4;
	sub_829B8B98(ctx, base);
	// 829B92F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B92F8: 48000008  b 0x829b9300
	pc = 0x829B9300; continue 'dispatch;
	// 829B92FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829B9300: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829B9304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B9308: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B930C: 4BFFFEB5  bl 0x829b91c0
	ctx.lr = 0x829B9310;
	sub_829B91C0(ctx, base);
	// 829B9310: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829B9314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829B9318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B931C: 4B906CE5  bl 0x822c0000
	ctx.lr = 0x829B9320;
	sub_822C0000(ctx, base);
	// 829B9320: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B9324: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B9328: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B932C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829B9330: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829B9334: 419A0024  beq cr6, 0x829b9358
	if ctx.cr[6].eq {
	pc = 0x829B9358; continue 'dispatch;
	}
	// 829B9338: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829B933C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B9340: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B9344: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B9348: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B934C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B9350: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B9354: 4082FFE8  bne 0x829b933c
	if !ctx.cr[0].eq {
	pc = 0x829B933C; continue 'dispatch;
	}
	// 829B9358: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B935C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829B9360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B9364: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B9368: 4BFEBCF9  bl 0x829a5060
	ctx.lr = 0x829B936C;
	sub_829A5060(ctx, base);
	// 829B936C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829B9370: 419A000C  beq cr6, 0x829b937c
	if ctx.cr[6].eq {
	pc = 0x829B937C; continue 'dispatch;
	}
	// 829B9374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9378: 4B907519  bl 0x822c0890
	ctx.lr = 0x829B937C;
	sub_822C0890(ctx, base);
	// 829B937C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B9380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B9384: 4BFEBB55  bl 0x829a4ed8
	ctx.lr = 0x829B9388;
	sub_829A4ED8(ctx, base);
	// 829B9388: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 829B938C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 829B9390: 807E03F0  lwz r3, 0x3f0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829B9394: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829B9398: 4B916CC1  bl 0x822d0058
	ctx.lr = 0x829B939C;
	sub_822D0058(ctx, base);
	// 829B939C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 829B93A0: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829B93A4: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B93A8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 829B93AC: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B93B0: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B93B4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B93B8: C161006C  lfs f11, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B93BC: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B93C0: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B93C4: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B93C8: 13FE50C7  vcmpequd (lvx128) v31, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829B93CC: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B9408 size=112
    let mut pc: u32 = 0x829B9408;
    'dispatch: loop {
        match pc {
            0x829B9408 => {
    //   block [0x829B9408..0x829B9478)
	// 829B9408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B940C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B9414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B9418: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829B941C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B9424: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829B9428: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829B942C: 4BFE9C05  bl 0x829a3030
	ctx.lr = 0x829B9430;
	sub_829A3030(ctx, base);
	// 829B9430: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9434: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829B9438: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829B943C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 829B9440: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829B9444: 394A2950  addi r10, r10, 0x2950
	ctx.r[10].s64 = ctx.r[10].s64 + 10576;
	// 829B9448: 993F001C  stb r9, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 829B944C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9450: C00B9B2C  lfs f0, -0x64d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25812 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9454: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829B9458: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B945C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B9460: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B9464: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9468: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829B946C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B9470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B9474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B9478 size=8
    let mut pc: u32 = 0x829B9478;
    'dispatch: loop {
        match pc {
            0x829B9478 => {
    //   block [0x829B9478..0x829B9480)
	// 829B9478: 8863001C  lbz r3, 0x1c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 829B947C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9480 size=120
    let mut pc: u32 = 0x829B9480;
    'dispatch: loop {
        match pc {
            0x829B9480 => {
    //   block [0x829B9480..0x829B94F8)
	// 829B9480: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 829B9484: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B9488: 419800CC  blt cr6, 0x829b9554
	if ctx.cr[6].lt {
		sub_829B9554(ctx, base);
		return;
	}
	// 829B948C: 419A000C  beq cr6, 0x829b9498
	if ctx.cr[6].eq {
	pc = 0x829B9498; continue 'dispatch;
	}
	// 829B9490: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B9494: 409800E8  bge cr6, 0x829b957c
	if !ctx.cr[6].lt {
		sub_829B9554(ctx, base);
		return;
	}
	// 829B9498: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B949C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B94A0: 419800A8  blt cr6, 0x829b9548
	if ctx.cr[6].lt {
		sub_829B9548(ctx, base);
		return;
	}
	// 829B94A4: 419A0084  beq cr6, 0x829b9528
	if ctx.cr[6].eq {
		sub_829B9528(ctx, base);
		return;
	}
	// 829B94A8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B94AC: 41980064  blt cr6, 0x829b9510
	if ctx.cr[6].lt {
		sub_829B9510(ctx, base);
		return;
	}
	// 829B94B0: 419A0054  beq cr6, 0x829b9504
	if ctx.cr[6].eq {
		sub_829B9504(ctx, base);
		return;
	}
	// 829B94B4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B94B8: 41980040  blt cr6, 0x829b94f8
	if ctx.cr[6].lt {
		sub_829B94F8(ctx, base);
		return;
	}
	// 829B94BC: 409A00C0  bne cr6, 0x829b957c
	if !ctx.cr[6].eq {
		sub_829B9554(ctx, base);
		return;
	}
	// 829B94C0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B94C4: C00A2960  lfs f0, 0x2960(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B94C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B94CC: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B94D0: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B94D4: 396B9B3C  addi r11, r11, -0x64c4
	ctx.r[11].s64 = ctx.r[11].s64 + -25796;
	// 829B94D8: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B94DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829B94E0: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B94E4: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B94E8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B94EC: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B94F0: C18908A4  lfs f12, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B94F4: 48000150  b 0x829b9644
	sub_829B961C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B94F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B94F8 size=12
    let mut pc: u32 = 0x829B94F8;
    'dispatch: loop {
        match pc {
            0x829B94F8 => {
    //   block [0x829B94F8..0x829B9504)
	// 829B94F8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B94FC: C00A9534  lfs f0, -0x6acc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9500: 4BFFFFC8  b 0x829b94c8
	sub_829B9480(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9504(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9504 size=12
    let mut pc: u32 = 0x829B9504;
    'dispatch: loop {
        match pc {
            0x829B9504 => {
    //   block [0x829B9504..0x829B9510)
	// 829B9504: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829B9508: C00A9524  lfs f0, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B950C: 4BFFFFBC  b 0x829b94c8
	sub_829B9480(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9510 size=24
    let mut pc: u32 = 0x829B9510;
    'dispatch: loop {
        match pc {
            0x829B9510 => {
    //   block [0x829B9510..0x829B9528)
	// 829B9510: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9514: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9518: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B951C: 396B9B3C  addi r11, r11, -0x64c4
	ctx.r[11].s64 = ctx.r[11].s64 + -25796;
	// 829B9520: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9524: 4800010C  b 0x829b9630
	sub_829B961C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9528 size=32
    let mut pc: u32 = 0x829B9528;
    'dispatch: loop {
        match pc {
            0x829B9528 => {
    //   block [0x829B9528..0x829B9548)
	// 829B9528: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829B952C: C00A2E54  lfs f0, 0x2e54(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11860 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9530: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9534: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B9538: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B953C: 396B9B3C  addi r11, r11, -0x64c4
	ctx.r[11].s64 = ctx.r[11].s64 + -25796;
	// 829B9540: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B9544: 4BFFFF98  b 0x829b94dc
	sub_829B9480(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9548 size=12
    let mut pc: u32 = 0x829B9548;
    'dispatch: loop {
        match pc {
            0x829B9548 => {
    //   block [0x829B9548..0x829B9554)
	// 829B9548: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829B954C: C00A7BC4  lfs f0, 0x7bc4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9550: 4BFFFFE0  b 0x829b9530
	sub_829B9528(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9554(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9554 size=68
    let mut pc: u32 = 0x829B9554;
    'dispatch: loop {
        match pc {
            0x829B9554 => {
    //   block [0x829B9554..0x829B9598)
	// 829B9554: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829B9558: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B955C: 419800C0  blt cr6, 0x829b961c
	if ctx.cr[6].lt {
		sub_829B961C(ctx, base);
		return;
	}
	// 829B9560: 419A00B0  beq cr6, 0x829b9610
	if ctx.cr[6].eq {
		sub_829B9610(ctx, base);
		return;
	}
	// 829B9564: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829B9568: 41980094  blt cr6, 0x829b95fc
	if ctx.cr[6].lt {
		sub_829B95FC(ctx, base);
		return;
	}
	// 829B956C: 419A007C  beq cr6, 0x829b95e8
	if ctx.cr[6].eq {
		sub_829B95E8(ctx, base);
		return;
	}
	// 829B9570: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829B9574: 41980050  blt cr6, 0x829b95c4
	if ctx.cr[6].lt {
		sub_829B95C4(ctx, base);
		return;
	}
	// 829B9578: 419A0020  beq cr6, 0x829b9598
	if ctx.cr[6].eq {
		sub_829B9598(ctx, base);
		return;
	}
	// 829B957C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B9580: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9584: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B9588: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B958C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B9590: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B9594: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9598 size=44
    let mut pc: u32 = 0x829B9598;
    'dispatch: loop {
        match pc {
            0x829B9598 => {
    //   block [0x829B9598..0x829B95C4)
	// 829B9598: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B959C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B95A0: FD400050  fneg f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B95A4: 392B9B3C  addi r9, r11, -0x64c4
	ctx.r[9].s64 = ctx.r[11].s64 + -25796;
	// 829B95A8: C16B9B3C  lfs f11, -0x64c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25796 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829B95AC: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B95B0: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B95B4: C1A9FFFC  lfs f13, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B95B8: EC0A5828  fsubs f0, f10, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 829B95BC: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B95C0: 48000078  b 0x829b9638
	sub_829B961C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B95C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B95C4 size=36
    let mut pc: u32 = 0x829B95C4;
    'dispatch: loop {
        match pc {
            0x829B95C4 => {
    //   block [0x829B95C4..0x829B95E8)
	// 829B95C4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B95C8: C1A40018  lfs f13, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B95CC: C00B9B3C  lfs f0, -0x64c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B95D0: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B95D4: 392B9B3C  addi r9, r11, -0x64c4
	ctx.r[9].s64 = ctx.r[11].s64 + -25796;
	// 829B95D8: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B95DC: C009FFF8  lfs f0, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B95E0: C1A9FFFC  lfs f13, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B95E4: 48000050  b 0x829b9634
	sub_829B961C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B95E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B95E8 size=20
    let mut pc: u32 = 0x829B95E8;
    'dispatch: loop {
        match pc {
            0x829B95E8 => {
    //   block [0x829B95E8..0x829B95FC)
	// 829B95E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B95EC: C1A40018  lfs f13, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B95F0: C00B9B3C  lfs f0, -0x64c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B95F4: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B95F8: 4BFFFFDC  b 0x829b95d4
	sub_829B95C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B95FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B95FC size=20
    let mut pc: u32 = 0x829B95FC;
    'dispatch: loop {
        match pc {
            0x829B95FC => {
    //   block [0x829B95FC..0x829B9610)
	// 829B95FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9600: C1A40018  lfs f13, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B9604: C00B9B3C  lfs f0, -0x64c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9608: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829B960C: 4BFFFFC8  b 0x829b95d4
	sub_829B95C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9610 size=12
    let mut pc: u32 = 0x829B9610;
    'dispatch: loop {
        match pc {
            0x829B9610 => {
    //   block [0x829B9610..0x829B961C)
	// 829B9610: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9614: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829B9618: 48000008  b 0x829b9620
	sub_829B961C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B961C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B961C size=48
    let mut pc: u32 = 0x829B961C;
    'dispatch: loop {
        match pc {
            0x829B961C => {
    //   block [0x829B961C..0x829B964C)
	// 829B961C: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9620: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9624: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829B9628: 396B9B3C  addi r11, r11, -0x64c4
	ctx.r[11].s64 = ctx.r[11].s64 + -25796;
	// 829B962C: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9630: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B9634: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829B9638: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B963C: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829B9640: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B9644: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B9648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B9650 size=548
    let mut pc: u32 = 0x829B9650;
    'dispatch: loop {
        match pc {
            0x829B9650 => {
    //   block [0x829B9650..0x829B9874)
	// 829B9650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9654: 487EEB19  bl 0x831a816c
	ctx.lr = 0x829B9658;
	sub_831A8130(ctx, base);
	// 829B9658: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829B965C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B9664: 4879AF9D  bl 0x83154600
	ctx.lr = 0x829B9668;
	sub_83154600(ctx, base);
	// 829B9668: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B966C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9670: 4BFFCDB1  bl 0x829b6420
	ctx.lr = 0x829B9674;
	sub_829B6420(ctx, base);
	// 829B9674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9678: 484A0101  bl 0x82e59778
	ctx.lr = 0x829B967C;
	sub_82E59778(ctx, base);
	// 829B967C: 897F0165  lbz r11, 0x165(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(357 as u32) ) } as u64;
	// 829B9680: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B9684: C01F0168  lfs f0, 0x168(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9688: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B968C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829B9690: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 829B9694: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829B9698: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B969C: 419800B4  blt cr6, 0x829b9750
	if ctx.cr[6].lt {
	pc = 0x829B9750; continue 'dispatch;
	}
	// 829B96A0: 409A0140  bne cr6, 0x829b97e0
	if !ctx.cr[6].eq {
	pc = 0x829B97E0; continue 'dispatch;
	}
	// 829B96A4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B96A8: C1AB9B54  lfs f13, -0x64ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25772 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B96AC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829B96B0: 41980130  blt cr6, 0x829b97e0
	if ctx.cr[6].lt {
	pc = 0x829B97E0; continue 'dispatch;
	}
	// 829B96B4: 815F0184  lwz r10, 0x184(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 829B96B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B96BC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829B96C0: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 829B96C4: 997F0165  stb r11, 0x165(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(357 as u32), ctx.r[11].u8 ) };
	// 829B96C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B96CC: 996A001C  stb r11, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 829B96D0: 4BB313B9  bl 0x824eaa88
	ctx.lr = 0x829B96D4;
	sub_824EAA88(ctx, base);
	// 829B96D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B96D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B96DC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B96E0: 4BB55CE9  bl 0x8250f3c8
	ctx.lr = 0x829B96E4;
	sub_8250F3C8(ctx, base);
	// 829B96E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B96E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B96EC: 4BB31925  bl 0x824eb010
	ctx.lr = 0x829B96F0;
	sub_824EB010(ctx, base);
	// 829B96F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B96F4: 895F016C  lbz r10, 0x16c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 829B96F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B96FC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 829B9700: C00B2960  lfs f0, 0x2960(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9704: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B9708: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829B970C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 829B9710: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829B9714: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829B9718: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829B971C: 997F016C  stb r11, 0x16c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u8 ) };
	// 829B9720: 48438571  bl 0x82df1c90
	ctx.lr = 0x829B9724;
	sub_82DF1C90(ctx, base);
	// 829B9724: 897F016C  lbz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 829B9728: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829B972C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829B9730: 4198000C  blt cr6, 0x829b973c
	if ctx.cr[6].lt {
	pc = 0x829B973C; continue 'dispatch;
	}
	// 829B9734: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 829B9738: 997F016C  stb r11, 0x16c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u8 ) };
	// 829B973C: 39600420  li r11, 0x420
	ctx.r[11].s64 = 1056;
	// 829B9740: 39400170  li r10, 0x170
	ctx.r[10].s64 = 368;
	// 829B9744: 13FE58C7  vcmpequd (lvx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B9878 size=52
    let mut pc: u32 = 0x829B9878;
    'dispatch: loop {
        match pc {
            0x829B9878 => {
    //   block [0x829B9878..0x829B98AC)
	// 829B9878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B987C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B9884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B988C: 4BFFFDC5  bl 0x829b9650
	ctx.lr = 0x829B9890;
	sub_829B9650(ctx, base);
	// 829B9890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9894: 4879AD6D  bl 0x83154600
	ctx.lr = 0x829B9898;
	sub_83154600(ctx, base);
	// 829B9898: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B989C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B98A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B98A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B98A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B98B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B98B0 size=172
    let mut pc: u32 = 0x829B98B0;
    'dispatch: loop {
        match pc {
            0x829B98B0 => {
    //   block [0x829B98B0..0x829B995C)
	// 829B98B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B98B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B98B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B98BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B98C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B98C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B98C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B98CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B98D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B98D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B98D8: 4B907061  bl 0x822c0938
	ctx.lr = 0x829B98DC;
	sub_822C0938(ctx, base);
	// 829B98DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B98E0: 41820028  beq 0x829b9908
	if ctx.cr[0].eq {
	pc = 0x829B9908; continue 'dispatch;
	}
	// 829B98E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B98E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B98EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B98F0: 392B2968  addi r9, r11, 0x2968
	ctx.r[9].s64 = ctx.r[11].s64 + 10600;
	// 829B98F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B98F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B98FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B9900: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B9904: 48000008  b 0x829b990c
	pc = 0x829B990C; continue 'dispatch;
	// 829B9908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B990C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B9910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B9914: 409A002C  bne cr6, 0x829b9940
	if !ctx.cr[6].eq {
	pc = 0x829B9940; continue 'dispatch;
	}
	// 829B9918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B991C: 4B90694D  bl 0x822c0268
	ctx.lr = 0x829B9920;
	sub_822C0268(ctx, base);
	// 829B9920: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9924: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B9928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B992C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B9930: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B9934: 816B9B70  lwz r11, -0x6490(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25744 as u32) ) } as u64;
	// 829B9938: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B993C: 4B9066C5  bl 0x822c0000
	ctx.lr = 0x829B9940;
	sub_822C0000(ctx, base);
	// 829B9940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B9944: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B9948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B994C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9950: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B9954: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B9958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B9960 size=484
    let mut pc: u32 = 0x829B9960;
    'dispatch: loop {
        match pc {
            0x829B9960 => {
    //   block [0x829B9960..0x829B9B44)
	// 829B9960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9964: 487EE805  bl 0x831a8168
	ctx.lr = 0x829B9968;
	sub_831A8130(ctx, base);
	// 829B9968: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829B996C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B9974: 4879AC8D  bl 0x83154600
	ctx.lr = 0x829B9978;
	sub_83154600(ctx, base);
	// 829B9978: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829B997C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9980: 4BFFCA59  bl 0x829b63d8
	ctx.lr = 0x829B9984;
	sub_829B63D8(ctx, base);
	// 829B9984: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B9988: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829B998C: 388B2978  addi r4, r11, 0x2978
	ctx.r[4].s64 = ctx.r[11].s64 + 10616;
	// 829B9990: 38A0014A  li r5, 0x14a
	ctx.r[5].s64 = 330;
	// 829B9994: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 829B9998: 4B906A41  bl 0x822c03d8
	ctx.lr = 0x829B999C;
	sub_822C03D8(ctx, base);
	// 829B999C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829B99A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829B99A4: 41820028  beq 0x829b99cc
	if ctx.cr[0].eq {
	pc = 0x829B99CC; continue 'dispatch;
	}
	// 829B99A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B99AC: C3FD0444  lfs f31, 0x444(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B99B0: 4BFE96B1  bl 0x829a3060
	ctx.lr = 0x829B99B4;
	sub_829A3060(ctx, base);
	// 829B99B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B99B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B99BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829B99C0: 4BFFFA49  bl 0x829b9408
	ctx.lr = 0x829B99C4;
	sub_829B9408(ctx, base);
	// 829B99C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B99C8: 48000008  b 0x829b99d0
	pc = 0x829B99D0; continue 'dispatch;
	// 829B99CC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 829B99D0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829B99D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B99D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B99DC: 4BFFFED5  bl 0x829b98b0
	ctx.lr = 0x829B99E0;
	sub_829B98B0(ctx, base);
	// 829B99E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B99E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829B99E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829B99EC: 4B906615  bl 0x822c0000
	ctx.lr = 0x829B99F0;
	sub_822C0000(ctx, base);
	// 829B99F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829B99F4: 3BDF0184  addi r30, r31, 0x184
	ctx.r[30].s64 = ctx.r[31].s64 + 388;
	// 829B99F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829B99FC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829B9A00: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 829B9A04: 4B90AA5D  bl 0x822c4460
	ctx.lr = 0x829B9A08;
	sub_822C4460(ctx, base);
	// 829B9A08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829B9A0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B9A10: 419A0008  beq cr6, 0x829b9a18
	if ctx.cr[6].eq {
	pc = 0x829B9A18; continue 'dispatch;
	}
	// 829B9A14: 4B906E7D  bl 0x822c0890
	ctx.lr = 0x829B9A18;
	sub_822C0890(ctx, base);
	// 829B9A18: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829B9A1C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B9A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B9A24: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B9A28: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B9A2C: 419A0024  beq cr6, 0x829b9a50
	if ctx.cr[6].eq {
	pc = 0x829B9A50; continue 'dispatch;
	}
	// 829B9A30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829B9A34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829B9A38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B9A3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829B9A40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829B9A44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829B9A48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829B9A4C: 4082FFE8  bne 0x829b9a34
	if !ctx.cr[0].eq {
	pc = 0x829B9A34; continue 'dispatch;
	}
	// 829B9A50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B9A54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829B9A58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B9A5C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829B9A60: 4BFEB601  bl 0x829a5060
	ctx.lr = 0x829B9A64;
	sub_829A5060(ctx, base);
	// 829B9A64: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829B9A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B9A6C: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829B9A70: 48439F99  bl 0x82df3a08
	ctx.lr = 0x829B9A74;
	sub_82DF3A08(ctx, base);
	// 829B9A74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B9A78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829B9A7C: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829B9A80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829B9A84: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829B9A88: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829B9A8C: 481F98ED  bl 0x82bb3378
	ctx.lr = 0x829B9A90;
	sub_82BB3378(ctx, base);
	// 829B9A90: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829B9A94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829B9A98: 419A0008  beq cr6, 0x829b9aa0
	if ctx.cr[6].eq {
	pc = 0x829B9AA0; continue 'dispatch;
	}
	// 829B9A9C: 4B906DF5  bl 0x822c0890
	ctx.lr = 0x829B9AA0;
	sub_822C0890(ctx, base);
	// 829B9AA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B9AA4: 48439985  bl 0x82df3428
	ctx.lr = 0x829B9AA8;
	sub_82DF3428(ctx, base);
	// 829B9AA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B9AAC: 9B9F0164  stb r28, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[28].u8 ) };
	// 829B9AB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B9AB4: 9B9F0165  stb r28, 0x165(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(357 as u32), ctx.r[28].u8 ) };
	// 829B9AB8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9ABC: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829B9AC0: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 829B9AC4: 4BB30FC5  bl 0x824eaa88
	ctx.lr = 0x829B9AC8;
	sub_824EAA88(ctx, base);
	// 829B9AC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B9ACC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B9AD0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B9AD4: 4BB558F5  bl 0x8250f3c8
	ctx.lr = 0x829B9AD8;
	sub_8250F3C8(ctx, base);
	// 829B9AD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B9ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B9AE0: 4BB31531  bl 0x824eb010
	ctx.lr = 0x829B9AE4;
	sub_824EB010(ctx, base);
	// 829B9AE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829B9AE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829B9AEC: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9AF0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829B9AF4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 829B9AF8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 829B9AFC: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 829B9B00: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 829B9B04: 997F016C  stb r11, 0x16c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u8 ) };
	// 829B9B08: 48438189  bl 0x82df1c90
	ctx.lr = 0x829B9B0C;
	sub_82DF1C90(ctx, base);
	// 829B9B0C: 39600420  li r11, 0x420
	ctx.r[11].s64 = 1056;
	// 829B9B10: 39400170  li r10, 0x170
	ctx.r[10].s64 = 368;
	// 829B9B14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829B9B18: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B9B48 size=84
    let mut pc: u32 = 0x829B9B48;
    'dispatch: loop {
        match pc {
            0x829B9B48 => {
    //   block [0x829B9B48..0x829B9B9C)
	// 829B9B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9B50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B9B54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9B58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B9B5C: 4BFE94D5  bl 0x829a3030
	ctx.lr = 0x829B9B60;
	sub_829A3030(ctx, base);
	// 829B9B60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B9B64: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829B9B68: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829B9B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9B70: 392929D0  addi r9, r9, 0x29d0
	ctx.r[9].s64 = ctx.r[9].s64 + 10704;
	// 829B9B74: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9B78: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829B9B7C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B9B80: C00A9C0C  lfs f0, -0x63f4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9B84: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829B9B88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B9B8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B9B90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9B94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B9B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829B9BA0 size=36
    let mut pc: u32 = 0x829B9BA0;
    'dispatch: loop {
        match pc {
            0x829B9BA0 => {
    //   block [0x829B9BA0..0x829B9BC4)
	// 829B9BA0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9BA4: C1A30014  lfs f13, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B9BA8: C00B9C2C  lfs f0, -0x63d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25556 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9BAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B9BB0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829B9BB4: 40980008  bge cr6, 0x829b9bbc
	if !ctx.cr[6].lt {
	pc = 0x829B9BBC; continue 'dispatch;
	}
	// 829B9BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B9BBC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B9BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B9BC8 size=100
    let mut pc: u32 = 0x829B9BC8;
    'dispatch: loop {
        match pc {
            0x829B9BC8 => {
    //   block [0x829B9BC8..0x829B9C2C)
	// 829B9BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9BCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9BD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B9BD8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 829B9BDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829B9BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B9BE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829B9BE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829B9BEC: 4E800421  bctrl
	ctx.lr = 0x829B9BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829B9BF0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9BF4: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829B9BF8: C1830004  lfs f12, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829B9BFC: C00B9C28  lfs f0, -0x63d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9C00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829B9C04: C1AA7BC4  lfs f13, 0x7bc4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829B9C08: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829B9C0C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 829B9C10: 40980008  bge cr6, 0x829b9c18
	if !ctx.cr[6].lt {
	pc = 0x829B9C18; continue 'dispatch;
	}
	// 829B9C14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B9C18: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829B9C1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B9C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B9C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829B9C30 size=264
    let mut pc: u32 = 0x829B9C30;
    'dispatch: loop {
        match pc {
            0x829B9C30 => {
    //   block [0x829B9C30..0x829B9D38)
	// 829B9C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B9C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B9C40: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829B9C44: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B9C4C: 4879A9B5  bl 0x83154600
	ctx.lr = 0x829B9C50;
	sub_83154600(ctx, base);
	// 829B9C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9C54: 4BFFC7CD  bl 0x829b6420
	ctx.lr = 0x829B9C58;
	sub_829B6420(ctx, base);
	// 829B9C58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B9C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9C60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829B9C64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B9C68: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829B9C6C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829B9C70: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829B9C74: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829B9C78: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829B9C7C: 480046DD  bl 0x829be358
	ctx.lr = 0x829B9C80;
	sub_829BE358(ctx, base);
	// 829B9C80: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829B9C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9C88: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 829B9C8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829B9C90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B9C94: 480046DD  bl 0x829be370
	ctx.lr = 0x829B9C98;
	sub_829BE370(ctx, base);
	// 829B9C98: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829B9C9C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829B9CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9CA4: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829B9CA8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829B9CAC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829B9CB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B9CB4: 480046A5  bl 0x829be358
	ctx.lr = 0x829B9CB8;
	sub_829BE358(ctx, base);
	// 829B9CB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B9CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9CC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829B9CC4: 480046AD  bl 0x829be370
	ctx.lr = 0x829B9CC8;
	sub_829BE370(ctx, base);
	// 829B9CC8: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829B9CCC: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829B9CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9CD4: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829B9CD8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829B9CDC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829B9CE0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829B9CE4: 48004675  bl 0x829be358
	ctx.lr = 0x829B9CE8;
	sub_829BE358(ctx, base);
	// 829B9CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9CEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829B9CF0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829B9CF4: 4800467D  bl 0x829be370
	ctx.lr = 0x829B9CF8;
	sub_829BE370(ctx, base);
	// 829B9CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9CFC: 4849FA65  bl 0x82e59760
	ctx.lr = 0x829B9D00;
	sub_82E59760(ctx, base);
	// 829B9D00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829B9D04: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829B9D08: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829B9D0C: 40990008  ble cr6, 0x829b9d14
	if !ctx.cr[6].gt {
	pc = 0x829B9D14; continue 'dispatch;
	}
	// 829B9D10: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 829B9D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9D18: 48004691  bl 0x829be3a8
	ctx.lr = 0x829B9D1C;
	sub_829BE3A8(ctx, base);
	// 829B9D1C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829B9D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B9D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9D28: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829B9D2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B9D30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B9D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829B9D38 size=476
    let mut pc: u32 = 0x829B9D38;
    'dispatch: loop {
        match pc {
            0x829B9D38 => {
    //   block [0x829B9D38..0x829B9F14)
	// 829B9D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9D3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9D40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B9D44: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 829B9D48: 487EED2D  bl 0x831a8a74
	ctx.lr = 0x829B9D4C;
	sub_831A8A40(ctx, base);
	// 829B9D4C: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B9F18 size=52
    let mut pc: u32 = 0x829B9F18;
    'dispatch: loop {
        match pc {
            0x829B9F18 => {
    //   block [0x829B9F18..0x829B9F4C)
	// 829B9F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B9F24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829B9F2C: 4BFFFD05  bl 0x829b9c30
	ctx.lr = 0x829B9F30;
	sub_829B9C30(ctx, base);
	// 829B9F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9F34: 4879A6CD  bl 0x83154600
	ctx.lr = 0x829B9F38;
	sub_83154600(ctx, base);
	// 829B9F38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829B9F3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B9F40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B9F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829B9F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829B9F50 size=172
    let mut pc: u32 = 0x829B9F50;
    'dispatch: loop {
        match pc {
            0x829B9F50 => {
    //   block [0x829B9F50..0x829B9FFC)
	// 829B9F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829B9F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829B9F58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829B9F5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829B9F60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829B9F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829B9F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B9F6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829B9F70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829B9F74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B9F78: 4B9069C1  bl 0x822c0938
	ctx.lr = 0x829B9F7C;
	sub_822C0938(ctx, base);
	// 829B9F7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829B9F80: 41820028  beq 0x829b9fa8
	if ctx.cr[0].eq {
	pc = 0x829B9FA8; continue 'dispatch;
	}
	// 829B9F84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829B9F88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829B9F8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829B9F90: 392B29E8  addi r9, r11, 0x29e8
	ctx.r[9].s64 = ctx.r[11].s64 + 10728;
	// 829B9F94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829B9F98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829B9F9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829B9FA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829B9FA4: 48000008  b 0x829b9fac
	pc = 0x829B9FAC; continue 'dispatch;
	// 829B9FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829B9FAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829B9FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829B9FB4: 409A002C  bne cr6, 0x829b9fe0
	if !ctx.cr[6].eq {
	pc = 0x829B9FE0; continue 'dispatch;
	}
	// 829B9FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829B9FBC: 4B9062AD  bl 0x822c0268
	ctx.lr = 0x829B9FC0;
	sub_822C0268(ctx, base);
	// 829B9FC0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829B9FC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829B9FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829B9FCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829B9FD0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829B9FD4: 816B9C5C  lwz r11, -0x63a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25508 as u32) ) } as u64;
	// 829B9FD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829B9FDC: 4B906025  bl 0x822c0000
	ctx.lr = 0x829B9FE0;
	sub_822C0000(ctx, base);
	// 829B9FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829B9FE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829B9FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829B9FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829B9FF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829B9FF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829B9FF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA000 size=300
    let mut pc: u32 = 0x829BA000;
    'dispatch: loop {
        match pc {
            0x829BA000 => {
    //   block [0x829BA000..0x829BA12C)
	// 829BA000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA004: 487EE169  bl 0x831a816c
	ctx.lr = 0x829BA008;
	sub_831A8130(ctx, base);
	// 829BA008: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA00C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BA010: 4879A5F1  bl 0x83154600
	ctx.lr = 0x829BA014;
	sub_83154600(ctx, base);
	// 829BA014: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BA018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BA01C: 4BFFC3BD  bl 0x829b63d8
	ctx.lr = 0x829BA020;
	sub_829B63D8(ctx, base);
	// 829BA020: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BA024: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BA028: 388B29F8  addi r4, r11, 0x29f8
	ctx.r[4].s64 = ctx.r[11].s64 + 10744;
	// 829BA02C: 38A00102  li r5, 0x102
	ctx.r[5].s64 = 258;
	// 829BA030: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829BA034: 4B9063A5  bl 0x822c03d8
	ctx.lr = 0x829BA038;
	sub_822C03D8(ctx, base);
	// 829BA038: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BA03C: 41820010  beq 0x829ba04c
	if ctx.cr[0].eq {
	pc = 0x829BA04C; continue 'dispatch;
	}
	// 829BA040: 4BFFFB09  bl 0x829b9b48
	ctx.lr = 0x829BA044;
	sub_829B9B48(ctx, base);
	// 829BA044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA048: 48000008  b 0x829ba050
	pc = 0x829BA050; continue 'dispatch;
	// 829BA04C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829BA050: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829BA054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BA058: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BA05C: 4BFFFEF5  bl 0x829b9f50
	ctx.lr = 0x829BA060;
	sub_829B9F50(ctx, base);
	// 829BA060: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BA064: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BA068: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BA06C: 4B905F95  bl 0x822c0000
	ctx.lr = 0x829BA070;
	sub_822C0000(ctx, base);
	// 829BA070: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BA074: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BA078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BA07C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829BA080: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BA084: 419A0024  beq cr6, 0x829ba0a8
	if ctx.cr[6].eq {
	pc = 0x829BA0A8; continue 'dispatch;
	}
	// 829BA088: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BA08C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BA090: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BA094: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BA098: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BA09C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BA0A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BA0A4: 4082FFE8  bne 0x829ba08c
	if !ctx.cr[0].eq {
	pc = 0x829BA08C; continue 'dispatch;
	}
	// 829BA0A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BA0AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829BA0B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BA0B4: C02B9524  lfs f1, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BA0B8: 4BFEAFA9  bl 0x829a5060
	ctx.lr = 0x829BA0BC;
	sub_829A5060(ctx, base);
	// 829BA0BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BA0C0: 419A000C  beq cr6, 0x829ba0cc
	if ctx.cr[6].eq {
	pc = 0x829BA0CC; continue 'dispatch;
	}
	// 829BA0C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA0C8: 4B9067C9  bl 0x822c0890
	ctx.lr = 0x829BA0CC;
	sub_822C0890(ctx, base);
	// 829BA0CC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829BA0D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BA0D4: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829BA0D8: 48439931  bl 0x82df3a08
	ctx.lr = 0x829BA0DC;
	sub_82DF3A08(ctx, base);
	// 829BA0DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BA0E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BA0E4: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BA0E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BA0EC: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BA0F0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BA0F4: 481F9285  bl 0x82bb3378
	ctx.lr = 0x829BA0F8;
	sub_82BB3378(ctx, base);
	// 829BA0F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BA0FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BA100: 419A0008  beq cr6, 0x829ba108
	if ctx.cr[6].eq {
	pc = 0x829BA108; continue 'dispatch;
	}
	// 829BA104: 4B90678D  bl 0x822c0890
	ctx.lr = 0x829BA108;
	sub_822C0890(ctx, base);
	// 829BA108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BA10C: 4843931D  bl 0x82df3428
	ctx.lr = 0x829BA110;
	sub_82DF3428(ctx, base);
	// 829BA110: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BA114: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829BA118: 995E0164  stb r10, 0x164(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(356 as u32), ctx.r[10].u8 ) };
	// 829BA11C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA120: D01E0160  stfs f0, 0x160(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BA124: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829BA128: 487EE094  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA130 size=84
    let mut pc: u32 = 0x829BA130;
    'dispatch: loop {
        match pc {
            0x829BA130 => {
    //   block [0x829BA130..0x829BA184)
	// 829BA130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BA138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BA13C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA144: 4BFE8EED  bl 0x829a3030
	ctx.lr = 0x829BA148;
	sub_829A3030(ctx, base);
	// 829BA148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BA14C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829BA150: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829BA154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA158: 39292A4C  addi r9, r9, 0x2a4c
	ctx.r[9].s64 = ctx.r[9].s64 + 10828;
	// 829BA15C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA160: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829BA164: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BA168: C00A9CF0  lfs f0, -0x6310(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA16C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BA170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BA174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BA178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BA17C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BA180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829BA188 size=36
    let mut pc: u32 = 0x829BA188;
    'dispatch: loop {
        match pc {
            0x829BA188 => {
    //   block [0x829BA188..0x829BA1AC)
	// 829BA188: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA18C: C1A30018  lfs f13, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA190: C00B9D10  lfs f0, -0x62f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA194: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829BA198: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829BA19C: 40980008  bge cr6, 0x829ba1a4
	if !ctx.cr[6].lt {
	pc = 0x829BA1A4; continue 'dispatch;
	}
	// 829BA1A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BA1A4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829BA1A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA1B0 size=548
    let mut pc: u32 = 0x829BA1B0;
    'dispatch: loop {
        match pc {
            0x829BA1B0 => {
    //   block [0x829BA1B0..0x829BA3D4)
	// 829BA1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA1B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BA1B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BA1BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BA1C0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 829BA1C4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829BA1C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA1CC: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA1D0: 3FC08212  lis r30, -0x7dee
	ctx.r[30].s64 = -2112749568;
	// 829BA1D4: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA1D8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829BA1DC: ED806824  fdivs f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829BA1E0: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829BA1E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA1E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BA1EC: C01EDFAC  lfs f0, -0x2054(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA1F0: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA1F4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BA1F8: EFEC0372  fmuls f31, f12, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BA1FC: 41980188  blt cr6, 0x829ba384
	if ctx.cr[6].lt {
	pc = 0x829BA384; continue 'dispatch;
	}
	// 829BA200: 419A0150  beq cr6, 0x829ba350
	if ctx.cr[6].eq {
	pc = 0x829BA350; continue 'dispatch;
	}
	// 829BA204: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BA208: 41980110  blt cr6, 0x829ba318
	if ctx.cr[6].lt {
	pc = 0x829BA318; continue 'dispatch;
	}
	// 829BA20C: 419A00B4  beq cr6, 0x829ba2c0
	if ctx.cr[6].eq {
	pc = 0x829BA2C0; continue 'dispatch;
	}
	// 829BA210: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829BA214: 41980078  blt cr6, 0x829ba28c
	if ctx.cr[6].lt {
	pc = 0x829BA28C; continue 'dispatch;
	}
	// 829BA218: 419A001C  beq cr6, 0x829ba234
	if ctx.cr[6].eq {
	pc = 0x829BA234; continue 'dispatch;
	}
	// 829BA21C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BA220: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA224: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BA228: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BA22C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BA230: 4800017C  b 0x829ba3ac
	pc = 0x829BA3AC; continue 'dispatch;
	// 829BA234: EC20F82A  fadds f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 829BA238: 487EEB91  bl 0x831a8dc8
	ctx.lr = 0x829BA23C;
	sub_831A8DC8(ctx, base);
	// 829BA23C: C01EDFAC  lfs f0, -0x2054(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA240: FFC00818  frsp f30, f1
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BA244: EC20F82A  fadds f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 829BA248: 487EEC61  bl 0x831a8ea8
	ctx.lr = 0x829BA24C;
	sub_831A8EA8(ctx, base);
	// 829BA24C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA250: 392B9D08  addi r9, r11, -0x62f8
	ctx.r[9].s64 = ctx.r[11].s64 + -25336;
	// 829BA254: C1AB9D08  lfs f13, -0x62f8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25336 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA258: C009FFF0  lfs f0, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA25C: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BA260: C169FFF8  lfs f11, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BA264: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA268: FD400818  frsp f10, f1
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BA26C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BA270: EC0907BA  fmadds f0, f9, f30, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BA274: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BA278: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BA27C: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BA280: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BA284: EC095AB8  fmsubs f0, f9, f10, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 829BA288: 48000124  b 0x829ba3ac
	pc = 0x829BA3AC; continue 'dispatch;
	// 829BA28C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BA290: 487EEB39  bl 0x831a8dc8
	ctx.lr = 0x829BA294;
	sub_831A8DC8(ctx, base);
	// 829BA294: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BA298: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BA29C: 487EEC0D  bl 0x831a8ea8
	ctx.lr = 0x829BA2A0;
	sub_831A8EA8(ctx, base);
	// 829BA2A0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA2A4: 396B9D08  addi r11, r11, -0x62f8
	ctx.r[11].s64 = ctx.r[11].s64 + -25336;
	// 829BA2A8: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA2AC: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA2B0: ED206828  fsubs f9, f0, f13
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BA2B4: C16BFFF8  lfs f11, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BA2B8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA2BC: 4BFFFFAC  b 0x829ba268
	pc = 0x829BA268; continue 'dispatch;
	// 829BA2C0: EC20F828  fsubs f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 829BA2C4: 487EEB05  bl 0x831a8dc8
	ctx.lr = 0x829BA2C8;
	sub_831A8DC8(ctx, base);
	// 829BA2C8: C01EDFAC  lfs f0, -0x2054(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA2CC: FFC00818  frsp f30, f1
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BA2D0: EC20F828  fsubs f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 829BA2D4: 487EEBD5  bl 0x831a8ea8
	ctx.lr = 0x829BA2D8;
	sub_831A8EA8(ctx, base);
	// 829BA2D8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA2DC: 392B9D08  addi r9, r11, -0x62f8
	ctx.r[9].s64 = ctx.r[11].s64 + -25336;
	// 829BA2E0: C1AB9D08  lfs f13, -0x62f8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25336 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA2E4: C009FFF0  lfs f0, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA2E8: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BA2EC: C169FFF8  lfs f11, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BA2F0: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA2F4: FD400818  frsp f10, f1
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BA2F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BA2FC: EC0907BA  fmadds f0, f9, f30, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 829BA300: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BA304: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BA308: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BA30C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BA310: EC095ABA  fmadds f0, f9, f10, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 829BA314: 48000098  b 0x829ba3ac
	pc = 0x829BA3AC; continue 'dispatch;
	// 829BA318: FFE0F850  fneg f31, f31
	ctx.f[31].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BA31C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BA320: 487EEAA9  bl 0x831a8dc8
	ctx.lr = 0x829BA324;
	sub_831A8DC8(ctx, base);
	// 829BA324: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BA328: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BA32C: 487EEB7D  bl 0x831a8ea8
	ctx.lr = 0x829BA330;
	sub_831A8EA8(ctx, base);
	// 829BA330: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA334: 396B9D08  addi r11, r11, -0x62f8
	ctx.r[11].s64 = ctx.r[11].s64 + -25336;
	// 829BA338: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA33C: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA340: ED206828  fsubs f9, f0, f13
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BA344: C16BFFF8  lfs f11, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BA348: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA34C: 4BFFFFA8  b 0x829ba2f4
	pc = 0x829BA2F4; continue 'dispatch;
	// 829BA350: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA354: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BA358: 396B9D08  addi r11, r11, -0x62f8
	ctx.r[11].s64 = ctx.r[11].s64 + -25336;
	// 829BA35C: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BA360: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA364: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BA368: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA36C: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA370: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BA374: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BA378: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BA37C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BA380: 48000030  b 0x829ba3b0
	pc = 0x829BA3B0; continue 'dispatch;
	// 829BA384: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA388: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BA38C: 396B9D08  addi r11, r11, -0x62f8
	ctx.r[11].s64 = ctx.r[11].s64 + -25336;
	// 829BA390: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BA394: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA398: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BA39C: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA3A0: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829BA3A4: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829BA3A8: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BA3AC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829BA3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA3B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829BA3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BA3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BA3C0: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829BA3C4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829BA3C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BA3CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BA3D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA3D8 size=284
    let mut pc: u32 = 0x829BA3D8;
    'dispatch: loop {
        match pc {
            0x829BA3D8 => {
    //   block [0x829BA3D8..0x829BA4F4)
	// 829BA3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA3DC: 487EDD91  bl 0x831a816c
	ctx.lr = 0x829BA3E0;
	sub_831A8130(ctx, base);
	// 829BA3E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA3E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA3E8: 4879A219  bl 0x83154600
	ctx.lr = 0x829BA3EC;
	sub_83154600(ctx, base);
	// 829BA3EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BA3F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA3F4: 4BFFC02D  bl 0x829b6420
	ctx.lr = 0x829BA3F8;
	sub_829B6420(ctx, base);
	// 829BA3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA3FC: 4849F365  bl 0x82e59760
	ctx.lr = 0x829BA400;
	sub_82E59760(ctx, base);
	// 829BA400: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA404: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 829BA408: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829BA40C: 3BAB9D18  addi r29, r11, -0x62e8
	ctx.r[29].s64 = ctx.r[11].s64 + -25320;
	// 829BA410: C1AB9D18  lfs f13, -0x62e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA414: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA418: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829BA41C: C0099524  lfs f0, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA420: EDA10372  fmuls f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 829BA424: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829BA428: 487EE9A1  bl 0x831a8dc8
	ctx.lr = 0x829BA42C;
	sub_831A8DC8(ctx, base);
	// 829BA42C: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829BA430: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BA434: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829BA438: C1BDFFFC  lfs f13, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA43C: 3BDE0420  addi r30, r30, 0x420
	ctx.r[30].s64 = ctx.r[30].s64 + 1056;
	// 829BA440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA444: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BA448: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA44C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BA450: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BA454: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BA458: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BA45C: EC0D0332  fmuls f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 829BA460: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BA464: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BA4F8 size=52
    let mut pc: u32 = 0x829BA4F8;
    'dispatch: loop {
        match pc {
            0x829BA4F8 => {
    //   block [0x829BA4F8..0x829BA52C)
	// 829BA4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA4FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BA500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BA504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA50C: 4BFFFECD  bl 0x829ba3d8
	ctx.lr = 0x829BA510;
	sub_829BA3D8(ctx, base);
	// 829BA510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA514: 4879A0ED  bl 0x83154600
	ctx.lr = 0x829BA518;
	sub_83154600(ctx, base);
	// 829BA518: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BA51C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BA520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BA524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BA528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BA530 size=172
    let mut pc: u32 = 0x829BA530;
    'dispatch: loop {
        match pc {
            0x829BA530 => {
    //   block [0x829BA530..0x829BA5DC)
	// 829BA530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BA538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BA53C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BA540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BA548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BA54C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829BA550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BA554: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BA558: 4B9063E1  bl 0x822c0938
	ctx.lr = 0x829BA55C;
	sub_822C0938(ctx, base);
	// 829BA55C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BA560: 41820028  beq 0x829ba588
	if ctx.cr[0].eq {
	pc = 0x829BA588; continue 'dispatch;
	}
	// 829BA564: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BA568: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829BA56C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BA570: 392B2A64  addi r9, r11, 0x2a64
	ctx.r[9].s64 = ctx.r[11].s64 + 10852;
	// 829BA574: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BA578: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BA57C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BA580: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829BA584: 48000008  b 0x829ba58c
	pc = 0x829BA58C; continue 'dispatch;
	// 829BA588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BA58C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BA590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BA594: 409A002C  bne cr6, 0x829ba5c0
	if !ctx.cr[6].eq {
	pc = 0x829BA5C0; continue 'dispatch;
	}
	// 829BA598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA59C: 4B905CCD  bl 0x822c0268
	ctx.lr = 0x829BA5A0;
	sub_822C0268(ctx, base);
	// 829BA5A0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA5A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BA5A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BA5AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829BA5B0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BA5B4: 816B9D24  lwz r11, -0x62dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25308 as u32) ) } as u64;
	// 829BA5B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BA5BC: 4B905A45  bl 0x822c0000
	ctx.lr = 0x829BA5C0;
	sub_822C0000(ctx, base);
	// 829BA5C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BA5C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BA5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BA5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BA5D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BA5D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BA5D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA5E0 size=300
    let mut pc: u32 = 0x829BA5E0;
    'dispatch: loop {
        match pc {
            0x829BA5E0 => {
    //   block [0x829BA5E0..0x829BA70C)
	// 829BA5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA5E4: 487EDB89  bl 0x831a816c
	ctx.lr = 0x829BA5E8;
	sub_831A8130(ctx, base);
	// 829BA5E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA5EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BA5F0: 4879A011  bl 0x83154600
	ctx.lr = 0x829BA5F4;
	sub_83154600(ctx, base);
	// 829BA5F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BA5F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BA5FC: 4BFFBDDD  bl 0x829b63d8
	ctx.lr = 0x829BA600;
	sub_829B63D8(ctx, base);
	// 829BA600: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BA604: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BA608: 388B2A78  addi r4, r11, 0x2a78
	ctx.r[4].s64 = ctx.r[11].s64 + 10872;
	// 829BA60C: 38A000E6  li r5, 0xe6
	ctx.r[5].s64 = 230;
	// 829BA610: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829BA614: 4B905DC5  bl 0x822c03d8
	ctx.lr = 0x829BA618;
	sub_822C03D8(ctx, base);
	// 829BA618: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BA61C: 41820010  beq 0x829ba62c
	if ctx.cr[0].eq {
	pc = 0x829BA62C; continue 'dispatch;
	}
	// 829BA620: 4BFFFB11  bl 0x829ba130
	ctx.lr = 0x829BA624;
	sub_829BA130(ctx, base);
	// 829BA624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA628: 48000008  b 0x829ba630
	pc = 0x829BA630; continue 'dispatch;
	// 829BA62C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829BA630: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829BA634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BA638: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BA63C: 4BFFFEF5  bl 0x829ba530
	ctx.lr = 0x829BA640;
	sub_829BA530(ctx, base);
	// 829BA640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829BA644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829BA648: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BA64C: 4B9059B5  bl 0x822c0000
	ctx.lr = 0x829BA650;
	sub_822C0000(ctx, base);
	// 829BA650: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BA654: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BA658: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BA65C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829BA660: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829BA664: 419A0024  beq cr6, 0x829ba688
	if ctx.cr[6].eq {
	pc = 0x829BA688; continue 'dispatch;
	}
	// 829BA668: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829BA66C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BA670: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BA674: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BA678: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BA67C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BA680: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BA684: 4082FFE8  bne 0x829ba66c
	if !ctx.cr[0].eq {
	pc = 0x829BA66C; continue 'dispatch;
	}
	// 829BA688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BA68C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829BA690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BA694: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829BA698: 4BFEA9C9  bl 0x829a5060
	ctx.lr = 0x829BA69C;
	sub_829A5060(ctx, base);
	// 829BA69C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829BA6A0: 419A000C  beq cr6, 0x829ba6ac
	if ctx.cr[6].eq {
	pc = 0x829BA6AC; continue 'dispatch;
	}
	// 829BA6A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA6A8: 4B9061E9  bl 0x822c0890
	ctx.lr = 0x829BA6AC;
	sub_822C0890(ctx, base);
	// 829BA6AC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 829BA6B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BA6B4: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 829BA6B8: 48439351  bl 0x82df3a08
	ctx.lr = 0x829BA6BC;
	sub_82DF3A08(ctx, base);
	// 829BA6BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BA6C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BA6C4: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BA6C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BA6CC: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BA6D0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BA6D4: 481F8CA5  bl 0x82bb3378
	ctx.lr = 0x829BA6D8;
	sub_82BB3378(ctx, base);
	// 829BA6D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BA6DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BA6E0: 419A0008  beq cr6, 0x829ba6e8
	if ctx.cr[6].eq {
	pc = 0x829BA6E8; continue 'dispatch;
	}
	// 829BA6E4: 4B9061AD  bl 0x822c0890
	ctx.lr = 0x829BA6E8;
	sub_822C0890(ctx, base);
	// 829BA6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BA6EC: 48438D3D  bl 0x82df3428
	ctx.lr = 0x829BA6F0;
	sub_82DF3428(ctx, base);
	// 829BA6F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BA6F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829BA6F8: 995E0164  stb r10, 0x164(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(356 as u32), ctx.r[10].u8 ) };
	// 829BA6FC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA700: D01E0160  stfs f0, 0x160(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BA704: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829BA708: 487EDAB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA710 size=92
    let mut pc: u32 = 0x829BA710;
    'dispatch: loop {
        match pc {
            0x829BA710 => {
    //   block [0x829BA710..0x829BA76C)
	// 829BA710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BA718: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BA71C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA720: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA724: 4BFE890D  bl 0x829a3030
	ctx.lr = 0x829BA728;
	sub_829A3030(ctx, base);
	// 829BA728: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BA72C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829BA730: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829BA734: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829BA738: 39292ACC  addi r9, r9, 0x2acc
	ctx.r[9].s64 = ctx.r[9].s64 + 10956;
	// 829BA73C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA740: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 829BA744: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829BA748: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BA74C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA750: C00A9DB8  lfs f0, -0x6248(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA754: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829BA758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BA75C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BA760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BA764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BA768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA770 size=412
    let mut pc: u32 = 0x829BA770;
    'dispatch: loop {
        match pc {
            0x829BA770 => {
    //   block [0x829BA770..0x829BA90C)
	// 829BA770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BA778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BA77C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA780: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 829BA784: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA788: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA78C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829BA790: 396B9DDC  addi r11, r11, -0x6224
	ctx.r[11].s64 = ctx.r[11].s64 + -25124;
	// 829BA794: 419800CC  blt cr6, 0x829ba860
	if ctx.cr[6].lt {
	pc = 0x829BA860; continue 'dispatch;
	}
	// 829BA798: 419A0098  beq cr6, 0x829ba830
	if ctx.cr[6].eq {
	pc = 0x829BA830; continue 'dispatch;
	}
	// 829BA79C: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 829BA7A0: 41980088  blt cr6, 0x829ba828
	if ctx.cr[6].lt {
	pc = 0x829BA828; continue 'dispatch;
	}
	// 829BA7A4: 419A0058  beq cr6, 0x829ba7fc
	if ctx.cr[6].eq {
	pc = 0x829BA7FC; continue 'dispatch;
	}
	// 829BA7A8: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 829BA7AC: 4198001C  blt cr6, 0x829ba7c8
	if ctx.cr[6].lt {
	pc = 0x829BA7C8; continue 'dispatch;
	}
	// 829BA7B0: 409A00E0  bne cr6, 0x829ba890
	if !ctx.cr[6].eq {
	pc = 0x829BA890; continue 'dispatch;
	}
	// 829BA7B4: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA7B8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BA7BC: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA7C0: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BA7C4: 480000A8  b 0x829ba86c
	pc = 0x829BA86C; continue 'dispatch;
	// 829BA7C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829BA7CC: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA7D0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829BA7D4: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA7D8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BA7DC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BA7E0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BA7E4: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA7E8: C1A908A4  lfs f13, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA7EC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BA7F0: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BA7F4: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BA7F8: 48000094  b 0x829ba88c
	pc = 0x829BA88C; continue 'dispatch;
	// 829BA7FC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829BA800: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA804: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829BA808: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BA80C: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA810: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BA814: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BA818: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA81C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BA820: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BA824: 4BFFFFD0  b 0x829ba7f4
	pc = 0x829BA7F4; continue 'dispatch;
	// 829BA828: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA82C: 4BFFFF90  b 0x829ba7bc
	pc = 0x829BA7BC; continue 'dispatch;
	// 829BA830: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BA834: C00BFFE0  lfs f0, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA838: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829BA83C: C1ABFFE4  lfs f13, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA840: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BA844: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BA848: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BA84C: C00BFFE8  lfs f0, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA850: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA854: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BA858: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BA85C: 4800002C  b 0x829ba888
	pc = 0x829BA888; continue 'dispatch;
	// 829BA860: C00BFFE0  lfs f0, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA864: C1ABFFE4  lfs f13, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BA868: C18BFFE8  lfs f12, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BA86C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BA870: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829BA874: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BA878: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829BA87C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829BA880: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BA884: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829BA888: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BA910 size=232
    //   switch @ 0x829BA990: r30 with 12 label(s)
    //       case  0  0x829BA9A0
    //       case  1  0x829BA9A8
    //       case  2  0x829BA9A8
    //       case  3  0x829BA9A8
    //       case  4  0x829BA9B0
    //       case  5  0x829BA9B8
    //       case  6  0x829BA9B0
    //       case  7  0x829BA9C0
    //       case  8  0x829BA9C8
    //       case  9  0x829BA9C0
    //       case 10  0x829BA9D0
    //       case 11  0x829BA9D8
    let mut pc: u32 = 0x829BA910;
    'dispatch: loop {
        match pc {
            0x829BA910 => {
    //   block [0x829BA910..0x829BA9A0)
	// 829BA910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BA918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BA91C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BA920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BA924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA928: 48799CD9  bl 0x83154600
	ctx.lr = 0x829BA92C;
	sub_83154600(ctx, base);
	// 829BA92C: 897F0164  lbz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829BA930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BA934: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829BA938: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 829BA93C: 419800A4  blt cr6, 0x829ba9e0
	if ctx.cr[6].lt {
	pc = 0x829BA9E0; continue 'dispatch;
	}
	// 829BA940: 4BFE8759  bl 0x829a3098
	ctx.lr = 0x829BA944;
	sub_829A3098(ctx, base);
	// 829BA944: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BA948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA94C: 7D7E0774  extsb r30, r11
	ctx.r[30].s64 = ctx.r[11].s8 as i64;
	// 829BA950: 4BFE8711  bl 0x829a3060
	ctx.lr = 0x829BA954;
	sub_829A3060(ctx, base);
	// 829BA954: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BA958: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829BA95C: 396B9E24  addi r11, r11, -0x61dc
	ctx.r[11].s64 = ctx.r[11].s64 + -25052;
	// 829BA960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BA964: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829BA968: 7C8BF0AE  lbzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 829BA96C: 4BFF465D  bl 0x829aefc8
	ctx.lr = 0x829BA970;
	sub_829AEFC8(ctx, base);
	// 829BA970: 2B1E000B  cmplwi cr6, r30, 0xb
	ctx.cr[6].compare_u32(ctx.r[30].u32, 11 as u32, &mut ctx.xer);
	// 829BA974: 4199006C  bgt cr6, 0x829ba9e0
	if ctx.cr[6].gt {
	pc = 0x829BA9E0; continue 'dispatch;
	}
	// 829BA978: 3D80820A  lis r12, -0x7df6
	ctx.r[12].s64 = -2113273856;
	// 829BA97C: 398C2AE0  addi r12, r12, 0x2ae0
	ctx.r[12].s64 = ctx.r[12].s64 + 10976;
	// 829BA980: 7C0CF0AE  lbzx r0, r12, r30
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 829BA984: 3D80829C  lis r12, -0x7d64
	ctx.r[12].s64 = -2103705600;
	// 829BA988: 398CA9A0  addi r12, r12, -0x5660
	ctx.r[12].s64 = ctx.r[12].s64 + -22112;
	// 829BA98C: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 829BA990: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 829BA994: 60000000  nop
	// 829BA998: 60000000  nop
	// 829BA99C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x829BA9A0 => {
    //   block [0x829BA9A0..0x829BA9A8)
	// 829BA9A0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829BA9A4: 48000038  b 0x829ba9dc
	pc = 0x829BA9DC; continue 'dispatch;
            }
            0x829BA9A8 => {
    //   block [0x829BA9A8..0x829BA9B0)
	// 829BA9A8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 829BA9AC: 48000030  b 0x829ba9dc
	pc = 0x829BA9DC; continue 'dispatch;
            }
            0x829BA9B0 => {
    //   block [0x829BA9B0..0x829BA9B8)
	// 829BA9B0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 829BA9B4: 48000028  b 0x829ba9dc
	pc = 0x829BA9DC; continue 'dispatch;
            }
            0x829BA9B8 => {
    //   block [0x829BA9B8..0x829BA9C0)
	// 829BA9B8: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 829BA9BC: 48000020  b 0x829ba9dc
	pc = 0x829BA9DC; continue 'dispatch;
            }
            0x829BA9C0 => {
    //   block [0x829BA9C0..0x829BA9C8)
	// 829BA9C0: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 829BA9C4: 48000018  b 0x829ba9dc
	pc = 0x829BA9DC; continue 'dispatch;
            }
            0x829BA9C8 => {
    //   block [0x829BA9C8..0x829BA9D0)
	// 829BA9C8: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 829BA9CC: 48000010  b 0x829ba9dc
	pc = 0x829BA9DC; continue 'dispatch;
            }
            0x829BA9D0 => {
    //   block [0x829BA9D0..0x829BA9D8)
	// 829BA9D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829BA9D4: 48000008  b 0x829ba9dc
	pc = 0x829BA9DC; continue 'dispatch;
            }
            0x829BA9D8 => {
    //   block [0x829BA9D8..0x829BA9F8)
	// 829BA9D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BA9DC: 997F03D8  stb r11, 0x3d8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(984 as u32), ctx.r[11].u8 ) };
	// 829BA9E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BA9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BA9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BA9EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BA9F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BA9F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BA9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BA9F8 size=140
    let mut pc: u32 = 0x829BA9F8;
    'dispatch: loop {
        match pc {
            0x829BA9F8 => {
    //   block [0x829BA9F8..0x829BAA84)
	// 829BA9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BA9FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BAA00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BAA04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BAA08: 48799BF9  bl 0x83154600
	ctx.lr = 0x829BAA0C;
	sub_83154600(ctx, base);
	// 829BAA0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BAA10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BAA14: 4BFEC45D  bl 0x829a6e70
	ctx.lr = 0x829BAA18;
	sub_829A6E70(ctx, base);
	// 829BAA18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BAA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BAA20: 4BFEA349  bl 0x829a4d68
	ctx.lr = 0x829BAA24;
	sub_829A4D68(ctx, base);
	// 829BAA24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BAA28: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 829BAA2C: B17F03BC  sth r11, 0x3bc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[11].u16 ) };
	// 829BAA30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BAA34: 388AD748  addi r4, r10, -0x28b8
	ctx.r[4].s64 = ctx.r[10].s64 + -10424;
	// 829BAA38: 48438FD1  bl 0x82df3a08
	ctx.lr = 0x829BAA3C;
	sub_82DF3A08(ctx, base);
	// 829BAA3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BAA40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BAA44: 809F0170  lwz r4, 0x170(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BAA48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829BAA4C: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BAA50: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BAA54: 481F8925  bl 0x82bb3378
	ctx.lr = 0x829BAA58;
	sub_82BB3378(ctx, base);
	// 829BAA58: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BAA5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BAA60: 419A0008  beq cr6, 0x829baa68
	if ctx.cr[6].eq {
	pc = 0x829BAA68; continue 'dispatch;
	}
	// 829BAA64: 4B905E2D  bl 0x822c0890
	ctx.lr = 0x829BAA68;
	sub_822C0890(ctx, base);
	// 829BAA68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BAA6C: 484389BD  bl 0x82df3428
	ctx.lr = 0x829BAA70;
	sub_82DF3428(ctx, base);
	// 829BAA70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BAA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BAA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BAA7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BAA80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BAA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BAA88 size=460
    let mut pc: u32 = 0x829BAA88;
    'dispatch: loop {
        match pc {
            0x829BAA88 => {
    //   block [0x829BAA88..0x829BAC54)
	// 829BAA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BAA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BAA90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BAA94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BAA98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BAA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BAAA0: 48799B61  bl 0x83154600
	ctx.lr = 0x829BAAA4;
	sub_83154600(ctx, base);
	// 829BAAA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BAAA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BAAAC: 4849ECCD  bl 0x82e59778
	ctx.lr = 0x829BAAB0;
	sub_82E59778(ctx, base);
	// 829BAAB0: 897F0164  lbz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829BAAB4: C01F0160  lfs f0, 0x160(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BAAB8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829BAABC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829BAAC0: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BAAC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829BAAC8: 41980110  blt cr6, 0x829babd8
	if ctx.cr[6].lt {
	pc = 0x829BABD8; continue 'dispatch;
	}
	// 829BAACC: 419A0070  beq cr6, 0x829bab3c
	if ctx.cr[6].eq {
	pc = 0x829BAB3C; continue 'dispatch;
	}
	// 829BAAD0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829BAAD4: 40980168  bge cr6, 0x829bac3c
	if !ctx.cr[6].lt {
	pc = 0x829BAC3C; continue 'dispatch;
	}
	// 829BAAD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BAADC: C1AB9524  lfs f13, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BAAE0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829BAAE4: 41980158  blt cr6, 0x829bac3c
	if ctx.cr[6].lt {
	pc = 0x829BAC3C; continue 'dispatch;
	}
	// 829BAAE8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829BAAEC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BAAF0: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BAAF4: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 829BAAF8: 997F0164  stb r11, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u8 ) };
	// 829BAAFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BAB00: 388AD748  addi r4, r10, -0x28b8
	ctx.r[4].s64 = ctx.r[10].s64 + -10424;
	// 829BAB04: 48438F05  bl 0x82df3a08
	ctx.lr = 0x829BAB08;
	sub_82DF3A08(ctx, base);
	// 829BAB08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BAB0C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BAB10: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BAB14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829BAB18: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BAB1C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BAB20: 481F8859  bl 0x82bb3378
	ctx.lr = 0x829BAB24;
	sub_82BB3378(ctx, base);
	// 829BAB24: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829BAB28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BAB2C: 419A0008  beq cr6, 0x829bab34
	if ctx.cr[6].eq {
	pc = 0x829BAB34; continue 'dispatch;
	}
	// 829BAB30: 4B905D61  bl 0x822c0890
	ctx.lr = 0x829BAB34;
	sub_822C0890(ctx, base);
	// 829BAB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BAB38: 48000100  b 0x829bac38
	pc = 0x829BAC38; continue 'dispatch;
	// 829BAB3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BAB40: 4849EC21  bl 0x82e59760
	ctx.lr = 0x829BAB44;
	sub_82E59760(ctx, base);
	// 829BAB44: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BAB48: C1AB9DE0  lfs f13, -0x6220(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BAB4C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 829BAB50: 419800EC  blt cr6, 0x829bac3c
	if ctx.cr[6].lt {
	pc = 0x829BAC3C; continue 'dispatch;
	}
	// 829BAB54: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829BAB58: 897F0164  lbz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829BAB5C: C19F0160  lfs f12, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BAB60: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829BAB64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829BAB68: 38891F64  addi r4, r9, 0x1f64
	ctx.r[4].s64 = ctx.r[9].s64 + 8036;
	// 829BAB6C: 997F0164  stb r11, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u8 ) };
	// 829BAB70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BAB74: C00A2F20  lfs f0, 0x2f20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BAB78: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BAB7C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 829BAB80: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BAB84: 48438E85  bl 0x82df3a08
	ctx.lr = 0x829BAB88;
	sub_82DF3A08(ctx, base);
	// 829BAB88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BAB8C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829BAB90: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BAB94: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829BAB98: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BAB9C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BABA0: 481F87D9  bl 0x82bb3378
	ctx.lr = 0x829BABA4;
	sub_82BB3378(ctx, base);
	// 829BABA4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829BABA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BABAC: 419A0008  beq cr6, 0x829babb4
	if ctx.cr[6].eq {
	pc = 0x829BABB4; continue 'dispatch;
	}
	// 829BABB0: 4B905CE1  bl 0x822c0890
	ctx.lr = 0x829BABB4;
	sub_822C0890(ctx, base);
	// 829BABB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BABB8: 48438871  bl 0x82df3428
	ctx.lr = 0x829BABBC;
	sub_82DF3428(ctx, base);
	// 829BABBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BABC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BABC4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BABC8: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829BABCC: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829BABD0: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 829BABD4: 48000068  b 0x829bac3c
	pc = 0x829BAC3C; continue 'dispatch;
	// 829BABD8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829BABDC: C1AB2F20  lfs f13, 0x2f20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BABE0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829BABE4: 41980058  blt cr6, 0x829bac3c
	if ctx.cr[6].lt {
	pc = 0x829BAC3C; continue 'dispatch;
	}
	// 829BABE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829BABEC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829BABF0: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BABF4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829BABF8: 997F0164  stb r11, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u8 ) };
	// 829BABFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829BAC00: 388A1F88  addi r4, r10, 0x1f88
	ctx.r[4].s64 = ctx.r[10].s64 + 8072;
	// 829BAC04: 48438E05  bl 0x82df3a08
	ctx.lr = 0x829BAC08;
	sub_82DF3A08(ctx, base);
	// 829BAC08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BAC0C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829BAC10: 809E0170  lwz r4, 0x170(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BAC14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829BAC18: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BAC1C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BAC20: 481F8759  bl 0x82bb3378
	ctx.lr = 0x829BAC24;
	sub_82BB3378(ctx, base);
	// 829BAC24: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829BAC28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BAC2C: 419A0008  beq cr6, 0x829bac34
	if ctx.cr[6].eq {
	pc = 0x829BAC34; continue 'dispatch;
	}
	// 829BAC30: 4B905C61  bl 0x822c0890
	ctx.lr = 0x829BAC34;
	sub_822C0890(ctx, base);
	// 829BAC34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829BAC38: 484387F1  bl 0x82df3428
	ctx.lr = 0x829BAC3C;
	sub_82DF3428(ctx, base);
	// 829BAC3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829BAC40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BAC44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BAC48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BAC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BAC50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BAC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BAC58 size=1028
    let mut pc: u32 = 0x829BAC58;
    'dispatch: loop {
        match pc {
            0x829BAC58 => {
    //   block [0x829BAC58..0x829BB05C)
	// 829BAC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BAC5C: 487ED511  bl 0x831a816c
	ctx.lr = 0x829BAC60;
	sub_831A8130(ctx, base);
	// 829BAC60: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 829BAC64: 487EDE15  bl 0x831a8a78
	ctx.lr = 0x829BAC68;
	sub_831A8A40(ctx, base);
	// 829BAC68: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BAC6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BAC70: 48799991  bl 0x83154600
	ctx.lr = 0x829BAC74;
	sub_83154600(ctx, base);
	// 829BAC74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BAC78: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 829BAC7C: 38A10170  addi r5, r1, 0x170
	ctx.r[5].s64 = ctx.r[1].s64 + 368;
	// 829BAC80: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 829BAC84: 807E03F0  lwz r3, 0x3f0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BAC88: 4B9153D1  bl 0x822d0058
	ctx.lr = 0x829BAC8C;
	sub_822D0058(ctx, base);
	// 829BAC8C: 39610110  addi r11, r1, 0x110
	ctx.r[11].s64 = ctx.r[1].s64 + 272;
	// 829BAC90: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BAC94: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829BAC98: C1A10084  lfs f13, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BAC9C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829BACA0: C1810088  lfs f12, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BACA4: C161008C  lfs f11, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BACA8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 829BACAC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BACB0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829BACB4: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BACB8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BACBC: 13FE50C7  vcmpequd (lvx128) v31, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BACC0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BB060 size=172
    let mut pc: u32 = 0x829BB060;
    'dispatch: loop {
        match pc {
            0x829BB060 => {
    //   block [0x829BB060..0x829BB10C)
	// 829BB060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BB068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829BB06C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BB070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB074: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BB078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BB07C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829BB080: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829BB084: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BB088: 4B9058B1  bl 0x822c0938
	ctx.lr = 0x829BB08C;
	sub_822C0938(ctx, base);
	// 829BB08C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BB090: 41820028  beq 0x829bb0b8
	if ctx.cr[0].eq {
	pc = 0x829BB0B8; continue 'dispatch;
	}
	// 829BB094: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BB098: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829BB09C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829BB0A0: 392B2B14  addi r9, r11, 0x2b14
	ctx.r[9].s64 = ctx.r[11].s64 + 11028;
	// 829BB0A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829BB0A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829BB0AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829BB0B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829BB0B4: 48000008  b 0x829bb0bc
	pc = 0x829BB0BC; continue 'dispatch;
	// 829BB0B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829BB0BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829BB0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BB0C4: 409A002C  bne cr6, 0x829bb0f0
	if !ctx.cr[6].eq {
	pc = 0x829BB0F0; continue 'dispatch;
	}
	// 829BB0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB0CC: 4B90519D  bl 0x822c0268
	ctx.lr = 0x829BB0D0;
	sub_822C0268(ctx, base);
	// 829BB0D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829BB0D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829BB0D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BB0DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829BB0E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BB0E4: 816B9DF0  lwz r11, -0x6210(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25104 as u32) ) } as u64;
	// 829BB0E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BB0EC: 4B904F15  bl 0x822c0000
	ctx.lr = 0x829BB0F0;
	sub_822C0000(ctx, base);
	// 829BB0F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829BB0F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829BB0F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BB0FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BB100: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829BB104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BB108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829BB110 size=68
    let mut pc: u32 = 0x829BB110;
    'dispatch: loop {
        match pc {
            0x829BB110 => {
    //   block [0x829BB110..0x829BB154)
	// 829BB110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829BB118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829BB11C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BB124: 487994DD  bl 0x83154600
	ctx.lr = 0x829BB128;
	sub_83154600(ctx, base);
	// 829BB128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB12C: 4BFFF95D  bl 0x829baa88
	ctx.lr = 0x829BB130;
	sub_829BAA88(ctx, base);
	// 829BB130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB134: 4BFFFB25  bl 0x829bac58
	ctx.lr = 0x829BB138;
	sub_829BAC58(ctx, base);
	// 829BB138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB13C: 4BFFF7D5  bl 0x829ba910
	ctx.lr = 0x829BB140;
	sub_829BA910(ctx, base);
	// 829BB140: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829BB144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829BB148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829BB14C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829BB150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829BB158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829BB158 size=556
    let mut pc: u32 = 0x829BB158;
    'dispatch: loop {
        match pc {
            0x829BB158 => {
    //   block [0x829BB158..0x829BB384)
	// 829BB158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829BB15C: 487ED011  bl 0x831a816c
	ctx.lr = 0x829BB160;
	sub_831A8130(ctx, base);
	// 829BB160: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829BB164: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829BB168: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829BB16C: 48799495  bl 0x83154600
	ctx.lr = 0x829BB170;
	sub_83154600(ctx, base);
	// 829BB170: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829BB174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB178: 48003141  bl 0x829be2b8
	ctx.lr = 0x829BB17C;
	sub_829BE2B8(ctx, base);
	// 829BB17C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829BB180: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829BB184: 388B2B28  addi r4, r11, 0x2b28
	ctx.r[4].s64 = ctx.r[11].s64 + 11048;
	// 829BB188: 38A000C0  li r5, 0xc0
	ctx.r[5].s64 = 192;
	// 829BB18C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829BB190: 4B905249  bl 0x822c03d8
	ctx.lr = 0x829BB194;
	sub_822C03D8(ctx, base);
	// 829BB194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829BB198: 41820010  beq 0x829bb1a8
	if ctx.cr[0].eq {
	pc = 0x829BB1A8; continue 'dispatch;
	}
	// 829BB19C: 4BFFF575  bl 0x829ba710
	ctx.lr = 0x829BB1A0;
	sub_829BA710(ctx, base);
	// 829BB1A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829BB1A4: 48000008  b 0x829bb1ac
	pc = 0x829BB1AC; continue 'dispatch;
	// 829BB1A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829BB1AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829BB1B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829BB1B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BB1B8: 4BFFFEA9  bl 0x829bb060
	ctx.lr = 0x829BB1BC;
	sub_829BB060(ctx, base);
	// 829BB1BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BB1C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829BB1C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829BB1C8: 4B904E39  bl 0x822c0000
	ctx.lr = 0x829BB1CC;
	sub_822C0000(ctx, base);
	// 829BB1CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829BB1D0: 3BDF0168  addi r30, r31, 0x168
	ctx.r[30].s64 = ctx.r[31].s64 + 360;
	// 829BB1D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829BB1D8: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829BB1DC: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 829BB1E0: 4B909281  bl 0x822c4460
	ctx.lr = 0x829BB1E4;
	sub_822C4460(ctx, base);
	// 829BB1E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829BB1E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BB1EC: 419A0008  beq cr6, 0x829bb1f4
	if ctx.cr[6].eq {
	pc = 0x829BB1F4; continue 'dispatch;
	}
	// 829BB1F0: 4B9056A1  bl 0x822c0890
	ctx.lr = 0x829BB1F4;
	sub_822C0890(ctx, base);
	// 829BB1F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829BB1F8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829BB1FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829BB200: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829BB204: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829BB208: 419A0024  beq cr6, 0x829bb22c
	if ctx.cr[6].eq {
	pc = 0x829BB22C; continue 'dispatch;
	}
	// 829BB20C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829BB210: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829BB214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BB218: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829BB21C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829BB220: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829BB224: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829BB228: 4082FFE8  bne 0x829bb210
	if !ctx.cr[0].eq {
	pc = 0x829BB210; continue 'dispatch;
	}
	// 829BB22C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BB230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829BB234: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BB238: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829BB23C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BB240: 4BFE9E21  bl 0x829a5060
	ctx.lr = 0x829BB244;
	sub_829A5060(ctx, base);
	// 829BB244: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BB248: 4BFEE321  bl 0x829a9568
	ctx.lr = 0x829BB24C;
	sub_829A9568(ctx, base);
	// 829BB24C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BB250: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829BB254: 4BFEBC1D  bl 0x829a6e70
	ctx.lr = 0x829BB258;
	sub_829A6E70(ctx, base);
	// 829BB258: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829BB25C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829BB260: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 829BB264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB268: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BB26C: 48003105  bl 0x829be370
	ctx.lr = 0x829BB270;
	sub_829BE370(ctx, base);
	// 829BB270: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BB274: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829BB278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB27C: 480030F5  bl 0x829be370
	ctx.lr = 0x829BB280;
	sub_829BE370(ctx, base);
	// 829BB280: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829BB284: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829BB288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB28C: 480030E5  bl 0x829be370
	ctx.lr = 0x829BB290;
	sub_829BE370(ctx, base);
	// 829BB290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB294: 4849E4CD  bl 0x82e59760
	ctx.lr = 0x829BB298;
	sub_82E59760(ctx, base);
	// 829BB298: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 829BB29C: 40990008  ble cr6, 0x829bb2a4
	if !ctx.cr[6].gt {
	pc = 0x829BB2A4; continue 'dispatch;
	}
	// 829BB2A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829BB2A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829BB2A8: 48003101  bl 0x829be3a8
	ctx.lr = 0x829BB2AC;
	sub_829BE3A8(ctx, base);
	// 829BB2AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829BB2B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829BB2B4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829BB2B8: 995F0164  stb r10, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u8 ) };
	// 829BB2BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BB2C0: 38891FAC  addi r4, r9, 0x1fac
	ctx.r[4].s64 = ctx.r[9].s64 + 8108;
	// 829BB2C4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BB2C8: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829BB2CC: 4843873D  bl 0x82df3a08
	ctx.lr = 0x829BB2D0;
	sub_82DF3A08(ctx, base);
	// 829BB2D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829BB2D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829BB2D8: 809D0170  lwz r4, 0x170(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 829BB2DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829BB2E0: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829BB2E4: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829BB2E8: 481F8091  bl 0x82bb3378
	ctx.lr = 0x829BB2EC;
	sub_82BB3378(ctx, base);
	// 829BB2EC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829BB2F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829BB2F4: 419A0008  beq cr6, 0x829bb2fc
	if ctx.cr[6].eq {
	pc = 0x829BB2FC; continue 'dispatch;
	}
	// 829BB2F8: 4B905599  bl 0x822c0890
	ctx.lr = 0x829BB2FC;
	sub_822C0890(ctx, base);
	// 829BB2FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829BB300: 48438129  bl 0x82df3428
	ctx.lr = 0x829BB304;
	sub_82DF3428(ctx, base);
	// 829BB304: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 829BB308: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 829BB30C: 807D03F0  lwz r3, 0x3f0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1008 as u32) ) } as u64;
	// 829BB310: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829BB314: 4B914D45  bl 0x822d0058
	ctx.lr = 0x829BB318;
	sub_822D0058(ctx, base);
	// 829BB318: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 829BB31C: 394003E0  li r10, 0x3e0
	ctx.r[10].s64 = 992;
	// 829BB320: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829BB324: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 829BB328: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829BB32C: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829BB330: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BB334: C161006C  lfs f11, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829BB338: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BB33C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BB340: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 829BB344: 13FD50C7  vcmpequd (lvx128) v31, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829BB348: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


