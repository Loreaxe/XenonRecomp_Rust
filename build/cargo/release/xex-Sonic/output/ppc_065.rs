pub fn sub_8269A008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8269A008 size=116
    let mut pc: u32 = 0x8269A008;
    'dispatch: loop {
        match pc {
            0x8269A008 => {
    //   block [0x8269A008..0x8269A07C)
	// 8269A008: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269A00C: C1630120  lfs f11, 0x120(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269A010: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8269A014: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8269A018: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 8269A01C: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8269A020: C18B9450  lfs f12, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269A024: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269A028: C1AA0A90  lfs f13, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269A02C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8269A030: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A034: ED8B6B3C  fnmsubs f12, f11, f12, f13
	ctx.f[12].f64 = -(((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8269A038: D181FFF0  stfs f12, -0x10(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8269A03C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8269A040: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8269A044: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8269A048: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8269A04C: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A080 size=316
    let mut pc: u32 = 0x8269A080;
    'dispatch: loop {
        match pc {
            0x8269A080 => {
    //   block [0x8269A080..0x8269A1BC)
	// 8269A080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A08C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8269A090: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A098: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269A09C: C01F0130  lfs f0, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A0A0: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269A0A4: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8269A0A8: 419A00FC  beq cr6, 0x8269a1a4
	if ctx.cr[6].eq {
	pc = 0x8269A1A4; continue 'dispatch;
	}
	// 8269A0AC: C01F0134  lfs f0, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A0B0: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8269A0B4: 419A00F0  beq cr6, 0x8269a1a4
	if ctx.cr[6].eq {
	pc = 0x8269A1A4; continue 'dispatch;
	}
	// 8269A0B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269A0BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269A0C0: 4BE75409  bl 0x8250f4c8
	ctx.lr = 0x8269A0C4;
	sub_8250F4C8(ctx, base);
	// 8269A0C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269A0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269A0CC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269A0D0: 409A0008  bne cr6, 0x8269a0d8
	if !ctx.cr[6].eq {
	pc = 0x8269A0D8; continue 'dispatch;
	}
	// 8269A0D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269A0D8: 4BE6E441  bl 0x82508518
	ctx.lr = 0x8269A0DC;
	sub_82508518(ctx, base);
	// 8269A0DC: C01F0138  lfs f0, 0x138(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A0E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269A0E4: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8269A0E8: 48757BA9  bl 0x82df1c90
	ctx.lr = 0x8269A0EC;
	sub_82DF1C90(ctx, base);
	// 8269A0EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269A0F0: C01F0134  lfs f0, 0x134(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A0F4: C17F013C  lfs f11, 0x13c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269A0F8: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269A0FC: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8269A100: EDAB602A  fadds f13, f11, f12
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 8269A104: ED5F6824  fdivs f10, f31, f13
	ctx.f[10].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 8269A108: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 8269A10C: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 8269A110: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269A114: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 8269A118: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 8269A11C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269A120: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8269A124: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8269A128: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8269A12C: EDAAFB7C  fnmsubs f13, f10, f13, f31
	ctx.f[13].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 8269A130: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 8269A134: 4098001C  bge cr6, 0x8269a150
	if !ctx.cr[6].lt {
	pc = 0x8269A150; continue 'dispatch;
	}
	// 8269A138: 4082000C  bne 0x8269a144
	if !ctx.cr[0].eq {
	pc = 0x8269A144; continue 'dispatch;
	}
	// 8269A13C: C03F0130  lfs f1, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269A140: 48000064  b 0x8269a1a4
	pc = 0x8269A1A4; continue 'dispatch;
	// 8269A144: C01F0130  lfs f0, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A148: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8269A14C: 48000058  b 0x8269a1a4
	pc = 0x8269A1A4; continue 'dispatch;
	// 8269A150: C17F013C  lfs f11, 0x13c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269A154: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 8269A158: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8269A15C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8269A160: 4082001C  bne 0x8269a17c
	if !ctx.cr[0].eq {
	pc = 0x8269A17C; continue 'dispatch;
	}
	// 8269A164: C18BDFAC  lfs f12, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269A168: C16A9524  lfs f11, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269A16C: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 8269A170: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 8269A174: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8269A178: 4800001C  b 0x8269a194
	pc = 0x8269A194; continue 'dispatch;
	// 8269A17C: ED6D602A  fadds f11, f13, f12
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8269A180: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269A184: C18A9524  lfs f12, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269A188: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8269A18C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 8269A190: EC2002F2  fmuls f1, f0, f11
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 8269A194: 48B0ED15  bl 0x831a8ea8
	ctx.lr = 0x8269A198;
	sub_831A8EA8(ctx, base);
	// 8269A198: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8269A19C: C1BF0130  lfs f13, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269A1A0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8269A1A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269A1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269A1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269A1B0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269A1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269A1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A1C0 size=156
    let mut pc: u32 = 0x8269A1C0;
    'dispatch: loop {
        match pc {
            0x8269A1C0 => {
    //   block [0x8269A1C0..0x8269A25C)
	// 8269A1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A1C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A1CC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8269A1D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A1D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A1D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269A1DC: C01F0130  lfs f0, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A1E0: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269A1E4: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8269A1E8: 419A005C  beq cr6, 0x8269a244
	if ctx.cr[6].eq {
	pc = 0x8269A244; continue 'dispatch;
	}
	// 8269A1EC: C01F0134  lfs f0, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A1F0: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8269A1F4: 419A0050  beq cr6, 0x8269a244
	if ctx.cr[6].eq {
	pc = 0x8269A244; continue 'dispatch;
	}
	// 8269A1F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269A1FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269A200: 4BE752C9  bl 0x8250f4c8
	ctx.lr = 0x8269A204;
	sub_8250F4C8(ctx, base);
	// 8269A204: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269A208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269A20C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269A210: 409A0008  bne cr6, 0x8269a218
	if !ctx.cr[6].eq {
	pc = 0x8269A218; continue 'dispatch;
	}
	// 8269A214: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269A218: 4BE6E301  bl 0x82508518
	ctx.lr = 0x8269A21C;
	sub_82508518(ctx, base);
	// 8269A21C: C01F0138  lfs f0, 0x138(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269A224: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8269A228: 48757A69  bl 0x82df1c90
	ctx.lr = 0x8269A22C;
	sub_82DF1C90(ctx, base);
	// 8269A22C: C05F0130  lfs f2, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8269A230: C01F0134  lfs f0, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A234: EC020024  fdivs f0, f2, f0
	ctx.f[0].f64 = ((ctx.f[2].f64 / ctx.f[0].f64) as f32) as f64;
	// 8269A238: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8269A23C: 48B105D5  bl 0x831aa810
	ctx.lr = 0x8269A240;
	sub_831AA810(ctx, base);
	// 8269A240: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8269A244: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269A248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269A24C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269A250: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269A254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269A258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A260 size=76
    let mut pc: u32 = 0x8269A260;
    'dispatch: loop {
        match pc {
            0x8269A260 => {
    //   block [0x8269A260..0x8269A2AC)
	// 8269A260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A26C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269A274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A278: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269A27C: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8269A280: C03F003C  lfs f1, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269A284: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 8269A288: 487E1CE9  bl 0x82e7bf70
	ctx.lr = 0x8269A28C;
	sub_82E7BF70(ctx, base);
	// 8269A28C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269A290: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8269A294: 48778FCD  bl 0x82e13260
	ctx.lr = 0x8269A298;
	sub_82E13260(ctx, base);
	// 8269A298: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8269A29C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269A2A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269A2A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269A2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A2B0 size=168
    let mut pc: u32 = 0x8269A2B0;
    'dispatch: loop {
        match pc {
            0x8269A2B0 => {
    //   block [0x8269A2B0..0x8269A358)
	// 8269A2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A2BC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8269A2C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A2C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A2C8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8269A2CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269A2D0: 809F0118  lwz r4, 0x118(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 8269A2D4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269A2D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8269A2DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269A2E0: 4E800421  bctrl
	ctx.lr = 0x8269A2E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269A2E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269A2E8: 4BE77801  bl 0x82511ae8
	ctx.lr = 0x8269A2EC;
	sub_82511AE8(ctx, base);
	// 8269A2EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269A2F0: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 8269A2F4: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 8269A2F8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8269A2FC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8269A300: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8269A304: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269A308: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8269A30C: 13DF50C7  vcmpequd (lvx128) v30, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269A310: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269A358 size=32
    let mut pc: u32 = 0x8269A358;
    'dispatch: loop {
        match pc {
            0x8269A358 => {
    //   block [0x8269A358..0x8269A378)
	// 8269A358: 81030118  lwz r8, 0x118(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 8269A35C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8269A360: 39430118  addi r10, r3, 0x118
	ctx.r[10].s64 = ctx.r[3].s64 + 280;
	// 8269A364: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 8269A368: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 8269A36C: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 8269A370: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 8269A374: 4BC2A0EC  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A378 size=548
    let mut pc: u32 = 0x8269A378;
    'dispatch: loop {
        match pc {
            0x8269A378 => {
    //   block [0x8269A378..0x8269A59C)
	// 8269A378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A37C: 48B0DDDD  bl 0x831a8158
	ctx.lr = 0x8269A380;
	sub_831A8130(ctx, base);
	// 8269A380: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8269A384: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A388: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269A38C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8269A390: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8269A394: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8269A398: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8269A39C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8269A3A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269A3A4: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8269A3A8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8269A3AC: 83DB0100  lwz r30, 0x100(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 8269A3B0: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269A3B4: C02A9530  lfs f1, -0x6ad0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269A3B8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269A3BC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269A3C0: 487E1C59  bl 0x82e7c018
	ctx.lr = 0x8269A3C4;
	sub_82E7C018(ctx, base);
	// 8269A3C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269A3C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8269A3CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8269A3D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269A3D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269A3D8: 4E800421  bctrl
	ctx.lr = 0x8269A3DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269A3DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269A3E0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8269A3E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8269A3E8: 4BC2A519  bl 0x822c4900
	ctx.lr = 0x8269A3EC;
	sub_822C4900(ctx, base);
	// 8269A3EC: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 8269A3F0: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 8269A3F4: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269A3F8: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 8269A3FC: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8269A400: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8269A404: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8269A408: 13DC1C07  vcmpneb. (lvlx128) v30, v28, v3
	tmp.u32 = ctx.r[28].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269A40C: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8269A410: 13BD1C07  vcmpneb. (lvlx128) v29, v29, v3
	tmp.u32 = ctx.r[29].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269A414: 139E1C07  vcmpneb. (lvlx128) v28, v30, v3
	tmp.u32 = ctx.r[30].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269A418: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A5A0 size=296
    let mut pc: u32 = 0x8269A5A0;
    'dispatch: loop {
        match pc {
            0x8269A5A0 => {
    //   block [0x8269A5A0..0x8269A6C8)
	// 8269A5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A5A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269A5AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A5B0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8269A5B4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A5B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A5BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269A5C0: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 8269A5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269A5C8: 409A000C  bne cr6, 0x8269a5d4
	if !ctx.cr[6].eq {
	pc = 0x8269A5D4; continue 'dispatch;
	}
	// 8269A5CC: 4BFFFAB5  bl 0x8269a080
	ctx.lr = 0x8269A5D0;
	sub_8269A080(ctx, base);
	// 8269A5D0: 48000008  b 0x8269a5d8
	pc = 0x8269A5D8; continue 'dispatch;
	// 8269A5D4: 4BFFFBED  bl 0x8269a1c0
	ctx.lr = 0x8269A5D8;
	sub_8269A1C0(ctx, base);
	// 8269A5D8: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 8269A5DC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8269A5E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269A5E4: 409A002C  bne cr6, 0x8269a610
	if !ctx.cr[6].eq {
	pc = 0x8269A610; continue 'dispatch;
	}
	// 8269A5E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269A5EC: D3FF00F4  stfs f31, 0xf4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 8269A5F0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8269A5F4: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 8269A5F8: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A5FC: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269A600: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8269A604: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 8269A608: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8269A60C: 48000050  b 0x8269a65c
	pc = 0x8269A65C; continue 'dispatch;
	// 8269A610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269A614: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8269A618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269A61C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A620: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8269A624: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8269A628: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8269A62C: 4BE7752D  bl 0x82511b58
	ctx.lr = 0x8269A630;
	sub_82511B58(ctx, base);
	// 8269A630: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269A634: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269A638: 487E1861  bl 0x82e7be98
	ctx.lr = 0x8269A63C;
	sub_82E7BE98(ctx, base);
	// 8269A63C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269A640: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269A644: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269A648: 487E1681  bl 0x82e7bcc8
	ctx.lr = 0x8269A64C;
	sub_82E7BCC8(ctx, base);
	// 8269A64C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8269A650: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 8269A654: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269A6C8 size=4
    let mut pc: u32 = 0x8269A6C8;
    'dispatch: loop {
        match pc {
            0x8269A6C8 => {
    //   block [0x8269A6C8..0x8269A6CC)
	// 8269A6C8: 4BFFFB98  b 0x8269a260
	sub_8269A260(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269A6D0 size=196
    let mut pc: u32 = 0x8269A6D0;
    'dispatch: loop {
        match pc {
            0x8269A6D0 => {
    //   block [0x8269A6D0..0x8269A794)
	// 8269A6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A6D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269A6DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A6E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A6E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269A6E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269A6EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8269A6F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269A6F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269A6F8: 4BC26241  bl 0x822c0938
	ctx.lr = 0x8269A6FC;
	sub_822C0938(ctx, base);
	// 8269A6FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269A700: 41820028  beq 0x8269a728
	if ctx.cr[0].eq {
	pc = 0x8269A728; continue 'dispatch;
	}
	// 8269A704: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269A708: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8269A70C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8269A710: 392BFCCC  addi r9, r11, -0x334
	ctx.r[9].s64 = ctx.r[11].s64 + -820;
	// 8269A714: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8269A718: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269A71C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8269A720: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8269A724: 48000008  b 0x8269a72c
	pc = 0x8269A72C; continue 'dispatch;
	// 8269A728: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269A72C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269A730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269A734: 409A0044  bne cr6, 0x8269a778
	if !ctx.cr[6].eq {
	pc = 0x8269A778; continue 'dispatch;
	}
	// 8269A738: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269A73C: 419A001C  beq cr6, 0x8269a758
	if ctx.cr[6].eq {
	pc = 0x8269A758; continue 'dispatch;
	}
	// 8269A740: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269A744: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8269A748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269A74C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269A750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269A754: 4E800421  bctrl
	ctx.lr = 0x8269A758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269A758: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269A75C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269A760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269A764: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8269A768: 816B93E8  lwz r11, -0x6c18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27672 as u32) ) } as u64;
	// 8269A76C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269A770: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269A774: 4BC2588D  bl 0x822c0000
	ctx.lr = 0x8269A778;
	sub_822C0000(ctx, base);
	// 8269A778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269A77C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269A780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269A784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269A788: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269A78C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269A790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A798 size=184
    let mut pc: u32 = 0x8269A798;
    'dispatch: loop {
        match pc {
            0x8269A798 => {
    //   block [0x8269A798..0x8269A850)
	// 8269A798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A79C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A7A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269A7A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A7A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A7AC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269A7B0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8269A7B4: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 8269A7B8: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 8269A7BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269A7C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A7C4: 4BE77A9D  bl 0x82512260
	ctx.lr = 0x8269A7C8;
	sub_82512260(ctx, base);
	// 8269A7C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269A7CC: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269A7D0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 8269A7D4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269A7D8: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269A7DC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8269A7E0: 3969FD74  addi r11, r9, -0x28c
	ctx.r[11].s64 = ctx.r[9].s64 + -652;
	// 8269A7E4: 38E000F0  li r7, 0xf0
	ctx.r[7].s64 = 240;
	// 8269A7E8: 394AFD34  addi r10, r10, -0x2cc
	ctx.r[10].s64 = ctx.r[10].s64 + -716;
	// 8269A7EC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8269A7F0: 3928FCE4  addi r9, r8, -0x31c
	ctx.r[9].s64 = ctx.r[8].s64 + -796;
	// 8269A7F4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8269A7F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269A7FC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8269A800: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269A850 size=8
    let mut pc: u32 = 0x8269A850;
    'dispatch: loop {
        match pc {
            0x8269A850 => {
    //   block [0x8269A850..0x8269A858)
	// 8269A850: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8269A854: 480002AC  b 0x8269ab00
	sub_8269AB00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269A858 size=8
    let mut pc: u32 = 0x8269A858;
    'dispatch: loop {
        match pc {
            0x8269A858 => {
    //   block [0x8269A858..0x8269A860)
	// 8269A858: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8269A85C: 480002A4  b 0x8269ab00
	sub_8269AB00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269A860 size=168
    let mut pc: u32 = 0x8269A860;
    'dispatch: loop {
        match pc {
            0x8269A860 => {
    //   block [0x8269A860..0x8269A908)
	// 8269A860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269A86C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A878: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269A87C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269A880: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269A884: 396BFD34  addi r11, r11, -0x2cc
	ctx.r[11].s64 = ctx.r[11].s64 + -716;
	// 8269A888: 394AFD74  addi r10, r10, -0x28c
	ctx.r[10].s64 = ctx.r[10].s64 + -652;
	// 8269A88C: 3929FCE4  addi r9, r9, -0x31c
	ctx.r[9].s64 = ctx.r[9].s64 + -796;
	// 8269A890: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269A894: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8269A898: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 8269A89C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8269A8A0: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 8269A8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269A8A8: 419A0008  beq cr6, 0x8269a8b0
	if ctx.cr[6].eq {
	pc = 0x8269A8B0; continue 'dispatch;
	}
	// 8269A8AC: 4BC25FE5  bl 0x822c0890
	ctx.lr = 0x8269A8B0;
	sub_822C0890(ctx, base);
	// 8269A8B0: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269A8B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269A8B8: 419A0008  beq cr6, 0x8269a8c0
	if ctx.cr[6].eq {
	pc = 0x8269A8C0; continue 'dispatch;
	}
	// 8269A8BC: 4BC25FD5  bl 0x822c0890
	ctx.lr = 0x8269A8C0;
	sub_822C0890(ctx, base);
	// 8269A8C0: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 8269A8C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269A8C8: 419A0008  beq cr6, 0x8269a8d0
	if ctx.cr[6].eq {
	pc = 0x8269A8D0; continue 'dispatch;
	}
	// 8269A8CC: 4BC25FC5  bl 0x822c0890
	ctx.lr = 0x8269A8D0;
	sub_822C0890(ctx, base);
	// 8269A8D0: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 8269A8D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269A8D8: 419A0008  beq cr6, 0x8269a8e0
	if ctx.cr[6].eq {
	pc = 0x8269A8E0; continue 'dispatch;
	}
	// 8269A8DC: 4BC25FB5  bl 0x822c0890
	ctx.lr = 0x8269A8E0;
	sub_822C0890(ctx, base);
	// 8269A8E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269A8E4: 4810CD75  bl 0x827a7658
	ctx.lr = 0x8269A8E8;
	sub_827A7658(ctx, base);
	// 8269A8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269A8EC: 4BCB4A65  bl 0x8234f350
	ctx.lr = 0x8269A8F0;
	sub_8234F350(ctx, base);
	// 8269A8F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269A8F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269A8F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269A8FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269A900: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269A904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269A908 size=32
    let mut pc: u32 = 0x8269A908;
    'dispatch: loop {
        match pc {
            0x8269A908 => {
    //   block [0x8269A908..0x8269A928)
	// 8269A908: 81030100  lwz r8, 0x100(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) } as u64;
	// 8269A90C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8269A910: 39430100  addi r10, r3, 0x100
	ctx.r[10].s64 = ctx.r[3].s64 + 256;
	// 8269A914: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 8269A918: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 8269A91C: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 8269A920: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 8269A924: 4BC29B3C  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269A928 size=120
    let mut pc: u32 = 0x8269A928;
    'dispatch: loop {
        match pc {
            0x8269A928 => {
    //   block [0x8269A928..0x8269A9A0)
	// 8269A928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269A930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269A934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269A93C: 4BFFFE5D  bl 0x8269a798
	ctx.lr = 0x8269A940;
	sub_8269A798(ctx, base);
	// 8269A940: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269A944: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269A948: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269A94C: 3CE08205  lis r7, -0x7dfb
	ctx.r[7].s64 = -2113601536;
	// 8269A950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269A954: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269A958: 3948FE1C  addi r10, r8, -0x1e4
	ctx.r[10].s64 = ctx.r[8].s64 + -484;
	// 8269A95C: 3929FDDC  addi r9, r9, -0x224
	ctx.r[9].s64 = ctx.r[9].s64 + -548;
	// 8269A960: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 8269A964: 3907FD8C  addi r8, r7, -0x274
	ctx.r[8].s64 = ctx.r[7].s64 + -628;
	// 8269A968: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 8269A96C: D01F0138  stfs f0, 0x138(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 8269A970: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8269A974: D01F013C  stfs f0, 0x13c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 8269A978: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8269A97C: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 8269A980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269A984: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 8269A988: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 8269A98C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269A990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269A994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269A998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269A99C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269A9A0 size=8
    let mut pc: u32 = 0x8269A9A0;
    'dispatch: loop {
        match pc {
            0x8269A9A0 => {
    //   block [0x8269A9A0..0x8269A9A8)
	// 8269A9A0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8269A9A4: 4800023C  b 0x8269abe0
	sub_8269ABE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269A9A8 size=8
    let mut pc: u32 = 0x8269A9A8;
    'dispatch: loop {
        match pc {
            0x8269A9A8 => {
    //   block [0x8269A9A8..0x8269A9B0)
	// 8269A9A8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8269A9AC: 48000234  b 0x8269abe0
	sub_8269ABE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269A9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269A9B0 size=332
    let mut pc: u32 = 0x8269A9B0;
    'dispatch: loop {
        match pc {
            0x8269A9B0 => {
    //   block [0x8269A9B0..0x8269AAFC)
	// 8269A9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269A9B4: 48B0D7B5  bl 0x831a8168
	ctx.lr = 0x8269A9B8;
	sub_831A8130(ctx, base);
	// 8269A9B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269A9BC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8269A9C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269A9C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269A9C8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269A9CC: 41820038  beq 0x8269aa04
	if ctx.cr[0].eq {
	pc = 0x8269AA04; continue 'dispatch;
	}
	// 8269A9D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269A9D4: 48B0EFB5  bl 0x831a9988
	ctx.lr = 0x8269A9D8;
	sub_831A9988(ctx, base);
	// 8269A9D8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269A9DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269A9E0: 386B9470  addi r3, r11, -0x6b90
	ctx.r[3].s64 = ctx.r[11].s64 + -27536;
	// 8269A9E4: 48B0D715  bl 0x831a80f8
	ctx.lr = 0x8269A9E8;
	sub_831A80F8(ctx, base);
	// 8269A9E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269A9EC: 41820018  beq 0x8269aa04
	if ctx.cr[0].eq {
	pc = 0x8269AA04; continue 'dispatch;
	}
	// 8269A9F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269A9F4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269A9F8: 4BFFF611  bl 0x8269a008
	ctx.lr = 0x8269A9FC;
	sub_8269A008(ctx, base);
	// 8269A9FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8269AA00: 480000F4  b 0x8269aaf4
	pc = 0x8269AAF4; continue 'dispatch;
	// 8269AA04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269AA08: 419A00DC  beq cr6, 0x8269aae4
	if ctx.cr[6].eq {
	pc = 0x8269AAE4; continue 'dispatch;
	}
	// 8269AA0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AA10: 48B0EF79  bl 0x831a9988
	ctx.lr = 0x8269AA14;
	sub_831A9988(ctx, base);
	// 8269AA14: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8269AA18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269AA1C: 386B193C  addi r3, r11, 0x193c
	ctx.r[3].s64 = ctx.r[11].s64 + 6460;
	// 8269AA20: 48B0D6D9  bl 0x831a80f8
	ctx.lr = 0x8269AA24;
	sub_831A80F8(ctx, base);
	// 8269AA24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269AA28: 41820014  beq 0x8269aa3c
	if ctx.cr[0].eq {
	pc = 0x8269AA3C; continue 'dispatch;
	}
	// 8269AA2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AA30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269AA34: 4BFFF925  bl 0x8269a358
	ctx.lr = 0x8269AA38;
	sub_8269A358(ctx, base);
	// 8269AA38: 4BFFFFC4  b 0x8269a9fc
	pc = 0x8269A9FC; continue 'dispatch;
	// 8269AA3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269AA40: 419A00A4  beq cr6, 0x8269aae4
	if ctx.cr[6].eq {
	pc = 0x8269AAE4; continue 'dispatch;
	}
	// 8269AA44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AA48: 48B0EF41  bl 0x831a9988
	ctx.lr = 0x8269AA4C;
	sub_831A9988(ctx, base);
	// 8269AA4C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269AA50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269AA54: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 8269AA58: 48B0D6A1  bl 0x831a80f8
	ctx.lr = 0x8269AA5C;
	sub_831A80F8(ctx, base);
	// 8269AA5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269AA60: 41820014  beq 0x8269aa74
	if ctx.cr[0].eq {
	pc = 0x8269AA74; continue 'dispatch;
	}
	// 8269AA64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AA68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269AA6C: 4BFFFE9D  bl 0x8269a908
	ctx.lr = 0x8269AA70;
	sub_8269A908(ctx, base);
	// 8269AA70: 4BFFFF8C  b 0x8269a9fc
	pc = 0x8269A9FC; continue 'dispatch;
	// 8269AA74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269AA78: 419A006C  beq cr6, 0x8269aae4
	if ctx.cr[6].eq {
	pc = 0x8269AAE4; continue 'dispatch;
	}
	// 8269AA7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AA80: 48B0EF09  bl 0x831a9988
	ctx.lr = 0x8269AA84;
	sub_831A9988(ctx, base);
	// 8269AA84: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269AA88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269AA8C: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 8269AA90: 48B0D669  bl 0x831a80f8
	ctx.lr = 0x8269AA94;
	sub_831A80F8(ctx, base);
	// 8269AA94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269AA98: 41820014  beq 0x8269aaac
	if ctx.cr[0].eq {
	pc = 0x8269AAAC; continue 'dispatch;
	}
	// 8269AA9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AAA0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269AAA4: 4BFFF8D5  bl 0x8269a378
	ctx.lr = 0x8269AAA8;
	sub_8269A378(ctx, base);
	// 8269AAA8: 4BFFFF54  b 0x8269a9fc
	pc = 0x8269A9FC; continue 'dispatch;
	// 8269AAAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269AAB0: 419A0034  beq cr6, 0x8269aae4
	if ctx.cr[6].eq {
	pc = 0x8269AAE4; continue 'dispatch;
	}
	// 8269AAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AAB8: 48B0EED1  bl 0x831a9988
	ctx.lr = 0x8269AABC;
	sub_831A9988(ctx, base);
	// 8269AABC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8269AAC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269AAC4: 386B66B4  addi r3, r11, 0x66b4
	ctx.r[3].s64 = ctx.r[11].s64 + 26292;
	// 8269AAC8: 48B0D631  bl 0x831a80f8
	ctx.lr = 0x8269AACC;
	sub_831A80F8(ctx, base);
	// 8269AACC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269AAD0: 41820014  beq 0x8269aae4
	if ctx.cr[0].eq {
	pc = 0x8269AAE4; continue 'dispatch;
	}
	// 8269AAD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AAD8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269AADC: 480AB5F5  bl 0x827460d0
	ctx.lr = 0x8269AAE0;
	sub_827460D0(ctx, base);
	// 8269AAE0: 4BFFFF1C  b 0x8269a9fc
	pc = 0x8269A9FC; continue 'dispatch;
	// 8269AAE4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8269AAE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AAEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269AAF0: 4BE77B29  bl 0x82512618
	ctx.lr = 0x8269AAF4;
	sub_82512618(ctx, base);
	// 8269AAF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269AAF8: 48B0D6C0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269AB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269AB00 size=76
    let mut pc: u32 = 0x8269AB00;
    'dispatch: loop {
        match pc {
            0x8269AB00 => {
    //   block [0x8269AB00..0x8269AB4C)
	// 8269AB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269AB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269AB08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269AB0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269AB10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269AB14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269AB18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269AB1C: 4BFFFD45  bl 0x8269a860
	ctx.lr = 0x8269AB20;
	sub_8269A860(ctx, base);
	// 8269AB20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269AB24: 4182000C  beq 0x8269ab30
	if ctx.cr[0].eq {
	pc = 0x8269AB30; continue 'dispatch;
	}
	// 8269AB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AB2C: 487578AD  bl 0x82df23d8
	ctx.lr = 0x8269AB30;
	sub_82DF23D8(ctx, base);
	// 8269AB30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AB34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269AB38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269AB3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269AB40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269AB44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269AB48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269AB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269AB50 size=140
    let mut pc: u32 = 0x8269AB50;
    'dispatch: loop {
        match pc {
            0x8269AB50 => {
    //   block [0x8269AB50..0x8269ABDC)
	// 8269AB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269AB54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269AB58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269AB5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269AB60: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269AB64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269AB68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269AB6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269AB70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AB74: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 8269AB78: 48758E91  bl 0x82df3a08
	ctx.lr = 0x8269AB7C;
	sub_82DF3A08(ctx, base);
	// 8269AB7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269AB80: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8269AB84: 389F003C  addi r4, r31, 0x3c
	ctx.r[4].s64 = ctx.r[31].s64 + 60;
	// 8269AB88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269AB8C: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8269AB90: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8269AB94: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 8269AB98: 4BF08619  bl 0x825a31b0
	ctx.lr = 0x8269AB9C;
	sub_825A31B0(ctx, base);
	// 8269AB9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269ABA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269ABA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269ABA8: 4BF06BC9  bl 0x825a1770
	ctx.lr = 0x8269ABAC;
	sub_825A1770(ctx, base);
	// 8269ABAC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8269ABB0: 48758879  bl 0x82df3428
	ctx.lr = 0x8269ABB4;
	sub_82DF3428(ctx, base);
	// 8269ABB4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8269ABB8: 4BC2E101  bl 0x822c8cb8
	ctx.lr = 0x8269ABBC;
	sub_822C8CB8(ctx, base);
	// 8269ABBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269ABC0: 48758869  bl 0x82df3428
	ctx.lr = 0x8269ABC4;
	sub_82DF3428(ctx, base);
	// 8269ABC4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8269ABC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269ABCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269ABD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269ABD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269ABD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269ABE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269ABE0 size=112
    let mut pc: u32 = 0x8269ABE0;
    'dispatch: loop {
        match pc {
            0x8269ABE0 => {
    //   block [0x8269ABE0..0x8269AC50)
	// 8269ABE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269ABE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269ABE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269ABEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269ABF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269ABF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269ABF8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269ABFC: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269AC00: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269AC04: 396BFDDC  addi r11, r11, -0x224
	ctx.r[11].s64 = ctx.r[11].s64 + -548;
	// 8269AC08: 394AFE1C  addi r10, r10, -0x1e4
	ctx.r[10].s64 = ctx.r[10].s64 + -484;
	// 8269AC0C: 3929FD8C  addi r9, r9, -0x274
	ctx.r[9].s64 = ctx.r[9].s64 + -628;
	// 8269AC10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269AC14: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8269AC18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269AC1C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8269AC20: 4BFFFC41  bl 0x8269a860
	ctx.lr = 0x8269AC24;
	sub_8269A860(ctx, base);
	// 8269AC24: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269AC28: 4182000C  beq 0x8269ac34
	if ctx.cr[0].eq {
	pc = 0x8269AC34; continue 'dispatch;
	}
	// 8269AC2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AC30: 487577A9  bl 0x82df23d8
	ctx.lr = 0x8269AC34;
	sub_82DF23D8(ctx, base);
	// 8269AC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AC38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269AC3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269AC40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269AC44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269AC48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269AC4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269AC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269AC50 size=584
    let mut pc: u32 = 0x8269AC50;
    'dispatch: loop {
        match pc {
            0x8269AC50 => {
    //   block [0x8269AC50..0x8269AE98)
	// 8269AC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269AC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269AC58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269AC5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269AC60: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 8269AC64: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8269AC68: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8269AC6C: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269AC70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269AC74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269AC78: 4BFFFED9  bl 0x8269ab50
	ctx.lr = 0x8269AC7C;
	sub_8269AB50(ctx, base);
	// 8269AC7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269AC80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AC84: 388B1310  addi r4, r11, 0x1310
	ctx.r[4].s64 = ctx.r[11].s64 + 4880;
	// 8269AC88: 48758D81  bl 0x82df3a08
	ctx.lr = 0x8269AC8C;
	sub_82DF3A08(ctx, base);
	// 8269AC8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269AC90: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8269AC94: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8269AC98: 389F004C  addi r4, r31, 0x4c
	ctx.r[4].s64 = ctx.r[31].s64 + 76;
	// 8269AC9C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 8269ACA0: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269ACA4: C3CA9A8C  lfs f30, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8269ACA8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269ACAC: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8269ACB0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8269ACB4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269ACB8: 4BF084F9  bl 0x825a31b0
	ctx.lr = 0x8269ACBC;
	sub_825A31B0(ctx, base);
	// 8269ACBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269ACC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269ACC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269ACC8: 4BF06AA9  bl 0x825a1770
	ctx.lr = 0x8269ACCC;
	sub_825A1770(ctx, base);
	// 8269ACCC: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 8269ACD0: 48758759  bl 0x82df3428
	ctx.lr = 0x8269ACD4;
	sub_82DF3428(ctx, base);
	// 8269ACD4: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 8269ACD8: 4BC2DFE1  bl 0x822c8cb8
	ctx.lr = 0x8269ACDC;
	sub_822C8CB8(ctx, base);
	// 8269ACDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269ACE0: 48758749  bl 0x82df3428
	ctx.lr = 0x8269ACE4;
	sub_82DF3428(ctx, base);
	// 8269ACE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269ACE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269ACEC: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 8269ACF0: 48758D19  bl 0x82df3a08
	ctx.lr = 0x8269ACF4;
	sub_82DF3A08(ctx, base);
	// 8269ACF4: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 8269ACF8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8269ACFC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269AD00: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8269AD04: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269AD08: 4BF084A9  bl 0x825a31b0
	ctx.lr = 0x8269AD0C;
	sub_825A31B0(ctx, base);
	// 8269AD0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269AD10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269AD14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269AD18: 4BF06A59  bl 0x825a1770
	ctx.lr = 0x8269AD1C;
	sub_825A1770(ctx, base);
	// 8269AD1C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8269AD20: 48758709  bl 0x82df3428
	ctx.lr = 0x8269AD24;
	sub_82DF3428(ctx, base);
	// 8269AD24: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 8269AD28: 4BC2DF91  bl 0x822c8cb8
	ctx.lr = 0x8269AD2C;
	sub_822C8CB8(ctx, base);
	// 8269AD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AD30: 487586F9  bl 0x82df3428
	ctx.lr = 0x8269AD34;
	sub_82DF3428(ctx, base);
	// 8269AD34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269AD38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AD3C: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 8269AD40: 48758CC9  bl 0x82df3a08
	ctx.lr = 0x8269AD44;
	sub_82DF3A08(ctx, base);
	// 8269AD44: 389F0054  addi r4, r31, 0x54
	ctx.r[4].s64 = ctx.r[31].s64 + 84;
	// 8269AD48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269AD4C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269AD50: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8269AD54: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269AD58: 4BF08459  bl 0x825a31b0
	ctx.lr = 0x8269AD5C;
	sub_825A31B0(ctx, base);
	// 8269AD5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269AD60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269AD64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269AD68: 4BF06A09  bl 0x825a1770
	ctx.lr = 0x8269AD6C;
	sub_825A1770(ctx, base);
	// 8269AD6C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8269AD70: 487586B9  bl 0x82df3428
	ctx.lr = 0x8269AD74;
	sub_82DF3428(ctx, base);
	// 8269AD74: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8269AD78: 4BC2DF41  bl 0x822c8cb8
	ctx.lr = 0x8269AD7C;
	sub_822C8CB8(ctx, base);
	// 8269AD7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AD80: 487586A9  bl 0x82df3428
	ctx.lr = 0x8269AD84;
	sub_82DF3428(ctx, base);
	// 8269AD84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269AD88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AD8C: 388B4370  addi r4, r11, 0x4370
	ctx.r[4].s64 = ctx.r[11].s64 + 17264;
	// 8269AD90: 48758C79  bl 0x82df3a08
	ctx.lr = 0x8269AD94;
	sub_82DF3A08(ctx, base);
	// 8269AD94: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 8269AD98: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8269AD9C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269ADA0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8269ADA4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269ADA8: 4BF08409  bl 0x825a31b0
	ctx.lr = 0x8269ADAC;
	sub_825A31B0(ctx, base);
	// 8269ADAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269ADB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269ADB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269ADB8: 4BF069B9  bl 0x825a1770
	ctx.lr = 0x8269ADBC;
	sub_825A1770(ctx, base);
	// 8269ADBC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8269ADC0: 48758669  bl 0x82df3428
	ctx.lr = 0x8269ADC4;
	sub_82DF3428(ctx, base);
	// 8269ADC4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8269ADC8: 4BC2DEF1  bl 0x822c8cb8
	ctx.lr = 0x8269ADCC;
	sub_822C8CB8(ctx, base);
	// 8269ADCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269ADD0: 48758659  bl 0x82df3428
	ctx.lr = 0x8269ADD4;
	sub_82DF3428(ctx, base);
	// 8269ADD4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8269ADD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269ADDC: 388B4A98  addi r4, r11, 0x4a98
	ctx.r[4].s64 = ctx.r[11].s64 + 19096;
	// 8269ADE0: 48758C29  bl 0x82df3a08
	ctx.lr = 0x8269ADE4;
	sub_82DF3A08(ctx, base);
	// 8269ADE4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8269ADE8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269ADEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269ADF0: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 8269ADF4: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8269ADF8: 4BF085B1  bl 0x825a33a8
	ctx.lr = 0x8269ADFC;
	sub_825A33A8(ctx, base);
	// 8269ADFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269AE00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269AE04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269AE08: 4BF070D1  bl 0x825a1ed8
	ctx.lr = 0x8269AE0C;
	sub_825A1ED8(ctx, base);
	// 8269AE0C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 8269AE10: 48758619  bl 0x82df3428
	ctx.lr = 0x8269AE14;
	sub_82DF3428(ctx, base);
	// 8269AE14: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 8269AE18: 4BC2DEA1  bl 0x822c8cb8
	ctx.lr = 0x8269AE1C;
	sub_822C8CB8(ctx, base);
	// 8269AE1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AE20: 48758609  bl 0x82df3428
	ctx.lr = 0x8269AE24;
	sub_82DF3428(ctx, base);
	// 8269AE24: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8269AE28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AE2C: 388B5EA0  addi r4, r11, 0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + 24224;
	// 8269AE30: 48758BD9  bl 0x82df3a08
	ctx.lr = 0x8269AE34;
	sub_82DF3A08(ctx, base);
	// 8269AE34: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8269AE38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269AE3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269AE40: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 8269AE44: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 8269AE48: 4BF08561  bl 0x825a33a8
	ctx.lr = 0x8269AE4C;
	sub_825A33A8(ctx, base);
	// 8269AE4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269AE50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269AE54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269AE58: 4BF07081  bl 0x825a1ed8
	ctx.lr = 0x8269AE5C;
	sub_825A1ED8(ctx, base);
	// 8269AE5C: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 8269AE60: 487585C9  bl 0x82df3428
	ctx.lr = 0x8269AE64;
	sub_82DF3428(ctx, base);
	// 8269AE64: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 8269AE68: 4BC2DE51  bl 0x822c8cb8
	ctx.lr = 0x8269AE6C;
	sub_822C8CB8(ctx, base);
	// 8269AE6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269AE70: 487585B9  bl 0x82df3428
	ctx.lr = 0x8269AE74;
	sub_82DF3428(ctx, base);
	// 8269AE74: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 8269AE78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269AE7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269AE80: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8269AE84: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8269AE88: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8269AE8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269AE90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269AE94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269AE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269AE98 size=424
    let mut pc: u32 = 0x8269AE98;
    'dispatch: loop {
        match pc {
            0x8269AE98 => {
    //   block [0x8269AE98..0x8269B040)
	// 8269AE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269AE9C: 48B0D2C9  bl 0x831a8164
	ctx.lr = 0x8269AEA0;
	sub_831A8130(ctx, base);
	// 8269AEA0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269AEA4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269AEA8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8269AEAC: 3BCBFE30  addi r30, r11, -0x1d0
	ctx.r[30].s64 = ctx.r[11].s64 + -464;
	// 8269AEB0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8269AEB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269AEB8: 38A000E9  li r5, 0xe9
	ctx.r[5].s64 = 233;
	// 8269AEBC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8269AEC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269AEC4: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 8269AEC8: 48757521  bl 0x82df23e8
	ctx.lr = 0x8269AECC;
	sub_82DF23E8(ctx, base);
	// 8269AECC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269AED0: 41820010  beq 0x8269aee0
	if ctx.cr[0].eq {
	pc = 0x8269AEE0; continue 'dispatch;
	}
	// 8269AED4: 4BFFFA55  bl 0x8269a928
	ctx.lr = 0x8269AED8;
	sub_8269A928(ctx, base);
	// 8269AED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269AEDC: 48000008  b 0x8269aee4
	pc = 0x8269AEE4; continue 'dispatch;
	// 8269AEE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269AEE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8269AEE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AEEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269AEF0: 4BFFF7E1  bl 0x8269a6d0
	ctx.lr = 0x8269AEF4;
	sub_8269A6D0(ctx, base);
	// 8269AEF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269AEF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AEFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269AF00: 4BC25101  bl 0x822c0000
	ctx.lr = 0x8269AF04;
	sub_822C0000(ctx, base);
	// 8269AF04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269AF08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269AF0C: 38A000EB  li r5, 0xeb
	ctx.r[5].s64 = 235;
	// 8269AF10: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8269AF14: 4BC254C5  bl 0x822c03d8
	ctx.lr = 0x8269AF18;
	sub_822C03D8(ctx, base);
	// 8269AF18: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8269AF1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269AF20: 418200B4  beq 0x8269afd4
	if ctx.cr[0].eq {
	pc = 0x8269AFD4; continue 'dispatch;
	}
	// 8269AF24: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8269AF28: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8269AF2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8269AF30: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8269AF34: 409A0008  bne cr6, 0x8269af3c
	if !ctx.cr[6].eq {
	pc = 0x8269AF3C; continue 'dispatch;
	}
	// 8269AF38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269AF3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8269AF40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269AF44: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8269AF48: 419A0024  beq cr6, 0x8269af6c
	if ctx.cr[6].eq {
	pc = 0x8269AF6C; continue 'dispatch;
	}
	// 8269AF4C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269AF50: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8269AF54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269AF58: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8269AF5C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8269AF60: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269AF64: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269AF68: 4082FFE8  bne 0x8269af50
	if !ctx.cr[0].eq {
	pc = 0x8269AF50; continue 'dispatch;
	}
	// 8269AF6C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8269AF70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269AF74: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8269AF78: 419A0024  beq cr6, 0x8269af9c
	if ctx.cr[6].eq {
	pc = 0x8269AF9C; continue 'dispatch;
	}
	// 8269AF7C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269AF80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269AF84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269AF88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269AF8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269AF90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269AF94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269AF98: 4082FFE8  bne 0x8269af80
	if !ctx.cr[0].eq {
	pc = 0x8269AF80; continue 'dispatch;
	}
	// 8269AF9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269AFA0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8269AFA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8269AFA8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8269AFAC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8269AFB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269AFB4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269AFB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269AFBC: 480FDF75  bl 0x82798f30
	ctx.lr = 0x8269AFC0;
	sub_82798F30(ctx, base);
	// 8269AFC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269AFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269AFC8: 481006A1  bl 0x8279b668
	ctx.lr = 0x8269AFCC;
	sub_8279B668(ctx, base);
	// 8269AFCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269AFD0: 48000008  b 0x8269afd8
	pc = 0x8269AFD8; continue 'dispatch;
	// 8269AFD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269AFD8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8269AFDC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8269AFE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AFE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269AFE8: 4BEFCC69  bl 0x82597c50
	ctx.lr = 0x8269AFEC;
	sub_82597C50(ctx, base);
	// 8269AFEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269AFF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269AFF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269AFF8: 4BC25009  bl 0x822c0000
	ctx.lr = 0x8269AFFC;
	sub_822C0000(ctx, base);
	// 8269AFFC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269B000: 41820024  beq 0x8269b024
	if ctx.cr[0].eq {
	pc = 0x8269B024; continue 'dispatch;
	}
	// 8269B004: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8269B008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269B00C: 419A0008  beq cr6, 0x8269b014
	if ctx.cr[6].eq {
	pc = 0x8269B014; continue 'dispatch;
	}
	// 8269B010: 4BC25881  bl 0x822c0890
	ctx.lr = 0x8269B014;
	sub_822C0890(ctx, base);
	// 8269B014: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8269B018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269B01C: 419A0008  beq cr6, 0x8269b024
	if ctx.cr[6].eq {
	pc = 0x8269B024; continue 'dispatch;
	}
	// 8269B020: 4BC25871  bl 0x822c0890
	ctx.lr = 0x8269B024;
	sub_822C0890(ctx, base);
	// 8269B024: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269B028: 419A000C  beq cr6, 0x8269b034
	if ctx.cr[6].eq {
	pc = 0x8269B034; continue 'dispatch;
	}
	// 8269B02C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269B030: 4BC25861  bl 0x822c0890
	ctx.lr = 0x8269B034;
	sub_822C0890(ctx, base);
	// 8269B034: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8269B038: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8269B03C: 48B0D178  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269B040 size=988
    let mut pc: u32 = 0x8269B040;
    'dispatch: loop {
        match pc {
            0x8269B040 => {
    //   block [0x8269B040..0x8269B41C)
	// 8269B040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B044: 48B0D11D  bl 0x831a8160
	ctx.lr = 0x8269B048;
	sub_831A8130(ctx, base);
	// 8269B048: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269B050: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8269B054: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8269B058: 4BE76981  bl 0x825119d8
	ctx.lr = 0x8269B05C;
	sub_825119D8(ctx, base);
	// 8269B05C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269B060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B064: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8269B068: 487589A1  bl 0x82df3a08
	ctx.lr = 0x8269B06C;
	sub_82DF3A08(ctx, base);
	// 8269B06C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269B070: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269B074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269B078: 4BE6D709  bl 0x82508780
	ctx.lr = 0x8269B07C;
	sub_82508780(ctx, base);
	// 8269B07C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B080: 487583A9  bl 0x82df3428
	ctx.lr = 0x8269B084;
	sub_82DF3428(ctx, base);
	// 8269B084: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269B088: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8269B08C: 409A0008  bne cr6, 0x8269b094
	if !ctx.cr[6].eq {
	pc = 0x8269B094; continue 'dispatch;
	}
	// 8269B090: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269B094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269B098: 4BE6D709  bl 0x825087a0
	ctx.lr = 0x8269B09C;
	sub_825087A0(ctx, base);
	// 8269B09C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269B0A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269B0A4: 3B6BFE30  addi r27, r11, -0x1d0
	ctx.r[27].s64 = ctx.r[11].s64 + -464;
	// 8269B0A8: 38A0004E  li r5, 0x4e
	ctx.r[5].s64 = 78;
	// 8269B0AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269B0B0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269B0B4: 48757335  bl 0x82df23e8
	ctx.lr = 0x8269B0B8;
	sub_82DF23E8(ctx, base);
	// 8269B0B8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269B0BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269B0C0: 3BCB6880  addi r30, r11, 0x6880
	ctx.r[30].s64 = ctx.r[11].s64 + 26752;
	// 8269B0C4: 41820014  beq 0x8269b0d8
	if ctx.cr[0].eq {
	pc = 0x8269B0D8; continue 'dispatch;
	}
	// 8269B0C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269B0CC: 48778025  bl 0x82e130f0
	ctx.lr = 0x8269B0D0;
	sub_82E130F0(ctx, base);
	// 8269B0D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269B0D4: 48000008  b 0x8269b0dc
	pc = 0x8269B0DC; continue 'dispatch;
	// 8269B0D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269B0DC: 3BBF0100  addi r29, r31, 0x100
	ctx.r[29].s64 = ctx.r[31].s64 + 256;
	// 8269B0E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269B0E4: 4BC46C6D  bl 0x822e1d50
	ctx.lr = 0x8269B0E8;
	sub_822E1D50(ctx, base);
	// 8269B0E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B0EC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8269B0F0: 835F0100  lwz r26, 0x100(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 8269B0F4: 4BE77025  bl 0x82512118
	ctx.lr = 0x8269B0F8;
	sub_82512118(ctx, base);
	// 8269B0F8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8269B0FC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B100: 48777D31  bl 0x82e12e30
	ctx.lr = 0x8269B104;
	sub_82E12E30(ctx, base);
	// 8269B104: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8269B108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269B10C: 419A0008  beq cr6, 0x8269b114
	if ctx.cr[6].eq {
	pc = 0x8269B114; continue 'dispatch;
	}
	// 8269B110: 4BC25781  bl 0x822c0890
	ctx.lr = 0x8269B114;
	sub_822C0890(ctx, base);
	// 8269B114: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269B118: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269B11C: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 8269B120: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269B124: 487572C5  bl 0x82df23e8
	ctx.lr = 0x8269B128;
	sub_82DF23E8(ctx, base);
	// 8269B128: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269B12C: 41820014  beq 0x8269b140
	if ctx.cr[0].eq {
	pc = 0x8269B140; continue 'dispatch;
	}
	// 8269B130: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269B134: 48777FBD  bl 0x82e130f0
	ctx.lr = 0x8269B138;
	sub_82E130F0(ctx, base);
	// 8269B138: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269B13C: 48000008  b 0x8269b144
	pc = 0x8269B144; continue 'dispatch;
	// 8269B140: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269B144: 3BDF0108  addi r30, r31, 0x108
	ctx.r[30].s64 = ctx.r[31].s64 + 264;
	// 8269B148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269B14C: 4BC46C05  bl 0x822e1d50
	ctx.lr = 0x8269B150;
	sub_822E1D50(ctx, base);
	// 8269B150: 809F0108  lwz r4, 0x108(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8269B154: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B158: 48777CD9  bl 0x82e12e30
	ctx.lr = 0x8269B15C;
	sub_82E12E30(ctx, base);
	// 8269B15C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8269B160: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B164: 4878F985  bl 0x82e2aae8
	ctx.lr = 0x8269B168;
	sub_82E2AAE8(ctx, base);
	// 8269B168: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269B16C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B170: 808B93E4  lwz r4, -0x6c1c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27676 as u32) ) } as u64;
	// 8269B174: 48758895  bl 0x82df3a08
	ctx.lr = 0x8269B178;
	sub_82DF3A08(ctx, base);
	// 8269B178: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269B17C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269B180: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8269B184: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269B188: 48793CE9  bl 0x82e2ee70
	ctx.lr = 0x8269B18C;
	sub_82E2EE70(ctx, base);
	// 8269B18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B190: 48758299  bl 0x82df3428
	ctx.lr = 0x8269B194;
	sub_82DF3428(ctx, base);
	// 8269B194: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8269B198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B19C: 419A00B0  beq cr6, 0x8269b24c
	if ctx.cr[6].eq {
	pc = 0x8269B24C; continue 'dispatch;
	}
	// 8269B1A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269B1A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269B1A8: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 8269B1AC: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8269B1B0: 48757239  bl 0x82df23e8
	ctx.lr = 0x8269B1B4;
	sub_82DF23E8(ctx, base);
	// 8269B1B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269B1B8: 41820014  beq 0x8269b1cc
	if ctx.cr[0].eq {
	pc = 0x8269B1CC; continue 'dispatch;
	}
	// 8269B1BC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269B1C0: 4877B6D1  bl 0x82e16890
	ctx.lr = 0x8269B1C4;
	sub_82E16890(ctx, base);
	// 8269B1C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269B1C8: 48000008  b 0x8269b1d0
	pc = 0x8269B1D0; continue 'dispatch;
	// 8269B1CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269B1D0: 3BBF0110  addi r29, r31, 0x110
	ctx.r[29].s64 = ctx.r[31].s64 + 272;
	// 8269B1D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269B1D8: 4BCC2199  bl 0x8235d370
	ctx.lr = 0x8269B1DC;
	sub_8235D370(ctx, base);
	// 8269B1DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269B1E0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B1E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269B1EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269B1F0: 419A0024  beq cr6, 0x8269b214
	if ctx.cr[6].eq {
	pc = 0x8269B214; continue 'dispatch;
	}
	// 8269B1F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269B1F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269B1FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269B200: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269B204: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269B208: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269B20C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269B210: 4082FFE8  bne 0x8269b1f8
	if !ctx.cr[0].eq {
	pc = 0x8269B1F8; continue 'dispatch;
	}
	// 8269B214: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269B218: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B21C: 48779E95  bl 0x82e150b0
	ctx.lr = 0x8269B220;
	sub_82E150B0(ctx, base);
	// 8269B220: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 8269B224: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 8269B228: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8269B22C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269B230: 4E800421  bctrl
	ctx.lr = 0x8269B234;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269B234: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8269B238: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269B23C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8269B240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269B244: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8269B248: 4BE75911  bl 0x82510b58
	ctx.lr = 0x8269B24C;
	sub_82510B58(ctx, base);
	// 8269B24C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8269B250: 48831799  bl 0x82ecc9e8
	ctx.lr = 0x8269B254;
	sub_82ECC9E8(ctx, base);
	// 8269B254: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 8269B258: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B25C: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 8269B260: 99610160  stb r11, 0x160(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u8 ) };
	// 8269B264: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8269B268: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 8269B26C: 7C7DF02E  lwzx r3, r29, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8269B270: 488054C1  bl 0x82ea0730
	ctx.lr = 0x8269B274;
	sub_82EA0730(ctx, base);
	// 8269B274: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8269B278: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 8269B27C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8269B280: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 8269B284: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8269B288: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8269B28C: C01F0120  lfs f0, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B290: C04BF614  lfs f2, -0x9ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8269B294: 3969BC40  addi r11, r9, -0x43c0
	ctx.r[11].s64 = ctx.r[9].s64 + -17344;
	// 8269B298: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8269B29C: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8269B2A0: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8269B2A4: C00808A4  lfs f0, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B2A8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8269B2AC: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269B2B0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8269B2B4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8269B2B8: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8269B2BC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 8269B2C0: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8269B2C4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269B2C8: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269B420 size=172
    let mut pc: u32 = 0x8269B420;
    'dispatch: loop {
        match pc {
            0x8269B420 => {
    //   block [0x8269B420..0x8269B4CC)
	// 8269B420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269B428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269B42C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269B430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269B438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269B43C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8269B440: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8269B444: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8269B448: 915E0030  stw r10, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 8269B44C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8269B450: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B454: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8269B458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269B45C: 4E800421  bctrl
	ctx.lr = 0x8269B460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269B460: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8269B464: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B468: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 8269B46C: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269B470: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269B474: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269B478: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8269B47C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8269B480: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8269B484: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8269B488: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269B4D0 size=316
    let mut pc: u32 = 0x8269B4D0;
    'dispatch: loop {
        match pc {
            0x8269B4D0 => {
    //   block [0x8269B4D0..0x8269B60C)
	// 8269B4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269B4D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269B4DC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8269B4E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B4E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269B4E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269B4EC: C01F0168  lfs f0, 0x168(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B4F0: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269B4F4: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8269B4F8: 419A00FC  beq cr6, 0x8269b5f4
	if ctx.cr[6].eq {
	pc = 0x8269B5F4; continue 'dispatch;
	}
	// 8269B4FC: C01F016C  lfs f0, 0x16c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B500: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8269B504: 419A00F0  beq cr6, 0x8269b5f4
	if ctx.cr[6].eq {
	pc = 0x8269B5F4; continue 'dispatch;
	}
	// 8269B508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B50C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B510: 4BE73FB9  bl 0x8250f4c8
	ctx.lr = 0x8269B514;
	sub_8250F4C8(ctx, base);
	// 8269B514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B51C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269B520: 409A0008  bne cr6, 0x8269b528
	if !ctx.cr[6].eq {
	pc = 0x8269B528; continue 'dispatch;
	}
	// 8269B524: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269B528: 4BE6CFF1  bl 0x82508518
	ctx.lr = 0x8269B52C;
	sub_82508518(ctx, base);
	// 8269B52C: C01F0170  lfs f0, 0x170(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B534: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8269B538: 48756759  bl 0x82df1c90
	ctx.lr = 0x8269B53C;
	sub_82DF1C90(ctx, base);
	// 8269B53C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269B540: C01F016C  lfs f0, 0x16c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B544: C17F0174  lfs f11, 0x174(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269B548: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269B54C: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8269B550: EDAB602A  fadds f13, f11, f12
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 8269B554: ED5F6824  fdivs f10, f31, f13
	ctx.f[10].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 8269B558: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 8269B55C: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 8269B560: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269B564: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 8269B568: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 8269B56C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269B570: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8269B574: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8269B578: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8269B57C: EDAAFB7C  fnmsubs f13, f10, f13, f31
	ctx.f[13].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 8269B580: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 8269B584: 4098001C  bge cr6, 0x8269b5a0
	if !ctx.cr[6].lt {
	pc = 0x8269B5A0; continue 'dispatch;
	}
	// 8269B588: 4082000C  bne 0x8269b594
	if !ctx.cr[0].eq {
	pc = 0x8269B594; continue 'dispatch;
	}
	// 8269B58C: C03F0168  lfs f1, 0x168(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269B590: 48000064  b 0x8269b5f4
	pc = 0x8269B5F4; continue 'dispatch;
	// 8269B594: C01F0168  lfs f0, 0x168(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269B598: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8269B59C: 48000058  b 0x8269b5f4
	pc = 0x8269B5F4; continue 'dispatch;
	// 8269B5A0: C17F0174  lfs f11, 0x174(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269B5A4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 8269B5A8: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8269B5AC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8269B5B0: 4082001C  bne 0x8269b5cc
	if !ctx.cr[0].eq {
	pc = 0x8269B5CC; continue 'dispatch;
	}
	// 8269B5B4: C18BDFAC  lfs f12, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269B5B8: C16A9524  lfs f11, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8269B5BC: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 8269B5C0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 8269B5C4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8269B5C8: 4800001C  b 0x8269b5e4
	pc = 0x8269B5E4; continue 'dispatch;
	// 8269B5CC: ED6D602A  fadds f11, f13, f12
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8269B5D0: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269B5D4: C18A9524  lfs f12, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269B5D8: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8269B5DC: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 8269B5E0: EC2002F2  fmuls f1, f0, f11
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 8269B5E4: 48B0D8C5  bl 0x831a8ea8
	ctx.lr = 0x8269B5E8;
	sub_831A8EA8(ctx, base);
	// 8269B5E8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8269B5EC: C1BF0168  lfs f13, 0x168(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269B5F0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8269B5F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269B5F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269B5FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269B600: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269B604: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269B608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269B610 size=184
    let mut pc: u32 = 0x8269B610;
    'dispatch: loop {
        match pc {
            0x8269B610 => {
    //   block [0x8269B610..0x8269B6C8)
	// 8269B610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269B618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269B61C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269B620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269B628: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269B62C: 3BFEFF1C  addi r31, r30, -0xe4
	ctx.r[31].s64 = ctx.r[30].s64 + -228;
	// 8269B630: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B634: 4BE73E95  bl 0x8250f4c8
	ctx.lr = 0x8269B638;
	sub_8250F4C8(ctx, base);
	// 8269B638: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B63C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B640: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269B644: 409A0008  bne cr6, 0x8269b64c
	if !ctx.cr[6].eq {
	pc = 0x8269B64C; continue 'dispatch;
	}
	// 8269B648: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269B64C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B650: 4BE6D141  bl 0x82508790
	ctx.lr = 0x8269B654;
	sub_82508790(ctx, base);
	// 8269B654: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269B658: 48756639  bl 0x82df1c90
	ctx.lr = 0x8269B65C;
	sub_82DF1C90(ctx, base);
	// 8269B65C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269B660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B664: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 8269B668: 487583A1  bl 0x82df3a08
	ctx.lr = 0x8269B66C;
	sub_82DF3A08(ctx, base);
	// 8269B66C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B670: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269B674: 4BE73E55  bl 0x8250f4c8
	ctx.lr = 0x8269B678;
	sub_8250F4C8(ctx, base);
	// 8269B678: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B680: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269B684: 409A0008  bne cr6, 0x8269b68c
	if !ctx.cr[6].eq {
	pc = 0x8269B68C; continue 'dispatch;
	}
	// 8269B688: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269B68C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269B690: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269B694: 4BE6D0ED  bl 0x82508780
	ctx.lr = 0x8269B698;
	sub_82508780(ctx, base);
	// 8269B698: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269B69C: 487565F5  bl 0x82df1c90
	ctx.lr = 0x8269B6A0;
	sub_82DF1C90(ctx, base);
	// 8269B6A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B6A4: 48757D85  bl 0x82df3428
	ctx.lr = 0x8269B6A8;
	sub_82DF3428(ctx, base);
	// 8269B6A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8269B6AC: 997E00AC  stb r11, 0xac(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[11].u8 ) };
	// 8269B6B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269B6B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269B6B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269B6BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269B6C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269B6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269B6C8 size=184
    let mut pc: u32 = 0x8269B6C8;
    'dispatch: loop {
        match pc {
            0x8269B6C8 => {
    //   block [0x8269B6C8..0x8269B780)
	// 8269B6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269B6D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269B6D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269B6D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B6DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269B6E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269B6E4: 3BFEFF1C  addi r31, r30, -0xe4
	ctx.r[31].s64 = ctx.r[30].s64 + -228;
	// 8269B6E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B6EC: 4BE73DDD  bl 0x8250f4c8
	ctx.lr = 0x8269B6F0;
	sub_8250F4C8(ctx, base);
	// 8269B6F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B6F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269B6FC: 409A0008  bne cr6, 0x8269b704
	if !ctx.cr[6].eq {
	pc = 0x8269B704; continue 'dispatch;
	}
	// 8269B700: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269B704: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B708: 4BE6D089  bl 0x82508790
	ctx.lr = 0x8269B70C;
	sub_82508790(ctx, base);
	// 8269B70C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269B710: 48756581  bl 0x82df1c90
	ctx.lr = 0x8269B714;
	sub_82DF1C90(ctx, base);
	// 8269B714: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269B718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B71C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8269B720: 487582E9  bl 0x82df3a08
	ctx.lr = 0x8269B724;
	sub_82DF3A08(ctx, base);
	// 8269B724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269B728: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269B72C: 4BE73D9D  bl 0x8250f4c8
	ctx.lr = 0x8269B730;
	sub_8250F4C8(ctx, base);
	// 8269B730: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B738: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269B73C: 409A0008  bne cr6, 0x8269b744
	if !ctx.cr[6].eq {
	pc = 0x8269B744; continue 'dispatch;
	}
	// 8269B740: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269B744: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269B748: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269B74C: 4BE6D035  bl 0x82508780
	ctx.lr = 0x8269B750;
	sub_82508780(ctx, base);
	// 8269B750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269B754: 4875653D  bl 0x82df1c90
	ctx.lr = 0x8269B758;
	sub_82DF1C90(ctx, base);
	// 8269B758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B75C: 48757CCD  bl 0x82df3428
	ctx.lr = 0x8269B760;
	sub_82DF3428(ctx, base);
	// 8269B760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269B764: 997E00AC  stb r11, 0xac(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[11].u8 ) };
	// 8269B768: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269B76C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269B770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269B774: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269B778: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269B77C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269B780 size=196
    let mut pc: u32 = 0x8269B780;
    'dispatch: loop {
        match pc {
            0x8269B780 => {
    //   block [0x8269B780..0x8269B844)
	// 8269B780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269B788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269B78C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269B790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B794: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269B798: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269B79C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8269B7A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269B7A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269B7A8: 4BC25191  bl 0x822c0938
	ctx.lr = 0x8269B7AC;
	sub_822C0938(ctx, base);
	// 8269B7AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269B7B0: 41820028  beq 0x8269b7d8
	if ctx.cr[0].eq {
	pc = 0x8269B7D8; continue 'dispatch;
	}
	// 8269B7B4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269B7B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8269B7BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8269B7C0: 392BFEC4  addi r9, r11, -0x13c
	ctx.r[9].s64 = ctx.r[11].s64 + -316;
	// 8269B7C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8269B7C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269B7CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8269B7D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8269B7D4: 48000008  b 0x8269b7dc
	pc = 0x8269B7DC; continue 'dispatch;
	// 8269B7D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269B7DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269B7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B7E4: 409A0044  bne cr6, 0x8269b828
	if !ctx.cr[6].eq {
	pc = 0x8269B828; continue 'dispatch;
	}
	// 8269B7E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269B7EC: 419A001C  beq cr6, 0x8269b808
	if ctx.cr[6].eq {
	pc = 0x8269B808; continue 'dispatch;
	}
	// 8269B7F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B7F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8269B7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269B7FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269B804: 4E800421  bctrl
	ctx.lr = 0x8269B808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269B808: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269B80C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269B810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B814: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8269B818: 816B94BC  lwz r11, -0x6b44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27460 as u32) ) } as u64;
	// 8269B81C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269B820: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269B824: 4BC247DD  bl 0x822c0000
	ctx.lr = 0x8269B828;
	sub_822C0000(ctx, base);
	// 8269B828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269B82C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269B830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269B834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269B838: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269B83C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269B840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269B848 size=196
    let mut pc: u32 = 0x8269B848;
    'dispatch: loop {
        match pc {
            0x8269B848 => {
    //   block [0x8269B848..0x8269B90C)
	// 8269B848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269B850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269B854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269B858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B85C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269B860: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269B864: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8269B868: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269B86C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269B870: 4BC250C9  bl 0x822c0938
	ctx.lr = 0x8269B874;
	sub_822C0938(ctx, base);
	// 8269B874: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269B878: 41820028  beq 0x8269b8a0
	if ctx.cr[0].eq {
	pc = 0x8269B8A0; continue 'dispatch;
	}
	// 8269B87C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269B880: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8269B884: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8269B888: 392BFED8  addi r9, r11, -0x128
	ctx.r[9].s64 = ctx.r[11].s64 + -296;
	// 8269B88C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8269B890: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269B894: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8269B898: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8269B89C: 48000008  b 0x8269b8a4
	pc = 0x8269B8A4; continue 'dispatch;
	// 8269B8A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269B8A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269B8A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269B8AC: 409A0044  bne cr6, 0x8269b8f0
	if !ctx.cr[6].eq {
	pc = 0x8269B8F0; continue 'dispatch;
	}
	// 8269B8B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269B8B4: 419A001C  beq cr6, 0x8269b8d0
	if ctx.cr[6].eq {
	pc = 0x8269B8D0; continue 'dispatch;
	}
	// 8269B8B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B8BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8269B8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269B8C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B8C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269B8CC: 4E800421  bctrl
	ctx.lr = 0x8269B8D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269B8D0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269B8D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269B8D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269B8DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8269B8E0: 816B94BC  lwz r11, -0x6b44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27460 as u32) ) } as u64;
	// 8269B8E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269B8E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269B8EC: 4BC24715  bl 0x822c0000
	ctx.lr = 0x8269B8F0;
	sub_822C0000(ctx, base);
	// 8269B8F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269B8F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269B8F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269B8FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269B900: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269B904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269B908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269B910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269B910 size=1264
    let mut pc: u32 = 0x8269B910;
    'dispatch: loop {
        match pc {
            0x8269B910 => {
    //   block [0x8269B910..0x8269BE00)
	// 8269B910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269B914: 48B0C841  bl 0x831a8154
	ctx.lr = 0x8269B918;
	sub_831A8130(ctx, base);
	// 8269B918: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 8269B91C: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269B920: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8269B924: 807C00F0  lwz r3, 0xf0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(240 as u32) ) } as u64;
	// 8269B928: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269B92C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8269B930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269B934: 4E800421  bctrl
	ctx.lr = 0x8269B938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269B938: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 8269B93C: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 8269B940: 817C0184  lwz r11, 0x184(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(388 as u32) ) } as u64;
	// 8269B944: 3BE00030  li r31, 0x30
	ctx.r[31].s64 = 48;
	// 8269B948: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269B94C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8269B950: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8269B954: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 8269B958: 13DD1C07  vcmpneb. (lvlx128) v30, v29, v3
	tmp.u32 = ctx.r[29].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269B95C: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8269B960: 13BE1C07  vcmpneb. (lvlx128) v29, v30, v3
	tmp.u32 = ctx.r[30].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269B964: 139F1C07  vcmpneb. (lvlx128) v28, v31, v3
	tmp.u32 = ctx.r[31].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269B968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269BE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269BE00 size=460
    let mut pc: u32 = 0x8269BE00;
    'dispatch: loop {
        match pc {
            0x8269BE00 => {
    //   block [0x8269BE00..0x8269BFCC)
	// 8269BE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269BE04: 48B0C365  bl 0x831a8168
	ctx.lr = 0x8269BE08;
	sub_831A8130(ctx, base);
	// 8269BE08: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8269BE0C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8269BE10: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8269BE14: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269BE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269BE1C: 4BE748ED  bl 0x82510708
	ctx.lr = 0x8269BE20;
	sub_82510708(ctx, base);
	// 8269BE20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269BE24: 4BFFF6AD  bl 0x8269b4d0
	ctx.lr = 0x8269BE28;
	sub_8269B4D0(ctx, base);
	// 8269BE28: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8269BE2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269BE30: C01F0194  lfs f0, 0x194(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269BE34: 815F0184  lwz r10, 0x184(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 8269BE38: D3DF0194  stfs f30, 0x194(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 8269BE3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8269BE40: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269BE44: D3FF01A0  stfs f31, 0x1a0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 8269BE48: D3FF01A8  stfs f31, 0x1a8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 8269BE4C: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 8269BE50: D01F01A4  stfs f0, 0x1a4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 8269BE54: 409A0020  bne cr6, 0x8269be74
	if !ctx.cr[6].eq {
	pc = 0x8269BE74; continue 'dispatch;
	}
	// 8269BE58: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8269BE5C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269BE60: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8269BE64: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8269BE68: 487E01B1  bl 0x82e7c018
	ctx.lr = 0x8269BE6C;
	sub_82E7C018(ctx, base);
	// 8269BE6C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 8269BE70: 4800000C  b 0x8269be7c
	pc = 0x8269BE7C; continue 'dispatch;
	// 8269BE74: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269BE78: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 8269BE7C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8269BE80: 487773E1  bl 0x82e13260
	ctx.lr = 0x8269BE84;
	sub_82E13260(ctx, base);
	// 8269BE84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269BE88: C1BF0178  lfs f13, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269BE8C: 815F0184  lwz r10, 0x184(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 8269BE90: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8269BE94: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269BE98: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 8269BE9C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8269BEA0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269BEA4: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8269BEA8: EC5DF02A  fadds f2, f29, f30
	ctx.f[2].f64 = ((ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64;
	// 8269BEAC: 409A0060  bne cr6, 0x8269bf0c
	if !ctx.cr[6].eq {
	pc = 0x8269BF0C; continue 'dispatch;
	}
	// 8269BEB0: 487E0169  bl 0x82e7c018
	ctx.lr = 0x8269BEB4;
	sub_82E7C018(ctx, base);
	// 8269BEB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269BEB8: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 8269BEBC: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8269BEC0: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 8269BEC4: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 8269BEC8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8269BECC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8269BED0: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269BED4: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 8269BED8: 13DC5C07  vcmpneb. (lvlx128) v30, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269BEDC: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8269BEE0: 13BD5C07  vcmpneb. (lvlx128) v29, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269BEE4: 139E5C07  vcmpneb. (lvlx128) v28, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269BEE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269BFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269BFD0 size=32
    let mut pc: u32 = 0x8269BFD0;
    'dispatch: loop {
        match pc {
            0x8269BFD0 => {
    //   block [0x8269BFD0..0x8269BFF0)
	// 8269BFD0: 810300F8  lwz r8, 0xf8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) } as u64;
	// 8269BFD4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8269BFD8: 394300F8  addi r10, r3, 0xf8
	ctx.r[10].s64 = ctx.r[3].s64 + 248;
	// 8269BFDC: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 8269BFE0: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 8269BFE4: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 8269BFE8: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 8269BFEC: 4BC28474  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269BFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269BFF0 size=112
    let mut pc: u32 = 0x8269BFF0;
    'dispatch: loop {
        match pc {
            0x8269BFF0 => {
    //   block [0x8269BFF0..0x8269C060)
	// 8269BFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269BFF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269BFF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269BFFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269C000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C004: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269C008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269C00C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8269C010: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269C014: 4BFFF835  bl 0x8269b848
	ctx.lr = 0x8269C018;
	sub_8269B848(ctx, base);
	// 8269C018: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8269C01C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269C020: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269C024: 4BC23FDD  bl 0x822c0000
	ctx.lr = 0x8269C028;
	sub_822C0000(ctx, base);
	// 8269C028: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8269C02C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8269C030: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269C034: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269C038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C03C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8269C040: 419A0008  beq cr6, 0x8269c048
	if ctx.cr[6].eq {
	pc = 0x8269C048; continue 'dispatch;
	}
	// 8269C044: 4BC2484D  bl 0x822c0890
	ctx.lr = 0x8269C048;
	sub_822C0890(ctx, base);
	// 8269C048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269C04C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269C050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269C054: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269C058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269C05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269C060 size=720
    let mut pc: u32 = 0x8269C060;
    'dispatch: loop {
        match pc {
            0x8269C060 => {
    //   block [0x8269C060..0x8269C330)
	// 8269C060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269C064: 48B0C109  bl 0x831a816c
	ctx.lr = 0x8269C068;
	sub_831A8130(ctx, base);
	// 8269C068: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 8269C06C: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8269C070: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8269C074: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C078: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269C07C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269C080: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269C084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C088: 388B1310  addi r4, r11, 0x1310
	ctx.r[4].s64 = ctx.r[11].s64 + 4880;
	// 8269C08C: 4875797D  bl 0x82df3a08
	ctx.lr = 0x8269C090;
	sub_82DF3A08(ctx, base);
	// 8269C090: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269C094: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8269C098: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8269C09C: 389F0084  addi r4, r31, 0x84
	ctx.r[4].s64 = ctx.r[31].s64 + 132;
	// 8269C0A0: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 8269C0A4: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8269C0A8: C3EA9A8C  lfs f31, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269C0AC: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8269C0B0: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8269C0B4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269C0B8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269C0BC: 4BF070F5  bl 0x825a31b0
	ctx.lr = 0x8269C0C0;
	sub_825A31B0(ctx, base);
	// 8269C0C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C0C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C0C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C0CC: 4BF056A5  bl 0x825a1770
	ctx.lr = 0x8269C0D0;
	sub_825A1770(ctx, base);
	// 8269C0D0: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 8269C0D4: 48757355  bl 0x82df3428
	ctx.lr = 0x8269C0D8;
	sub_82DF3428(ctx, base);
	// 8269C0D8: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 8269C0DC: 4BC2CBDD  bl 0x822c8cb8
	ctx.lr = 0x8269C0E0;
	sub_822C8CB8(ctx, base);
	// 8269C0E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C0E4: 48757345  bl 0x82df3428
	ctx.lr = 0x8269C0E8;
	sub_82DF3428(ctx, base);
	// 8269C0E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269C0EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C0F0: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 8269C0F4: 48757915  bl 0x82df3a08
	ctx.lr = 0x8269C0F8;
	sub_82DF3A08(ctx, base);
	// 8269C0F8: 389F0088  addi r4, r31, 0x88
	ctx.r[4].s64 = ctx.r[31].s64 + 136;
	// 8269C0FC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8269C100: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8269C104: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269C108: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269C10C: 4BF070A5  bl 0x825a31b0
	ctx.lr = 0x8269C110;
	sub_825A31B0(ctx, base);
	// 8269C110: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C114: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C118: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C11C: 4BF05655  bl 0x825a1770
	ctx.lr = 0x8269C120;
	sub_825A1770(ctx, base);
	// 8269C120: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8269C124: 48757305  bl 0x82df3428
	ctx.lr = 0x8269C128;
	sub_82DF3428(ctx, base);
	// 8269C128: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 8269C12C: 4BC2CB8D  bl 0x822c8cb8
	ctx.lr = 0x8269C130;
	sub_822C8CB8(ctx, base);
	// 8269C130: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C134: 487572F5  bl 0x82df3428
	ctx.lr = 0x8269C138;
	sub_82DF3428(ctx, base);
	// 8269C138: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269C13C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C140: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 8269C144: 487578C5  bl 0x82df3a08
	ctx.lr = 0x8269C148;
	sub_82DF3A08(ctx, base);
	// 8269C148: 389F008C  addi r4, r31, 0x8c
	ctx.r[4].s64 = ctx.r[31].s64 + 140;
	// 8269C14C: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 8269C150: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8269C154: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269C158: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269C15C: 4BF07055  bl 0x825a31b0
	ctx.lr = 0x8269C160;
	sub_825A31B0(ctx, base);
	// 8269C160: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C168: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C16C: 4BF05605  bl 0x825a1770
	ctx.lr = 0x8269C170;
	sub_825A1770(ctx, base);
	// 8269C170: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 8269C174: 487572B5  bl 0x82df3428
	ctx.lr = 0x8269C178;
	sub_82DF3428(ctx, base);
	// 8269C178: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 8269C17C: 4BC2CB3D  bl 0x822c8cb8
	ctx.lr = 0x8269C180;
	sub_822C8CB8(ctx, base);
	// 8269C180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C184: 487572A5  bl 0x82df3428
	ctx.lr = 0x8269C188;
	sub_82DF3428(ctx, base);
	// 8269C188: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269C18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C190: 388B4370  addi r4, r11, 0x4370
	ctx.r[4].s64 = ctx.r[11].s64 + 17264;
	// 8269C194: 48757875  bl 0x82df3a08
	ctx.lr = 0x8269C198;
	sub_82DF3A08(ctx, base);
	// 8269C198: 389F0090  addi r4, r31, 0x90
	ctx.r[4].s64 = ctx.r[31].s64 + 144;
	// 8269C19C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269C1A0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8269C1A4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269C1A8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269C1AC: 4BF07005  bl 0x825a31b0
	ctx.lr = 0x8269C1B0;
	sub_825A31B0(ctx, base);
	// 8269C1B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C1B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C1B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C1BC: 4BF055B5  bl 0x825a1770
	ctx.lr = 0x8269C1C0;
	sub_825A1770(ctx, base);
	// 8269C1C0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8269C1C4: 48757265  bl 0x82df3428
	ctx.lr = 0x8269C1C8;
	sub_82DF3428(ctx, base);
	// 8269C1C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8269C1CC: 4BC2CAED  bl 0x822c8cb8
	ctx.lr = 0x8269C1D0;
	sub_822C8CB8(ctx, base);
	// 8269C1D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C1D4: 48757255  bl 0x82df3428
	ctx.lr = 0x8269C1D8;
	sub_82DF3428(ctx, base);
	// 8269C1D8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269C1DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C1E0: 388BFF18  addi r4, r11, -0xe8
	ctx.r[4].s64 = ctx.r[11].s64 + -232;
	// 8269C1E4: 48757825  bl 0x82df3a08
	ctx.lr = 0x8269C1E8;
	sub_82DF3A08(ctx, base);
	// 8269C1E8: 389F0094  addi r4, r31, 0x94
	ctx.r[4].s64 = ctx.r[31].s64 + 148;
	// 8269C1EC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8269C1F0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8269C1F4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269C1F8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8269C1FC: 4BF06FB5  bl 0x825a31b0
	ctx.lr = 0x8269C200;
	sub_825A31B0(ctx, base);
	// 8269C200: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C20C: 4BF05565  bl 0x825a1770
	ctx.lr = 0x8269C210;
	sub_825A1770(ctx, base);
	// 8269C210: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8269C214: 48757215  bl 0x82df3428
	ctx.lr = 0x8269C218;
	sub_82DF3428(ctx, base);
	// 8269C218: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8269C21C: 4BC2CA9D  bl 0x822c8cb8
	ctx.lr = 0x8269C220;
	sub_822C8CB8(ctx, base);
	// 8269C220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C224: 48757205  bl 0x82df3428
	ctx.lr = 0x8269C228;
	sub_82DF3428(ctx, base);
	// 8269C228: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269C22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C230: 388BFF00  addi r4, r11, -0x100
	ctx.r[4].s64 = ctx.r[11].s64 + -256;
	// 8269C234: 487577D5  bl 0x82df3a08
	ctx.lr = 0x8269C238;
	sub_82DF3A08(ctx, base);
	// 8269C238: 3FA08205  lis r29, -0x7dfb
	ctx.r[29].s64 = -2113601536;
	// 8269C23C: 389F0098  addi r4, r31, 0x98
	ctx.r[4].s64 = ctx.r[31].s64 + 152;
	// 8269C240: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269C244: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8269C248: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269C24C: C07DFEB4  lfs f3, -0x14c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-332 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8269C250: 4BF06F61  bl 0x825a31b0
	ctx.lr = 0x8269C254;
	sub_825A31B0(ctx, base);
	// 8269C254: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C25C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C260: 4BF05511  bl 0x825a1770
	ctx.lr = 0x8269C264;
	sub_825A1770(ctx, base);
	// 8269C264: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 8269C268: 487571C1  bl 0x82df3428
	ctx.lr = 0x8269C26C;
	sub_82DF3428(ctx, base);
	// 8269C26C: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 8269C270: 4BC2CA49  bl 0x822c8cb8
	ctx.lr = 0x8269C274;
	sub_822C8CB8(ctx, base);
	// 8269C274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C278: 487571B1  bl 0x82df3428
	ctx.lr = 0x8269C27C;
	sub_82DF3428(ctx, base);
	// 8269C27C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269C280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C284: 388BFEE8  addi r4, r11, -0x118
	ctx.r[4].s64 = ctx.r[11].s64 + -280;
	// 8269C288: 48757781  bl 0x82df3a08
	ctx.lr = 0x8269C28C;
	sub_82DF3A08(ctx, base);
	// 8269C28C: 389F009C  addi r4, r31, 0x9c
	ctx.r[4].s64 = ctx.r[31].s64 + 156;
	// 8269C290: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 8269C294: C07DFEB4  lfs f3, -0x14c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-332 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8269C298: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8269C29C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8269C2A0: 4BF06F11  bl 0x825a31b0
	ctx.lr = 0x8269C2A4;
	sub_825A31B0(ctx, base);
	// 8269C2A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C2A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C2AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C2B0: 4BF054C1  bl 0x825a1770
	ctx.lr = 0x8269C2B4;
	sub_825A1770(ctx, base);
	// 8269C2B4: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 8269C2B8: 48757171  bl 0x82df3428
	ctx.lr = 0x8269C2BC;
	sub_82DF3428(ctx, base);
	// 8269C2BC: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 8269C2C0: 4BC2C9F9  bl 0x822c8cb8
	ctx.lr = 0x8269C2C4;
	sub_822C8CB8(ctx, base);
	// 8269C2C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C2C8: 48757161  bl 0x82df3428
	ctx.lr = 0x8269C2CC;
	sub_82DF3428(ctx, base);
	// 8269C2CC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8269C2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C2D4: 388B4A98  addi r4, r11, 0x4a98
	ctx.r[4].s64 = ctx.r[11].s64 + 19096;
	// 8269C2D8: 48757731  bl 0x82df3a08
	ctx.lr = 0x8269C2DC;
	sub_82DF3A08(ctx, base);
	// 8269C2DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8269C2E0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8269C2E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269C2E8: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 8269C2EC: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 8269C2F0: 4BF070B9  bl 0x825a33a8
	ctx.lr = 0x8269C2F4;
	sub_825A33A8(ctx, base);
	// 8269C2F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C2F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269C2FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C300: 4BF05BD9  bl 0x825a1ed8
	ctx.lr = 0x8269C304;
	sub_825A1ED8(ctx, base);
	// 8269C304: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 8269C308: 48757121  bl 0x82df3428
	ctx.lr = 0x8269C30C;
	sub_82DF3428(ctx, base);
	// 8269C30C: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 8269C310: 4BC2C9A9  bl 0x822c8cb8
	ctx.lr = 0x8269C314;
	sub_822C8CB8(ctx, base);
	// 8269C314: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269C318: 48757111  bl 0x82df3428
	ctx.lr = 0x8269C31C;
	sub_82DF3428(ctx, base);
	// 8269C31C: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 8269C320: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8269C324: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8269C328: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8269C32C: 48B0BE90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269C330 size=200
    let mut pc: u32 = 0x8269C330;
    'dispatch: loop {
        match pc {
            0x8269C330 => {
    //   block [0x8269C330..0x8269C3F8)
	// 8269C330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269C334: 48B0BE39  bl 0x831a816c
	ctx.lr = 0x8269C338;
	sub_831A8130(ctx, base);
	// 8269C338: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C33C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269C340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269C344: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269C348: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 8269C34C: 4BE7579D  bl 0x82511ae8
	ctx.lr = 0x8269C350;
	sub_82511AE8(ctx, base);
	// 8269C350: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8269C354: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269C358: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 8269C35C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269C360: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8269C364: 4816FB2D  bl 0x8280be90
	ctx.lr = 0x8269C368;
	sub_8280BE90(ctx, base);
	// 8269C368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269C36C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8269C370: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269C374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269C378: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269C37C: 419A0024  beq cr6, 0x8269c3a0
	if ctx.cr[6].eq {
	pc = 0x8269C3A0; continue 'dispatch;
	}
	// 8269C380: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269C384: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269C388: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269C38C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269C390: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269C394: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269C398: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269C39C: 4082FFE8  bne 0x8269c384
	if !ctx.cr[0].eq {
	pc = 0x8269C384; continue 'dispatch;
	}
	// 8269C3A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C3A4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8269C3A8: 4896BD81  bl 0x83008128
	ctx.lr = 0x8269C3AC;
	sub_83008128(ctx, base);
	// 8269C3AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269C3B0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269C3B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8269C3B8: 388AFF28  addi r4, r10, -0xd8
	ctx.r[4].s64 = ctx.r[10].s64 + -216;
	// 8269C3BC: 38A0010E  li r5, 0x10e
	ctx.r[5].s64 = 270;
	// 8269C3C0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8269C3C4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269C3C8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8269C3CC: 487BC675  bl 0x82e58a40
	ctx.lr = 0x8269C3D0;
	sub_82E58A40(ctx, base);
	// 8269C3D0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8269C3D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C3D8: 419A0008  beq cr6, 0x8269c3e0
	if ctx.cr[6].eq {
	pc = 0x8269C3E0; continue 'dispatch;
	}
	// 8269C3DC: 4BC244B5  bl 0x822c0890
	ctx.lr = 0x8269C3E0;
	sub_822C0890(ctx, base);
	// 8269C3E0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269C3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C3E8: 419A0008  beq cr6, 0x8269c3f0
	if ctx.cr[6].eq {
	pc = 0x8269C3F0; continue 'dispatch;
	}
	// 8269C3EC: 4BC244A5  bl 0x822c0890
	ctx.lr = 0x8269C3F0;
	sub_822C0890(ctx, base);
	// 8269C3F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269C3F4: 48B0BDC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269C3F8 size=220
    let mut pc: u32 = 0x8269C3F8;
    'dispatch: loop {
        match pc {
            0x8269C3F8 => {
    //   block [0x8269C3F8..0x8269C4D4)
	// 8269C3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269C3FC: 48B0BD6D  bl 0x831a8168
	ctx.lr = 0x8269C400;
	sub_831A8130(ctx, base);
	// 8269C400: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C404: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8269C408: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269C40C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269C410: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269C414: 41820038  beq 0x8269c44c
	if ctx.cr[0].eq {
	pc = 0x8269C44C; continue 'dispatch;
	}
	// 8269C418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269C41C: 48B0D56D  bl 0x831a9988
	ctx.lr = 0x8269C420;
	sub_831A9988(ctx, base);
	// 8269C420: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269C424: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269C428: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 8269C42C: 48B0BCCD  bl 0x831a80f8
	ctx.lr = 0x8269C430;
	sub_831A80F8(ctx, base);
	// 8269C430: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269C434: 41820018  beq 0x8269c44c
	if ctx.cr[0].eq {
	pc = 0x8269C44C; continue 'dispatch;
	}
	// 8269C438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269C43C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269C440: 4BFFFEF1  bl 0x8269c330
	ctx.lr = 0x8269C444;
	sub_8269C330(ctx, base);
	// 8269C444: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8269C448: 48000084  b 0x8269c4cc
	pc = 0x8269C4CC; continue 'dispatch;
	// 8269C44C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269C450: 419A006C  beq cr6, 0x8269c4bc
	if ctx.cr[6].eq {
	pc = 0x8269C4BC; continue 'dispatch;
	}
	// 8269C454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269C458: 48B0D531  bl 0x831a9988
	ctx.lr = 0x8269C45C;
	sub_831A9988(ctx, base);
	// 8269C45C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269C460: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269C464: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 8269C468: 48B0BC91  bl 0x831a80f8
	ctx.lr = 0x8269C46C;
	sub_831A80F8(ctx, base);
	// 8269C46C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269C470: 41820014  beq 0x8269c484
	if ctx.cr[0].eq {
	pc = 0x8269C484; continue 'dispatch;
	}
	// 8269C474: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269C478: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269C47C: 4BFFFB55  bl 0x8269bfd0
	ctx.lr = 0x8269C480;
	sub_8269BFD0(ctx, base);
	// 8269C480: 4BFFFFC4  b 0x8269c444
	pc = 0x8269C444; continue 'dispatch;
	// 8269C484: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269C488: 419A0034  beq cr6, 0x8269c4bc
	if ctx.cr[6].eq {
	pc = 0x8269C4BC; continue 'dispatch;
	}
	// 8269C48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269C490: 48B0D4F9  bl 0x831a9988
	ctx.lr = 0x8269C494;
	sub_831A9988(ctx, base);
	// 8269C494: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269C498: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269C49C: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 8269C4A0: 48B0BC59  bl 0x831a80f8
	ctx.lr = 0x8269C4A4;
	sub_831A80F8(ctx, base);
	// 8269C4A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269C4A8: 41820014  beq 0x8269c4bc
	if ctx.cr[0].eq {
	pc = 0x8269C4BC; continue 'dispatch;
	}
	// 8269C4AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269C4B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269C4B4: 4BFFEF6D  bl 0x8269b420
	ctx.lr = 0x8269C4B8;
	sub_8269B420(ctx, base);
	// 8269C4B8: 4BFFFF8C  b 0x8269c444
	pc = 0x8269C444; continue 'dispatch;
	// 8269C4BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8269C4C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269C4C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C4C8: 4BE76151  bl 0x82512618
	ctx.lr = 0x8269C4CC;
	sub_82512618(ctx, base);
	// 8269C4CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269C4D0: 48B0BCE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269C4D8 size=324
    let mut pc: u32 = 0x8269C4D8;
    'dispatch: loop {
        match pc {
            0x8269C4D8 => {
    //   block [0x8269C4D8..0x8269C61C)
	// 8269C4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269C4DC: 48B0BC8D  bl 0x831a8168
	ctx.lr = 0x8269C4E0;
	sub_831A8130(ctx, base);
	// 8269C4E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C4E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269C4E8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269C4EC: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269C4F0: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 8269C4F4: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269C4F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269C4FC: 394AFFD0  addi r10, r10, -0x30
	ctx.r[10].s64 = ctx.r[10].s64 + -48;
	// 8269C500: 3929FF84  addi r9, r9, -0x7c
	ctx.r[9].s64 = ctx.r[9].s64 + -124;
	// 8269C504: 397F0168  addi r11, r31, 0x168
	ctx.r[11].s64 = ctx.r[31].s64 + 360;
	// 8269C508: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8269C50C: 3B9F00E4  addi r28, r31, 0xe4
	ctx.r[28].s64 = ctx.r[31].s64 + 228;
	// 8269C510: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8269C514: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8269C518: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 8269C51C: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 8269C520: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269C524: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C528: 419A0008  beq cr6, 0x8269c530
	if ctx.cr[6].eq {
	pc = 0x8269C530; continue 'dispatch;
	}
	// 8269C52C: 4BC24365  bl 0x822c0890
	ctx.lr = 0x8269C530;
	sub_822C0890(ctx, base);
	// 8269C530: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269C534: 4080FFE8  bge 0x8269c51c
	if !ctx.cr[0].lt {
	pc = 0x8269C51C; continue 'dispatch;
	}
	// 8269C538: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 8269C53C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C540: 419A0008  beq cr6, 0x8269c548
	if ctx.cr[6].eq {
	pc = 0x8269C548; continue 'dispatch;
	}
	// 8269C544: 4BC2434D  bl 0x822c0890
	ctx.lr = 0x8269C548;
	sub_822C0890(ctx, base);
	// 8269C548: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 8269C54C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8269C550: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 8269C554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269C558: 4BE14D49  bl 0x824b12a0
	ctx.lr = 0x8269C55C;
	sub_824B12A0(ctx, base);
	// 8269C55C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269C560: 4080FFF0  bge 0x8269c550
	if !ctx.cr[0].lt {
	pc = 0x8269C550; continue 'dispatch;
	}
	// 8269C564: 397F0130  addi r11, r31, 0x130
	ctx.r[11].s64 = ctx.r[31].s64 + 304;
	// 8269C568: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8269C56C: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 8269C570: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 8269C574: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269C578: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C57C: 419A0008  beq cr6, 0x8269c584
	if ctx.cr[6].eq {
	pc = 0x8269C584; continue 'dispatch;
	}
	// 8269C580: 4BC24311  bl 0x822c0890
	ctx.lr = 0x8269C584;
	sub_822C0890(ctx, base);
	// 8269C584: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269C588: 4080FFE8  bge 0x8269c570
	if !ctx.cr[0].lt {
	pc = 0x8269C570; continue 'dispatch;
	}
	// 8269C58C: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 8269C590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C594: 419A0008  beq cr6, 0x8269c59c
	if ctx.cr[6].eq {
	pc = 0x8269C59C; continue 'dispatch;
	}
	// 8269C598: 4BC242F9  bl 0x822c0890
	ctx.lr = 0x8269C59C;
	sub_822C0890(ctx, base);
	// 8269C59C: 397F0118  addi r11, r31, 0x118
	ctx.r[11].s64 = ctx.r[31].s64 + 280;
	// 8269C5A0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8269C5A4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 8269C5A8: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 8269C5AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269C5B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C5B4: 419A0008  beq cr6, 0x8269c5bc
	if ctx.cr[6].eq {
	pc = 0x8269C5BC; continue 'dispatch;
	}
	// 8269C5B8: 4BC242D9  bl 0x822c0890
	ctx.lr = 0x8269C5BC;
	sub_822C0890(ctx, base);
	// 8269C5BC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269C5C0: 4080FFE8  bge 0x8269c5a8
	if !ctx.cr[0].lt {
	pc = 0x8269C5A8; continue 'dispatch;
	}
	// 8269C5C4: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 8269C5C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C5CC: 419A0008  beq cr6, 0x8269c5d4
	if ctx.cr[6].eq {
	pc = 0x8269C5D4; continue 'dispatch;
	}
	// 8269C5D0: 4BC242C1  bl 0x822c0890
	ctx.lr = 0x8269C5D4;
	sub_822C0890(ctx, base);
	// 8269C5D4: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 8269C5D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C5DC: 419A0008  beq cr6, 0x8269c5e4
	if ctx.cr[6].eq {
	pc = 0x8269C5E4; continue 'dispatch;
	}
	// 8269C5E0: 4BC242B1  bl 0x822c0890
	ctx.lr = 0x8269C5E4;
	sub_822C0890(ctx, base);
	// 8269C5E4: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 8269C5E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C5EC: 419A0008  beq cr6, 0x8269c5f4
	if ctx.cr[6].eq {
	pc = 0x8269C5F4; continue 'dispatch;
	}
	// 8269C5F0: 4BC242A1  bl 0x822c0890
	ctx.lr = 0x8269C5F4;
	sub_822C0890(ctx, base);
	// 8269C5F4: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 8269C5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269C5FC: 419A0008  beq cr6, 0x8269c604
	if ctx.cr[6].eq {
	pc = 0x8269C604; continue 'dispatch;
	}
	// 8269C600: 4BC24291  bl 0x822c0890
	ctx.lr = 0x8269C604;
	sub_822C0890(ctx, base);
	// 8269C604: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8269C608: 4810B051  bl 0x827a7658
	ctx.lr = 0x8269C60C;
	sub_827A7658(ctx, base);
	// 8269C60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269C610: 4BCB2D41  bl 0x8234f350
	ctx.lr = 0x8269C614;
	sub_8234F350(ctx, base);
	// 8269C614: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269C618: 48B0BBA0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269C620 size=8
    let mut pc: u32 = 0x8269C620;
    'dispatch: loop {
        match pc {
            0x8269C620 => {
    //   block [0x8269C620..0x8269C628)
	// 8269C620: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8269C624: 4800018C  b 0x8269c7b0
	sub_8269C7B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269C628 size=8
    let mut pc: u32 = 0x8269C628;
    'dispatch: loop {
        match pc {
            0x8269C628 => {
    //   block [0x8269C628..0x8269C630)
	// 8269C628: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8269C62C: 48000184  b 0x8269c7b0
	sub_8269C7B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269C630 size=380
    let mut pc: u32 = 0x8269C630;
    'dispatch: loop {
        match pc {
            0x8269C630 => {
    //   block [0x8269C630..0x8269C7AC)
	// 8269C630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269C634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269C638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269C63C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269C640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C644: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269C648: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8269C64C: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 8269C650: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 8269C654: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269C658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269C65C: 4BE75C05  bl 0x82512260
	ctx.lr = 0x8269C660;
	sub_82512260(ctx, base);
	// 8269C660: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269C664: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269C668: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 8269C66C: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269C670: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269C674: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8269C678: 394AFFE4  addi r10, r10, -0x1c
	ctx.r[10].s64 = ctx.r[10].s64 + -28;
	// 8269C67C: 3929FFD0  addi r9, r9, -0x30
	ctx.r[9].s64 = ctx.r[9].s64 + -48;
	// 8269C680: 3908FF84  addi r8, r8, -0x7c
	ctx.r[8].s64 = ctx.r[8].s64 + -124;
	// 8269C684: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8269C688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269C68C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 8269C690: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 8269C694: 395F0108  addi r10, r31, 0x108
	ctx.r[10].s64 = ctx.r[31].s64 + 264;
	// 8269C698: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 8269C69C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8269C6A0: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 8269C6A4: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 8269C6A8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 8269C6AC: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 8269C6B0: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 8269C6B4: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 8269C6B8: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 8269C6BC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269C6C0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8269C6C4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8269C6C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8269C6CC: 4080FFF0  bge 0x8269c6bc
	if !ctx.cr[0].lt {
	pc = 0x8269C6BC; continue 'dispatch;
	}
	// 8269C6D0: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 8269C6D4: 395F0120  addi r10, r31, 0x120
	ctx.r[10].s64 = ctx.r[31].s64 + 288;
	// 8269C6D8: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 8269C6DC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8269C6E0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269C6E4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8269C6E8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8269C6EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8269C6F0: 4080FFF0  bge 0x8269c6e0
	if !ctx.cr[0].lt {
	pc = 0x8269C6E0; continue 'dispatch;
	}
	// 8269C6F4: 395F0130  addi r10, r31, 0x130
	ctx.r[10].s64 = ctx.r[31].s64 + 304;
	// 8269C6F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8269C6FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8269C700: 916AFFFC  stw r11, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 8269C704: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8269C708: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269C70C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8269C710: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8269C714: 4080FFEC  bge 0x8269c700
	if !ctx.cr[0].lt {
	pc = 0x8269C700; continue 'dispatch;
	}
	// 8269C718: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 8269C71C: 395F0158  addi r10, r31, 0x158
	ctx.r[10].s64 = ctx.r[31].s64 + 344;
	// 8269C720: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 8269C724: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8269C728: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269C72C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8269C730: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8269C734: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8269C738: 4080FFF0  bge 0x8269c728
	if !ctx.cr[0].lt {
	pc = 0x8269C728; continue 'dispatch;
	}
	// 8269C73C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8269C740: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 8269C744: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8269C748: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 8269C74C: 396001A0  li r11, 0x1a0
	ctx.r[11].s64 = 416;
	// 8269C750: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269C754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269C758: C00A9524  lfs f0, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269C75C: C1A908A4  lfs f13, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269C760: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 8269C764: D01F016C  stfs f0, 0x16c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 8269C768: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 8269C76C: D1BF0170  stfs f13, 0x170(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 8269C770: D1BF0174  stfs f13, 0x174(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 8269C774: D1BF0194  stfs f13, 0x194(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 8269C778: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269C77C: C008FEB4  lfs f0, -0x14c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269C7B0 size=76
    let mut pc: u32 = 0x8269C7B0;
    'dispatch: loop {
        match pc {
            0x8269C7B0 => {
    //   block [0x8269C7B0..0x8269C7FC)
	// 8269C7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269C7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269C7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269C7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269C7C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269C7C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269C7CC: 4BFFFD0D  bl 0x8269c4d8
	ctx.lr = 0x8269C7D0;
	sub_8269C4D8(ctx, base);
	// 8269C7D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269C7D4: 4182000C  beq 0x8269c7e0
	if ctx.cr[0].eq {
	pc = 0x8269C7E0; continue 'dispatch;
	}
	// 8269C7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269C7DC: 48755BFD  bl 0x82df23d8
	ctx.lr = 0x8269C7E0;
	sub_82DF23D8(ctx, base);
	// 8269C7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269C7E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269C7E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269C7EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269C7F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269C7F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269C7F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269C800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269C800 size=1152
    let mut pc: u32 = 0x8269C800;
    'dispatch: loop {
        match pc {
            0x8269C800 => {
    //   block [0x8269C800..0x8269CC80)
	// 8269C800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269C804: 48B0B93D  bl 0x831a8140
	ctx.lr = 0x8269C808;
	sub_831A8130(ctx, base);
	// 8269C808: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 8269C80C: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 8269C810: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269C814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269C818: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 8269C81C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269C820: 40820450  bne 0x8269cc70
	if !ctx.cr[0].eq {
	pc = 0x8269CC70; continue 'dispatch;
	}
	// 8269C824: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8269C828: 488301C1  bl 0x82ecc9e8
	ctx.lr = 0x8269C82C;
	sub_82ECC9E8(ctx, base);
	// 8269C82C: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 8269C830: 996101D0  stb r11, 0x1d0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[11].u8 ) };
	// 8269C834: 817F0184  lwz r11, 0x184(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 8269C838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269C83C: 409A000C  bne cr6, 0x8269c848
	if !ctx.cr[6].eq {
	pc = 0x8269C848; continue 'dispatch;
	}
	// 8269C840: C3DF0178  lfs f30, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8269C844: 48000018  b 0x8269c85c
	pc = 0x8269C85C; continue 'dispatch;
	// 8269C848: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269C84C: C1BF0168  lfs f13, 0x168(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269C850: C19F0178  lfs f12, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269C854: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269C858: EFCD603A  fmadds f30, f13, f0, f12
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8269C85C: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269C860: 3B000014  li r24, 0x14
	ctx.r[24].s64 = 20;
	// 8269C864: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8269C868: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 8269C86C: 7C78C82E  lwzx r3, r24, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 8269C870: 48803EC1  bl 0x82ea0730
	ctx.lr = 0x8269C874;
	sub_82EA0730(ctx, base);
	// 8269C874: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269C878: 3EC08201  lis r22, -0x7dff
	ctx.r[22].s64 = -2113863680;
	// 8269C87C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269C880: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8269C884: 3A800060  li r20, 0x60
	ctx.r[20].s64 = 96;
	// 8269C888: C00B9530  lfs f0, -0x6ad0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269C88C: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 8269C890: EDBE0032  fmuls f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 8269C894: C0169450  lfs f0, -0x6bb0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269C898: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269C89C: EC1E0032  fmuls f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 8269C8A0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8269C8A4: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 8269C8A8: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8269C8AC: B2830004  sth r20, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[20].u16 ) };
	// 8269C8B0: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8269C8B4: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269C8B8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8269C8BC: 3EA08332  lis r21, -0x7cce
	ctx.r[21].s64 = -2093875200;
	// 8269C8C0: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269C8C4: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8269C8C8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8269C8CC: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 8269C8D0: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8269C8D4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8269C8D8: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8269C8DC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8269C8E0: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269CC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269CC80 size=424
    let mut pc: u32 = 0x8269CC80;
    'dispatch: loop {
        match pc {
            0x8269CC80 => {
    //   block [0x8269CC80..0x8269CE28)
	// 8269CC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269CC84: 48B0B4E1  bl 0x831a8164
	ctx.lr = 0x8269CC88;
	sub_831A8130(ctx, base);
	// 8269CC88: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269CC8C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269CC90: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8269CC94: 3BCBFF28  addi r30, r11, -0xd8
	ctx.r[30].s64 = ctx.r[11].s64 + -216;
	// 8269CC98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8269CC9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269CCA0: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 8269CCA4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8269CCA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269CCAC: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 8269CCB0: 48755739  bl 0x82df23e8
	ctx.lr = 0x8269CCB4;
	sub_82DF23E8(ctx, base);
	// 8269CCB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269CCB8: 41820010  beq 0x8269ccc8
	if ctx.cr[0].eq {
	pc = 0x8269CCC8; continue 'dispatch;
	}
	// 8269CCBC: 4BFFF975  bl 0x8269c630
	ctx.lr = 0x8269CCC0;
	sub_8269C630(ctx, base);
	// 8269CCC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269CCC4: 48000008  b 0x8269cccc
	pc = 0x8269CCCC; continue 'dispatch;
	// 8269CCC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269CCCC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8269CCD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269CCD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269CCD8: 4BFFEAA9  bl 0x8269b780
	ctx.lr = 0x8269CCDC;
	sub_8269B780(ctx, base);
	// 8269CCDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269CCE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269CCE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269CCE8: 4BC23319  bl 0x822c0000
	ctx.lr = 0x8269CCEC;
	sub_822C0000(ctx, base);
	// 8269CCEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269CCF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269CCF4: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 8269CCF8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8269CCFC: 4BC236DD  bl 0x822c03d8
	ctx.lr = 0x8269CD00;
	sub_822C03D8(ctx, base);
	// 8269CD00: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8269CD04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269CD08: 418200B4  beq 0x8269cdbc
	if ctx.cr[0].eq {
	pc = 0x8269CDBC; continue 'dispatch;
	}
	// 8269CD0C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8269CD10: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8269CD14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8269CD18: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8269CD1C: 409A0008  bne cr6, 0x8269cd24
	if !ctx.cr[6].eq {
	pc = 0x8269CD24; continue 'dispatch;
	}
	// 8269CD20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269CD24: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8269CD28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269CD2C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8269CD30: 419A0024  beq cr6, 0x8269cd54
	if ctx.cr[6].eq {
	pc = 0x8269CD54; continue 'dispatch;
	}
	// 8269CD34: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269CD38: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8269CD3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269CD40: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8269CD44: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8269CD48: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269CD4C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269CD50: 4082FFE8  bne 0x8269cd38
	if !ctx.cr[0].eq {
	pc = 0x8269CD38; continue 'dispatch;
	}
	// 8269CD54: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8269CD58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269CD5C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8269CD60: 419A0024  beq cr6, 0x8269cd84
	if ctx.cr[6].eq {
	pc = 0x8269CD84; continue 'dispatch;
	}
	// 8269CD64: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269CD68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269CD6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269CD70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269CD74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269CD78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269CD7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269CD80: 4082FFE8  bne 0x8269cd68
	if !ctx.cr[0].eq {
	pc = 0x8269CD68; continue 'dispatch;
	}
	// 8269CD84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269CD88: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8269CD8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8269CD90: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8269CD94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8269CD98: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269CD9C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269CDA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269CDA4: 480FC18D  bl 0x82798f30
	ctx.lr = 0x8269CDA8;
	sub_82798F30(ctx, base);
	// 8269CDA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269CDAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269CDB0: 480FE8B9  bl 0x8279b668
	ctx.lr = 0x8269CDB4;
	sub_8279B668(ctx, base);
	// 8269CDB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269CDB8: 48000008  b 0x8269cdc0
	pc = 0x8269CDC0; continue 'dispatch;
	// 8269CDBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269CDC0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8269CDC4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8269CDC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269CDCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269CDD0: 4BEFAE81  bl 0x82597c50
	ctx.lr = 0x8269CDD4;
	sub_82597C50(ctx, base);
	// 8269CDD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269CDD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269CDDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269CDE0: 4BC23221  bl 0x822c0000
	ctx.lr = 0x8269CDE4;
	sub_822C0000(ctx, base);
	// 8269CDE4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269CDE8: 41820024  beq 0x8269ce0c
	if ctx.cr[0].eq {
	pc = 0x8269CE0C; continue 'dispatch;
	}
	// 8269CDEC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8269CDF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269CDF4: 419A0008  beq cr6, 0x8269cdfc
	if ctx.cr[6].eq {
	pc = 0x8269CDFC; continue 'dispatch;
	}
	// 8269CDF8: 4BC23A99  bl 0x822c0890
	ctx.lr = 0x8269CDFC;
	sub_822C0890(ctx, base);
	// 8269CDFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8269CE00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269CE04: 419A0008  beq cr6, 0x8269ce0c
	if ctx.cr[6].eq {
	pc = 0x8269CE0C; continue 'dispatch;
	}
	// 8269CE08: 4BC23A89  bl 0x822c0890
	ctx.lr = 0x8269CE0C;
	sub_822C0890(ctx, base);
	// 8269CE0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269CE10: 419A000C  beq cr6, 0x8269ce1c
	if ctx.cr[6].eq {
	pc = 0x8269CE1C; continue 'dispatch;
	}
	// 8269CE14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269CE18: 4BC23A79  bl 0x822c0890
	ctx.lr = 0x8269CE1C;
	sub_822C0890(ctx, base);
	// 8269CE1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8269CE20: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8269CE24: 48B0B390  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269CE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269CE28 size=516
    let mut pc: u32 = 0x8269CE28;
    'dispatch: loop {
        match pc {
            0x8269CE28 => {
    //   block [0x8269CE28..0x8269D02C)
	// 8269CE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269CE2C: 48B0B311  bl 0x831a813c
	ctx.lr = 0x8269CE30;
	sub_831A8130(ctx, base);
	// 8269CE30: DBE1FF78  stfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 8269CE34: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269CE38: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8269CE3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8269CE40: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269CE44: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269CE48: 3ABD0120  addi r21, r29, 0x120
	ctx.r[21].s64 = ctx.r[29].s64 + 288;
	// 8269CE4C: C3E90A90  lfs f31, 0xa90(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2704 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269CE50: 3A7D017C  addi r19, r29, 0x17c
	ctx.r[19].s64 = ctx.r[29].s64 + 380;
	// 8269CE54: 3B3D0134  addi r25, r29, 0x134
	ctx.r[25].s64 = ctx.r[29].s64 + 308;
	// 8269CE58: 3A200002  li r17, 2
	ctx.r[17].s64 = 2;
	// 8269CE5C: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 8269CE60: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 8269CE64: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 8269CE68: 3E80832A  lis r20, -0x7cd6
	ctx.r[20].s64 = -2094399488;
	// 8269CE6C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 8269CE70: 3B6B6880  addi r27, r11, 0x6880
	ctx.r[27].s64 = ctx.r[11].s64 + 26752;
	// 8269CE74: 3A4AFF28  addi r18, r10, -0xd8
	ctx.r[18].s64 = ctx.r[10].s64 + -216;
	// 8269CE78: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269CE7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269CE80: 419A0050  beq cr6, 0x8269ced0
	if ctx.cr[6].eq {
	pc = 0x8269CED0; continue 'dispatch;
	}
	// 8269CE84: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269CE88: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8269CE8C: 7D7F1E71  srawi. r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269CE90: 40810040  ble 0x8269ced0
	if !ctx.cr[0].gt {
	pc = 0x8269CED0; continue 'dispatch;
	}
	// 8269CE94: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269CE98: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8269CE9C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8269CEA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269CEA4: 4BE7334D  bl 0x825101f0
	ctx.lr = 0x8269CEA8;
	sub_825101F0(ctx, base);
	// 8269CEA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8269CEAC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269CEB0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269CEB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269CEB8: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8269CEBC: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8269CEC0: 4BE73331  bl 0x825101f0
	ctx.lr = 0x8269CEC4;
	sub_825101F0(ctx, base);
	// 8269CEC4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269CEC8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 8269CECC: 4082FFE0  bne 0x8269ceac
	if !ctx.cr[0].eq {
	pc = 0x8269CEAC; continue 'dispatch;
	}
	// 8269CED0: 3BD9FFFC  addi r30, r25, -4
	ctx.r[30].s64 = ctx.r[25].s64 + -4;
	// 8269CED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269CED8: 4BC29CD1  bl 0x822c6ba8
	ctx.lr = 0x8269CEDC;
	sub_822C6BA8(ctx, base);
	// 8269CEDC: C0130000  lfs f0, 0(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269CEE0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8269CEE4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8269CEE8: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 8269CEEC: 83E1006C  lwz r31, 0x6c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8269CEF0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269CEF4: 40990118  ble cr6, 0x8269d00c
	if !ctx.cr[6].gt {
	pc = 0x8269D00C; continue 'dispatch;
	}
	// 8269CEF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269CEFC: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8269CF00: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8269CF04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269CF08: 4BE73C51  bl 0x82510b58
	ctx.lr = 0x8269CF0C;
	sub_82510B58(ctx, base);
	// 8269CF0C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 8269CF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269CF14: 809494B8  lwz r4, -0x6b48(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-27464 as u32) ) } as u64;
	// 8269CF18: 48756AF1  bl 0x82df3a08
	ctx.lr = 0x8269CF1C;
	sub_82DF3A08(ctx, base);
	// 8269CF1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269CF20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269CF24: 809D00E8  lwz r4, 0xe8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(232 as u32) ) } as u64;
	// 8269CF28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269CF2C: 48791F45  bl 0x82e2ee70
	ctx.lr = 0x8269CF30;
	sub_82E2EE70(ctx, base);
	// 8269CF30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269CF34: 487564F5  bl 0x82df3428
	ctx.lr = 0x8269CF38;
	sub_82DF3428(ctx, base);
	// 8269CF38: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8269CF3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269CF40: 419A00B4  beq cr6, 0x8269cff4
	if ctx.cr[6].eq {
	pc = 0x8269CFF4; continue 'dispatch;
	}
	// 8269CF44: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 8269CF48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269CF4C: 38A00147  li r5, 0x147
	ctx.r[5].s64 = 327;
	// 8269CF50: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8269CF54: 48755495  bl 0x82df23e8
	ctx.lr = 0x8269CF58;
	sub_82DF23E8(ctx, base);
	// 8269CF58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269CF5C: 41820014  beq 0x8269cf70
	if ctx.cr[0].eq {
	pc = 0x8269CF70; continue 'dispatch;
	}
	// 8269CF60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269CF64: 4877992D  bl 0x82e16890
	ctx.lr = 0x8269CF68;
	sub_82E16890(ctx, base);
	// 8269CF68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269CF6C: 48000008  b 0x8269cf74
	pc = 0x8269CF74; continue 'dispatch;
	// 8269CF70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269CF74: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8269CF78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269CF7C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8269CF80: 4BCBC139  bl 0x823590b8
	ctx.lr = 0x8269CF84;
	sub_823590B8(ctx, base);
	// 8269CF84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269CF88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269CF8C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8269CF90: 4BC23071  bl 0x822c0000
	ctx.lr = 0x8269CF94;
	sub_822C0000(ctx, base);
	// 8269CF94: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8269CF98: 13F6DC07  vcmpneb. (lvlx128) v31, v22, v27
	tmp.u32 = ctx.r[22].u32 + ctx.r[27].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269CF9C: 13D7DC07  vcmpneb. (lvlx128) v30, v23, v27
	tmp.u32 = ctx.r[23].u32 + ctx.r[27].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269CFA0: 13B8DC07  vcmpneb. (lvlx128) v29, v24, v27
	tmp.u32 = ctx.r[24].u32 + ctx.r[27].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269CFA4: 1380DC07  vcmpneb. (lvlx128) v28, v0, v27
	tmp.u32 = ctx.r[27].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269CFA8: 806B0084  lwz r3, 0x84(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 8269CFAC: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269D030 size=116
    let mut pc: u32 = 0x8269D030;
    'dispatch: loop {
        match pc {
            0x8269D030 => {
    //   block [0x8269D030..0x8269D0A4)
	// 8269D030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269D038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269D03C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269D040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269D048: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269D04C: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269D050: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8269D054: 409A0014  bne cr6, 0x8269d068
	if !ctx.cr[6].eq {
	pc = 0x8269D068; continue 'dispatch;
	}
	// 8269D058: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269D05C: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269D060: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8269D064: 419A0028  beq cr6, 0x8269d08c
	if ctx.cr[6].eq {
	pc = 0x8269D08C; continue 'dispatch;
	}
	// 8269D068: 3BDFFF1C  addi r30, r31, -0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + -228;
	// 8269D06C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D070: 4BFFFDB9  bl 0x8269ce28
	ctx.lr = 0x8269D074;
	sub_8269CE28(ctx, base);
	// 8269D074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D078: 4BFFE899  bl 0x8269b910
	ctx.lr = 0x8269D07C;
	sub_8269B910(ctx, base);
	// 8269D07C: C01F0098  lfs f0, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269D080: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269D084: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8269D088: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8269D08C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269D090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269D094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269D098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269D09C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269D0A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269D0A8 size=396
    let mut pc: u32 = 0x8269D0A8;
    'dispatch: loop {
        match pc {
            0x8269D0A8 => {
    //   block [0x8269D0A8..0x8269D234)
	// 8269D0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D0AC: 48B0B0B9  bl 0x831a8164
	ctx.lr = 0x8269D0B0;
	sub_831A8130(ctx, base);
	// 8269D0B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D0B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269D0B8: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D0BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269D0C0: 4878DA29  bl 0x82e2aae8
	ctx.lr = 0x8269D0C4;
	sub_82E2AAE8(ctx, base);
	// 8269D0C4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269D0C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269D0CC: 3B8B94B0  addi r28, r11, -0x6b50
	ctx.r[28].s64 = ctx.r[11].s64 + -27472;
	// 8269D0D0: 808B94B0  lwz r4, -0x6b50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27472 as u32) ) } as u64;
	// 8269D0D4: 48756935  bl 0x82df3a08
	ctx.lr = 0x8269D0D8;
	sub_82DF3A08(ctx, base);
	// 8269D0D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D0DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269D0E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269D0E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269D0E8: 48791D89  bl 0x82e2ee70
	ctx.lr = 0x8269D0EC;
	sub_82E2EE70(ctx, base);
	// 8269D0EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269D0F0: 48756339  bl 0x82df3428
	ctx.lr = 0x8269D0F4;
	sub_82DF3428(ctx, base);
	// 8269D0F4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269D0F8: 3B6BFF28  addi r27, r11, -0xd8
	ctx.r[27].s64 = ctx.r[11].s64 + -216;
	// 8269D0FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8269D100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269D104: 419A0058  beq cr6, 0x8269d15c
	if ctx.cr[6].eq {
	pc = 0x8269D15C; continue 'dispatch;
	}
	// 8269D108: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D10C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D110: 38A000C7  li r5, 0xc7
	ctx.r[5].s64 = 199;
	// 8269D114: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8269D118: 487552D1  bl 0x82df23e8
	ctx.lr = 0x8269D11C;
	sub_82DF23E8(ctx, base);
	// 8269D11C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D120: 41820014  beq 0x8269d134
	if ctx.cr[0].eq {
	pc = 0x8269D134; continue 'dispatch;
	}
	// 8269D124: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8269D128: 48779769  bl 0x82e16890
	ctx.lr = 0x8269D12C;
	sub_82E16890(ctx, base);
	// 8269D12C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D130: 48000008  b 0x8269d138
	pc = 0x8269D138; continue 'dispatch;
	// 8269D134: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D138: 3BFE0118  addi r31, r30, 0x118
	ctx.r[31].s64 = ctx.r[30].s64 + 280;
	// 8269D13C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D140: 4BCC0231  bl 0x8235d370
	ctx.lr = 0x8269D144;
	sub_8235D370(ctx, base);
	// 8269D144: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8269D148: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269D14C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269D150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D154: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8269D158: 4BE73A01  bl 0x82510b58
	ctx.lr = 0x8269D15C;
	sub_82510B58(ctx, base);
	// 8269D15C: 3BFE0120  addi r31, r30, 0x120
	ctx.r[31].s64 = ctx.r[30].s64 + 288;
	// 8269D160: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 8269D164: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269D168: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269D16C: 4875689D  bl 0x82df3a08
	ctx.lr = 0x8269D170;
	sub_82DF3A08(ctx, base);
	// 8269D170: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D174: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8269D178: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269D17C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8269D180: 48791CF1  bl 0x82e2ee70
	ctx.lr = 0x8269D184;
	sub_82E2EE70(ctx, base);
	// 8269D184: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269D188: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8269D18C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8269D190: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D194: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8269D198: 4BC272C9  bl 0x822c4460
	ctx.lr = 0x8269D19C;
	sub_822C4460(ctx, base);
	// 8269D19C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8269D1A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D1A4: 419A0008  beq cr6, 0x8269d1ac
	if ctx.cr[6].eq {
	pc = 0x8269D1AC; continue 'dispatch;
	}
	// 8269D1A8: 4BC236E9  bl 0x822c0890
	ctx.lr = 0x8269D1AC;
	sub_822C0890(ctx, base);
	// 8269D1AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269D1B0: 48756279  bl 0x82df3428
	ctx.lr = 0x8269D1B4;
	sub_82DF3428(ctx, base);
	// 8269D1B4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8269D1B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269D1BC: 419A003C  beq cr6, 0x8269d1f8
	if ctx.cr[6].eq {
	pc = 0x8269D1F8; continue 'dispatch;
	}
	// 8269D1C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D1C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D1C8: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 8269D1CC: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8269D1D0: 48755219  bl 0x82df23e8
	ctx.lr = 0x8269D1D4;
	sub_82DF23E8(ctx, base);
	// 8269D1D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D1D8: 41820014  beq 0x8269d1ec
	if ctx.cr[0].eq {
	pc = 0x8269D1EC; continue 'dispatch;
	}
	// 8269D1DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8269D1E0: 487796B1  bl 0x82e16890
	ctx.lr = 0x8269D1E4;
	sub_82E16890(ctx, base);
	// 8269D1E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D1E8: 48000008  b 0x8269d1f0
	pc = 0x8269D1F0; continue 'dispatch;
	// 8269D1EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D1F4: 4BCC017D  bl 0x8235d370
	ctx.lr = 0x8269D1F8;
	sub_8235D370(ctx, base);
	// 8269D1F8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269D1FC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 8269D200: 4082FF64  bne 0x8269d164
	if !ctx.cr[0].eq {
	pc = 0x8269D164; continue 'dispatch;
	}
	// 8269D204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D208: 4BFFFC21  bl 0x8269ce28
	ctx.lr = 0x8269D20C;
	sub_8269CE28(ctx, base);
	// 8269D20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D210: 4BFFE701  bl 0x8269b910
	ctx.lr = 0x8269D214;
	sub_8269B910(ctx, base);
	// 8269D214: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269D218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D21C: 419A0008  beq cr6, 0x8269d224
	if ctx.cr[6].eq {
	pc = 0x8269D224; continue 'dispatch;
	}
	// 8269D220: 4BC23671  bl 0x822c0890
	ctx.lr = 0x8269D224;
	sub_822C0890(ctx, base);
	// 8269D224: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269D228: 4878D8D9  bl 0x82e2ab00
	ctx.lr = 0x8269D22C;
	sub_82E2AB00(ctx, base);
	// 8269D22C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8269D230: 48B0AF84  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269D238 size=676
    let mut pc: u32 = 0x8269D238;
    'dispatch: loop {
        match pc {
            0x8269D238 => {
    //   block [0x8269D238..0x8269D4DC)
	// 8269D238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D23C: 48B0AF1D  bl 0x831a8158
	ctx.lr = 0x8269D240;
	sub_831A8130(ctx, base);
	// 8269D240: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269D248: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8269D24C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8269D250: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 8269D254: 4BE74785  bl 0x825119d8
	ctx.lr = 0x8269D258;
	sub_825119D8(ctx, base);
	// 8269D258: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269D25C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D260: 3B6BFF28  addi r27, r11, -0xd8
	ctx.r[27].s64 = ctx.r[11].s64 + -216;
	// 8269D264: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 8269D268: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D26C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8269D270: 4BC23169  bl 0x822c03d8
	ctx.lr = 0x8269D274;
	sub_822C03D8(ctx, base);
	// 8269D274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D278: 41820014  beq 0x8269d28c
	if ctx.cr[0].eq {
	pc = 0x8269D28C; continue 'dispatch;
	}
	// 8269D27C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D280: 4878D869  bl 0x82e2aae8
	ctx.lr = 0x8269D284;
	sub_82E2AAE8(ctx, base);
	// 8269D284: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D288: 48000008  b 0x8269d290
	pc = 0x8269D290; continue 'dispatch;
	// 8269D28C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D290: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 8269D294: 4BFFED5D  bl 0x8269bff0
	ctx.lr = 0x8269D298;
	sub_8269BFF0(ctx, base);
	// 8269D298: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269D29C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269D2A0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8269D2A4: 48756765  bl 0x82df3a08
	ctx.lr = 0x8269D2A8;
	sub_82DF3A08(ctx, base);
	// 8269D2A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269D2AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269D2B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D2B4: 4BE6B4CD  bl 0x82508780
	ctx.lr = 0x8269D2B8;
	sub_82508780(ctx, base);
	// 8269D2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269D2BC: 4875616D  bl 0x82df3428
	ctx.lr = 0x8269D2C0;
	sub_82DF3428(ctx, base);
	// 8269D2C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269D2C4: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8269D2C8: 409A0008  bne cr6, 0x8269d2d0
	if !ctx.cr[6].eq {
	pc = 0x8269D2D0; continue 'dispatch;
	}
	// 8269D2CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D2D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D2D4: 4BE6B4CD  bl 0x825087a0
	ctx.lr = 0x8269D2D8;
	sub_825087A0(ctx, base);
	// 8269D2D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D2DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D2E0: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 8269D2E4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269D2E8: 48755101  bl 0x82df23e8
	ctx.lr = 0x8269D2EC;
	sub_82DF23E8(ctx, base);
	// 8269D2EC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269D2F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D2F4: 3B8B6880  addi r28, r11, 0x6880
	ctx.r[28].s64 = ctx.r[11].s64 + 26752;
	// 8269D2F8: 41820014  beq 0x8269d30c
	if ctx.cr[0].eq {
	pc = 0x8269D30C; continue 'dispatch;
	}
	// 8269D2FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8269D300: 48775DF1  bl 0x82e130f0
	ctx.lr = 0x8269D304;
	sub_82E130F0(ctx, base);
	// 8269D304: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D308: 48000008  b 0x8269d310
	pc = 0x8269D310; continue 'dispatch;
	// 8269D30C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D310: 3BBF00F0  addi r29, r31, 0xf0
	ctx.r[29].s64 = ctx.r[31].s64 + 240;
	// 8269D314: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269D318: 4BC44A39  bl 0x822e1d50
	ctx.lr = 0x8269D31C;
	sub_822E1D50(ctx, base);
	// 8269D31C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D320: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D324: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 8269D328: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269D32C: 487550BD  bl 0x82df23e8
	ctx.lr = 0x8269D330;
	sub_82DF23E8(ctx, base);
	// 8269D330: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D334: 41820014  beq 0x8269d348
	if ctx.cr[0].eq {
	pc = 0x8269D348; continue 'dispatch;
	}
	// 8269D338: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8269D33C: 48775DB5  bl 0x82e130f0
	ctx.lr = 0x8269D340;
	sub_82E130F0(ctx, base);
	// 8269D340: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D344: 48000008  b 0x8269d34c
	pc = 0x8269D34C; continue 'dispatch;
	// 8269D348: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D34C: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 8269D350: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D354: 4BC449FD  bl 0x822e1d50
	ctx.lr = 0x8269D358;
	sub_822E1D50(ctx, base);
	// 8269D358: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269D35C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269D360: 831D0000  lwz r24, 0(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D364: 4BE74DB5  bl 0x82512118
	ctx.lr = 0x8269D368;
	sub_82512118(ctx, base);
	// 8269D368: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8269D36C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D370: 48775AC1  bl 0x82e12e30
	ctx.lr = 0x8269D374;
	sub_82E12E30(ctx, base);
	// 8269D374: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269D378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D37C: 419A0008  beq cr6, 0x8269d384
	if ctx.cr[6].eq {
	pc = 0x8269D384; continue 'dispatch;
	}
	// 8269D380: 4BC23511  bl 0x822c0890
	ctx.lr = 0x8269D384;
	sub_822C0890(ctx, base);
	// 8269D384: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D388: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D38C: 48775AA5  bl 0x82e12e30
	ctx.lr = 0x8269D390;
	sub_82E12E30(ctx, base);
	// 8269D390: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D394: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D398: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 8269D39C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269D3A0: 48755049  bl 0x82df23e8
	ctx.lr = 0x8269D3A4;
	sub_82DF23E8(ctx, base);
	// 8269D3A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D3A8: 41820014  beq 0x8269d3bc
	if ctx.cr[0].eq {
	pc = 0x8269D3BC; continue 'dispatch;
	}
	// 8269D3AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8269D3B0: 48775D41  bl 0x82e130f0
	ctx.lr = 0x8269D3B4;
	sub_82E130F0(ctx, base);
	// 8269D3B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D3B8: 48000008  b 0x8269d3c0
	pc = 0x8269D3C0; continue 'dispatch;
	// 8269D3BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D3C0: 387F0108  addi r3, r31, 0x108
	ctx.r[3].s64 = ctx.r[31].s64 + 264;
	// 8269D3C4: 4BC4498D  bl 0x822e1d50
	ctx.lr = 0x8269D3C8;
	sub_822E1D50(ctx, base);
	// 8269D3C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269D3CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269D3D0: 83DF0108  lwz r30, 0x108(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8269D3D4: 4BE74D45  bl 0x82512118
	ctx.lr = 0x8269D3D8;
	sub_82512118(ctx, base);
	// 8269D3D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269D3DC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D3E0: 48775A51  bl 0x82e12e30
	ctx.lr = 0x8269D3E4;
	sub_82E12E30(ctx, base);
	// 8269D3E4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8269D3E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D3EC: 419A0008  beq cr6, 0x8269d3f4
	if ctx.cr[6].eq {
	pc = 0x8269D3F4; continue 'dispatch;
	}
	// 8269D3F0: 4BC234A1  bl 0x822c0890
	ctx.lr = 0x8269D3F4;
	sub_822C0890(ctx, base);
	// 8269D3F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D3F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D3FC: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 8269D400: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269D404: 48754FE5  bl 0x82df23e8
	ctx.lr = 0x8269D408;
	sub_82DF23E8(ctx, base);
	// 8269D408: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D40C: 41820014  beq 0x8269d420
	if ctx.cr[0].eq {
	pc = 0x8269D420; continue 'dispatch;
	}
	// 8269D410: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8269D414: 48775CDD  bl 0x82e130f0
	ctx.lr = 0x8269D418;
	sub_82E130F0(ctx, base);
	// 8269D418: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D41C: 48000008  b 0x8269d424
	pc = 0x8269D424; continue 'dispatch;
	// 8269D420: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D424: 3BDF0110  addi r30, r31, 0x110
	ctx.r[30].s64 = ctx.r[31].s64 + 272;
	// 8269D428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D42C: 4BC44925  bl 0x822e1d50
	ctx.lr = 0x8269D430;
	sub_822E1D50(ctx, base);
	// 8269D430: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269D434: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8269D438: 83BF0110  lwz r29, 0x110(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 8269D43C: 4BE74CDD  bl 0x82512118
	ctx.lr = 0x8269D440;
	sub_82512118(ctx, base);
	// 8269D440: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269D444: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D448: 487759E9  bl 0x82e12e30
	ctx.lr = 0x8269D44C;
	sub_82E12E30(ctx, base);
	// 8269D44C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8269D450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D454: 419A0008  beq cr6, 0x8269d45c
	if ctx.cr[6].eq {
	pc = 0x8269D45C; continue 'dispatch;
	}
	// 8269D458: 4BC23439  bl 0x822c0890
	ctx.lr = 0x8269D45C;
	sub_822C0890(ctx, base);
	// 8269D45C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8269D460: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D464: 38A00065  li r5, 0x65
	ctx.r[5].s64 = 101;
	// 8269D468: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269D46C: 48754F7D  bl 0x82df23e8
	ctx.lr = 0x8269D470;
	sub_82DF23E8(ctx, base);
	// 8269D470: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269D474: 41820028  beq 0x8269d49c
	if ctx.cr[0].eq {
	pc = 0x8269D49C; continue 'dispatch;
	}
	// 8269D478: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 8269D47C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269D480: C02BDFAC  lfs f1, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269D484: 487DF505  bl 0x82e7c988
	ctx.lr = 0x8269D488;
	sub_82E7C988(ctx, base);
	// 8269D488: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D48C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269D490: 48775C61  bl 0x82e130f0
	ctx.lr = 0x8269D494;
	sub_82E130F0(ctx, base);
	// 8269D494: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D498: 48000008  b 0x8269d4a0
	pc = 0x8269D4A0; continue 'dispatch;
	// 8269D49C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269D4A0: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 8269D4A4: 4BC448AD  bl 0x822e1d50
	ctx.lr = 0x8269D4A8;
	sub_822E1D50(ctx, base);
	// 8269D4A8: 809F0100  lwz r4, 0x100(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 8269D4AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D4B0: 48775981  bl 0x82e12e30
	ctx.lr = 0x8269D4B4;
	sub_82E12E30(ctx, base);
	// 8269D4B4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8269D4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D4BC: 4BFFFBED  bl 0x8269d0a8
	ctx.lr = 0x8269D4C0;
	sub_8269D0A8(ctx, base);
	// 8269D4C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D4C4: 4BE755D5  bl 0x82512a98
	ctx.lr = 0x8269D4C8;
	sub_82512A98(ctx, base);
	// 8269D4C8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8269D4CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D4D0: 4BFFF331  bl 0x8269c800
	ctx.lr = 0x8269D4D4;
	sub_8269C800(ctx, base);
	// 8269D4D4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8269D4D8: 48B0ACD0  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269D4E0 size=204
    let mut pc: u32 = 0x8269D4E0;
    'dispatch: loop {
        match pc {
            0x8269D4E0 => {
    //   block [0x8269D4E0..0x8269D5AC)
	// 8269D4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269D4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269D4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269D4F0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269D5B0 size=128
    let mut pc: u32 = 0x8269D5B0;
    'dispatch: loop {
        match pc {
            0x8269D5B0 => {
    //   block [0x8269D5B0..0x8269D630)
	// 8269D5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269D5B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269D5BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269D5C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D5C4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269D5C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269D5CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269D5D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269D5D4: 388B0060  addi r4, r11, 0x60
	ctx.r[4].s64 = ctx.r[11].s64 + 96;
	// 8269D5D8: 48756431  bl 0x82df3a08
	ctx.lr = 0x8269D5DC;
	sub_82DF3A08(ctx, base);
	// 8269D5DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269D5E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269D5E4: 809E0120  lwz r4, 0x120(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 8269D5E8: 485155E1  bl 0x82bb2bc8
	ctx.lr = 0x8269D5EC;
	sub_82BB2BC8(ctx, base);
	// 8269D5EC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269D5F0: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D5F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269D5F8: 419A000C  beq cr6, 0x8269d604
	if ctx.cr[6].eq {
	pc = 0x8269D604; continue 'dispatch;
	}
	// 8269D5FC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8269D600: 4BC23291  bl 0x822c0890
	ctx.lr = 0x8269D604;
	sub_822C0890(ctx, base);
	// 8269D604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269D608: 48755E21  bl 0x82df3428
	ctx.lr = 0x8269D60C;
	sub_82DF3428(ctx, base);
	// 8269D60C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D610: C03F0018  lfs f1, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269D614: 4851B4FD  bl 0x82bb8b10
	ctx.lr = 0x8269D618;
	sub_82BB8B10(ctx, base);
	// 8269D618: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269D61C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269D620: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269D624: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269D628: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269D62C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269D630 size=196
    let mut pc: u32 = 0x8269D630;
    'dispatch: loop {
        match pc {
            0x8269D630 => {
    //   block [0x8269D630..0x8269D6F4)
	// 8269D630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269D638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269D63C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269D640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D644: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269D648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269D64C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8269D650: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269D654: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269D658: 4BC232E1  bl 0x822c0938
	ctx.lr = 0x8269D65C;
	sub_822C0938(ctx, base);
	// 8269D65C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D660: 41820028  beq 0x8269d688
	if ctx.cr[0].eq {
	pc = 0x8269D688; continue 'dispatch;
	}
	// 8269D664: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269D668: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8269D66C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8269D670: 392B003C  addi r9, r11, 0x3c
	ctx.r[9].s64 = ctx.r[11].s64 + 60;
	// 8269D674: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8269D678: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269D67C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8269D680: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8269D684: 48000008  b 0x8269d68c
	pc = 0x8269D68C; continue 'dispatch;
	// 8269D688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269D68C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269D690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269D694: 409A0044  bne cr6, 0x8269d6d8
	if !ctx.cr[6].eq {
	pc = 0x8269D6D8; continue 'dispatch;
	}
	// 8269D698: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269D69C: 419A001C  beq cr6, 0x8269d6b8
	if ctx.cr[6].eq {
	pc = 0x8269D6B8; continue 'dispatch;
	}
	// 8269D6A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D6A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8269D6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D6AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269D6B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269D6B4: 4E800421  bctrl
	ctx.lr = 0x8269D6B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269D6B8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269D6BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269D6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269D6C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8269D6C8: 816B9598  lwz r11, -0x6a68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27240 as u32) ) } as u64;
	// 8269D6CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269D6D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269D6D4: 4BC2292D  bl 0x822c0000
	ctx.lr = 0x8269D6D8;
	sub_822C0000(ctx, base);
	// 8269D6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269D6E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269D6E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269D6E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269D6EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269D6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269D6F8 size=108
    let mut pc: u32 = 0x8269D6F8;
    'dispatch: loop {
        match pc {
            0x8269D6F8 => {
    //   block [0x8269D6F8..0x8269D764)
	// 8269D6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D6FC: 48B0AA71  bl 0x831a816c
	ctx.lr = 0x8269D700;
	sub_831A8130(ctx, base);
	// 8269D700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D704: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8269D708: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8269D70C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269D710: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269D714: 41820038  beq 0x8269d74c
	if ctx.cr[0].eq {
	pc = 0x8269D74C; continue 'dispatch;
	}
	// 8269D718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D71C: 48B0C26D  bl 0x831a9988
	ctx.lr = 0x8269D720;
	sub_831A9988(ctx, base);
	// 8269D720: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269D724: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269D728: 386B95E8  addi r3, r11, -0x6a18
	ctx.r[3].s64 = ctx.r[11].s64 + -27160;
	// 8269D72C: 48B0A9CD  bl 0x831a80f8
	ctx.lr = 0x8269D730;
	sub_831A80F8(ctx, base);
	// 8269D730: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269D734: 41820018  beq 0x8269d74c
	if ctx.cr[0].eq {
	pc = 0x8269D74C; continue 'dispatch;
	}
	// 8269D738: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269D73C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 8269D740: 4BFFFE71  bl 0x8269d5b0
	ctx.lr = 0x8269D744;
	sub_8269D5B0(ctx, base);
	// 8269D744: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8269D748: 48000014  b 0x8269d75c
	pc = 0x8269D75C; continue 'dispatch;
	// 8269D74C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8269D750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269D754: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269D758: 4BE74EC1  bl 0x82512618
	ctx.lr = 0x8269D75C;
	sub_82512618(ctx, base);
	// 8269D75C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269D760: 48B0AA5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269D768 size=192
    let mut pc: u32 = 0x8269D768;
    'dispatch: loop {
        match pc {
            0x8269D768 => {
    //   block [0x8269D768..0x8269D828)
	// 8269D768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269D770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269D774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269D778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D77C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269D780: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8269D784: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 8269D788: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 8269D78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269D790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269D794: 4BE74ACD  bl 0x82512260
	ctx.lr = 0x8269D798;
	sub_82512260(ctx, base);
	// 8269D798: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269D79C: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269D7A0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 8269D7A4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269D7A8: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269D7AC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8269D7B0: 396900FC  addi r11, r9, 0xfc
	ctx.r[11].s64 = ctx.r[9].s64 + 252;
	// 8269D7B4: 38E000F0  li r7, 0xf0
	ctx.r[7].s64 = 240;
	// 8269D7B8: 394A00BC  addi r10, r10, 0xbc
	ctx.r[10].s64 = ctx.r[10].s64 + 188;
	// 8269D7BC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8269D7C0: 3928006C  addi r9, r8, 0x6c
	ctx.r[9].s64 = ctx.r[8].s64 + 108;
	// 8269D7C4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8269D7C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269D7CC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8269D7D0: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269D828 size=8
    let mut pc: u32 = 0x8269D828;
    'dispatch: loop {
        match pc {
            0x8269D828 => {
    //   block [0x8269D828..0x8269D830)
	// 8269D828: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8269D82C: 480000C4  b 0x8269d8f0
	sub_8269D8F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269D830 size=8
    let mut pc: u32 = 0x8269D830;
    'dispatch: loop {
        match pc {
            0x8269D830 => {
    //   block [0x8269D830..0x8269D838)
	// 8269D830: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8269D834: 480000BC  b 0x8269d8f0
	sub_8269D8F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269D838 size=184
    let mut pc: u32 = 0x8269D838;
    'dispatch: loop {
        match pc {
            0x8269D838 => {
    //   block [0x8269D838..0x8269D8F0)
	// 8269D838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D83C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269D840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269D844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269D848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D84C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269D850: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269D854: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269D858: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269D85C: 396B00BC  addi r11, r11, 0xbc
	ctx.r[11].s64 = ctx.r[11].s64 + 188;
	// 8269D860: 394A00FC  addi r10, r10, 0xfc
	ctx.r[10].s64 = ctx.r[10].s64 + 252;
	// 8269D864: 3929006C  addi r9, r9, 0x6c
	ctx.r[9].s64 = ctx.r[9].s64 + 108;
	// 8269D868: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269D86C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8269D870: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 8269D874: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8269D878: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 8269D87C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D880: 419A0008  beq cr6, 0x8269d888
	if ctx.cr[6].eq {
	pc = 0x8269D888; continue 'dispatch;
	}
	// 8269D884: 4BC2300D  bl 0x822c0890
	ctx.lr = 0x8269D888;
	sub_822C0890(ctx, base);
	// 8269D888: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 8269D88C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D890: 419A0008  beq cr6, 0x8269d898
	if ctx.cr[6].eq {
	pc = 0x8269D898; continue 'dispatch;
	}
	// 8269D894: 4BC22FFD  bl 0x822c0890
	ctx.lr = 0x8269D898;
	sub_822C0890(ctx, base);
	// 8269D898: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269D89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D8A0: 419A0008  beq cr6, 0x8269d8a8
	if ctx.cr[6].eq {
	pc = 0x8269D8A8; continue 'dispatch;
	}
	// 8269D8A4: 4BC22FED  bl 0x822c0890
	ctx.lr = 0x8269D8A8;
	sub_822C0890(ctx, base);
	// 8269D8A8: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 8269D8AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D8B0: 419A0008  beq cr6, 0x8269d8b8
	if ctx.cr[6].eq {
	pc = 0x8269D8B8; continue 'dispatch;
	}
	// 8269D8B4: 4BC22FDD  bl 0x822c0890
	ctx.lr = 0x8269D8B8;
	sub_822C0890(ctx, base);
	// 8269D8B8: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 8269D8BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269D8C0: 419A0008  beq cr6, 0x8269d8c8
	if ctx.cr[6].eq {
	pc = 0x8269D8C8; continue 'dispatch;
	}
	// 8269D8C4: 4BC22FCD  bl 0x822c0890
	ctx.lr = 0x8269D8C8;
	sub_822C0890(ctx, base);
	// 8269D8C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269D8CC: 48109D8D  bl 0x827a7658
	ctx.lr = 0x8269D8D0;
	sub_827A7658(ctx, base);
	// 8269D8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D8D4: 4BCB1A7D  bl 0x8234f350
	ctx.lr = 0x8269D8D8;
	sub_8234F350(ctx, base);
	// 8269D8D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269D8DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269D8E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269D8E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269D8E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269D8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269D8F0 size=76
    let mut pc: u32 = 0x8269D8F0;
    'dispatch: loop {
        match pc {
            0x8269D8F0 => {
    //   block [0x8269D8F0..0x8269D93C)
	// 8269D8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269D8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269D8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269D900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D904: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269D908: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269D90C: 4BFFFF2D  bl 0x8269d838
	ctx.lr = 0x8269D910;
	sub_8269D838(ctx, base);
	// 8269D910: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269D914: 4182000C  beq 0x8269d920
	if ctx.cr[0].eq {
	pc = 0x8269D920; continue 'dispatch;
	}
	// 8269D918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D91C: 48754ABD  bl 0x82df23d8
	ctx.lr = 0x8269D920;
	sub_82DF23D8(ctx, base);
	// 8269D920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269D924: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269D928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269D92C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269D930: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269D934: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269D938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269D940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269D940 size=424
    let mut pc: u32 = 0x8269D940;
    'dispatch: loop {
        match pc {
            0x8269D940 => {
    //   block [0x8269D940..0x8269DAE8)
	// 8269D940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269D944: 48B0A821  bl 0x831a8164
	ctx.lr = 0x8269D948;
	sub_831A8130(ctx, base);
	// 8269D948: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269D94C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269D950: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8269D954: 3BCB0110  addi r30, r11, 0x110
	ctx.r[30].s64 = ctx.r[11].s64 + 272;
	// 8269D958: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8269D95C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D960: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 8269D964: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8269D968: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269D96C: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 8269D970: 48754A79  bl 0x82df23e8
	ctx.lr = 0x8269D974;
	sub_82DF23E8(ctx, base);
	// 8269D974: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269D978: 41820010  beq 0x8269d988
	if ctx.cr[0].eq {
	pc = 0x8269D988; continue 'dispatch;
	}
	// 8269D97C: 4BFFFDED  bl 0x8269d768
	ctx.lr = 0x8269D980;
	sub_8269D768(ctx, base);
	// 8269D980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269D984: 48000008  b 0x8269d98c
	pc = 0x8269D98C; continue 'dispatch;
	// 8269D988: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269D98C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8269D990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269D994: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269D998: 4BFFFC99  bl 0x8269d630
	ctx.lr = 0x8269D99C;
	sub_8269D630(ctx, base);
	// 8269D99C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269D9A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269D9A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269D9A8: 4BC22659  bl 0x822c0000
	ctx.lr = 0x8269D9AC;
	sub_822C0000(ctx, base);
	// 8269D9AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269D9B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269D9B4: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 8269D9B8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8269D9BC: 4BC22A1D  bl 0x822c03d8
	ctx.lr = 0x8269D9C0;
	sub_822C03D8(ctx, base);
	// 8269D9C0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8269D9C4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269D9C8: 418200B4  beq 0x8269da7c
	if ctx.cr[0].eq {
	pc = 0x8269DA7C; continue 'dispatch;
	}
	// 8269D9CC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8269D9D0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8269D9D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8269D9D8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8269D9DC: 409A0008  bne cr6, 0x8269d9e4
	if !ctx.cr[6].eq {
	pc = 0x8269D9E4; continue 'dispatch;
	}
	// 8269D9E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269D9E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8269D9E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269D9EC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8269D9F0: 419A0024  beq cr6, 0x8269da14
	if ctx.cr[6].eq {
	pc = 0x8269DA14; continue 'dispatch;
	}
	// 8269D9F4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269D9F8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8269D9FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DA00: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8269DA04: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8269DA08: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269DA0C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DA10: 4082FFE8  bne 0x8269d9f8
	if !ctx.cr[0].eq {
	pc = 0x8269D9F8; continue 'dispatch;
	}
	// 8269DA14: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8269DA18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269DA1C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8269DA20: 419A0024  beq cr6, 0x8269da44
	if ctx.cr[6].eq {
	pc = 0x8269DA44; continue 'dispatch;
	}
	// 8269DA24: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269DA28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269DA2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DA30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269DA34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269DA38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269DA3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DA40: 4082FFE8  bne 0x8269da28
	if !ctx.cr[0].eq {
	pc = 0x8269DA28; continue 'dispatch;
	}
	// 8269DA44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269DA48: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8269DA4C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8269DA50: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8269DA54: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8269DA58: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269DA5C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269DA60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269DA64: 480FB4CD  bl 0x82798f30
	ctx.lr = 0x8269DA68;
	sub_82798F30(ctx, base);
	// 8269DA68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269DA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269DA70: 480FDBF9  bl 0x8279b668
	ctx.lr = 0x8269DA74;
	sub_8279B668(ctx, base);
	// 8269DA74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269DA78: 48000008  b 0x8269da80
	pc = 0x8269DA80; continue 'dispatch;
	// 8269DA7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269DA80: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8269DA84: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8269DA88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269DA8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269DA90: 4BEFA1C1  bl 0x82597c50
	ctx.lr = 0x8269DA94;
	sub_82597C50(ctx, base);
	// 8269DA94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269DA98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269DA9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269DAA0: 4BC22561  bl 0x822c0000
	ctx.lr = 0x8269DAA4;
	sub_822C0000(ctx, base);
	// 8269DAA4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269DAA8: 41820024  beq 0x8269dacc
	if ctx.cr[0].eq {
	pc = 0x8269DACC; continue 'dispatch;
	}
	// 8269DAAC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8269DAB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269DAB4: 419A0008  beq cr6, 0x8269dabc
	if ctx.cr[6].eq {
	pc = 0x8269DABC; continue 'dispatch;
	}
	// 8269DAB8: 4BC22DD9  bl 0x822c0890
	ctx.lr = 0x8269DABC;
	sub_822C0890(ctx, base);
	// 8269DABC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8269DAC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269DAC4: 419A0008  beq cr6, 0x8269dacc
	if ctx.cr[6].eq {
	pc = 0x8269DACC; continue 'dispatch;
	}
	// 8269DAC8: 4BC22DC9  bl 0x822c0890
	ctx.lr = 0x8269DACC;
	sub_822C0890(ctx, base);
	// 8269DACC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269DAD0: 419A000C  beq cr6, 0x8269dadc
	if ctx.cr[6].eq {
	pc = 0x8269DADC; continue 'dispatch;
	}
	// 8269DAD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269DAD8: 4BC22DB9  bl 0x822c0890
	ctx.lr = 0x8269DADC;
	sub_822C0890(ctx, base);
	// 8269DADC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8269DAE0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8269DAE4: 48B0A6D0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269DAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269DAE8 size=1544
    let mut pc: u32 = 0x8269DAE8;
    'dispatch: loop {
        match pc {
            0x8269DAE8 => {
    //   block [0x8269DAE8..0x8269E0F0)
	// 8269DAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269DAEC: 48B0A665  bl 0x831a8150
	ctx.lr = 0x8269DAF0;
	sub_831A8130(ctx, base);
	// 8269DAF0: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 8269DAF4: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269DAF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269DAFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269DB00: 7FF7FB78  mr r23, r31
	ctx.r[23].u64 = ctx.r[31].u64;
	// 8269DB04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8269DB08: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8269DB0C: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 8269DB10: 4BE73EC9  bl 0x825119d8
	ctx.lr = 0x8269DB14;
	sub_825119D8(ctx, base);
	// 8269DB14: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269DB18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269DB1C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8269DB20: 48755EE9  bl 0x82df3a08
	ctx.lr = 0x8269DB24;
	sub_82DF3A08(ctx, base);
	// 8269DB24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8269DB28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269DB2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269DB30: 4BE6AC51  bl 0x82508780
	ctx.lr = 0x8269DB34;
	sub_82508780(ctx, base);
	// 8269DB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269DB38: 487558F1  bl 0x82df3428
	ctx.lr = 0x8269DB3C;
	sub_82DF3428(ctx, base);
	// 8269DB3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8269DB40: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 8269DB44: 409A0008  bne cr6, 0x8269db4c
	if !ctx.cr[6].eq {
	pc = 0x8269DB4C; continue 'dispatch;
	}
	// 8269DB48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269DB4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269DB50: 4BE6AC51  bl 0x825087a0
	ctx.lr = 0x8269DB54;
	sub_825087A0(ctx, base);
	// 8269DB54: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269DB58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269DB5C: 3B0B0110  addi r24, r11, 0x110
	ctx.r[24].s64 = ctx.r[11].s64 + 272;
	// 8269DB60: 38A0004E  li r5, 0x4e
	ctx.r[5].s64 = 78;
	// 8269DB64: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8269DB68: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269DB6C: 4875487D  bl 0x82df23e8
	ctx.lr = 0x8269DB70;
	sub_82DF23E8(ctx, base);
	// 8269DB70: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269DB74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269DB78: 3BAB6880  addi r29, r11, 0x6880
	ctx.r[29].s64 = ctx.r[11].s64 + 26752;
	// 8269DB7C: 41820014  beq 0x8269db90
	if ctx.cr[0].eq {
	pc = 0x8269DB90; continue 'dispatch;
	}
	// 8269DB80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269DB84: 4877556D  bl 0x82e130f0
	ctx.lr = 0x8269DB88;
	sub_82E130F0(ctx, base);
	// 8269DB88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269DB8C: 48000008  b 0x8269db94
	pc = 0x8269DB94; continue 'dispatch;
	// 8269DB90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269DB94: 3B9E0100  addi r28, r30, 0x100
	ctx.r[28].s64 = ctx.r[30].s64 + 256;
	// 8269DB98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8269DB9C: 4BC441B5  bl 0x822e1d50
	ctx.lr = 0x8269DBA0;
	sub_822E1D50(ctx, base);
	// 8269DBA0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8269DBA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269DBA8: 38A0004F  li r5, 0x4f
	ctx.r[5].s64 = 79;
	// 8269DBAC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269DBB0: 48754839  bl 0x82df23e8
	ctx.lr = 0x8269DBB4;
	sub_82DF23E8(ctx, base);
	// 8269DBB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269DBB8: 41820014  beq 0x8269dbcc
	if ctx.cr[0].eq {
	pc = 0x8269DBCC; continue 'dispatch;
	}
	// 8269DBBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269DBC0: 48775531  bl 0x82e130f0
	ctx.lr = 0x8269DBC4;
	sub_82E130F0(ctx, base);
	// 8269DBC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269DBC8: 48000008  b 0x8269dbd0
	pc = 0x8269DBD0; continue 'dispatch;
	// 8269DBCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269DBD0: 3ADE0108  addi r22, r30, 0x108
	ctx.r[22].s64 = ctx.r[30].s64 + 264;
	// 8269DBD4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8269DBD8: 4BC44179  bl 0x822e1d50
	ctx.lr = 0x8269DBDC;
	sub_822E1D50(ctx, base);
	// 8269DBDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269DBE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8269DBE4: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DBE8: 4BE74531  bl 0x82512118
	ctx.lr = 0x8269DBEC;
	sub_82512118(ctx, base);
	// 8269DBEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269DBF0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DBF4: 4877523D  bl 0x82e12e30
	ctx.lr = 0x8269DBF8;
	sub_82E12E30(ctx, base);
	// 8269DBF8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8269DBFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269DC00: 419A0008  beq cr6, 0x8269dc08
	if ctx.cr[6].eq {
	pc = 0x8269DC08; continue 'dispatch;
	}
	// 8269DC04: 4BC22C8D  bl 0x822c0890
	ctx.lr = 0x8269DC08;
	sub_822C0890(ctx, base);
	// 8269DC08: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8269DC0C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DC10: 4878CED9  bl 0x82e2aae8
	ctx.lr = 0x8269DC14;
	sub_82E2AAE8(ctx, base);
	// 8269DC14: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269DC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269DC1C: 808B9594  lwz r4, -0x6a6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) } as u64;
	// 8269DC20: 48755DE9  bl 0x82df3a08
	ctx.lr = 0x8269DC24;
	sub_82DF3A08(ctx, base);
	// 8269DC24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269DC28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269DC2C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8269DC30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269DC34: 4879123D  bl 0x82e2ee70
	ctx.lr = 0x8269DC38;
	sub_82E2EE70(ctx, base);
	// 8269DC38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269DC3C: 487557ED  bl 0x82df3428
	ctx.lr = 0x8269DC40;
	sub_82DF3428(ctx, base);
	// 8269DC40: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8269DC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269DC48: 419A00B0  beq cr6, 0x8269dcf8
	if ctx.cr[6].eq {
	pc = 0x8269DCF8; continue 'dispatch;
	}
	// 8269DC4C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8269DC50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269DC54: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 8269DC58: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8269DC5C: 4875478D  bl 0x82df23e8
	ctx.lr = 0x8269DC60;
	sub_82DF23E8(ctx, base);
	// 8269DC60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269DC64: 41820014  beq 0x8269dc78
	if ctx.cr[0].eq {
	pc = 0x8269DC78; continue 'dispatch;
	}
	// 8269DC68: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8269DC6C: 48778C25  bl 0x82e16890
	ctx.lr = 0x8269DC70;
	sub_82E16890(ctx, base);
	// 8269DC70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269DC74: 48000008  b 0x8269dc7c
	pc = 0x8269DC7C; continue 'dispatch;
	// 8269DC78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269DC7C: 3BBE0110  addi r29, r30, 0x110
	ctx.r[29].s64 = ctx.r[30].s64 + 272;
	// 8269DC80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269DC84: 4BCBF6ED  bl 0x8235d370
	ctx.lr = 0x8269DC88;
	sub_8235D370(ctx, base);
	// 8269DC88: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269DC8C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269DC94: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8269DC98: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8269DC9C: 419A0024  beq cr6, 0x8269dcc0
	if ctx.cr[6].eq {
	pc = 0x8269DCC0; continue 'dispatch;
	}
	// 8269DCA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269DCA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269DCA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DCAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269DCB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269DCB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269DCB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DCBC: 4082FFE8  bne 0x8269dca4
	if !ctx.cr[0].eq {
	pc = 0x8269DCA4; continue 'dispatch;
	}
	// 8269DCC0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8269DCC4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DCC8: 487773E9  bl 0x82e150b0
	ctx.lr = 0x8269DCCC;
	sub_82E150B0(ctx, base);
	// 8269DCCC: 817E00E4  lwz r11, 0xe4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 8269DCD0: 387E00E4  addi r3, r30, 0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + 228;
	// 8269DCD4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8269DCD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269DCDC: 4E800421  bctrl
	ctx.lr = 0x8269DCE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269DCE0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8269DCE4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269DCE8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8269DCEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269DCF0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8269DCF4: 4BE72E65  bl 0x82510b58
	ctx.lr = 0x8269DCF8;
	sub_82510B58(ctx, base);
	// 8269DCF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269DCFC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DD00: 4878CDE9  bl 0x82e2aae8
	ctx.lr = 0x8269DD04;
	sub_82E2AAE8(ctx, base);
	// 8269DD04: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8269DD08: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8269DD0C: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 8269DD10: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269DD14: 9BE100BC  stb r31, 0xbc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u8 ) };
	// 8269DD18: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269DD1C: 3B2B0060  addi r25, r11, 0x60
	ctx.r[25].s64 = ctx.r[11].s64 + 96;
	// 8269DD20: 3BAA0180  addi r29, r10, 0x180
	ctx.r[29].s64 = ctx.r[10].s64 + 384;
	// 8269DD24: C3E908A4  lfs f31, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269DD28: C0089534  lfs f0, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269DD2C: 932100A0  stw r25, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[25].u32 ) };
	// 8269DD30: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8269DD34: 93A100A4  stw r29, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[29].u32 ) };
	// 8269DD38: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8269DD3C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8269DD40: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8269DD44: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8269DD48: 48760B81  bl 0x82dfe8c8
	ctx.lr = 0x8269DD4C;
	sub_82DFE8C8(ctx, base);
	// 8269DD4C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8269DD50: 48760B79  bl 0x82dfe8c8
	ctx.lr = 0x8269DD54;
	sub_82DFE8C8(ctx, base);
	// 8269DD54: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8269DD58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269DD5C: 38A00068  li r5, 0x68
	ctx.r[5].s64 = 104;
	// 8269DD60: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 8269DD64: 48754685  bl 0x82df23e8
	ctx.lr = 0x8269DD68;
	sub_82DF23E8(ctx, base);
	// 8269DD68: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8269DD6C: 4182003C  beq 0x8269dda8
	if ctx.cr[0].eq {
	pc = 0x8269DDA8; continue 'dispatch;
	}
	// 8269DD70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269DD74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269DD78: 48755C91  bl 0x82df3a08
	ctx.lr = 0x8269DD7C;
	sub_82DF3A08(ctx, base);
	// 8269DD7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269DD80: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8269DD84: 3AE00003  li r23, 3
	ctx.r[23].s64 = 3;
	// 8269DD88: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8269DD8C: 4BE7173D  bl 0x8250f4c8
	ctx.lr = 0x8269DD90;
	sub_8250F4C8(ctx, base);
	// 8269DD90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269DD94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8269DD98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8269DD9C: 48515E65  bl 0x82bb3c00
	ctx.lr = 0x8269DDA0;
	sub_82BB3C00(ctx, base);
	// 8269DDA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269DDA4: 48000008  b 0x8269ddac
	pc = 0x8269DDAC; continue 'dispatch;
	// 8269DDA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269DDAC: 3B5E0120  addi r26, r30, 0x120
	ctx.r[26].s64 = ctx.r[30].s64 + 288;
	// 8269DDB0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8269DDB4: 4BCBF62D  bl 0x8235d3e0
	ctx.lr = 0x8269DDB8;
	sub_8235D3E0(ctx, base);
	// 8269DDB8: 56EB07BD  rlwinm. r11, r23, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269DDBC: 41820010  beq 0x8269ddcc
	if ctx.cr[0].eq {
	pc = 0x8269DDCC; continue 'dispatch;
	}
	// 8269DDC0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8269DDC4: 56F707FA  rlwinm r23, r23, 0, 0x1f, 0x1d
	ctx.r[23].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 8269DDC8: 48753EC9  bl 0x82df1c90
	ctx.lr = 0x8269DDCC;
	sub_82DF1C90(ctx, base);
	// 8269DDCC: 56EB07FF  clrlwi. r11, r23, 0x1f
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269DDD0: 4182000C  beq 0x8269dddc
	if ctx.cr[0].eq {
	pc = 0x8269DDDC; continue 'dispatch;
	}
	// 8269DDD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269DDD8: 48755651  bl 0x82df3428
	ctx.lr = 0x8269DDDC;
	sub_82DF3428(ctx, base);
	// 8269DDDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269DDE0: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DDE4: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269DDE8: 4850FB51  bl 0x82bad938
	ctx.lr = 0x8269DDEC;
	sub_82BAD938(ctx, base);
	// 8269DDEC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8269DDF0: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DDF4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8269DDF8: 48517169  bl 0x82bb4f60
	ctx.lr = 0x8269DDFC;
	sub_82BB4F60(ctx, base);
	// 8269DDFC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269DE00: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DE04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269DE08: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8269DE0C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 8269DE10: 419A0024  beq cr6, 0x8269de34
	if ctx.cr[6].eq {
	pc = 0x8269DE34; continue 'dispatch;
	}
	// 8269DE14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269DE18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269DE1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DE20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269DE24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269DE28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269DE2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269DE30: 4082FFE8  bne 0x8269de18
	if !ctx.cr[0].eq {
	pc = 0x8269DE18; continue 'dispatch;
	}
	// 8269DE34: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8269DE38: 807E0110  lwz r3, 0x110(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 8269DE3C: 48777135  bl 0x82e14f70
	ctx.lr = 0x8269DE40;
	sub_82E14F70(ctx, base);
	// 8269DE40: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8269DE44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269DE48: 419A0008  beq cr6, 0x8269de50
	if ctx.cr[6].eq {
	pc = 0x8269DE50; continue 'dispatch;
	}
	// 8269DE4C: 4BC22A45  bl 0x822c0890
	ctx.lr = 0x8269DE50;
	sub_822C0890(ctx, base);
	// 8269DE50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269DE54: 4878CCAD  bl 0x82e2ab00
	ctx.lr = 0x8269DE58;
	sub_82E2AB00(ctx, base);
	// 8269DE58: 817E0110  lwz r11, 0x110(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 8269DE5C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8269DE60: 48760981  bl 0x82dfe7e0
	ctx.lr = 0x8269DE64;
	sub_82DFE7E0(ctx, base);
	// 8269DE64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269DE68: 41820010  beq 0x8269de78
	if ctx.cr[0].eq {
	pc = 0x8269DE78; continue 'dispatch;
	}
	// 8269DE6C: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DE70: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8269DE74: 4851767D  bl 0x82bb54f0
	ctx.lr = 0x8269DE78;
	sub_82BB54F0(ctx, base);
	// 8269DE78: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8269DE7C: 4882EB6D  bl 0x82ecc9e8
	ctx.lr = 0x8269DE80;
	sub_82ECC9E8(ctx, base);
	// 8269DE80: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 8269DE84: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269DE88: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 8269DE8C: 99610190  stb r11, 0x190(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 8269DE90: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8269DE94: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 8269DE98: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8269DE9C: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8269DEA0: 48802891  bl 0x82ea0730
	ctx.lr = 0x8269DEA4;
	sub_82EA0730(ctx, base);
	// 8269DEA4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269DEA8: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 8269DEAC: 396B0170  addi r11, r11, 0x170
	ctx.r[11].s64 = ctx.r[11].s64 + 368;
	// 8269DEB0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8269DEB4: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 8269DEB8: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 8269DEBC: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 8269DEC0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E0F0 size=12
    let mut pc: u32 = 0x8269E0F0;
    'dispatch: loop {
        match pc {
            0x8269E0F0 => {
    //   block [0x8269E0F0..0x8269E0FC)
	// 8269E0F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8269E0F4: 99630126  stb r11, 0x126(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(294 as u32), ctx.r[11].u8 ) };
	// 8269E0F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E100 size=12
    let mut pc: u32 = 0x8269E100;
    'dispatch: loop {
        match pc {
            0x8269E100 => {
    //   block [0x8269E100..0x8269E10C)
	// 8269E100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E104: 99630126  stb r11, 0x126(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(294 as u32), ctx.r[11].u8 ) };
	// 8269E108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8269E110 size=20
    let mut pc: u32 = 0x8269E110;
    'dispatch: loop {
        match pc {
            0x8269E110 => {
    //   block [0x8269E110..0x8269E124)
	// 8269E110: C0030138  lfs f0, 0x138(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269E114: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8269E118: C003013C  lfs f0, 0x13c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269E11C: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8269E120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E128 size=12
    let mut pc: u32 = 0x8269E128;
    'dispatch: loop {
        match pc {
            0x8269E128 => {
    //   block [0x8269E128..0x8269E134)
	// 8269E128: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8269E12C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8269E130: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E134(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E134 size=12
    let mut pc: u32 = 0x8269E134;
    'dispatch: loop {
        match pc {
            0x8269E134 => {
    //   block [0x8269E134..0x8269E140)
	// 8269E134: 81630128  lwz r11, 0x128(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(296 as u32) ) } as u64;
	// 8269E138: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8269E13C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E140 size=12
    let mut pc: u32 = 0x8269E140;
    'dispatch: loop {
        match pc {
            0x8269E140 => {
    //   block [0x8269E140..0x8269E14C)
	// 8269E140: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8269E144: 91630128  stw r11, 0x128(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 8269E148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E150 size=12
    let mut pc: u32 = 0x8269E150;
    'dispatch: loop {
        match pc {
            0x8269E150 => {
    //   block [0x8269E150..0x8269E15C)
	// 8269E150: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E154: 99630125  stb r11, 0x125(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(293 as u32), ctx.r[11].u8 ) };
	// 8269E158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269E160 size=196
    let mut pc: u32 = 0x8269E160;
    'dispatch: loop {
        match pc {
            0x8269E160 => {
    //   block [0x8269E160..0x8269E224)
	// 8269E160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269E168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269E16C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269E170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269E178: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E17C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8269E180: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269E184: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269E188: 4BC227B1  bl 0x822c0938
	ctx.lr = 0x8269E18C;
	sub_822C0938(ctx, base);
	// 8269E18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269E190: 41820028  beq 0x8269e1b8
	if ctx.cr[0].eq {
	pc = 0x8269E1B8; continue 'dispatch;
	}
	// 8269E194: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E198: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8269E19C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8269E1A0: 392B0544  addi r9, r11, 0x544
	ctx.r[9].s64 = ctx.r[11].s64 + 1348;
	// 8269E1A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8269E1A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269E1AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8269E1B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8269E1B4: 48000008  b 0x8269e1bc
	pc = 0x8269E1BC; continue 'dispatch;
	// 8269E1B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E1BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269E1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269E1C4: 409A0044  bne cr6, 0x8269e208
	if !ctx.cr[6].eq {
	pc = 0x8269E208; continue 'dispatch;
	}
	// 8269E1C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269E1CC: 419A001C  beq cr6, 0x8269e1e8
	if ctx.cr[6].eq {
	pc = 0x8269E1E8; continue 'dispatch;
	}
	// 8269E1D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E1D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8269E1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269E1DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E1E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269E1E4: 4E800421  bctrl
	ctx.lr = 0x8269E1E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269E1E8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269E1EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269E1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E1F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8269E1F8: 816B97CC  lwz r11, -0x6834(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26676 as u32) ) } as u64;
	// 8269E1FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269E200: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269E204: 4BC21DFD  bl 0x822c0000
	ctx.lr = 0x8269E208;
	sub_822C0000(ctx, base);
	// 8269E208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269E20C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269E210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269E214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269E218: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269E21C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269E220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269E228 size=196
    let mut pc: u32 = 0x8269E228;
    'dispatch: loop {
        match pc {
            0x8269E228 => {
    //   block [0x8269E228..0x8269E2EC)
	// 8269E228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E22C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269E230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269E234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269E238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E23C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269E240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E244: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8269E248: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269E24C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269E250: 4BC226E9  bl 0x822c0938
	ctx.lr = 0x8269E254;
	sub_822C0938(ctx, base);
	// 8269E254: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269E258: 41820028  beq 0x8269e280
	if ctx.cr[0].eq {
	pc = 0x8269E280; continue 'dispatch;
	}
	// 8269E25C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E260: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8269E264: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8269E268: 392B0558  addi r9, r11, 0x558
	ctx.r[9].s64 = ctx.r[11].s64 + 1368;
	// 8269E26C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8269E270: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269E274: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8269E278: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8269E27C: 48000008  b 0x8269e284
	pc = 0x8269E284; continue 'dispatch;
	// 8269E280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E284: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269E288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269E28C: 409A0044  bne cr6, 0x8269e2d0
	if !ctx.cr[6].eq {
	pc = 0x8269E2D0; continue 'dispatch;
	}
	// 8269E290: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269E294: 419A001C  beq cr6, 0x8269e2b0
	if ctx.cr[6].eq {
	pc = 0x8269E2B0; continue 'dispatch;
	}
	// 8269E298: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E29C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8269E2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269E2A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E2A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269E2AC: 4E800421  bctrl
	ctx.lr = 0x8269E2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269E2B0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269E2B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269E2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E2BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8269E2C0: 816B97CC  lwz r11, -0x6834(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26676 as u32) ) } as u64;
	// 8269E2C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269E2C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269E2CC: 4BC21D35  bl 0x822c0000
	ctx.lr = 0x8269E2D0;
	sub_822C0000(ctx, base);
	// 8269E2D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269E2D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269E2D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269E2DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269E2E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269E2E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269E2E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269E2F0 size=468
    let mut pc: u32 = 0x8269E2F0;
    'dispatch: loop {
        match pc {
            0x8269E2F0 => {
    //   block [0x8269E2F0..0x8269E4C4)
	// 8269E2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269E2F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269E2FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269E300: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8269E304: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269E30C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269E310: 815F0128  lwz r10, 0x128(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 8269E314: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269E318: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 8269E31C: 409A007C  bne cr6, 0x8269e398
	if !ctx.cr[6].eq {
	pc = 0x8269E398; continue 'dispatch;
	}
	// 8269E320: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269E324: C1BF0134  lfs f13, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269E328: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269E32C: EC01683C  fnmsubs f0, f1, f0, f13
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8269E330: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 8269E334: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8269E338: 409800F0  bge cr6, 0x8269e428
	if !ctx.cr[6].lt {
	pc = 0x8269E428; continue 'dispatch;
	}
	// 8269E33C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E340: D3FF0134  stfs f31, 0x134(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 8269E344: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269E348: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 8269E34C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E350: 388A0060  addi r4, r10, 0x60
	ctx.r[4].s64 = ctx.r[10].s64 + 96;
	// 8269E354: 487556B5  bl 0x82df3a08
	ctx.lr = 0x8269E358;
	sub_82DF3A08(ctx, base);
	// 8269E358: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269E35C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269E360: 809F0114  lwz r4, 0x114(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269E364: 48514865  bl 0x82bb2bc8
	ctx.lr = 0x8269E368;
	sub_82BB2BC8(ctx, base);
	// 8269E368: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269E36C: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269E374: 419A000C  beq cr6, 0x8269e380
	if ctx.cr[6].eq {
	pc = 0x8269E380; continue 'dispatch;
	}
	// 8269E378: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8269E37C: 4BC22515  bl 0x822c0890
	ctx.lr = 0x8269E380;
	sub_822C0890(ctx, base);
	// 8269E380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E384: 487550A5  bl 0x82df3428
	ctx.lr = 0x8269E388;
	sub_82DF3428(ctx, base);
	// 8269E388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269E38C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8269E390: 4851A781  bl 0x82bb8b10
	ctx.lr = 0x8269E394;
	sub_82BB8B10(ctx, base);
	// 8269E394: 48000094  b 0x8269e428
	pc = 0x8269E428; continue 'dispatch;
	// 8269E398: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269E39C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E3A0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8269E3A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269E3A8: 4E800421  bctrl
	ctx.lr = 0x8269E3AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269E3AC: 39630040  addi r11, r3, 0x40
	ctx.r[11].s64 = ctx.r[3].s64 + 64;
	// 8269E3B0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8269E3B4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8269E3B8: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 8269E3BC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8269E3C0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8269E3C4: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269E3C8: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269E3CC: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8269E3D0: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 8269E3D4: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269E3D8: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269E3DC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269E4C8 size=188
    let mut pc: u32 = 0x8269E4C8;
    'dispatch: loop {
        match pc {
            0x8269E4C8 => {
    //   block [0x8269E4C8..0x8269E584)
	// 8269E4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269E4D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269E4D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269E4D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E4DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269E4E0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8269E4E4: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 8269E4E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269E4EC: 394A9728  addi r10, r10, -0x68d8
	ctx.r[10].s64 = ctx.r[10].s64 + -26840;
	// 8269E4F0: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8269E4F4: 9BDF0127  stb r30, 0x127(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(295 as u32), ctx.r[30].u8 ) };
	// 8269E4F8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 8269E4FC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8269E500: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E504: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8269E508: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269E50C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269E510: 4E800421  bctrl
	ctx.lr = 0x8269E514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269E514: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 8269E518: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E51C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E520: 388B0060  addi r4, r11, 0x60
	ctx.r[4].s64 = ctx.r[11].s64 + 96;
	// 8269E524: 487554E5  bl 0x82df3a08
	ctx.lr = 0x8269E528;
	sub_82DF3A08(ctx, base);
	// 8269E528: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269E52C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269E530: 809F0114  lwz r4, 0x114(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269E534: 48514695  bl 0x82bb2bc8
	ctx.lr = 0x8269E538;
	sub_82BB2BC8(ctx, base);
	// 8269E538: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269E53C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E540: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269E544: 4851A52D  bl 0x82bb8a70
	ctx.lr = 0x8269E548;
	sub_82BB8A70(ctx, base);
	// 8269E548: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269E54C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E550: 419A0008  beq cr6, 0x8269e558
	if ctx.cr[6].eq {
	pc = 0x8269E558; continue 'dispatch;
	}
	// 8269E554: 4BC2233D  bl 0x822c0890
	ctx.lr = 0x8269E558;
	sub_822C0890(ctx, base);
	// 8269E558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E55C: 48754ECD  bl 0x82df3428
	ctx.lr = 0x8269E560;
	sub_82DF3428(ctx, base);
	// 8269E560: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8269E564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269E568: 4BE714E9  bl 0x8250fa50
	ctx.lr = 0x8269E56C;
	sub_8250FA50(ctx, base);
	// 8269E56C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269E570: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269E574: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269E578: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269E57C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269E580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269E588 size=272
    let mut pc: u32 = 0x8269E588;
    'dispatch: loop {
        match pc {
            0x8269E588 => {
    //   block [0x8269E588..0x8269E698)
	// 8269E588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269E590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269E594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269E598: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E59C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269E5A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8269E5A4: 817F0128  lwz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 8269E5A8: 9BDF0127  stb r30, 0x127(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(295 as u32), ctx.r[30].u8 ) };
	// 8269E5AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8269E5B0: 409A0048  bne cr6, 0x8269e5f8
	if !ctx.cr[6].eq {
	pc = 0x8269E5F8; continue 'dispatch;
	}
	// 8269E5B4: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8269E5B8: 484A8111  bl 0x82b466c8
	ctx.lr = 0x8269E5BC;
	sub_82B466C8(ctx, base);
	// 8269E5BC: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 8269E5C0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E5C8: 388B0060  addi r4, r11, 0x60
	ctx.r[4].s64 = ctx.r[11].s64 + 96;
	// 8269E5CC: 4875543D  bl 0x82df3a08
	ctx.lr = 0x8269E5D0;
	sub_82DF3A08(ctx, base);
	// 8269E5D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269E5D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269E5D8: 809F0114  lwz r4, 0x114(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269E5DC: 485145ED  bl 0x82bb2bc8
	ctx.lr = 0x8269E5E0;
	sub_82BB2BC8(ctx, base);
	// 8269E5E0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8269E5E4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E5E8: C02B2514  lfs f1, 0x2514(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9492 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269E5EC: 4851A485  bl 0x82bb8a70
	ctx.lr = 0x8269E5F0;
	sub_82BB8A70(ctx, base);
	// 8269E5F0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269E5F4: 48000078  b 0x8269e66c
	pc = 0x8269E66C; continue 'dispatch;
	// 8269E5F8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E5FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E600: 388B0570  addi r4, r11, 0x570
	ctx.r[4].s64 = ctx.r[11].s64 + 1392;
	// 8269E604: 48755405  bl 0x82df3a08
	ctx.lr = 0x8269E608;
	sub_82DF3A08(ctx, base);
	// 8269E608: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269E60C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8269E610: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8269E614: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8269E618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269E61C: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8269E620: C02AD5B8  lfs f1, -0x2a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269E624: 484A85FD  bl 0x82b46c20
	ctx.lr = 0x8269E628;
	sub_82B46C20(ctx, base);
	// 8269E628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E62C: 48754DFD  bl 0x82df3428
	ctx.lr = 0x8269E630;
	sub_82DF3428(ctx, base);
	// 8269E630: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8269E634: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269E638: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 8269E63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E640: 388A0060  addi r4, r10, 0x60
	ctx.r[4].s64 = ctx.r[10].s64 + 96;
	// 8269E644: 487553C5  bl 0x82df3a08
	ctx.lr = 0x8269E648;
	sub_82DF3A08(ctx, base);
	// 8269E648: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269E64C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269E650: 809F0114  lwz r4, 0x114(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269E654: 48514575  bl 0x82bb2bc8
	ctx.lr = 0x8269E658;
	sub_82BB2BC8(ctx, base);
	// 8269E658: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269E65C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E660: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269E664: 4851A40D  bl 0x82bb8a70
	ctx.lr = 0x8269E668;
	sub_82BB8A70(ctx, base);
	// 8269E668: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8269E66C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E670: 419A0008  beq cr6, 0x8269e678
	if ctx.cr[6].eq {
	pc = 0x8269E678; continue 'dispatch;
	}
	// 8269E674: 4BC2221D  bl 0x822c0890
	ctx.lr = 0x8269E678;
	sub_822C0890(ctx, base);
	// 8269E678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E67C: 48754DAD  bl 0x82df3428
	ctx.lr = 0x8269E680;
	sub_82DF3428(ctx, base);
	// 8269E680: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269E684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269E688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269E68C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269E690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269E694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269E698 size=196
    let mut pc: u32 = 0x8269E698;
    'dispatch: loop {
        match pc {
            0x8269E698 => {
    //   block [0x8269E698..0x8269E75C)
	// 8269E698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E69C: 48B09AD1  bl 0x831a816c
	ctx.lr = 0x8269E6A0;
	sub_831A8130(ctx, base);
	// 8269E6A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E6A4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E6A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269E6AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269E6B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E6B4: 388B0060  addi r4, r11, 0x60
	ctx.r[4].s64 = ctx.r[11].s64 + 96;
	// 8269E6B8: 48755351  bl 0x82df3a08
	ctx.lr = 0x8269E6BC;
	sub_82DF3A08(ctx, base);
	// 8269E6BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269E6C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8269E6C4: 809F0114  lwz r4, 0x114(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 8269E6C8: 48514501  bl 0x82bb2bc8
	ctx.lr = 0x8269E6CC;
	sub_82BB2BC8(ctx, base);
	// 8269E6CC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269E6D0: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269E6D8: 419A000C  beq cr6, 0x8269e6e4
	if ctx.cr[6].eq {
	pc = 0x8269E6E4; continue 'dispatch;
	}
	// 8269E6DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8269E6E0: 4BC221B1  bl 0x822c0890
	ctx.lr = 0x8269E6E4;
	sub_822C0890(ctx, base);
	// 8269E6E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269E6E8: 48754D41  bl 0x82df3428
	ctx.lr = 0x8269E6EC;
	sub_82DF3428(ctx, base);
	// 8269E6EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269E6F0: C03E0018  lfs f1, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269E6F4: 4851A41D  bl 0x82bb8b10
	ctx.lr = 0x8269E6F8;
	sub_82BB8B10(ctx, base);
	// 8269E6F8: 817F0128  lwz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 8269E6FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8269E700: 409A0054  bne cr6, 0x8269e754
	if !ctx.cr[6].eq {
	pc = 0x8269E754; continue 'dispatch;
	}
	// 8269E704: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8269E708: C1BE0018  lfs f13, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269E70C: C00B7BC4  lfs f0, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269E710: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8269E714: 41980040  blt cr6, 0x8269e754
	if ctx.cr[6].lt {
	pc = 0x8269E754; continue 'dispatch;
	}
	// 8269E718: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8269E71C: 484A7FAD  bl 0x82b466c8
	ctx.lr = 0x8269E720;
	sub_82B466C8(ctx, base);
	// 8269E720: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8269E724: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269E728: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 8269E72C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269E730: 396B9778  addi r11, r11, -0x6888
	ctx.r[11].s64 = ctx.r[11].s64 + -26760;
	// 8269E734: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8269E738: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E73C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8269E740: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269E744: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8269E748: 4E800421  bctrl
	ctx.lr = 0x8269E74C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8269E74C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8269E750: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 8269E754: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269E758: 48B09A64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269E760 size=232
    let mut pc: u32 = 0x8269E760;
    'dispatch: loop {
        match pc {
            0x8269E760 => {
    //   block [0x8269E760..0x8269E848)
	// 8269E760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E764: 48B09A09  bl 0x831a816c
	ctx.lr = 0x8269E768;
	sub_831A8130(ctx, base);
	// 8269E768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E76C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8269E770: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8269E774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269E778: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8269E77C: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 8269E780: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 8269E784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269E788: 4BE73AD9  bl 0x82512260
	ctx.lr = 0x8269E78C;
	sub_82512260(ctx, base);
	// 8269E78C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269E790: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269E794: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 8269E798: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269E79C: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8269E7A0: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8269E7A4: 394A05E4  addi r10, r10, 0x5e4
	ctx.r[10].s64 = ctx.r[10].s64 + 1508;
	// 8269E7A8: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 8269E7AC: 392905D0  addi r9, r9, 0x5d0
	ctx.r[9].s64 = ctx.r[9].s64 + 1488;
	// 8269E7B0: 39080584  addi r8, r8, 0x584
	ctx.r[8].s64 = ctx.r[8].s64 + 1412;
	// 8269E7B4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8269E7B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269E7BC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 8269E7C0: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 8269E7C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269E7C8: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 8269E7CC: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 8269E7D0: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 8269E7D4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8269E7D8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 8269E7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269E7E0: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 8269E7E4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 8269E7E8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269E7EC: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 8269E7F0: C1A97BC8  lfs f13, 0x7bc8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31688 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269E7F4: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 8269E7F8: C188964C  lfs f12, -0x69b4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8269E7FC: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 8269E800: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 8269E804: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 8269E808: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 8269E80C: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 8269E810: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 8269E814: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 8269E818: 9BBF0124  stb r29, 0x124(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[29].u8 ) };
	// 8269E81C: 9BBF0125  stb r29, 0x125(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(293 as u32), ctx.r[29].u8 ) };
	// 8269E820: 997F0126  stb r11, 0x126(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(294 as u32), ctx.r[11].u8 ) };
	// 8269E824: 997F0127  stb r11, 0x127(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(295 as u32), ctx.r[11].u8 ) };
	// 8269E828: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 8269E82C: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 8269E830: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 8269E834: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 8269E838: D1BF0138  stfs f13, 0x138(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 8269E83C: D19F013C  stfs f12, 0x13c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 8269E840: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269E844: 48B09978  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E848 size=8
    let mut pc: u32 = 0x8269E848;
    'dispatch: loop {
        match pc {
            0x8269E848 => {
    //   block [0x8269E848..0x8269E850)
	// 8269E848: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8269E84C: 48000194  b 0x8269e9e0
	sub_8269E9E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8269E850 size=8
    let mut pc: u32 = 0x8269E850;
    'dispatch: loop {
        match pc {
            0x8269E850 => {
    //   block [0x8269E850..0x8269E858)
	// 8269E850: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8269E854: 4800018C  b 0x8269e9e0
	sub_8269E9E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269E858 size=232
    let mut pc: u32 = 0x8269E858;
    'dispatch: loop {
        match pc {
            0x8269E858 => {
    //   block [0x8269E858..0x8269E940)
	// 8269E858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269E860: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269E864: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269E868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E86C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269E870: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E874: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8269E878: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8269E87C: 396B05E4  addi r11, r11, 0x5e4
	ctx.r[11].s64 = ctx.r[11].s64 + 1508;
	// 8269E880: 394A05D0  addi r10, r10, 0x5d0
	ctx.r[10].s64 = ctx.r[10].s64 + 1488;
	// 8269E884: 39290584  addi r9, r9, 0x584
	ctx.r[9].s64 = ctx.r[9].s64 + 1412;
	// 8269E888: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269E88C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8269E890: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 8269E894: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8269E898: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 8269E89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E8A0: 419A0008  beq cr6, 0x8269e8a8
	if ctx.cr[6].eq {
	pc = 0x8269E8A8; continue 'dispatch;
	}
	// 8269E8A4: 4BC21FED  bl 0x822c0890
	ctx.lr = 0x8269E8A8;
	sub_822C0890(ctx, base);
	// 8269E8A8: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 8269E8AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E8B0: 419A0008  beq cr6, 0x8269e8b8
	if ctx.cr[6].eq {
	pc = 0x8269E8B8; continue 'dispatch;
	}
	// 8269E8B4: 4BC21FDD  bl 0x822c0890
	ctx.lr = 0x8269E8B8;
	sub_822C0890(ctx, base);
	// 8269E8B8: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 8269E8BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E8C0: 419A0008  beq cr6, 0x8269e8c8
	if ctx.cr[6].eq {
	pc = 0x8269E8C8; continue 'dispatch;
	}
	// 8269E8C4: 4BC21FCD  bl 0x822c0890
	ctx.lr = 0x8269E8C8;
	sub_822C0890(ctx, base);
	// 8269E8C8: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 8269E8CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E8D0: 419A0008  beq cr6, 0x8269e8d8
	if ctx.cr[6].eq {
	pc = 0x8269E8D8; continue 'dispatch;
	}
	// 8269E8D4: 4BC21FBD  bl 0x822c0890
	ctx.lr = 0x8269E8D8;
	sub_822C0890(ctx, base);
	// 8269E8D8: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8269E8DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E8E0: 419A0008  beq cr6, 0x8269e8e8
	if ctx.cr[6].eq {
	pc = 0x8269E8E8; continue 'dispatch;
	}
	// 8269E8E4: 4BC21FAD  bl 0x822c0890
	ctx.lr = 0x8269E8E8;
	sub_822C0890(ctx, base);
	// 8269E8E8: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 8269E8EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E8F0: 419A0008  beq cr6, 0x8269e8f8
	if ctx.cr[6].eq {
	pc = 0x8269E8F8; continue 'dispatch;
	}
	// 8269E8F4: 4BC21F9D  bl 0x822c0890
	ctx.lr = 0x8269E8F8;
	sub_822C0890(ctx, base);
	// 8269E8F8: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8269E8FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E900: 419A0008  beq cr6, 0x8269e908
	if ctx.cr[6].eq {
	pc = 0x8269E908; continue 'dispatch;
	}
	// 8269E904: 4BC21F8D  bl 0x822c0890
	ctx.lr = 0x8269E908;
	sub_822C0890(ctx, base);
	// 8269E908: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8269E90C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269E910: 419A0008  beq cr6, 0x8269e918
	if ctx.cr[6].eq {
	pc = 0x8269E918; continue 'dispatch;
	}
	// 8269E914: 4BC21F7D  bl 0x822c0890
	ctx.lr = 0x8269E918;
	sub_822C0890(ctx, base);
	// 8269E918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269E91C: 48108D3D  bl 0x827a7658
	ctx.lr = 0x8269E920;
	sub_827A7658(ctx, base);
	// 8269E920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269E924: 4BCB0A2D  bl 0x8234f350
	ctx.lr = 0x8269E928;
	sub_8234F350(ctx, base);
	// 8269E928: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269E92C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269E930: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269E934: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269E938: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269E93C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269E940 size=160
    let mut pc: u32 = 0x8269E940;
    'dispatch: loop {
        match pc {
            0x8269E940 => {
    //   block [0x8269E940..0x8269E9E0)
	// 8269E940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E944: 48B09825  bl 0x831a8168
	ctx.lr = 0x8269E948;
	sub_831A8130(ctx, base);
	// 8269E948: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E94C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269E950: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8269E954: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269E958: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8269E95C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269E960: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8269E964: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8269E968: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8269E96C: 48753A7D  bl 0x82df23e8
	ctx.lr = 0x8269E970;
	sub_82DF23E8(ctx, base);
	// 8269E970: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269E974: 41820038  beq 0x8269e9ac
	if ctx.cr[0].eq {
	pc = 0x8269E9AC; continue 'dispatch;
	}
	// 8269E978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269E97C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269E980: 487BAD01  bl 0x82e59680
	ctx.lr = 0x8269E984;
	sub_82E59680(ctx, base);
	// 8269E984: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269E988: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8269E98C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 8269E990: 396B056C  addi r11, r11, 0x56c
	ctx.r[11].s64 = ctx.r[11].s64 + 1388;
	// 8269E994: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8269E998: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8269E99C: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8269E9A0: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269E9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269E9E0 size=76
    let mut pc: u32 = 0x8269E9E0;
    'dispatch: loop {
        match pc {
            0x8269E9E0 => {
    //   block [0x8269E9E0..0x8269EA2C)
	// 8269E9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269E9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269E9E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269E9EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269E9F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269E9F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269E9F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269E9FC: 4BFFFE5D  bl 0x8269e858
	ctx.lr = 0x8269EA00;
	sub_8269E858(ctx, base);
	// 8269EA00: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269EA04: 4182000C  beq 0x8269ea10
	if ctx.cr[0].eq {
	pc = 0x8269EA10; continue 'dispatch;
	}
	// 8269EA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269EA0C: 487539CD  bl 0x82df23d8
	ctx.lr = 0x8269EA10;
	sub_82DF23D8(ctx, base);
	// 8269EA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269EA14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269EA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269EA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269EA20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269EA24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269EA28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269EA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269EA30 size=308
    let mut pc: u32 = 0x8269EA30;
    'dispatch: loop {
        match pc {
            0x8269EA30 => {
    //   block [0x8269EA30..0x8269EB64)
	// 8269EA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269EA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269EA38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269EA3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269EA40: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8269EA44: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8269EA48: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269EA4C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269EA50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269EA54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269EA58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269EA5C: 388B0638  addi r4, r11, 0x638
	ctx.r[4].s64 = ctx.r[11].s64 + 1592;
	// 8269EA60: 48754FA9  bl 0x82df3a08
	ctx.lr = 0x8269EA64;
	sub_82DF3A08(ctx, base);
	// 8269EA64: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269EA68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269EA6C: 388B0630  addi r4, r11, 0x630
	ctx.r[4].s64 = ctx.r[11].s64 + 1584;
	// 8269EA70: 48754F99  bl 0x82df3a08
	ctx.lr = 0x8269EA74;
	sub_82DF3A08(ctx, base);
	// 8269EA74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269EA78: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8269EA7C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8269EA80: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 8269EA84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269EA88: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269EA8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269EA90: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8269EA94: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269EA98: C02908A8  lfs f1, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269EA9C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8269EAA0: 4BF0F019  bl 0x825adab8
	ctx.lr = 0x8269EAA4;
	sub_825ADAB8(ctx, base);
	// 8269EAA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269EAA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269EAAC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8269EAB0: 4BF02BA1  bl 0x825a1650
	ctx.lr = 0x8269EAB4;
	sub_825A1650(ctx, base);
	// 8269EAB4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8269EAB8: 48754971  bl 0x82df3428
	ctx.lr = 0x8269EABC;
	sub_82DF3428(ctx, base);
	// 8269EABC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8269EAC0: 4BC2A1F9  bl 0x822c8cb8
	ctx.lr = 0x8269EAC4;
	sub_822C8CB8(ctx, base);
	// 8269EAC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269EAC8: 48754961  bl 0x82df3428
	ctx.lr = 0x8269EACC;
	sub_82DF3428(ctx, base);
	// 8269EACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269EAD0: 48754959  bl 0x82df3428
	ctx.lr = 0x8269EAD4;
	sub_82DF3428(ctx, base);
	// 8269EAD4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269EAD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269EADC: 388B0620  addi r4, r11, 0x620
	ctx.r[4].s64 = ctx.r[11].s64 + 1568;
	// 8269EAE0: 48754F29  bl 0x82df3a08
	ctx.lr = 0x8269EAE4;
	sub_82DF3A08(ctx, base);
	// 8269EAE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269EAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269EAEC: 388BFF68  addi r4, r11, -0x98
	ctx.r[4].s64 = ctx.r[11].s64 + -152;
	// 8269EAF0: 48754F19  bl 0x82df3a08
	ctx.lr = 0x8269EAF4;
	sub_82DF3A08(ctx, base);
	// 8269EAF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269EAF8: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 8269EAFC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8269EB00: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8269EB04: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8269EB08: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8269EB0C: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269EB10: 4BF0EFA9  bl 0x825adab8
	ctx.lr = 0x8269EB14;
	sub_825ADAB8(ctx, base);
	// 8269EB14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8269EB18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269EB1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269EB20: 4BF02B31  bl 0x825a1650
	ctx.lr = 0x8269EB24;
	sub_825A1650(ctx, base);
	// 8269EB24: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8269EB28: 48754901  bl 0x82df3428
	ctx.lr = 0x8269EB2C;
	sub_82DF3428(ctx, base);
	// 8269EB2C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8269EB30: 4BC2A189  bl 0x822c8cb8
	ctx.lr = 0x8269EB34;
	sub_822C8CB8(ctx, base);
	// 8269EB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269EB38: 487548F1  bl 0x82df3428
	ctx.lr = 0x8269EB3C;
	sub_82DF3428(ctx, base);
	// 8269EB3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269EB40: 487548E9  bl 0x82df3428
	ctx.lr = 0x8269EB44;
	sub_82DF3428(ctx, base);
	// 8269EB44: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8269EB48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269EB4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269EB50: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8269EB54: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8269EB58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269EB5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269EB60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269EB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269EB68 size=680
    let mut pc: u32 = 0x8269EB68;
    'dispatch: loop {
        match pc {
            0x8269EB68 => {
    //   block [0x8269EB68..0x8269EE10)
	// 8269EB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269EB6C: 48B095F9  bl 0x831a8164
	ctx.lr = 0x8269EB70;
	sub_831A8130(ctx, base);
	// 8269EB70: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8269EB74: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269EB78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269EB7C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8269EB80: 4BE71B89  bl 0x82510708
	ctx.lr = 0x8269EB84;
	sub_82510708(ctx, base);
	// 8269EB84: 817F0128  lwz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 8269EB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269EB8C: 409A024C  bne cr6, 0x8269edd8
	if !ctx.cr[6].eq {
	pc = 0x8269EDD8; continue 'dispatch;
	}
	// 8269EB90: 897F0127  lbz r11, 0x127(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(295 as u32) ) } as u64;
	// 8269EB94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269EB98: 40820240  bne 0x8269edd8
	if !ctx.cr[0].eq {
	pc = 0x8269EDD8; continue 'dispatch;
	}
	// 8269EB9C: 897F0126  lbz r11, 0x126(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(294 as u32) ) } as u64;
	// 8269EBA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269EBA4: 41820234  beq 0x8269edd8
	if ctx.cr[0].eq {
	pc = 0x8269EDD8; continue 'dispatch;
	}
	// 8269EBA8: 897F0125  lbz r11, 0x125(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(293 as u32) ) } as u64;
	// 8269EBAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269EBB0: 40820228  bne 0x8269edd8
	if !ctx.cr[0].eq {
	pc = 0x8269EDD8; continue 'dispatch;
	}
	// 8269EBB4: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 8269EBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269EBBC: 4BE731DD  bl 0x82511d98
	ctx.lr = 0x8269EBC0;
	sub_82511D98(ctx, base);
	// 8269EBC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269EBC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269EBC8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8269EBCC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 8269EBD0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8269EBD4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269EBD8: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269EBDC: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8269EBE0: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8269EBE4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8269EBE8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8269EBEC: 487DD15D  bl 0x82e7bd48
	ctx.lr = 0x8269EBF0;
	sub_82E7BD48(ctx, base);
	// 8269EBF0: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 8269EBF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269EBF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8269EBFC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8269EC00: 4BC7E5D1  bl 0x8231d1d0
	ctx.lr = 0x8269EC04;
	sub_8231D1D0(ctx, base);
	// 8269EC04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269EC08: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8269EC0C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269EC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269EC14: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8269EC18: 419A0024  beq cr6, 0x8269ec3c
	if ctx.cr[6].eq {
	pc = 0x8269EC3C; continue 'dispatch;
	}
	// 8269EC1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269EC20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269EC24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269EC28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269EC2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269EC30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269EC34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269EC38: 4082FFE8  bne 0x8269ec20
	if !ctx.cr[0].eq {
	pc = 0x8269EC20; continue 'dispatch;
	}
	// 8269EC3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269EC40: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8269EC44: 4BE70885  bl 0x8250f4c8
	ctx.lr = 0x8269EC48;
	sub_8250F4C8(ctx, base);
	// 8269EC48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269EC4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269EC50: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269EC54: 409A0008  bne cr6, 0x8269ec5c
	if !ctx.cr[6].eq {
	pc = 0x8269EC5C; continue 'dispatch;
	}
	// 8269EC58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269EC5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269EC60: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 8269EC64: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 8269EC68: 4BE69DB1  bl 0x82508a18
	ctx.lr = 0x8269EC6C;
	sub_82508A18(ctx, base);
	// 8269EC6C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269EC70: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8269EC74: 3BAB0658  addi r29, r11, 0x658
	ctx.r[29].s64 = ctx.r[11].s64 + 1624;
	// 8269EC78: 38A001FD  li r5, 0x1fd
	ctx.r[5].s64 = 509;
	// 8269EC7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269EC80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269EC84: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8269EC88: 487B8361  bl 0x82e56fe8
	ctx.lr = 0x8269EC8C;
	sub_82E56FE8(ctx, base);
	// 8269EC8C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8269EC90: 48753001  bl 0x82df1c90
	ctx.lr = 0x8269EC94;
	sub_82DF1C90(ctx, base);
	// 8269EC94: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8269EC98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269EC9C: 419A0008  beq cr6, 0x8269eca4
	if ctx.cr[6].eq {
	pc = 0x8269ECA4; continue 'dispatch;
	}
	// 8269ECA0: 4BC21BF1  bl 0x822c0890
	ctx.lr = 0x8269ECA4;
	sub_822C0890(ctx, base);
	// 8269ECA4: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8269ECA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269ECAC: 419A0008  beq cr6, 0x8269ecb4
	if ctx.cr[6].eq {
	pc = 0x8269ECB4; continue 'dispatch;
	}
	// 8269ECB0: 4BC21BE1  bl 0x822c0890
	ctx.lr = 0x8269ECB4;
	sub_822C0890(ctx, base);
	// 8269ECB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269ECB8: 4BE72E31  bl 0x82511ae8
	ctx.lr = 0x8269ECBC;
	sub_82511AE8(ctx, base);
	// 8269ECBC: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 8269ECC0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8269ECC4: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 8269ECC8: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 8269ECCC: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269EE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269EE10 size=440
    let mut pc: u32 = 0x8269EE10;
    'dispatch: loop {
        match pc {
            0x8269EE10 => {
    //   block [0x8269EE10..0x8269EFC8)
	// 8269EE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269EE14: 48B09351  bl 0x831a8164
	ctx.lr = 0x8269EE18;
	sub_831A8130(ctx, base);
	// 8269EE18: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269EE1C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269EE20: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8269EE24: 3BCB0658  addi r30, r11, 0x658
	ctx.r[30].s64 = ctx.r[11].s64 + 1624;
	// 8269EE28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269EE2C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8269EE30: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8269EE34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269EE38: 38A00102  li r5, 0x102
	ctx.r[5].s64 = 258;
	// 8269EE3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8269EE40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269EE44: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 8269EE48: 487535A1  bl 0x82df23e8
	ctx.lr = 0x8269EE4C;
	sub_82DF23E8(ctx, base);
	// 8269EE4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269EE50: 41820018  beq 0x8269ee68
	if ctx.cr[0].eq {
	pc = 0x8269EE68; continue 'dispatch;
	}
	// 8269EE54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8269EE58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269EE5C: 4BFFF905  bl 0x8269e760
	ctx.lr = 0x8269EE60;
	sub_8269E760(ctx, base);
	// 8269EE60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269EE64: 48000008  b 0x8269ee6c
	pc = 0x8269EE6C; continue 'dispatch;
	// 8269EE68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269EE6C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8269EE70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269EE74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269EE78: 4BFFF2E9  bl 0x8269e160
	ctx.lr = 0x8269EE7C;
	sub_8269E160(ctx, base);
	// 8269EE7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269EE80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269EE84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8269EE88: 4BC21179  bl 0x822c0000
	ctx.lr = 0x8269EE8C;
	sub_822C0000(ctx, base);
	// 8269EE8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269EE90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269EE94: 38A00103  li r5, 0x103
	ctx.r[5].s64 = 259;
	// 8269EE98: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8269EE9C: 4BC2153D  bl 0x822c03d8
	ctx.lr = 0x8269EEA0;
	sub_822C03D8(ctx, base);
	// 8269EEA0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8269EEA4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8269EEA8: 418200B4  beq 0x8269ef5c
	if ctx.cr[0].eq {
	pc = 0x8269EF5C; continue 'dispatch;
	}
	// 8269EEAC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8269EEB0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8269EEB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8269EEB8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8269EEBC: 409A0008  bne cr6, 0x8269eec4
	if !ctx.cr[6].eq {
	pc = 0x8269EEC4; continue 'dispatch;
	}
	// 8269EEC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8269EEC4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8269EEC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269EECC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8269EED0: 419A0024  beq cr6, 0x8269eef4
	if ctx.cr[6].eq {
	pc = 0x8269EEF4; continue 'dispatch;
	}
	// 8269EED4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269EED8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8269EEDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269EEE0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8269EEE4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8269EEE8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269EEEC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269EEF0: 4082FFE8  bne 0x8269eed8
	if !ctx.cr[0].eq {
	pc = 0x8269EED8; continue 'dispatch;
	}
	// 8269EEF4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8269EEF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269EEFC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8269EF00: 419A0024  beq cr6, 0x8269ef24
	if ctx.cr[6].eq {
	pc = 0x8269EF24; continue 'dispatch;
	}
	// 8269EF04: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8269EF08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269EF0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269EF10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269EF14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269EF18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269EF1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269EF20: 4082FFE8  bne 0x8269ef08
	if !ctx.cr[0].eq {
	pc = 0x8269EF08; continue 'dispatch;
	}
	// 8269EF24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8269EF28: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8269EF2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8269EF30: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8269EF34: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8269EF38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269EF3C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269EF40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269EF44: 480F9FED  bl 0x82798f30
	ctx.lr = 0x8269EF48;
	sub_82798F30(ctx, base);
	// 8269EF48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269EF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269EF50: 480FC719  bl 0x8279b668
	ctx.lr = 0x8269EF54;
	sub_8279B668(ctx, base);
	// 8269EF54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269EF58: 48000008  b 0x8269ef60
	pc = 0x8269EF60; continue 'dispatch;
	// 8269EF5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8269EF60: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8269EF64: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8269EF68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269EF6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269EF70: 4BEF8CE1  bl 0x82597c50
	ctx.lr = 0x8269EF74;
	sub_82597C50(ctx, base);
	// 8269EF74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269EF78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269EF7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269EF80: 4BC21081  bl 0x822c0000
	ctx.lr = 0x8269EF84;
	sub_822C0000(ctx, base);
	// 8269EF84: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269EF88: 41820024  beq 0x8269efac
	if ctx.cr[0].eq {
	pc = 0x8269EFAC; continue 'dispatch;
	}
	// 8269EF8C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8269EF90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269EF94: 419A0008  beq cr6, 0x8269ef9c
	if ctx.cr[6].eq {
	pc = 0x8269EF9C; continue 'dispatch;
	}
	// 8269EF98: 4BC218F9  bl 0x822c0890
	ctx.lr = 0x8269EF9C;
	sub_822C0890(ctx, base);
	// 8269EF9C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8269EFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269EFA4: 419A0008  beq cr6, 0x8269efac
	if ctx.cr[6].eq {
	pc = 0x8269EFAC; continue 'dispatch;
	}
	// 8269EFA8: 4BC218E9  bl 0x822c0890
	ctx.lr = 0x8269EFAC;
	sub_822C0890(ctx, base);
	// 8269EFAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269EFB0: 419A000C  beq cr6, 0x8269efbc
	if ctx.cr[6].eq {
	pc = 0x8269EFBC; continue 'dispatch;
	}
	// 8269EFB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269EFB8: 4BC218D9  bl 0x822c0890
	ctx.lr = 0x8269EFBC;
	sub_822C0890(ctx, base);
	// 8269EFBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8269EFC0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8269EFC4: 48B091F0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269EFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269EFC8 size=56
    let mut pc: u32 = 0x8269EFC8;
    'dispatch: loop {
        match pc {
            0x8269EFC8 => {
    //   block [0x8269EFC8..0x8269F000)
	// 8269EFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269EFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269EFD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269EFD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269EFD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269EFDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269EFE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269EFE4: 4BFFFE2D  bl 0x8269ee10
	ctx.lr = 0x8269EFE8;
	sub_8269EE10(ctx, base);
	// 8269EFE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269EFEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269EFF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269EFF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269EFF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269EFFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F000 size=56
    let mut pc: u32 = 0x8269F000;
    'dispatch: loop {
        match pc {
            0x8269F000 => {
    //   block [0x8269F000..0x8269F038)
	// 8269F000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F008: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F00C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F010: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F014: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8269F018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F01C: 4BFFFDF5  bl 0x8269ee10
	ctx.lr = 0x8269F020;
	sub_8269EE10(ctx, base);
	// 8269F020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F024: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F02C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F030: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F038 size=56
    let mut pc: u32 = 0x8269F038;
    'dispatch: loop {
        match pc {
            0x8269F038 => {
    //   block [0x8269F038..0x8269F070)
	// 8269F038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F040: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F044: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F048: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F04C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8269F050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F054: 4BFFFDBD  bl 0x8269ee10
	ctx.lr = 0x8269F058;
	sub_8269EE10(ctx, base);
	// 8269F058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F05C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F06C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F070 size=56
    let mut pc: u32 = 0x8269F070;
    'dispatch: loop {
        match pc {
            0x8269F070 => {
    //   block [0x8269F070..0x8269F0A8)
	// 8269F070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F07C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F080: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F084: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8269F088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F08C: 4BFFFD85  bl 0x8269ee10
	ctx.lr = 0x8269F090;
	sub_8269EE10(ctx, base);
	// 8269F090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F094: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F09C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F0A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F0A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F0A8 size=56
    let mut pc: u32 = 0x8269F0A8;
    'dispatch: loop {
        match pc {
            0x8269F0A8 => {
    //   block [0x8269F0A8..0x8269F0E0)
	// 8269F0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F0B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F0B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F0B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F0BC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8269F0C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F0C4: 4BFFFD4D  bl 0x8269ee10
	ctx.lr = 0x8269F0C8;
	sub_8269EE10(ctx, base);
	// 8269F0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F0CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F0D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F0D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F0D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F0DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F0E0 size=56
    let mut pc: u32 = 0x8269F0E0;
    'dispatch: loop {
        match pc {
            0x8269F0E0 => {
    //   block [0x8269F0E0..0x8269F118)
	// 8269F0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F0E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F0E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F0EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F0F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8269F0F4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8269F0F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F0FC: 4BFFFD15  bl 0x8269ee10
	ctx.lr = 0x8269F100;
	sub_8269EE10(ctx, base);
	// 8269F100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F104: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F10C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F110: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F118 size=56
    let mut pc: u32 = 0x8269F118;
    'dispatch: loop {
        match pc {
            0x8269F118 => {
    //   block [0x8269F118..0x8269F150)
	// 8269F118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F128: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8269F12C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 8269F130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F134: 4BFFFCDD  bl 0x8269ee10
	ctx.lr = 0x8269F138;
	sub_8269EE10(ctx, base);
	// 8269F138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F13C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F148: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F14C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F150 size=56
    let mut pc: u32 = 0x8269F150;
    'dispatch: loop {
        match pc {
            0x8269F150 => {
    //   block [0x8269F150..0x8269F188)
	// 8269F150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F15C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F160: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F164: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 8269F168: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F16C: 4BFFFCA5  bl 0x8269ee10
	ctx.lr = 0x8269F170;
	sub_8269EE10(ctx, base);
	// 8269F170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F174: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F178: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F17C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F180: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F188 size=56
    let mut pc: u32 = 0x8269F188;
    'dispatch: loop {
        match pc {
            0x8269F188 => {
    //   block [0x8269F188..0x8269F1C0)
	// 8269F188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F18C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F194: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F198: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F19C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8269F1A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F1A4: 4BFFFC6D  bl 0x8269ee10
	ctx.lr = 0x8269F1A8;
	sub_8269EE10(ctx, base);
	// 8269F1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F1AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F1B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F1B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F1B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F1BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F1C0 size=56
    let mut pc: u32 = 0x8269F1C0;
    'dispatch: loop {
        match pc {
            0x8269F1C0 => {
    //   block [0x8269F1C0..0x8269F1F8)
	// 8269F1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F1C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F1CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F1D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F1D4: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 8269F1D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F1DC: 4BFFFC35  bl 0x8269ee10
	ctx.lr = 0x8269F1E0;
	sub_8269EE10(ctx, base);
	// 8269F1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F1E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F1F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F1F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F1F8 size=56
    let mut pc: u32 = 0x8269F1F8;
    'dispatch: loop {
        match pc {
            0x8269F1F8 => {
    //   block [0x8269F1F8..0x8269F230)
	// 8269F1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F1FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F200: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F204: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F208: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F20C: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 8269F210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F214: 4BFFFBFD  bl 0x8269ee10
	ctx.lr = 0x8269F218;
	sub_8269EE10(ctx, base);
	// 8269F218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F21C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F22C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F230 size=56
    let mut pc: u32 = 0x8269F230;
    'dispatch: loop {
        match pc {
            0x8269F230 => {
    //   block [0x8269F230..0x8269F268)
	// 8269F230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F23C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F240: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F244: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 8269F248: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F24C: 4BFFFBC5  bl 0x8269ee10
	ctx.lr = 0x8269F250;
	sub_8269EE10(ctx, base);
	// 8269F250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F254: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F258: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F25C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F260: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F268 size=56
    let mut pc: u32 = 0x8269F268;
    'dispatch: loop {
        match pc {
            0x8269F268 => {
    //   block [0x8269F268..0x8269F2A0)
	// 8269F268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F274: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F278: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F27C: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 8269F280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F284: 4BFFFB8D  bl 0x8269ee10
	ctx.lr = 0x8269F288;
	sub_8269EE10(ctx, base);
	// 8269F288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F28C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F290: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F294: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F298: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F29C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F2A0 size=56
    let mut pc: u32 = 0x8269F2A0;
    'dispatch: loop {
        match pc {
            0x8269F2A0 => {
    //   block [0x8269F2A0..0x8269F2D8)
	// 8269F2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F2A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F2AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F2B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F2B4: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 8269F2B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F2BC: 4BFFFB55  bl 0x8269ee10
	ctx.lr = 0x8269F2C0;
	sub_8269EE10(ctx, base);
	// 8269F2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F2C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F2C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F2CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F2D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F2D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F2D8 size=56
    let mut pc: u32 = 0x8269F2D8;
    'dispatch: loop {
        match pc {
            0x8269F2D8 => {
    //   block [0x8269F2D8..0x8269F310)
	// 8269F2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F2DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F2E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F2E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F2E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F2EC: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8269F2F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F2F4: 4BFFFB1D  bl 0x8269ee10
	ctx.lr = 0x8269F2F8;
	sub_8269EE10(ctx, base);
	// 8269F2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F2FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F308: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F30C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F310 size=56
    let mut pc: u32 = 0x8269F310;
    'dispatch: loop {
        match pc {
            0x8269F310 => {
    //   block [0x8269F310..0x8269F348)
	// 8269F310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F318: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F31C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F320: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F324: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 8269F328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F32C: 4BFFFAE5  bl 0x8269ee10
	ctx.lr = 0x8269F330;
	sub_8269EE10(ctx, base);
	// 8269F330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F33C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F348 size=56
    let mut pc: u32 = 0x8269F348;
    'dispatch: loop {
        match pc {
            0x8269F348 => {
    //   block [0x8269F348..0x8269F380)
	// 8269F348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F354: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F358: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F35C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8269F360: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F364: 4BFFFAAD  bl 0x8269ee10
	ctx.lr = 0x8269F368;
	sub_8269EE10(ctx, base);
	// 8269F368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F36C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F370: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F374: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F378: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F380 size=56
    let mut pc: u32 = 0x8269F380;
    'dispatch: loop {
        match pc {
            0x8269F380 => {
    //   block [0x8269F380..0x8269F3B8)
	// 8269F380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F38C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F390: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F394: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8269F398: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F39C: 4BFFFA75  bl 0x8269ee10
	ctx.lr = 0x8269F3A0;
	sub_8269EE10(ctx, base);
	// 8269F3A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F3A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F3A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F3AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F3B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F3B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F3B8 size=56
    let mut pc: u32 = 0x8269F3B8;
    'dispatch: loop {
        match pc {
            0x8269F3B8 => {
    //   block [0x8269F3B8..0x8269F3F0)
	// 8269F3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F3C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F3C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F3C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F3CC: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 8269F3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F3D4: 4BFFFA3D  bl 0x8269ee10
	ctx.lr = 0x8269F3D8;
	sub_8269EE10(ctx, base);
	// 8269F3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F3DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F3E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F3E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F3E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F3EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F3F0 size=56
    let mut pc: u32 = 0x8269F3F0;
    'dispatch: loop {
        match pc {
            0x8269F3F0 => {
    //   block [0x8269F3F0..0x8269F428)
	// 8269F3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F3F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F3FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F400: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269F404: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 8269F408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F40C: 4BFFFA05  bl 0x8269ee10
	ctx.lr = 0x8269F410;
	sub_8269EE10(ctx, base);
	// 8269F410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F414: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269F418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F41C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269F428 size=96
    let mut pc: u32 = 0x8269F428;
    'dispatch: loop {
        match pc {
            0x8269F428 => {
    //   block [0x8269F428..0x8269F488)
	// 8269F428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269F430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8269F434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269F438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F43C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8269F440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F444: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8269F448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F44C: 388B4920  addi r4, r11, 0x4920
	ctx.r[4].s64 = ctx.r[11].s64 + 18720;
	// 8269F450: 487545B9  bl 0x82df3a08
	ctx.lr = 0x8269F454;
	sub_82DF3A08(ctx, base);
	// 8269F454: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269F458: 38BF0125  addi r5, r31, 0x125
	ctx.r[5].s64 = ctx.r[31].s64 + 293;
	// 8269F45C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F460: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269F464: 4BF58C25  bl 0x825f8088
	ctx.lr = 0x8269F468;
	sub_825F8088(ctx, base);
	// 8269F468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F46C: 48753FBD  bl 0x82df3428
	ctx.lr = 0x8269F470;
	sub_82DF3428(ctx, base);
	// 8269F470: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8269F474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269F478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269F47C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269F480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269F484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269F488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269F488 size=2128
    let mut pc: u32 = 0x8269F488;
    'dispatch: loop {
        match pc {
            0x8269F488 => {
    //   block [0x8269F488..0x8269FCD8)
	// 8269F488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269F48C: 48B08CC5  bl 0x831a8150
	ctx.lr = 0x8269F490;
	sub_831A8130(ctx, base);
	// 8269F490: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 8269F494: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269F498: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8269F49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269F4A0: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 8269F4A4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 8269F4A8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 8269F4AC: 4BE7252D  bl 0x825119d8
	ctx.lr = 0x8269F4B0;
	sub_825119D8(ctx, base);
	// 8269F4B0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269F4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F4B8: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8269F4BC: 4875454D  bl 0x82df3a08
	ctx.lr = 0x8269F4C0;
	sub_82DF3A08(ctx, base);
	// 8269F4C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8269F4C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269F4C8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8269F4CC: 4BE692B5  bl 0x82508780
	ctx.lr = 0x8269F4D0;
	sub_82508780(ctx, base);
	// 8269F4D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F4D4: 48753F55  bl 0x82df3428
	ctx.lr = 0x8269F4D8;
	sub_82DF3428(ctx, base);
	// 8269F4D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8269F4DC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8269F4E0: 409A0008  bne cr6, 0x8269f4e8
	if !ctx.cr[6].eq {
	pc = 0x8269F4E8; continue 'dispatch;
	}
	// 8269F4E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269F4E8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8269F4EC: 4BE692B5  bl 0x825087a0
	ctx.lr = 0x8269F4F0;
	sub_825087A0(ctx, base);
	// 8269F4F0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269F4F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269F4F8: 3AEB0658  addi r23, r11, 0x658
	ctx.r[23].s64 = ctx.r[11].s64 + 1624;
	// 8269F4FC: 38A0018B  li r5, 0x18b
	ctx.r[5].s64 = 395;
	// 8269F500: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8269F504: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269F508: 48752EE1  bl 0x82df23e8
	ctx.lr = 0x8269F50C;
	sub_82DF23E8(ctx, base);
	// 8269F50C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8269F510: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269F514: 3BCB6880  addi r30, r11, 0x6880
	ctx.r[30].s64 = ctx.r[11].s64 + 26752;
	// 8269F518: 41820014  beq 0x8269f52c
	if ctx.cr[0].eq {
	pc = 0x8269F52C; continue 'dispatch;
	}
	// 8269F51C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269F520: 48773BD1  bl 0x82e130f0
	ctx.lr = 0x8269F524;
	sub_82E130F0(ctx, base);
	// 8269F524: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269F528: 48000008  b 0x8269f530
	pc = 0x8269F530; continue 'dispatch;
	// 8269F52C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269F530: 3B9F00FC  addi r28, r31, 0xfc
	ctx.r[28].s64 = ctx.r[31].s64 + 252;
	// 8269F534: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8269F538: 4BC42819  bl 0x822e1d50
	ctx.lr = 0x8269F53C;
	sub_822E1D50(ctx, base);
	// 8269F53C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269F540: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8269F544: 83BF00FC  lwz r29, 0xfc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 8269F548: 4BE72BD1  bl 0x82512118
	ctx.lr = 0x8269F54C;
	sub_82512118(ctx, base);
	// 8269F54C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269F550: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F554: 487738DD  bl 0x82e12e30
	ctx.lr = 0x8269F558;
	sub_82E12E30(ctx, base);
	// 8269F558: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 8269F55C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269F560: 419A0008  beq cr6, 0x8269f568
	if ctx.cr[6].eq {
	pc = 0x8269F568; continue 'dispatch;
	}
	// 8269F564: 4BC2132D  bl 0x822c0890
	ctx.lr = 0x8269F568;
	sub_822C0890(ctx, base);
	// 8269F568: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8269F56C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269F570: 38A0018D  li r5, 0x18d
	ctx.r[5].s64 = 397;
	// 8269F574: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269F578: 48752E71  bl 0x82df23e8
	ctx.lr = 0x8269F57C;
	sub_82DF23E8(ctx, base);
	// 8269F57C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269F580: 41820014  beq 0x8269f594
	if ctx.cr[0].eq {
	pc = 0x8269F594; continue 'dispatch;
	}
	// 8269F584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269F588: 48773B69  bl 0x82e130f0
	ctx.lr = 0x8269F58C;
	sub_82E130F0(ctx, base);
	// 8269F58C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269F590: 48000008  b 0x8269f598
	pc = 0x8269F598; continue 'dispatch;
	// 8269F594: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269F598: 3B1F0104  addi r24, r31, 0x104
	ctx.r[24].s64 = ctx.r[31].s64 + 260;
	// 8269F59C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8269F5A0: 4BC427B1  bl 0x822e1d50
	ctx.lr = 0x8269F5A4;
	sub_822E1D50(ctx, base);
	// 8269F5A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269F5A8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8269F5AC: 83DF0104  lwz r30, 0x104(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 8269F5B0: 4BE72B69  bl 0x82512118
	ctx.lr = 0x8269F5B4;
	sub_82512118(ctx, base);
	// 8269F5B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269F5B8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F5BC: 48773875  bl 0x82e12e30
	ctx.lr = 0x8269F5C0;
	sub_82E12E30(ctx, base);
	// 8269F5C0: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 8269F5C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269F5C8: 419A0008  beq cr6, 0x8269f5d0
	if ctx.cr[6].eq {
	pc = 0x8269F5D0; continue 'dispatch;
	}
	// 8269F5CC: 4BC212C5  bl 0x822c0890
	ctx.lr = 0x8269F5D0;
	sub_822C0890(ctx, base);
	// 8269F5D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8269F5D4: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F5D8: 4878B511  bl 0x82e2aae8
	ctx.lr = 0x8269F5DC;
	sub_82E2AAE8(ctx, base);
	// 8269F5DC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269F5E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F5E4: 3B6B9638  addi r27, r11, -0x69c8
	ctx.r[27].s64 = ctx.r[11].s64 + -27080;
	// 8269F5E8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 8269F5EC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8269F5F0: 7C8BD82E  lwzx r4, r11, r27
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8269F5F4: 48754415  bl 0x82df3a08
	ctx.lr = 0x8269F5F8;
	sub_82DF3A08(ctx, base);
	// 8269F5F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269F5FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269F600: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8269F604: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8269F608: 4878F869  bl 0x82e2ee70
	ctx.lr = 0x8269F60C;
	sub_82E2EE70(ctx, base);
	// 8269F60C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F610: 48753E19  bl 0x82df3428
	ctx.lr = 0x8269F614;
	sub_82DF3428(ctx, base);
	// 8269F614: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8269F618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269F61C: 419A013C  beq cr6, 0x8269f758
	if ctx.cr[6].eq {
	pc = 0x8269F758; continue 'dispatch;
	}
	// 8269F620: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8269F624: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269F628: 38A00194  li r5, 0x194
	ctx.r[5].s64 = 404;
	// 8269F62C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8269F630: 48752DB9  bl 0x82df23e8
	ctx.lr = 0x8269F634;
	sub_82DF23E8(ctx, base);
	// 8269F634: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8269F638: 41820014  beq 0x8269f64c
	if ctx.cr[0].eq {
	pc = 0x8269F64C; continue 'dispatch;
	}
	// 8269F63C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8269F640: 48777251  bl 0x82e16890
	ctx.lr = 0x8269F644;
	sub_82E16890(ctx, base);
	// 8269F644: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269F648: 48000008  b 0x8269f650
	pc = 0x8269F650; continue 'dispatch;
	// 8269F64C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269F650: 3BBF00EC  addi r29, r31, 0xec
	ctx.r[29].s64 = ctx.r[31].s64 + 236;
	// 8269F654: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8269F658: 4BCBDD19  bl 0x8235d370
	ctx.lr = 0x8269F65C;
	sub_8235D370(ctx, base);
	// 8269F65C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 8269F660: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 8269F664: 409A0098  bne cr6, 0x8269f6fc
	if !ctx.cr[6].eq {
	pc = 0x8269F6FC; continue 'dispatch;
	}
	// 8269F668: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8269F66C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269F670: 38A0019A  li r5, 0x19a
	ctx.r[5].s64 = 410;
	// 8269F674: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8269F678: 48752D71  bl 0x82df23e8
	ctx.lr = 0x8269F67C;
	sub_82DF23E8(ctx, base);
	// 8269F67C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8269F680: 41820028  beq 0x8269f6a8
	if ctx.cr[0].eq {
	pc = 0x8269F6A8; continue 'dispatch;
	}
	// 8269F684: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8269F688: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8269F68C: C02B7590  lfs f1, 0x7590(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269F690: 487DD359  bl 0x82e7c9e8
	ctx.lr = 0x8269F694;
	sub_82E7C9E8(ctx, base);
	// 8269F694: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269F698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269F69C: 48773A55  bl 0x82e130f0
	ctx.lr = 0x8269F6A0;
	sub_82E130F0(ctx, base);
	// 8269F6A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269F6A4: 48000008  b 0x8269f6ac
	pc = 0x8269F6AC; continue 'dispatch;
	// 8269F6A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269F6AC: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 8269F6B0: 4BC426A1  bl 0x822e1d50
	ctx.lr = 0x8269F6B4;
	sub_822E1D50(ctx, base);
	// 8269F6B4: 809F010C  lwz r4, 0x10c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 8269F6B8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F6BC: 48773775  bl 0x82e12e30
	ctx.lr = 0x8269F6C0;
	sub_82E12E30(ctx, base);
	// 8269F6C0: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 8269F6C4: 815F010C  lwz r10, 0x10c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 8269F6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269F6CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269F6D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269F6D4: 419A0060  beq cr6, 0x8269f734
	if ctx.cr[6].eq {
	pc = 0x8269F734; continue 'dispatch;
	}
	// 8269F6D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269F6DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269F6E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269F6E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269F6E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269F6EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269F6F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269F6F4: 4082FFE8  bne 0x8269f6dc
	if !ctx.cr[0].eq {
	pc = 0x8269F6DC; continue 'dispatch;
	}
	// 8269F6F8: 4800003C  b 0x8269f734
	pc = 0x8269F734; continue 'dispatch;
	// 8269F6FC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269F700: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269F708: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269F70C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269F710: 419A0024  beq cr6, 0x8269f734
	if ctx.cr[6].eq {
	pc = 0x8269F734; continue 'dispatch;
	}
	// 8269F714: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269F718: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269F71C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269F720: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269F724: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269F728: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269F72C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269F730: 4082FFE8  bne 0x8269f718
	if !ctx.cr[0].eq {
	pc = 0x8269F718; continue 'dispatch;
	}
	// 8269F734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269F738: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F73C: 48775975  bl 0x82e150b0
	ctx.lr = 0x8269F740;
	sub_82E150B0(ctx, base);
	// 8269F740: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8269F744: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8269F748: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8269F74C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269F750: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8269F754: 4BE71405  bl 0x82510b58
	ctx.lr = 0x8269F758;
	sub_82510B58(ctx, base);
	// 8269F758: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269F75C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F760: 4878B389  bl 0x82e2aae8
	ctx.lr = 0x8269F764;
	sub_82E2AAE8(ctx, base);
	// 8269F764: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269F768: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269F76C: 3BAB0060  addi r29, r11, 0x60
	ctx.r[29].s64 = ctx.r[11].s64 + 96;
	// 8269F770: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269F774: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8269F778: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 8269F77C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8269F780: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269F784: 912100EC  stw r9, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[9].u32 ) };
	// 8269F788: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8269F78C: 990100FC  stb r8, 0xfc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[8].u8 ) };
	// 8269F790: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269F794: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8269F798: D3E100F0  stfs f31, 0xf0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8269F79C: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 8269F7A0: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 8269F7A4: 817B0190  lwz r11, 0x190(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(400 as u32) ) } as u64;
	// 8269F7A8: 916100E4  stw r11, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8269F7AC: 4875F11D  bl 0x82dfe8c8
	ctx.lr = 0x8269F7B0;
	sub_82DFE8C8(ctx, base);
	// 8269F7B0: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 8269F7B4: 4875F115  bl 0x82dfe8c8
	ctx.lr = 0x8269F7B8;
	sub_82DFE8C8(ctx, base);
	// 8269F7B8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8269F7BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269F7C0: 38A001AD  li r5, 0x1ad
	ctx.r[5].s64 = 429;
	// 8269F7C4: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 8269F7C8: 48752C21  bl 0x82df23e8
	ctx.lr = 0x8269F7CC;
	sub_82DF23E8(ctx, base);
	// 8269F7CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8269F7D0: 4182003C  beq 0x8269f80c
	if ctx.cr[0].eq {
	pc = 0x8269F80C; continue 'dispatch;
	}
	// 8269F7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F7D8: 809B0190  lwz r4, 0x190(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(400 as u32) ) } as u64;
	// 8269F7DC: 4875422D  bl 0x82df3a08
	ctx.lr = 0x8269F7E0;
	sub_82DF3A08(ctx, base);
	// 8269F7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269F7E4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8269F7E8: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	// 8269F7EC: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 8269F7F0: 4BE6FCD9  bl 0x8250f4c8
	ctx.lr = 0x8269F7F4;
	sub_8250F4C8(ctx, base);
	// 8269F7F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269F7F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269F7FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8269F800: 48514401  bl 0x82bb3c00
	ctx.lr = 0x8269F804;
	sub_82BB3C00(ctx, base);
	// 8269F804: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269F808: 48000008  b 0x8269f810
	pc = 0x8269F810; continue 'dispatch;
	// 8269F80C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8269F810: 3B5F0114  addi r26, r31, 0x114
	ctx.r[26].s64 = ctx.r[31].s64 + 276;
	// 8269F814: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8269F818: 4BCBDBC9  bl 0x8235d3e0
	ctx.lr = 0x8269F81C;
	sub_8235D3E0(ctx, base);
	// 8269F81C: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269F820: 41820010  beq 0x8269f830
	if ctx.cr[0].eq {
	pc = 0x8269F830; continue 'dispatch;
	}
	// 8269F824: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8269F828: 573907FA  rlwinm r25, r25, 0, 0x1f, 0x1d
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 8269F82C: 48752465  bl 0x82df1c90
	ctx.lr = 0x8269F830;
	sub_82DF1C90(ctx, base);
	// 8269F830: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269F834: 4182000C  beq 0x8269f840
	if ctx.cr[0].eq {
	pc = 0x8269F840; continue 'dispatch;
	}
	// 8269F838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F83C: 48753BED  bl 0x82df3428
	ctx.lr = 0x8269F840;
	sub_82DF3428(ctx, base);
	// 8269F840: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8269F844: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F848: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 8269F84C: 48515715  bl 0x82bb4f60
	ctx.lr = 0x8269F850;
	sub_82BB4F60(ctx, base);
	// 8269F850: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269F854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F858: 487541B1  bl 0x82df3a08
	ctx.lr = 0x8269F85C;
	sub_82DF3A08(ctx, base);
	// 8269F85C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8269F860: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269F864: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F868: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8269F86C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8269F870: 485133B1  bl 0x82bb2c20
	ctx.lr = 0x8269F874;
	sub_82BB2C20(ctx, base);
	// 8269F874: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8269F878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269F87C: 419A0008  beq cr6, 0x8269f884
	if ctx.cr[6].eq {
	pc = 0x8269F884; continue 'dispatch;
	}
	// 8269F880: 4BC21011  bl 0x822c0890
	ctx.lr = 0x8269F884;
	sub_822C0890(ctx, base);
	// 8269F884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F888: 48753BA1  bl 0x82df3428
	ctx.lr = 0x8269F88C;
	sub_82DF3428(ctx, base);
	// 8269F88C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8269F890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F894: 48754175  bl 0x82df3a08
	ctx.lr = 0x8269F898;
	sub_82DF3A08(ctx, base);
	// 8269F898: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269F89C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8269F8A0: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F8A4: 48513325  bl 0x82bb2bc8
	ctx.lr = 0x8269F8A8;
	sub_82BB2BC8(ctx, base);
	// 8269F8A8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F8AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8269F8B0: 485191C1  bl 0x82bb8a70
	ctx.lr = 0x8269F8B4;
	sub_82BB8A70(ctx, base);
	// 8269F8B4: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8269F8B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269F8BC: 419A0008  beq cr6, 0x8269f8c4
	if ctx.cr[6].eq {
	pc = 0x8269F8C4; continue 'dispatch;
	}
	// 8269F8C0: 4BC20FD1  bl 0x822c0890
	ctx.lr = 0x8269F8C4;
	sub_822C0890(ctx, base);
	// 8269F8C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F8C8: 48753B61  bl 0x82df3428
	ctx.lr = 0x8269F8CC;
	sub_82DF3428(ctx, base);
	// 8269F8CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269F8D0: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F8D4: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8269F8D8: 4850E061  bl 0x82bad938
	ctx.lr = 0x8269F8DC;
	sub_82BAD938(ctx, base);
	// 8269F8DC: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F8E0: 48514E89  bl 0x82bb4768
	ctx.lr = 0x8269F8E4;
	sub_82BB4768(ctx, base);
	// 8269F8E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269F8E8: 4878B219  bl 0x82e2ab00
	ctx.lr = 0x8269F8EC;
	sub_82E2AB00(ctx, base);
	// 8269F8EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269F8F0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8269F8F4: 4BE6FBD5  bl 0x8250f4c8
	ctx.lr = 0x8269F8F8;
	sub_8250F4C8(ctx, base);
	// 8269F8F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269F900: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8269F904: 409A0008  bne cr6, 0x8269f90c
	if !ctx.cr[6].eq {
	pc = 0x8269F90C; continue 'dispatch;
	}
	// 8269F908: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8269F90C: 4BE68C1D  bl 0x82508528
	ctx.lr = 0x8269F910;
	sub_82508528(ctx, base);
	// 8269F910: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269F914: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8269F918: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F91C: 4BC478ED  bl 0x822e7208
	ctx.lr = 0x8269F920;
	sub_822E7208(ctx, base);
	// 8269F920: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8269F924: 4875236D  bl 0x82df1c90
	ctx.lr = 0x8269F928;
	sub_82DF1C90(ctx, base);
	// 8269F928: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 8269F92C: 397B0050  addi r11, r27, 0x50
	ctx.r[11].s64 = ctx.r[27].s64 + 80;
	// 8269F930: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8269F934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F938: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8269F93C: 487540CD  bl 0x82df3a08
	ctx.lr = 0x8269F940;
	sub_82DF3A08(ctx, base);
	// 8269F940: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269F944: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269F948: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8269F94C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8269F950: 4BC47A41  bl 0x822e7390
	ctx.lr = 0x8269F954;
	sub_822E7390(ctx, base);
	// 8269F954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F958: 48753AD1  bl 0x82df3428
	ctx.lr = 0x8269F95C;
	sub_82DF3428(ctx, base);
	// 8269F95C: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 8269F960: 397B00A0  addi r11, r27, 0xa0
	ctx.r[11].s64 = ctx.r[27].s64 + 160;
	// 8269F964: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8269F968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F96C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 8269F970: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8269F974: 48754095  bl 0x82df3a08
	ctx.lr = 0x8269F978;
	sub_82DF3A08(ctx, base);
	// 8269F978: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8269F97C: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8269F980: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8269F984: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8269F988: 4BC4ED51  bl 0x822ee6d8
	ctx.lr = 0x8269F98C;
	sub_822EE6D8(ctx, base);
	// 8269F98C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8269F990: 3BDF00F4  addi r30, r31, 0xf4
	ctx.r[30].s64 = ctx.r[31].s64 + 244;
	// 8269F994: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8269F998: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8269F99C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F9A0: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 8269F9A4: 4BC24ABD  bl 0x822c4460
	ctx.lr = 0x8269F9A8;
	sub_822C4460(ctx, base);
	// 8269F9A8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8269F9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8269F9B0: 419A0008  beq cr6, 0x8269f9b8
	if ctx.cr[6].eq {
	pc = 0x8269F9B8; continue 'dispatch;
	}
	// 8269F9B4: 4BC20EDD  bl 0x822c0890
	ctx.lr = 0x8269F9B8;
	sub_822C0890(ctx, base);
	// 8269F9B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269F9BC: 48753A6D  bl 0x82df3428
	ctx.lr = 0x8269F9C0;
	sub_82DF3428(ctx, base);
	// 8269F9C0: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 8269F9C4: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269F9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8269F9CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8269F9D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8269F9D4: 419A0024  beq cr6, 0x8269f9f8
	if ctx.cr[6].eq {
	pc = 0x8269F9F8; continue 'dispatch;
	}
	// 8269F9D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8269F9DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8269F9E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269F9E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8269F9E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8269F9EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8269F9F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8269F9F4: 4082FFE8  bne 0x8269f9dc
	if !ctx.cr[0].eq {
	pc = 0x8269F9DC; continue 'dispatch;
	}
	// 8269F9F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269F9FC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269FA00: 4BC4E561  bl 0x822edf60
	ctx.lr = 0x8269FA04;
	sub_822EDF60(ctx, base);
	// 8269FA04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8269FA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FA0C: 4BE71335  bl 0x82510d40
	ctx.lr = 0x8269FA10;
	sub_82510D40(ctx, base);
	// 8269FA10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8269FA14: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269FA18: 4BC454A9  bl 0x822e4ec0
	ctx.lr = 0x8269FA1C;
	sub_822E4EC0(ctx, base);
	// 8269FA1C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8269FA20: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8269FA24: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 8269FA28: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8269FA2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8269FA30: 80CB6754  lwz r6, 0x6754(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26452 as u32) ) } as u64;
	// 8269FA34: 80AA6758  lwz r5, 0x6758(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26456 as u32) ) } as u64;
	// 8269FA38: 80896750  lwz r4, 0x6750(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26448 as u32) ) } as u64;
	// 8269FA3C: 4BC57DDD  bl 0x822f7818
	ctx.lr = 0x8269FA40;
	sub_822F7818(ctx, base);
	// 8269FA40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8269FA44: E89C0000  ld r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 8269FA48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8269FA4C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8269FA50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8269FA54: 4BDEC835  bl 0x8248c288
	ctx.lr = 0x8269FA58;
	sub_8248C288(ctx, base);
	// 8269FA58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FA5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269FA60: 4BDEF941  bl 0x8248f3a0
	ctx.lr = 0x8269FA64;
	sub_8248F3A0(ctx, base);
	// 8269FA64: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8269FA68: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8269FA6C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8269FA70: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 8269FA74: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8269FA78: 48800CB9  bl 0x82ea0730
	ctx.lr = 0x8269FA7C;
	sub_82EA0730(ctx, base);
	// 8269FA7C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8269FA80: 39410120  addi r10, r1, 0x120
	ctx.r[10].s64 = ctx.r[1].s64 + 288;
	// 8269FA84: 396B06C0  addi r11, r11, 0x6c0
	ctx.r[11].s64 = ctx.r[11].s64 + 1728;
	// 8269FA88: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8269FA8C: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 8269FA90: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 8269FA94: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 8269FA98: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269FCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269FCD8 size=48
    let mut pc: u32 = 0x8269FCD8;
    'dispatch: loop {
        match pc {
            0x8269FCD8 => {
    //   block [0x8269FCD8..0x8269FD08)
	// 8269FCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269FCDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269FCE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269FCE4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8269FCE8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8269FCEC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8269FCF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269FCF4: 4BE154E5  bl 0x824b51d8
	ctx.lr = 0x8269FCF8;
	sub_824B51D8(ctx, base);
	// 8269FCF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269FCFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269FD00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269FD04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269FD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269FD08 size=48
    let mut pc: u32 = 0x8269FD08;
    'dispatch: loop {
        match pc {
            0x8269FD08 => {
    //   block [0x8269FD08..0x8269FD38)
	// 8269FD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269FD0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269FD10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269FD14: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8269FD18: 80640018  lwz r3, 0x18(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8269FD1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269FD20: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8269FD24: 4BE154B5  bl 0x824b51d8
	ctx.lr = 0x8269FD28;
	sub_824B51D8(ctx, base);
	// 8269FD28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8269FD2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269FD30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269FD34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269FD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8269FD38 size=556
    let mut pc: u32 = 0x8269FD38;
    'dispatch: loop {
        match pc {
            0x8269FD38 => {
    //   block [0x8269FD38..0x8269FF64)
	// 8269FD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269FD3C: 48B0842D  bl 0x831a8168
	ctx.lr = 0x8269FD40;
	sub_831A8130(ctx, base);
	// 8269FD40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269FD44: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8269FD48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8269FD4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8269FD50: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8269FD54: 41820038  beq 0x8269fd8c
	if ctx.cr[0].eq {
	pc = 0x8269FD8C; continue 'dispatch;
	}
	// 8269FD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FD5C: 48B09C2D  bl 0x831a9988
	ctx.lr = 0x8269FD60;
	sub_831A9988(ctx, base);
	// 8269FD60: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269FD64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FD68: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 8269FD6C: 48B0838D  bl 0x831a80f8
	ctx.lr = 0x8269FD70;
	sub_831A80F8(ctx, base);
	// 8269FD70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FD74: 41820018  beq 0x8269fd8c
	if ctx.cr[0].eq {
	pc = 0x8269FD8C; continue 'dispatch;
	}
	// 8269FD78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FD7C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FD80: 4BFFE371  bl 0x8269e0f0
	ctx.lr = 0x8269FD84;
	sub_8269E0F0(ctx, base);
	// 8269FD84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8269FD88: 480001D4  b 0x8269ff5c
	pc = 0x8269FF5C; continue 'dispatch;
	// 8269FD8C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FD90: 419A018C  beq cr6, 0x8269ff1c
	if ctx.cr[6].eq {
	pc = 0x8269FF1C; continue 'dispatch;
	}
	// 8269FD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FD98: 48B09BF1  bl 0x831a9988
	ctx.lr = 0x8269FD9C;
	sub_831A9988(ctx, base);
	// 8269FD9C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8269FDA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FDA4: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 8269FDA8: 48B08351  bl 0x831a80f8
	ctx.lr = 0x8269FDAC;
	sub_831A80F8(ctx, base);
	// 8269FDAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FDB0: 41820014  beq 0x8269fdc4
	if ctx.cr[0].eq {
	pc = 0x8269FDC4; continue 'dispatch;
	}
	// 8269FDB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FDB8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FDBC: 4BFFE345  bl 0x8269e100
	ctx.lr = 0x8269FDC0;
	sub_8269E100(ctx, base);
	// 8269FDC0: 4BFFFFC4  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FDC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FDC8: 419A0154  beq cr6, 0x8269ff1c
	if ctx.cr[6].eq {
	pc = 0x8269FF1C; continue 'dispatch;
	}
	// 8269FDCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FDD0: 48B09BB9  bl 0x831a9988
	ctx.lr = 0x8269FDD4;
	sub_831A9988(ctx, base);
	// 8269FDD4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269FDD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FDDC: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 8269FDE0: 48B08319  bl 0x831a80f8
	ctx.lr = 0x8269FDE4;
	sub_831A80F8(ctx, base);
	// 8269FDE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FDE8: 41820014  beq 0x8269fdfc
	if ctx.cr[0].eq {
	pc = 0x8269FDFC; continue 'dispatch;
	}
	// 8269FDEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FDF0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FDF4: 4BFFE6D5  bl 0x8269e4c8
	ctx.lr = 0x8269FDF8;
	sub_8269E4C8(ctx, base);
	// 8269FDF8: 4BFFFF8C  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FDFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FE00: 419A011C  beq cr6, 0x8269ff1c
	if ctx.cr[6].eq {
	pc = 0x8269FF1C; continue 'dispatch;
	}
	// 8269FE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FE08: 48B09B81  bl 0x831a9988
	ctx.lr = 0x8269FE0C;
	sub_831A9988(ctx, base);
	// 8269FE0C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8269FE10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FE14: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 8269FE18: 48B082E1  bl 0x831a80f8
	ctx.lr = 0x8269FE1C;
	sub_831A80F8(ctx, base);
	// 8269FE1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FE20: 41820014  beq 0x8269fe34
	if ctx.cr[0].eq {
	pc = 0x8269FE34; continue 'dispatch;
	}
	// 8269FE24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FE28: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FE2C: 4BFFE75D  bl 0x8269e588
	ctx.lr = 0x8269FE30;
	sub_8269E588(ctx, base);
	// 8269FE30: 4BFFFF54  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FE34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FE38: 419A00E4  beq cr6, 0x8269ff1c
	if ctx.cr[6].eq {
	pc = 0x8269FF1C; continue 'dispatch;
	}
	// 8269FE3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FE40: 48B09B49  bl 0x831a9988
	ctx.lr = 0x8269FE44;
	sub_831A9988(ctx, base);
	// 8269FE44: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269FE48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FE4C: 386B95E8  addi r3, r11, -0x6a18
	ctx.r[3].s64 = ctx.r[11].s64 + -27160;
	// 8269FE50: 48B082A9  bl 0x831a80f8
	ctx.lr = 0x8269FE54;
	sub_831A80F8(ctx, base);
	// 8269FE54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FE58: 41820014  beq 0x8269fe6c
	if ctx.cr[0].eq {
	pc = 0x8269FE6C; continue 'dispatch;
	}
	// 8269FE5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FE60: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FE64: 4BFFE835  bl 0x8269e698
	ctx.lr = 0x8269FE68;
	sub_8269E698(ctx, base);
	// 8269FE68: 4BFFFF1C  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FE6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FE70: 419A00AC  beq cr6, 0x8269ff1c
	if ctx.cr[6].eq {
	pc = 0x8269FF1C; continue 'dispatch;
	}
	// 8269FE74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FE78: 48B09B11  bl 0x831a9988
	ctx.lr = 0x8269FE7C;
	sub_831A9988(ctx, base);
	// 8269FE7C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 8269FE80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FE84: 386B988C  addi r3, r11, -0x6774
	ctx.r[3].s64 = ctx.r[11].s64 + -26484;
	// 8269FE88: 48B08271  bl 0x831a80f8
	ctx.lr = 0x8269FE8C;
	sub_831A80F8(ctx, base);
	// 8269FE8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FE90: 41820014  beq 0x8269fea4
	if ctx.cr[0].eq {
	pc = 0x8269FEA4; continue 'dispatch;
	}
	// 8269FE94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FE98: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FE9C: 4BFFE275  bl 0x8269e110
	ctx.lr = 0x8269FEA0;
	sub_8269E110(ctx, base);
	// 8269FEA0: 4BFFFEE4  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FEA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FEA8: 419A0074  beq cr6, 0x8269ff1c
	if ctx.cr[6].eq {
	pc = 0x8269FF1C; continue 'dispatch;
	}
	// 8269FEAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FEB0: 48B09AD9  bl 0x831a9988
	ctx.lr = 0x8269FEB4;
	sub_831A9988(ctx, base);
	// 8269FEB4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269FEB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FEBC: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 8269FEC0: 48B08239  bl 0x831a80f8
	ctx.lr = 0x8269FEC4;
	sub_831A80F8(ctx, base);
	// 8269FEC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FEC8: 41820014  beq 0x8269fedc
	if ctx.cr[0].eq {
	pc = 0x8269FEDC; continue 'dispatch;
	}
	// 8269FECC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FED0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FED4: 4BFFFE35  bl 0x8269fd08
	ctx.lr = 0x8269FED8;
	sub_8269FD08(ctx, base);
	// 8269FED8: 4BFFFEAC  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FEDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FEE0: 419A003C  beq cr6, 0x8269ff1c
	if ctx.cr[6].eq {
	pc = 0x8269FF1C; continue 'dispatch;
	}
	// 8269FEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FEE8: 48B09AA1  bl 0x831a9988
	ctx.lr = 0x8269FEEC;
	sub_831A9988(ctx, base);
	// 8269FEEC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8269FEF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FEF4: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 8269FEF8: 48B08201  bl 0x831a80f8
	ctx.lr = 0x8269FEFC;
	sub_831A80F8(ctx, base);
	// 8269FEFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FF00: 41820014  beq 0x8269ff14
	if ctx.cr[0].eq {
	pc = 0x8269FF14; continue 'dispatch;
	}
	// 8269FF04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FF08: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FF0C: 4BFFE21D  bl 0x8269e128
	ctx.lr = 0x8269FF10;
	sub_8269E128(ctx, base);
	// 8269FF10: 4BFFFE74  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FF14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8269FF18: 409A0034  bne cr6, 0x8269ff4c
	if !ctx.cr[6].eq {
	pc = 0x8269FF4C; continue 'dispatch;
	}
	// 8269FF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8269FF20: 48B09A69  bl 0x831a9988
	ctx.lr = 0x8269FF24;
	sub_831A9988(ctx, base);
	// 8269FF24: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8269FF28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8269FF2C: 386B12E0  addi r3, r11, 0x12e0
	ctx.r[3].s64 = ctx.r[11].s64 + 4832;
	// 8269FF30: 48B081C9  bl 0x831a80f8
	ctx.lr = 0x8269FF34;
	sub_831A80F8(ctx, base);
	// 8269FF34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8269FF38: 41820014  beq 0x8269ff4c
	if ctx.cr[0].eq {
	pc = 0x8269FF4C; continue 'dispatch;
	}
	// 8269FF3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FF40: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8269FF44: 4BFFE20D  bl 0x8269e150
	ctx.lr = 0x8269FF48;
	sub_8269E150(ctx, base);
	// 8269FF48: 4BFFFE3C  b 0x8269fd84
	pc = 0x8269FD84; continue 'dispatch;
	// 8269FF4C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8269FF50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8269FF54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8269FF58: 4BE726C1  bl 0x82512618
	ctx.lr = 0x8269FF5C;
	sub_82512618(ctx, base);
	// 8269FF5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8269FF60: 48B08258  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269FF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269FF68 size=144
    let mut pc: u32 = 0x8269FF68;
    'dispatch: loop {
        match pc {
            0x8269FF68 => {
    //   block [0x8269FF68..0x8269FFF8)
	// 8269FF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269FF6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8269FF70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8269FF74: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8269FF78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8269FF7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8269FF80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269FF84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8269FF88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8269FF8C: C1BF004C  lfs f13, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269FF90: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8269FF94: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269FF98: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8269FF9C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8269FFA0: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8269FFA4: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8269FFA8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8269FFAC: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8269FFB0: 4BEEAEB9  bl 0x8258ae68
	ctx.lr = 0x8269FFB4;
	sub_8258AE68(ctx, base);
	// 8269FFB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8269FFB8: C1BF004C  lfs f13, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8269FFBC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8269FFC0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8269FFC4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8269FFC8: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8269FFCC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8269FFD0: C00B9530  lfs f0, -0x6ad0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8269FFD4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8269FFD8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8269FFDC: 4BEEAE8D  bl 0x8258ae68
	ctx.lr = 0x8269FFE0;
	sub_8258AE68(ctx, base);
	// 8269FFE0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8269FFE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8269FFE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8269FFEC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8269FFF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8269FFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8269FFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8269FFF8 size=316
    let mut pc: u32 = 0x8269FFF8;
    'dispatch: loop {
        match pc {
            0x8269FFF8 => {
    //   block [0x8269FFF8..0x826A0134)
	// 8269FFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8269FFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A0000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A0004: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A0008: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A000C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A0010: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A0014: C01F0134  lfs f0, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A0018: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A001C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 826A0020: 419A00FC  beq cr6, 0x826a011c
	if ctx.cr[6].eq {
	pc = 0x826A011C; continue 'dispatch;
	}
	// 826A0024: C01F0138  lfs f0, 0x138(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A0028: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 826A002C: 419A00F0  beq cr6, 0x826a011c
	if ctx.cr[6].eq {
	pc = 0x826A011C; continue 'dispatch;
	}
	// 826A0030: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0038: 4BE6F491  bl 0x8250f4c8
	ctx.lr = 0x826A003C;
	sub_8250F4C8(ctx, base);
	// 826A003C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A0044: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A0048: 409A0008  bne cr6, 0x826a0050
	if !ctx.cr[6].eq {
	pc = 0x826A0050; continue 'dispatch;
	}
	// 826A004C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A0050: 4BE684C9  bl 0x82508518
	ctx.lr = 0x826A0054;
	sub_82508518(ctx, base);
	// 826A0054: C01F013C  lfs f0, 0x13c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A0058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A005C: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 826A0060: 48751C31  bl 0x82df1c90
	ctx.lr = 0x826A0064;
	sub_82DF1C90(ctx, base);
	// 826A0064: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A0068: C01F0138  lfs f0, 0x138(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A006C: C17F0140  lfs f11, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826A0070: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A0074: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826A0078: EDAB602A  fadds f13, f11, f12
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 826A007C: ED5F6824  fdivs f10, f31, f13
	ctx.f[10].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 826A0080: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 826A0084: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 826A0088: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A008C: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 826A0090: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 826A0094: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A0098: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 826A009C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 826A00A0: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 826A00A4: EDAAFB7C  fnmsubs f13, f10, f13, f31
	ctx.f[13].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 826A00A8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 826A00AC: 4098001C  bge cr6, 0x826a00c8
	if !ctx.cr[6].lt {
	pc = 0x826A00C8; continue 'dispatch;
	}
	// 826A00B0: 4082000C  bne 0x826a00bc
	if !ctx.cr[0].eq {
	pc = 0x826A00BC; continue 'dispatch;
	}
	// 826A00B4: C03F0134  lfs f1, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A00B8: 48000064  b 0x826a011c
	pc = 0x826A011C; continue 'dispatch;
	// 826A00BC: C01F0134  lfs f0, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A00C0: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A00C4: 48000058  b 0x826a011c
	pc = 0x826A011C; continue 'dispatch;
	// 826A00C8: C17F0140  lfs f11, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826A00CC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826A00D0: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 826A00D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A00D8: 4082001C  bne 0x826a00f4
	if !ctx.cr[0].eq {
	pc = 0x826A00F4; continue 'dispatch;
	}
	// 826A00DC: C18BDFAC  lfs f12, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A00E0: C16A9524  lfs f11, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826A00E4: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 826A00E8: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 826A00EC: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826A00F0: 4800001C  b 0x826a010c
	pc = 0x826A010C; continue 'dispatch;
	// 826A00F4: ED6D602A  fadds f11, f13, f12
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 826A00F8: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A00FC: C18A9524  lfs f12, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A0100: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 826A0104: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 826A0108: EC2002F2  fmuls f1, f0, f11
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 826A010C: 48B08D9D  bl 0x831a8ea8
	ctx.lr = 0x826A0110;
	sub_831A8EA8(ctx, base);
	// 826A0110: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826A0114: C1BF0134  lfs f13, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A0118: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826A011C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A0120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A0124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A0128: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A012C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A0130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A0138 size=380
    let mut pc: u32 = 0x826A0138;
    'dispatch: loop {
        match pc {
            0x826A0138 => {
    //   block [0x826A0138..0x826A02B4)
	// 826A0138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A013C: 48B08029  bl 0x831a8164
	ctx.lr = 0x826A0140;
	sub_831A8130(ctx, base);
	// 826A0140: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A0148: 4BFFFEB1  bl 0x8269fff8
	ctx.lr = 0x826A014C;
	sub_8269FFF8(ctx, base);
	// 826A014C: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826A0150: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A0154: 41980028  blt cr6, 0x826a017c
	if ctx.cr[6].lt {
	pc = 0x826A017C; continue 'dispatch;
	}
	// 826A0158: 409A0048  bne cr6, 0x826a01a0
	if !ctx.cr[6].eq {
	pc = 0x826A01A0; continue 'dispatch;
	}
	// 826A015C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A0160: D0210070  stfs f1, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826A0164: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826A0168: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A016C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826A0170: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826A0174: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 826A0178: 48000020  b 0x826a0198
	pc = 0x826A0198; continue 'dispatch;
	// 826A017C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A0180: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826A0184: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826A0188: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A018C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826A0190: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826A0194: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826A0198: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826A019C: 4BEEACCD  bl 0x8258ae68
	ctx.lr = 0x826A01A0;
	sub_8258AE68(ctx, base);
	// 826A01A0: 3B810090  addi r28, r1, 0x90
	ctx.r[28].s64 = ctx.r[1].s64 + 144;
	// 826A01A4: 3BBF00F0  addi r29, r31, 0xf0
	ctx.r[29].s64 = ctx.r[31].s64 + 240;
	// 826A01A8: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 826A01AC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A01B0: 48155221  bl 0x827f53d0
	ctx.lr = 0x826A01B4;
	sub_827F53D0(ctx, base);
	// 826A01B4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826A01B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A01BC: 4BE7192D  bl 0x82511ae8
	ctx.lr = 0x826A01C0;
	sub_82511AE8(ctx, base);
	// 826A01C0: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A01C4: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A01C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A02B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A02B8 size=196
    let mut pc: u32 = 0x826A02B8;
    'dispatch: loop {
        match pc {
            0x826A02B8 => {
    //   block [0x826A02B8..0x826A037C)
	// 826A02B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A02BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A02C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A02C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A02C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A02CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A02D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A02D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A02D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A02DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A02E0: 4BC20659  bl 0x822c0938
	ctx.lr = 0x826A02E4;
	sub_822C0938(ctx, base);
	// 826A02E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A02E8: 41820028  beq 0x826a0310
	if ctx.cr[0].eq {
	pc = 0x826A0310; continue 'dispatch;
	}
	// 826A02EC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A02F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A02F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A02F8: 392B06F0  addi r9, r11, 0x6f0
	ctx.r[9].s64 = ctx.r[11].s64 + 1776;
	// 826A02FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A0300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A0304: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A0308: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A030C: 48000008  b 0x826a0314
	pc = 0x826A0314; continue 'dispatch;
	// 826A0310: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A0314: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A0318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A031C: 409A0044  bne cr6, 0x826a0360
	if !ctx.cr[6].eq {
	pc = 0x826A0360; continue 'dispatch;
	}
	// 826A0320: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A0324: 419A001C  beq cr6, 0x826a0340
	if ctx.cr[6].eq {
	pc = 0x826A0340; continue 'dispatch;
	}
	// 826A0328: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A032C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A0330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A0334: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0338: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A033C: 4E800421  bctrl
	ctx.lr = 0x826A0340;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A0340: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A0344: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A0348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A034C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A0350: 816B98CC  lwz r11, -0x6734(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26420 as u32) ) } as u64;
	// 826A0354: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A0358: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A035C: 4BC1FCA5  bl 0x822c0000
	ctx.lr = 0x826A0360;
	sub_822C0000(ctx, base);
	// 826A0360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0364: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A0368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A036C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A0370: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A0374: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A0378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A0380 size=188
    let mut pc: u32 = 0x826A0380;
    'dispatch: loop {
        match pc {
            0x826A0380 => {
    //   block [0x826A0380..0x826A043C)
	// 826A0380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A0384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A0388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A038C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A0390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0394: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A0398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A039C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A03A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A03A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A03A8: 4BC20591  bl 0x822c0938
	ctx.lr = 0x826A03AC;
	sub_822C0938(ctx, base);
	// 826A03AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A03B0: 41820028  beq 0x826a03d8
	if ctx.cr[0].eq {
	pc = 0x826A03D8; continue 'dispatch;
	}
	// 826A03B4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A03B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A03BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A03C0: 392B0704  addi r9, r11, 0x704
	ctx.r[9].s64 = ctx.r[11].s64 + 1796;
	// 826A03C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A03C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A03CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A03D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A03D4: 48000008  b 0x826a03dc
	pc = 0x826A03DC; continue 'dispatch;
	// 826A03D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A03DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A03E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A03E4: 409A003C  bne cr6, 0x826a0420
	if !ctx.cr[6].eq {
	pc = 0x826A0420; continue 'dispatch;
	}
	// 826A03E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A03EC: 419A0014  beq cr6, 0x826a0400
	if ctx.cr[6].eq {
	pc = 0x826A0400; continue 'dispatch;
	}
	// 826A03F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A03F4: 4812604D  bl 0x827c6440
	ctx.lr = 0x826A03F8;
	sub_827C6440(ctx, base);
	// 826A03F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A03FC: 4BC1FE6D  bl 0x822c0268
	ctx.lr = 0x826A0400;
	sub_822C0268(ctx, base);
	// 826A0400: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A0404: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A0408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A040C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A0410: 816B98CC  lwz r11, -0x6734(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26420 as u32) ) } as u64;
	// 826A0414: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A0418: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A041C: 4BC1FBE5  bl 0x822c0000
	ctx.lr = 0x826A0420;
	sub_822C0000(ctx, base);
	// 826A0420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A0428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A042C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A0430: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A0434: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A0438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A0440 size=64
    let mut pc: u32 = 0x826A0440;
    'dispatch: loop {
        match pc {
            0x826A0440 => {
    //   block [0x826A0440..0x826A0480)
	// 826A0440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A0444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A0448: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A044C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0450: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A0454: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A0458: 419A0014  beq cr6, 0x826a046c
	if ctx.cr[6].eq {
	pc = 0x826A046C; continue 'dispatch;
	}
	// 826A045C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A0460: 48125FE1  bl 0x827c6440
	ctx.lr = 0x826A0464;
	sub_827C6440(ctx, base);
	// 826A0464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A0468: 4BC1FE01  bl 0x822c0268
	ctx.lr = 0x826A046C;
	sub_822C0268(ctx, base);
	// 826A046C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A0470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A0474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A0478: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A047C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A0480 size=268
    let mut pc: u32 = 0x826A0480;
    'dispatch: loop {
        match pc {
            0x826A0480 => {
    //   block [0x826A0480..0x826A058C)
	// 826A0480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A0484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A0488: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A048C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0490: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 826A0494: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826A0498: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 826A049C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 826A04A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A04A4: 4BE71DBD  bl 0x82512260
	ctx.lr = 0x826A04A8;
	sub_82512260(ctx, base);
	// 826A04A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A04AC: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A04B0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826A04B4: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A04B8: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 826A04BC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826A04C0: 394A077C  addi r10, r10, 0x77c
	ctx.r[10].s64 = ctx.r[10].s64 + 1916;
	// 826A04C4: 39290768  addi r9, r9, 0x768
	ctx.r[9].s64 = ctx.r[9].s64 + 1896;
	// 826A04C8: 3908071C  addi r8, r8, 0x71c
	ctx.r[8].s64 = ctx.r[8].s64 + 1820;
	// 826A04CC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826A04D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A04D4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826A04D8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826A04DC: 395F00F0  addi r10, r31, 0xf0
	ctx.r[10].s64 = ctx.r[31].s64 + 240;
	// 826A04E0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826A04E4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826A04E8: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826A04EC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A04F0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826A04F4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826A04F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826A04FC: 4080FFF0  bge 0x826a04ec
	if !ctx.cr[0].lt {
	pc = 0x826A04EC; continue 'dispatch;
	}
	// 826A0500: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 826A0504: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826A0508: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A050C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826A0510: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826A0514: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826A0518: 4080FFF0  bge 0x826a0508
	if !ctx.cr[0].lt {
	pc = 0x826A0508; continue 'dispatch;
	}
	// 826A051C: 395F0110  addi r10, r31, 0x110
	ctx.r[10].s64 = ctx.r[31].s64 + 272;
	// 826A0520: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826A0524: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A0528: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826A052C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826A0530: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826A0534: 4080FFF0  bge 0x826a0524
	if !ctx.cr[0].lt {
	pc = 0x826A0524; continue 'dispatch;
	}
	// 826A0538: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826A053C: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826A0540: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A0544: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826A0548: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 826A054C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A0550: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 826A0554: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 826A0558: C1AAD7BC  lfs f13, -0x2844(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A055C: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 826A0560: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A0564: D1BF0130  stfs f13, 0x130(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 826A0568: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 826A056C: D01F0138  stfs f0, 0x138(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 826A0570: D01F013C  stfs f0, 0x13c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 826A0574: D01F0140  stfs f0, 0x140(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 826A0578: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A057C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A0580: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A0584: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A0588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A0590 size=8
    let mut pc: u32 = 0x826A0590;
    'dispatch: loop {
        match pc {
            0x826A0590 => {
    //   block [0x826A0590..0x826A0598)
	// 826A0590: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826A0594: 48000104  b 0x826a0698
	sub_826A0698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A0598 size=8
    let mut pc: u32 = 0x826A0598;
    'dispatch: loop {
        match pc {
            0x826A0598 => {
    //   block [0x826A0598..0x826A05A0)
	// 826A0598: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826A059C: 480000FC  b 0x826a0698
	sub_826A0698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A05A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A05A0 size=248
    let mut pc: u32 = 0x826A05A0;
    'dispatch: loop {
        match pc {
            0x826A05A0 => {
    //   block [0x826A05A0..0x826A0698)
	// 826A05A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A05A4: 48B07BC5  bl 0x831a8168
	ctx.lr = 0x826A05A8;
	sub_831A8130(ctx, base);
	// 826A05A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A05AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A05B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A05B4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A05B8: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A05BC: 396B077C  addi r11, r11, 0x77c
	ctx.r[11].s64 = ctx.r[11].s64 + 1916;
	// 826A05C0: 394A0768  addi r10, r10, 0x768
	ctx.r[10].s64 = ctx.r[10].s64 + 1896;
	// 826A05C4: 3929071C  addi r9, r9, 0x71c
	ctx.r[9].s64 = ctx.r[9].s64 + 1820;
	// 826A05C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A05CC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A05D0: 3B9F00E4  addi r28, r31, 0xe4
	ctx.r[28].s64 = ctx.r[31].s64 + 228;
	// 826A05D4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A05D8: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 826A05DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A05E0: 419A0008  beq cr6, 0x826a05e8
	if ctx.cr[6].eq {
	pc = 0x826A05E8; continue 'dispatch;
	}
	// 826A05E4: 4BC202AD  bl 0x822c0890
	ctx.lr = 0x826A05E8;
	sub_822C0890(ctx, base);
	// 826A05E8: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826A05EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A05F0: 419A0008  beq cr6, 0x826a05f8
	if ctx.cr[6].eq {
	pc = 0x826A05F8; continue 'dispatch;
	}
	// 826A05F4: 4BC2029D  bl 0x822c0890
	ctx.lr = 0x826A05F8;
	sub_822C0890(ctx, base);
	// 826A05F8: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 826A05FC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826A0600: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826A0604: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826A0608: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A060C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0610: 419A0008  beq cr6, 0x826a0618
	if ctx.cr[6].eq {
	pc = 0x826A0618; continue 'dispatch;
	}
	// 826A0614: 4BC2027D  bl 0x822c0890
	ctx.lr = 0x826A0618;
	sub_822C0890(ctx, base);
	// 826A0618: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A061C: 4080FFE8  bge 0x826a0604
	if !ctx.cr[0].lt {
	pc = 0x826A0604; continue 'dispatch;
	}
	// 826A0620: 397F0110  addi r11, r31, 0x110
	ctx.r[11].s64 = ctx.r[31].s64 + 272;
	// 826A0624: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826A0628: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826A062C: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826A0630: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0638: 419A0008  beq cr6, 0x826a0640
	if ctx.cr[6].eq {
	pc = 0x826A0640; continue 'dispatch;
	}
	// 826A063C: 4BC20255  bl 0x822c0890
	ctx.lr = 0x826A0640;
	sub_822C0890(ctx, base);
	// 826A0640: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A0644: 4080FFE8  bge 0x826a062c
	if !ctx.cr[0].lt {
	pc = 0x826A062C; continue 'dispatch;
	}
	// 826A0648: 397F0100  addi r11, r31, 0x100
	ctx.r[11].s64 = ctx.r[31].s64 + 256;
	// 826A064C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826A0650: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826A0654: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826A0658: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A065C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0660: 419A0008  beq cr6, 0x826a0668
	if ctx.cr[6].eq {
	pc = 0x826A0668; continue 'dispatch;
	}
	// 826A0664: 4BC2022D  bl 0x822c0890
	ctx.lr = 0x826A0668;
	sub_822C0890(ctx, base);
	// 826A0668: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A066C: 4080FFE8  bge 0x826a0654
	if !ctx.cr[0].lt {
	pc = 0x826A0654; continue 'dispatch;
	}
	// 826A0670: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826A0674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0678: 419A0008  beq cr6, 0x826a0680
	if ctx.cr[6].eq {
	pc = 0x826A0680; continue 'dispatch;
	}
	// 826A067C: 4BC20215  bl 0x822c0890
	ctx.lr = 0x826A0680;
	sub_822C0890(ctx, base);
	// 826A0680: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A0684: 48106FD5  bl 0x827a7658
	ctx.lr = 0x826A0688;
	sub_827A7658(ctx, base);
	// 826A0688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A068C: 4BCAECC5  bl 0x8234f350
	ctx.lr = 0x826A0690;
	sub_8234F350(ctx, base);
	// 826A0690: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A0694: 48B07B24  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A0698 size=76
    let mut pc: u32 = 0x826A0698;
    'dispatch: loop {
        match pc {
            0x826A0698 => {
    //   block [0x826A0698..0x826A06E4)
	// 826A0698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A069C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A06A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A06A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A06A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A06AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A06B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A06B4: 4BFFFEED  bl 0x826a05a0
	ctx.lr = 0x826A06B8;
	sub_826A05A0(ctx, base);
	// 826A06B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A06BC: 4182000C  beq 0x826a06c8
	if ctx.cr[0].eq {
	pc = 0x826A06C8; continue 'dispatch;
	}
	// 826A06C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A06C4: 48751D15  bl 0x82df23d8
	ctx.lr = 0x826A06C8;
	sub_82DF23D8(ctx, base);
	// 826A06C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A06CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A06D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A06D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A06D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A06DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A06E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A06E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A06E8 size=668
    let mut pc: u32 = 0x826A06E8;
    'dispatch: loop {
        match pc {
            0x826A06E8 => {
    //   block [0x826A06E8..0x826A0984)
	// 826A06E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A06EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A06F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A06F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A06F8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826A06FC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826A0700: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826A0704: 9421FDB0  stwu r1, -0x250(r1)
	ea = ctx.r[1].u32.wrapping_add(-592 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0708: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A070C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A0710: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A0714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0718: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 826A071C: 487532ED  bl 0x82df3a08
	ctx.lr = 0x826A0720;
	sub_82DF3A08(ctx, base);
	// 826A0720: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A0724: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A0728: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A072C: 389F004C  addi r4, r31, 0x4c
	ctx.r[4].s64 = ctx.r[31].s64 + 76;
	// 826A0730: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 826A0734: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A0738: C04AE0B4  lfs f2, -0x1f4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8012 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A073C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A0740: C02908A8  lfs f1, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A0744: 4BF02A6D  bl 0x825a31b0
	ctx.lr = 0x826A0748;
	sub_825A31B0(ctx, base);
	// 826A0748: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A074C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0750: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A0754: 4BF0101D  bl 0x825a1770
	ctx.lr = 0x826A0758;
	sub_825A1770(ctx, base);
	// 826A0758: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 826A075C: 48752CCD  bl 0x82df3428
	ctx.lr = 0x826A0760;
	sub_82DF3428(ctx, base);
	// 826A0760: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 826A0764: 4BC28555  bl 0x822c8cb8
	ctx.lr = 0x826A0768;
	sub_822C8CB8(ctx, base);
	// 826A0768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A076C: 48752CBD  bl 0x82df3428
	ctx.lr = 0x826A0770;
	sub_82DF3428(ctx, base);
	// 826A0770: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A0774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0778: 388B1310  addi r4, r11, 0x1310
	ctx.r[4].s64 = ctx.r[11].s64 + 4880;
	// 826A077C: 4875328D  bl 0x82df3a08
	ctx.lr = 0x826A0780;
	sub_82DF3A08(ctx, base);
	// 826A0780: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826A0784: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A0788: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A078C: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 826A0790: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 826A0794: C3CB9A8C  lfs f30, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A0798: C3AA08A4  lfs f29, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826A079C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A07A0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826A07A4: 4BF02A0D  bl 0x825a31b0
	ctx.lr = 0x826A07A8;
	sub_825A31B0(ctx, base);
	// 826A07A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A07AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A07B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A07B4: 4BF00FBD  bl 0x825a1770
	ctx.lr = 0x826A07B8;
	sub_825A1770(ctx, base);
	// 826A07B8: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 826A07BC: 48752C6D  bl 0x82df3428
	ctx.lr = 0x826A07C0;
	sub_82DF3428(ctx, base);
	// 826A07C0: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 826A07C4: 4BC284F5  bl 0x822c8cb8
	ctx.lr = 0x826A07C8;
	sub_822C8CB8(ctx, base);
	// 826A07C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A07CC: 48752C5D  bl 0x82df3428
	ctx.lr = 0x826A07D0;
	sub_82DF3428(ctx, base);
	// 826A07D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A07D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A07D8: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 826A07DC: 4875322D  bl 0x82df3a08
	ctx.lr = 0x826A07E0;
	sub_82DF3A08(ctx, base);
	// 826A07E0: 389F0054  addi r4, r31, 0x54
	ctx.r[4].s64 = ctx.r[31].s64 + 84;
	// 826A07E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A07E8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A07EC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A07F0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826A07F4: 4BF029BD  bl 0x825a31b0
	ctx.lr = 0x826A07F8;
	sub_825A31B0(ctx, base);
	// 826A07F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A07FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A0804: 4BF00F6D  bl 0x825a1770
	ctx.lr = 0x826A0808;
	sub_825A1770(ctx, base);
	// 826A0808: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A080C: 48752C1D  bl 0x82df3428
	ctx.lr = 0x826A0810;
	sub_82DF3428(ctx, base);
	// 826A0810: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A0814: 4BC284A5  bl 0x822c8cb8
	ctx.lr = 0x826A0818;
	sub_822C8CB8(ctx, base);
	// 826A0818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A081C: 48752C0D  bl 0x82df3428
	ctx.lr = 0x826A0820;
	sub_82DF3428(ctx, base);
	// 826A0820: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A0824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0828: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 826A082C: 487531DD  bl 0x82df3a08
	ctx.lr = 0x826A0830;
	sub_82DF3A08(ctx, base);
	// 826A0830: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 826A0834: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A0838: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A083C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A0840: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826A0844: 4BF0296D  bl 0x825a31b0
	ctx.lr = 0x826A0848;
	sub_825A31B0(ctx, base);
	// 826A0848: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A084C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A0854: 4BF00F1D  bl 0x825a1770
	ctx.lr = 0x826A0858;
	sub_825A1770(ctx, base);
	// 826A0858: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826A085C: 48752BCD  bl 0x82df3428
	ctx.lr = 0x826A0860;
	sub_82DF3428(ctx, base);
	// 826A0860: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826A0864: 4BC28455  bl 0x822c8cb8
	ctx.lr = 0x826A0868;
	sub_822C8CB8(ctx, base);
	// 826A0868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A086C: 48752BBD  bl 0x82df3428
	ctx.lr = 0x826A0870;
	sub_82DF3428(ctx, base);
	// 826A0870: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A0874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0878: 388B4370  addi r4, r11, 0x4370
	ctx.r[4].s64 = ctx.r[11].s64 + 17264;
	// 826A087C: 4875318D  bl 0x82df3a08
	ctx.lr = 0x826A0880;
	sub_82DF3A08(ctx, base);
	// 826A0880: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 826A0884: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826A0888: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A088C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A0890: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826A0894: 4BF0291D  bl 0x825a31b0
	ctx.lr = 0x826A0898;
	sub_825A31B0(ctx, base);
	// 826A0898: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A089C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A08A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A08A4: 4BF00ECD  bl 0x825a1770
	ctx.lr = 0x826A08A8;
	sub_825A1770(ctx, base);
	// 826A08A8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826A08AC: 48752B7D  bl 0x82df3428
	ctx.lr = 0x826A08B0;
	sub_82DF3428(ctx, base);
	// 826A08B0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826A08B4: 4BC28405  bl 0x822c8cb8
	ctx.lr = 0x826A08B8;
	sub_822C8CB8(ctx, base);
	// 826A08B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A08BC: 48752B6D  bl 0x82df3428
	ctx.lr = 0x826A08C0;
	sub_82DF3428(ctx, base);
	// 826A08C0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 826A08C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A08C8: 388B5EA0  addi r4, r11, 0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + 24224;
	// 826A08CC: 4875313D  bl 0x82df3a08
	ctx.lr = 0x826A08D0;
	sub_82DF3A08(ctx, base);
	// 826A08D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A08D4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A08D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A08DC: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 826A08E0: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 826A08E4: 4BF02AC5  bl 0x825a33a8
	ctx.lr = 0x826A08E8;
	sub_825A33A8(ctx, base);
	// 826A08E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A08EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A08F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A08F4: 4BF015E5  bl 0x825a1ed8
	ctx.lr = 0x826A08F8;
	sub_825A1ED8(ctx, base);
	// 826A08F8: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 826A08FC: 48752B2D  bl 0x82df3428
	ctx.lr = 0x826A0900;
	sub_82DF3428(ctx, base);
	// 826A0900: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 826A0904: 4BC283B5  bl 0x822c8cb8
	ctx.lr = 0x826A0908;
	sub_822C8CB8(ctx, base);
	// 826A0908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A090C: 48752B1D  bl 0x82df3428
	ctx.lr = 0x826A0910;
	sub_82DF3428(ctx, base);
	// 826A0910: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826A0914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0918: 388B44A0  addi r4, r11, 0x44a0
	ctx.r[4].s64 = ctx.r[11].s64 + 17568;
	// 826A091C: 487530ED  bl 0x82df3a08
	ctx.lr = 0x826A0920;
	sub_82DF3A08(ctx, base);
	// 826A0920: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A0924: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A0928: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A092C: 389F0064  addi r4, r31, 0x64
	ctx.r[4].s64 = ctx.r[31].s64 + 100;
	// 826A0930: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 826A0934: 4BF02A75  bl 0x825a33a8
	ctx.lr = 0x826A0938;
	sub_825A33A8(ctx, base);
	// 826A0938: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A093C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A0940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0944: 4BF01595  bl 0x825a1ed8
	ctx.lr = 0x826A0948;
	sub_825A1ED8(ctx, base);
	// 826A0948: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 826A094C: 48752ADD  bl 0x82df3428
	ctx.lr = 0x826A0950;
	sub_82DF3428(ctx, base);
	// 826A0950: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 826A0954: 4BC28365  bl 0x822c8cb8
	ctx.lr = 0x826A0958;
	sub_822C8CB8(ctx, base);
	// 826A0958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A095C: 48752ACD  bl 0x82df3428
	ctx.lr = 0x826A0960;
	sub_82DF3428(ctx, base);
	// 826A0960: 38210250  addi r1, r1, 0x250
	ctx.r[1].s64 = ctx.r[1].s64 + 592;
	// 826A0964: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A0968: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A096C: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826A0970: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826A0974: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826A0978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A097C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A0980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A0988 size=112
    let mut pc: u32 = 0x826A0988;
    'dispatch: loop {
        match pc {
            0x826A0988 => {
    //   block [0x826A0988..0x826A09F8)
	// 826A0988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A098C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A0990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A0994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A0998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A099C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A09A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A09A4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826A09A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A09AC: 4BFFF9D5  bl 0x826a0380
	ctx.lr = 0x826A09B0;
	sub_826A0380(ctx, base);
	// 826A09B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A09B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A09B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A09BC: 4BC1F645  bl 0x822c0000
	ctx.lr = 0x826A09C0;
	sub_822C0000(ctx, base);
	// 826A09C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A09C4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A09C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A09CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A09D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A09D4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A09D8: 419A0008  beq cr6, 0x826a09e0
	if ctx.cr[6].eq {
	pc = 0x826A09E0; continue 'dispatch;
	}
	// 826A09DC: 4BC1FEB5  bl 0x822c0890
	ctx.lr = 0x826A09E0;
	sub_822C0890(ctx, base);
	// 826A09E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A09E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A09E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A09EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A09F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A09F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A09F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A09F8 size=200
    let mut pc: u32 = 0x826A09F8;
    'dispatch: loop {
        match pc {
            0x826A09F8 => {
    //   block [0x826A09F8..0x826A0AC0)
	// 826A09F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A09FC: 48B07771  bl 0x831a816c
	ctx.lr = 0x826A0A00;
	sub_831A8130(ctx, base);
	// 826A0A00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0A04: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A0A08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A0A0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A0A10: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826A0A14: 4BE710D5  bl 0x82511ae8
	ctx.lr = 0x826A0A18;
	sub_82511AE8(ctx, base);
	// 826A0A18: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826A0A1C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A0A20: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 826A0A24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A0A28: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 826A0A2C: 4816B465  bl 0x8280be90
	ctx.lr = 0x826A0A30;
	sub_8280BE90(ctx, base);
	// 826A0A30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0A34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826A0A38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A0A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A0A40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A0A44: 419A0024  beq cr6, 0x826a0a68
	if ctx.cr[6].eq {
	pc = 0x826A0A68; continue 'dispatch;
	}
	// 826A0A48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A0A4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A0A50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0A54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A0A58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A0A5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A0A60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0A64: 4082FFE8  bne 0x826a0a4c
	if !ctx.cr[0].eq {
	pc = 0x826A0A4C; continue 'dispatch;
	}
	// 826A0A68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0A6C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826A0A70: 489676B9  bl 0x83008128
	ctx.lr = 0x826A0A74;
	sub_83008128(ctx, base);
	// 826A0A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A0A78: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A0A7C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826A0A80: 388A07B8  addi r4, r10, 0x7b8
	ctx.r[4].s64 = ctx.r[10].s64 + 1976;
	// 826A0A84: 38A000BF  li r5, 0xbf
	ctx.r[5].s64 = 191;
	// 826A0A88: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826A0A8C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A0A90: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826A0A94: 487B7FAD  bl 0x82e58a40
	ctx.lr = 0x826A0A98;
	sub_82E58A40(ctx, base);
	// 826A0A98: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A0A9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0AA0: 419A0008  beq cr6, 0x826a0aa8
	if ctx.cr[6].eq {
	pc = 0x826A0AA8; continue 'dispatch;
	}
	// 826A0AA4: 4BC1FDED  bl 0x822c0890
	ctx.lr = 0x826A0AA8;
	sub_822C0890(ctx, base);
	// 826A0AA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A0AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0AB0: 419A0008  beq cr6, 0x826a0ab8
	if ctx.cr[6].eq {
	pc = 0x826A0AB8; continue 'dispatch;
	}
	// 826A0AB4: 4BC1FDDD  bl 0x822c0890
	ctx.lr = 0x826A0AB8;
	sub_822C0890(ctx, base);
	// 826A0AB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A0ABC: 48B07700  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A0AC0 size=108
    let mut pc: u32 = 0x826A0AC0;
    'dispatch: loop {
        match pc {
            0x826A0AC0 => {
    //   block [0x826A0AC0..0x826A0B2C)
	// 826A0AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A0AC4: 48B076A9  bl 0x831a816c
	ctx.lr = 0x826A0AC8;
	sub_831A8130(ctx, base);
	// 826A0AC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0ACC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826A0AD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826A0AD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A0AD8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A0ADC: 41820038  beq 0x826a0b14
	if ctx.cr[0].eq {
	pc = 0x826A0B14; continue 'dispatch;
	}
	// 826A0AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A0AE4: 48B08EA5  bl 0x831a9988
	ctx.lr = 0x826A0AE8;
	sub_831A9988(ctx, base);
	// 826A0AE8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A0AEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A0AF0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826A0AF4: 48B07605  bl 0x831a80f8
	ctx.lr = 0x826A0AF8;
	sub_831A80F8(ctx, base);
	// 826A0AF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A0AFC: 41820018  beq 0x826a0b14
	if ctx.cr[0].eq {
	pc = 0x826A0B14; continue 'dispatch;
	}
	// 826A0B00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0B04: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 826A0B08: 4BFFFEF1  bl 0x826a09f8
	ctx.lr = 0x826A0B0C;
	sub_826A09F8(ctx, base);
	// 826A0B0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826A0B10: 48000014  b 0x826a0b24
	pc = 0x826A0B24; continue 'dispatch;
	// 826A0B14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A0B18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0B1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A0B20: 4BE71AF9  bl 0x82512618
	ctx.lr = 0x826A0B24;
	sub_82512618(ctx, base);
	// 826A0B24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A0B28: 48B07694  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A0B30 size=424
    let mut pc: u32 = 0x826A0B30;
    'dispatch: loop {
        match pc {
            0x826A0B30 => {
    //   block [0x826A0B30..0x826A0CD8)
	// 826A0B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A0B34: 48B07631  bl 0x831a8164
	ctx.lr = 0x826A0B38;
	sub_831A8130(ctx, base);
	// 826A0B38: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0B3C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A0B40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826A0B44: 3BCB07B8  addi r30, r11, 0x7b8
	ctx.r[30].s64 = ctx.r[11].s64 + 1976;
	// 826A0B48: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826A0B4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0B50: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 826A0B54: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826A0B58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A0B5C: 3860014C  li r3, 0x14c
	ctx.r[3].s64 = 332;
	// 826A0B60: 48751889  bl 0x82df23e8
	ctx.lr = 0x826A0B64;
	sub_82DF23E8(ctx, base);
	// 826A0B64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A0B68: 41820010  beq 0x826a0b78
	if ctx.cr[0].eq {
	pc = 0x826A0B78; continue 'dispatch;
	}
	// 826A0B6C: 4BFFF915  bl 0x826a0480
	ctx.lr = 0x826A0B70;
	sub_826A0480(ctx, base);
	// 826A0B70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A0B74: 48000008  b 0x826a0b7c
	pc = 0x826A0B7C; continue 'dispatch;
	// 826A0B78: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A0B7C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A0B80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0B84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A0B88: 4BFFF731  bl 0x826a02b8
	ctx.lr = 0x826A0B8C;
	sub_826A02B8(ctx, base);
	// 826A0B8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A0B90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0B94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A0B98: 4BC1F469  bl 0x822c0000
	ctx.lr = 0x826A0B9C;
	sub_822C0000(ctx, base);
	// 826A0B9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A0BA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0BA4: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 826A0BA8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826A0BAC: 4BC1F82D  bl 0x822c03d8
	ctx.lr = 0x826A0BB0;
	sub_822C03D8(ctx, base);
	// 826A0BB0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A0BB4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A0BB8: 418200B4  beq 0x826a0c6c
	if ctx.cr[0].eq {
	pc = 0x826A0C6C; continue 'dispatch;
	}
	// 826A0BBC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A0BC0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826A0BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826A0BC8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826A0BCC: 409A0008  bne cr6, 0x826a0bd4
	if !ctx.cr[6].eq {
	pc = 0x826A0BD4; continue 'dispatch;
	}
	// 826A0BD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A0BD4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A0BD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A0BDC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826A0BE0: 419A0024  beq cr6, 0x826a0c04
	if ctx.cr[6].eq {
	pc = 0x826A0C04; continue 'dispatch;
	}
	// 826A0BE4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826A0BE8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826A0BEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0BF0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826A0BF4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826A0BF8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A0BFC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0C00: 4082FFE8  bne 0x826a0be8
	if !ctx.cr[0].eq {
	pc = 0x826A0BE8; continue 'dispatch;
	}
	// 826A0C04: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826A0C08: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A0C0C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826A0C10: 419A0024  beq cr6, 0x826a0c34
	if ctx.cr[6].eq {
	pc = 0x826A0C34; continue 'dispatch;
	}
	// 826A0C14: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826A0C18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A0C1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0C20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A0C24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A0C28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A0C2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0C30: 4082FFE8  bne 0x826a0c18
	if !ctx.cr[0].eq {
	pc = 0x826A0C18; continue 'dispatch;
	}
	// 826A0C34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A0C38: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826A0C3C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A0C40: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826A0C44: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A0C48: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A0C4C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A0C50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A0C54: 480F82DD  bl 0x82798f30
	ctx.lr = 0x826A0C58;
	sub_82798F30(ctx, base);
	// 826A0C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A0C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A0C60: 480FAA09  bl 0x8279b668
	ctx.lr = 0x826A0C64;
	sub_8279B668(ctx, base);
	// 826A0C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A0C68: 48000008  b 0x826a0c70
	pc = 0x826A0C70; continue 'dispatch;
	// 826A0C6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A0C70: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826A0C74: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826A0C78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0C80: 4BEF6FD1  bl 0x82597c50
	ctx.lr = 0x826A0C84;
	sub_82597C50(ctx, base);
	// 826A0C84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A0C88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0C8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0C90: 4BC1F371  bl 0x822c0000
	ctx.lr = 0x826A0C94;
	sub_822C0000(ctx, base);
	// 826A0C94: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A0C98: 41820024  beq 0x826a0cbc
	if ctx.cr[0].eq {
	pc = 0x826A0CBC; continue 'dispatch;
	}
	// 826A0C9C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826A0CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0CA4: 419A0008  beq cr6, 0x826a0cac
	if ctx.cr[6].eq {
	pc = 0x826A0CAC; continue 'dispatch;
	}
	// 826A0CA8: 4BC1FBE9  bl 0x822c0890
	ctx.lr = 0x826A0CAC;
	sub_822C0890(ctx, base);
	// 826A0CAC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826A0CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0CB4: 419A0008  beq cr6, 0x826a0cbc
	if ctx.cr[6].eq {
	pc = 0x826A0CBC; continue 'dispatch;
	}
	// 826A0CB8: 4BC1FBD9  bl 0x822c0890
	ctx.lr = 0x826A0CBC;
	sub_822C0890(ctx, base);
	// 826A0CBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A0CC0: 419A000C  beq cr6, 0x826a0ccc
	if ctx.cr[6].eq {
	pc = 0x826A0CCC; continue 'dispatch;
	}
	// 826A0CC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A0CC8: 4BC1FBC9  bl 0x822c0890
	ctx.lr = 0x826A0CCC;
	sub_822C0890(ctx, base);
	// 826A0CCC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826A0CD0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826A0CD4: 48B074E0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A0CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A0CD8 size=1492
    let mut pc: u32 = 0x826A0CD8;
    'dispatch: loop {
        match pc {
            0x826A0CD8 => {
    //   block [0x826A0CD8..0x826A12AC)
	// 826A0CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A0CDC: 48B0746D  bl 0x831a8148
	ctx.lr = 0x826A0CE0;
	sub_831A8130(ctx, base);
	// 826A0CE0: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 826A0CE4: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A0CE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A0CEC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826A0CF0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 826A0CF4: 4BE70CE5  bl 0x825119d8
	ctx.lr = 0x826A0CF8;
	sub_825119D8(ctx, base);
	// 826A0CF8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A0CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0D00: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826A0D04: 48752D05  bl 0x82df3a08
	ctx.lr = 0x826A0D08;
	sub_82DF3A08(ctx, base);
	// 826A0D08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A0D0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A0D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0D14: 4BE67A6D  bl 0x82508780
	ctx.lr = 0x826A0D18;
	sub_82508780(ctx, base);
	// 826A0D18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0D1C: 4875270D  bl 0x82df3428
	ctx.lr = 0x826A0D20;
	sub_82DF3428(ctx, base);
	// 826A0D20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A0D24: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826A0D28: 409A0008  bne cr6, 0x826a0d30
	if !ctx.cr[6].eq {
	pc = 0x826A0D30; continue 'dispatch;
	}
	// 826A0D2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A0D30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0D34: 4BE67A6D  bl 0x825087a0
	ctx.lr = 0x826A0D38;
	sub_825087A0(ctx, base);
	// 826A0D38: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A0D3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0D40: 3ACB07B8  addi r22, r11, 0x7b8
	ctx.r[22].s64 = ctx.r[11].s64 + 1976;
	// 826A0D44: 38A0004E  li r5, 0x4e
	ctx.r[5].s64 = 78;
	// 826A0D48: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826A0D4C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 826A0D50: 48751699  bl 0x82df23e8
	ctx.lr = 0x826A0D54;
	sub_82DF23E8(ctx, base);
	// 826A0D54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A0D58: 41820010  beq 0x826a0d68
	if ctx.cr[0].eq {
	pc = 0x826A0D68; continue 'dispatch;
	}
	// 826A0D5C: 4BEE9F3D  bl 0x8258ac98
	ctx.lr = 0x826A0D60;
	sub_8258AC98(ctx, base);
	// 826A0D60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A0D64: 48000008  b 0x826a0d6c
	pc = 0x826A0D6C; continue 'dispatch;
	// 826A0D68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A0D6C: 3A9F00E8  addi r20, r31, 0xe8
	ctx.r[20].s64 = ctx.r[31].s64 + 232;
	// 826A0D70: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826A0D74: 4BD32AB5  bl 0x823d3828
	ctx.lr = 0x826A0D78;
	sub_823D3828(ctx, base);
	// 826A0D78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A0D7C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A0D80: 83DF00E8  lwz r30, 0xe8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826A0D84: 4BE71395  bl 0x82512118
	ctx.lr = 0x826A0D88;
	sub_82512118(ctx, base);
	// 826A0D88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A0D8C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0D90: 487720A1  bl 0x82e12e30
	ctx.lr = 0x826A0D94;
	sub_82E12E30(ctx, base);
	// 826A0D94: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 826A0D98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0D9C: 419A0008  beq cr6, 0x826a0da4
	if ctx.cr[6].eq {
	pc = 0x826A0DA4; continue 'dispatch;
	}
	// 826A0DA0: 4BC1FAF1  bl 0x822c0890
	ctx.lr = 0x826A0DA4;
	sub_822C0890(ctx, base);
	// 826A0DA4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826A0DA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0DAC: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 826A0DB0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 826A0DB4: 48751635  bl 0x82df23e8
	ctx.lr = 0x826A0DB8;
	sub_82DF23E8(ctx, base);
	// 826A0DB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A0DBC: 41820010  beq 0x826a0dcc
	if ctx.cr[0].eq {
	pc = 0x826A0DCC; continue 'dispatch;
	}
	// 826A0DC0: 4BEE9ED9  bl 0x8258ac98
	ctx.lr = 0x826A0DC4;
	sub_8258AC98(ctx, base);
	// 826A0DC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A0DC8: 48000008  b 0x826a0dd0
	pc = 0x826A0DD0; continue 'dispatch;
	// 826A0DCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A0DD0: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 826A0DD4: 4BD32A55  bl 0x823d3828
	ctx.lr = 0x826A0DD8;
	sub_823D3828(ctx, base);
	// 826A0DD8: 3EA08201  lis r21, -0x7dff
	ctx.r[21].s64 = -2113863680;
	// 826A0DDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A0DE0: C1BF0130  lfs f13, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A0DE4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826A0DE8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826A0DEC: C0159450  lfs f0, -0x6bb0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A0DF0: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A0DF4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826A0DF8: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 826A0DFC: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 826A0E00: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 826A0E04: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 826A0E08: 4BEEA061  bl 0x8258ae68
	ctx.lr = 0x826A0E0C;
	sub_8258AE68(ctx, base);
	// 826A0E0C: 809F00F0  lwz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826A0E10: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0E14: 4877201D  bl 0x82e12e30
	ctx.lr = 0x826A0E18;
	sub_82E12E30(ctx, base);
	// 826A0E18: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826A0E1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0E20: 38A00055  li r5, 0x55
	ctx.r[5].s64 = 85;
	// 826A0E24: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 826A0E28: 487515C1  bl 0x82df23e8
	ctx.lr = 0x826A0E2C;
	sub_82DF23E8(ctx, base);
	// 826A0E2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A0E30: 41820010  beq 0x826a0e40
	if ctx.cr[0].eq {
	pc = 0x826A0E40; continue 'dispatch;
	}
	// 826A0E34: 4BEE9E65  bl 0x8258ac98
	ctx.lr = 0x826A0E38;
	sub_8258AC98(ctx, base);
	// 826A0E38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A0E3C: 48000008  b 0x826a0e44
	pc = 0x826A0E44; continue 'dispatch;
	// 826A0E40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A0E44: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 826A0E48: 4BD329E1  bl 0x823d3828
	ctx.lr = 0x826A0E4C;
	sub_823D3828(ctx, base);
	// 826A0E4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A0E50: C1BF0130  lfs f13, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A0E54: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826A0E58: D3E100A0  stfs f31, 0xa0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 826A0E5C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A0E60: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 826A0E64: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 826A0E68: C00B9530  lfs f0, -0x6ad0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A0E6C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826A0E70: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 826A0E74: 4BEE9FF5  bl 0x8258ae68
	ctx.lr = 0x826A0E78;
	sub_8258AE68(ctx, base);
	// 826A0E78: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A0E7C: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0E80: 48771FB1  bl 0x82e12e30
	ctx.lr = 0x826A0E84;
	sub_82E12E30(ctx, base);
	// 826A0E84: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826A0E88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0E8C: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 826A0E90: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 826A0E94: 4BC1F545  bl 0x822c03d8
	ctx.lr = 0x826A0E98;
	sub_822C03D8(ctx, base);
	// 826A0E98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A0E9C: 41820018  beq 0x826a0eb4
	if ctx.cr[0].eq {
	pc = 0x826A0EB4; continue 'dispatch;
	}
	// 826A0EA0: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 826A0EA4: C0359450  lfs f1, -0x6bb0(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A0EA8: 48125511  bl 0x827c63b8
	ctx.lr = 0x826A0EAC;
	sub_827C63B8(ctx, base);
	// 826A0EAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A0EB0: 48000008  b 0x826a0eb8
	pc = 0x826A0EB8; continue 'dispatch;
	// 826A0EB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A0EB8: 387F0128  addi r3, r31, 0x128
	ctx.r[3].s64 = ctx.r[31].s64 + 296;
	// 826A0EBC: 4BFFFACD  bl 0x826a0988
	ctx.lr = 0x826A0EC0;
	sub_826A0988(ctx, base);
	// 826A0EC0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826A0EC4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0EC8: 48789C21  bl 0x82e2aae8
	ctx.lr = 0x826A0ECC;
	sub_82E2AAE8(ctx, base);
	// 826A0ECC: 3BDF0100  addi r30, r31, 0x100
	ctx.r[30].s64 = ctx.r[31].s64 + 256;
	// 826A0ED0: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 826A0ED4: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826A0ED8: 3F60832A  lis r27, -0x7cd6
	ctx.r[27].s64 = -2094399488;
	// 826A0EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0EE0: 809B98C8  lwz r4, -0x6738(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-26424 as u32) ) } as u64;
	// 826A0EE4: 48752B25  bl 0x82df3a08
	ctx.lr = 0x826A0EE8;
	sub_82DF3A08(ctx, base);
	// 826A0EE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0EEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A0EF0: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826A0EF4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A0EF8: 4878DF79  bl 0x82e2ee70
	ctx.lr = 0x826A0EFC;
	sub_82E2EE70(ctx, base);
	// 826A0EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A0F00: 48752529  bl 0x82df3428
	ctx.lr = 0x826A0F04;
	sub_82DF3428(ctx, base);
	// 826A0F04: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826A0F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A0F0C: 419A0094  beq cr6, 0x826a0fa0
	if ctx.cr[6].eq {
	pc = 0x826A0FA0; continue 'dispatch;
	}
	// 826A0F10: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826A0F14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A0F18: 38A00062  li r5, 0x62
	ctx.r[5].s64 = 98;
	// 826A0F1C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A0F20: 487514C9  bl 0x82df23e8
	ctx.lr = 0x826A0F24;
	sub_82DF23E8(ctx, base);
	// 826A0F24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A0F28: 41820014  beq 0x826a0f3c
	if ctx.cr[0].eq {
	pc = 0x826A0F3C; continue 'dispatch;
	}
	// 826A0F2C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826A0F30: 48775961  bl 0x82e16890
	ctx.lr = 0x826A0F34;
	sub_82E16890(ctx, base);
	// 826A0F34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A0F38: 48000008  b 0x826a0f40
	pc = 0x826A0F40; continue 'dispatch;
	// 826A0F3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A0F40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A0F44: 4BCBC42D  bl 0x8235d370
	ctx.lr = 0x826A0F48;
	sub_8235D370(ctx, base);
	// 826A0F48: 817EFFF4  lwz r11, -0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) } as u64;
	// 826A0F4C: 815EFFF0  lwz r10, -0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) } as u64;
	// 826A0F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A0F54: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826A0F58: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826A0F5C: 419A0024  beq cr6, 0x826a0f80
	if ctx.cr[6].eq {
	pc = 0x826A0F80; continue 'dispatch;
	}
	// 826A0F60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A0F64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A0F68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0F6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A0F70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A0F74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A0F78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A0F7C: 4082FFE8  bne 0x826a0f64
	if !ctx.cr[0].eq {
	pc = 0x826A0F64; continue 'dispatch;
	}
	// 826A0F80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A0F84: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0F88: 48774129  bl 0x82e150b0
	ctx.lr = 0x826A0F8C;
	sub_82E150B0(ctx, base);
	// 826A0F8C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A0F90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A0F94: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A0F98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A0F9C: 4BE6FBBD  bl 0x82510b58
	ctx.lr = 0x826A0FA0;
	sub_82510B58(ctx, base);
	// 826A0FA0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826A0FA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A0FA8: 419A0008  beq cr6, 0x826a0fb0
	if ctx.cr[6].eq {
	pc = 0x826A0FB0; continue 'dispatch;
	}
	// 826A0FAC: 4BC1F8E5  bl 0x822c0890
	ctx.lr = 0x826A0FB0;
	sub_822C0890(ctx, base);
	// 826A0FB0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A0FB4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 826A0FB8: 4082FF24  bne 0x826a0edc
	if !ctx.cr[0].eq {
	pc = 0x826A0EDC; continue 'dispatch;
	}
	// 826A0FBC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826A0FC0: 4882BA29  bl 0x82ecc9e8
	ctx.lr = 0x826A0FC4;
	sub_82ECC9E8(ctx, base);
	// 826A0FC4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 826A0FC8: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A0FCC: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 826A0FD0: 996101A0  stb r11, 0x1a0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u8 ) };
	// 826A0FD4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826A0FD8: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 826A0FDC: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 826A0FE0: 487FF751  bl 0x82ea0730
	ctx.lr = 0x826A0FE4;
	sub_82EA0730(ctx, base);
	// 826A0FE4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A0FE8: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 826A0FEC: 396B0810  addi r11, r11, 0x810
	ctx.r[11].s64 = ctx.r[11].s64 + 2064;
	// 826A0FF0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826A0FF4: 3F408332  lis r26, -0x7cce
	ctx.r[26].s64 = -2093875200;
	// 826A0FF8: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 826A0FFC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 826A1000: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A12B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A12B0 size=12
    let mut pc: u32 = 0x826A12B0;
    'dispatch: loop {
        match pc {
            0x826A12B0 => {
    //   block [0x826A12B0..0x826A12BC)
	// 826A12B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A12B4: 996301D5  stb r11, 0x1d5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(469 as u32), ctx.r[11].u8 ) };
	// 826A12B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A12C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A12C0 size=12
    let mut pc: u32 = 0x826A12C0;
    'dispatch: loop {
        match pc {
            0x826A12C0 => {
    //   block [0x826A12C0..0x826A12CC)
	// 826A12C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A12C4: 996301D5  stb r11, 0x1d5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(469 as u32), ctx.r[11].u8 ) };
	// 826A12C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A12D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A12D0 size=136
    let mut pc: u32 = 0x826A12D0;
    'dispatch: loop {
        match pc {
            0x826A12D0 => {
    //   block [0x826A12D0..0x826A1358)
	// 826A12D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A12D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A12D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A12DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A12E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A12E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A12E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A12EC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 826A12F0: 409A0020  bne cr6, 0x826a1310
	if !ctx.cr[6].eq {
	pc = 0x826A1310; continue 'dispatch;
	}
	// 826A12F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A12F8: 419A0048  beq cr6, 0x826a1340
	if ctx.cr[6].eq {
	pc = 0x826A1340; continue 'dispatch;
	}
	// 826A12FC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826A1300: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 826A1304: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 826A1308: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 826A130C: 48000034  b 0x826a1340
	pc = 0x826A1340; continue 'dispatch;
	// 826A1310: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 826A1314: 419A002C  beq cr6, 0x826a1340
	if ctx.cr[6].eq {
	pc = 0x826A1340; continue 'dispatch;
	}
	// 826A1318: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A131C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A1320: 388B9AD0  addi r4, r11, -0x6530
	ctx.r[4].s64 = ctx.r[11].s64 + -25904;
	// 826A1324: 48B06DD5  bl 0x831a80f8
	ctx.lr = 0x826A1328;
	sub_831A80F8(ctx, base);
	// 826A1328: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A132C: 4182000C  beq 0x826a1338
	if ctx.cr[0].eq {
	pc = 0x826A1338; continue 'dispatch;
	}
	// 826A1330: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826A1334: 4800000C  b 0x826a1340
	pc = 0x826A1340; continue 'dispatch;
	// 826A1338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A133C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A1340: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A1344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A1348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A134C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A1350: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A1354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A1358 size=16
    let mut pc: u32 = 0x826A1358;
    'dispatch: loop {
        match pc {
            0x826A1358 => {
    //   block [0x826A1358..0x826A1368)
	// 826A1358: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A135C: 816C0040  lwz r11, 0x40(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(64 as u32) ) } as u64;
	// 826A1360: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A1364: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A1368 size=456
    let mut pc: u32 = 0x826A1368;
    'dispatch: loop {
        match pc {
            0x826A1368 => {
    //   block [0x826A1368..0x826A1530)
	// 826A1368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A136C: 48B06E01  bl 0x831a816c
	ctx.lr = 0x826A1370;
	sub_831A8130(ctx, base);
	// 826A1370: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826A1374: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1378: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A137C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 826A1380: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 826A1384: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A1388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A138C: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A1390: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A1530 size=100
    let mut pc: u32 = 0x826A1530;
    'dispatch: loop {
        match pc {
            0x826A1530 => {
    //   block [0x826A1530..0x826A1594)
	// 826A1530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A1538: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A153C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A1544: C03F01E0  lfs f1, 0x1e0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A1548: 48004491  bl 0x826a59d8
	ctx.lr = 0x826A154C;
	sub_826A59D8(ctx, base);
	// 826A154C: C01F01DC  lfs f0, 0x1dc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A1550: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A1554: EDA00072  fmuls f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826A1558: C19F01E8  lfs f12, 0x1e8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A155C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A1560: 83FF01BC  lwz r31, 0x1bc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A1564: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A1568: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A156C: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 826A1570: 487DB479  bl 0x82e7c9e8
	ctx.lr = 0x826A1574;
	sub_82E7C9E8(ctx, base);
	// 826A1574: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A1578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A157C: 48771CE5  bl 0x82e13260
	ctx.lr = 0x826A1580;
	sub_82E13260(ctx, base);
	// 826A1580: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826A1584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A1588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A158C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A1590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A1598 size=196
    let mut pc: u32 = 0x826A1598;
    'dispatch: loop {
        match pc {
            0x826A1598 => {
    //   block [0x826A1598..0x826A165C)
	// 826A1598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A159C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A15A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A15A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A15A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A15AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A15B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A15B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A15B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A15BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A15C0: 4BC1F379  bl 0x822c0938
	ctx.lr = 0x826A15C4;
	sub_822C0938(ctx, base);
	// 826A15C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A15C8: 41820028  beq 0x826a15f0
	if ctx.cr[0].eq {
	pc = 0x826A15F0; continue 'dispatch;
	}
	// 826A15CC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A15D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A15D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A15D8: 392B0D60  addi r9, r11, 0xd60
	ctx.r[9].s64 = ctx.r[11].s64 + 3424;
	// 826A15DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A15E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A15E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A15E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A15EC: 48000008  b 0x826a15f4
	pc = 0x826A15F4; continue 'dispatch;
	// 826A15F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A15F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A15F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A15FC: 409A0044  bne cr6, 0x826a1640
	if !ctx.cr[6].eq {
	pc = 0x826A1640; continue 'dispatch;
	}
	// 826A1600: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A1604: 419A001C  beq cr6, 0x826a1620
	if ctx.cr[6].eq {
	pc = 0x826A1620; continue 'dispatch;
	}
	// 826A1608: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A160C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A1610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1614: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A1618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A161C: 4E800421  bctrl
	ctx.lr = 0x826A1620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A1620: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A1624: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A1628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A162C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A1630: 816B9A3C  lwz r11, -0x65c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26052 as u32) ) } as u64;
	// 826A1634: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A1638: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A163C: 4BC1E9C5  bl 0x822c0000
	ctx.lr = 0x826A1640;
	sub_822C0000(ctx, base);
	// 826A1640: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A1644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A1648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A164C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A1650: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A1654: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A1658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A1660 size=460
    let mut pc: u32 = 0x826A1660;
    'dispatch: loop {
        match pc {
            0x826A1660 => {
    //   block [0x826A1660..0x826A182C)
	// 826A1660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1664: 48B06B01  bl 0x831a8164
	ctx.lr = 0x826A1668;
	sub_831A8130(ctx, base);
	// 826A1668: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A166C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A1670: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A1674: 396BD3D0  addi r11, r11, -0x2c30
	ctx.r[11].s64 = ctx.r[11].s64 + -11312;
	// 826A1678: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A167C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826A1680: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826A1684: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A1688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A168C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A1690: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A1830 size=532
    let mut pc: u32 = 0x826A1830;
    'dispatch: loop {
        match pc {
            0x826A1830 => {
    //   block [0x826A1830..0x826A1A44)
	// 826A1830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1834: 48B06931  bl 0x831a8164
	ctx.lr = 0x826A1838;
	sub_831A8130(ctx, base);
	// 826A1838: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826A183C: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1840: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A1844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A1848: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 826A184C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826A1850: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A1854: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 826A1858: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A185C: 911F0060  stw r8, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 826A1860: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 826A1864: 807E01BC  lwz r3, 0x1bc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A1868: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A186C: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A1870: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826A1874: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826A1878: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 826A187C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826A1880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A1884: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A1888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A188C: 4E800421  bctrl
	ctx.lr = 0x826A1890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A1890: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A1894: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A1898: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826A189C: 487DA42D  bl 0x82e7bcc8
	ctx.lr = 0x826A18A0;
	sub_82E7BCC8(ctx, base);
	// 826A18A0: 3FA08205  lis r29, -0x7dfb
	ctx.r[29].s64 = -2113601536;
	// 826A18A4: C1BE01D8  lfs f13, 0x1d8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A18A8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826A18AC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A18B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A18B4: C01D0D54  lfs f0, 0xd54(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3412 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A18B8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A18BC: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A18C0: 839E01BC  lwz r28, 0x1bc(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A18C4: 487DA755  bl 0x82e7c018
	ctx.lr = 0x826A18C8;
	sub_82E7C018(ctx, base);
	// 826A18C8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A18CC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826A18D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A18D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A18D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A18DC: 4E800421  bctrl
	ctx.lr = 0x826A18E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A18E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A18E4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A18E8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826A18EC: 4BC23015  bl 0x822c4900
	ctx.lr = 0x826A18F0;
	sub_822C4900(ctx, base);
	// 826A18F0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A18F4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826A18F8: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 826A18FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A1900: 487DA3C9  bl 0x82e7bcc8
	ctx.lr = 0x826A1904;
	sub_82E7BCC8(ctx, base);
	// 826A1904: 897E01D4  lbz r11, 0x1d4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(468 as u32) ) } as u64;
	// 826A1908: C17D0D54  lfs f11, 0xd54(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3412 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826A190C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A1910: 4182001C  beq 0x826a192c
	if ctx.cr[0].eq {
	pc = 0x826A192C; continue 'dispatch;
	}
	// 826A1914: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A1918: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A191C: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 826A1920: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 826A1924: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826A1928: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 826A192C: 38FF0020  addi r7, r31, 0x20
	ctx.r[7].s64 = ctx.r[31].s64 + 32;
	// 826A1930: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 826A1934: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 826A1938: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A193C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A1940: 48006779  bl 0x826a80b8
	ctx.lr = 0x826A1944;
	sub_826A80B8(ctx, base);
	// 826A1944: 3BBF0040  addi r29, r31, 0x40
	ctx.r[29].s64 = ctx.r[31].s64 + 64;
	// 826A1948: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A1A48 size=72
    let mut pc: u32 = 0x826A1A48;
    'dispatch: loop {
        match pc {
            0x826A1A48 => {
    //   block [0x826A1A48..0x826A1A90)
	// 826A1A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A1A50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1A54: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 826A1A58: 419A001C  beq cr6, 0x826a1a74
	if ctx.cr[6].eq {
	pc = 0x826A1A74; continue 'dispatch;
	}
	// 826A1A5C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826A1A60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826A1A64: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 826A1A68: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A1A6C: 4BFFF865  bl 0x826a12d0
	ctx.lr = 0x826A1A70;
	sub_826A12D0(ctx, base);
	// 826A1A70: 48000010  b 0x826a1a80
	pc = 0x826A1A80; continue 'dispatch;
	// 826A1A74: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A1A78: 396B9AD0  addi r11, r11, -0x6530
	ctx.r[11].s64 = ctx.r[11].s64 + -25904;
	// 826A1A7C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A1A80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A1A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A1A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A1A8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A1A90 size=32
    let mut pc: u32 = 0x826A1A90;
    'dispatch: loop {
        match pc {
            0x826A1A90 => {
    //   block [0x826A1A90..0x826A1AB0)
	// 826A1A90: 810301BC  lwz r8, 0x1bc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A1A94: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826A1A98: 394301BC  addi r10, r3, 0x1bc
	ctx.r[10].s64 = ctx.r[3].s64 + 444;
	// 826A1A9C: 392B0018  addi r9, r11, 0x18
	ctx.r[9].s64 = ctx.r[11].s64 + 24;
	// 826A1AA0: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 826A1AA4: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 826A1AA8: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 826A1AAC: 4BC229B4  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A1AB0 size=332
    let mut pc: u32 = 0x826A1AB0;
    'dispatch: loop {
        match pc {
            0x826A1AB0 => {
    //   block [0x826A1AB0..0x826A1BFC)
	// 826A1AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1AB4: 48B066B5  bl 0x831a8168
	ctx.lr = 0x826A1AB8;
	sub_831A8130(ctx, base);
	// 826A1AB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1ABC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826A1AC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A1AC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A1AC8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A1ACC: 41820038  beq 0x826a1b04
	if ctx.cr[0].eq {
	pc = 0x826A1B04; continue 'dispatch;
	}
	// 826A1AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1AD4: 48B07EB5  bl 0x831a9988
	ctx.lr = 0x826A1AD8;
	sub_831A9988(ctx, base);
	// 826A1AD8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A1ADC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A1AE0: 386BCB78  addi r3, r11, -0x3488
	ctx.r[3].s64 = ctx.r[11].s64 + -13448;
	// 826A1AE4: 48B06615  bl 0x831a80f8
	ctx.lr = 0x826A1AE8;
	sub_831A80F8(ctx, base);
	// 826A1AE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A1AEC: 41820018  beq 0x826a1b04
	if ctx.cr[0].eq {
	pc = 0x826A1B04; continue 'dispatch;
	}
	// 826A1AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A1AF4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A1AF8: 4BFFFB69  bl 0x826a1660
	ctx.lr = 0x826A1AFC;
	sub_826A1660(ctx, base);
	// 826A1AFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826A1B00: 480000F4  b 0x826a1bf4
	pc = 0x826A1BF4; continue 'dispatch;
	// 826A1B04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A1B08: 419A00DC  beq cr6, 0x826a1be4
	if ctx.cr[6].eq {
	pc = 0x826A1BE4; continue 'dispatch;
	}
	// 826A1B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1B10: 48B07E79  bl 0x831a9988
	ctx.lr = 0x826A1B14;
	sub_831A9988(ctx, base);
	// 826A1B14: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A1B18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A1B1C: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826A1B20: 48B065D9  bl 0x831a80f8
	ctx.lr = 0x826A1B24;
	sub_831A80F8(ctx, base);
	// 826A1B24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A1B28: 41820014  beq 0x826a1b3c
	if ctx.cr[0].eq {
	pc = 0x826A1B3C; continue 'dispatch;
	}
	// 826A1B2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A1B30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A1B34: 4BFFFF5D  bl 0x826a1a90
	ctx.lr = 0x826A1B38;
	sub_826A1A90(ctx, base);
	// 826A1B38: 4BFFFFC4  b 0x826a1afc
	pc = 0x826A1AFC; continue 'dispatch;
	// 826A1B3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A1B40: 419A00A4  beq cr6, 0x826a1be4
	if ctx.cr[6].eq {
	pc = 0x826A1BE4; continue 'dispatch;
	}
	// 826A1B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1B48: 48B07E41  bl 0x831a9988
	ctx.lr = 0x826A1B4C;
	sub_831A9988(ctx, base);
	// 826A1B4C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A1B50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A1B54: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 826A1B58: 48B065A1  bl 0x831a80f8
	ctx.lr = 0x826A1B5C;
	sub_831A80F8(ctx, base);
	// 826A1B5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A1B60: 41820014  beq 0x826a1b74
	if ctx.cr[0].eq {
	pc = 0x826A1B74; continue 'dispatch;
	}
	// 826A1B64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A1B68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A1B6C: 4BFFF745  bl 0x826a12b0
	ctx.lr = 0x826A1B70;
	sub_826A12B0(ctx, base);
	// 826A1B70: 4BFFFF8C  b 0x826a1afc
	pc = 0x826A1AFC; continue 'dispatch;
	// 826A1B74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A1B78: 419A006C  beq cr6, 0x826a1be4
	if ctx.cr[6].eq {
	pc = 0x826A1BE4; continue 'dispatch;
	}
	// 826A1B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1B80: 48B07E09  bl 0x831a9988
	ctx.lr = 0x826A1B84;
	sub_831A9988(ctx, base);
	// 826A1B84: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A1B88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A1B8C: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 826A1B90: 48B06569  bl 0x831a80f8
	ctx.lr = 0x826A1B94;
	sub_831A80F8(ctx, base);
	// 826A1B94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A1B98: 41820014  beq 0x826a1bac
	if ctx.cr[0].eq {
	pc = 0x826A1BAC; continue 'dispatch;
	}
	// 826A1B9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A1BA0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A1BA4: 4BFFF71D  bl 0x826a12c0
	ctx.lr = 0x826A1BA8;
	sub_826A12C0(ctx, base);
	// 826A1BA8: 4BFFFF54  b 0x826a1afc
	pc = 0x826A1AFC; continue 'dispatch;
	// 826A1BAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A1BB0: 419A0034  beq cr6, 0x826a1be4
	if ctx.cr[6].eq {
	pc = 0x826A1BE4; continue 'dispatch;
	}
	// 826A1BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1BB8: 48B07DD1  bl 0x831a9988
	ctx.lr = 0x826A1BBC;
	sub_831A9988(ctx, base);
	// 826A1BBC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A1BC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A1BC4: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 826A1BC8: 48B06531  bl 0x831a80f8
	ctx.lr = 0x826A1BCC;
	sub_831A80F8(ctx, base);
	// 826A1BCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A1BD0: 41820014  beq 0x826a1be4
	if ctx.cr[0].eq {
	pc = 0x826A1BE4; continue 'dispatch;
	}
	// 826A1BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A1BD8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A1BDC: 4BFFFC55  bl 0x826a1830
	ctx.lr = 0x826A1BE0;
	sub_826A1830(ctx, base);
	// 826A1BE0: 4BFFFF1C  b 0x826a1afc
	pc = 0x826A1AFC; continue 'dispatch;
	// 826A1BE4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826A1BE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A1BEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A1BF0: 48005CD9  bl 0x826a78c8
	ctx.lr = 0x826A1BF4;
	sub_826A78C8(ctx, base);
	// 826A1BF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A1BF8: 48B065C0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A1C00 size=260
    let mut pc: u32 = 0x826A1C00;
    'dispatch: loop {
        match pc {
            0x826A1C00 => {
    //   block [0x826A1C00..0x826A1D04)
	// 826A1C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A1C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A1C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A1C10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1C14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A1C18: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A1C1C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 826A1C20: 807F01A4  lwz r3, 0x1a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A1C24: 4BC4B52D  bl 0x822ed150
	ctx.lr = 0x826A1C28;
	sub_822ED150(ctx, base);
	// 826A1C28: 897F01D5  lbz r11, 0x1d5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(469 as u32) ) } as u64;
	// 826A1C2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A1C30: 418200BC  beq 0x826a1cec
	if ctx.cr[0].eq {
	pc = 0x826A1CEC; continue 'dispatch;
	}
	// 826A1C34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A1C38: 4BD1D3F1  bl 0x823bf028
	ctx.lr = 0x826A1C3C;
	sub_823BF028(ctx, base);
	// 826A1C3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A1C40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826A1C44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A1C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A1C4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A1C50: 419A0024  beq cr6, 0x826a1c74
	if ctx.cr[6].eq {
	pc = 0x826A1C74; continue 'dispatch;
	}
	// 826A1C54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A1C58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A1C5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A1C60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A1C64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A1C68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A1C6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A1C70: 4082FFE8  bne 0x826a1c58
	if !ctx.cr[0].eq {
	pc = 0x826A1C58; continue 'dispatch;
	}
	// 826A1C74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A1C78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A1C7C: 4BE6D84D  bl 0x8250f4c8
	ctx.lr = 0x826A1C80;
	sub_8250F4C8(ctx, base);
	// 826A1C80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A1C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A1C88: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A1C8C: 409A0008  bne cr6, 0x826a1c94
	if !ctx.cr[6].eq {
	pc = 0x826A1C94; continue 'dispatch;
	}
	// 826A1C90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A1C94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A1C98: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826A1C9C: 4BE66D7D  bl 0x82508a18
	ctx.lr = 0x826A1CA0;
	sub_82508A18(ctx, base);
	// 826A1CA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A1CA4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A1CA8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826A1CAC: 388A0D70  addi r4, r10, 0xd70
	ctx.r[4].s64 = ctx.r[10].s64 + 3440;
	// 826A1CB0: 38A00169  li r5, 0x169
	ctx.r[5].s64 = 361;
	// 826A1CB4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826A1CB8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A1CBC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826A1CC0: 487B6D81  bl 0x82e58a40
	ctx.lr = 0x826A1CC4;
	sub_82E58A40(ctx, base);
	// 826A1CC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A1CC8: 4874FFC9  bl 0x82df1c90
	ctx.lr = 0x826A1CCC;
	sub_82DF1C90(ctx, base);
	// 826A1CCC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A1CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1CD4: 419A0008  beq cr6, 0x826a1cdc
	if ctx.cr[6].eq {
	pc = 0x826A1CDC; continue 'dispatch;
	}
	// 826A1CD8: 4BC1EBB9  bl 0x822c0890
	ctx.lr = 0x826A1CDC;
	sub_822C0890(ctx, base);
	// 826A1CDC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A1CE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1CE4: 419A0008  beq cr6, 0x826a1cec
	if ctx.cr[6].eq {
	pc = 0x826A1CEC; continue 'dispatch;
	}
	// 826A1CE8: 4BC1EBA9  bl 0x822c0890
	ctx.lr = 0x826A1CEC;
	sub_822C0890(ctx, base);
	// 826A1CEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A1CF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A1CF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A1CF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A1CFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A1D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A1D08 size=128
    let mut pc: u32 = 0x826A1D08;
    'dispatch: loop {
        match pc {
            0x826A1D08 => {
    //   block [0x826A1D08..0x826A1D88)
	// 826A1D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1D0C: 48B06461  bl 0x831a816c
	ctx.lr = 0x826A1D10;
	sub_831A8130(ctx, base);
	// 826A1D10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1D14: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826A1D18: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826A1D1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A1D20: 3BEB8144  addi r31, r11, -0x7ebc
	ctx.r[31].s64 = ctx.r[11].s64 + -32444;
	// 826A1D24: 816A814C  lwz r11, -0x7eb4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32436 as u32) ) } as u64;
	// 826A1D28: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826A1D2C: 40820024  bne 0x826a1d50
	if !ctx.cr[0].eq {
	pc = 0x826A1D50; continue 'dispatch;
	}
	// 826A1D30: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 826A1D34: 3D00826A  lis r8, -0x7d96
	ctx.r[8].s64 = -2106982400;
	// 826A1D38: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 826A1D3C: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 826A1D40: 39081A48  addi r8, r8, 0x1a48
	ctx.r[8].s64 = ctx.r[8].s64 + 6728;
	// 826A1D44: 916A814C  stw r11, -0x7eb4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32436 as u32), ctx.r[11].u32 ) };
	// 826A1D48: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826A1D4C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826A1D50: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826A1D54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826A1D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1D5C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 826A1D60: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 826A1D64: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A1D68: 4BFB2859  bl 0x826545c0
	ctx.lr = 0x826A1D6C;
	sub_826545C0(ctx, base);
	// 826A1D6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A1D70: 4182000C  beq 0x826a1d7c
	if ctx.cr[0].eq {
	pc = 0x826A1D7C; continue 'dispatch;
	}
	// 826A1D74: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826A1D78: 48000008  b 0x826a1d80
	pc = 0x826A1D80; continue 'dispatch;
	// 826A1D7C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826A1D80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A1D84: 48B06438  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A1D88 size=220
    let mut pc: u32 = 0x826A1D88;
    'dispatch: loop {
        match pc {
            0x826A1D88 => {
    //   block [0x826A1D88..0x826A1E64)
	// 826A1D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A1D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A1D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A1D9C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A1DA0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A1DA4: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A1DA8: 396B0E24  addi r11, r11, 0xe24
	ctx.r[11].s64 = ctx.r[11].s64 + 3620;
	// 826A1DAC: 394A0E10  addi r10, r10, 0xe10
	ctx.r[10].s64 = ctx.r[10].s64 + 3600;
	// 826A1DB0: 39290DC4  addi r9, r9, 0xdc4
	ctx.r[9].s64 = ctx.r[9].s64 + 3524;
	// 826A1DB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A1DB8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A1DBC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A1DC0: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 826A1DC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1DC8: 419A0008  beq cr6, 0x826a1dd0
	if ctx.cr[6].eq {
	pc = 0x826A1DD0; continue 'dispatch;
	}
	// 826A1DCC: 4BC1EAC5  bl 0x822c0890
	ctx.lr = 0x826A1DD0;
	sub_822C0890(ctx, base);
	// 826A1DD0: 807F01C8  lwz r3, 0x1c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 826A1DD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1DD8: 419A0008  beq cr6, 0x826a1de0
	if ctx.cr[6].eq {
	pc = 0x826A1DE0; continue 'dispatch;
	}
	// 826A1DDC: 4BC1EAB5  bl 0x822c0890
	ctx.lr = 0x826A1DE0;
	sub_822C0890(ctx, base);
	// 826A1DE0: 807F01C0  lwz r3, 0x1c0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 826A1DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1DE8: 419A0008  beq cr6, 0x826a1df0
	if ctx.cr[6].eq {
	pc = 0x826A1DF0; continue 'dispatch;
	}
	// 826A1DEC: 4BC1EAA5  bl 0x822c0890
	ctx.lr = 0x826A1DF0;
	sub_822C0890(ctx, base);
	// 826A1DF0: 807F01B8  lwz r3, 0x1b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 826A1DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1DF8: 419A0008  beq cr6, 0x826a1e00
	if ctx.cr[6].eq {
	pc = 0x826A1E00; continue 'dispatch;
	}
	// 826A1DFC: 4BC1EA95  bl 0x822c0890
	ctx.lr = 0x826A1E00;
	sub_822C0890(ctx, base);
	// 826A1E00: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 826A1E04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1E08: 419A0008  beq cr6, 0x826a1e10
	if ctx.cr[6].eq {
	pc = 0x826A1E10; continue 'dispatch;
	}
	// 826A1E0C: 4BC1EA85  bl 0x822c0890
	ctx.lr = 0x826A1E10;
	sub_822C0890(ctx, base);
	// 826A1E10: 807F01A8  lwz r3, 0x1a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 826A1E14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1E18: 419A0008  beq cr6, 0x826a1e20
	if ctx.cr[6].eq {
	pc = 0x826A1E20; continue 'dispatch;
	}
	// 826A1E1C: 4BC1EA75  bl 0x822c0890
	ctx.lr = 0x826A1E20;
	sub_822C0890(ctx, base);
	// 826A1E20: 387F0194  addi r3, r31, 0x194
	ctx.r[3].s64 = ctx.r[31].s64 + 404;
	// 826A1E24: 4BE0F47D  bl 0x824b12a0
	ctx.lr = 0x826A1E28;
	sub_824B12A0(ctx, base);
	// 826A1E28: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826A1E2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1E30: 419A0008  beq cr6, 0x826a1e38
	if ctx.cr[6].eq {
	pc = 0x826A1E38; continue 'dispatch;
	}
	// 826A1E34: 4BC1EA5D  bl 0x822c0890
	ctx.lr = 0x826A1E38;
	sub_822C0890(ctx, base);
	// 826A1E38: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826A1E3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A1E40: 419A0008  beq cr6, 0x826a1e48
	if ctx.cr[6].eq {
	pc = 0x826A1E48; continue 'dispatch;
	}
	// 826A1E44: 4BC1EA4D  bl 0x822c0890
	ctx.lr = 0x826A1E48;
	sub_822C0890(ctx, base);
	// 826A1E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1E4C: 480049BD  bl 0x826a6808
	ctx.lr = 0x826A1E50;
	sub_826A6808(ctx, base);
	// 826A1E50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A1E54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A1E58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A1E5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A1E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A1E68 size=8
    let mut pc: u32 = 0x826A1E68;
    'dispatch: loop {
        match pc {
            0x826A1E68 => {
    //   block [0x826A1E68..0x826A1E70)
	// 826A1E68: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826A1E6C: 4800000C  b 0x826a1e78
	sub_826A1E78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A1E70 size=8
    let mut pc: u32 = 0x826A1E70;
    'dispatch: loop {
        match pc {
            0x826A1E70 => {
    //   block [0x826A1E70..0x826A1E78)
	// 826A1E70: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826A1E74: 48000004  b 0x826a1e78
	sub_826A1E78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A1E78 size=76
    let mut pc: u32 = 0x826A1E78;
    'dispatch: loop {
        match pc {
            0x826A1E78 => {
    //   block [0x826A1E78..0x826A1EC4)
	// 826A1E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A1E80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A1E84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A1E88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1E8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A1E90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A1E94: 4BFFFEF5  bl 0x826a1d88
	ctx.lr = 0x826A1E98;
	sub_826A1D88(ctx, base);
	// 826A1E98: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A1E9C: 4182000C  beq 0x826a1ea8
	if ctx.cr[0].eq {
	pc = 0x826A1EA8; continue 'dispatch;
	}
	// 826A1EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1EA4: 48750535  bl 0x82df23d8
	ctx.lr = 0x826A1EA8;
	sub_82DF23D8(ctx, base);
	// 826A1EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1EAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A1EB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A1EB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A1EB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A1EBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A1EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A1EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A1EC8 size=740
    let mut pc: u32 = 0x826A1EC8;
    'dispatch: loop {
        match pc {
            0x826A1EC8 => {
    //   block [0x826A1EC8..0x826A21AC)
	// 826A1EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A1ECC: 48B062A1  bl 0x831a816c
	ctx.lr = 0x826A1ED0;
	sub_831A8130(ctx, base);
	// 826A1ED0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826A1ED4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826A1ED8: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A1EDC: 3D60826A  lis r11, -0x7d96
	ctx.r[11].s64 = -2106982400;
	// 826A1EE0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A1EE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A1EE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A1EEC: 396B1358  addi r11, r11, 0x1358
	ctx.r[11].s64 = ctx.r[11].s64 + 4952;
	// 826A1EF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826A1EF4: 388AD3FC  addi r4, r10, -0x2c04
	ctx.r[4].s64 = ctx.r[10].s64 + -11268;
	// 826A1EF8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826A1EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A1F00: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826A1F04: 48751B05  bl 0x82df3a08
	ctx.lr = 0x826A1F08;
	sub_82DF3A08(ctx, base);
	// 826A1F08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A1F0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A1F10: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 826A1F14: 48751AF5  bl 0x82df3a08
	ctx.lr = 0x826A1F18;
	sub_82DF3A08(ctx, base);
	// 826A1F18: 397FFF1C  addi r11, r31, -0xe4
	ctx.r[11].s64 = ctx.r[31].s64 + -228;
	// 826A1F1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A1F20: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 826A1F24: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826A1F28: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 826A1F2C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 826A1F30: 4BFFFDD9  bl 0x826a1d08
	ctx.lr = 0x826A1F34;
	sub_826A1D08(ctx, base);
	// 826A1F34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A1F38: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A1F3C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 826A1F40: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826A1F44: 38BF00F4  addi r5, r31, 0xf4
	ctx.r[5].s64 = ctx.r[31].s64 + 244;
	// 826A1F48: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A1F4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A1F50: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 826A1F54: C04A0E9C  lfs f2, 0xe9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3740 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A1F58: C0289524  lfs f1, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A1F5C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A1F60: 4BF012C9  bl 0x825a3228
	ctx.lr = 0x826A1F64;
	sub_825A3228(ctx, base);
	// 826A1F64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A1F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A1F6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A1F70: 4BEFF801  bl 0x825a1770
	ctx.lr = 0x826A1F74;
	sub_825A1770(ctx, base);
	// 826A1F74: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 826A1F78: 487514B1  bl 0x82df3428
	ctx.lr = 0x826A1F7C;
	sub_82DF3428(ctx, base);
	// 826A1F7C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 826A1F80: 4BC26D39  bl 0x822c8cb8
	ctx.lr = 0x826A1F84;
	sub_822C8CB8(ctx, base);
	// 826A1F84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A1F88: 487514A1  bl 0x82df3428
	ctx.lr = 0x826A1F8C;
	sub_82DF3428(ctx, base);
	// 826A1F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A1F90: 48751499  bl 0x82df3428
	ctx.lr = 0x826A1F94;
	sub_82DF3428(ctx, base);
	// 826A1F94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A1F98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A1F9C: 48004D1D  bl 0x826a6cb8
	ctx.lr = 0x826A1FA0;
	sub_826A6CB8(ctx, base);
	// 826A1FA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A1FA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A1FA8: 388B2BF0  addi r4, r11, 0x2bf0
	ctx.r[4].s64 = ctx.r[11].s64 + 11248;
	// 826A1FAC: 48751A5D  bl 0x82df3a08
	ctx.lr = 0x826A1FB0;
	sub_82DF3A08(ctx, base);
	// 826A1FB0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A1FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A1FB8: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 826A1FBC: 48751A4D  bl 0x82df3a08
	ctx.lr = 0x826A1FC0;
	sub_82DF3A08(ctx, base);
	// 826A1FC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A1FC4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826A1FC8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826A1FCC: 38BF00F8  addi r5, r31, 0xf8
	ctx.r[5].s64 = ctx.r[31].s64 + 248;
	// 826A1FD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A1FD4: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A1FD8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826A1FDC: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A1FE0: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A1FE4: C0290790  lfs f1, 0x790(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A1FE8: 4BF0BAD1  bl 0x825adab8
	ctx.lr = 0x826A1FEC;
	sub_825ADAB8(ctx, base);
	// 826A1FEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A1FF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A1FF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A1FF8: 4BEFF659  bl 0x825a1650
	ctx.lr = 0x826A1FFC;
	sub_825A1650(ctx, base);
	// 826A1FFC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826A2000: 48751429  bl 0x82df3428
	ctx.lr = 0x826A2004;
	sub_82DF3428(ctx, base);
	// 826A2004: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826A2008: 4BC26CB1  bl 0x822c8cb8
	ctx.lr = 0x826A200C;
	sub_822C8CB8(ctx, base);
	// 826A200C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2010: 48751419  bl 0x82df3428
	ctx.lr = 0x826A2014;
	sub_82DF3428(ctx, base);
	// 826A2014: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A2018: 48751411  bl 0x82df3428
	ctx.lr = 0x826A201C;
	sub_82DF3428(ctx, base);
	// 826A201C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2020: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A2024: 388BD2B4  addi r4, r11, -0x2d4c
	ctx.r[4].s64 = ctx.r[11].s64 + -11596;
	// 826A2028: 487519E1  bl 0x82df3a08
	ctx.lr = 0x826A202C;
	sub_82DF3A08(ctx, base);
	// 826A202C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2034: 388BA13C  addi r4, r11, -0x5ec4
	ctx.r[4].s64 = ctx.r[11].s64 + -24260;
	// 826A2038: 487519D1  bl 0x82df3a08
	ctx.lr = 0x826A203C;
	sub_82DF3A08(ctx, base);
	// 826A203C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A2040: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A2044: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A2048: 38BF00FC  addi r5, r31, 0xfc
	ctx.r[5].s64 = ctx.r[31].s64 + 252;
	// 826A204C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A2050: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826A2054: C3CA08A4  lfs f30, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A2058: C04B9584  lfs f2, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A205C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A2060: 4BF0BA59  bl 0x825adab8
	ctx.lr = 0x826A2064;
	sub_825ADAB8(ctx, base);
	// 826A2064: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A2068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A206C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A2070: 4BEFF5E1  bl 0x825a1650
	ctx.lr = 0x826A2074;
	sub_825A1650(ctx, base);
	// 826A2074: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 826A2078: 487513B1  bl 0x82df3428
	ctx.lr = 0x826A207C;
	sub_82DF3428(ctx, base);
	// 826A207C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826A2080: 4BC26C39  bl 0x822c8cb8
	ctx.lr = 0x826A2084;
	sub_822C8CB8(ctx, base);
	// 826A2084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2088: 487513A1  bl 0x82df3428
	ctx.lr = 0x826A208C;
	sub_82DF3428(ctx, base);
	// 826A208C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A2090: 48751399  bl 0x82df3428
	ctx.lr = 0x826A2094;
	sub_82DF3428(ctx, base);
	// 826A2094: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2098: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A209C: 388B0E8C  addi r4, r11, 0xe8c
	ctx.r[4].s64 = ctx.r[11].s64 + 3724;
	// 826A20A0: 48751969  bl 0x82df3a08
	ctx.lr = 0x826A20A4;
	sub_82DF3A08(ctx, base);
	// 826A20A4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A20A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A20AC: 388B0E7C  addi r4, r11, 0xe7c
	ctx.r[4].s64 = ctx.r[11].s64 + 3708;
	// 826A20B0: 48751959  bl 0x82df3a08
	ctx.lr = 0x826A20B4;
	sub_82DF3A08(ctx, base);
	// 826A20B4: 38BF0100  addi r5, r31, 0x100
	ctx.r[5].s64 = ctx.r[31].s64 + 256;
	// 826A20B8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A20BC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A20C0: 4BF00F91  bl 0x825a3050
	ctx.lr = 0x826A20C4;
	sub_825A3050(ctx, base);
	// 826A20C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A20C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A20CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A20D0: 4BF000B9  bl 0x825a2188
	ctx.lr = 0x826A20D4;
	sub_825A2188(ctx, base);
	// 826A20D4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826A20D8: 48751351  bl 0x82df3428
	ctx.lr = 0x826A20DC;
	sub_82DF3428(ctx, base);
	// 826A20DC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A20E0: 4BC26BD9  bl 0x822c8cb8
	ctx.lr = 0x826A20E4;
	sub_822C8CB8(ctx, base);
	// 826A20E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A20E8: 48751341  bl 0x82df3428
	ctx.lr = 0x826A20EC;
	sub_82DF3428(ctx, base);
	// 826A20EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A20F0: 48751339  bl 0x82df3428
	ctx.lr = 0x826A20F4;
	sub_82DF3428(ctx, base);
	// 826A20F4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A20F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A20FC: 388B0E74  addi r4, r11, 0xe74
	ctx.r[4].s64 = ctx.r[11].s64 + 3700;
	// 826A2100: 48751909  bl 0x82df3a08
	ctx.lr = 0x826A2104;
	sub_82DF3A08(ctx, base);
	// 826A2104: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A210C: 388B0E68  addi r4, r11, 0xe68
	ctx.r[4].s64 = ctx.r[11].s64 + 3688;
	// 826A2110: 487518F9  bl 0x82df3a08
	ctx.lr = 0x826A2114;
	sub_82DF3A08(ctx, base);
	// 826A2114: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A2118: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826A211C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A2120: 38BF0104  addi r5, r31, 0x104
	ctx.r[5].s64 = ctx.r[31].s64 + 260;
	// 826A2124: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A2128: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 826A212C: C04BD200  lfs f2, -0x2e00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A2130: C02A8E4C  lfs f1, -0x71b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A2134: 4BF0B985  bl 0x825adab8
	ctx.lr = 0x826A2138;
	sub_825ADAB8(ctx, base);
	// 826A2138: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A213C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A2140: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A2144: 4BEFF50D  bl 0x825a1650
	ctx.lr = 0x826A2148;
	sub_825A1650(ctx, base);
	// 826A2148: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 826A214C: 487512DD  bl 0x82df3428
	ctx.lr = 0x826A2150;
	sub_82DF3428(ctx, base);
	// 826A2150: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 826A2154: 4BC26B65  bl 0x822c8cb8
	ctx.lr = 0x826A2158;
	sub_822C8CB8(ctx, base);
	// 826A2158: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A215C: 487512CD  bl 0x82df3428
	ctx.lr = 0x826A2160;
	sub_82DF3428(ctx, base);
	// 826A2160: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A2164: 487512C5  bl 0x82df3428
	ctx.lr = 0x826A2168;
	sub_82DF3428(ctx, base);
	// 826A2168: C01F00F8  lfs f0, 0xf8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A216C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 826A2170: 419A002C  beq cr6, 0x826a219c
	if ctx.cr[6].eq {
	pc = 0x826A219C; continue 'dispatch;
	}
	// 826A2174: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A217C: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 826A2180: 48751889  bl 0x82df3a08
	ctx.lr = 0x826A2184;
	sub_82DF3A08(ctx, base);
	// 826A2184: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A2188: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A218C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A2190: 4BEFF3F9  bl 0x825a1588
	ctx.lr = 0x826A2194;
	sub_825A1588(ctx, base);
	// 826A2194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2198: 48751291  bl 0x82df3428
	ctx.lr = 0x826A219C;
	sub_82DF3428(ctx, base);
	// 826A219C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 826A21A0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826A21A4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826A21A8: 48B06014  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A21B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A21B0 size=224
    let mut pc: u32 = 0x826A21B0;
    'dispatch: loop {
        match pc {
            0x826A21B0 => {
    //   block [0x826A21B0..0x826A2290)
	// 826A21B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A21B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A21B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A21BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A21C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A21C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A21C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A21CC: 48004955  bl 0x826a6b20
	ctx.lr = 0x826A21D0;
	sub_826A6B20(ctx, base);
	// 826A21D0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A21D4: 93DF0180  stw r30, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[30].u32 ) };
	// 826A21D8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A21DC: 396B0E24  addi r11, r11, 0xe24
	ctx.r[11].s64 = ctx.r[11].s64 + 3620;
	// 826A21E0: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A21E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A21E8: 394A0E10  addi r10, r10, 0xe10
	ctx.r[10].s64 = ctx.r[10].s64 + 3600;
	// 826A21EC: 39290DC4  addi r9, r9, 0xdc4
	ctx.r[9].s64 = ctx.r[9].s64 + 3524;
	// 826A21F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A21F4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A21F8: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A21FC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 826A2200: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 826A2204: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A2208: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 826A220C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2210: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 826A2214: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 826A2218: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 826A221C: C1AAE830  lfs f13, -0x17d0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A2220: 917F019C  stw r11, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 826A2224: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A2228: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 826A222C: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 826A2230: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 826A2234: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 826A2238: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 826A223C: 917F01B4  stw r11, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 826A2240: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 826A2244: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 826A2248: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 826A224C: 917F01C4  stw r11, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 826A2250: 917F01C8  stw r11, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 826A2254: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 826A2258: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 826A225C: D1BF01D8  stfs f13, 0x1d8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 826A2260: D01F01DC  stfs f0, 0x1dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 826A2264: 997F01D4  stb r11, 0x1d4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u8 ) };
	// 826A2268: D01F01E0  stfs f0, 0x1e0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 826A226C: 997F01D5  stb r11, 0x1d5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(469 as u32), ctx.r[11].u8 ) };
	// 826A2270: D01F01E8  stfs f0, 0x1e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 826A2274: 997F01E4  stb r11, 0x1e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u8 ) };
	// 826A2278: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A227C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A2280: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A2284: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A2288: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A228C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A2290 size=120
    let mut pc: u32 = 0x826A2290;
    'dispatch: loop {
        match pc {
            0x826A2290 => {
    //   block [0x826A2290..0x826A2308)
	// 826A2290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A2294: 48B05ED9  bl 0x831a816c
	ctx.lr = 0x826A2298;
	sub_831A8130(ctx, base);
	// 826A2298: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A229C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A22A0: 48005381  bl 0x826a7620
	ctx.lr = 0x826A22A4;
	sub_826A7620(ctx, base);
	// 826A22A4: 83FE01A4  lwz r31, 0x1a4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(420 as u32) ) } as u64;
	// 826A22A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A22AC: 419A004C  beq cr6, 0x826a22f8
	if ctx.cr[6].eq {
	pc = 0x826A22F8; continue 'dispatch;
	}
	// 826A22B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A22B4: 4BC42C0D  bl 0x822e4ec0
	ctx.lr = 0x826A22B8;
	sub_822E4EC0(ctx, base);
	// 826A22B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826A22BC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826A22C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826A22C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A22C8: 80AB6750  lwz r5, 0x6750(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 826A22CC: 808A6848  lwz r4, 0x6848(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26696 as u32) ) } as u64;
	// 826A22D0: 4BC554D1  bl 0x822f77a0
	ctx.lr = 0x826A22D4;
	sub_822F77A0(ctx, base);
	// 826A22D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A22D8: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 826A22DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A22E0: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826A22E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A22E8: 4BDE9FA1  bl 0x8248c288
	ctx.lr = 0x826A22EC;
	sub_8248C288(ctx, base);
	// 826A22EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A22F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A22F4: 4BDED0AD  bl 0x8248f3a0
	ctx.lr = 0x826A22F8;
	sub_8248F3A0(ctx, base);
	// 826A22F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A22FC: 4BFFF235  bl 0x826a1530
	ctx.lr = 0x826A2300;
	sub_826A1530(ctx, base);
	// 826A2300: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A2304: 48B05EB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A2308 size=432
    let mut pc: u32 = 0x826A2308;
    'dispatch: loop {
        match pc {
            0x826A2308 => {
    //   block [0x826A2308..0x826A24B8)
	// 826A2308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A230C: 48B05E59  bl 0x831a8164
	ctx.lr = 0x826A2310;
	sub_831A8130(ctx, base);
	// 826A2310: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2314: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2318: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826A231C: 3BCB0D70  addi r30, r11, 0xd70
	ctx.r[30].s64 = ctx.r[11].s64 + 3440;
	// 826A2320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A2324: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826A2328: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A232C: 38A0008F  li r5, 0x8f
	ctx.r[5].s64 = 143;
	// 826A2330: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826A2334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A2338: 386001F0  li r3, 0x1f0
	ctx.r[3].s64 = 496;
	// 826A233C: 487500AD  bl 0x82df23e8
	ctx.lr = 0x826A2340;
	sub_82DF23E8(ctx, base);
	// 826A2340: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A2344: 41820014  beq 0x826a2358
	if ctx.cr[0].eq {
	pc = 0x826A2358; continue 'dispatch;
	}
	// 826A2348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A234C: 4BFFFE65  bl 0x826a21b0
	ctx.lr = 0x826A2350;
	sub_826A21B0(ctx, base);
	// 826A2350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2354: 48000008  b 0x826a235c
	pc = 0x826A235C; continue 'dispatch;
	// 826A2358: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A235C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A2360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A2364: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A2368: 4BFFF231  bl 0x826a1598
	ctx.lr = 0x826A236C;
	sub_826A1598(ctx, base);
	// 826A236C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A2370: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A2374: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A2378: 4BC1DC89  bl 0x822c0000
	ctx.lr = 0x826A237C;
	sub_822C0000(ctx, base);
	// 826A237C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A2380: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2384: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 826A2388: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826A238C: 4BC1E04D  bl 0x822c03d8
	ctx.lr = 0x826A2390;
	sub_822C03D8(ctx, base);
	// 826A2390: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A2394: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A2398: 418200B4  beq 0x826a244c
	if ctx.cr[0].eq {
	pc = 0x826A244C; continue 'dispatch;
	}
	// 826A239C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A23A0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826A23A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826A23A8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826A23AC: 409A0008  bne cr6, 0x826a23b4
	if !ctx.cr[6].eq {
	pc = 0x826A23B4; continue 'dispatch;
	}
	// 826A23B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A23B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A23B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A23BC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826A23C0: 419A0024  beq cr6, 0x826a23e4
	if ctx.cr[6].eq {
	pc = 0x826A23E4; continue 'dispatch;
	}
	// 826A23C4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826A23C8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826A23CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A23D0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826A23D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826A23D8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A23DC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A23E0: 4082FFE8  bne 0x826a23c8
	if !ctx.cr[0].eq {
	pc = 0x826A23C8; continue 'dispatch;
	}
	// 826A23E4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826A23E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A23EC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826A23F0: 419A0024  beq cr6, 0x826a2414
	if ctx.cr[6].eq {
	pc = 0x826A2414; continue 'dispatch;
	}
	// 826A23F4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826A23F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A23FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2400: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A2404: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A2408: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A240C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2410: 4082FFE8  bne 0x826a23f8
	if !ctx.cr[0].eq {
	pc = 0x826A23F8; continue 'dispatch;
	}
	// 826A2414: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A2418: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826A241C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A2420: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826A2424: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A2428: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A242C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A2430: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A2434: 480F6AFD  bl 0x82798f30
	ctx.lr = 0x826A2438;
	sub_82798F30(ctx, base);
	// 826A2438: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A243C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2440: 480F9229  bl 0x8279b668
	ctx.lr = 0x826A2444;
	sub_8279B668(ctx, base);
	// 826A2444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2448: 48000008  b 0x826a2450
	pc = 0x826A2450; continue 'dispatch;
	// 826A244C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A2450: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826A2454: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826A2458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A245C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A2460: 4BEF57F1  bl 0x82597c50
	ctx.lr = 0x826A2464;
	sub_82597C50(ctx, base);
	// 826A2464: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A2468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A246C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A2470: 4BC1DB91  bl 0x822c0000
	ctx.lr = 0x826A2474;
	sub_822C0000(ctx, base);
	// 826A2474: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A2478: 41820024  beq 0x826a249c
	if ctx.cr[0].eq {
	pc = 0x826A249C; continue 'dispatch;
	}
	// 826A247C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826A2480: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2484: 419A0008  beq cr6, 0x826a248c
	if ctx.cr[6].eq {
	pc = 0x826A248C; continue 'dispatch;
	}
	// 826A2488: 4BC1E409  bl 0x822c0890
	ctx.lr = 0x826A248C;
	sub_822C0890(ctx, base);
	// 826A248C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826A2490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2494: 419A0008  beq cr6, 0x826a249c
	if ctx.cr[6].eq {
	pc = 0x826A249C; continue 'dispatch;
	}
	// 826A2498: 4BC1E3F9  bl 0x822c0890
	ctx.lr = 0x826A249C;
	sub_822C0890(ctx, base);
	// 826A249C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A24A0: 419A000C  beq cr6, 0x826a24ac
	if ctx.cr[6].eq {
	pc = 0x826A24AC; continue 'dispatch;
	}
	// 826A24A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A24A8: 4BC1E3E9  bl 0x822c0890
	ctx.lr = 0x826A24AC;
	sub_822C0890(ctx, base);
	// 826A24AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826A24B0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826A24B4: 48B05D00  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A24B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A24B8 size=52
    let mut pc: u32 = 0x826A24B8;
    'dispatch: loop {
        match pc {
            0x826A24B8 => {
    //   block [0x826A24B8..0x826A24EC)
	// 826A24B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A24BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A24C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A24C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A24C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A24CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A24D0: 4BFFFE39  bl 0x826a2308
	ctx.lr = 0x826A24D4;
	sub_826A2308(ctx, base);
	// 826A24D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A24D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A24DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A24E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A24E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A24E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A24F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A24F0 size=52
    let mut pc: u32 = 0x826A24F0;
    'dispatch: loop {
        match pc {
            0x826A24F0 => {
    //   block [0x826A24F0..0x826A2524)
	// 826A24F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A24F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A24F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A24FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2500: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A2504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2508: 4BFFFE01  bl 0x826a2308
	ctx.lr = 0x826A250C;
	sub_826A2308(ctx, base);
	// 826A250C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2510: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A2514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A2518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A251C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A2520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A2528 size=52
    let mut pc: u32 = 0x826A2528;
    'dispatch: loop {
        match pc {
            0x826A2528 => {
    //   block [0x826A2528..0x826A255C)
	// 826A2528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A252C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A2530: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A2534: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2538: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826A253C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2540: 4BFFFDC9  bl 0x826a2308
	ctx.lr = 0x826A2544;
	sub_826A2308(ctx, base);
	// 826A2544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2548: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A254C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A2550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A2554: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A2558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A2560 size=52
    let mut pc: u32 = 0x826A2560;
    'dispatch: loop {
        match pc {
            0x826A2560 => {
    //   block [0x826A2560..0x826A2594)
	// 826A2560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A2564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A2568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A256C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2570: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826A2574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2578: 4BFFFD91  bl 0x826a2308
	ctx.lr = 0x826A257C;
	sub_826A2308(ctx, base);
	// 826A257C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A2584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A2588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A258C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A2590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A2598 size=52
    let mut pc: u32 = 0x826A2598;
    'dispatch: loop {
        match pc {
            0x826A2598 => {
    //   block [0x826A2598..0x826A25CC)
	// 826A2598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A259C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A25A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A25A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A25A8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826A25AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A25B0: 4BFFFD59  bl 0x826a2308
	ctx.lr = 0x826A25B4;
	sub_826A2308(ctx, base);
	// 826A25B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A25B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A25BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A25C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A25C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A25C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A25D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A25D0 size=52
    let mut pc: u32 = 0x826A25D0;
    'dispatch: loop {
        match pc {
            0x826A25D0 => {
    //   block [0x826A25D0..0x826A2604)
	// 826A25D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A25D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A25D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A25DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A25E0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826A25E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A25E8: 4BFFFD21  bl 0x826a2308
	ctx.lr = 0x826A25EC;
	sub_826A2308(ctx, base);
	// 826A25EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A25F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A25F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A25F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A25FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A2600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A2608 size=52
    let mut pc: u32 = 0x826A2608;
    'dispatch: loop {
        match pc {
            0x826A2608 => {
    //   block [0x826A2608..0x826A263C)
	// 826A2608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A260C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A2610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A2614: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2618: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826A261C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2620: 4BFFFCE9  bl 0x826a2308
	ctx.lr = 0x826A2624;
	sub_826A2308(ctx, base);
	// 826A2624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2628: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A262C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A2630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A2634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A2638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A2640 size=52
    let mut pc: u32 = 0x826A2640;
    'dispatch: loop {
        match pc {
            0x826A2640 => {
    //   block [0x826A2640..0x826A2674)
	// 826A2640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A2644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A2648: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A264C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2650: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826A2654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2658: 4BFFFCB1  bl 0x826a2308
	ctx.lr = 0x826A265C;
	sub_826A2308(ctx, base);
	// 826A265C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2660: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A2664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A2668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A266C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A2670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A2678 size=52
    let mut pc: u32 = 0x826A2678;
    'dispatch: loop {
        match pc {
            0x826A2678 => {
    //   block [0x826A2678..0x826A26AC)
	// 826A2678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A267C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A2680: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A2684: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2688: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826A268C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2690: 4BFFFC79  bl 0x826a2308
	ctx.lr = 0x826A2694;
	sub_826A2308(ctx, base);
	// 826A2694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A269C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A26A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A26A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A26A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A26B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A26B0 size=1868
    let mut pc: u32 = 0x826A26B0;
    'dispatch: loop {
        match pc {
            0x826A26B0 => {
    //   block [0x826A26B0..0x826A2DFC)
	// 826A26B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A26B4: 48B05A95  bl 0x831a8148
	ctx.lr = 0x826A26B8;
	sub_831A8130(ctx, base);
	// 826A26B8: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 826A26BC: 48B063BD  bl 0x831a8a78
	ctx.lr = 0x826A26C0;
	sub_831A8A40(ctx, base);
	// 826A26C0: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A26C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826A26C8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826A26CC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A26D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A26D4: 4BE6CDF5  bl 0x8250f4c8
	ctx.lr = 0x826A26D8;
	sub_8250F4C8(ctx, base);
	// 826A26D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A26DC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 826A26E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A26E4: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 826A26E8: 409A0008  bne cr6, 0x826a26f0
	if !ctx.cr[6].eq {
	pc = 0x826A26F0; continue 'dispatch;
	}
	// 826A26EC: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 826A26F0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A26F4: 4874F59D  bl 0x82df1c90
	ctx.lr = 0x826A26F8;
	sub_82DF1C90(ctx, base);
	// 826A26F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A26FC: 419A06F0  beq cr6, 0x826a2dec
	if ctx.cr[6].eq {
	pc = 0x826A2DEC; continue 'dispatch;
	}
	// 826A2700: 817D0184  lwz r11, 0x184(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(388 as u32) ) } as u64;
	// 826A2704: 3A9D0184  addi r20, r29, 0x184
	ctx.r[20].s64 = ctx.r[29].s64 + 388;
	// 826A2708: 3EC08335  lis r22, -0x7ccb
	ctx.r[22].s64 = -2093678592;
	// 826A270C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A2710: 419A0018  beq cr6, 0x826a2728
	if ctx.cr[6].eq {
	pc = 0x826A2728; continue 'dispatch;
	}
	// 826A2714: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A2718: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A271C: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 826A2720: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A2724: 4BE6DACD  bl 0x825101f0
	ctx.lr = 0x826A2728;
	sub_825101F0(ctx, base);
	// 826A2728: 817D018C  lwz r11, 0x18c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(396 as u32) ) } as u64;
	// 826A272C: 3ABD018C  addi r21, r29, 0x18c
	ctx.r[21].s64 = ctx.r[29].s64 + 396;
	// 826A2730: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A2734: 419A0018  beq cr6, 0x826a274c
	if ctx.cr[6].eq {
	pc = 0x826A274C; continue 'dispatch;
	}
	// 826A2738: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A273C: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A2740: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 826A2744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A2748: 4BE6DAA9  bl 0x825101f0
	ctx.lr = 0x826A274C;
	sub_825101F0(ctx, base);
	// 826A274C: 83DD0198  lwz r30, 0x198(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 826A2750: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 826A2754: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A2758: 419A0058  beq cr6, 0x826a27b0
	if ctx.cr[6].eq {
	pc = 0x826A27B0; continue 'dispatch;
	}
	// 826A275C: 3BFD0194  addi r31, r29, 0x194
	ctx.r[31].s64 = ctx.r[29].s64 + 404;
	// 826A2760: 3B9E0008  addi r28, r30, 8
	ctx.r[28].s64 = ctx.r[30].s64 + 8;
	// 826A2764: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A2768: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A276C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A2770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A2774: 4BE6DA7D  bl 0x825101f0
	ctx.lr = 0x826A2778;
	sub_825101F0(ctx, base);
	// 826A2778: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A277C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A2780: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A2784: 4BC22BCD  bl 0x822c5350
	ctx.lr = 0x826A2788;
	sub_822C5350(ctx, base);
	// 826A2788: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A278C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A2790: 3864FFF8  addi r3, r4, -8
	ctx.r[3].s64 = ctx.r[4].s64 + -8;
	// 826A2794: 4812FBB5  bl 0x827d2348
	ctx.lr = 0x826A2798;
	sub_827D2348(ctx, base);
	// 826A2798: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A279C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 826A27A0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826A27A4: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 826A27A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A27AC: 409AFFB8  bne cr6, 0x826a2764
	if !ctx.cr[6].eq {
	pc = 0x826A2764; continue 'dispatch;
	}
	// 826A27B0: 809D01C4  lwz r4, 0x1c4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(452 as u32) ) } as u64;
	// 826A27B4: 3B7D01C4  addi r27, r29, 0x1c4
	ctx.r[27].s64 = ctx.r[29].s64 + 452;
	// 826A27B8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 826A27BC: 419A0024  beq cr6, 0x826a27e0
	if ctx.cr[6].eq {
	pc = 0x826A27E0; continue 'dispatch;
	}
	// 826A27C0: 807D01BC  lwz r3, 0x1bc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A27C4: 48770235  bl 0x82e129f8
	ctx.lr = 0x826A27C8;
	sub_82E129F8(ctx, base);
	// 826A27C8: 92FB0000  stw r23, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 826A27CC: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A27D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A27D4: 92FB0004  stw r23, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 826A27D8: 419A0008  beq cr6, 0x826a27e0
	if ctx.cr[6].eq {
	pc = 0x826A27E0; continue 'dispatch;
	}
	// 826A27DC: 4BC1E0B5  bl 0x822c0890
	ctx.lr = 0x826A27E0;
	sub_822C0890(ctx, base);
	// 826A27E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A27E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A27E8: 4BE6CCE1  bl 0x8250f4c8
	ctx.lr = 0x826A27EC;
	sub_8250F4C8(ctx, base);
	// 826A27EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A27F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A27F4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A27F8: 409A0008  bne cr6, 0x826a2800
	if !ctx.cr[6].eq {
	pc = 0x826A2800; continue 'dispatch;
	}
	// 826A27FC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826A2800: 4BE65D29  bl 0x82508528
	ctx.lr = 0x826A2804;
	sub_82508528(ctx, base);
	// 826A2804: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A2808: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A280C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2810: 487882D9  bl 0x82e2aae8
	ctx.lr = 0x826A2814;
	sub_82E2AAE8(ctx, base);
	// 826A2814: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A2818: 4874F479  bl 0x82df1c90
	ctx.lr = 0x826A281C;
	sub_82DF1C90(ctx, base);
	// 826A281C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A2820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2824: 3BEB9988  addi r31, r11, -0x6678
	ctx.r[31].s64 = ctx.r[11].s64 + -26232;
	// 826A2828: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A282C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A2830: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 826A2834: 487511D5  bl 0x82df3a08
	ctx.lr = 0x826A2838;
	sub_82DF3A08(ctx, base);
	// 826A2838: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A283C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A2840: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A2844: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A2848: 4878C629  bl 0x82e2ee70
	ctx.lr = 0x826A284C;
	sub_82E2EE70(ctx, base);
	// 826A284C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2850: 48750BD9  bl 0x82df3428
	ctx.lr = 0x826A2854;
	sub_82DF3428(ctx, base);
	// 826A2854: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826A2858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A285C: 419A0578  beq cr6, 0x826a2dd4
	if ctx.cr[6].eq {
	pc = 0x826A2DD4; continue 'dispatch;
	}
	// 826A2860: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A2864: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 826A2868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A286C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A2870: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826A2874: 48751195  bl 0x82df3a08
	ctx.lr = 0x826A2878;
	sub_82DF3A08(ctx, base);
	// 826A2878: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A287C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A2880: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A2884: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A2888: 4878C5E9  bl 0x82e2ee70
	ctx.lr = 0x826A288C;
	sub_82E2EE70(ctx, base);
	// 826A288C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2890: 48750B99  bl 0x82df3428
	ctx.lr = 0x826A2894;
	sub_82DF3428(ctx, base);
	// 826A2894: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826A2898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A289C: 419A0528  beq cr6, 0x826a2dc4
	if ctx.cr[6].eq {
	pc = 0x826A2DC4; continue 'dispatch;
	}
	// 826A28A0: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A28A4: 395F0048  addi r10, r31, 0x48
	ctx.r[10].s64 = ctx.r[31].s64 + 72;
	// 826A28A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A28AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A28B0: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826A28B4: 48751155  bl 0x82df3a08
	ctx.lr = 0x826A28B8;
	sub_82DF3A08(ctx, base);
	// 826A28B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A28BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A28C0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A28C4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826A28C8: 4878C5A9  bl 0x82e2ee70
	ctx.lr = 0x826A28CC;
	sub_82E2EE70(ctx, base);
	// 826A28CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A28D0: 48750B59  bl 0x82df3428
	ctx.lr = 0x826A28D4;
	sub_82DF3428(ctx, base);
	// 826A28D4: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 826A28D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A28DC: 419A04D8  beq cr6, 0x826a2db4
	if ctx.cr[6].eq {
	pc = 0x826A2DB4; continue 'dispatch;
	}
	// 826A28E0: 817D0180  lwz r11, 0x180(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A28E4: 395F006C  addi r10, r31, 0x6c
	ctx.r[10].s64 = ctx.r[31].s64 + 108;
	// 826A28E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A28EC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826A28F0: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826A28F4: 48751115  bl 0x82df3a08
	ctx.lr = 0x826A28F8;
	sub_82DF3A08(ctx, base);
	// 826A28F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A28FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A2900: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A2904: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A2908: 4878C569  bl 0x82e2ee70
	ctx.lr = 0x826A290C;
	sub_82E2EE70(ctx, base);
	// 826A290C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2910: 48750B19  bl 0x82df3428
	ctx.lr = 0x826A2914;
	sub_82DF3428(ctx, base);
	// 826A2914: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 826A2918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A291C: 419A0488  beq cr6, 0x826a2da4
	if ctx.cr[6].eq {
	pc = 0x826A2DA4; continue 'dispatch;
	}
	// 826A2920: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A2924: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 826A2928: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A292C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 826A2930: 3B0B0D70  addi r24, r11, 0xd70
	ctx.r[24].s64 = ctx.r[11].s64 + 3440;
	// 826A2934: C3AA08A8  lfs f29, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826A2938: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A293C: EDBFE828  fsubs f13, f31, f29
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[29].f64) as f32) as f64);
	// 826A2940: C0096150  lfs f0, 0x6150(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A2944: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2948: C388D7BC  lfs f28, -0x2844(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 826A294C: 38A001CC  li r5, 0x1cc
	ctx.r[5].s64 = 460;
	// 826A2950: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A2954: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826A2958: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 826A295C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 826A2960: 8321005C  lwz r25, 0x5c(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A2964: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 826A2968: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 826A296C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 826A2970: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826A2974: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826A2978: EC006F3C  fnmsubs f0, f0, f28, f13
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[28].f64 - ctx.f[13].f64) as f32) as f64);
	// 826A297C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 826A2980: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 826A2984: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A2988: 4874FA61  bl 0x82df23e8
	ctx.lr = 0x826A298C;
	sub_82DF23E8(ctx, base);
	// 826A298C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A2990: 41820014  beq 0x826a29a4
	if ctx.cr[0].eq {
	pc = 0x826A29A4; continue 'dispatch;
	}
	// 826A2994: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826A2998: 48773EF9  bl 0x82e16890
	ctx.lr = 0x826A299C;
	sub_82E16890(ctx, base);
	// 826A299C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A29A0: 48000008  b 0x826a29a8
	pc = 0x826A29A8; continue 'dispatch;
	// 826A29A4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A29A8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826A29AC: 4BCBA9C5  bl 0x8235d370
	ctx.lr = 0x826A29B0;
	sub_8235D370(ctx, base);
	// 826A29B0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A29B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A29B8: 38A001CD  li r5, 0x1cd
	ctx.r[5].s64 = 461;
	// 826A29BC: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A29C0: 4874FA29  bl 0x82df23e8
	ctx.lr = 0x826A29C4;
	sub_82DF23E8(ctx, base);
	// 826A29C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A29C8: 41820014  beq 0x826a29dc
	if ctx.cr[0].eq {
	pc = 0x826A29DC; continue 'dispatch;
	}
	// 826A29CC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826A29D0: 48773EC1  bl 0x82e16890
	ctx.lr = 0x826A29D4;
	sub_82E16890(ctx, base);
	// 826A29D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A29D8: 48000008  b 0x826a29e0
	pc = 0x826A29E0; continue 'dispatch;
	// 826A29DC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A29E0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 826A29E4: 4BCBA98D  bl 0x8235d370
	ctx.lr = 0x826A29E8;
	sub_8235D370(ctx, base);
	// 826A29E8: 92E1007C  stw r23, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	// 826A29EC: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 826A29F0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826A29F4: 419A0058  beq cr6, 0x826a2a4c
	if ctx.cr[6].eq {
	pc = 0x826A2A4C; continue 'dispatch;
	}
	// 826A29F8: 3B9D0194  addi r28, r29, 0x194
	ctx.r[28].s64 = ctx.r[29].s64 + 404;
	// 826A29FC: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 826A2A00: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2A04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2A08: 38A001D1  li r5, 0x1d1
	ctx.r[5].s64 = 465;
	// 826A2A0C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A2A10: 4874F9D9  bl 0x82df23e8
	ctx.lr = 0x826A2A14;
	sub_82DF23E8(ctx, base);
	// 826A2A14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A2A18: 41820014  beq 0x826a2a2c
	if ctx.cr[0].eq {
	pc = 0x826A2A2C; continue 'dispatch;
	}
	// 826A2A1C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826A2A20: 48773E71  bl 0x82e16890
	ctx.lr = 0x826A2A24;
	sub_82E16890(ctx, base);
	// 826A2A24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2A28: 48000008  b 0x826a2a30
	pc = 0x826A2A30; continue 'dispatch;
	// 826A2A2C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A2A30: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A2A34: 4BCBA93D  bl 0x8235d370
	ctx.lr = 0x826A2A38;
	sub_8235D370(ctx, base);
	// 826A2A38: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826A2A3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A2A40: 485106C9  bl 0x82bb3108
	ctx.lr = 0x826A2A44;
	sub_82BB3108(ctx, base);
	// 826A2A44: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826A2A48: 4082FFB8  bne 0x826a2a00
	if !ctx.cr[0].eq {
	pc = 0x826A2A00; continue 'dispatch;
	}
	// 826A2A4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A2A50: 419A0054  beq cr6, 0x826a2aa4
	if ctx.cr[6].eq {
	pc = 0x826A2AA4; continue 'dispatch;
	}
	// 826A2A54: 3BDD0194  addi r30, r29, 0x194
	ctx.r[30].s64 = ctx.r[29].s64 + 404;
	// 826A2A58: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2A5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2A60: 38A001D6  li r5, 0x1d6
	ctx.r[5].s64 = 470;
	// 826A2A64: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826A2A68: 4874F981  bl 0x82df23e8
	ctx.lr = 0x826A2A6C;
	sub_82DF23E8(ctx, base);
	// 826A2A6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A2A70: 41820014  beq 0x826a2a84
	if ctx.cr[0].eq {
	pc = 0x826A2A84; continue 'dispatch;
	}
	// 826A2A74: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826A2A78: 48773E19  bl 0x82e16890
	ctx.lr = 0x826A2A7C;
	sub_82E16890(ctx, base);
	// 826A2A7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2A80: 48000008  b 0x826a2a88
	pc = 0x826A2A88; continue 'dispatch;
	// 826A2A84: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A2A88: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A2A8C: 4BCBA8E5  bl 0x8235d370
	ctx.lr = 0x826A2A90;
	sub_8235D370(ctx, base);
	// 826A2A90: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826A2A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A2A98: 48510671  bl 0x82bb3108
	ctx.lr = 0x826A2A9C;
	sub_82BB3108(ctx, base);
	// 826A2A9C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A2AA0: 4082FFB8  bne 0x826a2a58
	if !ctx.cr[0].eq {
	pc = 0x826A2A58; continue 'dispatch;
	}
	// 826A2AA4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2AA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2AAC: 38A001DB  li r5, 0x1db
	ctx.r[5].s64 = 475;
	// 826A2AB0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A2AB4: 4874F935  bl 0x82df23e8
	ctx.lr = 0x826A2AB8;
	sub_82DF23E8(ctx, base);
	// 826A2AB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A2ABC: 41820018  beq 0x826a2ad4
	if ctx.cr[0].eq {
	pc = 0x826A2AD4; continue 'dispatch;
	}
	// 826A2AC0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A2AC4: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A2AC8: 48770629  bl 0x82e130f0
	ctx.lr = 0x826A2ACC;
	sub_82E130F0(ctx, base);
	// 826A2ACC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2AD0: 48000008  b 0x826a2ad8
	pc = 0x826A2AD8; continue 'dispatch;
	// 826A2AD4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A2AD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826A2ADC: 4BC3F275  bl 0x822e1d50
	ctx.lr = 0x826A2AE0;
	sub_822E1D50(ctx, base);
	// 826A2AE0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2AE4: 807D01BC  lwz r3, 0x1bc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A2AE8: 48770349  bl 0x82e12e30
	ctx.lr = 0x826A2AEC;
	sub_82E12E30(ctx, base);
	// 826A2AEC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A2AF0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2AF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A2AF8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 826A2AFC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826A2B00: 419A0024  beq cr6, 0x826a2b24
	if ctx.cr[6].eq {
	pc = 0x826A2B24; continue 'dispatch;
	}
	// 826A2B04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A2B08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A2B0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2B10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A2B14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A2B18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A2B1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2B20: 4082FFE8  bne 0x826a2b08
	if !ctx.cr[0].eq {
	pc = 0x826A2B08; continue 'dispatch;
	}
	// 826A2B24: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826A2B28: 80750000  lwz r3, 0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2B2C: 48772585  bl 0x82e150b0
	ctx.lr = 0x826A2B30;
	sub_82E150B0(ctx, base);
	// 826A2B30: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A2B34: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A2B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A2B3C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 826A2B40: C3EA0D54  lfs f31, 0xd54(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3412 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A2B44: 835B0000  lwz r26, 0(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2B48: 419A0024  beq cr6, 0x826a2b6c
	if ctx.cr[6].eq {
	pc = 0x826A2B6C; continue 'dispatch;
	}
	// 826A2B4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A2B50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A2B54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2B58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A2B5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A2B60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A2B64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2B68: 4082FFE8  bne 0x826a2b50
	if !ctx.cr[0].eq {
	pc = 0x826A2B50; continue 'dispatch;
	}
	// 826A2B6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A2B70: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 826A2B74: 3B7D0194  addi r27, r29, 0x194
	ctx.r[27].s64 = ctx.r[29].s64 + 404;
	// 826A2B78: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 826A2B7C: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 826A2B80: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 826A2B84: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A2B88: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A2B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A2B90: 419A00F0  beq cr6, 0x826a2c80
	if ctx.cr[6].eq {
	pc = 0x826A2C80; continue 'dispatch;
	}
	// 826A2B94: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A2B98: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826A2B9C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 826A2BA0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A2BA4: 409800DC  bge cr6, 0x826a2c80
	if !ctx.cr[6].lt {
	pc = 0x826A2C80; continue 'dispatch;
	}
	// 826A2BA8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2BAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2BB0: 38A001E3  li r5, 0x1e3
	ctx.r[5].s64 = 483;
	// 826A2BB4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A2BB8: 4874F831  bl 0x82df23e8
	ctx.lr = 0x826A2BBC;
	sub_82DF23E8(ctx, base);
	// 826A2BBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A2BC0: 4182002C  beq 0x826a2bec
	if ctx.cr[0].eq {
	pc = 0x826A2BEC; continue 'dispatch;
	}
	// 826A2BC4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A2BC8: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A2BCC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A2BD0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A2BD4: 487D9445  bl 0x82e7c018
	ctx.lr = 0x826A2BD8;
	sub_82E7C018(ctx, base);
	// 826A2BD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2BE0: 48770511  bl 0x82e130f0
	ctx.lr = 0x826A2BE4;
	sub_82E130F0(ctx, base);
	// 826A2BE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2BE8: 48000008  b 0x826a2bf0
	pc = 0x826A2BF0; continue 'dispatch;
	// 826A2BEC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A2BF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2BF4: 4BC3F15D  bl 0x822e1d50
	ctx.lr = 0x826A2BF8;
	sub_822E1D50(ctx, base);
	// 826A2BF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826A2BFC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A2C00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A2C04: 4877022D  bl 0x82e12e30
	ctx.lr = 0x826A2C08;
	sub_82E12E30(ctx, base);
	// 826A2C08: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A2C0C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826A2C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A2C14: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826A2C18: 419A0024  beq cr6, 0x826a2c3c
	if ctx.cr[6].eq {
	pc = 0x826A2C3C; continue 'dispatch;
	}
	// 826A2C1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A2C20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A2C24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2C28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A2C2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A2C30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A2C34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2C38: 4082FFE8  bne 0x826a2c20
	if !ctx.cr[0].eq {
	pc = 0x826A2C20; continue 'dispatch;
	}
	// 826A2C3C: 817D0198  lwz r11, 0x198(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 826A2C40: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A2C44: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826A2C48: 48772469  bl 0x82e150b0
	ctx.lr = 0x826A2C4C;
	sub_82E150B0(ctx, base);
	// 826A2C4C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 826A2C50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A2C54: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 826A2C58: 4BC21809  bl 0x822c4460
	ctx.lr = 0x826A2C5C;
	sub_822C4460(ctx, base);
	// 826A2C5C: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 826A2C60: 4098000C  bge cr6, 0x826a2c6c
	if !ctx.cr[6].lt {
	pc = 0x826A2C6C; continue 'dispatch;
	}
	// 826A2C64: FFE0E090  fmr f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[28].f64;
	// 826A2C68: 48000008  b 0x826a2c70
	pc = 0x826A2C70; continue 'dispatch;
	// 826A2C6C: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 826A2C70: 83410070  lwz r26, 0x70(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826A2C74: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 826A2C78: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 826A2C7C: 4BFFFF0C  b 0x826a2b88
	pc = 0x826A2B88; continue 'dispatch;
	// 826A2C80: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2C84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2C88: 38A001F0  li r5, 0x1f0
	ctx.r[5].s64 = 496;
	// 826A2C8C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A2C90: 4874F759  bl 0x82df23e8
	ctx.lr = 0x826A2C94;
	sub_82DF23E8(ctx, base);
	// 826A2C94: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A2C98: 4182002C  beq 0x826a2cc4
	if ctx.cr[0].eq {
	pc = 0x826A2CC4; continue 'dispatch;
	}
	// 826A2C9C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A2CA0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A2CA4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A2CA8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A2CAC: 487D936D  bl 0x82e7c018
	ctx.lr = 0x826A2CB0;
	sub_82E7C018(ctx, base);
	// 826A2CB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2CB8: 48770439  bl 0x82e130f0
	ctx.lr = 0x826A2CBC;
	sub_82E130F0(ctx, base);
	// 826A2CBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2CC0: 48000008  b 0x826a2cc8
	pc = 0x826A2CC8; continue 'dispatch;
	// 826A2CC4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A2CC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A2CCC: 4BC3F085  bl 0x822e1d50
	ctx.lr = 0x826A2CD0;
	sub_822E1D50(ctx, base);
	// 826A2CD0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826A2CD4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A2CD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A2CDC: 48770155  bl 0x82e12e30
	ctx.lr = 0x826A2CE0;
	sub_82E12E30(ctx, base);
	// 826A2CE0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A2CE4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826A2CE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826A2CEC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 826A2CF0: 419A0024  beq cr6, 0x826a2d14
	if ctx.cr[6].eq {
	pc = 0x826A2D14; continue 'dispatch;
	}
	// 826A2CF4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826A2CF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A2CFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2D00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A2D04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A2D08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A2D0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A2D10: 4082FFE8  bne 0x826a2cf8
	if !ctx.cr[0].eq {
	pc = 0x826A2CF8; continue 'dispatch;
	}
	// 826A2D14: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A2D18: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2D1C: 48772395  bl 0x82e150b0
	ctx.lr = 0x826A2D20;
	sub_82E150B0(ctx, base);
	// 826A2D20: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A2D24: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 826A2D28: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A2D2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A2D30: 4BE6DE29  bl 0x82510b58
	ctx.lr = 0x826A2D34;
	sub_82510B58(ctx, base);
	// 826A2D34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A2D38: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 826A2D3C: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A2D40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A2D44: 4BE6DE15  bl 0x82510b58
	ctx.lr = 0x826A2D48;
	sub_82510B58(ctx, base);
	// 826A2D48: 83FD0198  lwz r31, 0x198(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 826A2D4C: 4800001C  b 0x826a2d68
	pc = 0x826A2D68; continue 'dispatch;
	// 826A2D50: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A2D54: 80967058  lwz r4, 0x7058(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826A2D58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A2D5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A2D60: 4BE6DDF9  bl 0x82510b58
	ctx.lr = 0x826A2D64;
	sub_82510B58(ctx, base);
	// 826A2D64: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826A2D68: 817D019C  lwz r11, 0x19c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(412 as u32) ) } as u64;
	// 826A2D6C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A2D70: 409AFFE0  bne cr6, 0x826a2d50
	if !ctx.cr[6].eq {
	pc = 0x826A2D50; continue 'dispatch;
	}
	// 826A2D74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826A2D78: 419A000C  beq cr6, 0x826a2d84
	if ctx.cr[6].eq {
	pc = 0x826A2D84; continue 'dispatch;
	}
	// 826A2D7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A2D80: 4BC1DB11  bl 0x822c0890
	ctx.lr = 0x826A2D84;
	sub_822C0890(ctx, base);
	// 826A2D84: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826A2D88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2D8C: 419A0008  beq cr6, 0x826a2d94
	if ctx.cr[6].eq {
	pc = 0x826A2D94; continue 'dispatch;
	}
	// 826A2D90: 4BC1DB01  bl 0x822c0890
	ctx.lr = 0x826A2D94;
	sub_822C0890(ctx, base);
	// 826A2D94: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826A2D98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2D9C: 419A0008  beq cr6, 0x826a2da4
	if ctx.cr[6].eq {
	pc = 0x826A2DA4; continue 'dispatch;
	}
	// 826A2DA0: 4BC1DAF1  bl 0x822c0890
	ctx.lr = 0x826A2DA4;
	sub_822C0890(ctx, base);
	// 826A2DA4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826A2DA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2DAC: 419A0008  beq cr6, 0x826a2db4
	if ctx.cr[6].eq {
	pc = 0x826A2DB4; continue 'dispatch;
	}
	// 826A2DB0: 4BC1DAE1  bl 0x822c0890
	ctx.lr = 0x826A2DB4;
	sub_822C0890(ctx, base);
	// 826A2DB4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826A2DB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2DBC: 419A0008  beq cr6, 0x826a2dc4
	if ctx.cr[6].eq {
	pc = 0x826A2DC4; continue 'dispatch;
	}
	// 826A2DC0: 4BC1DAD1  bl 0x822c0890
	ctx.lr = 0x826A2DC4;
	sub_822C0890(ctx, base);
	// 826A2DC4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826A2DC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2DCC: 419A0008  beq cr6, 0x826a2dd4
	if ctx.cr[6].eq {
	pc = 0x826A2DD4; continue 'dispatch;
	}
	// 826A2DD0: 4BC1DAC1  bl 0x822c0890
	ctx.lr = 0x826A2DD4;
	sub_822C0890(ctx, base);
	// 826A2DD4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826A2DD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A2DDC: 419A0008  beq cr6, 0x826a2de4
	if ctx.cr[6].eq {
	pc = 0x826A2DE4; continue 'dispatch;
	}
	// 826A2DE0: 4BC1DAB1  bl 0x822c0890
	ctx.lr = 0x826A2DE4;
	sub_822C0890(ctx, base);
	// 826A2DE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A2DE8: 48787D19  bl 0x82e2ab00
	ctx.lr = 0x826A2DEC;
	sub_82E2AB00(ctx, base);
	// 826A2DEC: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 826A2DF0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 826A2DF4: 48B05CD1  bl 0x831a8ac4
	ctx.lr = 0x826A2DF8;
	sub_831A8A8C(ctx, base);
	// 826A2DF8: 48B053A0  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826A2E00 size=8
    let mut pc: u32 = 0x826A2E00;
    'dispatch: loop {
        match pc {
            0x826A2E00 => {
    //   block [0x826A2E00..0x826A2E08)
	// 826A2E00: C02301D8  lfs f1, 0x1d8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(472 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A2E04: 4BFFF8AC  b 0x826a26b0
	sub_826A26B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A2E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A2E08 size=2200
    let mut pc: u32 = 0x826A2E08;
    'dispatch: loop {
        match pc {
            0x826A2E08 => {
    //   block [0x826A2E08..0x826A36A0)
	// 826A2E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A2E0C: 48B05329  bl 0x831a8134
	ctx.lr = 0x826A2E10;
	sub_831A8130(ctx, base);
	// 826A2E10: DBE1FF68  stfd f31, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 826A2E14: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A2E18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A2E1C: 48004BC5  bl 0x826a79e0
	ctx.lr = 0x826A2E20;
	sub_826A79E0(ctx, base);
	// 826A2E20: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2E24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2E28: 3B0B0D70  addi r24, r11, 0xd70
	ctx.r[24].s64 = ctx.r[11].s64 + 3440;
	// 826A2E2C: 38A000D8  li r5, 0xd8
	ctx.r[5].s64 = 216;
	// 826A2E30: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2E34: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A2E38: 4874F5B1  bl 0x82df23e8
	ctx.lr = 0x826A2E3C;
	sub_82DF23E8(ctx, base);
	// 826A2E3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A2E40: 41820018  beq 0x826a2e58
	if ctx.cr[0].eq {
	pc = 0x826A2E58; continue 'dispatch;
	}
	// 826A2E44: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A2E48: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A2E4C: 487702A5  bl 0x82e130f0
	ctx.lr = 0x826A2E50;
	sub_82E130F0(ctx, base);
	// 826A2E50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2E54: 48000008  b 0x826a2e5c
	pc = 0x826A2E5C; continue 'dispatch;
	// 826A2E58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A2E5C: 3A5F01BC  addi r18, r31, 0x1bc
	ctx.r[18].s64 = ctx.r[31].s64 + 444;
	// 826A2E60: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 826A2E64: 4BC3EEED  bl 0x822e1d50
	ctx.lr = 0x826A2E68;
	sub_822E1D50(ctx, base);
	// 826A2E68: 809F01BC  lwz r4, 0x1bc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 826A2E6C: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A2E70: 4876FFC1  bl 0x82e12e30
	ctx.lr = 0x826A2E74;
	sub_82E12E30(ctx, base);
	// 826A2E74: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A2E78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A2E7C: 38A000DC  li r5, 0xdc
	ctx.r[5].s64 = 220;
	// 826A2E80: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A2E84: 4874F565  bl 0x82df23e8
	ctx.lr = 0x826A2E88;
	sub_82DF23E8(ctx, base);
	// 826A2E88: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A2E8C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A2E90: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826A2E94: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A2E98: 3B6B0D54  addi r27, r11, 0xd54
	ctx.r[27].s64 = ctx.r[11].s64 + 3412;
	// 826A2E9C: 41820034  beq 0x826a2ed0
	if ctx.cr[0].eq {
	pc = 0x826A2ED0; continue 'dispatch;
	}
	// 826A2EA0: C1BF01D8  lfs f13, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A2EA4: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 826A2EA8: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A2EAC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A2EB0: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A2EB4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A2EB8: 487D9161  bl 0x82e7c018
	ctx.lr = 0x826A2EBC;
	sub_82E7C018(ctx, base);
	// 826A2EBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A2EC4: 4877022D  bl 0x82e130f0
	ctx.lr = 0x826A2EC8;
	sub_82E130F0(ctx, base);
	// 826A2EC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A2ECC: 48000008  b 0x826a2ed4
	pc = 0x826A2ED4; continue 'dispatch;
	// 826A2ED0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A2ED4: 3B3F01CC  addi r25, r31, 0x1cc
	ctx.r[25].s64 = ctx.r[31].s64 + 460;
	// 826A2ED8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826A2EDC: 4BC3EE75  bl 0x822e1d50
	ctx.lr = 0x826A2EE0;
	sub_822E1D50(ctx, base);
	// 826A2EE0: 809F01CC  lwz r4, 0x1cc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 826A2EE4: 80720000  lwz r3, 0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2EE8: 4876FF49  bl 0x82e12e30
	ctx.lr = 0x826A2EEC;
	sub_82E12E30(ctx, base);
	// 826A2EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A2EF0: C03F01D8  lfs f1, 0x1d8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A2EF4: 4BFFF7BD  bl 0x826a26b0
	ctx.lr = 0x826A2EF8;
	sub_826A26B0(ctx, base);
	// 826A2EF8: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826A2EFC: 48829AED  bl 0x82ecc9e8
	ctx.lr = 0x826A2F00;
	sub_82ECC9E8(ctx, base);
	// 826A2F00: 3AA00006  li r21, 6
	ctx.r[21].s64 = 6;
	// 826A2F04: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A2F08: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 826A2F0C: 9AA101C0  stb r21, 0x1c0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[21].u8 ) };
	// 826A2F10: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826A2F14: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826A2F18: 7C7DF02E  lwzx r3, r29, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826A2F1C: 487FD815  bl 0x82ea0730
	ctx.lr = 0x826A2F20;
	sub_82EA0730(ctx, base);
	// 826A2F20: 3F408332  lis r26, -0x7cce
	ctx.r[26].s64 = -2093875200;
	// 826A2F24: 3AC00060  li r22, 0x60
	ctx.r[22].s64 = 96;
	// 826A2F28: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A2F2C: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 826A2F30: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826A2F34: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 826A2F38: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826A2F3C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 826A2F40: C1BF01D8  lfs f13, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A2F44: C05AF614  lfs f2, -0x9ec(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A2F48: 3A8B2770  addi r20, r11, 0x2770
	ctx.r[20].s64 = ctx.r[11].s64 + 10096;
	// 826A2F4C: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 826A2F50: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A2F54: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826A2F58: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 826A2F5C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826A2F60: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 826A2F64: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826A2F68: 13E0A0C7  vcmpequd (lvx128) v31, v0, v20
	tmp.u32 = ctx.r[20].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A2F6C: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A36A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A36A0 size=92
    let mut pc: u32 = 0x826A36A0;
    'dispatch: loop {
        match pc {
            0x826A36A0 => {
    //   block [0x826A36A0..0x826A36FC)
	// 826A36A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A36A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A36A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A36AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A36B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A36B4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A36B8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A36BC: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A36C0: 396B0F14  addi r11, r11, 0xf14
	ctx.r[11].s64 = ctx.r[11].s64 + 3860;
	// 826A36C4: 394A0F00  addi r10, r10, 0xf00
	ctx.r[10].s64 = ctx.r[10].s64 + 3840;
	// 826A36C8: 39290EB4  addi r9, r9, 0xeb4
	ctx.r[9].s64 = ctx.r[9].s64 + 3764;
	// 826A36CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A36D0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A36D4: 387F0184  addi r3, r31, 0x184
	ctx.r[3].s64 = ctx.r[31].s64 + 388;
	// 826A36D8: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A36DC: 487BA16D  bl 0x82e5d848
	ctx.lr = 0x826A36E0;
	sub_82E5D848(ctx, base);
	// 826A36E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A36E4: 48003125  bl 0x826a6808
	ctx.lr = 0x826A36E8;
	sub_826A6808(ctx, base);
	// 826A36E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A36EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A36F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A36F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A36F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A3700 size=68
    let mut pc: u32 = 0x826A3700;
    'dispatch: loop {
        match pc {
            0x826A3700 => {
    //   block [0x826A3700..0x826A3744)
	// 826A3700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A3708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A370C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A3710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A3718: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A371C: 48003F05  bl 0x826a7620
	ctx.lr = 0x826A3720;
	sub_826A7620(ctx, base);
	// 826A3720: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A3724: 387F0184  addi r3, r31, 0x184
	ctx.r[3].s64 = ctx.r[31].s64 + 388;
	// 826A3728: 487B9751  bl 0x82e5ce78
	ctx.lr = 0x826A372C;
	sub_82E5CE78(ctx, base);
	// 826A372C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A3730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A3734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A3738: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A373C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A3740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A3748 size=444
    let mut pc: u32 = 0x826A3748;
    'dispatch: loop {
        match pc {
            0x826A3748 => {
    //   block [0x826A3748..0x826A3904)
	// 826A3748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A374C: 48B04A11  bl 0x831a815c
	ctx.lr = 0x826A3750;
	sub_831A8130(ctx, base);
	// 826A3750: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3754: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 826A3758: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A375C: 4800173D  bl 0x826a4e98
	ctx.lr = 0x826A3760;
	sub_826A4E98(ctx, base);
	// 826A3760: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3768: 3BCB0F8C  addi r30, r11, 0xf8c
	ctx.r[30].s64 = ctx.r[11].s64 + 3980;
	// 826A376C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A3770: 48750299  bl 0x82df3a08
	ctx.lr = 0x826A3774;
	sub_82DF3A08(ctx, base);
	// 826A3774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3778: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A377C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A3780: 4BEFDE09  bl 0x825a1588
	ctx.lr = 0x826A3784;
	sub_825A1588(ctx, base);
	// 826A3784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3788: 4874FCA1  bl 0x82df3428
	ctx.lr = 0x826A378C;
	sub_82DF3428(ctx, base);
	// 826A378C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A3790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3794: 3BAB5D5C  addi r29, r11, 0x5d5c
	ctx.r[29].s64 = ctx.r[11].s64 + 23900;
	// 826A3798: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A379C: 4875026D  bl 0x82df3a08
	ctx.lr = 0x826A37A0;
	sub_82DF3A08(ctx, base);
	// 826A37A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A37A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A37A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A37AC: 4BEFDDDD  bl 0x825a1588
	ctx.lr = 0x826A37B0;
	sub_825A1588(ctx, base);
	// 826A37B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A37B4: 4874FC75  bl 0x82df3428
	ctx.lr = 0x826A37B8;
	sub_82DF3428(ctx, base);
	// 826A37B8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A37BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A37C0: 3B8B0F78  addi r28, r11, 0xf78
	ctx.r[28].s64 = ctx.r[11].s64 + 3960;
	// 826A37C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A37C8: 48750241  bl 0x82df3a08
	ctx.lr = 0x826A37CC;
	sub_82DF3A08(ctx, base);
	// 826A37CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A37D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A37D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A37D8: 4BEFDDB1  bl 0x825a1588
	ctx.lr = 0x826A37DC;
	sub_825A1588(ctx, base);
	// 826A37DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A37E0: 4874FC49  bl 0x82df3428
	ctx.lr = 0x826A37E4;
	sub_82DF3428(ctx, base);
	// 826A37E4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A37E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A37EC: 3B6B0F6C  addi r27, r11, 0xf6c
	ctx.r[27].s64 = ctx.r[11].s64 + 3948;
	// 826A37F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A37F4: 48750215  bl 0x82df3a08
	ctx.lr = 0x826A37F8;
	sub_82DF3A08(ctx, base);
	// 826A37F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A37FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A3800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A3804: 4BEFDD85  bl 0x825a1588
	ctx.lr = 0x826A3808;
	sub_825A1588(ctx, base);
	// 826A3808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A380C: 4874FC1D  bl 0x82df3428
	ctx.lr = 0x826A3810;
	sub_82DF3428(ctx, base);
	// 826A3810: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3818: 3B4B0F60  addi r26, r11, 0xf60
	ctx.r[26].s64 = ctx.r[11].s64 + 3936;
	// 826A381C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A3820: 487501E9  bl 0x82df3a08
	ctx.lr = 0x826A3824;
	sub_82DF3A08(ctx, base);
	// 826A3824: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A3828: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A382C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3830: 4BEFDD59  bl 0x825a1588
	ctx.lr = 0x826A3834;
	sub_825A1588(ctx, base);
	// 826A3834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3838: 4874FBF1  bl 0x82df3428
	ctx.lr = 0x826A383C;
	sub_82DF3428(ctx, base);
	// 826A383C: 89790109  lbz r11, 0x109(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(265 as u32) ) } as u64;
	// 826A3840: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A3844: 418200B8  beq 0x826a38fc
	if ctx.cr[0].eq {
	pc = 0x826A38FC; continue 'dispatch;
	}
	// 826A3848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A384C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3850: 487501B9  bl 0x82df3a08
	ctx.lr = 0x826A3854;
	sub_82DF3A08(ctx, base);
	// 826A3854: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A3858: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A385C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3860: 4BEFDD29  bl 0x825a1588
	ctx.lr = 0x826A3864;
	sub_825A1588(ctx, base);
	// 826A3864: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3868: 4874FBC1  bl 0x82df3428
	ctx.lr = 0x826A386C;
	sub_82DF3428(ctx, base);
	// 826A386C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A3870: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3874: 48750195  bl 0x82df3a08
	ctx.lr = 0x826A3878;
	sub_82DF3A08(ctx, base);
	// 826A3878: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A387C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A3880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3884: 4BEFDD05  bl 0x825a1588
	ctx.lr = 0x826A3888;
	sub_825A1588(ctx, base);
	// 826A3888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A388C: 4874FB9D  bl 0x82df3428
	ctx.lr = 0x826A3890;
	sub_82DF3428(ctx, base);
	// 826A3890: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A3894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3898: 48750171  bl 0x82df3a08
	ctx.lr = 0x826A389C;
	sub_82DF3A08(ctx, base);
	// 826A389C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A38A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A38A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A38A8: 4BEFDCE1  bl 0x825a1588
	ctx.lr = 0x826A38AC;
	sub_825A1588(ctx, base);
	// 826A38AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A38B0: 4874FB79  bl 0x82df3428
	ctx.lr = 0x826A38B4;
	sub_82DF3428(ctx, base);
	// 826A38B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A38B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A38BC: 4875014D  bl 0x82df3a08
	ctx.lr = 0x826A38C0;
	sub_82DF3A08(ctx, base);
	// 826A38C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A38C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A38C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A38CC: 4BEFDCBD  bl 0x825a1588
	ctx.lr = 0x826A38D0;
	sub_825A1588(ctx, base);
	// 826A38D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A38D4: 4874FB55  bl 0x82df3428
	ctx.lr = 0x826A38D8;
	sub_82DF3428(ctx, base);
	// 826A38D8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A38DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A38E0: 48750129  bl 0x82df3a08
	ctx.lr = 0x826A38E4;
	sub_82DF3A08(ctx, base);
	// 826A38E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A38E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A38EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A38F0: 4BEFDC99  bl 0x825a1588
	ctx.lr = 0x826A38F4;
	sub_825A1588(ctx, base);
	// 826A38F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A38F8: 4874FB31  bl 0x82df3428
	ctx.lr = 0x826A38FC;
	sub_82DF3428(ctx, base);
	// 826A38FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826A3900: 48B048AC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A3908 size=8
    let mut pc: u32 = 0x826A3908;
    'dispatch: loop {
        match pc {
            0x826A3908 => {
    //   block [0x826A3908..0x826A3910)
	// 826A3908: 886301EC  lbz r3, 0x1ec(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(492 as u32) ) } as u64;
	// 826A390C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A3910 size=8
    let mut pc: u32 = 0x826A3910;
    'dispatch: loop {
        match pc {
            0x826A3910 => {
    //   block [0x826A3910..0x826A3918)
	// 826A3910: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826A3914: 4800010C  b 0x826a3a20
	sub_826A3A20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A3918 size=8
    let mut pc: u32 = 0x826A3918;
    'dispatch: loop {
        match pc {
            0x826A3918 => {
    //   block [0x826A3918..0x826A3920)
	// 826A3918: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826A391C: 48000104  b 0x826a3a20
	sub_826A3A20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A3920 size=80
    let mut pc: u32 = 0x826A3920;
    'dispatch: loop {
        match pc {
            0x826A3920 => {
    //   block [0x826A3920..0x826A3970)
	// 826A3920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A3928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A392C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A3934: 487B8FF5  bl 0x82e5c928
	ctx.lr = 0x826A3938;
	sub_82E5C928(ctx, base);
	// 826A3938: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A393C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A3940: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826A3944: 394A0FD8  addi r10, r10, 0xfd8
	ctx.r[10].s64 = ctx.r[10].s64 + 4056;
	// 826A3948: 993F0064  stb r9, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u8 ) };
	// 826A394C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3950: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A3954: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826A3958: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826A395C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A3960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A3964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A3968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A396C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A3970 size=172
    let mut pc: u32 = 0x826A3970;
    'dispatch: loop {
        match pc {
            0x826A3970 => {
    //   block [0x826A3970..0x826A3A1C)
	// 826A3970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A3978: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A397C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A3984: 4800319D  bl 0x826a6b20
	ctx.lr = 0x826A3988;
	sub_826A6B20(ctx, base);
	// 826A3988: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A398C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A3990: 396B0F14  addi r11, r11, 0xf14
	ctx.r[11].s64 = ctx.r[11].s64 + 3860;
	// 826A3994: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A3998: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A399C: 394A0F00  addi r10, r10, 0xf00
	ctx.r[10].s64 = ctx.r[10].s64 + 3840;
	// 826A39A0: 39290EB4  addi r9, r9, 0xeb4
	ctx.r[9].s64 = ctx.r[9].s64 + 3764;
	// 826A39A4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 826A39A8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A39AC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A39B0: 387F0184  addi r3, r31, 0x184
	ctx.r[3].s64 = ctx.r[31].s64 + 388;
	// 826A39B4: 917F0180  stw r11, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 826A39B8: 487B9F19  bl 0x82e5d8d0
	ctx.lr = 0x826A39BC;
	sub_82E5D8D0(ctx, base);
	// 826A39BC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A39C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A39C4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 826A39C8: 38EB0EA4  addi r7, r11, 0xea4
	ctx.r[7].s64 = ctx.r[11].s64 + 3748;
	// 826A39CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A39D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A39D4: 90FF0184  stw r7, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[7].u32 ) };
	// 826A39D8: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A39DC: 997F01E4  stb r11, 0x1e4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u8 ) };
	// 826A39E0: C1A8A1C4  lfs f13, -0x5e3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A39E4: 997F01EC  stb r11, 0x1ec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[11].u8 ) };
	// 826A39E8: D01F01E8  stfs f0, 0x1e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 826A39EC: 995F01ED  stb r10, 0x1ed(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(493 as u32), ctx.r[10].u8 ) };
	// 826A39F0: D1BF01F4  stfs f13, 0x1f4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 826A39F4: 917F01F0  stw r11, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[11].u32 ) };
	// 826A39F8: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 826A39FC: 997F01F8  stb r11, 0x1f8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u8 ) };
	// 826A3A00: 915F0200  stw r10, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[10].u32 ) };
	// 826A3A04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3A08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A3A0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A3A10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A3A14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A3A18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A3A20 size=76
    let mut pc: u32 = 0x826A3A20;
    'dispatch: loop {
        match pc {
            0x826A3A20 => {
    //   block [0x826A3A20..0x826A3A6C)
	// 826A3A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A3A28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A3A2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A3A30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3A34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A3A38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A3A3C: 4BFFFC65  bl 0x826a36a0
	ctx.lr = 0x826A3A40;
	sub_826A36A0(ctx, base);
	// 826A3A40: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A3A44: 4182000C  beq 0x826a3a50
	if ctx.cr[0].eq {
	pc = 0x826A3A50; continue 'dispatch;
	}
	// 826A3A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3A4C: 4874E98D  bl 0x82df23d8
	ctx.lr = 0x826A3A50;
	sub_82DF23D8(ctx, base);
	// 826A3A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3A54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A3A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A3A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A3A60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A3A64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A3A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A3A70 size=196
    let mut pc: u32 = 0x826A3A70;
    'dispatch: loop {
        match pc {
            0x826A3A70 => {
    //   block [0x826A3A70..0x826A3B34)
	// 826A3A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A3A78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A3A7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A3A80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3A84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A3A88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A3A8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A3A90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A3A94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3A98: 4BC1CEA1  bl 0x822c0938
	ctx.lr = 0x826A3A9C;
	sub_822C0938(ctx, base);
	// 826A3A9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A3AA0: 41820028  beq 0x826a3ac8
	if ctx.cr[0].eq {
	pc = 0x826A3AC8; continue 'dispatch;
	}
	// 826A3AA4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3AA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A3AAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A3AB0: 392B0F9C  addi r9, r11, 0xf9c
	ctx.r[9].s64 = ctx.r[11].s64 + 3996;
	// 826A3AB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A3AB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A3ABC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A3AC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A3AC4: 48000008  b 0x826a3acc
	pc = 0x826A3ACC; continue 'dispatch;
	// 826A3AC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A3ACC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A3AD4: 409A0044  bne cr6, 0x826a3b18
	if !ctx.cr[6].eq {
	pc = 0x826A3B18; continue 'dispatch;
	}
	// 826A3AD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A3ADC: 419A001C  beq cr6, 0x826a3af8
	if ctx.cr[6].eq {
	pc = 0x826A3AF8; continue 'dispatch;
	}
	// 826A3AE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A3AE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A3AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3AEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A3AF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A3AF4: 4E800421  bctrl
	ctx.lr = 0x826A3AF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A3AF8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A3AFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A3B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3B04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A3B08: 816B9BA0  lwz r11, -0x6460(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25696 as u32) ) } as u64;
	// 826A3B0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A3B10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A3B14: 4BC1C4ED  bl 0x822c0000
	ctx.lr = 0x826A3B18;
	sub_822C0000(ctx, base);
	// 826A3B18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A3B1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A3B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A3B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A3B28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A3B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A3B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A3B38 size=196
    let mut pc: u32 = 0x826A3B38;
    'dispatch: loop {
        match pc {
            0x826A3B38 => {
    //   block [0x826A3B38..0x826A3BFC)
	// 826A3B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A3B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A3B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A3B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3B4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A3B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A3B54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A3B58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A3B5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3B60: 4BC1CDD9  bl 0x822c0938
	ctx.lr = 0x826A3B64;
	sub_822C0938(ctx, base);
	// 826A3B64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A3B68: 41820028  beq 0x826a3b90
	if ctx.cr[0].eq {
	pc = 0x826A3B90; continue 'dispatch;
	}
	// 826A3B6C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3B70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A3B74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A3B78: 392B0FB0  addi r9, r11, 0xfb0
	ctx.r[9].s64 = ctx.r[11].s64 + 4016;
	// 826A3B7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A3B80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A3B84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A3B88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A3B8C: 48000008  b 0x826a3b94
	pc = 0x826A3B94; continue 'dispatch;
	// 826A3B90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A3B94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A3B9C: 409A0044  bne cr6, 0x826a3be0
	if !ctx.cr[6].eq {
	pc = 0x826A3BE0; continue 'dispatch;
	}
	// 826A3BA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A3BA4: 419A001C  beq cr6, 0x826a3bc0
	if ctx.cr[6].eq {
	pc = 0x826A3BC0; continue 'dispatch;
	}
	// 826A3BA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A3BAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A3BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3BB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A3BB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A3BBC: 4E800421  bctrl
	ctx.lr = 0x826A3BC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A3BC0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A3BC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A3BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3BCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A3BD0: 816B9BA0  lwz r11, -0x6460(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25696 as u32) ) } as u64;
	// 826A3BD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A3BD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A3BDC: 4BC1C425  bl 0x822c0000
	ctx.lr = 0x826A3BE0;
	sub_822C0000(ctx, base);
	// 826A3BE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A3BE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A3BE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A3BEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A3BF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A3BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A3BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A3C00 size=196
    let mut pc: u32 = 0x826A3C00;
    'dispatch: loop {
        match pc {
            0x826A3C00 => {
    //   block [0x826A3C00..0x826A3CC4)
	// 826A3C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A3C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A3C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A3C10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3C14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A3C18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A3C1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A3C20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A3C24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3C28: 4BC1CD11  bl 0x822c0938
	ctx.lr = 0x826A3C2C;
	sub_822C0938(ctx, base);
	// 826A3C2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A3C30: 41820028  beq 0x826a3c58
	if ctx.cr[0].eq {
	pc = 0x826A3C58; continue 'dispatch;
	}
	// 826A3C34: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3C38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A3C3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A3C40: 392B0FC4  addi r9, r11, 0xfc4
	ctx.r[9].s64 = ctx.r[11].s64 + 4036;
	// 826A3C44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A3C48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A3C4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A3C50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A3C54: 48000008  b 0x826a3c5c
	pc = 0x826A3C5C; continue 'dispatch;
	// 826A3C58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A3C5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A3C64: 409A0044  bne cr6, 0x826a3ca8
	if !ctx.cr[6].eq {
	pc = 0x826A3CA8; continue 'dispatch;
	}
	// 826A3C68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A3C6C: 419A001C  beq cr6, 0x826a3c88
	if ctx.cr[6].eq {
	pc = 0x826A3C88; continue 'dispatch;
	}
	// 826A3C70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A3C74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A3C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3C7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A3C80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A3C84: 4E800421  bctrl
	ctx.lr = 0x826A3C88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A3C88: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A3C8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A3C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A3C94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A3C98: 816B9BA0  lwz r11, -0x6460(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25696 as u32) ) } as u64;
	// 826A3C9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A3CA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A3CA4: 4BC1C35D  bl 0x822c0000
	ctx.lr = 0x826A3CA8;
	sub_822C0000(ctx, base);
	// 826A3CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A3CAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A3CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A3CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A3CB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A3CBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A3CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A3CC8 size=732
    let mut pc: u32 = 0x826A3CC8;
    'dispatch: loop {
        match pc {
            0x826A3CC8 => {
    //   block [0x826A3CC8..0x826A3FA4)
	// 826A3CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3CCC: 48B044A1  bl 0x831a816c
	ctx.lr = 0x826A3CD0;
	sub_831A8130(ctx, base);
	// 826A3CD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3CD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A3CD8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826A3CDC: 817E0180  lwz r11, 0x180(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A3CE0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826A3CE4: 419A02B8  beq cr6, 0x826a3f9c
	if ctx.cr[6].eq {
	pc = 0x826A3F9C; continue 'dispatch;
	}
	// 826A3CE8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826A3CEC: 409A000C  bne cr6, 0x826a3cf8
	if !ctx.cr[6].eq {
	pc = 0x826A3CF8; continue 'dispatch;
	}
	// 826A3CF0: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 826A3CF4: 419A02A8  beq cr6, 0x826a3f9c
	if ctx.cr[6].eq {
	pc = 0x826A3F9C; continue 'dispatch;
	}
	// 826A3CF8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A3CFC: 409A0018  bne cr6, 0x826a3d14
	if !ctx.cr[6].eq {
	pc = 0x826A3D14; continue 'dispatch;
	}
	// 826A3D00: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 826A3D04: 409A0010  bne cr6, 0x826a3d14
	if !ctx.cr[6].eq {
	pc = 0x826A3D14; continue 'dispatch;
	}
	// 826A3D08: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826A3D0C: 917E0180  stw r11, 0x180(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 826A3D10: 4800028C  b 0x826a3f9c
	pc = 0x826A3F9C; continue 'dispatch;
	// 826A3D14: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 826A3D18: 4198019C  blt cr6, 0x826a3eb4
	if ctx.cr[6].lt {
	pc = 0x826A3EB4; continue 'dispatch;
	}
	// 826A3D1C: 2B1D0003  cmplwi cr6, r29, 3
	ctx.cr[6].compare_u32(ctx.r[29].u32, 3 as u32, &mut ctx.xer);
	// 826A3D20: 419800C8  blt cr6, 0x826a3de8
	if ctx.cr[6].lt {
	pc = 0x826A3DE8; continue 'dispatch;
	}
	// 826A3D24: 409A0274  bne cr6, 0x826a3f98
	if !ctx.cr[6].eq {
	pc = 0x826A3F98; continue 'dispatch;
	}
	// 826A3D28: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3D2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A3D30: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A3D34: 38A000E1  li r5, 0xe1
	ctx.r[5].s64 = 225;
	// 826A3D38: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 826A3D3C: 4874E6AD  bl 0x82df23e8
	ctx.lr = 0x826A3D40;
	sub_82DF23E8(ctx, base);
	// 826A3D40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A3D44: 41820010  beq 0x826a3d54
	if ctx.cr[0].eq {
	pc = 0x826A3D54; continue 'dispatch;
	}
	// 826A3D48: 4BFFFBD9  bl 0x826a3920
	ctx.lr = 0x826A3D4C;
	sub_826A3920(ctx, base);
	// 826A3D4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A3D50: 48000008  b 0x826a3d58
	pc = 0x826A3D58; continue 'dispatch;
	// 826A3D54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A3D58: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A3D5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A3D60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A3D64: 4BFFFE9D  bl 0x826a3c00
	ctx.lr = 0x826A3D68;
	sub_826A3C00(ctx, base);
	// 826A3D68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A3D6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A3D70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A3D74: 4BC1C28D  bl 0x822c0000
	ctx.lr = 0x826A3D78;
	sub_822C0000(ctx, base);
	// 826A3D78: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A3D7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A3D80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A3D84: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826A3D88: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A3D8C: 419A0024  beq cr6, 0x826a3db0
	if ctx.cr[6].eq {
	pc = 0x826A3DB0; continue 'dispatch;
	}
	// 826A3D90: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A3D94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A3D98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A3D9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A3DA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A3DA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A3DA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A3DAC: 4082FFE8  bne 0x826a3d94
	if !ctx.cr[0].eq {
	pc = 0x826A3D94; continue 'dispatch;
	}
	// 826A3DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A3DB4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A3DB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A3DBC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A3DC0: 389E0184  addi r4, r30, 0x184
	ctx.r[4].s64 = ctx.r[30].s64 + 388;
	// 826A3DC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A3DC8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A3DCC: 487BA8DD  bl 0x82e5e6a8
	ctx.lr = 0x826A3DD0;
	sub_82E5E6A8(ctx, base);
	// 826A3DD0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826A3DD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A3DD8: 419A0008  beq cr6, 0x826a3de0
	if ctx.cr[6].eq {
	pc = 0x826A3DE0; continue 'dispatch;
	}
	// 826A3DDC: 4BC1CAB5  bl 0x822c0890
	ctx.lr = 0x826A3DE0;
	sub_822C0890(ctx, base);
	// 826A3DE0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A3DE4: 48000198  b 0x826a3f7c
	pc = 0x826A3F7C; continue 'dispatch;
	// 826A3DE8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3DEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A3DF0: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A3DF4: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 826A3DF8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A3DFC: 4874E5ED  bl 0x82df23e8
	ctx.lr = 0x826A3E00;
	sub_82DF23E8(ctx, base);
	// 826A3E00: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A3E04: 4182001C  beq 0x826a3e20
	if ctx.cr[0].eq {
	pc = 0x826A3E20; continue 'dispatch;
	}
	// 826A3E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3E0C: 487B8B1D  bl 0x82e5c928
	ctx.lr = 0x826A3E10;
	sub_82E5C928(ctx, base);
	// 826A3E10: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3E14: 396B1028  addi r11, r11, 0x1028
	ctx.r[11].s64 = ctx.r[11].s64 + 4136;
	// 826A3E18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3E1C: 48000008  b 0x826a3e24
	pc = 0x826A3E24; continue 'dispatch;
	// 826A3E20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A3E24: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A3E28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A3E2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A3E30: 4BFFFD09  bl 0x826a3b38
	ctx.lr = 0x826A3E34;
	sub_826A3B38(ctx, base);
	// 826A3E34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A3E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A3E3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A3E40: 4BC1C1C1  bl 0x822c0000
	ctx.lr = 0x826A3E44;
	sub_822C0000(ctx, base);
	// 826A3E44: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A3E48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A3E4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A3E50: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 826A3E54: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826A3E58: 419A0024  beq cr6, 0x826a3e7c
	if ctx.cr[6].eq {
	pc = 0x826A3E7C; continue 'dispatch;
	}
	// 826A3E5C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A3E60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A3E64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A3E68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A3E6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A3E70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A3E74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A3E78: 4082FFE8  bne 0x826a3e60
	if !ctx.cr[0].eq {
	pc = 0x826A3E60; continue 'dispatch;
	}
	// 826A3E7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A3E80: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A3E84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A3E88: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826A3E8C: 389E0184  addi r4, r30, 0x184
	ctx.r[4].s64 = ctx.r[30].s64 + 388;
	// 826A3E90: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A3E94: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A3E98: 487BA811  bl 0x82e5e6a8
	ctx.lr = 0x826A3E9C;
	sub_82E5E6A8(ctx, base);
	// 826A3E9C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826A3EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A3EA4: 419A0008  beq cr6, 0x826a3eac
	if ctx.cr[6].eq {
	pc = 0x826A3EAC; continue 'dispatch;
	}
	// 826A3EA8: 4BC1C9E9  bl 0x822c0890
	ctx.lr = 0x826A3EAC;
	sub_822C0890(ctx, base);
	// 826A3EAC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A3EB0: 480000CC  b 0x826a3f7c
	pc = 0x826A3F7C; continue 'dispatch;
	// 826A3EB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3EB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A3EBC: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A3EC0: 38A000DA  li r5, 0xda
	ctx.r[5].s64 = 218;
	// 826A3EC4: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A3EC8: 4874E521  bl 0x82df23e8
	ctx.lr = 0x826A3ECC;
	sub_82DF23E8(ctx, base);
	// 826A3ECC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A3ED0: 4182001C  beq 0x826a3eec
	if ctx.cr[0].eq {
	pc = 0x826A3EEC; continue 'dispatch;
	}
	// 826A3ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3ED8: 487B8A51  bl 0x82e5c928
	ctx.lr = 0x826A3EDC;
	sub_82E5C928(ctx, base);
	// 826A3EDC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3EE0: 396B1000  addi r11, r11, 0x1000
	ctx.r[11].s64 = ctx.r[11].s64 + 4096;
	// 826A3EE4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A3EE8: 48000008  b 0x826a3ef0
	pc = 0x826A3EF0; continue 'dispatch;
	// 826A3EEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A3EF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A3EF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A3EF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A3EFC: 4BFFFB75  bl 0x826a3a70
	ctx.lr = 0x826A3F00;
	sub_826A3A70(ctx, base);
	// 826A3F00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A3F04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A3F08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A3F0C: 4BC1C0F5  bl 0x822c0000
	ctx.lr = 0x826A3F10;
	sub_822C0000(ctx, base);
	// 826A3F10: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A3F14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A3F18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A3F1C: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 826A3F20: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826A3F24: 419A0024  beq cr6, 0x826a3f48
	if ctx.cr[6].eq {
	pc = 0x826A3F48; continue 'dispatch;
	}
	// 826A3F28: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A3F2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A3F30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A3F34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A3F38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A3F3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A3F40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A3F44: 4082FFE8  bne 0x826a3f2c
	if !ctx.cr[0].eq {
	pc = 0x826A3F2C; continue 'dispatch;
	}
	// 826A3F48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A3F4C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A3F50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A3F54: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 826A3F58: 389E0184  addi r4, r30, 0x184
	ctx.r[4].s64 = ctx.r[30].s64 + 388;
	// 826A3F5C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A3F60: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A3F64: 487BA745  bl 0x82e5e6a8
	ctx.lr = 0x826A3F68;
	sub_82E5E6A8(ctx, base);
	// 826A3F68: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826A3F6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A3F70: 419A0008  beq cr6, 0x826a3f78
	if ctx.cr[6].eq {
	pc = 0x826A3F78; continue 'dispatch;
	}
	// 826A3F74: 4BC1C91D  bl 0x822c0890
	ctx.lr = 0x826A3F78;
	sub_822C0890(ctx, base);
	// 826A3F78: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826A3F7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A3F80: 419A0008  beq cr6, 0x826a3f88
	if ctx.cr[6].eq {
	pc = 0x826A3F88; continue 'dispatch;
	}
	// 826A3F84: 4BC1C90D  bl 0x822c0890
	ctx.lr = 0x826A3F88;
	sub_822C0890(ctx, base);
	// 826A3F88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A3F8C: 419A000C  beq cr6, 0x826a3f98
	if ctx.cr[6].eq {
	pc = 0x826A3F98; continue 'dispatch;
	}
	// 826A3F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A3F94: 4BC1C8FD  bl 0x822c0890
	ctx.lr = 0x826A3F98;
	sub_822C0890(ctx, base);
	// 826A3F98: 93BE0180  stw r29, 0x180(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[29].u32 ) };
	// 826A3F9C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826A3FA0: 48B0421C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A3FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A3FA8 size=564
    let mut pc: u32 = 0x826A3FA8;
    'dispatch: loop {
        match pc {
            0x826A3FA8 => {
    //   block [0x826A3FA8..0x826A41DC)
	// 826A3FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A3FAC: 48B041C1  bl 0x831a816c
	ctx.lr = 0x826A3FB0;
	sub_831A8130(ctx, base);
	// 826A3FB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A3FB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A3FB8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826A3FBC: 897E01ED  lbz r11, 0x1ed(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(493 as u32) ) } as u64;
	// 826A3FC0: 9BBE01E4  stb r29, 0x1e4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(484 as u32), ctx.r[29].u8 ) };
	// 826A3FC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A3FC8: 4182020C  beq 0x826a41d4
	if ctx.cr[0].eq {
	pc = 0x826A41D4; continue 'dispatch;
	}
	// 826A3FCC: 897E01F8  lbz r11, 0x1f8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(504 as u32) ) } as u64;
	// 826A3FD0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A3FD4: 817E0180  lwz r11, 0x180(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A3FD8: 41820104  beq 0x826a40dc
	if ctx.cr[0].eq {
	pc = 0x826A40DC; continue 'dispatch;
	}
	// 826A3FDC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826A3FE0: 419A01F4  beq cr6, 0x826a41d4
	if ctx.cr[6].eq {
	pc = 0x826A41D4; continue 'dispatch;
	}
	// 826A3FE4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A3FE8: 419A00E8  beq cr6, 0x826a40d0
	if ctx.cr[6].eq {
	pc = 0x826A40D0; continue 'dispatch;
	}
	// 826A3FEC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A3FF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A3FF4: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A3FF8: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 826A3FFC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A4000: 4874E3E9  bl 0x82df23e8
	ctx.lr = 0x826A4004;
	sub_82DF23E8(ctx, base);
	// 826A4004: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A4008: 4182001C  beq 0x826a4024
	if ctx.cr[0].eq {
	pc = 0x826A4024; continue 'dispatch;
	}
	// 826A400C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4010: 487B8919  bl 0x82e5c928
	ctx.lr = 0x826A4014;
	sub_82E5C928(ctx, base);
	// 826A4014: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4018: 396B1028  addi r11, r11, 0x1028
	ctx.r[11].s64 = ctx.r[11].s64 + 4136;
	// 826A401C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A4020: 48000008  b 0x826a4028
	pc = 0x826A4028; continue 'dispatch;
	// 826A4024: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A4028: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A402C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4030: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4034: 4BFFFB05  bl 0x826a3b38
	ctx.lr = 0x826A4038;
	sub_826A3B38(ctx, base);
	// 826A4038: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A403C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4040: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4044: 4BC1BFBD  bl 0x822c0000
	ctx.lr = 0x826A4048;
	sub_822C0000(ctx, base);
	// 826A4048: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A404C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A4050: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A4054: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826A4058: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A405C: 419A0024  beq cr6, 0x826a4080
	if ctx.cr[6].eq {
	pc = 0x826A4080; continue 'dispatch;
	}
	// 826A4060: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A4064: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A4068: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A406C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A4070: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A4074: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A4078: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A407C: 4082FFE8  bne 0x826a4064
	if !ctx.cr[0].eq {
	pc = 0x826A4064; continue 'dispatch;
	}
	// 826A4080: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A4084: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A4088: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A408C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A4090: 389E0184  addi r4, r30, 0x184
	ctx.r[4].s64 = ctx.r[30].s64 + 388;
	// 826A4094: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A4098: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A409C: 487BA60D  bl 0x82e5e6a8
	ctx.lr = 0x826A40A0;
	sub_82E5E6A8(ctx, base);
	// 826A40A0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826A40A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A40A8: 419A0008  beq cr6, 0x826a40b0
	if ctx.cr[6].eq {
	pc = 0x826A40B0; continue 'dispatch;
	}
	// 826A40AC: 4BC1C7E5  bl 0x822c0890
	ctx.lr = 0x826A40B0;
	sub_822C0890(ctx, base);
	// 826A40B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A40B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A40B8: 419A0008  beq cr6, 0x826a40c0
	if ctx.cr[6].eq {
	pc = 0x826A40C0; continue 'dispatch;
	}
	// 826A40BC: 4BC1C7D5  bl 0x822c0890
	ctx.lr = 0x826A40C0;
	sub_822C0890(ctx, base);
	// 826A40C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A40C4: 419A000C  beq cr6, 0x826a40d0
	if ctx.cr[6].eq {
	pc = 0x826A40D0; continue 'dispatch;
	}
	// 826A40C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A40CC: 4BC1C7C5  bl 0x822c0890
	ctx.lr = 0x826A40D0;
	sub_822C0890(ctx, base);
	// 826A40D0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826A40D4: 917E0180  stw r11, 0x180(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 826A40D8: 480000FC  b 0x826a41d4
	pc = 0x826A41D4; continue 'dispatch;
	// 826A40DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A40E0: 419A00F4  beq cr6, 0x826a41d4
	if ctx.cr[6].eq {
	pc = 0x826A41D4; continue 'dispatch;
	}
	// 826A40E4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826A40E8: 419A00EC  beq cr6, 0x826a41d4
	if ctx.cr[6].eq {
	pc = 0x826A41D4; continue 'dispatch;
	}
	// 826A40EC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A40F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A40F4: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A40F8: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 826A40FC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A4100: 4874E2E9  bl 0x82df23e8
	ctx.lr = 0x826A4104;
	sub_82DF23E8(ctx, base);
	// 826A4104: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A4108: 4182001C  beq 0x826a4124
	if ctx.cr[0].eq {
	pc = 0x826A4124; continue 'dispatch;
	}
	// 826A410C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4110: 487B8819  bl 0x82e5c928
	ctx.lr = 0x826A4114;
	sub_82E5C928(ctx, base);
	// 826A4114: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4118: 396B1028  addi r11, r11, 0x1028
	ctx.r[11].s64 = ctx.r[11].s64 + 4136;
	// 826A411C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A4120: 48000008  b 0x826a4128
	pc = 0x826A4128; continue 'dispatch;
	// 826A4124: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A4128: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A412C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4130: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4134: 4BFFFA05  bl 0x826a3b38
	ctx.lr = 0x826A4138;
	sub_826A3B38(ctx, base);
	// 826A4138: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A413C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4140: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4144: 4BC1BEBD  bl 0x822c0000
	ctx.lr = 0x826A4148;
	sub_822C0000(ctx, base);
	// 826A4148: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A414C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A4150: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A4154: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 826A4158: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826A415C: 419A0024  beq cr6, 0x826a4180
	if ctx.cr[6].eq {
	pc = 0x826A4180; continue 'dispatch;
	}
	// 826A4160: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A4164: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A4168: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A416C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A4170: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A4174: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A4178: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A417C: 4082FFE8  bne 0x826a4164
	if !ctx.cr[0].eq {
	pc = 0x826A4164; continue 'dispatch;
	}
	// 826A4180: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A4184: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A4188: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A418C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826A4190: 389E0184  addi r4, r30, 0x184
	ctx.r[4].s64 = ctx.r[30].s64 + 388;
	// 826A4194: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A4198: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A419C: 487BA50D  bl 0x82e5e6a8
	ctx.lr = 0x826A41A0;
	sub_82E5E6A8(ctx, base);
	// 826A41A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826A41A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A41A8: 419A0008  beq cr6, 0x826a41b0
	if ctx.cr[6].eq {
	pc = 0x826A41B0; continue 'dispatch;
	}
	// 826A41AC: 4BC1C6E5  bl 0x822c0890
	ctx.lr = 0x826A41B0;
	sub_822C0890(ctx, base);
	// 826A41B0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A41B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A41B8: 419A0008  beq cr6, 0x826a41c0
	if ctx.cr[6].eq {
	pc = 0x826A41C0; continue 'dispatch;
	}
	// 826A41BC: 4BC1C6D5  bl 0x822c0890
	ctx.lr = 0x826A41C0;
	sub_822C0890(ctx, base);
	// 826A41C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A41C4: 419A000C  beq cr6, 0x826a41d0
	if ctx.cr[6].eq {
	pc = 0x826A41D0; continue 'dispatch;
	}
	// 826A41C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A41CC: 4BC1C6C5  bl 0x822c0890
	ctx.lr = 0x826A41D0;
	sub_822C0890(ctx, base);
	// 826A41D0: 93BE0180  stw r29, 0x180(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[29].u32 ) };
	// 826A41D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826A41D8: 48B03FE4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A41E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A41E0 size=20
    let mut pc: u32 = 0x826A41E0;
    'dispatch: loop {
        match pc {
            0x826A41E0 => {
    //   block [0x826A41E0..0x826A41F4)
	// 826A41E0: 896301ED  lbz r11, 0x1ed(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(493 as u32) ) } as u64;
	// 826A41E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826A41E8: 994301E4  stb r10, 0x1e4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(484 as u32), ctx.r[10].u8 ) };
	// 826A41EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A41F0: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A41F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A41F4 size=12
    let mut pc: u32 = 0x826A41F4;
    'dispatch: loop {
        match pc {
            0x826A41F4 => {
    //   block [0x826A41F4..0x826A4200)
	// 826A41F4: 81630180  lwz r11, 0x180(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A41F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A41FC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A4200 size=8
    let mut pc: u32 = 0x826A4200;
    'dispatch: loop {
        match pc {
            0x826A4200 => {
    //   block [0x826A4200..0x826A4208)
	// 826A4200: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A4204: 4BFFFAC4  b 0x826a3cc8
	sub_826A3CC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A4208 size=4
    let mut pc: u32 = 0x826A4208;
    'dispatch: loop {
        match pc {
            0x826A4208 => {
    //   block [0x826A4208..0x826A420C)
	// 826A4208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A4210 size=144
    let mut pc: u32 = 0x826A4210;
    'dispatch: loop {
        match pc {
            0x826A4210 => {
    //   block [0x826A4210..0x826A42A0)
	// 826A4210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A4214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A4218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A421C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A4224: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 826A4228: 817F0200  lwz r11, 0x200(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 826A422C: 7D6A5851  subf. r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A4230: 917F0200  stw r11, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 826A4234: 41810058  bgt 0x826a428c
	if ctx.cr[0].gt {
	pc = 0x826A428C; continue 'dispatch;
	}
	// 826A4238: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826A423C: C1BF01FC  lfs f13, 0x1fc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A4240: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A4244: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A4248: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826A424C: 40990008  ble cr6, 0x826a4254
	if !ctx.cr[6].gt {
	pc = 0x826A4254; continue 'dispatch;
	}
	// 826A4250: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A4254: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A4258: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826A425C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4260: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 826A4264: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A4268: 4E800421  bctrl
	ctx.lr = 0x826A426C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A426C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A4270: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826A4274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4278: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A427C: D01F01E8  stfs f0, 0x1e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 826A4280: 4BFFFA49  bl 0x826a3cc8
	ctx.lr = 0x826A4284;
	sub_826A3CC8(ctx, base);
	// 826A4284: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A4288: 997F01EC  stb r11, 0x1ec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[11].u8 ) };
	// 826A428C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A4290: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A4294: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A4298: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A429C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A42A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A42A0 size=324
    let mut pc: u32 = 0x826A42A0;
    'dispatch: loop {
        match pc {
            0x826A42A0 => {
    //   block [0x826A42A0..0x826A43E4)
	// 826A42A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A42A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A42A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A42AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A42B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A42B4: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826A42B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A42BC: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 826A42C0: 419A000C  beq cr6, 0x826a42cc
	if ctx.cr[6].eq {
	pc = 0x826A42CC; continue 'dispatch;
	}
	// 826A42C4: 48001B15  bl 0x826a5dd8
	ctx.lr = 0x826A42C8;
	sub_826A5DD8(ctx, base);
	// 826A42C8: 48000104  b 0x826a43cc
	pc = 0x826A43CC; continue 'dispatch;
	// 826A42CC: 817E0180  lwz r11, 0x180(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A42D0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826A42D4: 419A00F8  beq cr6, 0x826a43cc
	if ctx.cr[6].eq {
	pc = 0x826A43CC; continue 'dispatch;
	}
	// 826A42D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A42DC: 419A00E8  beq cr6, 0x826a43c4
	if ctx.cr[6].eq {
	pc = 0x826A43C4; continue 'dispatch;
	}
	// 826A42E0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A42E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A42E8: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A42EC: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 826A42F0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A42F4: 4874E0F5  bl 0x82df23e8
	ctx.lr = 0x826A42F8;
	sub_82DF23E8(ctx, base);
	// 826A42F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A42FC: 4182001C  beq 0x826a4318
	if ctx.cr[0].eq {
	pc = 0x826A4318; continue 'dispatch;
	}
	// 826A4300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4304: 487B8625  bl 0x82e5c928
	ctx.lr = 0x826A4308;
	sub_82E5C928(ctx, base);
	// 826A4308: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A430C: 396B1028  addi r11, r11, 0x1028
	ctx.r[11].s64 = ctx.r[11].s64 + 4136;
	// 826A4310: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A4314: 48000008  b 0x826a431c
	pc = 0x826A431C; continue 'dispatch;
	// 826A4318: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A431C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A4320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4324: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4328: 4BFFF811  bl 0x826a3b38
	ctx.lr = 0x826A432C;
	sub_826A3B38(ctx, base);
	// 826A432C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A4330: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4334: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4338: 4BC1BCC9  bl 0x822c0000
	ctx.lr = 0x826A433C;
	sub_822C0000(ctx, base);
	// 826A433C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A4340: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A4344: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A4348: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826A434C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A4350: 419A0024  beq cr6, 0x826a4374
	if ctx.cr[6].eq {
	pc = 0x826A4374; continue 'dispatch;
	}
	// 826A4354: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A4358: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A435C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4360: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A4364: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A4368: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A436C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4370: 4082FFE8  bne 0x826a4358
	if !ctx.cr[0].eq {
	pc = 0x826A4358; continue 'dispatch;
	}
	// 826A4374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A4378: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A437C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A4380: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A4384: 389E0184  addi r4, r30, 0x184
	ctx.r[4].s64 = ctx.r[30].s64 + 388;
	// 826A4388: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A438C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A4390: 487BA319  bl 0x82e5e6a8
	ctx.lr = 0x826A4394;
	sub_82E5E6A8(ctx, base);
	// 826A4394: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A4398: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A439C: 419A0008  beq cr6, 0x826a43a4
	if ctx.cr[6].eq {
	pc = 0x826A43A4; continue 'dispatch;
	}
	// 826A43A0: 4BC1C4F1  bl 0x822c0890
	ctx.lr = 0x826A43A4;
	sub_822C0890(ctx, base);
	// 826A43A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A43A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A43AC: 419A0008  beq cr6, 0x826a43b4
	if ctx.cr[6].eq {
	pc = 0x826A43B4; continue 'dispatch;
	}
	// 826A43B0: 4BC1C4E1  bl 0x822c0890
	ctx.lr = 0x826A43B4;
	sub_822C0890(ctx, base);
	// 826A43B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A43B8: 419A000C  beq cr6, 0x826a43c4
	if ctx.cr[6].eq {
	pc = 0x826A43C4; continue 'dispatch;
	}
	// 826A43BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A43C0: 4BC1C4D1  bl 0x822c0890
	ctx.lr = 0x826A43C4;
	sub_822C0890(ctx, base);
	// 826A43C4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826A43C8: 917E0180  stw r11, 0x180(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 826A43CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A43D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A43D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A43D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A43DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A43E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A43E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A43E8 size=352
    let mut pc: u32 = 0x826A43E8;
    'dispatch: loop {
        match pc {
            0x826A43E8 => {
    //   block [0x826A43E8..0x826A4548)
	// 826A43E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A43EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A43F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A43F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A43F8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826A43FC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4400: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A4404: 48AB01FD  bl 0x83154600
	ctx.lr = 0x826A4408;
	sub_83154600(ctx, base);
	// 826A4408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A440C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4410: 487B5359  bl 0x82e59768
	ctx.lr = 0x826A4414;
	sub_82E59768(ctx, base);
	// 826A4414: C1BF01E8  lfs f13, 0x1e8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A4418: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A441C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826A4420: C1BF01F4  lfs f13, 0x1f4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A4424: D01F01E8  stfs f0, 0x1e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 826A4428: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826A442C: 419900E8  bgt cr6, 0x826a4514
	if ctx.cr[6].gt {
	pc = 0x826A4514; continue 'dispatch;
	}
	// 826A4430: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A4434: 895F01E4  lbz r10, 0x1e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 826A4438: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A443C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A4440: 418200B8  beq 0x826a44f8
	if ctx.cr[0].eq {
	pc = 0x826A44F8; continue 'dispatch;
	}
	// 826A4444: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A4448: 4BD1ABE1  bl 0x823bf028
	ctx.lr = 0x826A444C;
	sub_823BF028(ctx, base);
	// 826A444C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A4450: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826A4454: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A4458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A445C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A4460: 419A0024  beq cr6, 0x826a4484
	if ctx.cr[6].eq {
	pc = 0x826A4484; continue 'dispatch;
	}
	// 826A4464: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A4468: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A446C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4470: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A4474: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A4478: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A447C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4480: 4082FFE8  bne 0x826a4468
	if !ctx.cr[0].eq {
	pc = 0x826A4468; continue 'dispatch;
	}
	// 826A4484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4488: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A448C: 4BE6B03D  bl 0x8250f4c8
	ctx.lr = 0x826A4490;
	sub_8250F4C8(ctx, base);
	// 826A4490: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A4494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A4498: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A449C: 409A0008  bne cr6, 0x826a44a4
	if !ctx.cr[6].eq {
	pc = 0x826A44A4; continue 'dispatch;
	}
	// 826A44A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A44A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A44A8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826A44AC: 4BE6456D  bl 0x82508a18
	ctx.lr = 0x826A44B0;
	sub_82508A18(ctx, base);
	// 826A44B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A44B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826A44B8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A44BC: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A44C0: 38A00039  li r5, 0x39
	ctx.r[5].s64 = 57;
	// 826A44C4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826A44C8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826A44CC: 487B4575  bl 0x82e58a40
	ctx.lr = 0x826A44D0;
	sub_82E58A40(ctx, base);
	// 826A44D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A44D4: 4874D7BD  bl 0x82df1c90
	ctx.lr = 0x826A44D8;
	sub_82DF1C90(ctx, base);
	// 826A44D8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A44DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A44E0: 419A0008  beq cr6, 0x826a44e8
	if ctx.cr[6].eq {
	pc = 0x826A44E8; continue 'dispatch;
	}
	// 826A44E4: 4BC1C3AD  bl 0x822c0890
	ctx.lr = 0x826A44E8;
	sub_822C0890(ctx, base);
	// 826A44E8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A44EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A44F0: 419A0008  beq cr6, 0x826a44f8
	if ctx.cr[6].eq {
	pc = 0x826A44F8; continue 'dispatch;
	}
	// 826A44F4: 4BC1C39D  bl 0x822c0890
	ctx.lr = 0x826A44F8;
	sub_822C0890(ctx, base);
	// 826A44F8: D3FF01E8  stfs f31, 0x1e8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 826A44FC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826A4500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4504: 4BFFF7C5  bl 0x826a3cc8
	ctx.lr = 0x826A4508;
	sub_826A3CC8(ctx, base);
	// 826A4508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A450C: 997F01EC  stb r11, 0x1ec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[11].u8 ) };
	// 826A4510: 4800001C  b 0x826a452c
	pc = 0x826A452C; continue 'dispatch;
	// 826A4514: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A4518: EC2D0028  fsubs f1, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A451C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4520: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 826A4524: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A4528: 4E800421  bctrl
	ctx.lr = 0x826A452C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A452C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826A4530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A4534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A4538: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826A453C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A4540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A4544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A4548 size=480
    let mut pc: u32 = 0x826A4548;
    'dispatch: loop {
        match pc {
            0x826A4548 => {
    //   block [0x826A4548..0x826A4728)
	// 826A4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A454C: 48B03C1D  bl 0x831a8168
	ctx.lr = 0x826A4550;
	sub_831A8130(ctx, base);
	// 826A4550: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A4558: 48AB00A9  bl 0x83154600
	ctx.lr = 0x826A455C;
	sub_83154600(ctx, base);
	// 826A455C: 897F0064  lbz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A4560: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826A4564: 3FA08212  lis r29, -0x7dee
	ctx.r[29].s64 = -2112749568;
	// 826A4568: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A456C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A4570: 41820038  beq 0x826a45a8
	if ctx.cr[0].eq {
	pc = 0x826A45A8; continue 'dispatch;
	}
	// 826A4574: C1BE01FC  lfs f13, 0x1fc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A4578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A457C: C01DDFB0  lfs f0, -0x2050(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A4580: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826A4584: 40990008  ble cr6, 0x826a458c
	if !ctx.cr[6].gt {
	pc = 0x826A458C; continue 'dispatch;
	}
	// 826A4588: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 826A458C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A4590: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826A4594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4598: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 826A459C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A45A0: 4E800421  bctrl
	ctx.lr = 0x826A45A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A45A4: 9B9F0064  stb r28, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u8 ) };
	// 826A45A8: C01DDFB0  lfs f0, -0x2050(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A45AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A45B0: C1BE01FC  lfs f13, 0x1fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A45B4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826A45B8: 40990008  ble cr6, 0x826a45c0
	if !ctx.cr[6].gt {
	pc = 0x826A45C0; continue 'dispatch;
	}
	// 826A45BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 826A45C0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A45C4: 4182015C  beq 0x826a4720
	if ctx.cr[0].eq {
	pc = 0x826A4720; continue 'dispatch;
	}
	// 826A45C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A45CC: 487B519D  bl 0x82e59768
	ctx.lr = 0x826A45D0;
	sub_82E59768(ctx, base);
	// 826A45D0: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A45D4: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A45D8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 826A45DC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826A45E0: C1BE01FC  lfs f13, 0x1fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A45E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826A45E8: 41990138  bgt cr6, 0x826a4720
	if ctx.cr[6].gt {
	pc = 0x826A4720; continue 'dispatch;
	}
	// 826A45EC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A45F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A45F4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 826A45F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A45FC: 4E800421  bctrl
	ctx.lr = 0x826A4600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A4600: 817E01F0  lwz r11, 0x1f0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(496 as u32) ) } as u64;
	// 826A4604: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A4608: 409A0108  bne cr6, 0x826a4710
	if !ctx.cr[6].eq {
	pc = 0x826A4710; continue 'dispatch;
	}
	// 826A460C: 817E0180  lwz r11, 0x180(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A4610: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826A4614: 419A0108  beq cr6, 0x826a471c
	if ctx.cr[6].eq {
	pc = 0x826A471C; continue 'dispatch;
	}
	// 826A4618: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A461C: 419A00E8  beq cr6, 0x826a4704
	if ctx.cr[6].eq {
	pc = 0x826A4704; continue 'dispatch;
	}
	// 826A4620: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4624: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A4628: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A462C: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 826A4630: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A4634: 4874DDB5  bl 0x82df23e8
	ctx.lr = 0x826A4638;
	sub_82DF23E8(ctx, base);
	// 826A4638: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A463C: 4182001C  beq 0x826a4658
	if ctx.cr[0].eq {
	pc = 0x826A4658; continue 'dispatch;
	}
	// 826A4640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4644: 487B82E5  bl 0x82e5c928
	ctx.lr = 0x826A4648;
	sub_82E5C928(ctx, base);
	// 826A4648: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A464C: 396B1028  addi r11, r11, 0x1028
	ctx.r[11].s64 = ctx.r[11].s64 + 4136;
	// 826A4650: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A4654: 48000008  b 0x826a465c
	pc = 0x826A465C; continue 'dispatch;
	// 826A4658: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 826A465C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A4660: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4664: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4668: 4BFFF4D1  bl 0x826a3b38
	ctx.lr = 0x826A466C;
	sub_826A3B38(ctx, base);
	// 826A466C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A4670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4674: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4678: 4BC1B989  bl 0x822c0000
	ctx.lr = 0x826A467C;
	sub_822C0000(ctx, base);
	// 826A467C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A4680: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A4684: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A4688: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826A468C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A4690: 419A0024  beq cr6, 0x826a46b4
	if ctx.cr[6].eq {
	pc = 0x826A46B4; continue 'dispatch;
	}
	// 826A4694: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A4698: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A469C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A46A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A46A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A46A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A46AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A46B0: 4082FFE8  bne 0x826a4698
	if !ctx.cr[0].eq {
	pc = 0x826A4698; continue 'dispatch;
	}
	// 826A46B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A46B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A46BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A46C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A46C4: 389E0184  addi r4, r30, 0x184
	ctx.r[4].s64 = ctx.r[30].s64 + 388;
	// 826A46C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A46CC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A46D0: 487B9FD9  bl 0x82e5e6a8
	ctx.lr = 0x826A46D4;
	sub_82E5E6A8(ctx, base);
	// 826A46D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A46D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A46DC: 419A0008  beq cr6, 0x826a46e4
	if ctx.cr[6].eq {
	pc = 0x826A46E4; continue 'dispatch;
	}
	// 826A46E0: 4BC1C1B1  bl 0x822c0890
	ctx.lr = 0x826A46E4;
	sub_822C0890(ctx, base);
	// 826A46E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A46E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A46EC: 419A0008  beq cr6, 0x826a46f4
	if ctx.cr[6].eq {
	pc = 0x826A46F4; continue 'dispatch;
	}
	// 826A46F0: 4BC1C1A1  bl 0x822c0890
	ctx.lr = 0x826A46F4;
	sub_822C0890(ctx, base);
	// 826A46F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A46F8: 419A000C  beq cr6, 0x826a4704
	if ctx.cr[6].eq {
	pc = 0x826A4704; continue 'dispatch;
	}
	// 826A46FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4700: 4BC1C191  bl 0x822c0890
	ctx.lr = 0x826A4704;
	sub_822C0890(ctx, base);
	// 826A4704: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826A4708: 917E0180  stw r11, 0x180(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 826A470C: 48000010  b 0x826a471c
	pc = 0x826A471C; continue 'dispatch;
	// 826A4710: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A4714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4718: 4BFFF5B1  bl 0x826a3cc8
	ctx.lr = 0x826A471C;
	sub_826A3CC8(ctx, base);
	// 826A471C: 9B9E01EC  stb r28, 0x1ec(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(492 as u32), ctx.r[28].u8 ) };
	// 826A4720: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826A4724: 48B03A94  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A4728 size=404
    let mut pc: u32 = 0x826A4728;
    'dispatch: loop {
        match pc {
            0x826A4728 => {
    //   block [0x826A4728..0x826A48BC)
	// 826A4728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A472C: 48B03A41  bl 0x831a816c
	ctx.lr = 0x826A4730;
	sub_831A8130(ctx, base);
	// 826A4730: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4734: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A4738: 480032A9  bl 0x826a79e0
	ctx.lr = 0x826A473C;
	sub_826A79E0(ctx, base);
	// 826A473C: 817E0184  lwz r11, 0x184(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) } as u64;
	// 826A4740: 3BBE0184  addi r29, r30, 0x184
	ctx.r[29].s64 = ctx.r[30].s64 + 388;
	// 826A4744: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A4748: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A474C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826A4750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A4754: 4E800421  bctrl
	ctx.lr = 0x826A4758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A4758: 897E01ED  lbz r11, 0x1ed(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(493 as u32) ) } as u64;
	// 826A475C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A4760: 41820148  beq 0x826a48a8
	if ctx.cr[0].eq {
	pc = 0x826A48A8; continue 'dispatch;
	}
	// 826A4764: 815E0180  lwz r10, 0x180(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) } as u64;
	// 826A4768: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 826A476C: 409A0030  bne cr6, 0x826a479c
	if !ctx.cr[6].eq {
	pc = 0x826A479C; continue 'dispatch;
	}
	// 826A4770: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826A4774: C1BE01FC  lfs f13, 0x1fc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A4778: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A477C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A4780: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826A4784: 40990008  ble cr6, 0x826a478c
	if !ctx.cr[6].gt {
	pc = 0x826A478C; continue 'dispatch;
	}
	// 826A4788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A478C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A4790: 4082000C  bne 0x826a479c
	if !ctx.cr[0].eq {
	pc = 0x826A479C; continue 'dispatch;
	}
	// 826A4794: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826A4798: 48000114  b 0x826a48ac
	pc = 0x826A48AC; continue 'dispatch;
	// 826A479C: 817E01F0  lwz r11, 0x1f0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(496 as u32) ) } as u64;
	// 826A47A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A47A4: 409A0104  bne cr6, 0x826a48a8
	if !ctx.cr[6].eq {
	pc = 0x826A48A8; continue 'dispatch;
	}
	// 826A47A8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 826A47AC: 419A0108  beq cr6, 0x826a48b4
	if ctx.cr[6].eq {
	pc = 0x826A48B4; continue 'dispatch;
	}
	// 826A47B0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 826A47B4: 419A00E8  beq cr6, 0x826a489c
	if ctx.cr[6].eq {
	pc = 0x826A489C; continue 'dispatch;
	}
	// 826A47B8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A47BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A47C0: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A47C4: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 826A47C8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A47CC: 4874DC1D  bl 0x82df23e8
	ctx.lr = 0x826A47D0;
	sub_82DF23E8(ctx, base);
	// 826A47D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826A47D4: 4182001C  beq 0x826a47f0
	if ctx.cr[0].eq {
	pc = 0x826A47F0; continue 'dispatch;
	}
	// 826A47D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A47DC: 487B814D  bl 0x82e5c928
	ctx.lr = 0x826A47E0;
	sub_82E5C928(ctx, base);
	// 826A47E0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A47E4: 396B1028  addi r11, r11, 0x1028
	ctx.r[11].s64 = ctx.r[11].s64 + 4136;
	// 826A47E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A47EC: 48000008  b 0x826a47f4
	pc = 0x826A47F4; continue 'dispatch;
	// 826A47F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826A47F4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826A47F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A47FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4800: 4BFFF339  bl 0x826a3b38
	ctx.lr = 0x826A4804;
	sub_826A3B38(ctx, base);
	// 826A4804: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A4808: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A480C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A4810: 4BC1B7F1  bl 0x822c0000
	ctx.lr = 0x826A4814;
	sub_822C0000(ctx, base);
	// 826A4814: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A4818: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A481C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A4820: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826A4824: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826A4828: 419A0024  beq cr6, 0x826a484c
	if ctx.cr[6].eq {
	pc = 0x826A484C; continue 'dispatch;
	}
	// 826A482C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826A4830: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A4834: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4838: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A483C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A4840: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A4844: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4848: 4082FFE8  bne 0x826a4830
	if !ctx.cr[0].eq {
	pc = 0x826A4830; continue 'dispatch;
	}
	// 826A484C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A4850: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826A4854: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A4858: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A485C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A4860: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A4864: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A4868: 487B9E41  bl 0x82e5e6a8
	ctx.lr = 0x826A486C;
	sub_82E5E6A8(ctx, base);
	// 826A486C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A4870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A4874: 419A0008  beq cr6, 0x826a487c
	if ctx.cr[6].eq {
	pc = 0x826A487C; continue 'dispatch;
	}
	// 826A4878: 4BC1C019  bl 0x822c0890
	ctx.lr = 0x826A487C;
	sub_822C0890(ctx, base);
	// 826A487C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A4880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A4884: 419A0008  beq cr6, 0x826a488c
	if ctx.cr[6].eq {
	pc = 0x826A488C; continue 'dispatch;
	}
	// 826A4888: 4BC1C009  bl 0x822c0890
	ctx.lr = 0x826A488C;
	sub_822C0890(ctx, base);
	// 826A488C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A4890: 419A000C  beq cr6, 0x826a489c
	if ctx.cr[6].eq {
	pc = 0x826A489C; continue 'dispatch;
	}
	// 826A4894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4898: 4BC1BFF9  bl 0x822c0890
	ctx.lr = 0x826A489C;
	sub_822C0890(ctx, base);
	// 826A489C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826A48A0: 917E0180  stw r11, 0x180(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 826A48A4: 48000010  b 0x826a48b4
	pc = 0x826A48B4; continue 'dispatch;
	// 826A48A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A48AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A48B0: 4BFFF419  bl 0x826a3cc8
	ctx.lr = 0x826A48B4;
	sub_826A3CC8(ctx, base);
	// 826A48B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826A48B8: 48B03904  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A48C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A48C0 size=928
    let mut pc: u32 = 0x826A48C0;
    'dispatch: loop {
        match pc {
            0x826A48C0 => {
    //   block [0x826A48C0..0x826A4C60)
	// 826A48C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A48C4: 48B038A5  bl 0x831a8168
	ctx.lr = 0x826A48C8;
	sub_831A8130(ctx, base);
	// 826A48C8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 826A48CC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 826A48D0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 826A48D4: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A48D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826A48DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A48E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A48E4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826A48E8: 480023D1  bl 0x826a6cb8
	ctx.lr = 0x826A48EC;
	sub_826A6CB8(ctx, base);
	// 826A48EC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A48F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A48F4: 388B10F8  addi r4, r11, 0x10f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4344;
	// 826A48F8: 4874F111  bl 0x82df3a08
	ctx.lr = 0x826A48FC;
	sub_82DF3A08(ctx, base);
	// 826A48FC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4904: 388B10EC  addi r4, r11, 0x10ec
	ctx.r[4].s64 = ctx.r[11].s64 + 4332;
	// 826A4908: 4874F101  bl 0x82df3a08
	ctx.lr = 0x826A490C;
	sub_82DF3A08(ctx, base);
	// 826A490C: 38BF0109  addi r5, r31, 0x109
	ctx.r[5].s64 = ctx.r[31].s64 + 265;
	// 826A4910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4914: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A4918: 4BEFE739  bl 0x825a3050
	ctx.lr = 0x826A491C;
	sub_825A3050(ctx, base);
	// 826A491C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A4920: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A4924: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4928: 4BEFD861  bl 0x825a2188
	ctx.lr = 0x826A492C;
	sub_825A2188(ctx, base);
	// 826A492C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A4930: 4874EAF9  bl 0x82df3428
	ctx.lr = 0x826A4934;
	sub_82DF3428(ctx, base);
	// 826A4934: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A4938: 4BC24381  bl 0x822c8cb8
	ctx.lr = 0x826A493C;
	sub_822C8CB8(ctx, base);
	// 826A493C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4940: 4874EAE9  bl 0x82df3428
	ctx.lr = 0x826A4944;
	sub_82DF3428(ctx, base);
	// 826A4944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4948: 4874EAE1  bl 0x82df3428
	ctx.lr = 0x826A494C;
	sub_82DF3428(ctx, base);
	// 826A494C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4950: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A4954: 388B1050  addi r4, r11, 0x1050
	ctx.r[4].s64 = ctx.r[11].s64 + 4176;
	// 826A4958: 38A0009D  li r5, 0x9d
	ctx.r[5].s64 = 157;
	// 826A495C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826A4960: 4BC1BA79  bl 0x822c03d8
	ctx.lr = 0x826A4964;
	sub_822C03D8(ctx, base);
	// 826A4964: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A4968: 41820034  beq 0x826a499c
	if ctx.cr[0].eq {
	pc = 0x826A499C; continue 'dispatch;
	}
	// 826A496C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4974: 388B1CAC  addi r4, r11, 0x1cac
	ctx.r[4].s64 = ctx.r[11].s64 + 7340;
	// 826A4978: 4874F091  bl 0x82df3a08
	ctx.lr = 0x826A497C;
	sub_82DF3A08(ctx, base);
	// 826A497C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A4980: 38BF010C  addi r5, r31, 0x10c
	ctx.r[5].s64 = ctx.r[31].s64 + 268;
	// 826A4984: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4988: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A498C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826A4990: 4BF07A81  bl 0x825ac410
	ctx.lr = 0x826A4994;
	sub_825AC410(ctx, base);
	// 826A4994: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826A4998: 48000008  b 0x826a49a0
	pc = 0x826A49A0; continue 'dispatch;
	// 826A499C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826A49A0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 826A49A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A49A8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826A49AC: 4BE4EA0D  bl 0x824f33b8
	ctx.lr = 0x826A49B0;
	sub_824F33B8(ctx, base);
	// 826A49B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826A49B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A49B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826A49BC: 4BC1B645  bl 0x822c0000
	ctx.lr = 0x826A49C0;
	sub_822C0000(ctx, base);
	// 826A49C0: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A49C4: 4182000C  beq 0x826a49d0
	if ctx.cr[0].eq {
	pc = 0x826A49D0; continue 'dispatch;
	}
	// 826A49C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A49CC: 4874EA5D  bl 0x82df3428
	ctx.lr = 0x826A49D0;
	sub_82DF3428(ctx, base);
	// 826A49D0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A49D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A49D8: 388BC578  addi r4, r11, -0x3a88
	ctx.r[4].s64 = ctx.r[11].s64 + -14984;
	// 826A49DC: 4874F02D  bl 0x82df3a08
	ctx.lr = 0x826A49E0;
	sub_82DF3A08(ctx, base);
	// 826A49E0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826A49E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A49E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A49EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A49F0: 4BF073D1  bl 0x825abdc0
	ctx.lr = 0x826A49F4;
	sub_825ABDC0(ctx, base);
	// 826A49F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A49F8: 4874EA31  bl 0x82df3428
	ctx.lr = 0x826A49FC;
	sub_82DF3428(ctx, base);
	// 826A49FC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4A04: 388B10E0  addi r4, r11, 0x10e0
	ctx.r[4].s64 = ctx.r[11].s64 + 4320;
	// 826A4A08: 4874F001  bl 0x82df3a08
	ctx.lr = 0x826A4A0C;
	sub_82DF3A08(ctx, base);
	// 826A4A0C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A4A10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A4A14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826A4A18: 4BF073A9  bl 0x825abdc0
	ctx.lr = 0x826A4A1C;
	sub_825ABDC0(ctx, base);
	// 826A4A1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4A20: 4874EA09  bl 0x82df3428
	ctx.lr = 0x826A4A24;
	sub_82DF3428(ctx, base);
	// 826A4A24: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4A28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4A2C: 388B0F8C  addi r4, r11, 0xf8c
	ctx.r[4].s64 = ctx.r[11].s64 + 3980;
	// 826A4A30: 4874EFD9  bl 0x82df3a08
	ctx.lr = 0x826A4A34;
	sub_82DF3A08(ctx, base);
	// 826A4A34: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A4A38: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 826A4A3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A4A40: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826A4A44: 419A0024  beq cr6, 0x826a4a68
	if ctx.cr[6].eq {
	pc = 0x826A4A68; continue 'dispatch;
	}
	// 826A4A48: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826A4A4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A4A50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4A54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A4A58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A4A5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A4A60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A4A64: 4082FFE8  bne 0x826a4a4c
	if !ctx.cr[0].eq {
	pc = 0x826A4A4C; continue 'dispatch;
	}
	// 826A4A68: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826A4A6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4A74: 4BEFD69D  bl 0x825a2110
	ctx.lr = 0x826A4A78;
	sub_825A2110(ctx, base);
	// 826A4A78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4A7C: 4874E9AD  bl 0x82df3428
	ctx.lr = 0x826A4A80;
	sub_82DF3428(ctx, base);
	// 826A4A80: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4A84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4A88: 388B10CC  addi r4, r11, 0x10cc
	ctx.r[4].s64 = ctx.r[11].s64 + 4300;
	// 826A4A8C: 4874EF7D  bl 0x82df3a08
	ctx.lr = 0x826A4A90;
	sub_82DF3A08(ctx, base);
	// 826A4A90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4A94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4A98: 388B5D5C  addi r4, r11, 0x5d5c
	ctx.r[4].s64 = ctx.r[11].s64 + 23900;
	// 826A4A9C: 4874EF6D  bl 0x82df3a08
	ctx.lr = 0x826A4AA0;
	sub_82DF3A08(ctx, base);
	// 826A4AA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A4AA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826A4AA8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A4AAC: 38BF0110  addi r5, r31, 0x110
	ctx.r[5].s64 = ctx.r[31].s64 + 272;
	// 826A4AB0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A4AB4: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A4AB8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826A4ABC: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A4AC0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A4AC4: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826A4AC8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A4ACC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826A4AD0: 4BF08FE9  bl 0x825adab8
	ctx.lr = 0x826A4AD4;
	sub_825ADAB8(ctx, base);
	// 826A4AD4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A4AD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4AE0: 4BEFCB71  bl 0x825a1650
	ctx.lr = 0x826A4AE4;
	sub_825A1650(ctx, base);
	// 826A4AE4: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826A4AE8: 4874E941  bl 0x82df3428
	ctx.lr = 0x826A4AEC;
	sub_82DF3428(ctx, base);
	// 826A4AEC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826A4AF0: 4BC241C9  bl 0x822c8cb8
	ctx.lr = 0x826A4AF4;
	sub_822C8CB8(ctx, base);
	// 826A4AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4AF8: 4874E931  bl 0x82df3428
	ctx.lr = 0x826A4AFC;
	sub_82DF3428(ctx, base);
	// 826A4AFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4B00: 4874E929  bl 0x82df3428
	ctx.lr = 0x826A4B04;
	sub_82DF3428(ctx, base);
	// 826A4B04: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4B08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4B0C: 388B10B8  addi r4, r11, 0x10b8
	ctx.r[4].s64 = ctx.r[11].s64 + 4280;
	// 826A4B10: 4874EEF9  bl 0x82df3a08
	ctx.lr = 0x826A4B14;
	sub_82DF3A08(ctx, base);
	// 826A4B14: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4B1C: 388B0F78  addi r4, r11, 0xf78
	ctx.r[4].s64 = ctx.r[11].s64 + 3960;
	// 826A4B20: 4874EEE9  bl 0x82df3a08
	ctx.lr = 0x826A4B24;
	sub_82DF3A08(ctx, base);
	// 826A4B24: 38BF0114  addi r5, r31, 0x114
	ctx.r[5].s64 = ctx.r[31].s64 + 276;
	// 826A4B28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A4B2C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A4B30: 4BEFE521  bl 0x825a3050
	ctx.lr = 0x826A4B34;
	sub_825A3050(ctx, base);
	// 826A4B34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A4B38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4B40: 4BEFD649  bl 0x825a2188
	ctx.lr = 0x826A4B44;
	sub_825A2188(ctx, base);
	// 826A4B44: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826A4B48: 4874E8E1  bl 0x82df3428
	ctx.lr = 0x826A4B4C;
	sub_82DF3428(ctx, base);
	// 826A4B4C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826A4B50: 4BC24169  bl 0x822c8cb8
	ctx.lr = 0x826A4B54;
	sub_822C8CB8(ctx, base);
	// 826A4B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4B58: 4874E8D1  bl 0x82df3428
	ctx.lr = 0x826A4B5C;
	sub_82DF3428(ctx, base);
	// 826A4B5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4B60: 4874E8C9  bl 0x82df3428
	ctx.lr = 0x826A4B64;
	sub_82DF3428(ctx, base);
	// 826A4B64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4B68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4B6C: 388BF80C  addi r4, r11, -0x7f4
	ctx.r[4].s64 = ctx.r[11].s64 + -2036;
	// 826A4B70: 4874EE99  bl 0x82df3a08
	ctx.lr = 0x826A4B74;
	sub_82DF3A08(ctx, base);
	// 826A4B74: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4B78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4B7C: 388B0F6C  addi r4, r11, 0xf6c
	ctx.r[4].s64 = ctx.r[11].s64 + 3948;
	// 826A4B80: 4874EE89  bl 0x82df3a08
	ctx.lr = 0x826A4B84;
	sub_82DF3A08(ctx, base);
	// 826A4B84: 38BF0118  addi r5, r31, 0x118
	ctx.r[5].s64 = ctx.r[31].s64 + 280;
	// 826A4B88: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A4B8C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826A4B90: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826A4B94: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826A4B98: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826A4B9C: 4BF08F1D  bl 0x825adab8
	ctx.lr = 0x826A4BA0;
	sub_825ADAB8(ctx, base);
	// 826A4BA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A4BA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4BA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4BAC: 4BEFCAA5  bl 0x825a1650
	ctx.lr = 0x826A4BB0;
	sub_825A1650(ctx, base);
	// 826A4BB0: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826A4BB4: 4874E875  bl 0x82df3428
	ctx.lr = 0x826A4BB8;
	sub_82DF3428(ctx, base);
	// 826A4BB8: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826A4BBC: 4BC240FD  bl 0x822c8cb8
	ctx.lr = 0x826A4BC0;
	sub_822C8CB8(ctx, base);
	// 826A4BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4BC4: 4874E865  bl 0x82df3428
	ctx.lr = 0x826A4BC8;
	sub_82DF3428(ctx, base);
	// 826A4BC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4BCC: 4874E85D  bl 0x82df3428
	ctx.lr = 0x826A4BD0;
	sub_82DF3428(ctx, base);
	// 826A4BD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4BD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4BD8: 388B03DC  addi r4, r11, 0x3dc
	ctx.r[4].s64 = ctx.r[11].s64 + 988;
	// 826A4BDC: 4874EE2D  bl 0x82df3a08
	ctx.lr = 0x826A4BE0;
	sub_82DF3A08(ctx, base);
	// 826A4BE0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4BE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4BE8: 388B0F60  addi r4, r11, 0xf60
	ctx.r[4].s64 = ctx.r[11].s64 + 3936;
	// 826A4BEC: 4874EE1D  bl 0x82df3a08
	ctx.lr = 0x826A4BF0;
	sub_82DF3A08(ctx, base);
	// 826A4BF0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826A4BF4: 38E003E8  li r7, 0x3e8
	ctx.r[7].s64 = 1000;
	// 826A4BF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A4BFC: 38BF011C  addi r5, r31, 0x11c
	ctx.r[5].s64 = ctx.r[31].s64 + 284;
	// 826A4C00: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A4C04: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 826A4C08: 4BF08F89  bl 0x825adb90
	ctx.lr = 0x826A4C0C;
	sub_825ADB90(ctx, base);
	// 826A4C0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A4C10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4C18: 4BEFCF29  bl 0x825a1b40
	ctx.lr = 0x826A4C1C;
	sub_825A1B40(ctx, base);
	// 826A4C1C: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 826A4C20: 4874E809  bl 0x82df3428
	ctx.lr = 0x826A4C24;
	sub_82DF3428(ctx, base);
	// 826A4C24: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826A4C28: 4BC24091  bl 0x822c8cb8
	ctx.lr = 0x826A4C2C;
	sub_822C8CB8(ctx, base);
	// 826A4C2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4C30: 4874E7F9  bl 0x82df3428
	ctx.lr = 0x826A4C34;
	sub_82DF3428(ctx, base);
	// 826A4C34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A4C38: 4874E7F1  bl 0x82df3428
	ctx.lr = 0x826A4C3C;
	sub_82DF3428(ctx, base);
	// 826A4C3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A4C40: 419A000C  beq cr6, 0x826a4c4c
	if ctx.cr[6].eq {
	pc = 0x826A4C4C; continue 'dispatch;
	}
	// 826A4C44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A4C48: 4BC1BC49  bl 0x822c0890
	ctx.lr = 0x826A4C4C;
	sub_822C0890(ctx, base);
	// 826A4C4C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 826A4C50: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 826A4C54: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826A4C58: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826A4C5C: 48B0355C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A4C60 size=140
    let mut pc: u32 = 0x826A4C60;
    'dispatch: loop {
        match pc {
            0x826A4C60 => {
    //   block [0x826A4C60..0x826A4CEC)
	// 826A4C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A4C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A4C68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A4C6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A4C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4C74: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A4C7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A4C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4C84: 388B1104  addi r4, r11, 0x1104
	ctx.r[4].s64 = ctx.r[11].s64 + 4356;
	// 826A4C88: 4874ED81  bl 0x82df3a08
	ctx.lr = 0x826A4C8C;
	sub_82DF3A08(ctx, base);
	// 826A4C8C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A4C90: 38BF0180  addi r5, r31, 0x180
	ctx.r[5].s64 = ctx.r[31].s64 + 384;
	// 826A4C94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A4C98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4C9C: 4BFDACE5  bl 0x8267f980
	ctx.lr = 0x826A4CA0;
	sub_8267F980(ctx, base);
	// 826A4CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4CA4: 4874E785  bl 0x82df3428
	ctx.lr = 0x826A4CA8;
	sub_82DF3428(ctx, base);
	// 826A4CA8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4CAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4CB0: 388B0F6C  addi r4, r11, 0xf6c
	ctx.r[4].s64 = ctx.r[11].s64 + 3948;
	// 826A4CB4: 4874ED55  bl 0x82df3a08
	ctx.lr = 0x826A4CB8;
	sub_82DF3A08(ctx, base);
	// 826A4CB8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A4CBC: 38BF01FC  addi r5, r31, 0x1fc
	ctx.r[5].s64 = ctx.r[31].s64 + 508;
	// 826A4CC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A4CC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4CC8: 4BE681D9  bl 0x8250cea0
	ctx.lr = 0x826A4CCC;
	sub_8250CEA0(ctx, base);
	// 826A4CCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4CD0: 4874E759  bl 0x82df3428
	ctx.lr = 0x826A4CD4;
	sub_82DF3428(ctx, base);
	// 826A4CD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A4CD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A4CDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A4CE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A4CE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A4CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A4CF0 size=88
    let mut pc: u32 = 0x826A4CF0;
    'dispatch: loop {
        match pc {
            0x826A4CF0 => {
    //   block [0x826A4CF0..0x826A4D48)
	// 826A4CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A4CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A4CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A4CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A4D00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4D04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A4D08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A4D0C: 48041175  bl 0x826e5e80
	ctx.lr = 0x826A4D10;
	sub_826E5E80(ctx, base);
	// 826A4D10: 897E01ED  lbz r11, 0x1ed(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(493 as u32) ) } as u64;
	// 826A4D14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A4D18: 41820018  beq 0x826a4d30
	if ctx.cr[0].eq {
	pc = 0x826A4D30; continue 'dispatch;
	}
	// 826A4D1C: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 826A4D20: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826A4D24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4D28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826A4D2C: 4BE104AD  bl 0x824b51d8
	ctx.lr = 0x826A4D30;
	sub_824B51D8(ctx, base);
	// 826A4D30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A4D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A4D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A4D3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A4D40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A4D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A4D48 size=332
    let mut pc: u32 = 0x826A4D48;
    'dispatch: loop {
        match pc {
            0x826A4D48 => {
    //   block [0x826A4D48..0x826A4E94)
	// 826A4D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A4D4C: 48B0341D  bl 0x831a8168
	ctx.lr = 0x826A4D50;
	sub_831A8130(ctx, base);
	// 826A4D50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4D54: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826A4D58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A4D5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A4D60: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A4D64: 41820038  beq 0x826a4d9c
	if ctx.cr[0].eq {
	pc = 0x826A4D9C; continue 'dispatch;
	}
	// 826A4D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4D6C: 48B04C1D  bl 0x831a9988
	ctx.lr = 0x826A4D70;
	sub_831A9988(ctx, base);
	// 826A4D70: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A4D74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A4D78: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 826A4D7C: 48B0337D  bl 0x831a80f8
	ctx.lr = 0x826A4D80;
	sub_831A80F8(ctx, base);
	// 826A4D80: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A4D84: 41820018  beq 0x826a4d9c
	if ctx.cr[0].eq {
	pc = 0x826A4D9C; continue 'dispatch;
	}
	// 826A4D88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4D8C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A4D90: 4BFFF219  bl 0x826a3fa8
	ctx.lr = 0x826A4D94;
	sub_826A3FA8(ctx, base);
	// 826A4D94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826A4D98: 480000F4  b 0x826a4e8c
	pc = 0x826A4E8C; continue 'dispatch;
	// 826A4D9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A4DA0: 419A00DC  beq cr6, 0x826a4e7c
	if ctx.cr[6].eq {
	pc = 0x826A4E7C; continue 'dispatch;
	}
	// 826A4DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4DA8: 48B04BE1  bl 0x831a9988
	ctx.lr = 0x826A4DAC;
	sub_831A9988(ctx, base);
	// 826A4DAC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A4DB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A4DB4: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 826A4DB8: 48B03341  bl 0x831a80f8
	ctx.lr = 0x826A4DBC;
	sub_831A80F8(ctx, base);
	// 826A4DBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A4DC0: 41820014  beq 0x826a4dd4
	if ctx.cr[0].eq {
	pc = 0x826A4DD4; continue 'dispatch;
	}
	// 826A4DC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4DC8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A4DCC: 4BFFF415  bl 0x826a41e0
	ctx.lr = 0x826A4DD0;
	sub_826A41E0(ctx, base);
	// 826A4DD0: 4BFFFFC4  b 0x826a4d94
	pc = 0x826A4D94; continue 'dispatch;
	// 826A4DD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A4DD8: 419A00A4  beq cr6, 0x826a4e7c
	if ctx.cr[6].eq {
	pc = 0x826A4E7C; continue 'dispatch;
	}
	// 826A4DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4DE0: 48B04BA9  bl 0x831a9988
	ctx.lr = 0x826A4DE4;
	sub_831A9988(ctx, base);
	// 826A4DE4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 826A4DE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A4DEC: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 826A4DF0: 48B03309  bl 0x831a80f8
	ctx.lr = 0x826A4DF4;
	sub_831A80F8(ctx, base);
	// 826A4DF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A4DF8: 41820014  beq 0x826a4e0c
	if ctx.cr[0].eq {
	pc = 0x826A4E0C; continue 'dispatch;
	}
	// 826A4DFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4E00: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A4E04: 4BFFF40D  bl 0x826a4210
	ctx.lr = 0x826A4E08;
	sub_826A4210(ctx, base);
	// 826A4E08: 4BFFFF8C  b 0x826a4d94
	pc = 0x826A4D94; continue 'dispatch;
	// 826A4E0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A4E10: 419A006C  beq cr6, 0x826a4e7c
	if ctx.cr[6].eq {
	pc = 0x826A4E7C; continue 'dispatch;
	}
	// 826A4E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4E18: 48B04B71  bl 0x831a9988
	ctx.lr = 0x826A4E1C;
	sub_831A9988(ctx, base);
	// 826A4E1C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A4E20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A4E24: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826A4E28: 48B032D1  bl 0x831a80f8
	ctx.lr = 0x826A4E2C;
	sub_831A80F8(ctx, base);
	// 826A4E2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A4E30: 41820014  beq 0x826a4e44
	if ctx.cr[0].eq {
	pc = 0x826A4E44; continue 'dispatch;
	}
	// 826A4E34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4E38: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A4E3C: 4BFFFEB5  bl 0x826a4cf0
	ctx.lr = 0x826A4E40;
	sub_826A4CF0(ctx, base);
	// 826A4E40: 4BFFFF54  b 0x826a4d94
	pc = 0x826A4D94; continue 'dispatch;
	// 826A4E44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A4E48: 419A0034  beq cr6, 0x826a4e7c
	if ctx.cr[6].eq {
	pc = 0x826A4E7C; continue 'dispatch;
	}
	// 826A4E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4E50: 48B04B39  bl 0x831a9988
	ctx.lr = 0x826A4E54;
	sub_831A9988(ctx, base);
	// 826A4E54: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A4E58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A4E5C: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826A4E60: 48B03299  bl 0x831a80f8
	ctx.lr = 0x826A4E64;
	sub_831A80F8(ctx, base);
	// 826A4E64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A4E68: 41820014  beq 0x826a4e7c
	if ctx.cr[0].eq {
	pc = 0x826A4E7C; continue 'dispatch;
	}
	// 826A4E6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4E70: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A4E74: 4BFFF42D  bl 0x826a42a0
	ctx.lr = 0x826A4E78;
	sub_826A42A0(ctx, base);
	// 826A4E78: 4BFFFF1C  b 0x826a4d94
	pc = 0x826A4D94; continue 'dispatch;
	// 826A4E7C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826A4E80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A4E84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A4E88: 48002A41  bl 0x826a78c8
	ctx.lr = 0x826A4E8C;
	sub_826A78C8(ctx, base);
	// 826A4E8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A4E90: 48B03328  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A4E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A4E98 size=2524
    let mut pc: u32 = 0x826A4E98;
    'dispatch: loop {
        match pc {
            0x826A4E98 => {
    //   block [0x826A4E98..0x826A5874)
	// 826A4E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A4E9C: 48B032A9  bl 0x831a8144
	ctx.lr = 0x826A4EA0;
	sub_831A8130(ctx, base);
	// 826A4EA0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A4EA4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826A4EA8: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 826A4EAC: 3A6B4A98  addi r19, r11, 0x4a98
	ctx.r[19].s64 = ctx.r[11].s64 + 19096;
	// 826A4EB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A4EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4EB8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 826A4EBC: 4874EB4D  bl 0x82df3a08
	ctx.lr = 0x826A4EC0;
	sub_82DF3A08(ctx, base);
	// 826A4EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4EC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4EC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4ECC: 4BEFC6BD  bl 0x825a1588
	ctx.lr = 0x826A4ED0;
	sub_825A1588(ctx, base);
	// 826A4ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4ED4: 4874E555  bl 0x82df3428
	ctx.lr = 0x826A4ED8;
	sub_82DF3428(ctx, base);
	// 826A4ED8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4EE0: 3B8B132C  addi r28, r11, 0x132c
	ctx.r[28].s64 = ctx.r[11].s64 + 4908;
	// 826A4EE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A4EE8: 4874EB21  bl 0x82df3a08
	ctx.lr = 0x826A4EEC;
	sub_82DF3A08(ctx, base);
	// 826A4EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4EF0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4EF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4EF8: 4BEFC691  bl 0x825a1588
	ctx.lr = 0x826A4EFC;
	sub_825A1588(ctx, base);
	// 826A4EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F00: 4874E529  bl 0x82df3428
	ctx.lr = 0x826A4F04;
	sub_82DF3428(ctx, base);
	// 826A4F04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4F08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F0C: 3B6B1310  addi r27, r11, 0x1310
	ctx.r[27].s64 = ctx.r[11].s64 + 4880;
	// 826A4F10: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A4F14: 4874EAF5  bl 0x82df3a08
	ctx.lr = 0x826A4F18;
	sub_82DF3A08(ctx, base);
	// 826A4F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4F1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4F20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4F24: 4BEFC665  bl 0x825a1588
	ctx.lr = 0x826A4F28;
	sub_825A1588(ctx, base);
	// 826A4F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F2C: 4874E4FD  bl 0x82df3428
	ctx.lr = 0x826A4F30;
	sub_82DF3428(ctx, base);
	// 826A4F30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F38: 3BCBFD08  addi r30, r11, -0x2f8
	ctx.r[30].s64 = ctx.r[11].s64 + -760;
	// 826A4F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A4F40: 4874EAC9  bl 0x82df3a08
	ctx.lr = 0x826A4F44;
	sub_82DF3A08(ctx, base);
	// 826A4F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4F48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4F4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4F50: 4BEFC639  bl 0x825a1588
	ctx.lr = 0x826A4F54;
	sub_825A1588(ctx, base);
	// 826A4F54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F58: 4874E4D1  bl 0x82df3428
	ctx.lr = 0x826A4F5C;
	sub_82DF3428(ctx, base);
	// 826A4F5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A4F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F64: 3B0B4370  addi r24, r11, 0x4370
	ctx.r[24].s64 = ctx.r[11].s64 + 17264;
	// 826A4F68: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A4F6C: 4874EA9D  bl 0x82df3a08
	ctx.lr = 0x826A4F70;
	sub_82DF3A08(ctx, base);
	// 826A4F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4F74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4F78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4F7C: 4BEFC60D  bl 0x825a1588
	ctx.lr = 0x826A4F80;
	sub_825A1588(ctx, base);
	// 826A4F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F84: 4874E4A5  bl 0x82df3428
	ctx.lr = 0x826A4F88;
	sub_82DF3428(ctx, base);
	// 826A4F88: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4F90: 3B2BD2D0  addi r25, r11, -0x2d30
	ctx.r[25].s64 = ctx.r[11].s64 + -11568;
	// 826A4F94: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A4F98: 4874EA71  bl 0x82df3a08
	ctx.lr = 0x826A4F9C;
	sub_82DF3A08(ctx, base);
	// 826A4F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4FA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4FA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4FA8: 4BEFC5E1  bl 0x825a1588
	ctx.lr = 0x826A4FAC;
	sub_825A1588(ctx, base);
	// 826A4FAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4FB0: 4874E479  bl 0x82df3428
	ctx.lr = 0x826A4FB4;
	sub_82DF3428(ctx, base);
	// 826A4FB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4FBC: 3AEB1160  addi r23, r11, 0x1160
	ctx.r[23].s64 = ctx.r[11].s64 + 4448;
	// 826A4FC0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A4FC4: 4874EA45  bl 0x82df3a08
	ctx.lr = 0x826A4FC8;
	sub_82DF3A08(ctx, base);
	// 826A4FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4FCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4FD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A4FD4: 4BEFC5B5  bl 0x825a1588
	ctx.lr = 0x826A4FD8;
	sub_825A1588(ctx, base);
	// 826A4FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4FDC: 4874E44D  bl 0x82df3428
	ctx.lr = 0x826A4FE0;
	sub_82DF3428(ctx, base);
	// 826A4FE0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A4FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A4FE8: 3B4B1154  addi r26, r11, 0x1154
	ctx.r[26].s64 = ctx.r[11].s64 + 4436;
	// 826A4FEC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A4FF0: 4874EA19  bl 0x82df3a08
	ctx.lr = 0x826A4FF4;
	sub_82DF3A08(ctx, base);
	// 826A4FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A4FF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A4FFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A5000: 4BEFC589  bl 0x825a1588
	ctx.lr = 0x826A5004;
	sub_825A1588(ctx, base);
	// 826A5004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5008: 4874E421  bl 0x82df3428
	ctx.lr = 0x826A500C;
	sub_82DF3428(ctx, base);
	// 826A500C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A5010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5014: 3BABD2E8  addi r29, r11, -0x2d18
	ctx.r[29].s64 = ctx.r[11].s64 + -11544;
	// 826A5018: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A501C: 4874E9ED  bl 0x82df3a08
	ctx.lr = 0x826A5020;
	sub_82DF3A08(ctx, base);
	// 826A5020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5024: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A5028: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A502C: 4BEFC55D  bl 0x825a1588
	ctx.lr = 0x826A5030;
	sub_825A1588(ctx, base);
	// 826A5030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5034: 4874E3F5  bl 0x82df3428
	ctx.lr = 0x826A5038;
	sub_82DF3428(ctx, base);
	// 826A5038: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A503C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5040: 3AAB114C  addi r21, r11, 0x114c
	ctx.r[21].s64 = ctx.r[11].s64 + 4428;
	// 826A5044: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826A5048: 4874E9C1  bl 0x82df3a08
	ctx.lr = 0x826A504C;
	sub_82DF3A08(ctx, base);
	// 826A504C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5050: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A5054: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A5058: 4BEFC531  bl 0x825a1588
	ctx.lr = 0x826A505C;
	sub_825A1588(ctx, base);
	// 826A505C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5060: 4874E3C9  bl 0x82df3428
	ctx.lr = 0x826A5064;
	sub_82DF3428(ctx, base);
	// 826A5064: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A5068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A506C: 3A8B113C  addi r20, r11, 0x113c
	ctx.r[20].s64 = ctx.r[11].s64 + 4412;
	// 826A5070: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 826A5074: 4874E995  bl 0x82df3a08
	ctx.lr = 0x826A5078;
	sub_82DF3A08(ctx, base);
	// 826A5078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A507C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A5080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A5084: 4BEFC505  bl 0x825a1588
	ctx.lr = 0x826A5088;
	sub_825A1588(ctx, base);
	// 826A5088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A508C: 4874E39D  bl 0x82df3428
	ctx.lr = 0x826A5090;
	sub_82DF3428(ctx, base);
	// 826A5090: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 826A5094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5098: 4874E971  bl 0x82df3a08
	ctx.lr = 0x826A509C;
	sub_82DF3A08(ctx, base);
	// 826A509C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A50A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A50A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A50A8: 4BEFC4E1  bl 0x825a1588
	ctx.lr = 0x826A50AC;
	sub_825A1588(ctx, base);
	// 826A50AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A50B0: 4874E379  bl 0x82df3428
	ctx.lr = 0x826A50B4;
	sub_82DF3428(ctx, base);
	// 826A50B4: 81760064  lwz r11, 0x64(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A50B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826A50BC: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 826A50C0: 419907AC  bgt cr6, 0x826a586c
	if ctx.cr[6].gt {
	pc = 0x826A586C; continue 'dispatch;
	}
	// 826A50C4: 3D808205  lis r12, -0x7dfb
	ctx.r[12].s64 = -2113601536;
	// 826A50C8: 398C1118  addi r12, r12, 0x1118
	ctx.r[12].s64 = ctx.r[12].s64 + 4376;
	// 826A50CC: 5560083C  slwi r0, r11, 1
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 826A50D0: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 826A50D4: 3D80826A  lis r12, -0x7d96
	ctx.r[12].s64 = -2106982400;
	// 826A50D8: 398C50EC  addi r12, r12, 0x50ec
	ctx.r[12].s64 = ctx.r[12].s64 + 20716;
	// 826A50DC: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 826A50E0: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 826A50E4: 60000000  nop
	// 826A50E8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 826A50EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A50F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A50F4: 4874E915  bl 0x82df3a08
	ctx.lr = 0x826A50F8;
	sub_82DF3A08(ctx, base);
	// 826A50F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A50FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A5100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5104: 4BEFC485  bl 0x825a1588
	ctx.lr = 0x826A5108;
	sub_825A1588(ctx, base);
	// 826A5108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A510C: 4874E31D  bl 0x82df3428
	ctx.lr = 0x826A5110;
	sub_82DF3428(ctx, base);
	// 826A5110: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A5114: 386100BC  addi r3, r1, 0xbc
	ctx.r[3].s64 = ctx.r[1].s64 + 188;
	// 826A5118: 4874E8F1  bl 0x82df3a08
	ctx.lr = 0x826A511C;
	sub_82DF3A08(ctx, base);
	// 826A511C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5120: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 826A5124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5128: 4BEFC461  bl 0x825a1588
	ctx.lr = 0x826A512C;
	sub_825A1588(ctx, base);
	// 826A512C: 386100BC  addi r3, r1, 0xbc
	ctx.r[3].s64 = ctx.r[1].s64 + 188;
	// 826A5130: 4874E2F9  bl 0x82df3428
	ctx.lr = 0x826A5134;
	sub_82DF3428(ctx, base);
	// 826A5134: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A5138: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826A513C: 4874E8CD  bl 0x82df3a08
	ctx.lr = 0x826A5140;
	sub_82DF3A08(ctx, base);
	// 826A5140: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5144: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 826A5148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A514C: 4BEFC43D  bl 0x825a1588
	ctx.lr = 0x826A5150;
	sub_825A1588(ctx, base);
	// 826A5150: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826A5154: 4874E2D5  bl 0x82df3428
	ctx.lr = 0x826A5158;
	sub_82DF3428(ctx, base);
	// 826A5158: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A515C: 38610114  addi r3, r1, 0x114
	ctx.r[3].s64 = ctx.r[1].s64 + 276;
	// 826A5160: 4874E8A9  bl 0x82df3a08
	ctx.lr = 0x826A5164;
	sub_82DF3A08(ctx, base);
	// 826A5164: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5168: 38810114  addi r4, r1, 0x114
	ctx.r[4].s64 = ctx.r[1].s64 + 276;
	// 826A516C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5170: 4BEFC419  bl 0x825a1588
	ctx.lr = 0x826A5174;
	sub_825A1588(ctx, base);
	// 826A5174: 38610114  addi r3, r1, 0x114
	ctx.r[3].s64 = ctx.r[1].s64 + 276;
	// 826A5178: 4874E2B1  bl 0x82df3428
	ctx.lr = 0x826A517C;
	sub_82DF3428(ctx, base);
	// 826A517C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5180: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826A5184: 4874E885  bl 0x82df3a08
	ctx.lr = 0x826A5188;
	sub_82DF3A08(ctx, base);
	// 826A5188: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A518C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 826A5190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5194: 4BEFC3F5  bl 0x825a1588
	ctx.lr = 0x826A5198;
	sub_825A1588(ctx, base);
	// 826A5198: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826A519C: 4874E28D  bl 0x82df3428
	ctx.lr = 0x826A51A0;
	sub_82DF3428(ctx, base);
	// 826A51A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A51A4: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 826A51A8: 4874E861  bl 0x82df3a08
	ctx.lr = 0x826A51AC;
	sub_82DF3A08(ctx, base);
	// 826A51AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A51B0: 388100C4  addi r4, r1, 0xc4
	ctx.r[4].s64 = ctx.r[1].s64 + 196;
	// 826A51B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A51B8: 4BEFC3D1  bl 0x825a1588
	ctx.lr = 0x826A51BC;
	sub_825A1588(ctx, base);
	// 826A51BC: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 826A51C0: 480006A8  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A51C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A51C8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 826A51CC: 4874E83D  bl 0x82df3a08
	ctx.lr = 0x826A51D0;
	sub_82DF3A08(ctx, base);
	// 826A51D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A51D4: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 826A51D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A51DC: 4BEFC3AD  bl 0x825a1588
	ctx.lr = 0x826A51E0;
	sub_825A1588(ctx, base);
	// 826A51E0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 826A51E4: 4874E245  bl 0x82df3428
	ctx.lr = 0x826A51E8;
	sub_82DF3428(ctx, base);
	// 826A51E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A51EC: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 826A51F0: 4874E819  bl 0x82df3a08
	ctx.lr = 0x826A51F4;
	sub_82DF3A08(ctx, base);
	// 826A51F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A51F8: 388100F4  addi r4, r1, 0xf4
	ctx.r[4].s64 = ctx.r[1].s64 + 244;
	// 826A51FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5200: 4BEFC389  bl 0x825a1588
	ctx.lr = 0x826A5204;
	sub_825A1588(ctx, base);
	// 826A5204: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 826A5208: 4874E221  bl 0x82df3428
	ctx.lr = 0x826A520C;
	sub_82DF3428(ctx, base);
	// 826A520C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A5210: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 826A5214: 4874E7F5  bl 0x82df3a08
	ctx.lr = 0x826A5218;
	sub_82DF3A08(ctx, base);
	// 826A5218: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A521C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 826A5220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5224: 4BEFC365  bl 0x825a1588
	ctx.lr = 0x826A5228;
	sub_825A1588(ctx, base);
	// 826A5228: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 826A522C: 4874E1FD  bl 0x82df3428
	ctx.lr = 0x826A5230;
	sub_82DF3428(ctx, base);
	// 826A5230: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A5234: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 826A5238: 4874E7D1  bl 0x82df3a08
	ctx.lr = 0x826A523C;
	sub_82DF3A08(ctx, base);
	// 826A523C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5240: 388100CC  addi r4, r1, 0xcc
	ctx.r[4].s64 = ctx.r[1].s64 + 204;
	// 826A5244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5248: 4BEFC341  bl 0x825a1588
	ctx.lr = 0x826A524C;
	sub_825A1588(ctx, base);
	// 826A524C: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 826A5250: 4874E1D9  bl 0x82df3428
	ctx.lr = 0x826A5254;
	sub_82DF3428(ctx, base);
	// 826A5254: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A5258: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 826A525C: 4874E7AD  bl 0x82df3a08
	ctx.lr = 0x826A5260;
	sub_82DF3A08(ctx, base);
	// 826A5260: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5264: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 826A5268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A526C: 4BEFC31D  bl 0x825a1588
	ctx.lr = 0x826A5270;
	sub_825A1588(ctx, base);
	// 826A5270: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 826A5274: 4874E1B5  bl 0x82df3428
	ctx.lr = 0x826A5278;
	sub_82DF3428(ctx, base);
	// 826A5278: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A527C: 3861010C  addi r3, r1, 0x10c
	ctx.r[3].s64 = ctx.r[1].s64 + 268;
	// 826A5280: 4874E789  bl 0x82df3a08
	ctx.lr = 0x826A5284;
	sub_82DF3A08(ctx, base);
	// 826A5284: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5288: 3881010C  addi r4, r1, 0x10c
	ctx.r[4].s64 = ctx.r[1].s64 + 268;
	// 826A528C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5290: 4BEFC2F9  bl 0x825a1588
	ctx.lr = 0x826A5294;
	sub_825A1588(ctx, base);
	// 826A5294: 3861010C  addi r3, r1, 0x10c
	ctx.r[3].s64 = ctx.r[1].s64 + 268;
	// 826A5298: 4874E191  bl 0x82df3428
	ctx.lr = 0x826A529C;
	sub_82DF3428(ctx, base);
	// 826A529C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A52A0: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826A52A4: 4874E765  bl 0x82df3a08
	ctx.lr = 0x826A52A8;
	sub_82DF3A08(ctx, base);
	// 826A52A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A52AC: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 826A52B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A52B4: 4BEFC2D5  bl 0x825a1588
	ctx.lr = 0x826A52B8;
	sub_825A1588(ctx, base);
	// 826A52B8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826A52BC: 480005AC  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A52C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A52C4: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 826A52C8: 4874E741  bl 0x82df3a08
	ctx.lr = 0x826A52CC;
	sub_82DF3A08(ctx, base);
	// 826A52CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A52D0: 388100D4  addi r4, r1, 0xd4
	ctx.r[4].s64 = ctx.r[1].s64 + 212;
	// 826A52D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A52D8: 4BEFC2B1  bl 0x825a1588
	ctx.lr = 0x826A52DC;
	sub_825A1588(ctx, base);
	// 826A52DC: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 826A52E0: 4874E149  bl 0x82df3428
	ctx.lr = 0x826A52E4;
	sub_82DF3428(ctx, base);
	// 826A52E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A52E8: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 826A52EC: 4874E71D  bl 0x82df3a08
	ctx.lr = 0x826A52F0;
	sub_82DF3A08(ctx, base);
	// 826A52F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A52F4: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 826A52F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A52FC: 4BEFC28D  bl 0x825a1588
	ctx.lr = 0x826A5300;
	sub_825A1588(ctx, base);
	// 826A5300: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 826A5304: 4874E125  bl 0x82df3428
	ctx.lr = 0x826A5308;
	sub_82DF3428(ctx, base);
	// 826A5308: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A530C: 386100FC  addi r3, r1, 0xfc
	ctx.r[3].s64 = ctx.r[1].s64 + 252;
	// 826A5310: 4874E6F9  bl 0x82df3a08
	ctx.lr = 0x826A5314;
	sub_82DF3A08(ctx, base);
	// 826A5314: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5318: 388100FC  addi r4, r1, 0xfc
	ctx.r[4].s64 = ctx.r[1].s64 + 252;
	// 826A531C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5320: 4BEFC269  bl 0x825a1588
	ctx.lr = 0x826A5324;
	sub_825A1588(ctx, base);
	// 826A5324: 386100FC  addi r3, r1, 0xfc
	ctx.r[3].s64 = ctx.r[1].s64 + 252;
	// 826A5328: 4874E101  bl 0x82df3428
	ctx.lr = 0x826A532C;
	sub_82DF3428(ctx, base);
	// 826A532C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826A5330: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 826A5334: 4874E6D5  bl 0x82df3a08
	ctx.lr = 0x826A5338;
	sub_82DF3A08(ctx, base);
	// 826A5338: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A533C: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 826A5340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5344: 4BEFC245  bl 0x825a1588
	ctx.lr = 0x826A5348;
	sub_825A1588(ctx, base);
	// 826A5348: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 826A534C: 4874E0DD  bl 0x82df3428
	ctx.lr = 0x826A5350;
	sub_82DF3428(ctx, base);
	// 826A5350: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A5354: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 826A5358: 4874E6B1  bl 0x82df3a08
	ctx.lr = 0x826A535C;
	sub_82DF3A08(ctx, base);
	// 826A535C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5360: 388100DC  addi r4, r1, 0xdc
	ctx.r[4].s64 = ctx.r[1].s64 + 220;
	// 826A5364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5368: 4BEFC221  bl 0x825a1588
	ctx.lr = 0x826A536C;
	sub_825A1588(ctx, base);
	// 826A536C: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 826A5370: 4874E0B9  bl 0x82df3428
	ctx.lr = 0x826A5374;
	sub_82DF3428(ctx, base);
	// 826A5374: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5378: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 826A537C: 4874E68D  bl 0x82df3a08
	ctx.lr = 0x826A5380;
	sub_82DF3A08(ctx, base);
	// 826A5380: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5384: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 826A5388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A538C: 4BEFC1FD  bl 0x825a1588
	ctx.lr = 0x826A5390;
	sub_825A1588(ctx, base);
	// 826A5390: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 826A5394: 4874E095  bl 0x82df3428
	ctx.lr = 0x826A5398;
	sub_82DF3428(ctx, base);
	// 826A5398: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A539C: 3861011C  addi r3, r1, 0x11c
	ctx.r[3].s64 = ctx.r[1].s64 + 284;
	// 826A53A0: 4874E669  bl 0x82df3a08
	ctx.lr = 0x826A53A4;
	sub_82DF3A08(ctx, base);
	// 826A53A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A53A8: 3881011C  addi r4, r1, 0x11c
	ctx.r[4].s64 = ctx.r[1].s64 + 284;
	// 826A53AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A53B0: 4BEFC1D9  bl 0x825a1588
	ctx.lr = 0x826A53B4;
	sub_825A1588(ctx, base);
	// 826A53B4: 3861011C  addi r3, r1, 0x11c
	ctx.r[3].s64 = ctx.r[1].s64 + 284;
	// 826A53B8: 480004B0  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A53BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A53C0: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 826A53C4: 4874E645  bl 0x82df3a08
	ctx.lr = 0x826A53C8;
	sub_82DF3A08(ctx, base);
	// 826A53C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A53CC: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 826A53D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A53D4: 4BEFC1B5  bl 0x825a1588
	ctx.lr = 0x826A53D8;
	sub_825A1588(ctx, base);
	// 826A53D8: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 826A53DC: 4874E04D  bl 0x82df3428
	ctx.lr = 0x826A53E0;
	sub_82DF3428(ctx, base);
	// 826A53E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A53E4: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 826A53E8: 4874E621  bl 0x82df3a08
	ctx.lr = 0x826A53EC;
	sub_82DF3A08(ctx, base);
	// 826A53EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A53F0: 388100E4  addi r4, r1, 0xe4
	ctx.r[4].s64 = ctx.r[1].s64 + 228;
	// 826A53F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A53F8: 4BEFC191  bl 0x825a1588
	ctx.lr = 0x826A53FC;
	sub_825A1588(ctx, base);
	// 826A53FC: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 826A5400: 4874E029  bl 0x82df3428
	ctx.lr = 0x826A5404;
	sub_82DF3428(ctx, base);
	// 826A5404: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A5408: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 826A540C: 4874E5FD  bl 0x82df3a08
	ctx.lr = 0x826A5410;
	sub_82DF3A08(ctx, base);
	// 826A5410: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5414: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 826A5418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A541C: 4BEFC16D  bl 0x825a1588
	ctx.lr = 0x826A5420;
	sub_825A1588(ctx, base);
	// 826A5420: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 826A5424: 4874E005  bl 0x82df3428
	ctx.lr = 0x826A5428;
	sub_82DF3428(ctx, base);
	// 826A5428: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A542C: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 826A5430: 4874E5D9  bl 0x82df3a08
	ctx.lr = 0x826A5434;
	sub_82DF3A08(ctx, base);
	// 826A5434: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5438: 38810104  addi r4, r1, 0x104
	ctx.r[4].s64 = ctx.r[1].s64 + 260;
	// 826A543C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5440: 4BEFC149  bl 0x825a1588
	ctx.lr = 0x826A5444;
	sub_825A1588(ctx, base);
	// 826A5444: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 826A5448: 4874DFE1  bl 0x82df3428
	ctx.lr = 0x826A544C;
	sub_82DF3428(ctx, base);
	// 826A544C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5450: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 826A5454: 4874E5B5  bl 0x82df3a08
	ctx.lr = 0x826A5458;
	sub_82DF3A08(ctx, base);
	// 826A5458: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A545C: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 826A5460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5464: 4BEFC125  bl 0x825a1588
	ctx.lr = 0x826A5468;
	sub_825A1588(ctx, base);
	// 826A5468: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 826A546C: 4874DFBD  bl 0x82df3428
	ctx.lr = 0x826A5470;
	sub_82DF3428(ctx, base);
	// 826A5470: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A5474: 386100EC  addi r3, r1, 0xec
	ctx.r[3].s64 = ctx.r[1].s64 + 236;
	// 826A5478: 4874E591  bl 0x82df3a08
	ctx.lr = 0x826A547C;
	sub_82DF3A08(ctx, base);
	// 826A547C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5480: 388100EC  addi r4, r1, 0xec
	ctx.r[4].s64 = ctx.r[1].s64 + 236;
	// 826A5484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5488: 4BEFC101  bl 0x825a1588
	ctx.lr = 0x826A548C;
	sub_825A1588(ctx, base);
	// 826A548C: 386100EC  addi r3, r1, 0xec
	ctx.r[3].s64 = ctx.r[1].s64 + 236;
	// 826A5490: 480003D8  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A5494: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A5498: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A549C: 4874E56D  bl 0x82df3a08
	ctx.lr = 0x826A54A0;
	sub_82DF3A08(ctx, base);
	// 826A54A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A54A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826A54A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A54AC: 4BEFC0DD  bl 0x825a1588
	ctx.lr = 0x826A54B0;
	sub_825A1588(ctx, base);
	// 826A54B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A54B4: 4874DF75  bl 0x82df3428
	ctx.lr = 0x826A54B8;
	sub_82DF3428(ctx, base);
	// 826A54B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A54BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A54C0: 4874E549  bl 0x82df3a08
	ctx.lr = 0x826A54C4;
	sub_82DF3A08(ctx, base);
	// 826A54C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A54C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A54CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A54D0: 4BEFC0B9  bl 0x825a1588
	ctx.lr = 0x826A54D4;
	sub_825A1588(ctx, base);
	// 826A54D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A54D8: 4874DF51  bl 0x82df3428
	ctx.lr = 0x826A54DC;
	sub_82DF3428(ctx, base);
	// 826A54DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A54E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A54E4: 4874E525  bl 0x82df3a08
	ctx.lr = 0x826A54E8;
	sub_82DF3A08(ctx, base);
	// 826A54E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A54EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A54F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A54F4: 4BEFC095  bl 0x825a1588
	ctx.lr = 0x826A54F8;
	sub_825A1588(ctx, base);
	// 826A54F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A54FC: 4874DF2D  bl 0x82df3428
	ctx.lr = 0x826A5500;
	sub_82DF3428(ctx, base);
	// 826A5500: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A5504: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A5508: 4874E501  bl 0x82df3a08
	ctx.lr = 0x826A550C;
	sub_82DF3A08(ctx, base);
	// 826A550C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5510: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826A5514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5518: 4BEFC071  bl 0x825a1588
	ctx.lr = 0x826A551C;
	sub_825A1588(ctx, base);
	// 826A551C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A5520: 4874DF09  bl 0x82df3428
	ctx.lr = 0x826A5524;
	sub_82DF3428(ctx, base);
	// 826A5524: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5528: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A552C: 4874E4DD  bl 0x82df3a08
	ctx.lr = 0x826A5530;
	sub_82DF3A08(ctx, base);
	// 826A5530: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5534: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826A5538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A553C: 4BEFC04D  bl 0x825a1588
	ctx.lr = 0x826A5540;
	sub_825A1588(ctx, base);
	// 826A5540: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A5544: 4874DEE5  bl 0x82df3428
	ctx.lr = 0x826A5548;
	sub_82DF3428(ctx, base);
	// 826A5548: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A554C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A5550: 4874E4B9  bl 0x82df3a08
	ctx.lr = 0x826A5554;
	sub_82DF3A08(ctx, base);
	// 826A5554: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5558: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826A555C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5560: 4BEFC029  bl 0x825a1588
	ctx.lr = 0x826A5564;
	sub_825A1588(ctx, base);
	// 826A5564: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A5568: 48000300  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A556C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A5570: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A5574: 4874E495  bl 0x82df3a08
	ctx.lr = 0x826A5578;
	sub_82DF3A08(ctx, base);
	// 826A5578: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A557C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826A5580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5584: 4BEFC005  bl 0x825a1588
	ctx.lr = 0x826A5588;
	sub_825A1588(ctx, base);
	// 826A5588: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A558C: 4874DE9D  bl 0x82df3428
	ctx.lr = 0x826A5590;
	sub_82DF3428(ctx, base);
	// 826A5590: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A5594: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826A5598: 4874E471  bl 0x82df3a08
	ctx.lr = 0x826A559C;
	sub_82DF3A08(ctx, base);
	// 826A559C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A55A0: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826A55A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A55A8: 4BEFBFE1  bl 0x825a1588
	ctx.lr = 0x826A55AC;
	sub_825A1588(ctx, base);
	// 826A55AC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826A55B0: 4874DE79  bl 0x82df3428
	ctx.lr = 0x826A55B4;
	sub_82DF3428(ctx, base);
	// 826A55B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A55B8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A55BC: 4874E44D  bl 0x82df3a08
	ctx.lr = 0x826A55C0;
	sub_82DF3A08(ctx, base);
	// 826A55C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A55C4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826A55C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A55CC: 4BEFBFBD  bl 0x825a1588
	ctx.lr = 0x826A55D0;
	sub_825A1588(ctx, base);
	// 826A55D0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826A55D4: 4874DE55  bl 0x82df3428
	ctx.lr = 0x826A55D8;
	sub_82DF3428(ctx, base);
	// 826A55D8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A55DC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A55E0: 4874E429  bl 0x82df3a08
	ctx.lr = 0x826A55E4;
	sub_82DF3A08(ctx, base);
	// 826A55E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A55E8: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 826A55EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A55F0: 4BEFBF99  bl 0x825a1588
	ctx.lr = 0x826A55F4;
	sub_825A1588(ctx, base);
	// 826A55F4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A55F8: 4874DE31  bl 0x82df3428
	ctx.lr = 0x826A55FC;
	sub_82DF3428(ctx, base);
	// 826A55FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5600: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A5604: 4874E405  bl 0x82df3a08
	ctx.lr = 0x826A5608;
	sub_82DF3A08(ctx, base);
	// 826A5608: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A560C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826A5610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5614: 4BEFBF75  bl 0x825a1588
	ctx.lr = 0x826A5618;
	sub_825A1588(ctx, base);
	// 826A5618: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A561C: 4874DE0D  bl 0x82df3428
	ctx.lr = 0x826A5620;
	sub_82DF3428(ctx, base);
	// 826A5620: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A5624: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826A5628: 4874E3E1  bl 0x82df3a08
	ctx.lr = 0x826A562C;
	sub_82DF3A08(ctx, base);
	// 826A562C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5630: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 826A5634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5638: 4BEFBF51  bl 0x825a1588
	ctx.lr = 0x826A563C;
	sub_825A1588(ctx, base);
	// 826A563C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826A5640: 48000228  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A5644: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826A5648: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A564C: 4874E3BD  bl 0x82df3a08
	ctx.lr = 0x826A5650;
	sub_82DF3A08(ctx, base);
	// 826A5650: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5654: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826A5658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A565C: 4BEFBF2D  bl 0x825a1588
	ctx.lr = 0x826A5660;
	sub_825A1588(ctx, base);
	// 826A5660: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826A5664: 4874DDC5  bl 0x82df3428
	ctx.lr = 0x826A5668;
	sub_82DF3428(ctx, base);
	// 826A5668: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A566C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826A5670: 4874E399  bl 0x82df3a08
	ctx.lr = 0x826A5674;
	sub_82DF3A08(ctx, base);
	// 826A5674: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5678: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 826A567C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5680: 4BEFBF09  bl 0x825a1588
	ctx.lr = 0x826A5684;
	sub_825A1588(ctx, base);
	// 826A5684: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826A5688: 4874DDA1  bl 0x82df3428
	ctx.lr = 0x826A568C;
	sub_82DF3428(ctx, base);
	// 826A568C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5690: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826A5694: 4874E375  bl 0x82df3a08
	ctx.lr = 0x826A5698;
	sub_82DF3A08(ctx, base);
	// 826A5698: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A569C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 826A56A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A56A4: 4BEFBEE5  bl 0x825a1588
	ctx.lr = 0x826A56A8;
	sub_825A1588(ctx, base);
	// 826A56A8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826A56AC: 4874DD7D  bl 0x82df3428
	ctx.lr = 0x826A56B0;
	sub_82DF3428(ctx, base);
	// 826A56B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A56B4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826A56B8: 4874E351  bl 0x82df3a08
	ctx.lr = 0x826A56BC;
	sub_82DF3A08(ctx, base);
	// 826A56BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A56C0: 388100C8  addi r4, r1, 0xc8
	ctx.r[4].s64 = ctx.r[1].s64 + 200;
	// 826A56C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A56C8: 4BEFBEC1  bl 0x825a1588
	ctx.lr = 0x826A56CC;
	sub_825A1588(ctx, base);
	// 826A56CC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826A56D0: 4874DD59  bl 0x82df3428
	ctx.lr = 0x826A56D4;
	sub_82DF3428(ctx, base);
	// 826A56D4: 89760084  lbz r11, 0x84(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(132 as u32) ) } as u64;
	// 826A56D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A56DC: 41820190  beq 0x826a586c
	if ctx.cr[0].eq {
	pc = 0x826A586C; continue 'dispatch;
	}
	// 826A56E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A56E4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826A56E8: 4874E321  bl 0x82df3a08
	ctx.lr = 0x826A56EC;
	sub_82DF3A08(ctx, base);
	// 826A56EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A56F0: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 826A56F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A56F8: 4BEFBE91  bl 0x825a1588
	ctx.lr = 0x826A56FC;
	sub_825A1588(ctx, base);
	// 826A56FC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826A5700: 48000168  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A5704: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A5708: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826A570C: 4874E2FD  bl 0x82df3a08
	ctx.lr = 0x826A5710;
	sub_82DF3A08(ctx, base);
	// 826A5710: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5714: 388100D8  addi r4, r1, 0xd8
	ctx.r[4].s64 = ctx.r[1].s64 + 216;
	// 826A5718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A571C: 4BEFBE6D  bl 0x825a1588
	ctx.lr = 0x826A5720;
	sub_825A1588(ctx, base);
	// 826A5720: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826A5724: 4874DD05  bl 0x82df3428
	ctx.lr = 0x826A5728;
	sub_82DF3428(ctx, base);
	// 826A5728: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A572C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826A5730: 4874E2D9  bl 0x82df3a08
	ctx.lr = 0x826A5734;
	sub_82DF3A08(ctx, base);
	// 826A5734: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5738: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 826A573C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5740: 4BEFBE49  bl 0x825a1588
	ctx.lr = 0x826A5744;
	sub_825A1588(ctx, base);
	// 826A5744: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826A5748: 4874DCE1  bl 0x82df3428
	ctx.lr = 0x826A574C;
	sub_82DF3428(ctx, base);
	// 826A574C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5750: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826A5754: 4874E2B5  bl 0x82df3a08
	ctx.lr = 0x826A5758;
	sub_82DF3A08(ctx, base);
	// 826A5758: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A575C: 388100E8  addi r4, r1, 0xe8
	ctx.r[4].s64 = ctx.r[1].s64 + 232;
	// 826A5760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5764: 4BEFBE25  bl 0x825a1588
	ctx.lr = 0x826A5768;
	sub_825A1588(ctx, base);
	// 826A5768: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826A576C: 4874DCBD  bl 0x82df3428
	ctx.lr = 0x826A5770;
	sub_82DF3428(ctx, base);
	// 826A5770: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A5774: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826A5778: 4874E291  bl 0x82df3a08
	ctx.lr = 0x826A577C;
	sub_82DF3A08(ctx, base);
	// 826A577C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5780: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 826A5784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5788: 4BEFBE01  bl 0x825a1588
	ctx.lr = 0x826A578C;
	sub_825A1588(ctx, base);
	// 826A578C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826A5790: 480000D8  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A5794: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A5798: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826A579C: 4874E26D  bl 0x82df3a08
	ctx.lr = 0x826A57A0;
	sub_82DF3A08(ctx, base);
	// 826A57A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A57A4: 388100F8  addi r4, r1, 0xf8
	ctx.r[4].s64 = ctx.r[1].s64 + 248;
	// 826A57A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A57AC: 4BEFBDDD  bl 0x825a1588
	ctx.lr = 0x826A57B0;
	sub_825A1588(ctx, base);
	// 826A57B0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826A57B4: 4874DC75  bl 0x82df3428
	ctx.lr = 0x826A57B8;
	sub_82DF3428(ctx, base);
	// 826A57B8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826A57BC: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826A57C0: 4874E249  bl 0x82df3a08
	ctx.lr = 0x826A57C4;
	sub_82DF3A08(ctx, base);
	// 826A57C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A57C8: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 826A57CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A57D0: 4BEFBDB9  bl 0x825a1588
	ctx.lr = 0x826A57D4;
	sub_825A1588(ctx, base);
	// 826A57D4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826A57D8: 4874DC51  bl 0x82df3428
	ctx.lr = 0x826A57DC;
	sub_82DF3428(ctx, base);
	// 826A57DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A57E0: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826A57E4: 4874E225  bl 0x82df3a08
	ctx.lr = 0x826A57E8;
	sub_82DF3A08(ctx, base);
	// 826A57E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A57EC: 38810108  addi r4, r1, 0x108
	ctx.r[4].s64 = ctx.r[1].s64 + 264;
	// 826A57F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A57F4: 4BEFBD95  bl 0x825a1588
	ctx.lr = 0x826A57F8;
	sub_825A1588(ctx, base);
	// 826A57F8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826A57FC: 4874DC2D  bl 0x82df3428
	ctx.lr = 0x826A5800;
	sub_82DF3428(ctx, base);
	// 826A5800: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A5804: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826A5808: 4874E201  bl 0x82df3a08
	ctx.lr = 0x826A580C;
	sub_82DF3A08(ctx, base);
	// 826A580C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5810: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 826A5814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5818: 4BEFBD71  bl 0x825a1588
	ctx.lr = 0x826A581C;
	sub_825A1588(ctx, base);
	// 826A581C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826A5820: 48000048  b 0x826a5868
	pc = 0x826A5868; continue 'dispatch;
	// 826A5824: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826A5828: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826A582C: 4874E1DD  bl 0x82df3a08
	ctx.lr = 0x826A5830;
	sub_82DF3A08(ctx, base);
	// 826A5830: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5834: 38810118  addi r4, r1, 0x118
	ctx.r[4].s64 = ctx.r[1].s64 + 280;
	// 826A5838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A583C: 4BEFBD4D  bl 0x825a1588
	ctx.lr = 0x826A5840;
	sub_825A1588(ctx, base);
	// 826A5840: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826A5844: 4874DBE5  bl 0x82df3428
	ctx.lr = 0x826A5848;
	sub_82DF3428(ctx, base);
	// 826A5848: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 826A584C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 826A5850: 4874E1B9  bl 0x82df3a08
	ctx.lr = 0x826A5854;
	sub_82DF3A08(ctx, base);
	// 826A5854: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A5858: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 826A585C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5860: 4BEFBD29  bl 0x825a1588
	ctx.lr = 0x826A5864;
	sub_825A1588(ctx, base);
	// 826A5864: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 826A5868: 4874DBC1  bl 0x82df3428
	ctx.lr = 0x826A586C;
	sub_82DF3428(ctx, base);
	// 826A586C: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 826A5870: 48B02924  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A5878 size=44
    let mut pc: u32 = 0x826A5878;
    'dispatch: loop {
        match pc {
            0x826A5878 => {
    //   block [0x826A5878..0x826A58A4)
	// 826A5878: 81630148  lwz r11, 0x148(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) } as u64;
	// 826A587C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 826A5880: 419A0018  beq cr6, 0x826a5898
	if ctx.cr[6].eq {
	pc = 0x826A5898; continue 'dispatch;
	}
	// 826A5884: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 826A5888: 419A0010  beq cr6, 0x826a5898
	if ctx.cr[6].eq {
	pc = 0x826A5898; continue 'dispatch;
	}
	// 826A588C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 826A5890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A5894: 409A0008  bne cr6, 0x826a589c
	if !ctx.cr[6].eq {
	pc = 0x826A589C; continue 'dispatch;
	}
	// 826A5898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A589C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826A58A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A58A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A58A8 size=72
    let mut pc: u32 = 0x826A58A8;
    'dispatch: loop {
        match pc {
            0x826A58A8 => {
    //   block [0x826A58A8..0x826A58F0)
	// 826A58A8: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A58AC: 41820044  beq 0x826a58f0
	if ctx.cr[0].eq {
		sub_826A58F0(ctx, base);
		return;
	}
	// 826A58B0: 81630148  lwz r11, 0x148(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) } as u64;
	// 826A58B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A58B8: 419A0030  beq cr6, 0x826a58e8
	if ctx.cr[6].eq {
	pc = 0x826A58E8; continue 'dispatch;
	}
	// 826A58BC: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 826A58C0: 419A0018  beq cr6, 0x826a58d8
	if ctx.cr[6].eq {
	pc = 0x826A58D8; continue 'dispatch;
	}
	// 826A58C4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 826A58C8: 419A0010  beq cr6, 0x826a58d8
	if ctx.cr[6].eq {
	pc = 0x826A58D8; continue 'dispatch;
	}
	// 826A58CC: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 826A58D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A58D4: 409A0008  bne cr6, 0x826a58dc
	if !ctx.cr[6].eq {
	pc = 0x826A58DC; continue 'dispatch;
	}
	// 826A58D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A58DC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A58E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A58E4: 41820010  beq 0x826a58f4
	if ctx.cr[0].eq {
		sub_826A58F0(ctx, base);
		return;
	}
	// 826A58E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A58EC: 48000008  b 0x826a58f4
	sub_826A58F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A58F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A58F0 size=12
    let mut pc: u32 = 0x826A58F0;
    'dispatch: loop {
        match pc {
            0x826A58F0 => {
    //   block [0x826A58F0..0x826A58FC)
	// 826A58F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A58F4: 996300E9  stb r11, 0xe9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(233 as u32), ctx.r[11].u8 ) };
	// 826A58F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5900 size=104
    let mut pc: u32 = 0x826A5900;
    'dispatch: loop {
        match pc {
            0x826A5900 => {
    //   block [0x826A5900..0x826A5968)
	// 826A5900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A590C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5910: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5914: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A5918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A591C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A5920: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826A5924: C00BCEE4  lfs f0, -0x311c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5928: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 826A592C: 487D70BD  bl 0x82e7c9e8
	ctx.lr = 0x826A5930;
	sub_82E7C9E8(ctx, base);
	// 826A5930: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A5934: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A5938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A593C: 487D640D  bl 0x82e7bd48
	ctx.lr = 0x826A5940;
	sub_82E7BD48(ctx, base);
	// 826A5940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A5948: 487D7B09  bl 0x82e7d450
	ctx.lr = 0x826A594C;
	sub_82E7D450(ctx, base);
	// 826A594C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5950: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826A5954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A595C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A5960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A5968 size=52
    let mut pc: u32 = 0x826A5968;
    'dispatch: loop {
        match pc {
            0x826A5968 => {
    //   block [0x826A5968..0x826A599C)
	// 826A5968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A596C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5970: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5974: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 826A5978: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A597C: 386AFF1C  addi r3, r10, -0xe4
	ctx.r[3].s64 = ctx.r[10].s64 + -228;
	// 826A5980: 4BFFFF29  bl 0x826a58a8
	ctx.lr = 0x826A5984;
	sub_826A58A8(ctx, base);
	// 826A5984: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A5988: 996A0004  stb r11, 4(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 826A598C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A5990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A59A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A59A0 size=52
    let mut pc: u32 = 0x826A59A0;
    'dispatch: loop {
        match pc {
            0x826A59A0 => {
    //   block [0x826A59A0..0x826A59D4)
	// 826A59A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A59A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A59A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A59AC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 826A59B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A59B4: 386AFF1C  addi r3, r10, -0xe4
	ctx.r[3].s64 = ctx.r[10].s64 + -228;
	// 826A59B8: 4BFFFEF1  bl 0x826a58a8
	ctx.lr = 0x826A59BC;
	sub_826A58A8(ctx, base);
	// 826A59BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A59C0: 996A0004  stb r11, 4(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 826A59C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826A59C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A59CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A59D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A59D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A59D8 size=136
    let mut pc: u32 = 0x826A59D8;
    'dispatch: loop {
        match pc {
            0x826A59D8 => {
    //   block [0x826A59D8..0x826A5A60)
	// 826A59D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A59DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A59E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A59E4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A59E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A59EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A59F0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826A59F4: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826A59F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A59FC: 41820040  beq 0x826a5a3c
	if ctx.cr[0].eq {
	pc = 0x826A5A3C; continue 'dispatch;
	}
	// 826A5A00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A5A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5A08: 4BE69AC1  bl 0x8250f4c8
	ctx.lr = 0x826A5A0C;
	sub_8250F4C8(ctx, base);
	// 826A5A0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A5A10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5A14: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A5A18: 409A0008  bne cr6, 0x826a5a20
	if !ctx.cr[6].eq {
	pc = 0x826A5A20; continue 'dispatch;
	}
	// 826A5A1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A5A20: 4BE62AF9  bl 0x82508518
	ctx.lr = 0x826A5A24;
	sub_82508518(ctx, base);
	// 826A5A24: EC01F82A  fadds f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 826A5A28: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A5A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5A30: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826A5A34: 4874C25D  bl 0x82df1c90
	ctx.lr = 0x826A5A38;
	sub_82DF1C90(ctx, base);
	// 826A5A38: 4800000C  b 0x826a5a44
	pc = 0x826A5A44; continue 'dispatch;
	// 826A5A3C: C01F0110  lfs f0, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5A40: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 826A5A44: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A5A48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A5A4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5A50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5A54: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A5A58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5A60 size=176
    let mut pc: u32 = 0x826A5A60;
    'dispatch: loop {
        match pc {
            0x826A5A60 => {
    //   block [0x826A5A60..0x826A5B10)
	// 826A5A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A5A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5A70: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826A5A74: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826A5A78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5A7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A5A80: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5A84: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826A5A88: 419A0068  beq cr6, 0x826a5af0
	if ctx.cr[6].eq {
	pc = 0x826A5AF0; continue 'dispatch;
	}
	// 826A5A8C: 4BC2A495  bl 0x822cff20
	ctx.lr = 0x826A5A90;
	sub_822CFF20(ctx, base);
	// 826A5A90: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5A94: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826A5A98: 4BC2A479  bl 0x822cff10
	ctx.lr = 0x826A5A9C;
	sub_822CFF10(ctx, base);
	// 826A5A9C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5AA0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 826A5AA4: 4BC2A48D  bl 0x822cff30
	ctx.lr = 0x826A5AA8;
	sub_822CFF30(ctx, base);
	// 826A5AA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A5AAC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5AB0: C00B964C  lfs f0, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5AB4: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 826A5AB8: 4BC2A449  bl 0x822cff00
	ctx.lr = 0x826A5ABC;
	sub_822CFF00(ctx, base);
	// 826A5ABC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5AC0: 4BC2A461  bl 0x822cff20
	ctx.lr = 0x826A5AC4;
	sub_822CFF20(ctx, base);
	// 826A5AC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A5AC8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826A5ACC: C00B9F78  lfs f0, -0x6088(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5AD0: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A5AD4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 826A5AD8: 41980008  blt cr6, 0x826a5ae0
	if ctx.cr[6].lt {
	pc = 0x826A5AE0; continue 'dispatch;
	}
	// 826A5ADC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826A5AE0: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5AE4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A5AE8: 4BC2A449  bl 0x822cff30
	ctx.lr = 0x826A5AEC;
	sub_822CFF30(ctx, base);
	// 826A5AEC: 57C3063E  clrlwi r3, r30, 0x18
	ctx.r[3].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 826A5AF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A5AF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5AF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5AFC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826A5B00: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826A5B04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A5B08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5B0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5B10 size=128
    let mut pc: u32 = 0x826A5B10;
    'dispatch: loop {
        match pc {
            0x826A5B10 => {
    //   block [0x826A5B10..0x826A5B90)
	// 826A5B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5B18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5B1C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 826A5B20: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A5B24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5B28: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 826A5B2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A5B30: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 826A5B34: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5B38: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 826A5B3C: 419A0034  beq cr6, 0x826a5b70
	if ctx.cr[6].eq {
	pc = 0x826A5B70; continue 'dispatch;
	}
	// 826A5B40: C1A3014C  lfs f13, 0x14c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(332 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A5B44: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826A5B48: 419A0028  beq cr6, 0x826a5b70
	if ctx.cr[6].eq {
	pc = 0x826A5B70; continue 'dispatch;
	}
	// 826A5B4C: EC1F6824  fdivs f0, f31, f13
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 826A5B50: EFC00072  fmuls f30, f0, f1
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826A5B54: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A5B58: 48B04CB9  bl 0x831aa810
	ctx.lr = 0x826A5B5C;
	sub_831AA810(ctx, base);
	// 826A5B5C: EC1EF824  fdivs f0, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 826A5B60: FC200818  frsp f1, f1
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826A5B64: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 826A5B68: 7C00FFAE  stfiwx f0, 0, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32, tmp.u32) };
	// 826A5B6C: 48000008  b 0x826a5b74
	pc = 0x826A5B74; continue 'dispatch;
	// 826A5B70: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 826A5B74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A5B78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5B7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5B80: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826A5B84: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A5B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5B90 size=276
    let mut pc: u32 = 0x826A5B90;
    'dispatch: loop {
        match pc {
            0x826A5B90 => {
    //   block [0x826A5B90..0x826A5CA4)
	// 826A5B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5B98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5B9C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 826A5BA0: 48B02ED5  bl 0x831a8a74
	ctx.lr = 0x826A5BA4;
	sub_831A8A40(ctx, base);
	// 826A5BA4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A5BAC: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 826A5BB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A5BB4: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 826A5BB8: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5BBC: C36B08A4  lfs f27, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 826A5BC0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826A5BC4: 419A00C0  beq cr6, 0x826a5c84
	if ctx.cr[6].eq {
	pc = 0x826A5C84; continue 'dispatch;
	}
	// 826A5BC8: C01F0160  lfs f0, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5BCC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 826A5BD0: 419A00B4  beq cr6, 0x826a5c84
	if ctx.cr[6].eq {
	pc = 0x826A5C84; continue 'dispatch;
	}
	// 826A5BD4: 4BC2A33D  bl 0x822cff10
	ctx.lr = 0x826A5BD8;
	sub_822CFF10(ctx, base);
	// 826A5BD8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 826A5BDC: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 826A5BE0: C01F0160  lfs f0, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5BE8: EFFE0024  fdivs f31, f30, f0
	ctx.f[31].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 826A5BEC: 419A0010  beq cr6, 0x826a5bfc
	if ctx.cr[6].eq {
	pc = 0x826A5BFC; continue 'dispatch;
	}
	// 826A5BF0: EC1CF024  fdivs f0, f28, f30
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[30].f64) as f32) as f64;
	// 826A5BF4: EC20EFFA  fmadds f1, f0, f31, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 826A5BF8: 48000024  b 0x826a5c1c
	pc = 0x826A5C1C; continue 'dispatch;
	// 826A5BFC: EDBEE028  fsubs f13, f30, f28
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[28].f64) as f32) as f64);
	// 826A5C00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A5C04: C19F0158  lfs f12, 0x158(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A5C08: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5C0C: EDADF024  fdivs f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[30].f64) as f32) as f64;
	// 826A5C10: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 826A5C14: EC0067FA  fmadds f0, f0, f31, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 826A5C18: EC20E82A  fadds f1, f0, f29
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 826A5C1C: C01F0158  lfs f0, 0x158(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5C20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A5C24: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 826A5C28: C3AB9524  lfs f29, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826A5C2C: EC400772  fmuls f2, f0, f29
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 826A5C30: 48B04BE1  bl 0x831aa810
	ctx.lr = 0x826A5C34;
	sub_831AA810(ctx, base);
	// 826A5C34: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826A5C38: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 826A5C3C: 40980010  bge cr6, 0x826a5c4c
	if !ctx.cr[6].lt {
	pc = 0x826A5C4C; continue 'dispatch;
	}
	// 826A5C40: C1BF0160  lfs f13, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A5C44: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826A5C48: 48000040  b 0x826a5c88
	pc = 0x826A5C88; continue 'dispatch;
	// 826A5C4C: C1BF0158  lfs f13, 0x158(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A5C50: ED8DF82A  fadds f12, f13, f31
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 826A5C54: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 826A5C58: 4098000C  bge cr6, 0x826a5c64
	if !ctx.cr[6].lt {
	pc = 0x826A5C64; continue 'dispatch;
	}
	// 826A5C5C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A5C60: 48000028  b 0x826a5c88
	pc = 0x826A5C88; continue 'dispatch;
	// 826A5C64: ED9F6F7A  fmadds f12, f31, f29, f13
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 826A5C68: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 826A5C6C: 40980018  bge cr6, 0x826a5c84
	if !ctx.cr[6].lt {
	pc = 0x826A5C84; continue 'dispatch;
	}
	// 826A5C70: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 826A5C74: C19F0160  lfs f12, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A5C78: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826A5C7C: EC20F33C  fnmsubs f1, f0, f12, f30
	ctx.f[1].f64 = -(((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[30].f64) as f32) as f64);
	// 826A5C80: 48000008  b 0x826a5c88
	pc = 0x826A5C88; continue 'dispatch;
	// 826A5C84: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 826A5C88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826A5C8C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 826A5C90: 48B02E31  bl 0x831a8ac0
	ctx.lr = 0x826A5C94;
	sub_831A8A8C(ctx, base);
	// 826A5C94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5C98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5CA8 size=176
    let mut pc: u32 = 0x826A5CA8;
    'dispatch: loop {
        match pc {
            0x826A5CA8 => {
    //   block [0x826A5CA8..0x826A5D58)
	// 826A5CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A5CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5CB8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826A5CBC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826A5CC0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826A5CC4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5CC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A5CCC: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 826A5CD0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 826A5CD4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 826A5CD8: 807E00F8  lwz r3, 0xf8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5CDC: 4BC2A235  bl 0x822cff10
	ctx.lr = 0x826A5CE0;
	sub_822CFF10(ctx, base);
	// 826A5CE0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826A5CE4: 817E0164  lwz r11, 0x164(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 826A5CE8: C01E0160  lfs f0, 0x160(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5CEC: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 826A5CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5CF4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A5CF8: 419A0018  beq cr6, 0x826a5d10
	if ctx.cr[6].eq {
	pc = 0x826A5D10; continue 'dispatch;
	}
	// 826A5CFC: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 826A5D00: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A5D04: 48B04B0D  bl 0x831aa810
	ctx.lr = 0x826A5D08;
	sub_831AA810(ctx, base);
	// 826A5D08: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826A5D0C: 4800001C  b 0x826a5d28
	pc = 0x826A5D28; continue 'dispatch;
	// 826A5D10: EDBFF028  fsubs f13, f31, f30
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 826A5D14: EFCD002A  fadds f30, f13, f0
	ctx.f[30].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 826A5D18: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826A5D1C: 48B04AF5  bl 0x831aa810
	ctx.lr = 0x826A5D20;
	sub_831AA810(ctx, base);
	// 826A5D20: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826A5D24: EC3F6828  fsubs f1, f31, f13
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 826A5D28: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 826A5D2C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 826A5D30: 7C00FFAE  stfiwx f0, 0, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32, tmp.u32) };
	// 826A5D34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A5D38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5D3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5D40: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826A5D44: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826A5D48: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826A5D4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A5D50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5D58 size=128
    let mut pc: u32 = 0x826A5D58;
    'dispatch: loop {
        match pc {
            0x826A5D58 => {
    //   block [0x826A5D58..0x826A5DD8)
	// 826A5D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5D64: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A5D68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5D6C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826A5D70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A5D74: 4BFFFF35  bl 0x826a5ca8
	ctx.lr = 0x826A5D78;
	sub_826A5CA8(ctx, base);
	// 826A5D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5D7C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826A5D80: 4BFFFCE1  bl 0x826a5a60
	ctx.lr = 0x826A5D84;
	sub_826A5A60(ctx, base);
	// 826A5D84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A5D88: 40820034  bne 0x826a5dbc
	if !ctx.cr[0].eq {
	pc = 0x826A5DBC; continue 'dispatch;
	}
	// 826A5D8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A5D90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5D94: 419A0028  beq cr6, 0x826a5dbc
	if ctx.cr[6].eq {
	pc = 0x826A5DBC; continue 'dispatch;
	}
	// 826A5D98: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 826A5D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5DA0: 419A0014  beq cr6, 0x826a5db4
	if ctx.cr[6].eq {
	pc = 0x826A5DB4; continue 'dispatch;
	}
	// 826A5DA4: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A5DA8: 4BC2A169  bl 0x822cff10
	ctx.lr = 0x826A5DAC;
	sub_822CFF10(ctx, base);
	// 826A5DAC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826A5DB0: 4800000C  b 0x826a5dbc
	pc = 0x826A5DBC; continue 'dispatch;
	// 826A5DB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A5DB8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A5DBC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A5DC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A5DC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5DC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5DCC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A5DD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5DD8 size=268
    let mut pc: u32 = 0x826A5DD8;
    'dispatch: loop {
        match pc {
            0x826A5DD8 => {
    //   block [0x826A5DD8..0x826A5EE4)
	// 826A5DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5DE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5DE4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5DE8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826A5DEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A5DF0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826A5DF4: 419A0088  beq cr6, 0x826a5e7c
	if ctx.cr[6].eq {
	pc = 0x826A5E7C; continue 'dispatch;
	}
	// 826A5DF8: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826A5DFC: 409A00D4  bne cr6, 0x826a5ed0
	if !ctx.cr[6].eq {
	pc = 0x826A5ED0; continue 'dispatch;
	}
	// 826A5E00: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826A5E04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A5E08: 418200C8  beq 0x826a5ed0
	if ctx.cr[0].eq {
	pc = 0x826A5ED0; continue 'dispatch;
	}
	// 826A5E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A5E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5E14: 4BE696B5  bl 0x8250f4c8
	ctx.lr = 0x826A5E18;
	sub_8250F4C8(ctx, base);
	// 826A5E18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A5E1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5E20: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A5E24: 409A0008  bne cr6, 0x826a5e2c
	if !ctx.cr[6].eq {
	pc = 0x826A5E2C; continue 'dispatch;
	}
	// 826A5E28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A5E2C: 4BE626ED  bl 0x82508518
	ctx.lr = 0x826A5E30;
	sub_82508518(ctx, base);
	// 826A5E30: C01F010C  lfs f0, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5E34: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A5E38: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 826A5E3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5E40: 4874BE51  bl 0x82df1c90
	ctx.lr = 0x826A5E44;
	sub_82DF1C90(ctx, base);
	// 826A5E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A5E48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A5E4C: 4BE6967D  bl 0x8250f4c8
	ctx.lr = 0x826A5E50;
	sub_8250F4C8(ctx, base);
	// 826A5E50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A5E54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5E58: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A5E5C: 409A0008  bne cr6, 0x826a5e64
	if !ctx.cr[6].eq {
	pc = 0x826A5E64; continue 'dispatch;
	}
	// 826A5E60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A5E64: 4BE626B5  bl 0x82508518
	ctx.lr = 0x826A5E68;
	sub_82508518(ctx, base);
	// 826A5E68: D03F0108  stfs f1, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 826A5E6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A5E70: 4874BE21  bl 0x82df1c90
	ctx.lr = 0x826A5E74;
	sub_82DF1C90(ctx, base);
	// 826A5E74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A5E78: 48000054  b 0x826a5ecc
	pc = 0x826A5ECC; continue 'dispatch;
	// 826A5E7C: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826A5E80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A5E84: 4082004C  bne 0x826a5ed0
	if !ctx.cr[0].eq {
	pc = 0x826A5ED0; continue 'dispatch;
	}
	// 826A5E88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A5E8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A5E90: 4BE69639  bl 0x8250f4c8
	ctx.lr = 0x826A5E94;
	sub_8250F4C8(ctx, base);
	// 826A5E94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A5E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5E9C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A5EA0: 409A0008  bne cr6, 0x826a5ea8
	if !ctx.cr[6].eq {
	pc = 0x826A5EA8; continue 'dispatch;
	}
	// 826A5EA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A5EA8: 4BE62671  bl 0x82508518
	ctx.lr = 0x826A5EAC;
	sub_82508518(ctx, base);
	// 826A5EAC: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A5EB0: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 826A5EB4: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A5EB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A5EBC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826A5EC0: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 826A5EC4: 4874BDCD  bl 0x82df1c90
	ctx.lr = 0x826A5EC8;
	sub_82DF1C90(ctx, base);
	// 826A5EC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A5ECC: 997F0104  stb r11, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 826A5ED0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A5ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5EDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A5EE8 size=196
    let mut pc: u32 = 0x826A5EE8;
    'dispatch: loop {
        match pc {
            0x826A5EE8 => {
    //   block [0x826A5EE8..0x826A5FAC)
	// 826A5EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A5EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A5EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A5EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5EFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A5F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A5F04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A5F08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A5F0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A5F10: 4BC1AA29  bl 0x822c0938
	ctx.lr = 0x826A5F14;
	sub_822C0938(ctx, base);
	// 826A5F14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A5F18: 41820028  beq 0x826a5f40
	if ctx.cr[0].eq {
	pc = 0x826A5F40; continue 'dispatch;
	}
	// 826A5F1C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A5F20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A5F24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A5F28: 392B1170  addi r9, r11, 0x1170
	ctx.r[9].s64 = ctx.r[11].s64 + 4464;
	// 826A5F2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A5F30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A5F34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A5F38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A5F3C: 48000008  b 0x826a5f44
	pc = 0x826A5F44; continue 'dispatch;
	// 826A5F40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A5F44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A5F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A5F4C: 409A0044  bne cr6, 0x826a5f90
	if !ctx.cr[6].eq {
	pc = 0x826A5F90; continue 'dispatch;
	}
	// 826A5F50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A5F54: 419A001C  beq cr6, 0x826a5f70
	if ctx.cr[6].eq {
	pc = 0x826A5F70; continue 'dispatch;
	}
	// 826A5F58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A5F5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A5F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5F64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A5F68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A5F6C: 4E800421  bctrl
	ctx.lr = 0x826A5F70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A5F70: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A5F74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A5F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5F7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A5F80: 816B9E78  lwz r11, -0x6188(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24968 as u32) ) } as u64;
	// 826A5F84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A5F88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A5F8C: 4BC1A075  bl 0x822c0000
	ctx.lr = 0x826A5F90;
	sub_822C0000(ctx, base);
	// 826A5F90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A5F94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A5F98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A5F9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A5FA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A5FA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A5FA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A5FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A5FB0 size=172
    let mut pc: u32 = 0x826A5FB0;
    'dispatch: loop {
        match pc {
            0x826A5FB0 => {
    //   block [0x826A5FB0..0x826A605C)
	// 826A5FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A5FB4: 48B021B5  bl 0x831a8168
	ctx.lr = 0x826A5FB8;
	sub_831A8130(ctx, base);
	// 826A5FB8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A5FBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A5FC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A5FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A5FC8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826A5FCC: 4BE6BB8D  bl 0x82511b58
	ctx.lr = 0x826A5FD0;
	sub_82511B58(ctx, base);
	// 826A5FD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A5FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A5FD8: 487D5EC1  bl 0x82e7be98
	ctx.lr = 0x826A5FDC;
	sub_82E7BE98(ctx, base);
	// 826A5FDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826A5FE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A5FE4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826A5FE8: 487D5FF1  bl 0x82e7bfd8
	ctx.lr = 0x826A5FEC;
	sub_82E7BFD8(ctx, base);
	// 826A5FEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A5FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A5FF4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826A5FF8: 4BC1E909  bl 0x822c4900
	ctx.lr = 0x826A5FFC;
	sub_822C4900(ctx, base);
	// 826A5FFC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826A6000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A6004: 4BE6BD95  bl 0x82511d98
	ctx.lr = 0x826A6008;
	sub_82511D98(ctx, base);
	// 826A6008: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826A600C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826A6010: 487D5A59  bl 0x82e7ba68
	ctx.lr = 0x826A6014;
	sub_82E7BA68(ctx, base);
	// 826A6014: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A6018: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A601C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6020: 4BC1E8E1  bl 0x822c4900
	ctx.lr = 0x826A6024;
	sub_822C4900(ctx, base);
	// 826A6024: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 826A6028: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826A602C: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A6030: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 826A6034: 13C91C07  vcmpneb. (lvlx128) v30, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A6038: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A603C: 138B1C07  vcmpneb. (lvlx128) v28, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A6040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6060 size=216
    let mut pc: u32 = 0x826A6060;
    'dispatch: loop {
        match pc {
            0x826A6060 => {
    //   block [0x826A6060..0x826A6138)
	// 826A6060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A6064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A606C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A6070: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A6074: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A6078: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826A607C: 396BC4C0  addi r11, r11, -0x3b40
	ctx.r[11].s64 = ctx.r[11].s64 + -15168;
	// 826A6080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6084: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826A6088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A608C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A6090: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A6138 size=176
    let mut pc: u32 = 0x826A6138;
    'dispatch: loop {
        match pc {
            0x826A6138 => {
    //   block [0x826A6138..0x826A61E8)
	// 826A6138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A613C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A6144: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A6148: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A61E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A61E8 size=160
    let mut pc: u32 = 0x826A61E8;
    'dispatch: loop {
        match pc {
            0x826A61E8 => {
    //   block [0x826A61E8..0x826A6288)
	// 826A61E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A61EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A61F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A61F4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A61F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A61FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6200: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A6204: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826A6208: 419A0058  beq cr6, 0x826a6260
	if ctx.cr[6].eq {
	pc = 0x826A6260; continue 'dispatch;
	}
	// 826A620C: 4BC29D05  bl 0x822cff10
	ctx.lr = 0x826A6210;
	sub_822CFF10(ctx, base);
	// 826A6210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6214: C03F0154  lfs f1, 0x154(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A6218: C3FF0100  lfs f31, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A621C: 4BFFF7BD  bl 0x826a59d8
	ctx.lr = 0x826A6220;
	sub_826A59D8(ctx, base);
	// 826A6220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6224: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A6228: 4BFFF969  bl 0x826a5b90
	ctx.lr = 0x826A622C;
	sub_826A5B90(ctx, base);
	// 826A622C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A6230: 4BC29D01  bl 0x822cff30
	ctx.lr = 0x826A6234;
	sub_822CFF30(ctx, base);
	// 826A6234: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A6238: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A623C: 4BC29EAD  bl 0x822d00e8
	ctx.lr = 0x826A6240;
	sub_822D00E8(ctx, base);
	// 826A6240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A6244: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6248: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A624C: 83FF0140  lwz r31, 0x140(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A6250: 4BFFFD61  bl 0x826a5fb0
	ctx.lr = 0x826A6254;
	sub_826A5FB0(ctx, base);
	// 826A6254: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A6258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A625C: 48000010  b 0x826a626c
	pc = 0x826A626C; continue 'dispatch;
	// 826A6260: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A6264: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A6268: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A626C: 4876CFF5  bl 0x82e13260
	ctx.lr = 0x826A6270;
	sub_82E13260(ctx, base);
	// 826A6270: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826A6274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A6278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A627C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A6280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A6284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6288 size=276
    let mut pc: u32 = 0x826A6288;
    'dispatch: loop {
        match pc {
            0x826A6288 => {
    //   block [0x826A6288..0x826A639C)
	// 826A6288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A628C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A6294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A6298: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826A629C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A62A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A62A4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826A62A8: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 826A62AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A62B0: 419A0010  beq cr6, 0x826a62c0
	if ctx.cr[6].eq {
	pc = 0x826A62C0; continue 'dispatch;
	}
	// 826A62B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A62B8: 396B2D40  addi r11, r11, 0x2d40
	ctx.r[11].s64 = ctx.r[11].s64 + 11584;
	// 826A62BC: 4800000C  b 0x826a62c8
	pc = 0x826A62C8; continue 'dispatch;
	// 826A62C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A62C4: 396B2D50  addi r11, r11, 0x2d50
	ctx.r[11].s64 = ctx.r[11].s64 + 11600;
	// 826A62C8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A62CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A63A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A63A0 size=240
    let mut pc: u32 = 0x826A63A0;
    'dispatch: loop {
        match pc {
            0x826A63A0 => {
    //   block [0x826A63A0..0x826A6490)
	// 826A63A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A63A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A63A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A63AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A63B0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826A63B4: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6490 size=212
    let mut pc: u32 = 0x826A6490;
    'dispatch: loop {
        match pc {
            0x826A6490 => {
    //   block [0x826A6490..0x826A6564)
	// 826A6490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A6494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A649C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A64A0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826A64A4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A64A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A64AC: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A64B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A64B4: 419A0084  beq cr6, 0x826a6538
	if ctx.cr[6].eq {
	pc = 0x826A6538; continue 'dispatch;
	}
	// 826A64B8: C3FF0100  lfs f31, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A64BC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826A64C0: C03F0154  lfs f1, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A64C4: 4BFFF515  bl 0x826a59d8
	ctx.lr = 0x826A64C8;
	sub_826A59D8(ctx, base);
	// 826A64C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A64CC: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A64D0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826A64D4: 4BFFF7D5  bl 0x826a5ca8
	ctx.lr = 0x826A64D8;
	sub_826A5CA8(ctx, base);
	// 826A64D8: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A64DC: 4BC29A55  bl 0x822cff30
	ctx.lr = 0x826A64E0;
	sub_822CFF30(ctx, base);
	// 826A64E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A64E4: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A64E8: 4BC29C01  bl 0x822d00e8
	ctx.lr = 0x826A64EC;
	sub_822D00E8(ctx, base);
	// 826A64EC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826A64F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A64F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A64F8: 83DF0140  lwz r30, 0x140(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A64FC: 4BFFFAB5  bl 0x826a5fb0
	ctx.lr = 0x826A6500;
	sub_826A5FB0(ctx, base);
	// 826A6500: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A6504: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A6508: 4876CD59  bl 0x82e13260
	ctx.lr = 0x826A650C;
	sub_82E13260(ctx, base);
	// 826A650C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A6510: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826A6514: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 826A6518: 419A0030  beq cr6, 0x826a6548
	if ctx.cr[6].eq {
	pc = 0x826A6548; continue 'dispatch;
	}
	// 826A651C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A6520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6524: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 826A6528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A652C: 4E800421  bctrl
	ctx.lr = 0x826A6530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A6530: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 826A6534: 48000014  b 0x826a6548
	pc = 0x826A6548; continue 'dispatch;
	// 826A6538: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A653C: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A6540: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A6544: 4876CD1D  bl 0x82e13260
	ctx.lr = 0x826A6548;
	sub_82E13260(ctx, base);
	// 826A6548: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826A654C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A6550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A6554: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826A6558: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A655C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A6560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6568 size=228
    let mut pc: u32 = 0x826A6568;
    'dispatch: loop {
        match pc {
            0x826A6568 => {
    //   block [0x826A6568..0x826A664C)
	// 826A6568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A656C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A6574: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A6578: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A657C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6580: C3FF0150  lfs f31, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A6584: C03F0154  lfs f1, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A6588: 4BFFF451  bl 0x826a59d8
	ctx.lr = 0x826A658C;
	sub_826A59D8(ctx, base);
	// 826A658C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826A6590: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A6594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6598: 4BFFF579  bl 0x826a5b10
	ctx.lr = 0x826A659C;
	sub_826A5B10(ctx, base);
	// 826A659C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A65A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A65A4: 419A0008  beq cr6, 0x826a65ac
	if ctx.cr[6].eq {
	pc = 0x826A65AC; continue 'dispatch;
	}
	// 826A65A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A65AC: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 826A65B0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826A65B4: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826A65B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A65BC: 419A0010  beq cr6, 0x826a65cc
	if ctx.cr[6].eq {
	pc = 0x826A65CC; continue 'dispatch;
	}
	// 826A65C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A65C4: 396B2D40  addi r11, r11, 0x2d40
	ctx.r[11].s64 = ctx.r[11].s64 + 11584;
	// 826A65C8: 4800000C  b 0x826a65d4
	pc = 0x826A65D4; continue 'dispatch;
	// 826A65CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A65D0: 396B2D50  addi r11, r11, 0x2d50
	ctx.r[11].s64 = ctx.r[11].s64 + 11600;
	// 826A65D4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A65D8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6650 size=184
    let mut pc: u32 = 0x826A6650;
    'dispatch: loop {
        match pc {
            0x826A6650 => {
    //   block [0x826A6650..0x826A6708)
	// 826A6650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A6654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6658: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A665C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A6660: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A6664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6668: C3FF0150  lfs f31, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A666C: C03F0154  lfs f1, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A6670: 4BFFF369  bl 0x826a59d8
	ctx.lr = 0x826A6674;
	sub_826A59D8(ctx, base);
	// 826A6674: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826A6678: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A667C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6680: 4BFFF491  bl 0x826a5b10
	ctx.lr = 0x826A6684;
	sub_826A5B10(ctx, base);
	// 826A6684: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A6688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A668C: 419A0008  beq cr6, 0x826a6694
	if ctx.cr[6].eq {
	pc = 0x826A6694; continue 'dispatch;
	}
	// 826A6690: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A6694: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 826A6698: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826A669C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A66A0: 419A0010  beq cr6, 0x826a66b0
	if ctx.cr[6].eq {
	pc = 0x826A66B0; continue 'dispatch;
	}
	// 826A66A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A66A8: 396BC4B0  addi r11, r11, -0x3b50
	ctx.r[11].s64 = ctx.r[11].s64 + -15184;
	// 826A66AC: 4800000C  b 0x826a66b8
	pc = 0x826A66B8; continue 'dispatch;
	// 826A66B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A66B4: 396B1180  addi r11, r11, 0x1180
	ctx.r[11].s64 = ctx.r[11].s64 + 4480;
	// 826A66B8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A66BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826A66C0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826A66C4: 83FF0140  lwz r31, 0x140(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A66C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A66CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A66D0: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6708 size=152
    let mut pc: u32 = 0x826A6708;
    'dispatch: loop {
        match pc {
            0x826A6708 => {
    //   block [0x826A6708..0x826A67A0)
	// 826A6708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A670C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A6714: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A6718: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A671C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6720: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A6724: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A6728: 419A0050  beq cr6, 0x826a6778
	if ctx.cr[6].eq {
	pc = 0x826A6778; continue 'dispatch;
	}
	// 826A672C: C3FF0100  lfs f31, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A6730: C03F0154  lfs f1, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A6734: 4BFFF2A5  bl 0x826a59d8
	ctx.lr = 0x826A6738;
	sub_826A59D8(ctx, base);
	// 826A6738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A673C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826A6740: 4BFFF619  bl 0x826a5d58
	ctx.lr = 0x826A6744;
	sub_826A5D58(ctx, base);
	// 826A6744: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A6748: 4BC297E9  bl 0x822cff30
	ctx.lr = 0x826A674C;
	sub_822CFF30(ctx, base);
	// 826A674C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A6750: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A6754: 4BC29995  bl 0x822d00e8
	ctx.lr = 0x826A6758;
	sub_822D00E8(ctx, base);
	// 826A6758: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A675C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6760: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A6764: 83FF0140  lwz r31, 0x140(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A6768: 4BFFF849  bl 0x826a5fb0
	ctx.lr = 0x826A676C;
	sub_826A5FB0(ctx, base);
	// 826A676C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A6770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6774: 48000010  b 0x826a6784
	pc = 0x826A6784; continue 'dispatch;
	// 826A6778: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A677C: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A6780: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A6784: 4876CADD  bl 0x82e13260
	ctx.lr = 0x826A6788;
	sub_82E13260(ctx, base);
	// 826A6788: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826A678C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A6790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A6794: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A6798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A679C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A67A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A67A0 size=100
    let mut pc: u32 = 0x826A67A0;
    'dispatch: loop {
        match pc {
            0x826A67A0 => {
    //   block [0x826A67A0..0x826A6804)
	// 826A67A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A67A4: 48B019C9  bl 0x831a816c
	ctx.lr = 0x826A67A8;
	sub_831A8130(ctx, base);
	// 826A67A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A67AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A67B0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A67B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A67B8: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826A67BC: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A67C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A67C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A67C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A67CC: 4E800421  bctrl
	ctx.lr = 0x826A67D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A67D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A67D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A67D8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826A67DC: 487D54ED  bl 0x82e7bcc8
	ctx.lr = 0x826A67E0;
	sub_82E7BCC8(ctx, base);
	// 826A67E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826A67E4: 39400120  li r10, 0x120
	ctx.r[10].s64 = 288;
	// 826A67E8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A67EC: 13FF50C7  vcmpequd (lvx128) v31, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A6808 size=168
    let mut pc: u32 = 0x826A6808;
    'dispatch: loop {
        match pc {
            0x826A6808 => {
    //   block [0x826A6808..0x826A68B0)
	// 826A6808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A680C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A6814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A6818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A681C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6820: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6824: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A6828: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A682C: 396B11F4  addi r11, r11, 0x11f4
	ctx.r[11].s64 = ctx.r[11].s64 + 4596;
	// 826A6830: 394A11E0  addi r10, r10, 0x11e0
	ctx.r[10].s64 = ctx.r[10].s64 + 4576;
	// 826A6834: 39291194  addi r9, r9, 0x1194
	ctx.r[9].s64 = ctx.r[9].s64 + 4500;
	// 826A6838: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A683C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A6840: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 826A6844: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A6848: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826A684C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A6850: 419A0008  beq cr6, 0x826a6858
	if ctx.cr[6].eq {
	pc = 0x826A6858; continue 'dispatch;
	}
	// 826A6854: 4BC1A03D  bl 0x822c0890
	ctx.lr = 0x826A6858;
	sub_822C0890(ctx, base);
	// 826A6858: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826A685C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A6860: 419A0008  beq cr6, 0x826a6868
	if ctx.cr[6].eq {
	pc = 0x826A6868; continue 'dispatch;
	}
	// 826A6864: 4BC1A02D  bl 0x822c0890
	ctx.lr = 0x826A6868;
	sub_822C0890(ctx, base);
	// 826A6868: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826A686C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A6870: 419A0008  beq cr6, 0x826a6878
	if ctx.cr[6].eq {
	pc = 0x826A6878; continue 'dispatch;
	}
	// 826A6874: 4BC1A01D  bl 0x822c0890
	ctx.lr = 0x826A6878;
	sub_822C0890(ctx, base);
	// 826A6878: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826A687C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A6880: 419A0008  beq cr6, 0x826a6888
	if ctx.cr[6].eq {
	pc = 0x826A6888; continue 'dispatch;
	}
	// 826A6884: 4BC1A00D  bl 0x822c0890
	ctx.lr = 0x826A6888;
	sub_822C0890(ctx, base);
	// 826A6888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A688C: 48100DCD  bl 0x827a7658
	ctx.lr = 0x826A6890;
	sub_827A7658(ctx, base);
	// 826A6890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6894: 4BCA8ABD  bl 0x8234f350
	ctx.lr = 0x826A6898;
	sub_8234F350(ctx, base);
	// 826A6898: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A689C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A68A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A68A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A68A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A68AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A68B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A68B0 size=8
    let mut pc: u32 = 0x826A68B0;
    'dispatch: loop {
        match pc {
            0x826A68B0 => {
    //   block [0x826A68B0..0x826A68B8)
	// 826A68B0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826A68B4: 480003B4  b 0x826a6c68
	sub_826A6C68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A68B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A68B8 size=8
    let mut pc: u32 = 0x826A68B8;
    'dispatch: loop {
        match pc {
            0x826A68B8 => {
    //   block [0x826A68B8..0x826A68C0)
	// 826A68B8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826A68BC: 480003AC  b 0x826a6c68
	sub_826A6C68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A68C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A68C0 size=300
    let mut pc: u32 = 0x826A68C0;
    'dispatch: loop {
        match pc {
            0x826A68C0 => {
    //   block [0x826A68C0..0x826A69EC)
	// 826A68C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A68C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A68C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A68CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A68D0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A68D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A68D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826A68DC: 815F016C  lwz r10, 0x16c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 826A68E0: 816B853C  lwz r11, -0x7ac4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 826A68E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A68E8: 419A008C  beq cr6, 0x826a6974
	if ctx.cr[6].eq {
	pc = 0x826A6974; continue 'dispatch;
	}
	// 826A68EC: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826A68F0: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 826A68F4: 815F0134  lwz r10, 0x134(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 826A68F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A68FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A6900: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A6904: 419A0024  beq cr6, 0x826a6928
	if ctx.cr[6].eq {
	pc = 0x826A6928; continue 'dispatch;
	}
	// 826A6908: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A690C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A6910: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A6914: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A6918: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A691C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A6920: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A6924: 4082FFE8  bne 0x826a690c
	if !ctx.cr[0].eq {
	pc = 0x826A690C; continue 'dispatch;
	}
	// 826A6928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A692C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A6930: 4BE68C39  bl 0x8250f568
	ctx.lr = 0x826A6934;
	sub_8250F568(ctx, base);
	// 826A6934: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A6938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A693C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 826A6940: 409A0008  bne cr6, 0x826a6948
	if !ctx.cr[6].eq {
	pc = 0x826A6948; continue 'dispatch;
	}
	// 826A6944: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A6948: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A694C: 80DF016C  lwz r6, 0x16c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 826A6950: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A6954: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 826A6958: 388A1238  addi r4, r10, 0x1238
	ctx.r[4].s64 = ctx.r[10].s64 + 4664;
	// 826A695C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826A6960: 38A00304  li r5, 0x304
	ctx.r[5].s64 = 772;
	// 826A6964: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A6968: 48106C69  bl 0x827ad5d0
	ctx.lr = 0x826A696C;
	sub_827AD5D0(ctx, base);
	// 826A696C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A6970: 4874B321  bl 0x82df1c90
	ctx.lr = 0x826A6974;
	sub_82DF1C90(ctx, base);
	// 826A6974: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A6978: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826A697C: 419A0048  beq cr6, 0x826a69c4
	if ctx.cr[6].eq {
	pc = 0x826A69C4; continue 'dispatch;
	}
	// 826A6980: 4BC29591  bl 0x822cff10
	ctx.lr = 0x826A6984;
	sub_822CFF10(ctx, base);
	// 826A6984: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 826A6988: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A698C: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A6990: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826A6994: 4BC2959D  bl 0x822cff30
	ctx.lr = 0x826A6998;
	sub_822CFF30(ctx, base);
	// 826A6998: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826A699C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A69A0: 4BC29749  bl 0x822d00e8
	ctx.lr = 0x826A69A4;
	sub_822D00E8(ctx, base);
	// 826A69A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A69A8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826A69AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A69B0: 83FF0140  lwz r31, 0x140(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A69B4: 4BFFF5FD  bl 0x826a5fb0
	ctx.lr = 0x826A69B8;
	sub_826A5FB0(ctx, base);
	// 826A69B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A69BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A69C0: 48000010  b 0x826a69d0
	pc = 0x826A69D0; continue 'dispatch;
	// 826A69C4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A69C8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A69CC: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A69D0: 4876C891  bl 0x82e13260
	ctx.lr = 0x826A69D4;
	sub_82E13260(ctx, base);
	// 826A69D4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826A69D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A69DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A69E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A69E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A69E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A69F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A69F0 size=192
    let mut pc: u32 = 0x826A69F0;
    'dispatch: loop {
        match pc {
            0x826A69F0 => {
    //   block [0x826A69F0..0x826A6AB0)
	// 826A69F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A69F4: 48B01775  bl 0x831a8168
	ctx.lr = 0x826A69F8;
	sub_831A8130(ctx, base);
	// 826A69F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A69FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A6A00: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826A6A04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826A6A08: 817E0148  lwz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 826A6A0C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 826A6A10: 419A0018  beq cr6, 0x826a6a28
	if ctx.cr[6].eq {
	pc = 0x826A6A28; continue 'dispatch;
	}
	// 826A6A14: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 826A6A18: 419A0010  beq cr6, 0x826a6a28
	if ctx.cr[6].eq {
	pc = 0x826A6A28; continue 'dispatch;
	}
	// 826A6A1C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 826A6A20: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 826A6A24: 409A0008  bne cr6, 0x826a6a2c
	if !ctx.cr[6].eq {
	pc = 0x826A6A2C; continue 'dispatch;
	}
	// 826A6A28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A6A2C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A6A30: 41820068  beq 0x826a6a98
	if ctx.cr[0].eq {
	pc = 0x826A6A98; continue 'dispatch;
	}
	// 826A6A34: 3BFE00F8  addi r31, r30, 0xf8
	ctx.r[31].s64 = ctx.r[30].s64 + 248;
	// 826A6A38: 389C0020  addi r4, r28, 0x20
	ctx.r[4].s64 = ctx.r[28].s64 + 32;
	// 826A6A3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A6A40: 387E00F0  addi r3, r30, 0xf0
	ctx.r[3].s64 = ctx.r[30].s64 + 240;
	// 826A6A44: 4810C335  bl 0x827b2d78
	ctx.lr = 0x826A6A48;
	sub_827B2D78(ctx, base);
	// 826A6A48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A6A4C: 41820034  beq 0x826a6a80
	if ctx.cr[0].eq {
	pc = 0x826A6A80; continue 'dispatch;
	}
	// 826A6A50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A6A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A6A58: 419A0040  beq cr6, 0x826a6a98
	if ctx.cr[6].eq {
	pc = 0x826A6A98; continue 'dispatch;
	}
	// 826A6A5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A6A60: 4BC29689  bl 0x822d00e8
	ctx.lr = 0x826A6A64;
	sub_822D00E8(ctx, base);
	// 826A6A64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A6A68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A6A6C: 4BE6B015  bl 0x82511a80
	ctx.lr = 0x826A6A70;
	sub_82511A80(ctx, base);
	// 826A6A70: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A6A74: 4BC294AD  bl 0x822cff20
	ctx.lr = 0x826A6A78;
	sub_822CFF20(ctx, base);
	// 826A6A78: D03E0100  stfs f1, 0x100(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 826A6A7C: 4800002C  b 0x826a6aa8
	pc = 0x826A6AA8; continue 'dispatch;
	// 826A6A80: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826A6A84: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A6A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A6A8C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 826A6A90: 419A0008  beq cr6, 0x826a6a98
	if ctx.cr[6].eq {
	pc = 0x826A6A98; continue 'dispatch;
	}
	// 826A6A94: 4BC19DFD  bl 0x822c0890
	ctx.lr = 0x826A6A98;
	sub_822C0890(ctx, base);
	// 826A6A98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A6A9C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A6AA0: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 826A6AA4: 4BE6BB75  bl 0x82512618
	ctx.lr = 0x826A6AA8;
	sub_82512618(ctx, base);
	// 826A6AA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826A6AAC: 48B0170C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A6AB0 size=112
    let mut pc: u32 = 0x826A6AB0;
    'dispatch: loop {
        match pc {
            0x826A6AB0 => {
    //   block [0x826A6AB0..0x826A6B20)
	// 826A6AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A6AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6AB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A6ABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A6AC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A6AC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A6AC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6ACC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826A6AD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A6AD4: 4BFFF415  bl 0x826a5ee8
	ctx.lr = 0x826A6AD8;
	sub_826A5EE8(ctx, base);
	// 826A6AD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A6ADC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A6AE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826A6AE4: 4BC1951D  bl 0x822c0000
	ctx.lr = 0x826A6AE8;
	sub_822C0000(ctx, base);
	// 826A6AE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A6AEC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A6AF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A6AF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826A6AF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A6AFC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A6B00: 419A0008  beq cr6, 0x826a6b08
	if ctx.cr[6].eq {
	pc = 0x826A6B08; continue 'dispatch;
	}
	// 826A6B04: 4BC19D8D  bl 0x822c0890
	ctx.lr = 0x826A6B08;
	sub_822C0890(ctx, base);
	// 826A6B08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A6B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A6B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A6B14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A6B18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A6B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6B20 size=324
    let mut pc: u32 = 0x826A6B20;
    'dispatch: loop {
        match pc {
            0x826A6B20 => {
    //   block [0x826A6B20..0x826A6C64)
	// 826A6B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A6B24: 48B01645  bl 0x831a8168
	ctx.lr = 0x826A6B28;
	sub_831A8130(ctx, base);
	// 826A6B28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A6B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6B30: 4BE6B801  bl 0x82512330
	ctx.lr = 0x826A6B34;
	sub_82512330(ctx, base);
	// 826A6B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A6B38: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A6B3C: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826A6B40: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 826A6B44: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826A6B48: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 826A6B4C: 396A11F4  addi r11, r10, 0x11f4
	ctx.r[11].s64 = ctx.r[10].s64 + 4596;
	// 826A6B50: 394911E0  addi r10, r9, 0x11e0
	ctx.r[10].s64 = ctx.r[9].s64 + 4576;
	// 826A6B54: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826A6B58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A6B5C: 39281194  addi r9, r8, 0x1194
	ctx.r[9].s64 = ctx.r[8].s64 + 4500;
	// 826A6B60: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826A6B64: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826A6B68: 9BDF00E8  stb r30, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u8 ) };
	// 826A6B6C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826A6B70: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 826A6B74: 9B9F00E9  stb r28, 0xe9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(233 as u32), ctx.r[28].u8 ) };
	// 826A6B78: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 826A6B7C: 481C49CD  bl 0x8286b548
	ctx.lr = 0x826A6B80;
	sub_8286B548(ctx, base);
	// 826A6B80: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A6B84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A6B88: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 826A6B8C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 826A6B90: 93DF00FC  stw r30, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 826A6B94: 9B9F0104  stb r28, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[28].u8 ) };
	// 826A6B98: 39200120  li r9, 0x120
	ctx.r[9].s64 = 288;
	// 826A6B9C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826A6BA0: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 826A6BA4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A6BA8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826A6BAC: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 826A6BB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A6BB4: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 826A6BB8: 388A1238  addi r4, r10, 0x1238
	ctx.r[4].s64 = ctx.r[10].s64 + 4664;
	// 826A6BBC: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 826A6BC0: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 826A6BC4: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 826A6BC8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826A6BCC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A6BD0: 3BBF0134  addi r29, r31, 0x134
	ctx.r[29].s64 = ctx.r[31].s64 + 308;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A6C68 size=76
    let mut pc: u32 = 0x826A6C68;
    'dispatch: loop {
        match pc {
            0x826A6C68 => {
    //   block [0x826A6C68..0x826A6CB4)
	// 826A6C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A6C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A6C70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A6C74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A6C78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A6C7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6C80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A6C84: 4BFFFB85  bl 0x826a6808
	ctx.lr = 0x826A6C88;
	sub_826A6808(ctx, base);
	// 826A6C88: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A6C8C: 4182000C  beq 0x826a6c98
	if ctx.cr[0].eq {
	pc = 0x826A6C98; continue 'dispatch;
	}
	// 826A6C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6C94: 4874B745  bl 0x82df23d8
	ctx.lr = 0x826A6C98;
	sub_82DF23D8(ctx, base);
	// 826A6C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A6C9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A6CA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A6CA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A6CA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A6CAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A6CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A6CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A6CB8 size=1912
    let mut pc: u32 = 0x826A6CB8;
    'dispatch: loop {
        match pc {
            0x826A6CB8 => {
    //   block [0x826A6CB8..0x826A7430)
	// 826A6CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A6CBC: 48B014A1  bl 0x831a815c
	ctx.lr = 0x826A6CC0;
	sub_831A8130(ctx, base);
	// 826A6CC0: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 826A6CC4: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 826A6CC8: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 826A6CCC: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A6CD0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6CD4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 826A6CD8: 3B6B1238  addi r27, r11, 0x1238
	ctx.r[27].s64 = ctx.r[11].s64 + 4664;
	// 826A6CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A6CE0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 826A6CE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A6CE8: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 826A6CEC: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 826A6CF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A6CF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A6CF8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 826A6CFC: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 826A6D00: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826A6D04: 4BC196D5  bl 0x822c03d8
	ctx.lr = 0x826A6D08;
	sub_822C03D8(ctx, base);
	// 826A6D08: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A6D0C: 41820034  beq 0x826a6d40
	if ctx.cr[0].eq {
	pc = 0x826A6D40; continue 'dispatch;
	}
	// 826A6D10: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6D18: 388BC580  addi r4, r11, -0x3a80
	ctx.r[4].s64 = ctx.r[11].s64 + -14976;
	// 826A6D1C: 4874CCED  bl 0x82df3a08
	ctx.lr = 0x826A6D20;
	sub_82DF3A08(ctx, base);
	// 826A6D20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A6D24: 38BF0064  addi r5, r31, 0x64
	ctx.r[5].s64 = ctx.r[31].s64 + 100;
	// 826A6D28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A6D2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6D30: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826A6D34: 4BF056DD  bl 0x825ac410
	ctx.lr = 0x826A6D38;
	sub_825AC410(ctx, base);
	// 826A6D38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A6D3C: 48000008  b 0x826a6d44
	pc = 0x826A6D44; continue 'dispatch;
	// 826A6D40: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826A6D44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A6D48: 4BF0B6B1  bl 0x825b23f8
	ctx.lr = 0x826A6D4C;
	sub_825B23F8(ctx, base);
	// 826A6D4C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A6D50: 41820010  beq 0x826a6d60
	if ctx.cr[0].eq {
	pc = 0x826A6D60; continue 'dispatch;
	}
	// 826A6D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6D58: 579C003C  rlwinm r28, r28, 0, 0, 0x1e
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 826A6D5C: 4874C6CD  bl 0x82df3428
	ctx.lr = 0x826A6D60;
	sub_82DF3428(ctx, base);
	// 826A6D60: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6D68: 388BC578  addi r4, r11, -0x3a88
	ctx.r[4].s64 = ctx.r[11].s64 + -14984;
	// 826A6D6C: 4874CC9D  bl 0x82df3a08
	ctx.lr = 0x826A6D70;
	sub_82DF3A08(ctx, base);
	// 826A6D70: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826A6D74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6D78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A6D7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6D80: 4BF05041  bl 0x825abdc0
	ctx.lr = 0x826A6D84;
	sub_825ABDC0(ctx, base);
	// 826A6D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6D88: 4874C6A1  bl 0x82df3428
	ctx.lr = 0x826A6D8C;
	sub_82DF3428(ctx, base);
	// 826A6D8C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6D94: 388B1344  addi r4, r11, 0x1344
	ctx.r[4].s64 = ctx.r[11].s64 + 4932;
	// 826A6D98: 4874CC71  bl 0x82df3a08
	ctx.lr = 0x826A6D9C;
	sub_82DF3A08(ctx, base);
	// 826A6D9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6DA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A6DA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6DA8: 4BF05019  bl 0x825abdc0
	ctx.lr = 0x826A6DAC;
	sub_825ABDC0(ctx, base);
	// 826A6DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6DB0: 4874C679  bl 0x82df3428
	ctx.lr = 0x826A6DB4;
	sub_82DF3428(ctx, base);
	// 826A6DB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6DB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6DBC: 388B1334  addi r4, r11, 0x1334
	ctx.r[4].s64 = ctx.r[11].s64 + 4916;
	// 826A6DC0: 4874CC49  bl 0x82df3a08
	ctx.lr = 0x826A6DC4;
	sub_82DF3A08(ctx, base);
	// 826A6DC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6DC8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826A6DCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6DD0: 4BF04FF1  bl 0x825abdc0
	ctx.lr = 0x826A6DD4;
	sub_825ABDC0(ctx, base);
	// 826A6DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6DD8: 4874C651  bl 0x82df3428
	ctx.lr = 0x826A6DDC;
	sub_82DF3428(ctx, base);
	// 826A6DDC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 826A6DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6DE4: 388B997C  addi r4, r11, -0x6684
	ctx.r[4].s64 = ctx.r[11].s64 + -26244;
	// 826A6DE8: 4874CC21  bl 0x82df3a08
	ctx.lr = 0x826A6DEC;
	sub_82DF3A08(ctx, base);
	// 826A6DEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6DF0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826A6DF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6DF8: 4BF04FC9  bl 0x825abdc0
	ctx.lr = 0x826A6DFC;
	sub_825ABDC0(ctx, base);
	// 826A6DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E00: 4874C629  bl 0x82df3428
	ctx.lr = 0x826A6E04;
	sub_82DF3428(ctx, base);
	// 826A6E04: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E0C: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 826A6E10: 4874CBF9  bl 0x82df3a08
	ctx.lr = 0x826A6E14;
	sub_82DF3A08(ctx, base);
	// 826A6E14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6E18: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826A6E1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6E20: 4BF04FA1  bl 0x825abdc0
	ctx.lr = 0x826A6E24;
	sub_825ABDC0(ctx, base);
	// 826A6E24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E28: 4874C601  bl 0x82df3428
	ctx.lr = 0x826A6E2C;
	sub_82DF3428(ctx, base);
	// 826A6E2C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6E30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E34: 388B131C  addi r4, r11, 0x131c
	ctx.r[4].s64 = ctx.r[11].s64 + 4892;
	// 826A6E38: 4874CBD1  bl 0x82df3a08
	ctx.lr = 0x826A6E3C;
	sub_82DF3A08(ctx, base);
	// 826A6E3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6E40: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826A6E44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6E48: 4BF04F79  bl 0x825abdc0
	ctx.lr = 0x826A6E4C;
	sub_825ABDC0(ctx, base);
	// 826A6E4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E50: 4874C5D9  bl 0x82df3428
	ctx.lr = 0x826A6E54;
	sub_82DF3428(ctx, base);
	// 826A6E54: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6E58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E5C: 388B1314  addi r4, r11, 0x1314
	ctx.r[4].s64 = ctx.r[11].s64 + 4884;
	// 826A6E60: 4874CBA9  bl 0x82df3a08
	ctx.lr = 0x826A6E64;
	sub_82DF3A08(ctx, base);
	// 826A6E64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6E68: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826A6E6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6E70: 4BF04F51  bl 0x825abdc0
	ctx.lr = 0x826A6E74;
	sub_825ABDC0(ctx, base);
	// 826A6E74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E78: 4874C5B1  bl 0x82df3428
	ctx.lr = 0x826A6E7C;
	sub_82DF3428(ctx, base);
	// 826A6E7C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6E84: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 826A6E88: 4874CB81  bl 0x82df3a08
	ctx.lr = 0x826A6E8C;
	sub_82DF3A08(ctx, base);
	// 826A6E8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6E90: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826A6E94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6E98: 4BF04F29  bl 0x825abdc0
	ctx.lr = 0x826A6E9C;
	sub_825ABDC0(ctx, base);
	// 826A6E9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6EA0: 4874C589  bl 0x82df3428
	ctx.lr = 0x826A6EA4;
	sub_82DF3428(ctx, base);
	// 826A6EA4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6EAC: 388B12F8  addi r4, r11, 0x12f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4856;
	// 826A6EB0: 4874CB59  bl 0x82df3a08
	ctx.lr = 0x826A6EB4;
	sub_82DF3A08(ctx, base);
	// 826A6EB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6EB8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826A6EBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6EC0: 4BF04F01  bl 0x825abdc0
	ctx.lr = 0x826A6EC4;
	sub_825ABDC0(ctx, base);
	// 826A6EC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6EC8: 4874C561  bl 0x82df3428
	ctx.lr = 0x826A6ECC;
	sub_82DF3428(ctx, base);
	// 826A6ECC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6ED4: 388B12EC  addi r4, r11, 0x12ec
	ctx.r[4].s64 = ctx.r[11].s64 + 4844;
	// 826A6ED8: 4874CB31  bl 0x82df3a08
	ctx.lr = 0x826A6EDC;
	sub_82DF3A08(ctx, base);
	// 826A6EDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6EE0: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 826A6EE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6EE8: 4BF04ED9  bl 0x825abdc0
	ctx.lr = 0x826A6EEC;
	sub_825ABDC0(ctx, base);
	// 826A6EEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6EF0: 4874C539  bl 0x82df3428
	ctx.lr = 0x826A6EF4;
	sub_82DF3428(ctx, base);
	// 826A6EF4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6EFC: 388B12D4  addi r4, r11, 0x12d4
	ctx.r[4].s64 = ctx.r[11].s64 + 4820;
	// 826A6F00: 4874CB09  bl 0x82df3a08
	ctx.lr = 0x826A6F04;
	sub_82DF3A08(ctx, base);
	// 826A6F04: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826A6F08: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 826A6F0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A6F10: 4BF04EB1  bl 0x825abdc0
	ctx.lr = 0x826A6F14;
	sub_825ABDC0(ctx, base);
	// 826A6F14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6F18: 4874C511  bl 0x82df3428
	ctx.lr = 0x826A6F1C;
	sub_82DF3428(ctx, base);
	// 826A6F1C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826A6F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6F24: 388B4A98  addi r4, r11, 0x4a98
	ctx.r[4].s64 = ctx.r[11].s64 + 19096;
	// 826A6F28: 4874CAE1  bl 0x82df3a08
	ctx.lr = 0x826A6F2C;
	sub_82DF3A08(ctx, base);
	// 826A6F2C: 83210064  lwz r25, 0x64(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A6F30: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 826A6F34: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826A6F38: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 826A6F3C: 419A0024  beq cr6, 0x826a6f60
	if ctx.cr[6].eq {
	pc = 0x826A6F60; continue 'dispatch;
	}
	// 826A6F40: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 826A6F44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A6F48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A6F4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A6F50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A6F54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A6F58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A6F5C: 4082FFE8  bne 0x826a6f44
	if !ctx.cr[0].eq {
	pc = 0x826A6F44; continue 'dispatch;
	}
	// 826A6F60: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826A6F64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A6F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A6F6C: 4BEFB1A5  bl 0x825a2110
	ctx.lr = 0x826A6F70;
	sub_825A2110(ctx, base);
	// 826A6F70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6F74: 4874C4B5  bl 0x82df3428
	ctx.lr = 0x826A6F78;
	sub_82DF3428(ctx, base);
	// 826A6F78: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6F7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A6F80: 388BD2E0  addi r4, r11, -0x2d20
	ctx.r[4].s64 = ctx.r[11].s64 + -11552;
	// 826A6F84: 4874CA85  bl 0x82df3a08
	ctx.lr = 0x826A6F88;
	sub_82DF3A08(ctx, base);
	// 826A6F88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A6F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6F90: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 826A6F94: 4874CA75  bl 0x82df3a08
	ctx.lr = 0x826A6F98;
	sub_82DF3A08(ctx, base);
	// 826A6F98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A6F9C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A6FA0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826A6FA4: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 826A6FA8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A6FAC: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A6FB0: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 826A6FB4: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A6FB8: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A6FBC: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A6FC0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A6FC4: 4BEFC2E5  bl 0x825a32a8
	ctx.lr = 0x826A6FC8;
	sub_825A32A8(ctx, base);
	// 826A6FC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A6FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A6FD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A6FD4: 4BEFA79D  bl 0x825a1770
	ctx.lr = 0x826A6FD8;
	sub_825A1770(ctx, base);
	// 826A6FD8: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 826A6FDC: 4874C44D  bl 0x82df3428
	ctx.lr = 0x826A6FE0;
	sub_82DF3428(ctx, base);
	// 826A6FE0: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 826A6FE4: 4BC21CD5  bl 0x822c8cb8
	ctx.lr = 0x826A6FE8;
	sub_822C8CB8(ctx, base);
	// 826A6FE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A6FEC: 4874C43D  bl 0x82df3428
	ctx.lr = 0x826A6FF0;
	sub_82DF3428(ctx, base);
	// 826A6FF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A6FF4: 4874C435  bl 0x82df3428
	ctx.lr = 0x826A6FF8;
	sub_82DF3428(ctx, base);
	// 826A6FF8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A6FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7000: 388BC4D4  addi r4, r11, -0x3b2c
	ctx.r[4].s64 = ctx.r[11].s64 + -15148;
	// 826A7004: 4874CA05  bl 0x82df3a08
	ctx.lr = 0x826A7008;
	sub_82DF3A08(ctx, base);
	// 826A7008: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A700C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7010: 388B1310  addi r4, r11, 0x1310
	ctx.r[4].s64 = ctx.r[11].s64 + 4880;
	// 826A7014: 4874C9F5  bl 0x82df3a08
	ctx.lr = 0x826A7018;
	sub_82DF3A08(ctx, base);
	// 826A7018: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A701C: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 826A7020: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A7024: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7028: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A702C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826A7030: C3ABDD6C  lfs f29, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826A7034: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826A7038: 4BEFC271  bl 0x825a32a8
	ctx.lr = 0x826A703C;
	sub_825A32A8(ctx, base);
	// 826A703C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A7040: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A7044: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7048: 4BEFA729  bl 0x825a1770
	ctx.lr = 0x826A704C;
	sub_825A1770(ctx, base);
	// 826A704C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826A7050: 4874C3D9  bl 0x82df3428
	ctx.lr = 0x826A7054;
	sub_82DF3428(ctx, base);
	// 826A7054: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826A7058: 4BC21C61  bl 0x822c8cb8
	ctx.lr = 0x826A705C;
	sub_822C8CB8(ctx, base);
	// 826A705C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7060: 4874C3C9  bl 0x82df3428
	ctx.lr = 0x826A7064;
	sub_82DF3428(ctx, base);
	// 826A7064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7068: 4874C3C1  bl 0x82df3428
	ctx.lr = 0x826A706C;
	sub_82DF3428(ctx, base);
	// 826A706C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A7070: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7074: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 826A7078: 4874C991  bl 0x82df3a08
	ctx.lr = 0x826A707C;
	sub_82DF3A08(ctx, base);
	// 826A707C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A7080: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7084: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 826A7088: 4874C981  bl 0x82df3a08
	ctx.lr = 0x826A708C;
	sub_82DF3A08(ctx, base);
	// 826A708C: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 826A7090: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7094: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A7098: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 826A709C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826A70A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A70A4: 4BEFC205  bl 0x825a32a8
	ctx.lr = 0x826A70A8;
	sub_825A32A8(ctx, base);
	// 826A70A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A70AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A70B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A70B4: 4BEFA6BD  bl 0x825a1770
	ctx.lr = 0x826A70B8;
	sub_825A1770(ctx, base);
	// 826A70B8: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 826A70BC: 4874C36D  bl 0x82df3428
	ctx.lr = 0x826A70C0;
	sub_82DF3428(ctx, base);
	// 826A70C0: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 826A70C4: 4BC21BF5  bl 0x822c8cb8
	ctx.lr = 0x826A70C8;
	sub_822C8CB8(ctx, base);
	// 826A70C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A70CC: 4874C35D  bl 0x82df3428
	ctx.lr = 0x826A70D0;
	sub_82DF3428(ctx, base);
	// 826A70D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A70D4: 4874C355  bl 0x82df3428
	ctx.lr = 0x826A70D8;
	sub_82DF3428(ctx, base);
	// 826A70D8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A70DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A70E0: 388BF3F8  addi r4, r11, -0xc08
	ctx.r[4].s64 = ctx.r[11].s64 + -3080;
	// 826A70E4: 4874C925  bl 0x82df3a08
	ctx.lr = 0x826A70E8;
	sub_82DF3A08(ctx, base);
	// 826A70E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A70EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A70F0: 388B4370  addi r4, r11, 0x4370
	ctx.r[4].s64 = ctx.r[11].s64 + 17264;
	// 826A70F4: 4874C915  bl 0x82df3a08
	ctx.lr = 0x826A70F8;
	sub_82DF3A08(ctx, base);
	// 826A70F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826A70FC: 38BF0074  addi r5, r31, 0x74
	ctx.r[5].s64 = ctx.r[31].s64 + 116;
	// 826A7100: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A7104: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7108: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A710C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 826A7110: C3AB9A8C  lfs f29, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826A7114: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826A7118: 4BEFC191  bl 0x825a32a8
	ctx.lr = 0x826A711C;
	sub_825A32A8(ctx, base);
	// 826A711C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A7120: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A7124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7128: 4BEFA649  bl 0x825a1770
	ctx.lr = 0x826A712C;
	sub_825A1770(ctx, base);
	// 826A712C: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 826A7130: 4874C2F9  bl 0x82df3428
	ctx.lr = 0x826A7134;
	sub_82DF3428(ctx, base);
	// 826A7134: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 826A7138: 4BC21B81  bl 0x822c8cb8
	ctx.lr = 0x826A713C;
	sub_822C8CB8(ctx, base);
	// 826A713C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7140: 4874C2E9  bl 0x82df3428
	ctx.lr = 0x826A7144;
	sub_82DF3428(ctx, base);
	// 826A7144: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7148: 4874C2E1  bl 0x82df3428
	ctx.lr = 0x826A714C;
	sub_82DF3428(ctx, base);
	// 826A714C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7154: 388B12C8  addi r4, r11, 0x12c8
	ctx.r[4].s64 = ctx.r[11].s64 + 4808;
	// 826A7158: 4874C8B1  bl 0x82df3a08
	ctx.lr = 0x826A715C;
	sub_82DF3A08(ctx, base);
	// 826A715C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7164: 388BD2D0  addi r4, r11, -0x2d30
	ctx.r[4].s64 = ctx.r[11].s64 + -11568;
	// 826A7168: 4874C8A1  bl 0x82df3a08
	ctx.lr = 0x826A716C;
	sub_82DF3A08(ctx, base);
	// 826A716C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A7170: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A7174: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A7178: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 826A717C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7180: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826A7184: C06B08A8  lfs f3, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826A7188: C04AD200  lfs f2, -0x2e00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826A718C: 4BEFC11D  bl 0x825a32a8
	ctx.lr = 0x826A7190;
	sub_825A32A8(ctx, base);
	// 826A7190: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A7194: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A7198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A719C: 4BEFA5D5  bl 0x825a1770
	ctx.lr = 0x826A71A0;
	sub_825A1770(ctx, base);
	// 826A71A0: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826A71A4: 4874C285  bl 0x82df3428
	ctx.lr = 0x826A71A8;
	sub_82DF3428(ctx, base);
	// 826A71A8: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826A71AC: 4BC21B0D  bl 0x822c8cb8
	ctx.lr = 0x826A71B0;
	sub_822C8CB8(ctx, base);
	// 826A71B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A71B4: 4874C275  bl 0x82df3428
	ctx.lr = 0x826A71B8;
	sub_82DF3428(ctx, base);
	// 826A71B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A71BC: 4874C26D  bl 0x82df3428
	ctx.lr = 0x826A71C0;
	sub_82DF3428(ctx, base);
	// 826A71C0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A71C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A71C8: 388BC50C  addi r4, r11, -0x3af4
	ctx.r[4].s64 = ctx.r[11].s64 + -15092;
	// 826A71CC: 4874C83D  bl 0x82df3a08
	ctx.lr = 0x826A71D0;
	sub_82DF3A08(ctx, base);
	// 826A71D0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A71D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A71D8: 388B1160  addi r4, r11, 0x1160
	ctx.r[4].s64 = ctx.r[11].s64 + 4448;
	// 826A71DC: 4874C82D  bl 0x82df3a08
	ctx.lr = 0x826A71E0;
	sub_82DF3A08(ctx, base);
	// 826A71E0: 38BF007C  addi r5, r31, 0x7c
	ctx.r[5].s64 = ctx.r[31].s64 + 124;
	// 826A71E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A71E8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 826A71EC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826A71F0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826A71F4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826A71F8: 4BEFC0B1  bl 0x825a32a8
	ctx.lr = 0x826A71FC;
	sub_825A32A8(ctx, base);
	// 826A71FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A7200: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A7204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7208: 4BEFA569  bl 0x825a1770
	ctx.lr = 0x826A720C;
	sub_825A1770(ctx, base);
	// 826A720C: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 826A7210: 4874C219  bl 0x82df3428
	ctx.lr = 0x826A7214;
	sub_82DF3428(ctx, base);
	// 826A7214: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 826A7218: 4BC21AA1  bl 0x822c8cb8
	ctx.lr = 0x826A721C;
	sub_822C8CB8(ctx, base);
	// 826A721C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7220: 4874C209  bl 0x82df3428
	ctx.lr = 0x826A7224;
	sub_82DF3428(ctx, base);
	// 826A7224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7228: 4874C201  bl 0x82df3428
	ctx.lr = 0x826A722C;
	sub_82DF3428(ctx, base);
	// 826A722C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7234: 388B12BC  addi r4, r11, 0x12bc
	ctx.r[4].s64 = ctx.r[11].s64 + 4796;
	// 826A7238: 4874C7D1  bl 0x82df3a08
	ctx.lr = 0x826A723C;
	sub_82DF3A08(ctx, base);
	// 826A723C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7240: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7244: 388B1154  addi r4, r11, 0x1154
	ctx.r[4].s64 = ctx.r[11].s64 + 4436;
	// 826A7248: 4874C7C1  bl 0x82df3a08
	ctx.lr = 0x826A724C;
	sub_82DF3A08(ctx, base);
	// 826A724C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826A7250: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A7254: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A7258: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 826A725C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7260: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 826A7264: 4BEFC1B5  bl 0x825a3418
	ctx.lr = 0x826A7268;
	sub_825A3418(ctx, base);
	// 826A7268: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A726C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A7270: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7274: 4BEFAC65  bl 0x825a1ed8
	ctx.lr = 0x826A7278;
	sub_825A1ED8(ctx, base);
	// 826A7278: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 826A727C: 4874C1AD  bl 0x82df3428
	ctx.lr = 0x826A7280;
	sub_82DF3428(ctx, base);
	// 826A7280: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 826A7284: 4BC21A35  bl 0x822c8cb8
	ctx.lr = 0x826A7288;
	sub_822C8CB8(ctx, base);
	// 826A7288: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A728C: 4874C19D  bl 0x82df3428
	ctx.lr = 0x826A7290;
	sub_82DF3428(ctx, base);
	// 826A7290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7294: 4874C195  bl 0x82df3428
	ctx.lr = 0x826A7298;
	sub_82DF3428(ctx, base);
	// 826A7298: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A729C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A72A0: 388B4164  addi r4, r11, 0x4164
	ctx.r[4].s64 = ctx.r[11].s64 + 16740;
	// 826A72A4: 4874C765  bl 0x82df3a08
	ctx.lr = 0x826A72A8;
	sub_82DF3A08(ctx, base);
	// 826A72A8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A72AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A72B0: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 826A72B4: 4874C755  bl 0x82df3a08
	ctx.lr = 0x826A72B8;
	sub_82DF3A08(ctx, base);
	// 826A72B8: 38BF0084  addi r5, r31, 0x84
	ctx.r[5].s64 = ctx.r[31].s64 + 132;
	// 826A72BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A72C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A72C4: 4BEFBD8D  bl 0x825a3050
	ctx.lr = 0x826A72C8;
	sub_825A3050(ctx, base);
	// 826A72C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A72CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A72D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A72D4: 4BEFAEB5  bl 0x825a2188
	ctx.lr = 0x826A72D8;
	sub_825A2188(ctx, base);
	// 826A72D8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826A72DC: 4874C14D  bl 0x82df3428
	ctx.lr = 0x826A72E0;
	sub_82DF3428(ctx, base);
	// 826A72E0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826A72E4: 4BC219D5  bl 0x822c8cb8
	ctx.lr = 0x826A72E8;
	sub_822C8CB8(ctx, base);
	// 826A72E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A72EC: 4874C13D  bl 0x82df3428
	ctx.lr = 0x826A72F0;
	sub_82DF3428(ctx, base);
	// 826A72F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A72F4: 4874C135  bl 0x82df3428
	ctx.lr = 0x826A72F8;
	sub_82DF3428(ctx, base);
	// 826A72F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826A72FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A7300: 38A000B5  li r5, 0xb5
	ctx.r[5].s64 = 181;
	// 826A7304: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826A7308: 4BC190D1  bl 0x822c03d8
	ctx.lr = 0x826A730C;
	sub_822C03D8(ctx, base);
	// 826A730C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A7310: 41820034  beq 0x826a7344
	if ctx.cr[0].eq {
	pc = 0x826A7344; continue 'dispatch;
	}
	// 826A7314: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7318: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A731C: 388B12AC  addi r4, r11, 0x12ac
	ctx.r[4].s64 = ctx.r[11].s64 + 4780;
	// 826A7320: 4874C6E9  bl 0x82df3a08
	ctx.lr = 0x826A7324;
	sub_82DF3A08(ctx, base);
	// 826A7324: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 826A7328: 38BF0088  addi r5, r31, 0x88
	ctx.r[5].s64 = ctx.r[31].s64 + 136;
	// 826A732C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7330: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826A7334: 639C0002  ori r28, r28, 2
	ctx.r[28].u64 = ctx.r[28].u64 | 2;
	// 826A7338: 4BF02CF1  bl 0x825aa028
	ctx.lr = 0x826A733C;
	sub_825AA028(ctx, base);
	// 826A733C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826A7340: 48000008  b 0x826a7348
	pc = 0x826A7348; continue 'dispatch;
	// 826A7344: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 826A7348: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A734C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7350: 388B114C  addi r4, r11, 0x114c
	ctx.r[4].s64 = ctx.r[11].s64 + 4428;
	// 826A7354: 4874C6B5  bl 0x82df3a08
	ctx.lr = 0x826A7358;
	sub_82DF3A08(ctx, base);
	// 826A7358: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 826A735C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A7360: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826A7364: 4BF003BD  bl 0x825a7720
	ctx.lr = 0x826A7368;
	sub_825A7720(ctx, base);
	// 826A7368: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826A736C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A7370: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826A7374: 4BC18C8D  bl 0x822c0000
	ctx.lr = 0x826A7378;
	sub_822C0000(ctx, base);
	// 826A7378: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826A737C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A7380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7384: 4BEFAD8D  bl 0x825a2110
	ctx.lr = 0x826A7388;
	sub_825A2110(ctx, base);
	// 826A7388: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A738C: 4874C09D  bl 0x82df3428
	ctx.lr = 0x826A7390;
	sub_82DF3428(ctx, base);
	// 826A7390: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7394: 4182000C  beq 0x826a73a0
	if ctx.cr[0].eq {
	pc = 0x826A73A0; continue 'dispatch;
	}
	// 826A7398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A739C: 4874C08D  bl 0x82df3428
	ctx.lr = 0x826A73A0;
	sub_82DF3428(ctx, base);
	// 826A73A0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A73A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A73A8: 388B1298  addi r4, r11, 0x1298
	ctx.r[4].s64 = ctx.r[11].s64 + 4760;
	// 826A73AC: 4874C65D  bl 0x82df3a08
	ctx.lr = 0x826A73B0;
	sub_82DF3A08(ctx, base);
	// 826A73B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A73B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A73B8: 388B113C  addi r4, r11, 0x113c
	ctx.r[4].s64 = ctx.r[11].s64 + 4412;
	// 826A73BC: 4874C64D  bl 0x82df3a08
	ctx.lr = 0x826A73C0;
	sub_82DF3A08(ctx, base);
	// 826A73C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826A73C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A73C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A73CC: 38BF008C  addi r5, r31, 0x8c
	ctx.r[5].s64 = ctx.r[31].s64 + 140;
	// 826A73D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A73D4: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 826A73D8: 4BF067B9  bl 0x825adb90
	ctx.lr = 0x826A73DC;
	sub_825ADB90(ctx, base);
	// 826A73DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826A73E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826A73E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A73E8: 4BEFA9D1  bl 0x825a1db8
	ctx.lr = 0x826A73EC;
	sub_825A1DB8(ctx, base);
	// 826A73EC: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 826A73F0: 4874C039  bl 0x82df3428
	ctx.lr = 0x826A73F4;
	sub_82DF3428(ctx, base);
	// 826A73F4: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 826A73F8: 4BC218C1  bl 0x822c8cb8
	ctx.lr = 0x826A73FC;
	sub_822C8CB8(ctx, base);
	// 826A73FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7400: 4874C029  bl 0x82df3428
	ctx.lr = 0x826A7404;
	sub_82DF3428(ctx, base);
	// 826A7404: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7408: 4874C021  bl 0x82df3428
	ctx.lr = 0x826A740C;
	sub_82DF3428(ctx, base);
	// 826A740C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826A7410: 419A000C  beq cr6, 0x826a741c
	if ctx.cr[6].eq {
	pc = 0x826A741C; continue 'dispatch;
	}
	// 826A7414: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826A7418: 4BC19479  bl 0x822c0890
	ctx.lr = 0x826A741C;
	sub_822C0890(ctx, base);
	// 826A741C: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 826A7420: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 826A7424: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 826A7428: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 826A742C: 48B00D80  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7430 size=12
    let mut pc: u32 = 0x826A7430;
    'dispatch: loop {
        match pc {
            0x826A7430 => {
    //   block [0x826A7430..0x826A743C)
	// 826A7430: 81630148  lwz r11, 0x148(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) } as u64;
	// 826A7434: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 826A7438: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A743C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A743C size=40
    //   switch @ 0x826A7454: r11 with 11 label(s)
    //       case  0  0x826A7464
    //       case  1  0x826A7474
    //       case  2  0x826A7478
    //       case  3  0x826A747C
    //       case  4  0x826A7480
    //       case  5  0x826A7484
    //       case  6  0x826A7488
    //       case  7  0x826A748C
    //       case  8  0x826A7490
    //       case  9  0x826A7494
    //       case 10  0x826A7498
    let mut pc: u32 = 0x826A743C;
    'dispatch: loop {
        match pc {
            0x826A743C => {
    //   block [0x826A743C..0x826A7464)
	// 826A743C: 3D808205  lis r12, -0x7dfb
	ctx.r[12].s64 = -2113601536;
	// 826A7440: 398C1130  addi r12, r12, 0x1130
	ctx.r[12].s64 = ctx.r[12].s64 + 4400;
	// 826A7444: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826A7448: 3D80826A  lis r12, -0x7d96
	ctx.r[12].s64 = -2106982400;
	// 826A744C: 398C7464  addi r12, r12, 0x7464
	ctx.r[12].s64 = ctx.r[12].s64 + 29796;
	// 826A7450: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 826A7454: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 826A7458: 60000000  nop
	// 826A745C: 60000000  nop
	// 826A7460: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7464(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7464 size=16
    let mut pc: u32 = 0x826A7464;
    'dispatch: loop {
        match pc {
            0x826A7464 => {
    //   block [0x826A7464..0x826A7474)
	// 826A7464: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A7468: 80630140  lwz r3, 0x140(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A746C: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A7470: 4876BDF0  b 0x82e13260
	sub_82E13260(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7474(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7474 size=4
    let mut pc: u32 = 0x826A7474;
    'dispatch: loop {
        match pc {
            0x826A7474 => {
    //   block [0x826A7474..0x826A7478)
	// 826A7474: 4BFFEBEC  b 0x826a6060
	sub_826A6060(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7478 size=4
    let mut pc: u32 = 0x826A7478;
    'dispatch: loop {
        match pc {
            0x826A7478 => {
    //   block [0x826A7478..0x826A747C)
	// 826A7478: 4BFFEE10  b 0x826a6288
	sub_826A6288(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A747C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A747C size=4
    let mut pc: u32 = 0x826A747C;
    'dispatch: loop {
        match pc {
            0x826A747C => {
    //   block [0x826A747C..0x826A7480)
	// 826A747C: 4BFFF0EC  b 0x826a6568
	sub_826A6568(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7480 size=4
    let mut pc: u32 = 0x826A7480;
    'dispatch: loop {
        match pc {
            0x826A7480 => {
    //   block [0x826A7480..0x826A7484)
	// 826A7480: 4BFFECB8  b 0x826a6138
	sub_826A6138(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7484(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7484 size=4
    let mut pc: u32 = 0x826A7484;
    'dispatch: loop {
        match pc {
            0x826A7484 => {
    //   block [0x826A7484..0x826A7488)
	// 826A7484: 4BFFEF1C  b 0x826a63a0
	sub_826A63A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7488 size=4
    let mut pc: u32 = 0x826A7488;
    'dispatch: loop {
        match pc {
            0x826A7488 => {
    //   block [0x826A7488..0x826A748C)
	// 826A7488: 4BFFF1C8  b 0x826a6650
	sub_826A6650(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A748C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A748C size=4
    let mut pc: u32 = 0x826A748C;
    'dispatch: loop {
        match pc {
            0x826A748C => {
    //   block [0x826A748C..0x826A7490)
	// 826A748C: 4BFFED5C  b 0x826a61e8
	sub_826A61E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7490 size=4
    let mut pc: u32 = 0x826A7490;
    'dispatch: loop {
        match pc {
            0x826A7490 => {
    //   block [0x826A7490..0x826A7494)
	// 826A7490: 4BFFF000  b 0x826a6490
	sub_826A6490(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7494(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7494 size=4
    let mut pc: u32 = 0x826A7494;
    'dispatch: loop {
        match pc {
            0x826A7494 => {
    //   block [0x826A7494..0x826A7498)
	// 826A7494: 4BFFF274  b 0x826a6708
	sub_826A6708(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7498 size=8
    let mut pc: u32 = 0x826A7498;
    'dispatch: loop {
        match pc {
            0x826A7498 => {
    //   block [0x826A7498..0x826A74A0)
	// 826A7498: 4BFFF428  b 0x826a68c0
	sub_826A68C0(ctx, base);
	return;
	// 826A749C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A74A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A74A0 size=384
    let mut pc: u32 = 0x826A74A0;
    'dispatch: loop {
        match pc {
            0x826A74A0 => {
    //   block [0x826A74A0..0x826A7620)
	// 826A74A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A74A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A74A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A74AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A74B0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A74B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A74B8: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A74BC: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 826A74C0: 409A0108  bne cr6, 0x826a75c8
	if !ctx.cr[6].eq {
	pc = 0x826A75C8; continue 'dispatch;
	}
	// 826A74C4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826A74C8: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 826A74CC: 816B853C  lwz r11, -0x7ac4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 826A74D0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826A74D4: 419A0090  beq cr6, 0x826a7564
	if ctx.cr[6].eq {
	pc = 0x826A7564; continue 'dispatch;
	}
	// 826A74D8: 357FFF1C  addic. r11, r31, -0xe4
	ctx.xer.ca = (ctx.r[31].u32 > (!(-228 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + -228;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A74DC: 3BDFFF44  addi r30, r31, -0xbc
	ctx.r[30].s64 = ctx.r[31].s64 + -188;
	// 826A74E0: 40820008  bne 0x826a74e8
	if !ctx.cr[0].eq {
	pc = 0x826A74E8; continue 'dispatch;
	}
	// 826A74E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826A74E8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 826A74EC: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A74F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A74F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A74F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A74FC: 419A0024  beq cr6, 0x826a7520
	if ctx.cr[6].eq {
	pc = 0x826A7520; continue 'dispatch;
	}
	// 826A7500: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826A7504: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826A7508: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A750C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826A7510: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826A7514: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826A7518: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826A751C: 4082FFE8  bne 0x826a7504
	if !ctx.cr[0].eq {
	pc = 0x826A7504; continue 'dispatch;
	}
	// 826A7520: 389FFF1C  addi r4, r31, -0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + -228;
	// 826A7524: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A7528: 4BE68041  bl 0x8250f568
	ctx.lr = 0x826A752C;
	sub_8250F568(ctx, base);
	// 826A752C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A7534: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 826A7538: 409A0008  bne cr6, 0x826a7540
	if !ctx.cr[6].eq {
	pc = 0x826A7540; continue 'dispatch;
	}
	// 826A753C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A7540: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7544: 80DF0088  lwz r6, 0x88(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 826A7548: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 826A754C: 388B1238  addi r4, r11, 0x1238
	ctx.r[4].s64 = ctx.r[11].s64 + 4664;
	// 826A7550: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826A7554: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 826A7558: 48109789  bl 0x827b0ce0
	ctx.lr = 0x826A755C;
	sub_827B0CE0(ctx, base);
	// 826A755C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A7560: 4874A731  bl 0x82df1c90
	ctx.lr = 0x826A7564;
	sub_82DF1C90(ctx, base);
	// 826A7564: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 826A7568: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826A756C: 419A0048  beq cr6, 0x826a75b4
	if ctx.cr[6].eq {
	pc = 0x826A75B4; continue 'dispatch;
	}
	// 826A7570: 4BC289A1  bl 0x822cff10
	ctx.lr = 0x826A7574;
	sub_822CFF10(ctx, base);
	// 826A7574: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A7578: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 826A757C: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A7580: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826A7584: 4BC289AD  bl 0x822cff30
	ctx.lr = 0x826A7588;
	sub_822CFF30(ctx, base);
	// 826A7588: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826A758C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 826A7590: 4BC28B59  bl 0x822d00e8
	ctx.lr = 0x826A7594;
	sub_822D00E8(ctx, base);
	// 826A7594: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 826A7598: 389FFF1C  addi r4, r31, -0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + -228;
	// 826A759C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826A75A0: 83DF005C  lwz r30, 0x5c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A75A4: 4BFFEA0D  bl 0x826a5fb0
	ctx.lr = 0x826A75A8;
	sub_826A5FB0(ctx, base);
	// 826A75A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A75AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A75B0: 48000010  b 0x826a75c0
	pc = 0x826A75C0; continue 'dispatch;
	// 826A75B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A75B8: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A75BC: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A75C0: 4876BCA1  bl 0x82e13260
	ctx.lr = 0x826A75C4;
	sub_82E13260(ctx, base);
	// 826A75C4: 4800000C  b 0x826a75d0
	pc = 0x826A75D0; continue 'dispatch;
	// 826A75C8: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 826A75CC: 4BFFFE65  bl 0x826a7430
	ctx.lr = 0x826A75D0;
	sub_826A7430(ctx, base);
	// 826A75D0: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A75D4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A75D8: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 826A75DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A75E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A75E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A75E8: 4E800421  bctrl
	ctx.lr = 0x826A75EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A75EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A75F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A75F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A75F8: 487D46D1  bl 0x82e7bcc8
	ctx.lr = 0x826A75FC;
	sub_82E7BCC8(ctx, base);
	// 826A75FC: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 826A7600: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A7620 size=252
    let mut pc: u32 = 0x826A7620;
    'dispatch: loop {
        match pc {
            0x826A7620 => {
    //   block [0x826A7620..0x826A771C)
	// 826A7620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A7624: 48B00B49  bl 0x831a816c
	ctx.lr = 0x826A7628;
	sub_831A8130(ctx, base);
	// 826A7628: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A762C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A7630: 897E00E9  lbz r11, 0xe9(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(233 as u32) ) } as u64;
	// 826A7634: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A7638: 418200DC  beq 0x826a7714
	if ctx.cr[0].eq {
	pc = 0x826A7714; continue 'dispatch;
	}
	// 826A763C: 4BFFFDF5  bl 0x826a7430
	ctx.lr = 0x826A7640;
	sub_826A7430(ctx, base);
	// 826A7640: 807E0140  lwz r3, 0x140(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A7644: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A7648: 3BEB6910  addi r31, r11, 0x6910
	ctx.r[31].s64 = ctx.r[11].s64 + 26896;
	// 826A764C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7650: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826A7654: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A7658: 4E800421  bctrl
	ctx.lr = 0x826A765C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A765C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A7660: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826A7664: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A7668: 487D4661  bl 0x82e7bcc8
	ctx.lr = 0x826A766C;
	sub_82E7BCC8(ctx, base);
	// 826A766C: 39600120  li r11, 0x120
	ctx.r[11].s64 = 288;
	// 826A7670: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A7720 size=228
    let mut pc: u32 = 0x826A7720;
    'dispatch: loop {
        match pc {
            0x826A7720 => {
    //   block [0x826A7720..0x826A7804)
	// 826A7720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A7724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A7728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A772C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A7730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A7734: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7738: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A773C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826A7740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7744: 388B135C  addi r4, r11, 0x135c
	ctx.r[4].s64 = ctx.r[11].s64 + 4956;
	// 826A7748: 4874C2C1  bl 0x82df3a08
	ctx.lr = 0x826A774C;
	sub_82DF3A08(ctx, base);
	// 826A774C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A7750: 38BF013C  addi r5, r31, 0x13c
	ctx.r[5].s64 = ctx.r[31].s64 + 316;
	// 826A7754: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7758: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A775C: 4BF5092D  bl 0x825f8088
	ctx.lr = 0x826A7760;
	sub_825F8088(ctx, base);
	// 826A7760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7764: 4874BCC5  bl 0x82df3428
	ctx.lr = 0x826A7768;
	sub_82DF3428(ctx, base);
	// 826A7768: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A776C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7770: 388B1340  addi r4, r11, 0x1340
	ctx.r[4].s64 = ctx.r[11].s64 + 4928;
	// 826A7774: 4874C295  bl 0x82df3a08
	ctx.lr = 0x826A7778;
	sub_82DF3A08(ctx, base);
	// 826A7778: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A777C: 38BF0104  addi r5, r31, 0x104
	ctx.r[5].s64 = ctx.r[31].s64 + 260;
	// 826A7780: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7784: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7788: 4BF50901  bl 0x825f8088
	ctx.lr = 0x826A778C;
	sub_825F8088(ctx, base);
	// 826A778C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7790: 4874BC99  bl 0x82df3428
	ctx.lr = 0x826A7794;
	sub_82DF3428(ctx, base);
	// 826A7794: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826A7798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A779C: 388B1CE8  addi r4, r11, 0x1ce8
	ctx.r[4].s64 = ctx.r[11].s64 + 7400;
	// 826A77A0: 4874C269  bl 0x82df3a08
	ctx.lr = 0x826A77A4;
	sub_82DF3A08(ctx, base);
	// 826A77A4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A77A8: 38BF010C  addi r5, r31, 0x10c
	ctx.r[5].s64 = ctx.r[31].s64 + 268;
	// 826A77AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A77B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A77B4: 4BE656ED  bl 0x8250cea0
	ctx.lr = 0x826A77B8;
	sub_8250CEA0(ctx, base);
	// 826A77B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A77BC: 4874BC6D  bl 0x82df3428
	ctx.lr = 0x826A77C0;
	sub_82DF3428(ctx, base);
	// 826A77C0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A77C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A77C8: 388B134C  addi r4, r11, 0x134c
	ctx.r[4].s64 = ctx.r[11].s64 + 4940;
	// 826A77CC: 4874C23D  bl 0x82df3a08
	ctx.lr = 0x826A77D0;
	sub_82DF3A08(ctx, base);
	// 826A77D0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826A77D4: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 826A77D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A77DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A77E0: 4BE656C1  bl 0x8250cea0
	ctx.lr = 0x826A77E4;
	sub_8250CEA0(ctx, base);
	// 826A77E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A77E8: 4874BC41  bl 0x82df3428
	ctx.lr = 0x826A77EC;
	sub_82DF3428(ctx, base);
	// 826A77EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A77F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A77F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A77F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A77FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A7800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A7808 size=188
    let mut pc: u32 = 0x826A7808;
    'dispatch: loop {
        match pc {
            0x826A7808 => {
    //   block [0x826A7808..0x826A78C4)
	// 826A7808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A780C: 48B00961  bl 0x831a816c
	ctx.lr = 0x826A7810;
	sub_831A8130(ctx, base);
	// 826A7810: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A7814: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7818: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 826A781C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826A7820: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 826A7824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A7828: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826A782C: 487F8F05  bl 0x82ea0730
	ctx.lr = 0x826A7830;
	sub_82EA0730(ctx, base);
	// 826A7830: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 826A7834: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826A7838: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 826A783C: C02AD7BC  lfs f1, -0x2844(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826A7840: 488729B1  bl 0x82f1a1f0
	ctx.lr = 0x826A7844;
	sub_82F1A1F0(ctx, base);
	// 826A7844: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 826A7848: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826A784C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A7850: 808B6798  lwz r4, 0x6798(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26520 as u32) ) } as u64;
	// 826A7854: 4BC3D6DD  bl 0x822e4f30
	ctx.lr = 0x826A7858;
	sub_822E4F30(ctx, base);
	// 826A7858: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A785C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A7860: 4BC3D661  bl 0x822e4ec0
	ctx.lr = 0x826A7864;
	sub_822E4EC0(ctx, base);
	// 826A7864: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826A7868: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A786C: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826A7870: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A7874: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826A7878: 4BDE4A11  bl 0x8248c288
	ctx.lr = 0x826A787C;
	sub_8248C288(ctx, base);
	// 826A787C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A7880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A7884: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7888: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 826A788C: 4BE67C8D  bl 0x8250f518
	ctx.lr = 0x826A7890;
	sub_8250F518(ctx, base);
	// 826A7890: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A7894: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 826A7898: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826A789C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826A78A0: 4810B769  bl 0x827b3008
	ctx.lr = 0x826A78A4;
	sub_827B3008(ctx, base);
	// 826A78A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A78A8: 4874A3E9  bl 0x82df1c90
	ctx.lr = 0x826A78AC;
	sub_82DF1C90(ctx, base);
	// 826A78AC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826A78B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A78B4: 419A0008  beq cr6, 0x826a78bc
	if ctx.cr[6].eq {
	pc = 0x826A78BC; continue 'dispatch;
	}
	// 826A78B8: 4BC409B1  bl 0x822e8268
	ctx.lr = 0x826A78BC;
	sub_822E8268(ctx, base);
	// 826A78BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826A78C0: 48B008FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A78C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A78C8 size=276
    let mut pc: u32 = 0x826A78C8;
    'dispatch: loop {
        match pc {
            0x826A78C8 => {
    //   block [0x826A78C8..0x826A79DC)
	// 826A78C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A78CC: 48B0089D  bl 0x831a8168
	ctx.lr = 0x826A78D0;
	sub_831A8130(ctx, base);
	// 826A78D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A78D4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826A78D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A78DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A78E0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826A78E4: 41820038  beq 0x826a791c
	if ctx.cr[0].eq {
	pc = 0x826A791C; continue 'dispatch;
	}
	// 826A78E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A78EC: 48B0209D  bl 0x831a9988
	ctx.lr = 0x826A78F0;
	sub_831A9988(ctx, base);
	// 826A78F0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A78F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A78F8: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826A78FC: 48B007FD  bl 0x831a80f8
	ctx.lr = 0x826A7900;
	sub_831A80F8(ctx, base);
	// 826A7900: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7904: 41820018  beq 0x826a791c
	if ctx.cr[0].eq {
	pc = 0x826A791C; continue 'dispatch;
	}
	// 826A7908: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A790C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A7910: 4803E571  bl 0x826e5e80
	ctx.lr = 0x826A7914;
	sub_826E5E80(ctx, base);
	// 826A7914: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826A7918: 480000BC  b 0x826a79d4
	pc = 0x826A79D4; continue 'dispatch;
	// 826A791C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A7920: 419A00A4  beq cr6, 0x826a79c4
	if ctx.cr[6].eq {
	pc = 0x826A79C4; continue 'dispatch;
	}
	// 826A7924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7928: 48B02061  bl 0x831a9988
	ctx.lr = 0x826A792C;
	sub_831A9988(ctx, base);
	// 826A792C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A7930: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A7934: 386B5BA8  addi r3, r11, 0x5ba8
	ctx.r[3].s64 = ctx.r[11].s64 + 23464;
	// 826A7938: 48B007C1  bl 0x831a80f8
	ctx.lr = 0x826A793C;
	sub_831A80F8(ctx, base);
	// 826A793C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7940: 41820014  beq 0x826a7954
	if ctx.cr[0].eq {
	pc = 0x826A7954; continue 'dispatch;
	}
	// 826A7944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A7948: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A794C: 4BFFF0A5  bl 0x826a69f0
	ctx.lr = 0x826A7950;
	sub_826A69F0(ctx, base);
	// 826A7950: 4BFFFFC4  b 0x826a7914
	pc = 0x826A7914; continue 'dispatch;
	// 826A7954: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A7958: 419A006C  beq cr6, 0x826a79c4
	if ctx.cr[6].eq {
	pc = 0x826A79C4; continue 'dispatch;
	}
	// 826A795C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7960: 48B02029  bl 0x831a9988
	ctx.lr = 0x826A7964;
	sub_831A9988(ctx, base);
	// 826A7964: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A7968: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A796C: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826A7970: 48B00789  bl 0x831a80f8
	ctx.lr = 0x826A7974;
	sub_831A80F8(ctx, base);
	// 826A7974: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7978: 41820014  beq 0x826a798c
	if ctx.cr[0].eq {
	pc = 0x826A798C; continue 'dispatch;
	}
	// 826A797C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A7980: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A7984: 4BFFE455  bl 0x826a5dd8
	ctx.lr = 0x826A7988;
	sub_826A5DD8(ctx, base);
	// 826A7988: 4BFFFF8C  b 0x826a7914
	pc = 0x826A7914; continue 'dispatch;
	// 826A798C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826A7990: 419A0034  beq cr6, 0x826a79c4
	if ctx.cr[6].eq {
	pc = 0x826A79C4; continue 'dispatch;
	}
	// 826A7994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7998: 48B01FF1  bl 0x831a9988
	ctx.lr = 0x826A799C;
	sub_831A9988(ctx, base);
	// 826A799C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826A79A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A79A4: 386B7818  addi r3, r11, 0x7818
	ctx.r[3].s64 = ctx.r[11].s64 + 30744;
	// 826A79A8: 48B00751  bl 0x831a80f8
	ctx.lr = 0x826A79AC;
	sub_831A80F8(ctx, base);
	// 826A79AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A79B0: 41820014  beq 0x826a79c4
	if ctx.cr[0].eq {
	pc = 0x826A79C4; continue 'dispatch;
	}
	// 826A79B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A79B8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826A79BC: 4BFFEDE5  bl 0x826a67a0
	ctx.lr = 0x826A79C0;
	sub_826A67A0(ctx, base);
	// 826A79C0: 4BFFFF54  b 0x826a7914
	pc = 0x826A7914; continue 'dispatch;
	// 826A79C4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826A79C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A79CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A79D0: 4BE6AC49  bl 0x82512618
	ctx.lr = 0x826A79D4;
	sub_82512618(ctx, base);
	// 826A79D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A79D8: 48B007E0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A79E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A79E0 size=516
    let mut pc: u32 = 0x826A79E0;
    'dispatch: loop {
        match pc {
            0x826A79E0 => {
    //   block [0x826A79E0..0x826A7BE4)
	// 826A79E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A79E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A79E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A79EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A79F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A79F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A79F8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826A79FC: 4BE69FDD  bl 0x825119d8
	ctx.lr = 0x826A7A00;
	sub_825119D8(ctx, base);
	// 826A7A00: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A7A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7A08: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826A7A0C: 4874BFFD  bl 0x82df3a08
	ctx.lr = 0x826A7A10;
	sub_82DF3A08(ctx, base);
	// 826A7A10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A7A14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7A18: 4BE67AB1  bl 0x8250f4c8
	ctx.lr = 0x826A7A1C;
	sub_8250F4C8(ctx, base);
	// 826A7A1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A7A24: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A7A28: 409A0008  bne cr6, 0x826a7a30
	if !ctx.cr[6].eq {
	pc = 0x826A7A30; continue 'dispatch;
	}
	// 826A7A2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A7A30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A7A34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7A38: 4BE60D49  bl 0x82508780
	ctx.lr = 0x826A7A3C;
	sub_82508780(ctx, base);
	// 826A7A3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826A7A40: 4874A251  bl 0x82df1c90
	ctx.lr = 0x826A7A44;
	sub_82DF1C90(ctx, base);
	// 826A7A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7A48: 4874B9E1  bl 0x82df3428
	ctx.lr = 0x826A7A4C;
	sub_82DF3428(ctx, base);
	// 826A7A4C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826A7A50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7A54: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 826A7A58: 4874BFB1  bl 0x82df3a08
	ctx.lr = 0x826A7A5C;
	sub_82DF3A08(ctx, base);
	// 826A7A5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A7A60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A7A64: 4BE67A65  bl 0x8250f4c8
	ctx.lr = 0x826A7A68;
	sub_8250F4C8(ctx, base);
	// 826A7A68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7A6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A7A70: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826A7A74: 409A0008  bne cr6, 0x826a7a7c
	if !ctx.cr[6].eq {
	pc = 0x826A7A7C; continue 'dispatch;
	}
	// 826A7A78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826A7A7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826A7A80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7A84: 4BE60CFD  bl 0x82508780
	ctx.lr = 0x826A7A88;
	sub_82508780(ctx, base);
	// 826A7A88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826A7A8C: 4874A205  bl 0x82df1c90
	ctx.lr = 0x826A7A90;
	sub_82DF1C90(ctx, base);
	// 826A7A90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7A94: 4874B995  bl 0x82df3428
	ctx.lr = 0x826A7A98;
	sub_82DF3428(ctx, base);
	// 826A7A98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A7A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7AA0: 4BFFDE09  bl 0x826a58a8
	ctx.lr = 0x826A7AA4;
	sub_826A58A8(ctx, base);
	// 826A7AA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A7AA8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826A7AAC: 409A0008  bne cr6, 0x826a7ab4
	if !ctx.cr[6].eq {
	pc = 0x826A7AB4; continue 'dispatch;
	}
	// 826A7AB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A7AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7AB8: 4BE60CE9  bl 0x825087a0
	ctx.lr = 0x826A7ABC;
	sub_825087A0(ctx, base);
	// 826A7ABC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7AC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826A7AC4: 388B1238  addi r4, r11, 0x1238
	ctx.r[4].s64 = ctx.r[11].s64 + 4664;
	// 826A7AC8: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 826A7ACC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826A7AD0: 4874A919  bl 0x82df23e8
	ctx.lr = 0x826A7AD4;
	sub_82DF23E8(ctx, base);
	// 826A7AD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A7AD8: 41820018  beq 0x826a7af0
	if ctx.cr[0].eq {
	pc = 0x826A7AF0; continue 'dispatch;
	}
	// 826A7ADC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A7AE0: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A7AE4: 4876B60D  bl 0x82e130f0
	ctx.lr = 0x826A7AE8;
	sub_82E130F0(ctx, base);
	// 826A7AE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A7AEC: 48000008  b 0x826a7af4
	pc = 0x826A7AF4; continue 'dispatch;
	// 826A7AF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826A7AF4: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 826A7AF8: 4BC3A259  bl 0x822e1d50
	ctx.lr = 0x826A7AFC;
	sub_822E1D50(ctx, base);
	// 826A7AFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826A7B00: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826A7B04: 83DF0140  lwz r30, 0x140(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826A7B08: 4BE6A611  bl 0x82512118
	ctx.lr = 0x826A7B0C;
	sub_82512118(ctx, base);
	// 826A7B0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826A7B10: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7B14: 4876B31D  bl 0x82e12e30
	ctx.lr = 0x826A7B18;
	sub_82E12E30(ctx, base);
	// 826A7B18: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826A7B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A7B20: 419A0008  beq cr6, 0x826a7b28
	if ctx.cr[6].eq {
	pc = 0x826A7B28; continue 'dispatch;
	}
	// 826A7B24: 4BC18D6D  bl 0x822c0890
	ctx.lr = 0x826A7B28;
	sub_822C0890(ctx, base);
	// 826A7B28: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 826A7B2C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 826A7B30: 419A0018  beq cr6, 0x826a7b48
	if ctx.cr[6].eq {
	pc = 0x826A7B48; continue 'dispatch;
	}
	// 826A7B34: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 826A7B38: 419A0010  beq cr6, 0x826a7b48
	if ctx.cr[6].eq {
	pc = 0x826A7B48; continue 'dispatch;
	}
	// 826A7B3C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 826A7B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7B44: 409A0008  bne cr6, 0x826a7b4c
	if !ctx.cr[6].eq {
	pc = 0x826A7B4C; continue 'dispatch;
	}
	// 826A7B48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A7B4C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7B50: 4182003C  beq 0x826a7b8c
	if ctx.cr[0].eq {
	pc = 0x826A7B8C; continue 'dispatch;
	}
	// 826A7B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7B58: 4BFFFCB1  bl 0x826a7808
	ctx.lr = 0x826A7B5C;
	sub_826A7808(ctx, base);
	// 826A7B5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7B60: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 826A7B64: 4BE69F85  bl 0x82511ae8
	ctx.lr = 0x826A7B68;
	sub_82511AE8(ctx, base);
	// 826A7B68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826A7B6C: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 826A7B70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826A7B74: 4810B205  bl 0x827b2d78
	ctx.lr = 0x826A7B78;
	sub_827B2D78(ctx, base);
	// 826A7B78: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A7B7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826A7B80: 419A000C  beq cr6, 0x826a7b8c
	if ctx.cr[6].eq {
	pc = 0x826A7B8C; continue 'dispatch;
	}
	// 826A7B84: 4BC2839D  bl 0x822cff20
	ctx.lr = 0x826A7B88;
	sub_822CFF20(ctx, base);
	// 826A7B88: D03F0100  stfs f1, 0x100(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 826A7B8C: 897F013C  lbz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 826A7B90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A7B94: 40820020  bne 0x826a7bb4
	if !ctx.cr[0].eq {
	pc = 0x826A7BB4; continue 'dispatch;
	}
	// 826A7B98: 897F0168  lbz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 826A7B9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A7BA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A7BA4: 995F013C  stb r10, 0x13c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u8 ) };
	// 826A7BA8: 4182000C  beq 0x826a7bb4
	if ctx.cr[0].eq {
	pc = 0x826A7BB4; continue 'dispatch;
	}
	// 826A7BAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7BB0: 997F0104  stb r11, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 826A7BB4: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 826A7BB8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A7BBC: 813F0134  lwz r9, 0x134(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 826A7BC0: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A7BC4: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 826A7BC8: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826A7BCC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826A7BD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A7BD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A7BD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A7BDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A7BE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A7BE8 size=188
    let mut pc: u32 = 0x826A7BE8;
    'dispatch: loop {
        match pc {
            0x826A7BE8 => {
    //   block [0x826A7BE8..0x826A7CA4)
	// 826A7BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A7BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A7BF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A7BF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A7BF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A7BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A7C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7C04: 3BDFFF1C  addi r30, r31, -0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + -228;
	// 826A7C08: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826A7C0C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A7C10: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 826A7C14: 419A0018  beq cr6, 0x826a7c2c
	if ctx.cr[6].eq {
	pc = 0x826A7C2C; continue 'dispatch;
	}
	// 826A7C18: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 826A7C1C: 419A0010  beq cr6, 0x826a7c2c
	if ctx.cr[6].eq {
	pc = 0x826A7C2C; continue 'dispatch;
	}
	// 826A7C20: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 826A7C24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7C28: 409A0008  bne cr6, 0x826a7c30
	if !ctx.cr[6].eq {
	pc = 0x826A7C30; continue 'dispatch;
	}
	// 826A7C2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A7C30: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7C34: 4182000C  beq 0x826a7c40
	if ctx.cr[0].eq {
	pc = 0x826A7C40; continue 'dispatch;
	}
	// 826A7C38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7C3C: 4BFFFBCD  bl 0x826a7808
	ctx.lr = 0x826A7C40;
	sub_826A7808(ctx, base);
	// 826A7C40: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A7C44: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 826A7C48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826A7C4C: 419A0028  beq cr6, 0x826a7c74
	if ctx.cr[6].eq {
	pc = 0x826A7C74; continue 'dispatch;
	}
	// 826A7C50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A7C54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7C58: 4BFFDC51  bl 0x826a58a8
	ctx.lr = 0x826A7C5C;
	sub_826A58A8(ctx, base);
	// 826A7C5C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826A7C60: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826A7C64: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 826A7C68: 4876B5F9  bl 0x82e13260
	ctx.lr = 0x826A7C6C;
	sub_82E13260(ctx, base);
	// 826A7C6C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 826A7C70: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 826A7C74: 897F0084  lbz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 826A7C78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7C7C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 826A7C80: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 826A7C84: 997F0020  stb r11, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 826A7C88: 4BFFF7A9  bl 0x826a7430
	ctx.lr = 0x826A7C8C;
	sub_826A7430(ctx, base);
	// 826A7C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A7C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A7C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A7C98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A7C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A7CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7CA8 size=4
    let mut pc: u32 = 0x826A7CA8;
    'dispatch: loop {
        match pc {
            0x826A7CA8 => {
    //   block [0x826A7CA8..0x826A7CAC)
	// 826A7CA8: 4BFFFF40  b 0x826a7be8
	sub_826A7BE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A7CB0 size=220
    let mut pc: u32 = 0x826A7CB0;
    'dispatch: loop {
        match pc {
            0x826A7CB0 => {
    //   block [0x826A7CB0..0x826A7D8C)
	// 826A7CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A7CB4: 48B004B5  bl 0x831a8168
	ctx.lr = 0x826A7CB8;
	sub_831A8130(ctx, base);
	// 826A7CB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A7CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A7CC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A7CC4: 4BFFD1D5  bl 0x826a4e98
	ctx.lr = 0x826A7CC8;
	sub_826A4E98(ctx, base);
	// 826A7CC8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7CCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7CD0: 3BAB18B4  addi r29, r11, 0x18b4
	ctx.r[29].s64 = ctx.r[11].s64 + 6324;
	// 826A7CD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A7CD8: 4874BD31  bl 0x82df3a08
	ctx.lr = 0x826A7CDC;
	sub_82DF3A08(ctx, base);
	// 826A7CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7CE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A7CE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7CE8: 4BEF98A1  bl 0x825a1588
	ctx.lr = 0x826A7CEC;
	sub_825A1588(ctx, base);
	// 826A7CEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7CF0: 4874B739  bl 0x82df3428
	ctx.lr = 0x826A7CF4;
	sub_82DF3428(ctx, base);
	// 826A7CF4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7CF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7CFC: 3B8B18A4  addi r28, r11, 0x18a4
	ctx.r[28].s64 = ctx.r[11].s64 + 6308;
	// 826A7D00: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A7D04: 4874BD05  bl 0x82df3a08
	ctx.lr = 0x826A7D08;
	sub_82DF3A08(ctx, base);
	// 826A7D08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826A7D0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7D14: 4BEF9875  bl 0x825a1588
	ctx.lr = 0x826A7D18;
	sub_825A1588(ctx, base);
	// 826A7D18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7D1C: 4874B70D  bl 0x82df3428
	ctx.lr = 0x826A7D20;
	sub_82DF3428(ctx, base);
	// 826A7D20: 387EFF1C  addi r3, r30, -0xe4
	ctx.r[3].s64 = ctx.r[30].s64 + -228;
	// 826A7D24: 4BFFDB55  bl 0x826a5878
	ctx.lr = 0x826A7D28;
	sub_826A5878(ctx, base);
	// 826A7D28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7D2C: 41820058  beq 0x826a7d84
	if ctx.cr[0].eq {
	pc = 0x826A7D84; continue 'dispatch;
	}
	// 826A7D30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826A7D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7D38: 4874BCD1  bl 0x82df3a08
	ctx.lr = 0x826A7D3C;
	sub_82DF3A08(ctx, base);
	// 826A7D3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A7D40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7D48: 4BEF9841  bl 0x825a1588
	ctx.lr = 0x826A7D4C;
	sub_825A1588(ctx, base);
	// 826A7D4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7D50: 4874B6D9  bl 0x82df3428
	ctx.lr = 0x826A7D54;
	sub_82DF3428(ctx, base);
	// 826A7D54: 897E00E0  lbz r11, 0xe0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) } as u64;
	// 826A7D58: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A7D5C: 41820028  beq 0x826a7d84
	if ctx.cr[0].eq {
	pc = 0x826A7D84; continue 'dispatch;
	}
	// 826A7D60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826A7D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7D68: 4874BCA1  bl 0x82df3a08
	ctx.lr = 0x826A7D6C;
	sub_82DF3A08(ctx, base);
	// 826A7D6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826A7D70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826A7D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7D78: 4BEF9811  bl 0x825a1588
	ctx.lr = 0x826A7D7C;
	sub_825A1588(ctx, base);
	// 826A7D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7D80: 4874B6A9  bl 0x82df3428
	ctx.lr = 0x826A7D84;
	sub_82DF3428(ctx, base);
	// 826A7D84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826A7D88: 48B00430  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7D90 size=12
    let mut pc: u32 = 0x826A7D90;
    'dispatch: loop {
        match pc {
            0x826A7D90 => {
    //   block [0x826A7D90..0x826A7D9C)
	// 826A7D90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826A7D94: 996301BC  stb r11, 0x1bc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(444 as u32), ctx.r[11].u8 ) };
	// 826A7D98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A7DA0 size=12
    let mut pc: u32 = 0x826A7DA0;
    'dispatch: loop {
        match pc {
            0x826A7DA0 => {
    //   block [0x826A7DA0..0x826A7DAC)
	// 826A7DA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7DA4: 996301BC  stb r11, 0x1bc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(444 as u32), ctx.r[11].u8 ) };
	// 826A7DA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A7DB0 size=136
    let mut pc: u32 = 0x826A7DB0;
    'dispatch: loop {
        match pc {
            0x826A7DB0 => {
    //   block [0x826A7DB0..0x826A7E38)
	// 826A7DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A7DB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A7DB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A7DBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A7DC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A7DC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A7DC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A7DCC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 826A7DD0: 409A0020  bne cr6, 0x826a7df0
	if !ctx.cr[6].eq {
	pc = 0x826A7DF0; continue 'dispatch;
	}
	// 826A7DD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A7DD8: 419A0048  beq cr6, 0x826a7e20
	if ctx.cr[6].eq {
	pc = 0x826A7E20; continue 'dispatch;
	}
	// 826A7DDC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826A7DE0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 826A7DE4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 826A7DE8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 826A7DEC: 48000034  b 0x826a7e20
	pc = 0x826A7E20; continue 'dispatch;
	// 826A7DF0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 826A7DF4: 419A002C  beq cr6, 0x826a7e20
	if ctx.cr[6].eq {
	pc = 0x826A7E20; continue 'dispatch;
	}
	// 826A7DF8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A7DFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7E00: 388B9FE8  addi r4, r11, -0x6018
	ctx.r[4].s64 = ctx.r[11].s64 + -24600;
	// 826A7E04: 48B002F5  bl 0x831a80f8
	ctx.lr = 0x826A7E08;
	sub_831A80F8(ctx, base);
	// 826A7E08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826A7E0C: 4182000C  beq 0x826a7e18
	if ctx.cr[0].eq {
	pc = 0x826A7E18; continue 'dispatch;
	}
	// 826A7E10: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826A7E14: 4800000C  b 0x826a7e20
	pc = 0x826A7E20; continue 'dispatch;
	// 826A7E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7E1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A7E20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A7E24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A7E28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A7E2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A7E30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A7E34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826A7E38 size=108
    let mut pc: u32 = 0x826A7E38;
    'dispatch: loop {
        match pc {
            0x826A7E38 => {
    //   block [0x826A7E38..0x826A7EA4)
	// 826A7E38: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826A7E3C: C16301C0  lfs f11, 0x1c0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(448 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826A7E40: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826A7E44: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826A7E48: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 826A7E4C: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 826A7E50: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A7E54: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 826A7E58: C18A0A90  lfs f12, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A7E5C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 826A7E60: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A7E64: ED6B637A  fmadds f11, f11, f13, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 826A7E68: D161FFF0  stfs f11, -0x10(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 826A7E6C: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 826A7E70: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 826A7E74: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 826A7E78: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826A7EA8 size=196
    let mut pc: u32 = 0x826A7EA8;
    'dispatch: loop {
        match pc {
            0x826A7EA8 => {
    //   block [0x826A7EA8..0x826A7F6C)
	// 826A7EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A7EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A7EB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826A7EB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A7EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A7EBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826A7EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7EC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826A7EC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826A7ECC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A7ED0: 4BC18A69  bl 0x822c0938
	ctx.lr = 0x826A7ED4;
	sub_822C0938(ctx, base);
	// 826A7ED4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826A7ED8: 41820028  beq 0x826a7f00
	if ctx.cr[0].eq {
	pc = 0x826A7F00; continue 'dispatch;
	}
	// 826A7EDC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826A7EE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826A7EE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826A7EE8: 392B18C4  addi r9, r11, 0x18c4
	ctx.r[9].s64 = ctx.r[11].s64 + 6340;
	// 826A7EEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826A7EF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826A7EF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826A7EF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826A7EFC: 48000008  b 0x826a7f04
	pc = 0x826A7F04; continue 'dispatch;
	// 826A7F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826A7F04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826A7F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826A7F0C: 409A0044  bne cr6, 0x826a7f50
	if !ctx.cr[6].eq {
	pc = 0x826A7F50; continue 'dispatch;
	}
	// 826A7F10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826A7F14: 419A001C  beq cr6, 0x826a7f30
	if ctx.cr[6].eq {
	pc = 0x826A7F30; continue 'dispatch;
	}
	// 826A7F18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7F1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826A7F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826A7F24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826A7F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826A7F2C: 4E800421  bctrl
	ctx.lr = 0x826A7F30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826A7F30: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826A7F34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A7F38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7F3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826A7F40: 816B9F98  lwz r11, -0x6068(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24680 as u32) ) } as u64;
	// 826A7F44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826A7F48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826A7F4C: 4BC180B5  bl 0x822c0000
	ctx.lr = 0x826A7F50;
	sub_822C0000(ctx, base);
	// 826A7F50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826A7F54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826A7F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826A7F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826A7F60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826A7F64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826A7F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A7F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826A7F70 size=328
    let mut pc: u32 = 0x826A7F70;
    'dispatch: loop {
        match pc {
            0x826A7F70 => {
    //   block [0x826A7F70..0x826A80B8)
	// 826A7F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826A7F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826A7F78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826A7F7C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 826A7F80: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826A7F84: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826A7F88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826A7F8C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826A7F90: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826A7F94: 419A0108  beq cr6, 0x826a809c
	if ctx.cr[6].eq {
	pc = 0x826A809C; continue 'dispatch;
	}
	// 826A7F98: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826A7F9C: 4BC28115  bl 0x822d00b0
	ctx.lr = 0x826A7FA0;
	sub_822D00B0(ctx, base);
	// 826A7FA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826A7FA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826A7FA8: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 826A7FAC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826A7FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826A7FB4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826A7FB8: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826A7FBC: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826A7FC0: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826A7FC4: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826A7FC8: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826A7FCC: 487D5355  bl 0x82e7d320
	ctx.lr = 0x826A7FD0;
	sub_82E7D320(ctx, base);
	// 826A7FD0: 817F01C8  lwz r11, 0x1c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 826A7FD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826A7FD8: 409A0044  bne cr6, 0x826a801c
	if !ctx.cr[6].eq {
	pc = 0x826A801C; continue 'dispatch;
	}
	// 826A7FDC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826A7FE0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826A7FE4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 826A7FE8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826A7FEC: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826A7FF0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A7FF4: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826A7FF8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A7FFC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826A8000: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A8004: FC005850  fneg f0, f11
	ctx.f[0].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 826A8008: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826A800C: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826A8010: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826A8014: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A80B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826A80B8 size=100
    let mut pc: u32 = 0x826A80B8;
    'dispatch: loop {
        match pc {
            0x826A80B8 => {
    //   block [0x826A80B8..0x826A811C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826A811C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826A811C size=88
    let mut pc: u32 = 0x826A811C;
    'dispatch: loop {
        match pc {
            0x826A811C => {
    //   block [0x826A811C..0x826A8174)
	// 826A811C: 13C038C7  vcmpequd (lvx128) v30, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826A8120: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


