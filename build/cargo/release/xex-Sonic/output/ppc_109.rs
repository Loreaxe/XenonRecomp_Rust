pub fn sub_828F9378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F9378 size=256
    let mut pc: u32 = 0x828F9378;
    'dispatch: loop {
        match pc {
            0x828F9378 => {
    //   block [0x828F9378..0x828F9478)
	// 828F9378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F937C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F9384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9388: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9478 size=96
    let mut pc: u32 = 0x828F9478;
    'dispatch: loop {
        match pc {
            0x828F9478 => {
    //   block [0x828F9478..0x828F94D8)
	// 828F9478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F947C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9480: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9484: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F948C: 4BFFDEAD  bl 0x828f7338
	ctx.lr = 0x828F9490;
	sub_828F7338(ctx, base);
	// 828F9490: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9494: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F9498: 396B37BC  addi r11, r11, 0x37bc
	ctx.r[11].s64 = ctx.r[11].s64 + 14268;
	// 828F949C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F94A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F94A4: 808A0AF8  lwz r4, 0xaf8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828F94A8: 484FA561  bl 0x82df3a08
	ctx.lr = 0x828F94AC;
	sub_82DF3A08(ctx, base);
	// 828F94AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F94B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F94B4: 48560235  bl 0x82e596e8
	ctx.lr = 0x828F94B8;
	sub_82E596E8(ctx, base);
	// 828F94B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F94BC: 484F9F6D  bl 0x82df3428
	ctx.lr = 0x828F94C0;
	sub_82DF3428(ctx, base);
	// 828F94C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F94C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F94C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F94CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F94D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F94D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F94D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F94D8 size=268
    let mut pc: u32 = 0x828F94D8;
    'dispatch: loop {
        match pc {
            0x828F94D8 => {
    //   block [0x828F94D8..0x828F95E4)
	// 828F94D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F94DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F94E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F94E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F94E8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828F94EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F94F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F94F4: 4885B10D  bl 0x83154600
	ctx.lr = 0x828F94F8;
	sub_83154600(ctx, base);
	// 828F94F8: 4BFBF7F1  bl 0x828b8ce8
	ctx.lr = 0x828F94FC;
	sub_828B8CE8(ctx, base);
	// 828F94FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9504: 48560275  bl 0x82e59778
	ctx.lr = 0x828F9508;
	sub_82E59778(ctx, base);
	// 828F9508: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F950C: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828F9510: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F9514: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828F9518: 48010069  bl 0x82909580
	ctx.lr = 0x828F951C;
	sub_82909580(ctx, base);
	// 828F951C: 480228FD  bl 0x8291be18
	ctx.lr = 0x828F9520;
	sub_8291BE18(ctx, base);
	// 828F9520: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F9524: 41820048  beq 0x828f956c
	if ctx.cr[0].eq {
	pc = 0x828F956C; continue 'dispatch;
	}
	// 828F9528: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F952C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9530: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828F9534: 484FA4D5  bl 0x82df3a08
	ctx.lr = 0x828F9538;
	sub_82DF3A08(ctx, base);
	// 828F9538: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F953C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9540: 4870EBE9  bl 0x83008128
	ctx.lr = 0x828F9544;
	sub_83008128(ctx, base);
	// 828F9544: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F9548: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F954C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F9550: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F9554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9558: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F955C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F9560: 48565401  bl 0x82e5e960
	ctx.lr = 0x828F9564;
	sub_82E5E960(ctx, base);
	// 828F9564: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F9568: 48000054  b 0x828f95bc
	pc = 0x828F95BC; continue 'dispatch;
	// 828F956C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F9570: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F9574: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F9578: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828F957C: 4098004C  bge cr6, 0x828f95c8
	if !ctx.cr[6].lt {
	pc = 0x828F95C8; continue 'dispatch;
	}
	// 828F9580: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9588: 808BB404  lwz r4, -0x4bfc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19452 as u32) ) } as u64;
	// 828F958C: 484FA47D  bl 0x82df3a08
	ctx.lr = 0x828F9590;
	sub_82DF3A08(ctx, base);
	// 828F9590: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9598: 4870EB91  bl 0x83008128
	ctx.lr = 0x828F959C;
	sub_83008128(ctx, base);
	// 828F959C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F95A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F95A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F95A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F95AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F95B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F95B4: 485653AD  bl 0x82e5e960
	ctx.lr = 0x828F95B8;
	sub_82E5E960(ctx, base);
	// 828F95B8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F95BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F95C0: 419A0008  beq cr6, 0x828f95c8
	if ctx.cr[6].eq {
	pc = 0x828F95C8; continue 'dispatch;
	}
	// 828F95C4: 4B9C72CD  bl 0x822c0890
	ctx.lr = 0x828F95C8;
	sub_822C0890(ctx, base);
	// 828F95C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F95CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F95D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F95D4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828F95D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F95DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F95E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F95E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F95E8 size=196
    let mut pc: u32 = 0x828F95E8;
    'dispatch: loop {
        match pc {
            0x828F95E8 => {
    //   block [0x828F95E8..0x828F96AC)
	// 828F95E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F95EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F95F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F95F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F95F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F95FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9604: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F9608: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F960C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9610: 4B9C7329  bl 0x822c0938
	ctx.lr = 0x828F9614;
	sub_822C0938(ctx, base);
	// 828F9614: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F9618: 41820028  beq 0x828f9640
	if ctx.cr[0].eq {
	pc = 0x828F9640; continue 'dispatch;
	}
	// 828F961C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9620: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F9624: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F9628: 392B3780  addi r9, r11, 0x3780
	ctx.r[9].s64 = ctx.r[11].s64 + 14208;
	// 828F962C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F9630: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F9634: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F9638: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F963C: 48000008  b 0x828f9644
	pc = 0x828F9644; continue 'dispatch;
	// 828F9640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9644: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F964C: 409A0044  bne cr6, 0x828f9690
	if !ctx.cr[6].eq {
	pc = 0x828F9690; continue 'dispatch;
	}
	// 828F9650: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F9654: 419A001C  beq cr6, 0x828f9670
	if ctx.cr[6].eq {
	pc = 0x828F9670; continue 'dispatch;
	}
	// 828F9658: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F965C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9664: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F966C: 4E800421  bctrl
	ctx.lr = 0x828F9670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9670: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9674: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F9678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F967C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F9680: 816BB8AC  lwz r11, -0x4754(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18260 as u32) ) } as u64;
	// 828F9684: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F9688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F968C: 4B9C6975  bl 0x822c0000
	ctx.lr = 0x828F9690;
	sub_822C0000(ctx, base);
	// 828F9690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F969C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F96A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F96A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F96A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F96B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F96B0 size=196
    let mut pc: u32 = 0x828F96B0;
    'dispatch: loop {
        match pc {
            0x828F96B0 => {
    //   block [0x828F96B0..0x828F9774)
	// 828F96B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F96B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F96B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F96BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F96C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F96C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F96C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F96CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F96D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F96D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F96D8: 4B9C7261  bl 0x822c0938
	ctx.lr = 0x828F96DC;
	sub_822C0938(ctx, base);
	// 828F96DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F96E0: 41820028  beq 0x828f9708
	if ctx.cr[0].eq {
	pc = 0x828F9708; continue 'dispatch;
	}
	// 828F96E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F96E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F96EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F96F0: 392B3794  addi r9, r11, 0x3794
	ctx.r[9].s64 = ctx.r[11].s64 + 14228;
	// 828F96F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F96F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F96FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F9700: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F9704: 48000008  b 0x828f970c
	pc = 0x828F970C; continue 'dispatch;
	// 828F9708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F970C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9714: 409A0044  bne cr6, 0x828f9758
	if !ctx.cr[6].eq {
	pc = 0x828F9758; continue 'dispatch;
	}
	// 828F9718: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F971C: 419A001C  beq cr6, 0x828f9738
	if ctx.cr[6].eq {
	pc = 0x828F9738; continue 'dispatch;
	}
	// 828F9720: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9724: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F972C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9734: 4E800421  bctrl
	ctx.lr = 0x828F9738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9738: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F973C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F9740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9744: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F9748: 816BB8AC  lwz r11, -0x4754(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18260 as u32) ) } as u64;
	// 828F974C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F9750: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F9754: 4B9C68AD  bl 0x822c0000
	ctx.lr = 0x828F9758;
	sub_822C0000(ctx, base);
	// 828F9758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F975C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9768: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F976C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F9770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9778 size=196
    let mut pc: u32 = 0x828F9778;
    'dispatch: loop {
        match pc {
            0x828F9778 => {
    //   block [0x828F9778..0x828F983C)
	// 828F9778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F977C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F9784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F978C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9794: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F9798: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F979C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F97A0: 4B9C7199  bl 0x822c0938
	ctx.lr = 0x828F97A4;
	sub_822C0938(ctx, base);
	// 828F97A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F97A8: 41820028  beq 0x828f97d0
	if ctx.cr[0].eq {
	pc = 0x828F97D0; continue 'dispatch;
	}
	// 828F97AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F97B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F97B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F97B8: 392B37A8  addi r9, r11, 0x37a8
	ctx.r[9].s64 = ctx.r[11].s64 + 14248;
	// 828F97BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F97C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F97C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F97C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F97CC: 48000008  b 0x828f97d4
	pc = 0x828F97D4; continue 'dispatch;
	// 828F97D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F97D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F97D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F97DC: 409A0044  bne cr6, 0x828f9820
	if !ctx.cr[6].eq {
	pc = 0x828F9820; continue 'dispatch;
	}
	// 828F97E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F97E4: 419A001C  beq cr6, 0x828f9800
	if ctx.cr[6].eq {
	pc = 0x828F9800; continue 'dispatch;
	}
	// 828F97E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F97EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F97F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F97F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F97F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F97FC: 4E800421  bctrl
	ctx.lr = 0x828F9800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9800: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9804: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F9808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F980C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F9810: 816BB8AC  lwz r11, -0x4754(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18260 as u32) ) } as u64;
	// 828F9814: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F9818: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F981C: 4B9C67E5  bl 0x822c0000
	ctx.lr = 0x828F9820;
	sub_822C0000(ctx, base);
	// 828F9820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F982C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9830: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F9834: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F9838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9840 size=108
    let mut pc: u32 = 0x828F9840;
    'dispatch: loop {
        match pc {
            0x828F9840 => {
    //   block [0x828F9840..0x828F98AC)
	// 828F9840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F984C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9850: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9854: 4BFFDA9D  bl 0x828f72f0
	ctx.lr = 0x828F9858;
	sub_828F72F0(ctx, base);
	// 828F9858: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F985C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9860: 394A37E8  addi r10, r10, 0x37e8
	ctx.r[10].s64 = ctx.r[10].s64 + 14312;
	// 828F9864: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828F9868: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F986C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9870: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F9874: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828F9878: 80890AF0  lwz r4, 0xaf0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828F987C: 484FA18D  bl 0x82df3a08
	ctx.lr = 0x828F9880;
	sub_82DF3A08(ctx, base);
	// 828F9880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9884: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F9888: 4855FE61  bl 0x82e596e8
	ctx.lr = 0x828F988C;
	sub_82E596E8(ctx, base);
	// 828F988C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9890: 484F9B99  bl 0x82df3428
	ctx.lr = 0x828F9894;
	sub_82DF3428(ctx, base);
	// 828F9894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9898: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F989C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F98A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F98A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F98A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F98B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F98B0 size=264
    let mut pc: u32 = 0x828F98B0;
    'dispatch: loop {
        match pc {
            0x828F98B0 => {
    //   block [0x828F98B0..0x828F99B8)
	// 828F98B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F98B4: 488AE8B9  bl 0x831a816c
	ctx.lr = 0x828F98B8;
	sub_831A8130(ctx, base);
	// 828F98B8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828F98BC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F98C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F98C4: 4855FEB5  bl 0x82e59778
	ctx.lr = 0x828F98C8;
	sub_82E59778(ctx, base);
	// 828F98C8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F98CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F98D0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828F98D4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F98D8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F98DC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828F98E0: 409800CC  bge cr6, 0x828f99ac
	if !ctx.cr[6].lt {
	pc = 0x828F99AC; continue 'dispatch;
	}
	// 828F98E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F98E8: 4885AD19  bl 0x83154600
	ctx.lr = 0x828F98EC;
	sub_83154600(ctx, base);
	// 828F98EC: 4BFBF3FD  bl 0x828b8ce8
	ctx.lr = 0x828F98F0;
	sub_828B8CE8(ctx, base);
	// 828F98F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F98F4: 4BFF91F5  bl 0x828f2ae8
	ctx.lr = 0x828F98F8;
	sub_828F2AE8(ctx, base);
	// 828F98F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F98FC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F9900: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828F9904: C01D0008  lfs f0, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F9908: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F990C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F9910: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828F9914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9918: 4E800421  bctrl
	ctx.lr = 0x828F991C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F991C: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F9920: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F9924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9928: 40980040  bge cr6, 0x828f9968
	if !ctx.cr[6].lt {
	pc = 0x828F9968; continue 'dispatch;
	}
	// 828F992C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9930: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828F9934: 484FA0D5  bl 0x82df3a08
	ctx.lr = 0x828F9938;
	sub_82DF3A08(ctx, base);
	// 828F9938: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F993C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9940: 4870E7E9  bl 0x83008128
	ctx.lr = 0x828F9944;
	sub_83008128(ctx, base);
	// 828F9944: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9948: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F994C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F9950: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F9954: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9958: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F995C: 48565005  bl 0x82e5e960
	ctx.lr = 0x828F9960;
	sub_82E5E960(ctx, base);
	// 828F9960: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F9964: 4800003C  b 0x828f99a0
	pc = 0x828F99A0; continue 'dispatch;
	// 828F9968: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F996C: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828F9970: 484FA099  bl 0x82df3a08
	ctx.lr = 0x828F9974;
	sub_82DF3A08(ctx, base);
	// 828F9974: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F997C: 4870E7AD  bl 0x83008128
	ctx.lr = 0x828F9980;
	sub_83008128(ctx, base);
	// 828F9980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9984: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F9988: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F998C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F9990: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9994: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F9998: 48564FC9  bl 0x82e5e960
	ctx.lr = 0x828F999C;
	sub_82E5E960(ctx, base);
	// 828F999C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F99A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F99A4: 419A0008  beq cr6, 0x828f99ac
	if ctx.cr[6].eq {
	pc = 0x828F99AC; continue 'dispatch;
	}
	// 828F99A8: 4B9C6EE9  bl 0x822c0890
	ctx.lr = 0x828F99AC;
	sub_822C0890(ctx, base);
	// 828F99AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F99B0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828F99B4: 488AE808  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F99B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F99B8 size=112
    let mut pc: u32 = 0x828F99B8;
    'dispatch: loop {
        match pc {
            0x828F99B8 => {
    //   block [0x828F99B8..0x828F9A28)
	// 828F99B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F99BC: 488AE7B1  bl 0x831a816c
	ctx.lr = 0x828F99C0;
	sub_831A8130(ctx, base);
	// 828F99C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F99C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F99C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F99CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F99D0: 388B3810  addi r4, r11, 0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + 14352;
	// 828F99D4: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 828F99D8: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828F99DC: 484F8A0D  bl 0x82df23e8
	ctx.lr = 0x828F99E0;
	sub_82DF23E8(ctx, base);
	// 828F99E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F99E4: 41820010  beq 0x828f99f4
	if ctx.cr[0].eq {
	pc = 0x828F99F4; continue 'dispatch;
	}
	// 828F99E8: 4BFFFE59  bl 0x828f9840
	ctx.lr = 0x828F99EC;
	sub_828F9840(ctx, base);
	// 828F99EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F99F0: 48000008  b 0x828f99f8
	pc = 0x828F99F8; continue 'dispatch;
	// 828F99F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F99F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F99FC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F9A00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9A08: 4BFFFBE1  bl 0x828f95e8
	ctx.lr = 0x828F9A0C;
	sub_828F95E8(ctx, base);
	// 828F9A0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F9A10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9A18: 4B9C65E9  bl 0x822c0000
	ctx.lr = 0x828F9A1C;
	sub_822C0000(ctx, base);
	// 828F9A1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9A20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9A24: 488AE798  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9A28 size=112
    let mut pc: u32 = 0x828F9A28;
    'dispatch: loop {
        match pc {
            0x828F9A28 => {
    //   block [0x828F9A28..0x828F9A98)
	// 828F9A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9A2C: 488AE741  bl 0x831a816c
	ctx.lr = 0x828F9A30;
	sub_831A8130(ctx, base);
	// 828F9A30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9A34: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9A38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F9A3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9A40: 388B3810  addi r4, r11, 0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + 14352;
	// 828F9A44: 38A000A9  li r5, 0xa9
	ctx.r[5].s64 = 169;
	// 828F9A48: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F9A4C: 484F899D  bl 0x82df23e8
	ctx.lr = 0x828F9A50;
	sub_82DF23E8(ctx, base);
	// 828F9A50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F9A54: 41820010  beq 0x828f9a64
	if ctx.cr[0].eq {
	pc = 0x828F9A64; continue 'dispatch;
	}
	// 828F9A58: 4BFFF779  bl 0x828f91d0
	ctx.lr = 0x828F9A5C;
	sub_828F91D0(ctx, base);
	// 828F9A5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9A60: 48000008  b 0x828f9a68
	pc = 0x828F9A68; continue 'dispatch;
	// 828F9A64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F9A68: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F9A6C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F9A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9A78: 4BFFFC39  bl 0x828f96b0
	ctx.lr = 0x828F9A7C;
	sub_828F96B0(ctx, base);
	// 828F9A7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F9A80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9A84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9A88: 4B9C6579  bl 0x822c0000
	ctx.lr = 0x828F9A8C;
	sub_822C0000(ctx, base);
	// 828F9A8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9A90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9A94: 488AE728  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9A98 size=112
    let mut pc: u32 = 0x828F9A98;
    'dispatch: loop {
        match pc {
            0x828F9A98 => {
    //   block [0x828F9A98..0x828F9B08)
	// 828F9A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9A9C: 488AE6D1  bl 0x831a816c
	ctx.lr = 0x828F9AA0;
	sub_831A8130(ctx, base);
	// 828F9AA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9AA4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9AA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F9AAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9AB0: 388B3810  addi r4, r11, 0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + 14352;
	// 828F9AB4: 38A000F6  li r5, 0xf6
	ctx.r[5].s64 = 246;
	// 828F9AB8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F9ABC: 484F892D  bl 0x82df23e8
	ctx.lr = 0x828F9AC0;
	sub_82DF23E8(ctx, base);
	// 828F9AC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F9AC4: 41820010  beq 0x828f9ad4
	if ctx.cr[0].eq {
	pc = 0x828F9AD4; continue 'dispatch;
	}
	// 828F9AC8: 4BFFF9B1  bl 0x828f9478
	ctx.lr = 0x828F9ACC;
	sub_828F9478(ctx, base);
	// 828F9ACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9AD0: 48000008  b 0x828f9ad8
	pc = 0x828F9AD8; continue 'dispatch;
	// 828F9AD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F9AD8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F9ADC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F9AE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9AE8: 4BFFFC91  bl 0x828f9778
	ctx.lr = 0x828F9AEC;
	sub_828F9778(ctx, base);
	// 828F9AEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F9AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9AF8: 4B9C6509  bl 0x822c0000
	ctx.lr = 0x828F9AFC;
	sub_822C0000(ctx, base);
	// 828F9AFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9B00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9B04: 488AE6B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F9B08 size=240
    let mut pc: u32 = 0x828F9B08;
    'dispatch: loop {
        match pc {
            0x828F9B08 => {
    //   block [0x828F9B08..0x828F9BF8)
	// 828F9B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9B0C: 488AE65D  bl 0x831a8168
	ctx.lr = 0x828F9B10;
	sub_831A8130(ctx, base);
	// 828F9B10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9B14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F9B18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F9B1C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F9B20: 4885AAE1  bl 0x83154600
	ctx.lr = 0x828F9B24;
	sub_83154600(ctx, base);
	// 828F9B24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9B28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F9B2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9B30: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9B34: 4BEF5D1D  bl 0x827ef850
	ctx.lr = 0x828F9B38;
	sub_827EF850(ctx, base);
	// 828F9B38: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828F9B3C: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F9B40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9B48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9B4C: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F9B50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828F9B54: 4E800421  bctrl
	ctx.lr = 0x828F9B58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9B58: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9B5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9B60: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828F9B64: 484F9EA5  bl 0x82df3a08
	ctx.lr = 0x828F9B68;
	sub_82DF3A08(ctx, base);
	// 828F9B68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9B6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F9B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9B74: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F9B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9B7C: 4E800421  bctrl
	ctx.lr = 0x828F9B80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9B80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9B84: 484F98A5  bl 0x82df3428
	ctx.lr = 0x828F9B88;
	sub_82DF3428(ctx, base);
	// 828F9B88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9B8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9B90: 388B3810  addi r4, r11, 0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + 14352;
	// 828F9B94: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 828F9B98: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828F9B9C: 4B9C683D  bl 0x822c03d8
	ctx.lr = 0x828F9BA0;
	sub_822C03D8(ctx, base);
	// 828F9BA0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828F9BA4: 41820030  beq 0x828f9bd4
	if ctx.cr[0].eq {
	pc = 0x828F9BD4; continue 'dispatch;
	}
	// 828F9BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9BAC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828F9BB0: 4801CBB9  bl 0x82916768
	ctx.lr = 0x828F9BB4;
	sub_82916768(ctx, base);
	// 828F9BB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9BB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F9BBC: 4BC1595D  bl 0x8250f518
	ctx.lr = 0x828F9BC0;
	sub_8250F518(ctx, base);
	// 828F9BC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9BC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9BC8: 4BB97529  bl 0x824910f0
	ctx.lr = 0x828F9BCC;
	sub_824910F0(ctx, base);
	// 828F9BCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9BD0: 48000008  b 0x828f9bd8
	pc = 0x828F9BD8; continue 'dispatch;
	// 828F9BD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F9BD8: 387C0064  addi r3, r28, 0x64
	ctx.r[3].s64 = ctx.r[28].s64 + 100;
	// 828F9BDC: 4BA10B05  bl 0x8230a6e0
	ctx.lr = 0x828F9BE0;
	sub_8230A6E0(ctx, base);
	// 828F9BE0: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F9BE4: 4182000C  beq 0x828f9bf0
	if ctx.cr[0].eq {
	pc = 0x828F9BF0; continue 'dispatch;
	}
	// 828F9BE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F9BEC: 484F80A5  bl 0x82df1c90
	ctx.lr = 0x828F9BF0;
	sub_82DF1C90(ctx, base);
	// 828F9BF0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F9BF4: 488AE5C4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F9BF8 size=28
    let mut pc: u32 = 0x828F9BF8;
    'dispatch: loop {
        match pc {
            0x828F9BF8 => {
    //   block [0x828F9BF8..0x828F9C14)
	// 828F9BF8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F9BFC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828F9C00: C00B9528  lfs f0, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F9C04: C1AA2D48  lfs f13, 0x2d48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11592 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F9C08: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828F9C0C: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828F9C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9C18 size=196
    let mut pc: u32 = 0x828F9C18;
    'dispatch: loop {
        match pc {
            0x828F9C18 => {
    //   block [0x828F9C18..0x828F9CDC)
	// 828F9C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9C20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F9C24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9C28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9C2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9C30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9C34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F9C38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F9C3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9C40: 4B9C6CF9  bl 0x822c0938
	ctx.lr = 0x828F9C44;
	sub_822C0938(ctx, base);
	// 828F9C44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F9C48: 41820028  beq 0x828f9c70
	if ctx.cr[0].eq {
	pc = 0x828F9C70; continue 'dispatch;
	}
	// 828F9C4C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9C50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F9C54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F9C58: 392B3894  addi r9, r11, 0x3894
	ctx.r[9].s64 = ctx.r[11].s64 + 14484;
	// 828F9C5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F9C60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F9C64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F9C68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F9C6C: 48000008  b 0x828f9c74
	pc = 0x828F9C74; continue 'dispatch;
	// 828F9C70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9C74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9C7C: 409A0044  bne cr6, 0x828f9cc0
	if !ctx.cr[6].eq {
	pc = 0x828F9CC0; continue 'dispatch;
	}
	// 828F9C80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F9C84: 419A001C  beq cr6, 0x828f9ca0
	if ctx.cr[6].eq {
	pc = 0x828F9CA0; continue 'dispatch;
	}
	// 828F9C88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9C8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9C94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9C98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9C9C: 4E800421  bctrl
	ctx.lr = 0x828F9CA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9CA0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9CA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F9CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9CAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F9CB0: 816BBA6C  lwz r11, -0x4594(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17812 as u32) ) } as u64;
	// 828F9CB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F9CB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F9CBC: 4B9C6345  bl 0x822c0000
	ctx.lr = 0x828F9CC0;
	sub_822C0000(ctx, base);
	// 828F9CC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9CC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9CC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9CCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9CD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F9CD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F9CD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9CE0 size=124
    let mut pc: u32 = 0x828F9CE0;
    'dispatch: loop {
        match pc {
            0x828F9CE0 => {
    //   block [0x828F9CE0..0x828F9D5C)
	// 828F9CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9CE4: 488AE489  bl 0x831a816c
	ctx.lr = 0x828F9CE8;
	sub_831A8130(ctx, base);
	// 828F9CE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9CEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9CF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F9CF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9CF8: 388B38D8  addi r4, r11, 0x38d8
	ctx.r[4].s64 = ctx.r[11].s64 + 14552;
	// 828F9CFC: 38A00025  li r5, 0x25
	ctx.r[5].s64 = 37;
	// 828F9D00: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 828F9D04: 484F86E5  bl 0x82df23e8
	ctx.lr = 0x828F9D08;
	sub_82DF23E8(ctx, base);
	// 828F9D08: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828F9D0C: 4182001C  beq 0x828f9d28
	if ctx.cr[0].eq {
	pc = 0x828F9D28; continue 'dispatch;
	}
	// 828F9D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9D14: 4803CACD  bl 0x829367e0
	ctx.lr = 0x828F9D18;
	sub_829367E0(ctx, base);
	// 828F9D18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9D1C: 396B38A8  addi r11, r11, 0x38a8
	ctx.r[11].s64 = ctx.r[11].s64 + 14504;
	// 828F9D20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9D24: 48000008  b 0x828f9d2c
	pc = 0x828F9D2C; continue 'dispatch;
	// 828F9D28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F9D2C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F9D30: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F9D34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9D38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9D3C: 4BFFFEDD  bl 0x828f9c18
	ctx.lr = 0x828F9D40;
	sub_828F9C18(ctx, base);
	// 828F9D40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F9D44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9D4C: 4B9C62B5  bl 0x822c0000
	ctx.lr = 0x828F9D50;
	sub_822C0000(ctx, base);
	// 828F9D50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9D58: 488AE464  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F9D60 size=128
    let mut pc: u32 = 0x828F9D60;
    'dispatch: loop {
        match pc {
            0x828F9D60 => {
    //   block [0x828F9D60..0x828F9DE0)
	// 828F9D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9D68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9D6C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828F9D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9D78: 4885A889  bl 0x83154600
	ctx.lr = 0x828F9D7C;
	sub_83154600(ctx, base);
	// 828F9D7C: 4801C9ED  bl 0x82916768
	ctx.lr = 0x828F9D80;
	sub_82916768(ctx, base);
	// 828F9D80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F9D84: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828F9D88: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F9D8C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F9D90: 48014FE9  bl 0x8290ed78
	ctx.lr = 0x828F9D94;
	sub_8290ED78(ctx, base);
	// 828F9D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9D98: 4885A869  bl 0x83154600
	ctx.lr = 0x828F9D9C;
	sub_83154600(ctx, base);
	// 828F9D9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F9DA0: D3E1005C  stfs f31, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F9DA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F9DA8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F9DAC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F9DB0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F9DB4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F9DB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9DBC: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F9DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9DC4: 4E800421  bctrl
	ctx.lr = 0x828F9DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9DC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F9DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9DD4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F9DD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F9DDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9DE0 size=196
    let mut pc: u32 = 0x828F9DE0;
    'dispatch: loop {
        match pc {
            0x828F9DE0 => {
    //   block [0x828F9DE0..0x828F9EA4)
	// 828F9DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9DE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F9DEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9DF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9DF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9DF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9DFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F9E00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F9E04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9E08: 4B9C6B31  bl 0x822c0938
	ctx.lr = 0x828F9E0C;
	sub_822C0938(ctx, base);
	// 828F9E0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F9E10: 41820028  beq 0x828f9e38
	if ctx.cr[0].eq {
	pc = 0x828F9E38; continue 'dispatch;
	}
	// 828F9E14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9E18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F9E1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F9E20: 392B395C  addi r9, r11, 0x395c
	ctx.r[9].s64 = ctx.r[11].s64 + 14684;
	// 828F9E24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F9E28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F9E2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F9E30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F9E34: 48000008  b 0x828f9e3c
	pc = 0x828F9E3C; continue 'dispatch;
	// 828F9E38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9E3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F9E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9E44: 409A0044  bne cr6, 0x828f9e88
	if !ctx.cr[6].eq {
	pc = 0x828F9E88; continue 'dispatch;
	}
	// 828F9E48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F9E4C: 419A001C  beq cr6, 0x828f9e68
	if ctx.cr[6].eq {
	pc = 0x828F9E68; continue 'dispatch;
	}
	// 828F9E50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9E54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9E5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9E64: 4E800421  bctrl
	ctx.lr = 0x828F9E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9E68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9E6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F9E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9E74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F9E78: 816BBAFC  lwz r11, -0x4504(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17668 as u32) ) } as u64;
	// 828F9E7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F9E80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F9E84: 4B9C617D  bl 0x822c0000
	ctx.lr = 0x828F9E88;
	sub_822C0000(ctx, base);
	// 828F9E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F9E8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9E98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F9E9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F9EA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9EA8 size=108
    let mut pc: u32 = 0x828F9EA8;
    'dispatch: loop {
        match pc {
            0x828F9EA8 => {
    //   block [0x828F9EA8..0x828F9F14)
	// 828F9EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9EB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9EB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9EB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9EBC: 4BFFD435  bl 0x828f72f0
	ctx.lr = 0x828F9EC0;
	sub_828F72F0(ctx, base);
	// 828F9EC0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F9EC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9EC8: 394A3970  addi r10, r10, 0x3970
	ctx.r[10].s64 = ctx.r[10].s64 + 14704;
	// 828F9ECC: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828F9ED0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F9ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9ED8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F9EDC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828F9EE0: 80890B24  lwz r4, 0xb24(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F9EE4: 484F9B25  bl 0x82df3a08
	ctx.lr = 0x828F9EE8;
	sub_82DF3A08(ctx, base);
	// 828F9EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9EEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F9EF0: 4855F7F9  bl 0x82e596e8
	ctx.lr = 0x828F9EF4;
	sub_82E596E8(ctx, base);
	// 828F9EF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9EF8: 484F9531  bl 0x82df3428
	ctx.lr = 0x828F9EFC;
	sub_82DF3428(ctx, base);
	// 828F9EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9F00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9F04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9F08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9F0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F9F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F9F18 size=816
    let mut pc: u32 = 0x828F9F18;
    'dispatch: loop {
        match pc {
            0x828F9F18 => {
    //   block [0x828F9F18..0x828FA248)
	// 828F9F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9F1C: 488AE241  bl 0x831a815c
	ctx.lr = 0x828F9F20;
	sub_831A8130(ctx, base);
	// 828F9F20: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828F9F24: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9F28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F9F2C: 4885A6D5  bl 0x83154600
	ctx.lr = 0x828F9F30;
	sub_83154600(ctx, base);
	// 828F9F30: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828F9F34: 4BFBEDB5  bl 0x828b8ce8
	ctx.lr = 0x828F9F38;
	sub_828B8CE8(ctx, base);
	// 828F9F38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9F3C: 4BFF8BAD  bl 0x828f2ae8
	ctx.lr = 0x828F9F40;
	sub_828F2AE8(ctx, base);
	// 828F9F40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F9F44: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828F9F48: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F9F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9F50: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F9F54: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F9F58: 3B9B0100  addi r28, r27, 0x100
	ctx.r[28].s64 = ctx.r[27].s64 + 256;
	// 828F9F5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F9F60: 48014E19  bl 0x8290ed78
	ctx.lr = 0x828F9F64;
	sub_8290ED78(ctx, base);
	// 828F9F64: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9F68: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828F9F6C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F9F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9F74: 4E800421  bctrl
	ctx.lr = 0x828F9F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9F78: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F9F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9F80: 808BB3D0  lwz r4, -0x4c30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 828F9F84: 484F9A85  bl 0x82df3a08
	ctx.lr = 0x828F9F88;
	sub_82DF3A08(ctx, base);
	// 828F9F88: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9F8C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828F9F90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F9F94: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F9F98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9F9C: 4E800421  bctrl
	ctx.lr = 0x828F9FA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9FA4: 484F9485  bl 0x82df3428
	ctx.lr = 0x828F9FA8;
	sub_82DF3428(ctx, base);
	// 828F9FA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F9FAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9FB0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F9FB4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F9FB8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F9FBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9FC0: 4E800421  bctrl
	ctx.lr = 0x828F9FC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9FC4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828F9FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9FCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9FD0: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F9FD4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F9FD8: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F9FDC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F9FE0: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F9FE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9FE8: 4E800421  bctrl
	ctx.lr = 0x828F9FEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9FEC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F9FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9FF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F9FF8: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F9FFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA000: 4E800421  bctrl
	ctx.lr = 0x828FA004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA004: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828FA008: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828FA00C: 935D0064  stw r26, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 828FA010: 935D0068  stw r26, 0x68(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 828FA014: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA018: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA01C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA020: 4E800421  bctrl
	ctx.lr = 0x828FA024;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA024: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828FA028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA02C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA030: 4800F629  bl 0x82909658
	ctx.lr = 0x828FA034;
	sub_82909658(ctx, base);
	// 828FA034: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FA038: 13E0C8C7  vcmpequd (lvx128) v31, v0, v25
	tmp.u32 = ctx.r[25].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FA03C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FA248 size=112
    let mut pc: u32 = 0x828FA248;
    'dispatch: loop {
        match pc {
            0x828FA248 => {
    //   block [0x828FA248..0x828FA2B8)
	// 828FA248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA24C: 488ADF21  bl 0x831a816c
	ctx.lr = 0x828FA250;
	sub_831A8130(ctx, base);
	// 828FA250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA254: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FA258: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FA25C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FA260: 388B3998  addi r4, r11, 0x3998
	ctx.r[4].s64 = ctx.r[11].s64 + 14744;
	// 828FA264: 38A00135  li r5, 0x135
	ctx.r[5].s64 = 309;
	// 828FA268: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828FA26C: 484F817D  bl 0x82df23e8
	ctx.lr = 0x828FA270;
	sub_82DF23E8(ctx, base);
	// 828FA270: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FA274: 41820010  beq 0x828fa284
	if ctx.cr[0].eq {
	pc = 0x828FA284; continue 'dispatch;
	}
	// 828FA278: 4BFFFC31  bl 0x828f9ea8
	ctx.lr = 0x828FA27C;
	sub_828F9EA8(ctx, base);
	// 828FA27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FA280: 48000008  b 0x828fa288
	pc = 0x828FA288; continue 'dispatch;
	// 828FA284: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FA288: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FA28C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828FA290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FA298: 4BFFFB49  bl 0x828f9de0
	ctx.lr = 0x828FA29C;
	sub_828F9DE0(ctx, base);
	// 828FA29C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FA2A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA2A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FA2A8: 4B9C5D59  bl 0x822c0000
	ctx.lr = 0x828FA2AC;
	sub_822C0000(ctx, base);
	// 828FA2AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FA2B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FA2B4: 488ADF08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FA2B8 size=316
    let mut pc: u32 = 0x828FA2B8;
    'dispatch: loop {
        match pc {
            0x828FA2B8 => {
    //   block [0x828FA2B8..0x828FA3F4)
	// 828FA2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA2BC: 488ADEA9  bl 0x831a8164
	ctx.lr = 0x828FA2C0;
	sub_831A8130(ctx, base);
	// 828FA2C0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828FA2C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA2C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FA2CC: 4885A335  bl 0x83154600
	ctx.lr = 0x828FA2D0;
	sub_83154600(ctx, base);
	// 828FA2D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FA2D4: 4BFBEA15  bl 0x828b8ce8
	ctx.lr = 0x828FA2D8;
	sub_828B8CE8(ctx, base);
	// 828FA2D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FA2DC: 4BFF880D  bl 0x828f2ae8
	ctx.lr = 0x828FA2E0;
	sub_828F2AE8(ctx, base);
	// 828FA2E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FA2E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FA2E8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828FA2EC: 4855F48D  bl 0x82e59778
	ctx.lr = 0x828FA2F0;
	sub_82E59778(ctx, base);
	// 828FA2F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA2F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA2F8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FA2FC: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828FA300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA304: 4E800421  bctrl
	ctx.lr = 0x828FA308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA308: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FA30C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA310: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FA314: 4804591D  bl 0x8293fc30
	ctx.lr = 0x828FA318;
	sub_8293FC30(ctx, base);
	// 828FA318: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA320: 4800F339  bl 0x82909658
	ctx.lr = 0x828FA324;
	sub_82909658(ctx, base);
	// 828FA324: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA328: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FA32C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FA330: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA334: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA338: 4E800421  bctrl
	ctx.lr = 0x828FA33C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA33C: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FA340: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FA344: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FA3F8 size=1148
    let mut pc: u32 = 0x828FA3F8;
    'dispatch: loop {
        match pc {
            0x828FA3F8 => {
    //   block [0x828FA3F8..0x828FA874)
	// 828FA3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA3FC: 488ADD69  bl 0x831a8164
	ctx.lr = 0x828FA400;
	sub_831A8130(ctx, base);
	// 828FA400: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA404: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FA408: 4885A1F9  bl 0x83154600
	ctx.lr = 0x828FA40C;
	sub_83154600(ctx, base);
	// 828FA40C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FA410: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA414: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828FA418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA41C: 4E800421  bctrl
	ctx.lr = 0x828FA420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA420: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 828FA424: 3BDD0068  addi r30, r29, 0x68
	ctx.r[30].s64 = ctx.r[29].s64 + 104;
	// 828FA428: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FA42C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FA430: 41820010  beq 0x828fa440
	if ctx.cr[0].eq {
	pc = 0x828FA440; continue 'dispatch;
	}
	// 828FA434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FA438: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA43C: 480003D8  b 0x828fa814
	pc = 0x828FA814; continue 'dispatch;
	// 828FA440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA444: 4BFBE8A5  bl 0x828b8ce8
	ctx.lr = 0x828FA448;
	sub_828B8CE8(ctx, base);
	// 828FA448: 4BFF86A1  bl 0x828f2ae8
	ctx.lr = 0x828FA44C;
	sub_828F2AE8(ctx, base);
	// 828FA44C: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA450: 3B830100  addi r28, r3, 0x100
	ctx.r[28].s64 = ctx.r[3].s64 + 256;
	// 828FA454: 556AD7FF  rlwinm. r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FA458: 41820084  beq 0x828fa4dc
	if ctx.cr[0].eq {
	pc = 0x828FA4DC; continue 'dispatch;
	}
	// 828FA45C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FA460: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA464: 556B06B0  rlwinm r11, r11, 0, 0x1a, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA46C: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA470: 808AB3D4  lwz r4, -0x4c2c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19500 as u32) ) } as u64;
	// 828FA474: 484F9595  bl 0x82df3a08
	ctx.lr = 0x828FA478;
	sub_82DF3A08(ctx, base);
	// 828FA478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA47C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA480: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA48C: 4E800421  bctrl
	ctx.lr = 0x828FA490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA494: 484F8F95  bl 0x82df3428
	ctx.lr = 0x828FA498;
	sub_82DF3428(ctx, base);
	// 828FA498: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA49C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA4A0: C19C0010  lfs f12, 0x10(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA4A4: D18100A0  stfs f12, 0xa0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 828FA4A8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828FA4AC: D18100A8  stfs f12, 0xa8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 828FA4B0: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA4B4: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA4B8: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828FA4BC: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 828FA4C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA4C8: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FA4CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA4D0: 4E800421  bctrl
	ctx.lr = 0x828FA4D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA4D4: C03C0014  lfs f1, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FA4D8: 48000328  b 0x828fa800
	pc = 0x828FA800; continue 'dispatch;
	// 828FA4DC: 556ADFFF  rlwinm. r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FA4E0: 4182006C  beq 0x828fa54c
	if ctx.cr[0].eq {
	pc = 0x828FA54C; continue 'dispatch;
	}
	// 828FA4E4: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA4E8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA4F0: 556B06F2  rlwinm r11, r11, 0, 0x1b, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA4F4: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA4F8: 808AB3DC  lwz r4, -0x4c24(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19492 as u32) ) } as u64;
	// 828FA4FC: 484F950D  bl 0x82df3a08
	ctx.lr = 0x828FA500;
	sub_82DF3A08(ctx, base);
	// 828FA500: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA504: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA50C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA514: 4E800421  bctrl
	ctx.lr = 0x828FA518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA51C: 484F8F0D  bl 0x82df3428
	ctx.lr = 0x828FA520;
	sub_82DF3428(ctx, base);
	// 828FA520: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA524: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA528: C19C0010  lfs f12, 0x10(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA52C: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828FA530: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828FA534: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828FA538: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA53C: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA540: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828FA544: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828FA548: 4BFFFF78  b 0x828fa4c0
	pc = 0x828FA4C0; continue 'dispatch;
	// 828FA54C: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FA550: 4182006C  beq 0x828fa5bc
	if ctx.cr[0].eq {
	pc = 0x828FA5BC; continue 'dispatch;
	}
	// 828FA554: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA558: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA55C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA560: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA564: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA568: 808AB3D8  lwz r4, -0x4c28(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19496 as u32) ) } as u64;
	// 828FA56C: 484F949D  bl 0x82df3a08
	ctx.lr = 0x828FA570;
	sub_82DF3A08(ctx, base);
	// 828FA570: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA574: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA578: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA580: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA584: 4E800421  bctrl
	ctx.lr = 0x828FA588;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA58C: 484F8E9D  bl 0x82df3428
	ctx.lr = 0x828FA590;
	sub_82DF3428(ctx, base);
	// 828FA590: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA594: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA598: C19C0018  lfs f12, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA59C: D18100C0  stfs f12, 0xc0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 828FA5A0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 828FA5A4: D18100C8  stfs f12, 0xc8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 828FA5A8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA5AC: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA5B0: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 828FA5B4: D1A100CC  stfs f13, 0xcc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 828FA5B8: 48000230  b 0x828fa7e8
	pc = 0x828FA7E8; continue 'dispatch;
	// 828FA5BC: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FA5C0: 4182006C  beq 0x828fa62c
	if ctx.cr[0].eq {
	pc = 0x828FA62C; continue 'dispatch;
	}
	// 828FA5C4: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA5C8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA5CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA5D0: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA5D4: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA5D8: 808AB3E0  lwz r4, -0x4c20(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19488 as u32) ) } as u64;
	// 828FA5DC: 484F942D  bl 0x82df3a08
	ctx.lr = 0x828FA5E0;
	sub_82DF3A08(ctx, base);
	// 828FA5E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA5E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA5EC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA5F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA5F4: 4E800421  bctrl
	ctx.lr = 0x828FA5F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA5FC: 484F8E2D  bl 0x82df3428
	ctx.lr = 0x828FA600;
	sub_82DF3428(ctx, base);
	// 828FA600: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA604: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA608: C19C0018  lfs f12, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA60C: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828FA610: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FA614: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828FA618: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA61C: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA620: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828FA624: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828FA628: 480001C0  b 0x828fa7e8
	pc = 0x828FA7E8; continue 'dispatch;
	// 828FA62C: 556AC7FF  rlwinm. r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FA630: 4182006C  beq 0x828fa69c
	if ctx.cr[0].eq {
	pc = 0x828FA69C; continue 'dispatch;
	}
	// 828FA634: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA638: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA640: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA644: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA648: 808AB3E4  lwz r4, -0x4c1c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19484 as u32) ) } as u64;
	// 828FA64C: 484F93BD  bl 0x82df3a08
	ctx.lr = 0x828FA650;
	sub_82DF3A08(ctx, base);
	// 828FA650: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA654: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA65C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA660: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA664: 4E800421  bctrl
	ctx.lr = 0x828FA668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA66C: 484F8DBD  bl 0x82df3428
	ctx.lr = 0x828FA670;
	sub_82DF3428(ctx, base);
	// 828FA670: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA674: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA678: C19C0010  lfs f12, 0x10(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA67C: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828FA680: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FA684: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828FA688: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA68C: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA690: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828FA694: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828FA698: 4BFFFE28  b 0x828fa4c0
	pc = 0x828FA4C0; continue 'dispatch;
	// 828FA69C: 556AE7FF  rlwinm. r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FA6A0: 4182006C  beq 0x828fa70c
	if ctx.cr[0].eq {
	pc = 0x828FA70C; continue 'dispatch;
	}
	// 828FA6A4: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA6A8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA6AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA6B0: 556B0734  rlwinm r11, r11, 0, 0x1c, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA6B4: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA6B8: 808AB3E8  lwz r4, -0x4c18(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19480 as u32) ) } as u64;
	// 828FA6BC: 484F934D  bl 0x82df3a08
	ctx.lr = 0x828FA6C0;
	sub_82DF3A08(ctx, base);
	// 828FA6C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA6C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA6CC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA6D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA6D4: 4E800421  bctrl
	ctx.lr = 0x828FA6D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA6D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA6DC: 484F8D4D  bl 0x82df3428
	ctx.lr = 0x828FA6E0;
	sub_82DF3428(ctx, base);
	// 828FA6E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA6E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA6E8: C19C0018  lfs f12, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA6EC: D1810090  stfs f12, 0x90(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828FA6F0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828FA6F4: D1810098  stfs f12, 0x98(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828FA6F8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA6FC: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA700: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828FA704: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828FA708: 480000E0  b 0x828fa7e8
	pc = 0x828FA7E8; continue 'dispatch;
	// 828FA70C: 556ACFFF  rlwinm. r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FA710: 4182006C  beq 0x828fa77c
	if ctx.cr[0].eq {
	pc = 0x828FA77C; continue 'dispatch;
	}
	// 828FA714: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA718: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA720: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA724: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA728: 808AB3EC  lwz r4, -0x4c14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19476 as u32) ) } as u64;
	// 828FA72C: 484F92DD  bl 0x82df3a08
	ctx.lr = 0x828FA730;
	sub_82DF3A08(ctx, base);
	// 828FA730: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA73C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA744: 4E800421  bctrl
	ctx.lr = 0x828FA748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA74C: 484F8CDD  bl 0x82df3428
	ctx.lr = 0x828FA750;
	sub_82DF3428(ctx, base);
	// 828FA750: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA754: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA758: C19C0010  lfs f12, 0x10(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA75C: D18100B0  stfs f12, 0xb0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 828FA760: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 828FA764: D18100B8  stfs f12, 0xb8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 828FA768: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA76C: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA770: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828FA774: D1A100BC  stfs f13, 0xbc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 828FA778: 4BFFFD48  b 0x828fa4c0
	pc = 0x828FA4C0; continue 'dispatch;
	// 828FA77C: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FA780: 41820094  beq 0x828fa814
	if ctx.cr[0].eq {
	pc = 0x828FA814; continue 'dispatch;
	}
	// 828FA784: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FA788: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA78C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA790: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA794: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FA798: 808AB3F0  lwz r4, -0x4c10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19472 as u32) ) } as u64;
	// 828FA79C: 484F926D  bl 0x82df3a08
	ctx.lr = 0x828FA7A0;
	sub_82DF3A08(ctx, base);
	// 828FA7A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA7A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA7AC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA7B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA7B4: 4E800421  bctrl
	ctx.lr = 0x828FA7B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA7B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA7BC: 484F8C6D  bl 0x82df3428
	ctx.lr = 0x828FA7C0;
	sub_82DF3428(ctx, base);
	// 828FA7C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FA7C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FA7C8: C19C0018  lfs f12, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FA7CC: D18100D0  stfs f12, 0xd0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 828FA7D0: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 828FA7D4: D18100D8  stfs f12, 0xd8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 828FA7D8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA7DC: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FA7E0: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 828FA7E4: D1A100DC  stfs f13, 0xdc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 828FA7E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA7EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA7F0: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FA7F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA7F8: 4E800421  bctrl
	ctx.lr = 0x828FA7FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA7FC: C03C001C  lfs f1, 0x1c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FA800: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FA804: 4BEEFB65  bl 0x827ea368
	ctx.lr = 0x828FA808;
	sub_827EA368(ctx, base);
	// 828FA808: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA80C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828FA810: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FA814: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA818: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FA81C: 41820050  beq 0x828fa86c
	if ctx.cr[0].eq {
	pc = 0x828FA86C; continue 'dispatch;
	}
	// 828FA820: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FA824: 4BEEFAED  bl 0x827ea310
	ctx.lr = 0x828FA828;
	sub_827EA310(ctx, base);
	// 828FA828: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FA82C: 41820040  beq 0x828fa86c
	if ctx.cr[0].eq {
	pc = 0x828FA86C; continue 'dispatch;
	}
	// 828FA830: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FA834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA838: 808BB3D0  lwz r4, -0x4c30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 828FA83C: 484F91CD  bl 0x82df3a08
	ctx.lr = 0x828FA840;
	sub_82DF3A08(ctx, base);
	// 828FA840: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA844: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA84C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA854: 4E800421  bctrl
	ctx.lr = 0x828FA858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA85C: 484F8BCD  bl 0x82df3428
	ctx.lr = 0x828FA860;
	sub_82DF3428(ctx, base);
	// 828FA860: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA864: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA868: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FA86C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828FA870: 488AD944  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FA878 size=248
    let mut pc: u32 = 0x828FA878;
    'dispatch: loop {
        match pc {
            0x828FA878 => {
    //   block [0x828FA878..0x828FA970)
	// 828FA878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA87C: 488AD8E9  bl 0x831a8164
	ctx.lr = 0x828FA880;
	sub_831A8130(ctx, base);
	// 828FA880: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA884: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FA888: 48859D79  bl 0x83154600
	ctx.lr = 0x828FA88C;
	sub_83154600(ctx, base);
	// 828FA88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FA890: 4BFBE459  bl 0x828b8ce8
	ctx.lr = 0x828FA894;
	sub_828B8CE8(ctx, base);
	// 828FA894: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FA898: 4BFF8251  bl 0x828f2ae8
	ctx.lr = 0x828FA89C;
	sub_828F2AE8(ctx, base);
	// 828FA89C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA8A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FA8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA8A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA8AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FA8B0: 4E800421  bctrl
	ctx.lr = 0x828FA8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA8B4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FA8B8: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 828FA8BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FA8C0: 4800ED99  bl 0x82909658
	ctx.lr = 0x828FA8C4;
	sub_82909658(ctx, base);
	// 828FA8C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FA8C8: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FA8CC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828FA8D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FA8D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FA8D8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FA970 size=96
    let mut pc: u32 = 0x828FA970;
    'dispatch: loop {
        match pc {
            0x828FA970 => {
    //   block [0x828FA970..0x828FA9D0)
	// 828FA970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FA978: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FA97C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FA984: 4BFFC9B5  bl 0x828f7338
	ctx.lr = 0x828FA988;
	sub_828F7338(ctx, base);
	// 828FA988: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FA98C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FA990: 396B3A4C  addi r11, r11, 0x3a4c
	ctx.r[11].s64 = ctx.r[11].s64 + 14924;
	// 828FA994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA998: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FA99C: 808A0B10  lwz r4, 0xb10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828FA9A0: 484F9069  bl 0x82df3a08
	ctx.lr = 0x828FA9A4;
	sub_82DF3A08(ctx, base);
	// 828FA9A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA9A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FA9AC: 4855ED3D  bl 0x82e596e8
	ctx.lr = 0x828FA9B0;
	sub_82E596E8(ctx, base);
	// 828FA9B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA9B4: 484F8A75  bl 0x82df3428
	ctx.lr = 0x828FA9B8;
	sub_82DF3428(ctx, base);
	// 828FA9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA9BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FA9C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FA9C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FA9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FA9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FA9D0 size=408
    let mut pc: u32 = 0x828FA9D0;
    'dispatch: loop {
        match pc {
            0x828FA9D0 => {
    //   block [0x828FA9D0..0x828FAB68)
	// 828FA9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA9D4: 488AD795  bl 0x831a8168
	ctx.lr = 0x828FA9D8;
	sub_831A8130(ctx, base);
	// 828FA9D8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828FA9DC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA9E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FA9E4: 48859C1D  bl 0x83154600
	ctx.lr = 0x828FA9E8;
	sub_83154600(ctx, base);
	// 828FA9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FA9EC: 4BFBE2FD  bl 0x828b8ce8
	ctx.lr = 0x828FA9F0;
	sub_828B8CE8(ctx, base);
	// 828FA9F0: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 828FA9F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FA9F8: 4800EB89  bl 0x82909580
	ctx.lr = 0x828FA9FC;
	sub_82909580(ctx, base);
	// 828FA9FC: 4802141D  bl 0x8291be18
	ctx.lr = 0x828FAA00;
	sub_8291BE18(ctx, base);
	// 828FAA00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FAA04: 41820054  beq 0x828faa58
	if ctx.cr[0].eq {
	pc = 0x828FAA58; continue 'dispatch;
	}
	// 828FAA08: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FAA0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FAA10: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828FAA14: 484F8FF5  bl 0x82df3a08
	ctx.lr = 0x828FAA18;
	sub_82DF3A08(ctx, base);
	// 828FAA18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FAA1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FAA20: 4870D709  bl 0x83008128
	ctx.lr = 0x828FAA24;
	sub_83008128(ctx, base);
	// 828FAA24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FAA28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FAA2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FAA30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FAA34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FAA38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FAA3C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FAA40: 48563F21  bl 0x82e5e960
	ctx.lr = 0x828FAA44;
	sub_82E5E960(ctx, base);
	// 828FAA44: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FAA48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FAA4C: 419A0110  beq cr6, 0x828fab5c
	if ctx.cr[6].eq {
	pc = 0x828FAB5C; continue 'dispatch;
	}
	// 828FAA50: 4B9C5E41  bl 0x822c0890
	ctx.lr = 0x828FAA54;
	sub_822C0890(ctx, base);
	// 828FAA54: 48000108  b 0x828fab5c
	pc = 0x828FAB5C; continue 'dispatch;
	// 828FAA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAA5C: 4BEF4CDD  bl 0x827ef738
	ctx.lr = 0x828FAA60;
	sub_827EF738(ctx, base);
	// 828FAA60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAA64: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FAA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAA6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAA70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FAA74: 4E800421  bctrl
	ctx.lr = 0x828FAA78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAA78: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828FAA7C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FAA80: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828FAA84: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FAA88: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 828FAA8C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 828FAA90: 13DC58C7  vcmpequd (lvx128) v30, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FAA94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FAB68 size=196
    let mut pc: u32 = 0x828FAB68;
    'dispatch: loop {
        match pc {
            0x828FAB68 => {
    //   block [0x828FAB68..0x828FAC2C)
	// 828FAB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAB6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FAB70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FAB74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FAB78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAB7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FAB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FAB84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FAB88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FAB8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FAB90: 4B9C5DA9  bl 0x822c0938
	ctx.lr = 0x828FAB94;
	sub_822C0938(ctx, base);
	// 828FAB94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FAB98: 41820028  beq 0x828fabc0
	if ctx.cr[0].eq {
	pc = 0x828FABC0; continue 'dispatch;
	}
	// 828FAB9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FABA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FABA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FABA8: 392B3A24  addi r9, r11, 0x3a24
	ctx.r[9].s64 = ctx.r[11].s64 + 14884;
	// 828FABAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FABB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FABB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FABB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FABBC: 48000008  b 0x828fabc4
	pc = 0x828FABC4; continue 'dispatch;
	// 828FABC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FABC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FABC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FABCC: 409A0044  bne cr6, 0x828fac10
	if !ctx.cr[6].eq {
	pc = 0x828FAC10; continue 'dispatch;
	}
	// 828FABD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FABD4: 419A001C  beq cr6, 0x828fabf0
	if ctx.cr[6].eq {
	pc = 0x828FABF0; continue 'dispatch;
	}
	// 828FABD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FABDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FABE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FABE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FABE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FABEC: 4E800421  bctrl
	ctx.lr = 0x828FABF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FABF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FABF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FABF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FABFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FAC00: 816BBB94  lwz r11, -0x446c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17516 as u32) ) } as u64;
	// 828FAC04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FAC08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FAC0C: 4B9C53F5  bl 0x822c0000
	ctx.lr = 0x828FAC10;
	sub_822C0000(ctx, base);
	// 828FAC10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FAC14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FAC18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FAC1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FAC20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FAC24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FAC28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FAC30 size=196
    let mut pc: u32 = 0x828FAC30;
    'dispatch: loop {
        match pc {
            0x828FAC30 => {
    //   block [0x828FAC30..0x828FACF4)
	// 828FAC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAC34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FAC38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FAC3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FAC40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAC44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FAC48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FAC4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FAC50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FAC54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FAC58: 4B9C5CE1  bl 0x822c0938
	ctx.lr = 0x828FAC5C;
	sub_822C0938(ctx, base);
	// 828FAC5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FAC60: 41820028  beq 0x828fac88
	if ctx.cr[0].eq {
	pc = 0x828FAC88; continue 'dispatch;
	}
	// 828FAC64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FAC68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FAC6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FAC70: 392B3A38  addi r9, r11, 0x3a38
	ctx.r[9].s64 = ctx.r[11].s64 + 14904;
	// 828FAC74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FAC78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FAC7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FAC80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FAC84: 48000008  b 0x828fac8c
	pc = 0x828FAC8C; continue 'dispatch;
	// 828FAC88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FAC8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FAC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FAC94: 409A0044  bne cr6, 0x828facd8
	if !ctx.cr[6].eq {
	pc = 0x828FACD8; continue 'dispatch;
	}
	// 828FAC98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FAC9C: 419A001C  beq cr6, 0x828facb8
	if ctx.cr[6].eq {
	pc = 0x828FACB8; continue 'dispatch;
	}
	// 828FACA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FACA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FACA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FACAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FACB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FACB4: 4E800421  bctrl
	ctx.lr = 0x828FACB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FACB8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FACBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FACC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FACC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FACC8: 816BBB94  lwz r11, -0x446c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17516 as u32) ) } as u64;
	// 828FACCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FACD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FACD4: 4B9C532D  bl 0x822c0000
	ctx.lr = 0x828FACD8;
	sub_822C0000(ctx, base);
	// 828FACD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FACDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FACE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FACE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FACE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FACEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FACF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FACF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FACF8 size=96
    let mut pc: u32 = 0x828FACF8;
    'dispatch: loop {
        match pc {
            0x828FACF8 => {
    //   block [0x828FACF8..0x828FAD58)
	// 828FACF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FACFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FAD00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FAD04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAD08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FAD0C: 4BFFC66D  bl 0x828f7378
	ctx.lr = 0x828FAD10;
	sub_828F7378(ctx, base);
	// 828FAD10: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FAD14: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FAD18: 396B3A78  addi r11, r11, 0x3a78
	ctx.r[11].s64 = ctx.r[11].s64 + 14968;
	// 828FAD1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FAD20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FAD24: 808A0AFC  lwz r4, 0xafc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828FAD28: 484F8CE1  bl 0x82df3a08
	ctx.lr = 0x828FAD2C;
	sub_82DF3A08(ctx, base);
	// 828FAD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAD30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FAD34: 4855E9B5  bl 0x82e596e8
	ctx.lr = 0x828FAD38;
	sub_82E596E8(ctx, base);
	// 828FAD38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FAD3C: 484F86ED  bl 0x82df3428
	ctx.lr = 0x828FAD40;
	sub_82DF3428(ctx, base);
	// 828FAD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAD44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FAD48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FAD4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FAD50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FAD54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FAD58 size=336
    let mut pc: u32 = 0x828FAD58;
    'dispatch: loop {
        match pc {
            0x828FAD58 => {
    //   block [0x828FAD58..0x828FAEA8)
	// 828FAD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAD5C: 488AD411  bl 0x831a816c
	ctx.lr = 0x828FAD60;
	sub_831A8130(ctx, base);
	// 828FAD60: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828FAD64: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAD68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FAD6C: 48859895  bl 0x83154600
	ctx.lr = 0x828FAD70;
	sub_83154600(ctx, base);
	// 828FAD70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FAD74: 4BFBDF75  bl 0x828b8ce8
	ctx.lr = 0x828FAD78;
	sub_828B8CE8(ctx, base);
	// 828FAD78: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 828FAD7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FAD80: 4800E801  bl 0x82909580
	ctx.lr = 0x828FAD84;
	sub_82909580(ctx, base);
	// 828FAD84: 48021095  bl 0x8291be18
	ctx.lr = 0x828FAD88;
	sub_8291BE18(ctx, base);
	// 828FAD88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FAD8C: 41820054  beq 0x828fade0
	if ctx.cr[0].eq {
	pc = 0x828FADE0; continue 'dispatch;
	}
	// 828FAD90: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FAD94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FAD98: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828FAD9C: 484F8C6D  bl 0x82df3a08
	ctx.lr = 0x828FADA0;
	sub_82DF3A08(ctx, base);
	// 828FADA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FADA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FADA8: 4870D381  bl 0x83008128
	ctx.lr = 0x828FADAC;
	sub_83008128(ctx, base);
	// 828FADAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FADB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FADB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FADB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FADBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FADC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FADC4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FADC8: 48563B99  bl 0x82e5e960
	ctx.lr = 0x828FADCC;
	sub_82E5E960(ctx, base);
	// 828FADCC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FADD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FADD4: 419A00C8  beq cr6, 0x828fae9c
	if ctx.cr[6].eq {
	pc = 0x828FAE9C; continue 'dispatch;
	}
	// 828FADD8: 4B9C5AB9  bl 0x822c0890
	ctx.lr = 0x828FADDC;
	sub_822C0890(ctx, base);
	// 828FADDC: 480000C0  b 0x828fae9c
	pc = 0x828FAE9C; continue 'dispatch;
	// 828FADE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FADE4: 4855E995  bl 0x82e59778
	ctx.lr = 0x828FADE8;
	sub_82E59778(ctx, base);
	// 828FADE8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FADEC: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828FADF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FADF4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828FADF8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FADFC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828FAE00: 40980044  bge cr6, 0x828fae44
	if !ctx.cr[6].lt {
	pc = 0x828FAE44; continue 'dispatch;
	}
	// 828FAE04: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FAE08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FAE0C: 808BB404  lwz r4, -0x4bfc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19452 as u32) ) } as u64;
	// 828FAE10: 484F8BF9  bl 0x82df3a08
	ctx.lr = 0x828FAE14;
	sub_82DF3A08(ctx, base);
	// 828FAE14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FAE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAE1C: 4870D30D  bl 0x83008128
	ctx.lr = 0x828FAE20;
	sub_83008128(ctx, base);
	// 828FAE20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FAE24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FAE28: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FAE2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FAE30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FAE34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FAE38: 48563B29  bl 0x82e5e960
	ctx.lr = 0x828FAE3C;
	sub_82E5E960(ctx, base);
	// 828FAE3C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FAE40: 4BFFFF90  b 0x828fadd0
	pc = 0x828FADD0; continue 'dispatch;
	// 828FAE44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FAE48: 4800E741  bl 0x82909588
	ctx.lr = 0x828FAE4C;
	sub_82909588(ctx, base);
	// 828FAE4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FAE50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAE54: 4855E925  bl 0x82e59778
	ctx.lr = 0x828FAE58;
	sub_82E59778(ctx, base);
	// 828FAE58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FAE5C: 480454BD  bl 0x82940318
	ctx.lr = 0x828FAE60;
	sub_82940318(ctx, base);
	// 828FAE60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FAE64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828FAE68: 480453A1  bl 0x82940208
	ctx.lr = 0x828FAE6C;
	sub_82940208(ctx, base);
	// 828FAE6C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAE70: 4BFF7C79  bl 0x828f2ae8
	ctx.lr = 0x828FAE74;
	sub_828F2AE8(ctx, base);
	// 828FAE74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FAE78: C1A30048  lfs f13, 0x48(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FAE7C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FAE80: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FAE84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FAE88: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828FAE8C: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FAE90: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FAE94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FAE98: 4E800421  bctrl
	ctx.lr = 0x828FAE9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAE9C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828FAEA0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828FAEA4: 488AD318  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FAEA8 size=732
    let mut pc: u32 = 0x828FAEA8;
    'dispatch: loop {
        match pc {
            0x828FAEA8 => {
    //   block [0x828FAEA8..0x828FB184)
	// 828FAEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAEAC: 488AD2AD  bl 0x831a8158
	ctx.lr = 0x828FAEB0;
	sub_831A8130(ctx, base);
	// 828FAEB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAEB4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828FAEB8: 48859749  bl 0x83154600
	ctx.lr = 0x828FAEBC;
	sub_83154600(ctx, base);
	// 828FAEBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FAEC0: 4BFBDE29  bl 0x828b8ce8
	ctx.lr = 0x828FAEC4;
	sub_828B8CE8(ctx, base);
	// 828FAEC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FAEC8: 4BFF7C21  bl 0x828f2ae8
	ctx.lr = 0x828FAECC;
	sub_828F2AE8(ctx, base);
	// 828FAECC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FAED0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FAED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FAED8: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828FAEDC: 484F8B2D  bl 0x82df3a08
	ctx.lr = 0x828FAEE0;
	sub_82DF3A08(ctx, base);
	// 828FAEE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAEE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FAEE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FAEEC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FAEF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FAEF4: 4E800421  bctrl
	ctx.lr = 0x828FAEF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAEF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FAEFC: 484F852D  bl 0x82df3428
	ctx.lr = 0x828FAF00;
	sub_82DF3428(ctx, base);
	// 828FAF00: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828FAF04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FAF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAF0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAF10: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828FAF14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FAF18: 4E800421  bctrl
	ctx.lr = 0x828FAF1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAF1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAF24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FAF28: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828FAF2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FAF30: 4E800421  bctrl
	ctx.lr = 0x828FAF34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAF38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FAF3C: 4801580D  bl 0x82910748
	ctx.lr = 0x828FAF40;
	sub_82910748(ctx, base);
	// 828FAF40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAF44: 4800E645  bl 0x82909588
	ctx.lr = 0x828FAF48;
	sub_82909588(ctx, base);
	// 828FAF48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FAF4C: 4804555D  bl 0x829404a8
	ctx.lr = 0x828FAF50;
	sub_829404A8(ctx, base);
	// 828FAF50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FAF54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FAF58: 3B8B3AA0  addi r28, r11, 0x3aa0
	ctx.r[28].s64 = ctx.r[11].s64 + 15008;
	// 828FAF5C: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 828FAF60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FAF64: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828FAF68: 4B9C5471  bl 0x822c03d8
	ctx.lr = 0x828FAF6C;
	sub_822C03D8(ctx, base);
	// 828FAF6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FAF70: 41820018  beq 0x828faf88
	if ctx.cr[0].eq {
	pc = 0x828FAF88; continue 'dispatch;
	}
	// 828FAF74: 38BB00C4  addi r5, r27, 0xc4
	ctx.r[5].s64 = ctx.r[27].s64 + 196;
	// 828FAF78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FAF7C: 4804840D  bl 0x82943388
	ctx.lr = 0x828FAF80;
	sub_82943388(ctx, base);
	// 828FAF80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FAF84: 48000008  b 0x828faf8c
	pc = 0x828FAF8C; continue 'dispatch;
	// 828FAF88: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FAF8C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828FAF90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FAF94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FAF98: 4BF76F21  bl 0x82871eb8
	ctx.lr = 0x828FAF9C;
	sub_82871EB8(ctx, base);
	// 828FAF9C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828FAFA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FAFA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FAFA8: 4B9C5059  bl 0x822c0000
	ctx.lr = 0x828FAFAC;
	sub_822C0000(ctx, base);
	// 828FAFAC: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FAFB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FAFB4: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828FAFB8: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 828FAFBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FAFC0: 419A0024  beq cr6, 0x828fafe4
	if ctx.cr[6].eq {
	pc = 0x828FAFE4; continue 'dispatch;
	}
	// 828FAFC4: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 828FAFC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FAFCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FAFD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FAFD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FAFD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FAFDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FAFE0: 4082FFE8  bne 0x828fafc8
	if !ctx.cr[0].eq {
	pc = 0x828FAFC8; continue 'dispatch;
	}
	// 828FAFE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FAFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FAFEC: 480454C5  bl 0x829404b0
	ctx.lr = 0x828FAFF0;
	sub_829404B0(ctx, base);
	// 828FAFF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FAFF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FAFF8: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 828FAFFC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828FB000: 4B9C53D9  bl 0x822c03d8
	ctx.lr = 0x828FB004;
	sub_822C03D8(ctx, base);
	// 828FB004: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FB008: 41820018  beq 0x828fb020
	if ctx.cr[0].eq {
	pc = 0x828FB020; continue 'dispatch;
	}
	// 828FB00C: 38BB00D4  addi r5, r27, 0xd4
	ctx.r[5].s64 = ctx.r[27].s64 + 212;
	// 828FB010: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FB014: 48046EF5  bl 0x82941f08
	ctx.lr = 0x828FB018;
	sub_82941F08(ctx, base);
	// 828FB018: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB01C: 48000008  b 0x828fb024
	pc = 0x828FB024; continue 'dispatch;
	// 828FB020: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FB024: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828FB028: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FB02C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FB030: 4BF77D79  bl 0x82872da8
	ctx.lr = 0x828FB034;
	sub_82872DA8(ctx, base);
	// 828FB034: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828FB038: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FB03C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FB040: 4B9C4FC1  bl 0x822c0000
	ctx.lr = 0x828FB044;
	sub_822C0000(ctx, base);
	// 828FB044: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FB048: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB04C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828FB050: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828FB054: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FB058: 419A0024  beq cr6, 0x828fb07c
	if ctx.cr[6].eq {
	pc = 0x828FB07C; continue 'dispatch;
	}
	// 828FB05C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 828FB060: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FB064: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FB068: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FB06C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FB070: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FB074: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FB078: 4082FFE8  bne 0x828fb060
	if !ctx.cr[0].eq {
	pc = 0x828FB060; continue 'dispatch;
	}
	// 828FB07C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB084: 4804542D  bl 0x829404b0
	ctx.lr = 0x828FB088;
	sub_829404B0(ctx, base);
	// 828FB088: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FB08C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FB090: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 828FB094: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828FB098: 4B9C5341  bl 0x822c03d8
	ctx.lr = 0x828FB09C;
	sub_822C03D8(ctx, base);
	// 828FB09C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FB0A0: 41820018  beq 0x828fb0b8
	if ctx.cr[0].eq {
	pc = 0x828FB0B8; continue 'dispatch;
	}
	// 828FB0A4: 38BB00F0  addi r5, r27, 0xf0
	ctx.r[5].s64 = ctx.r[27].s64 + 240;
	// 828FB0A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FB0AC: 48047875  bl 0x82942920
	ctx.lr = 0x828FB0B0;
	sub_82942920(ctx, base);
	// 828FB0B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB0B4: 48000008  b 0x828fb0bc
	pc = 0x828FB0BC; continue 'dispatch;
	// 828FB0B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FB0BC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828FB0C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FB0C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FB0C8: 4BF76EB9  bl 0x82871f80
	ctx.lr = 0x828FB0CC;
	sub_82871F80(ctx, base);
	// 828FB0CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828FB0D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FB0D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FB0D8: 4B9C4F29  bl 0x822c0000
	ctx.lr = 0x828FB0DC;
	sub_822C0000(ctx, base);
	// 828FB0DC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FB0E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB0E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FB0E8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828FB0EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FB0F0: 419A0024  beq cr6, 0x828fb114
	if ctx.cr[6].eq {
	pc = 0x828FB114; continue 'dispatch;
	}
	// 828FB0F4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828FB0F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FB0FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FB100: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FB104: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FB108: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FB10C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FB110: 4082FFE8  bne 0x828fb0f8
	if !ctx.cr[0].eq {
	pc = 0x828FB0F8; continue 'dispatch;
	}
	// 828FB114: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB11C: 48045395  bl 0x829404b0
	ctx.lr = 0x828FB120;
	sub_829404B0(ctx, base);
	// 828FB120: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FB124: 419A000C  beq cr6, 0x828fb130
	if ctx.cr[6].eq {
	pc = 0x828FB130; continue 'dispatch;
	}
	// 828FB128: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB12C: 4B9C5765  bl 0x822c0890
	ctx.lr = 0x828FB130;
	sub_822C0890(ctx, base);
	// 828FB130: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828FB134: 419A000C  beq cr6, 0x828fb140
	if ctx.cr[6].eq {
	pc = 0x828FB140; continue 'dispatch;
	}
	// 828FB138: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828FB13C: 4B9C5755  bl 0x822c0890
	ctx.lr = 0x828FB140;
	sub_822C0890(ctx, base);
	// 828FB140: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828FB144: 419A000C  beq cr6, 0x828fb150
	if ctx.cr[6].eq {
	pc = 0x828FB150; continue 'dispatch;
	}
	// 828FB148: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828FB14C: 4B9C5745  bl 0x822c0890
	ctx.lr = 0x828FB150;
	sub_822C0890(ctx, base);
	// 828FB150: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB154: C01B0024  lfs f0, 0x24(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FB158: C1BB0020  lfs f13, 0x20(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FB15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB160: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828FB164: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828FB168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FB16C: 4E800421  bctrl
	ctx.lr = 0x828FB170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB170: C01B0020  lfs f0, 0x20(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FB174: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 828FB178: D0190060  stfs f0, 0x60(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828FB17C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828FB180: 488AD028  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB188 size=112
    let mut pc: u32 = 0x828FB188;
    'dispatch: loop {
        match pc {
            0x828FB188 => {
    //   block [0x828FB188..0x828FB1F8)
	// 828FB188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB18C: 488ACFE1  bl 0x831a816c
	ctx.lr = 0x828FB190;
	sub_831A8130(ctx, base);
	// 828FB190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB194: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FB198: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB19C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FB1A0: 388B3AA0  addi r4, r11, 0x3aa0
	ctx.r[4].s64 = ctx.r[11].s64 + 15008;
	// 828FB1A4: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 828FB1A8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828FB1AC: 484F723D  bl 0x82df23e8
	ctx.lr = 0x828FB1B0;
	sub_82DF23E8(ctx, base);
	// 828FB1B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FB1B4: 41820010  beq 0x828fb1c4
	if ctx.cr[0].eq {
	pc = 0x828FB1C4; continue 'dispatch;
	}
	// 828FB1B8: 4BFFFB41  bl 0x828facf8
	ctx.lr = 0x828FB1BC;
	sub_828FACF8(ctx, base);
	// 828FB1BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB1C0: 48000008  b 0x828fb1c8
	pc = 0x828FB1C8; continue 'dispatch;
	// 828FB1C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FB1C8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FB1CC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828FB1D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FB1D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB1D8: 4BFFF991  bl 0x828fab68
	ctx.lr = 0x828FB1DC;
	sub_828FAB68(ctx, base);
	// 828FB1DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FB1E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FB1E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB1E8: 4B9C4E19  bl 0x822c0000
	ctx.lr = 0x828FB1EC;
	sub_822C0000(ctx, base);
	// 828FB1EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB1F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB1F4: 488ACFC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FB1F8 size=388
    let mut pc: u32 = 0x828FB1F8;
    'dispatch: loop {
        match pc {
            0x828FB1F8 => {
    //   block [0x828FB1F8..0x828FB37C)
	// 828FB1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB1FC: 488ACF71  bl 0x831a816c
	ctx.lr = 0x828FB200;
	sub_831A8130(ctx, base);
	// 828FB200: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB204: 488593FD  bl 0x83154600
	ctx.lr = 0x828FB208;
	sub_83154600(ctx, base);
	// 828FB208: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB20C: 4BFBDADD  bl 0x828b8ce8
	ctx.lr = 0x828FB210;
	sub_828B8CE8(ctx, base);
	// 828FB210: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB21C: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828FB220: 484F87E9  bl 0x82df3a08
	ctx.lr = 0x828FB224;
	sub_82DF3A08(ctx, base);
	// 828FB224: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB228: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB22C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB230: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FB234: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FB238: 4E800421  bctrl
	ctx.lr = 0x828FB23C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB23C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB240: 484F81E9  bl 0x82df3428
	ctx.lr = 0x828FB244;
	sub_82DF3428(ctx, base);
	// 828FB244: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FB248: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828FB24C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FB250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB254: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828FB258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FB25C: 4E800421  bctrl
	ctx.lr = 0x828FB260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB260: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FB264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB268: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FB26C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828FB270: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FB274: 4E800421  bctrl
	ctx.lr = 0x828FB278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB278: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FB27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB280: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828FB284: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FB288: 48013AF1  bl 0x8290ed78
	ctx.lr = 0x828FB28C;
	sub_8290ED78(ctx, base);
	// 828FB28C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB290: 4800E2F9  bl 0x82909588
	ctx.lr = 0x828FB294;
	sub_82909588(ctx, base);
	// 828FB294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB298: 48045211  bl 0x829404a8
	ctx.lr = 0x828FB29C;
	sub_829404A8(ctx, base);
	// 828FB29C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB2A0: 48047071  bl 0x82942310
	ctx.lr = 0x828FB2A4;
	sub_82942310(ctx, base);
	// 828FB2A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB2A8: 4BEF4491  bl 0x827ef738
	ctx.lr = 0x828FB2AC;
	sub_827EF738(ctx, base);
	// 828FB2AC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828FB2B0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828FB2B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FB2B8: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FB2BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FB2C0: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FB2C4: 38883AA0  addi r4, r8, 0x3aa0
	ctx.r[4].s64 = ctx.r[8].s64 + 15008;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB380 size=112
    let mut pc: u32 = 0x828FB380;
    'dispatch: loop {
        match pc {
            0x828FB380 => {
    //   block [0x828FB380..0x828FB3F0)
	// 828FB380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB384: 488ACDE9  bl 0x831a816c
	ctx.lr = 0x828FB388;
	sub_831A8130(ctx, base);
	// 828FB388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB38C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FB390: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB394: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FB398: 388B3AA0  addi r4, r11, 0x3aa0
	ctx.r[4].s64 = ctx.r[11].s64 + 15008;
	// 828FB39C: 38A00108  li r5, 0x108
	ctx.r[5].s64 = 264;
	// 828FB3A0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828FB3A4: 484F7045  bl 0x82df23e8
	ctx.lr = 0x828FB3A8;
	sub_82DF23E8(ctx, base);
	// 828FB3A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FB3AC: 41820010  beq 0x828fb3bc
	if ctx.cr[0].eq {
	pc = 0x828FB3BC; continue 'dispatch;
	}
	// 828FB3B0: 4BFFF5C1  bl 0x828fa970
	ctx.lr = 0x828FB3B4;
	sub_828FA970(ctx, base);
	// 828FB3B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB3B8: 48000008  b 0x828fb3c0
	pc = 0x828FB3C0; continue 'dispatch;
	// 828FB3BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FB3C0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FB3C4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828FB3C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FB3CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB3D0: 4BFFF861  bl 0x828fac30
	ctx.lr = 0x828FB3D4;
	sub_828FAC30(ctx, base);
	// 828FB3D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FB3D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FB3DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB3E0: 4B9C4C21  bl 0x822c0000
	ctx.lr = 0x828FB3E4;
	sub_822C0000(ctx, base);
	// 828FB3E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB3E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB3EC: 488ACDD0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB3F0 size=4
    let mut pc: u32 = 0x828FB3F0;
    'dispatch: loop {
        match pc {
            0x828FB3F0 => {
    //   block [0x828FB3F0..0x828FB3F4)
	// 828FB3F0: 48063E48  b 0x8295f238
	sub_8295F238(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB3F8 size=92
    let mut pc: u32 = 0x828FB3F8;
    'dispatch: loop {
        match pc {
            0x828FB3F8 => {
    //   block [0x828FB3F8..0x828FB454)
	// 828FB3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FB400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FB404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FB408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB40C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FB410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB414: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FB418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB41C: 388B3B20  addi r4, r11, 0x3b20
	ctx.r[4].s64 = ctx.r[11].s64 + 15136;
	// 828FB420: 484F85E9  bl 0x82df3a08
	ctx.lr = 0x828FB424;
	sub_82DF3A08(ctx, base);
	// 828FB424: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FB428: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FB42C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828FB430: 48012A21  bl 0x8290de50
	ctx.lr = 0x828FB434;
	sub_8290DE50(ctx, base);
	// 828FB434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB438: 484F7FF1  bl 0x82df3428
	ctx.lr = 0x828FB43C;
	sub_82DF3428(ctx, base);
	// 828FB43C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FB448: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FB44C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FB450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB458 size=4
    let mut pc: u32 = 0x828FB458;
    'dispatch: loop {
        match pc {
            0x828FB458 => {
    //   block [0x828FB458..0x828FB45C)
	// 828FB458: 4800DF58  b 0x829093b0
	sub_829093B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB460 size=20
    let mut pc: u32 = 0x828FB460;
    'dispatch: loop {
        match pc {
            0x828FB460 => {
    //   block [0x828FB460..0x828FB474)
	// 828FB460: 8163FFF0  lwz r11, -0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828FB464: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FB468: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FB46C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FB470: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB478 size=12
    let mut pc: u32 = 0x828FB478;
    'dispatch: loop {
        match pc {
            0x828FB478 => {
    //   block [0x828FB478..0x828FB484)
	// 828FB478: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FB47C: 386BAEE4  addi r3, r11, -0x511c
	ctx.r[3].s64 = ctx.r[11].s64 + -20764;
	// 828FB480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB488 size=12
    let mut pc: u32 = 0x828FB488;
    'dispatch: loop {
        match pc {
            0x828FB488 => {
    //   block [0x828FB488..0x828FB494)
	// 828FB488: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FB48C: 41820008  beq 0x828fb494
	if ctx.cr[0].eq {
		sub_828FB494(ctx, base);
		return;
	}
	// 828FB490: 480102A0  b 0x8290b730
	sub_8290B730(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB494(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB494 size=4
    let mut pc: u32 = 0x828FB494;
    'dispatch: loop {
        match pc {
            0x828FB494 => {
    //   block [0x828FB494..0x828FB498)
	// 828FB494: 4800E2C4  b 0x82909758
	sub_82909758(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB498 size=76
    let mut pc: u32 = 0x828FB498;
    'dispatch: loop {
        match pc {
            0x828FB498 => {
    //   block [0x828FB498..0x828FB4E4)
	// 828FB498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FB4A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FB4A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB4A8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB4AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB4B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB4B4: 808BC230  lwz r4, -0x3dd0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15824 as u32) ) } as u64;
	// 828FB4B8: 484F8551  bl 0x82df3a08
	ctx.lr = 0x828FB4BC;
	sub_82DF3A08(ctx, base);
	// 828FB4BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB4C0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828FB4C4: 48063F1D  bl 0x8295f3e0
	ctx.lr = 0x828FB4C8;
	sub_8295F3E0(ctx, base);
	// 828FB4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB4CC: 484F7F5D  bl 0x82df3428
	ctx.lr = 0x828FB4D0;
	sub_82DF3428(ctx, base);
	// 828FB4D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB4D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB4D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FB4DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FB4E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FB4E8 size=160
    let mut pc: u32 = 0x828FB4E8;
    'dispatch: loop {
        match pc {
            0x828FB4E8 => {
    //   block [0x828FB4E8..0x828FB588)
	// 828FB4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB4EC: 488ACC81  bl 0x831a816c
	ctx.lr = 0x828FB4F0;
	sub_831A8130(ctx, base);
	// 828FB4F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB4F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB4F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB4FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB500: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828FB504: 484F8505  bl 0x82df3a08
	ctx.lr = 0x828FB508;
	sub_82DF3A08(ctx, base);
	// 828FB508: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828FB50C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828FB510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB514: 4BEF0CBD  bl 0x827ec1d0
	ctx.lr = 0x828FB518;
	sub_827EC1D0(ctx, base);
	// 828FB518: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FB51C: 4BEEEFC5  bl 0x827ea4e0
	ctx.lr = 0x828FB520;
	sub_827EA4E0(ctx, base);
	// 828FB520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB524: 484F7F05  bl 0x82df3428
	ctx.lr = 0x828FB528;
	sub_82DF3428(ctx, base);
	// 828FB528: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB52C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB530: 808B0BF0  lwz r4, 0xbf0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3056 as u32) ) } as u64;
	// 828FB534: 484F84D5  bl 0x82df3a08
	ctx.lr = 0x828FB538;
	sub_82DF3A08(ctx, base);
	// 828FB538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB53C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB540: 4BEF0FC9  bl 0x827ec508
	ctx.lr = 0x828FB544;
	sub_827EC508(ctx, base);
	// 828FB544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB548: 484F7EE1  bl 0x82df3428
	ctx.lr = 0x828FB54C;
	sub_82DF3428(ctx, base);
	// 828FB54C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB554: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FB558: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FB55C: 4E800421  bctrl
	ctx.lr = 0x828FB560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB560: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FB564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB568: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FB56C: 4800DFFD  bl 0x82909568
	ctx.lr = 0x828FB570;
	sub_82909568(ctx, base);
	// 828FB570: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FB574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB578: 388B3B80  addi r4, r11, 0x3b80
	ctx.r[4].s64 = ctx.r[11].s64 + 15232;
	// 828FB57C: 48063B3D  bl 0x8295f0b8
	ctx.lr = 0x828FB580;
	sub_8295F0B8(ctx, base);
	// 828FB580: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FB584: 488ACC38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB588 size=12
    let mut pc: u32 = 0x828FB588;
    'dispatch: loop {
        match pc {
            0x828FB588 => {
    //   block [0x828FB588..0x828FB594)
	// 828FB588: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828FB58C: 386B7650  addi r3, r11, 0x7650
	ctx.r[3].s64 = ctx.r[11].s64 + 30288;
	// 828FB590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB598 size=12
    let mut pc: u32 = 0x828FB598;
    'dispatch: loop {
        match pc {
            0x828FB598 => {
    //   block [0x828FB598..0x828FB5A4)
	// 828FB598: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FB59C: 386BAD10  addi r3, r11, -0x52f0
	ctx.r[3].s64 = ctx.r[11].s64 + -21232;
	// 828FB5A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB5A8 size=12
    let mut pc: u32 = 0x828FB5A8;
    'dispatch: loop {
        match pc {
            0x828FB5A8 => {
    //   block [0x828FB5A8..0x828FB5B4)
	// 828FB5A8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828FB5AC: 386B7624  addi r3, r11, 0x7624
	ctx.r[3].s64 = ctx.r[11].s64 + 30244;
	// 828FB5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB5B8 size=12
    let mut pc: u32 = 0x828FB5B8;
    'dispatch: loop {
        match pc {
            0x828FB5B8 => {
    //   block [0x828FB5B8..0x828FB5C4)
	// 828FB5B8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FB5BC: 386BAD98  addi r3, r11, -0x5268
	ctx.r[3].s64 = ctx.r[11].s64 + -21096;
	// 828FB5C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB5C8 size=16
    let mut pc: u32 = 0x828FB5C8;
    'dispatch: loop {
        match pc {
            0x828FB5C8 => {
    //   block [0x828FB5C8..0x828FB5D8)
	// 828FB5C8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FB5CC: 396BAD98  addi r11, r11, -0x5268
	ctx.r[11].s64 = ctx.r[11].s64 + -21096;
	// 828FB5D0: 386B00A4  addi r3, r11, 0xa4
	ctx.r[3].s64 = ctx.r[11].s64 + 164;
	// 828FB5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FB5D8 size=144
    let mut pc: u32 = 0x828FB5D8;
    'dispatch: loop {
        match pc {
            0x828FB5D8 => {
    //   block [0x828FB5D8..0x828FB668)
	// 828FB5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FB5E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FB5E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB5E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB5EC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828FB5F0: 4BFC72E1  bl 0x828c28d0
	ctx.lr = 0x828FB5F4;
	sub_828C28D0(ctx, base);
	// 828FB5F4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FB5F8: 396BAD98  addi r11, r11, -0x5268
	ctx.r[11].s64 = ctx.r[11].s64 + -21096;
	// 828FB5FC: C00B00B4  lfs f0, 0xb4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FB600: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828FB604: 40980050  bge cr6, 0x828fb654
	if !ctx.cr[6].lt {
	pc = 0x828FB654; continue 'dispatch;
	}
	// 828FB608: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB60C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB610: 808B0BF0  lwz r4, 0xbf0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3056 as u32) ) } as u64;
	// 828FB614: 484F83F5  bl 0x82df3a08
	ctx.lr = 0x828FB618;
	sub_82DF3A08(ctx, base);
	// 828FB618: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828FB61C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB624: 4BEF0EE5  bl 0x827ec508
	ctx.lr = 0x828FB628;
	sub_827EC508(ctx, base);
	// 828FB628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB62C: 484F7DFD  bl 0x82df3428
	ctx.lr = 0x828FB630;
	sub_82DF3428(ctx, base);
	// 828FB630: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB638: 808BC234  lwz r4, -0x3dcc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15820 as u32) ) } as u64;
	// 828FB63C: 484F83CD  bl 0x82df3a08
	ctx.lr = 0x828FB640;
	sub_82DF3A08(ctx, base);
	// 828FB640: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB648: 4BEF16A1  bl 0x827ecce8
	ctx.lr = 0x828FB64C;
	sub_827ECCE8(ctx, base);
	// 828FB64C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB650: 484F7DD9  bl 0x82df3428
	ctx.lr = 0x828FB654;
	sub_82DF3428(ctx, base);
	// 828FB654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FB660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FB664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB668 size=12
    let mut pc: u32 = 0x828FB668;
    'dispatch: loop {
        match pc {
            0x828FB668 => {
    //   block [0x828FB668..0x828FB674)
	// 828FB668: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828FB66C: 386B75F8  addi r3, r11, 0x75f8
	ctx.r[3].s64 = ctx.r[11].s64 + 30200;
	// 828FB670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB678 size=12
    let mut pc: u32 = 0x828FB678;
    'dispatch: loop {
        match pc {
            0x828FB678 => {
    //   block [0x828FB678..0x828FB684)
	// 828FB678: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FB67C: 386BAE50  addi r3, r11, -0x51b0
	ctx.r[3].s64 = ctx.r[11].s64 + -20912;
	// 828FB680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB688 size=8
    let mut pc: u32 = 0x828FB688;
    'dispatch: loop {
        match pc {
            0x828FB688 => {
    //   block [0x828FB688..0x828FB690)
	// 828FB688: 38630430  addi r3, r3, 0x430
	ctx.r[3].s64 = ctx.r[3].s64 + 1072;
	// 828FB68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB690 size=8
    let mut pc: u32 = 0x828FB690;
    'dispatch: loop {
        match pc {
            0x828FB690 => {
    //   block [0x828FB690..0x828FB698)
	// 828FB690: 386303D0  addi r3, r3, 0x3d0
	ctx.r[3].s64 = ctx.r[3].s64 + 976;
	// 828FB694: 48561004  b 0x82e5c698
	sub_82E5C698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB698 size=116
    let mut pc: u32 = 0x828FB698;
    'dispatch: loop {
        match pc {
            0x828FB698 => {
    //   block [0x828FB698..0x828FB70C)
	// 828FB698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FB6A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FB6A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FB6A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB6AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB6B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FB6B4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828FB6B8: 409A000C  bne cr6, 0x828fb6c4
	if !ctx.cr[6].eq {
	pc = 0x828FB6C4; continue 'dispatch;
	}
	// 828FB6BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB6C0: 48000030  b 0x828fb6f0
	pc = 0x828FB6F0; continue 'dispatch;
	// 828FB6C4: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828FB6C8: 419A0024  beq cr6, 0x828fb6ec
	if ctx.cr[6].eq {
	pc = 0x828FB6EC; continue 'dispatch;
	}
	// 828FB6CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB6D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB6D4: 388BBF78  addi r4, r11, -0x4088
	ctx.r[4].s64 = ctx.r[11].s64 + -16520;
	// 828FB6D8: 488ACA21  bl 0x831a80f8
	ctx.lr = 0x828FB6DC;
	sub_831A80F8(ctx, base);
	// 828FB6DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FB6E0: 4182000C  beq 0x828fb6ec
	if ctx.cr[0].eq {
	pc = 0x828FB6EC; continue 'dispatch;
	}
	// 828FB6E4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828FB6E8: 4800000C  b 0x828fb6f4
	pc = 0x828FB6F4; continue 'dispatch;
	// 828FB6EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FB6F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FB6F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB6F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB6FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FB700: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FB704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FB708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB710 size=136
    let mut pc: u32 = 0x828FB710;
    'dispatch: loop {
        match pc {
            0x828FB710 => {
    //   block [0x828FB710..0x828FB798)
	// 828FB710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FB718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FB71C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FB720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB724: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB728: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FB72C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828FB730: 409A0020  bne cr6, 0x828fb750
	if !ctx.cr[6].eq {
	pc = 0x828FB750; continue 'dispatch;
	}
	// 828FB734: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FB738: 419A0048  beq cr6, 0x828fb780
	if ctx.cr[6].eq {
	pc = 0x828FB780; continue 'dispatch;
	}
	// 828FB73C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828FB740: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828FB744: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828FB748: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828FB74C: 48000034  b 0x828fb780
	pc = 0x828FB780; continue 'dispatch;
	// 828FB750: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828FB754: 419A002C  beq cr6, 0x828fb780
	if ctx.cr[6].eq {
	pc = 0x828FB780; continue 'dispatch;
	}
	// 828FB758: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB75C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB760: 388BBFC0  addi r4, r11, -0x4040
	ctx.r[4].s64 = ctx.r[11].s64 + -16448;
	// 828FB764: 488AC995  bl 0x831a80f8
	ctx.lr = 0x828FB768;
	sub_831A80F8(ctx, base);
	// 828FB768: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FB76C: 4182000C  beq 0x828fb778
	if ctx.cr[0].eq {
	pc = 0x828FB778; continue 'dispatch;
	}
	// 828FB770: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828FB774: 4800000C  b 0x828fb780
	pc = 0x828FB780; continue 'dispatch;
	// 828FB778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FB77C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FB780: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB784: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB788: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FB78C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FB790: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FB794: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB798 size=136
    let mut pc: u32 = 0x828FB798;
    'dispatch: loop {
        match pc {
            0x828FB798 => {
    //   block [0x828FB798..0x828FB820)
	// 828FB798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB79C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FB7A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FB7A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FB7A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB7AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB7B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FB7B4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828FB7B8: 409A0020  bne cr6, 0x828fb7d8
	if !ctx.cr[6].eq {
	pc = 0x828FB7D8; continue 'dispatch;
	}
	// 828FB7BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FB7C0: 419A0048  beq cr6, 0x828fb808
	if ctx.cr[6].eq {
	pc = 0x828FB808; continue 'dispatch;
	}
	// 828FB7C4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828FB7C8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828FB7CC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828FB7D0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828FB7D4: 48000034  b 0x828fb808
	pc = 0x828FB808; continue 'dispatch;
	// 828FB7D8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828FB7DC: 419A002C  beq cr6, 0x828fb808
	if ctx.cr[6].eq {
	pc = 0x828FB808; continue 'dispatch;
	}
	// 828FB7E0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FB7E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB7E8: 388BC088  addi r4, r11, -0x3f78
	ctx.r[4].s64 = ctx.r[11].s64 + -16248;
	// 828FB7EC: 488AC90D  bl 0x831a80f8
	ctx.lr = 0x828FB7F0;
	sub_831A80F8(ctx, base);
	// 828FB7F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FB7F4: 4182000C  beq 0x828fb800
	if ctx.cr[0].eq {
	pc = 0x828FB800; continue 'dispatch;
	}
	// 828FB7F8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828FB7FC: 4800000C  b 0x828fb808
	pc = 0x828FB808; continue 'dispatch;
	// 828FB800: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FB804: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FB808: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FB80C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB810: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FB814: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FB818: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FB81C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB820 size=88
    let mut pc: u32 = 0x828FB820;
    'dispatch: loop {
        match pc {
            0x828FB820 => {
    //   block [0x828FB820..0x828FB878)
	// 828FB820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB824: 488AC949  bl 0x831a816c
	ctx.lr = 0x828FB828;
	sub_831A8130(ctx, base);
	// 828FB828: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB82C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB830: 83DF00F4  lwz r30, 0xf4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 828FB834: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FB838: 419A0038  beq cr6, 0x828fb870
	if ctx.cr[6].eq {
	pc = 0x828FB870; continue 'dispatch;
	}
	// 828FB83C: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828FB840: 480812B9  bl 0x8297caf8
	ctx.lr = 0x828FB844;
	sub_8297CAF8(ctx, base);
	// 828FB844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB848: 83FF03A0  lwz r31, 0x3a0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828FB84C: 480041B5  bl 0x828ffa00
	ctx.lr = 0x828FB850;
	sub_828FFA00(ctx, base);
	// 828FB850: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FB858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB85C: 480042D5  bl 0x828ffb30
	ctx.lr = 0x828FB860;
	sub_828FFB30(ctx, base);
	// 828FB860: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FB864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB868: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828FB86C: 48081965  bl 0x8297d1d0
	ctx.lr = 0x828FB870;
	sub_8297D1D0(ctx, base);
	// 828FB870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FB874: 488AC948  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FB878 size=320
    let mut pc: u32 = 0x828FB878;
    'dispatch: loop {
        match pc {
            0x828FB878 => {
    //   block [0x828FB878..0x828FB9B8)
	// 828FB878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB87C: 488AC8E5  bl 0x831a8160
	ctx.lr = 0x828FB880;
	sub_831A8130(ctx, base);
	// 828FB880: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB884: 3B6303B0  addi r27, r3, 0x3b0
	ctx.r[27].s64 = ctx.r[3].s64 + 944;
	// 828FB888: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 828FB88C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FB890: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FB9B8 size=212
    let mut pc: u32 = 0x828FB9B8;
    'dispatch: loop {
        match pc {
            0x828FB9B8 => {
    //   block [0x828FB9B8..0x828FBA8C)
	// 828FB9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB9BC: 488AC7B1  bl 0x831a816c
	ctx.lr = 0x828FB9C0;
	sub_831A8130(ctx, base);
	// 828FB9C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB9C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB9C8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828FB9CC: 48063755  bl 0x8295f120
	ctx.lr = 0x828FB9D0;
	sub_8295F120(ctx, base);
	// 828FB9D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB9D4: 4BEF078D  bl 0x827ec160
	ctx.lr = 0x828FB9D8;
	sub_827EC160(ctx, base);
	// 828FB9D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB9DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB9E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FB9E4: 4E800421  bctrl
	ctx.lr = 0x828FB9E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB9E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FB9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB9F0: 481C65A1  bl 0x82ac1f90
	ctx.lr = 0x828FB9F4;
	sub_82AC1F90(ctx, base);
	// 828FB9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB9F8: 4BEF0769  bl 0x827ec160
	ctx.lr = 0x828FB9FC;
	sub_827EC160(ctx, base);
	// 828FB9FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBA00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FBA04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FBA08: 4E800421  bctrl
	ctx.lr = 0x828FBA0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBA0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FBA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBA14: 481AFAC5  bl 0x82aab4d8
	ctx.lr = 0x828FBA18;
	sub_82AAB4D8(ctx, base);
	// 828FBA18: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FBA1C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FBA20: 3BCBAC40  addi r30, r11, -0x53c0
	ctx.r[30].s64 = ctx.r[11].s64 + -21440;
	// 828FBA24: 816AAC80  lwz r11, -0x5380(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21376 as u32) ) } as u64;
	// 828FBA28: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBA2C: 40820038  bne 0x828fba64
	if !ctx.cr[0].eq {
	pc = 0x828FBA64; continue 'dispatch;
	}
	// 828FBA30: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FBA34: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 828FBA38: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828FBA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBA40: 916AAC80  stw r11, -0x5380(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21376 as u32), ctx.r[11].u32 ) };
	// 828FBA44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FBA48: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FBA4C: C1A80590  lfs f13, 0x590(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FBA50: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828FBA54: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828FBA58: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828FBA5C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828FBA60: 48580579  bl 0x82e7bfd8
	ctx.lr = 0x828FBA64;
	sub_82E7BFD8(ctx, base);
	// 828FBA64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FBA68: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 828FBA6C: 485177F5  bl 0x82e13260
	ctx.lr = 0x828FBA70;
	sub_82E13260(ctx, base);
	// 828FBA70: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828FBA74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FBA78: 419A000C  beq cr6, 0x828fba84
	if ctx.cr[6].eq {
	pc = 0x828FBA84; continue 'dispatch;
	}
	// 828FBA7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FBA80: 48026EF9  bl 0x82922978
	ctx.lr = 0x828FBA84;
	sub_82922978(ctx, base);
	// 828FBA84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FBA88: 488AC734  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FBA90 size=152
    let mut pc: u32 = 0x828FBA90;
    'dispatch: loop {
        match pc {
            0x828FBA90 => {
    //   block [0x828FBA90..0x828FBB28)
	// 828FBA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBA98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBA9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBAA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FBAA4: 807F0380  lwz r3, 0x380(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(896 as u32) ) } as u64;
	// 828FBAA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FBAAC: 419A0028  beq cr6, 0x828fbad4
	if ctx.cr[6].eq {
	pc = 0x828FBAD4; continue 'dispatch;
	}
	// 828FBAB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBAB4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FBAB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FBABC: 4E800421  bctrl
	ctx.lr = 0x828FBAC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBAC0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828FBAC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FBAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBACC: C02B7BC4  lfs f1, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FBAD0: 48063549  bl 0x8295f018
	ctx.lr = 0x828FBAD4;
	sub_8295F018(ctx, base);
	// 828FBAD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBAD8: 48014871  bl 0x82910348
	ctx.lr = 0x828FBADC;
	sub_82910348(ctx, base);
	// 828FBADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBAE0: 480148B1  bl 0x82910390
	ctx.lr = 0x828FBAE4;
	sub_82910390(ctx, base);
	// 828FBAE4: 897F03B0  lbz r11, 0x3b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 828FBAE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FBAEC: 41820010  beq 0x828fbafc
	if ctx.cr[0].eq {
	pc = 0x828FBAFC; continue 'dispatch;
	}
	// 828FBAF0: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 828FBAF4: 4BFFF9A5  bl 0x828fb498
	ctx.lr = 0x828FBAF8;
	sub_828FB498(ctx, base);
	// 828FBAF8: 4800001C  b 0x828fbb14
	pc = 0x828FBB14; continue 'dispatch;
	// 828FBAFC: 397FFFF0  addi r11, r31, -0x10
	ctx.r[11].s64 = ctx.r[31].s64 + -16;
	// 828FBB00: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 828FBB04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBB08: 4800D221  bl 0x82908d28
	ctx.lr = 0x828FBB0C;
	sub_82908D28(ctx, base);
	// 828FBB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBB10: 4BC14AC1  bl 0x825105d0
	ctx.lr = 0x828FBB14;
	sub_825105D0(ctx, base);
	// 828FBB14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FBB18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBB1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBB20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBB24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FBB28 size=304
    let mut pc: u32 = 0x828FBB28;
    'dispatch: loop {
        match pc {
            0x828FBB28 => {
    //   block [0x828FBB28..0x828FBC58)
	// 828FBB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBB2C: 488AC641  bl 0x831a816c
	ctx.lr = 0x828FBB30;
	sub_831A8130(ctx, base);
	// 828FBB30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBB34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FBB38: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828FBB3C: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 828FBB40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FBB44: 38CB5DCC  addi r6, r11, 0x5dcc
	ctx.r[6].s64 = ctx.r[11].s64 + 24012;
	// 828FBB48: 38AAC8DC  addi r5, r10, -0x3724
	ctx.r[5].s64 = ctx.r[10].s64 + -14116;
	// 828FBB4C: 807D00F4  lwz r3, 0xf4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 828FBB50: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828FBB54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FBB58: 488AE3F1  bl 0x831a9f48
	ctx.lr = 0x828FBB5C;
	sub_831A9F48(ctx, base);
	// 828FBB5C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FBB60: 4182002C  beq 0x828fbb8c
	if ctx.cr[0].eq {
	pc = 0x828FBB8C; continue 'dispatch;
	}
	// 828FBB64: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828FBB68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBB6C: 4801B4C5  bl 0x82917030
	ctx.lr = 0x828FBB70;
	sub_82917030(ctx, base);
	// 828FBB70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FBB74: 40820018  bne 0x828fbb8c
	if !ctx.cr[0].eq {
	pc = 0x828FBB8C; continue 'dispatch;
	}
	// 828FBB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBB7C: 4801AF85  bl 0x82916b00
	ctx.lr = 0x828FBB80;
	sub_82916B00(ctx, base);
	// 828FBB80: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FBB84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FBB88: 41820008  beq 0x828fbb90
	if ctx.cr[0].eq {
	pc = 0x828FBB90; continue 'dispatch;
	}
	// 828FBB8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FBB90: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 828FBB94: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828FBB98: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828FBB9C: 807D0390  lwz r3, 0x390(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(912 as u32) ) } as u64;
	// 828FBBA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FBBA4: 419A0068  beq cr6, 0x828fbc0c
	if ctx.cr[6].eq {
	pc = 0x828FBC0C; continue 'dispatch;
	}
	// 828FBBA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBBAC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FBBB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FBBB4: 4E800421  bctrl
	ctx.lr = 0x828FBBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBBB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FBBBC: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FBBC0: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 828FBBC4: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FBBC8: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FBBCC: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FBBD0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828FBBD4: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828FBBD8: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828FBBDC: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828FBBE0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FBC58 size=144
    let mut pc: u32 = 0x828FBC58;
    'dispatch: loop {
        match pc {
            0x828FBC58 => {
    //   block [0x828FBC58..0x828FBCE8)
	// 828FBC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBC60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBC64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBC68: 81630390  lwz r11, 0x390(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(912 as u32) ) } as u64;
	// 828FBC6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FBC70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FBC74: 419A004C  beq cr6, 0x828fbcc0
	if ctx.cr[6].eq {
	pc = 0x828FBCC0; continue 'dispatch;
	}
	// 828FBC78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBC7C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FBC80: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FBC84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FBC88: 4E800421  bctrl
	ctx.lr = 0x828FBC8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBC8C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FBC90: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 828FBC94: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FBC98: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FBC9C: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FBCA0: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FBCA4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828FBCA8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828FBCAC: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828FBCB0: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828FBCB4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBCE8 size=72
    let mut pc: u32 = 0x828FBCE8;
    'dispatch: loop {
        match pc {
            0x828FBCE8 => {
    //   block [0x828FBCE8..0x828FBD30)
	// 828FBCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBCEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBCF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FBCF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBCF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBCFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FBD00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FBD04: 387F03C0  addi r3, r31, 0x3c0
	ctx.r[3].s64 = ctx.r[31].s64 + 960;
	// 828FBD08: 48561171  bl 0x82e5ce78
	ctx.lr = 0x828FBD0C;
	sub_82E5CE78(ctx, base);
	// 828FBD0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FBD10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBD14: 4BFFFCA5  bl 0x828fb9b8
	ctx.lr = 0x828FBD18;
	sub_828FB9B8(ctx, base);
	// 828FBD18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FBD1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBD20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBD24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FBD28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBD2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBD30 size=76
    let mut pc: u32 = 0x828FBD30;
    'dispatch: loop {
        match pc {
            0x828FBD30 => {
    //   block [0x828FBD30..0x828FBD7C)
	// 828FBD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBD34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBD38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBD3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBD40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FBD44: 807F0438  lwz r3, 0x438(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) } as u64;
	// 828FBD48: 4BECEA51  bl 0x827ca798
	ctx.lr = 0x828FBD4C;
	sub_827CA798(ctx, base);
	// 828FBD4C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828FBD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBD54: 4BEF052D  bl 0x827ec280
	ctx.lr = 0x828FBD58;
	sub_827EC280(ctx, base);
	// 828FBD58: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828FBD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBD60: 388B2AD4  addi r4, r11, 0x2ad4
	ctx.r[4].s64 = ctx.r[11].s64 + 10964;
	// 828FBD64: 48063355  bl 0x8295f0b8
	ctx.lr = 0x828FBD68;
	sub_8295F0B8(ctx, base);
	// 828FBD68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FBD6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBD70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBD74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBD78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBD80 size=80
    let mut pc: u32 = 0x828FBD80;
    'dispatch: loop {
        match pc {
            0x828FBD80 => {
    //   block [0x828FBD80..0x828FBDD0)
	// 828FBD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBD88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBD8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBD90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FBD94: 807F0438  lwz r3, 0x438(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) } as u64;
	// 828FBD98: 4BECEAA1  bl 0x827ca838
	ctx.lr = 0x828FBD9C;
	sub_827CA838(ctx, base);
	// 828FBD9C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828FBDA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FBDA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBDA8: 4BEF04C9  bl 0x827ec270
	ctx.lr = 0x828FBDAC;
	sub_827EC270(ctx, base);
	// 828FBDAC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FBDB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBDB4: 388B3B80  addi r4, r11, 0x3b80
	ctx.r[4].s64 = ctx.r[11].s64 + 15232;
	// 828FBDB8: 48063301  bl 0x8295f0b8
	ctx.lr = 0x828FBDBC;
	sub_8295F0B8(ctx, base);
	// 828FBDBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FBDC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBDC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBDC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBDCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBDD0 size=196
    let mut pc: u32 = 0x828FBDD0;
    'dispatch: loop {
        match pc {
            0x828FBDD0 => {
    //   block [0x828FBDD0..0x828FBE94)
	// 828FBDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBDD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FBDDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBDE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBDE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FBDE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FBDEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FBDF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FBDF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FBDF8: 4B9C4B41  bl 0x822c0938
	ctx.lr = 0x828FBDFC;
	sub_822C0938(ctx, base);
	// 828FBDFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FBE00: 41820028  beq 0x828fbe28
	if ctx.cr[0].eq {
	pc = 0x828FBE28; continue 'dispatch;
	}
	// 828FBE04: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FBE08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FBE0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FBE10: 392B3BA4  addi r9, r11, 0x3ba4
	ctx.r[9].s64 = ctx.r[11].s64 + 15268;
	// 828FBE14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FBE18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FBE1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FBE20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FBE24: 48000008  b 0x828fbe2c
	pc = 0x828FBE2C; continue 'dispatch;
	// 828FBE28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FBE2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FBE30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FBE34: 409A0044  bne cr6, 0x828fbe78
	if !ctx.cr[6].eq {
	pc = 0x828FBE78; continue 'dispatch;
	}
	// 828FBE38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FBE3C: 419A001C  beq cr6, 0x828fbe58
	if ctx.cr[6].eq {
	pc = 0x828FBE58; continue 'dispatch;
	}
	// 828FBE40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBE44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FBE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBE4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FBE54: 4E800421  bctrl
	ctx.lr = 0x828FBE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBE58: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FBE5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FBE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBE64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FBE68: 816BBCC0  lwz r11, -0x4340(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) } as u64;
	// 828FBE6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FBE70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FBE74: 4B9C418D  bl 0x822c0000
	ctx.lr = 0x828FBE78;
	sub_822C0000(ctx, base);
	// 828FBE78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBE7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FBE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBE88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FBE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBE98 size=196
    let mut pc: u32 = 0x828FBE98;
    'dispatch: loop {
        match pc {
            0x828FBE98 => {
    //   block [0x828FBE98..0x828FBF5C)
	// 828FBE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBEA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FBEA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBEA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBEAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FBEB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FBEB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FBEB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FBEBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FBEC0: 4B9C4A79  bl 0x822c0938
	ctx.lr = 0x828FBEC4;
	sub_822C0938(ctx, base);
	// 828FBEC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FBEC8: 41820028  beq 0x828fbef0
	if ctx.cr[0].eq {
	pc = 0x828FBEF0; continue 'dispatch;
	}
	// 828FBECC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FBED0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FBED4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FBED8: 392B3BB8  addi r9, r11, 0x3bb8
	ctx.r[9].s64 = ctx.r[11].s64 + 15288;
	// 828FBEDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FBEE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FBEE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FBEE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FBEEC: 48000008  b 0x828fbef4
	pc = 0x828FBEF4; continue 'dispatch;
	// 828FBEF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FBEF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FBEF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FBEFC: 409A0044  bne cr6, 0x828fbf40
	if !ctx.cr[6].eq {
	pc = 0x828FBF40; continue 'dispatch;
	}
	// 828FBF00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FBF04: 419A001C  beq cr6, 0x828fbf20
	if ctx.cr[6].eq {
	pc = 0x828FBF20; continue 'dispatch;
	}
	// 828FBF08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBF0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FBF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBF14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBF18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FBF1C: 4E800421  bctrl
	ctx.lr = 0x828FBF20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBF20: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FBF24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FBF28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBF2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FBF30: 816BBCC0  lwz r11, -0x4340(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) } as u64;
	// 828FBF34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FBF38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FBF3C: 4B9C40C5  bl 0x822c0000
	ctx.lr = 0x828FBF40;
	sub_822C0000(ctx, base);
	// 828FBF40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBF44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FBF48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBF4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBF50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FBF54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBF58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBF60 size=196
    let mut pc: u32 = 0x828FBF60;
    'dispatch: loop {
        match pc {
            0x828FBF60 => {
    //   block [0x828FBF60..0x828FC024)
	// 828FBF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBF64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBF68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FBF6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBF70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBF74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FBF78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FBF7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FBF80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FBF84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FBF88: 4B9C49B1  bl 0x822c0938
	ctx.lr = 0x828FBF8C;
	sub_822C0938(ctx, base);
	// 828FBF8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FBF90: 41820028  beq 0x828fbfb8
	if ctx.cr[0].eq {
	pc = 0x828FBFB8; continue 'dispatch;
	}
	// 828FBF94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FBF98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FBF9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FBFA0: 392B3BCC  addi r9, r11, 0x3bcc
	ctx.r[9].s64 = ctx.r[11].s64 + 15308;
	// 828FBFA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FBFA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FBFAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FBFB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FBFB4: 48000008  b 0x828fbfbc
	pc = 0x828FBFBC; continue 'dispatch;
	// 828FBFB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FBFBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FBFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FBFC4: 409A0044  bne cr6, 0x828fc008
	if !ctx.cr[6].eq {
	pc = 0x828FC008; continue 'dispatch;
	}
	// 828FBFC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FBFCC: 419A001C  beq cr6, 0x828fbfe8
	if ctx.cr[6].eq {
	pc = 0x828FBFE8; continue 'dispatch;
	}
	// 828FBFD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBFD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FBFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBFDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBFE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FBFE4: 4E800421  bctrl
	ctx.lr = 0x828FBFE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBFE8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FBFEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FBFF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBFF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FBFF8: 816BBCC0  lwz r11, -0x4340(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) } as u64;
	// 828FBFFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FC000: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FC004: 4B9C3FFD  bl 0x822c0000
	ctx.lr = 0x828FC008;
	sub_822C0000(ctx, base);
	// 828FC008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FC00C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FC010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC018: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FC01C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC028 size=196
    let mut pc: u32 = 0x828FC028;
    'dispatch: loop {
        match pc {
            0x828FC028 => {
    //   block [0x828FC028..0x828FC0EC)
	// 828FC028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FC034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC038: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC03C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FC040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FC044: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FC048: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FC04C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC050: 4B9C48E9  bl 0x822c0938
	ctx.lr = 0x828FC054;
	sub_822C0938(ctx, base);
	// 828FC054: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FC058: 41820028  beq 0x828fc080
	if ctx.cr[0].eq {
	pc = 0x828FC080; continue 'dispatch;
	}
	// 828FC05C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC060: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FC064: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FC068: 392B3BE0  addi r9, r11, 0x3be0
	ctx.r[9].s64 = ctx.r[11].s64 + 15328;
	// 828FC06C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FC070: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FC074: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FC078: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FC07C: 48000008  b 0x828fc084
	pc = 0x828FC084; continue 'dispatch;
	// 828FC080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FC084: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC08C: 409A0044  bne cr6, 0x828fc0d0
	if !ctx.cr[6].eq {
	pc = 0x828FC0D0; continue 'dispatch;
	}
	// 828FC090: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FC094: 419A001C  beq cr6, 0x828fc0b0
	if ctx.cr[6].eq {
	pc = 0x828FC0B0; continue 'dispatch;
	}
	// 828FC098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC09C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FC0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC0A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC0A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC0AC: 4E800421  bctrl
	ctx.lr = 0x828FC0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC0B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FC0B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FC0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC0BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FC0C0: 816BBCC0  lwz r11, -0x4340(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) } as u64;
	// 828FC0C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FC0C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FC0CC: 4B9C3F35  bl 0x822c0000
	ctx.lr = 0x828FC0D0;
	sub_822C0000(ctx, base);
	// 828FC0D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FC0D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FC0D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC0DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC0E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FC0E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC0F0 size=172
    let mut pc: u32 = 0x828FC0F0;
    'dispatch: loop {
        match pc {
            0x828FC0F0 => {
    //   block [0x828FC0F0..0x828FC19C)
	// 828FC0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC0F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC0F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FC0FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC100: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC104: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FC108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FC10C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FC110: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FC114: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC118: 4B9C4821  bl 0x822c0938
	ctx.lr = 0x828FC11C;
	sub_822C0938(ctx, base);
	// 828FC11C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FC120: 41820028  beq 0x828fc148
	if ctx.cr[0].eq {
	pc = 0x828FC148; continue 'dispatch;
	}
	// 828FC124: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC128: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FC12C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FC130: 392B3BF4  addi r9, r11, 0x3bf4
	ctx.r[9].s64 = ctx.r[11].s64 + 15348;
	// 828FC134: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FC138: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FC13C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FC140: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FC144: 48000008  b 0x828fc14c
	pc = 0x828FC14C; continue 'dispatch;
	// 828FC148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FC14C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC154: 409A002C  bne cr6, 0x828fc180
	if !ctx.cr[6].eq {
	pc = 0x828FC180; continue 'dispatch;
	}
	// 828FC158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC15C: 4B9C410D  bl 0x822c0268
	ctx.lr = 0x828FC160;
	sub_822C0268(ctx, base);
	// 828FC160: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FC164: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FC168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC16C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FC170: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FC174: 816BBCC0  lwz r11, -0x4340(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) } as u64;
	// 828FC178: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FC17C: 4B9C3E85  bl 0x822c0000
	ctx.lr = 0x828FC180;
	sub_822C0000(ctx, base);
	// 828FC180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FC184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FC188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FC194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC1A0 size=196
    let mut pc: u32 = 0x828FC1A0;
    'dispatch: loop {
        match pc {
            0x828FC1A0 => {
    //   block [0x828FC1A0..0x828FC264)
	// 828FC1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC1A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC1A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FC1AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC1B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC1B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FC1B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FC1BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FC1C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FC1C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC1C8: 4B9C4771  bl 0x822c0938
	ctx.lr = 0x828FC1CC;
	sub_822C0938(ctx, base);
	// 828FC1CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FC1D0: 41820028  beq 0x828fc1f8
	if ctx.cr[0].eq {
	pc = 0x828FC1F8; continue 'dispatch;
	}
	// 828FC1D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC1D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828FC1DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FC1E0: 392B3C08  addi r9, r11, 0x3c08
	ctx.r[9].s64 = ctx.r[11].s64 + 15368;
	// 828FC1E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FC1E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FC1EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FC1F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FC1F4: 48000008  b 0x828fc1fc
	pc = 0x828FC1FC; continue 'dispatch;
	// 828FC1F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FC1FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC204: 409A0044  bne cr6, 0x828fc248
	if !ctx.cr[6].eq {
	pc = 0x828FC248; continue 'dispatch;
	}
	// 828FC208: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FC20C: 419A001C  beq cr6, 0x828fc228
	if ctx.cr[6].eq {
	pc = 0x828FC228; continue 'dispatch;
	}
	// 828FC210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC214: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FC218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC21C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC224: 4E800421  bctrl
	ctx.lr = 0x828FC228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC228: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FC22C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FC230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC234: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828FC238: 816BBCC0  lwz r11, -0x4340(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) } as u64;
	// 828FC23C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FC240: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FC244: 4B9C3DBD  bl 0x822c0000
	ctx.lr = 0x828FC248;
	sub_822C0000(ctx, base);
	// 828FC248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FC24C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FC250: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC254: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC258: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FC25C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC268 size=72
    let mut pc: u32 = 0x828FC268;
    'dispatch: loop {
        match pc {
            0x828FC268 => {
    //   block [0x828FC268..0x828FC2B0)
	// 828FC268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC270: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC274: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828FC278: 419A001C  beq cr6, 0x828fc294
	if ctx.cr[6].eq {
	pc = 0x828FC294; continue 'dispatch;
	}
	// 828FC27C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FC280: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828FC284: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828FC288: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FC28C: 4BFFF40D  bl 0x828fb698
	ctx.lr = 0x828FC290;
	sub_828FB698(ctx, base);
	// 828FC290: 48000010  b 0x828fc2a0
	pc = 0x828FC2A0; continue 'dispatch;
	// 828FC294: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FC298: 396BBF78  addi r11, r11, -0x4088
	ctx.r[11].s64 = ctx.r[11].s64 + -16520;
	// 828FC29C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC2A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FC2A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC2A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC2B0 size=12
    let mut pc: u32 = 0x828FC2B0;
    'dispatch: loop {
        match pc {
            0x828FC2B0 => {
    //   block [0x828FC2B0..0x828FC2BC)
	// 828FC2B0: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FC2B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FC2B8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC2BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC2BC size=8
    let mut pc: u32 = 0x828FC2BC;
    'dispatch: loop {
        match pc {
            0x828FC2BC => {
    //   block [0x828FC2BC..0x828FC2C4)
	// 828FC2BC: 4BFFF5BC  b 0x828fb878
	sub_828FB878(ctx, base);
	return;
	// 828FC2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC2C8 size=376
    let mut pc: u32 = 0x828FC2C8;
    'dispatch: loop {
        match pc {
            0x828FC2C8 => {
    //   block [0x828FC2C8..0x828FC440)
	// 828FC2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC2D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC2D4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC2D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC2DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC2E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC2E4: 388B3C68  addi r4, r11, 0x3c68
	ctx.r[4].s64 = ctx.r[11].s64 + 15464;
	// 828FC2E8: 484F7721  bl 0x82df3a08
	ctx.lr = 0x828FC2EC;
	sub_82DF3A08(ctx, base);
	// 828FC2EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC2F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC2F4: 388B3C5C  addi r4, r11, 0x3c5c
	ctx.r[4].s64 = ctx.r[11].s64 + 15452;
	// 828FC2F8: 484F7711  bl 0x82df3a08
	ctx.lr = 0x828FC2FC;
	sub_82DF3A08(ctx, base);
	// 828FC2FC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC300: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 828FC304: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FC308: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FC30C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC310: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FC314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC318: 4E800421  bctrl
	ctx.lr = 0x828FC31C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC320: 484F7109  bl 0x82df3428
	ctx.lr = 0x828FC324;
	sub_82DF3428(ctx, base);
	// 828FC324: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC328: 484F7101  bl 0x82df3428
	ctx.lr = 0x828FC32C;
	sub_82DF3428(ctx, base);
	// 828FC32C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FC330: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FC334: 386BAD10  addi r3, r11, -0x52f0
	ctx.r[3].s64 = ctx.r[11].s64 + -21232;
	// 828FC338: 48003B61  bl 0x828ffe98
	ctx.lr = 0x828FC33C;
	sub_828FFE98(ctx, base);
	// 828FC33C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FC340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FC344: 419A0008  beq cr6, 0x828fc34c
	if ctx.cr[6].eq {
	pc = 0x828FC34C; continue 'dispatch;
	}
	// 828FC348: 4B9C4549  bl 0x822c0890
	ctx.lr = 0x828FC34C;
	sub_822C0890(ctx, base);
	// 828FC34C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC354: 388B3C48  addi r4, r11, 0x3c48
	ctx.r[4].s64 = ctx.r[11].s64 + 15432;
	// 828FC358: 484F76B1  bl 0x82df3a08
	ctx.lr = 0x828FC35C;
	sub_82DF3A08(ctx, base);
	// 828FC35C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC360: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC364: 388B3C3C  addi r4, r11, 0x3c3c
	ctx.r[4].s64 = ctx.r[11].s64 + 15420;
	// 828FC368: 484F76A1  bl 0x82df3a08
	ctx.lr = 0x828FC36C;
	sub_82DF3A08(ctx, base);
	// 828FC36C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC370: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828FC374: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828FC378: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FC37C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC380: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FC384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC388: 4E800421  bctrl
	ctx.lr = 0x828FC38C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC38C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC390: 484F7099  bl 0x82df3428
	ctx.lr = 0x828FC394;
	sub_82DF3428(ctx, base);
	// 828FC394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC398: 484F7091  bl 0x82df3428
	ctx.lr = 0x828FC39C;
	sub_82DF3428(ctx, base);
	// 828FC39C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FC3A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FC3A4: 386BAD98  addi r3, r11, -0x5268
	ctx.r[3].s64 = ctx.r[11].s64 + -21096;
	// 828FC3A8: 48003AF9  bl 0x828ffea0
	ctx.lr = 0x828FC3AC;
	sub_828FFEA0(ctx, base);
	// 828FC3AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FC3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FC3B4: 419A0008  beq cr6, 0x828fc3bc
	if ctx.cr[6].eq {
	pc = 0x828FC3BC; continue 'dispatch;
	}
	// 828FC3B8: 4B9C44D9  bl 0x822c0890
	ctx.lr = 0x828FC3BC;
	sub_822C0890(ctx, base);
	// 828FC3BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC3C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC3C4: 388B3C28  addi r4, r11, 0x3c28
	ctx.r[4].s64 = ctx.r[11].s64 + 15400;
	// 828FC3C8: 484F7641  bl 0x82df3a08
	ctx.lr = 0x828FC3CC;
	sub_82DF3A08(ctx, base);
	// 828FC3CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC3D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC3D4: 388B3C18  addi r4, r11, 0x3c18
	ctx.r[4].s64 = ctx.r[11].s64 + 15384;
	// 828FC3D8: 484F7631  bl 0x82df3a08
	ctx.lr = 0x828FC3DC;
	sub_82DF3A08(ctx, base);
	// 828FC3DC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC3E0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828FC3E4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828FC3E8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828FC3EC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC3F0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FC3F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC3F8: 4E800421  bctrl
	ctx.lr = 0x828FC3FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC3FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC400: 484F7029  bl 0x82df3428
	ctx.lr = 0x828FC404;
	sub_82DF3428(ctx, base);
	// 828FC404: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC408: 484F7021  bl 0x82df3428
	ctx.lr = 0x828FC40C;
	sub_82DF3428(ctx, base);
	// 828FC40C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FC410: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828FC414: 386BAE50  addi r3, r11, -0x51b0
	ctx.r[3].s64 = ctx.r[11].s64 + -20912;
	// 828FC418: 48003CD1  bl 0x829000e8
	ctx.lr = 0x828FC41C;
	sub_829000E8(ctx, base);
	// 828FC41C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828FC420: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FC424: 419A0008  beq cr6, 0x828fc42c
	if ctx.cr[6].eq {
	pc = 0x828FC42C; continue 'dispatch;
	}
	// 828FC428: 4B9C4469  bl 0x822c0890
	ctx.lr = 0x828FC42C;
	sub_822C0890(ctx, base);
	// 828FC42C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FC430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC438: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC43C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC440 size=180
    let mut pc: u32 = 0x828FC440;
    'dispatch: loop {
        match pc {
            0x828FC440 => {
    //   block [0x828FC440..0x828FC4F4)
	// 828FC440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC448: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FC44C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC450: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC458: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FC45C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FC460: 396B3E5C  addi r11, r11, 0x3e5c
	ctx.r[11].s64 = ctx.r[11].s64 + 15964;
	// 828FC464: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FC468: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FC46C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FC470: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828FC474: 394A3CB4  addi r10, r10, 0x3cb4
	ctx.r[10].s64 = ctx.r[10].s64 + 15540;
	// 828FC478: 39293C9C  addi r9, r9, 0x3c9c
	ctx.r[9].s64 = ctx.r[9].s64 + 15516;
	// 828FC47C: 39683C80  addi r11, r8, 0x3c80
	ctx.r[11].s64 = ctx.r[8].s64 + 15488;
	// 828FC480: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FC484: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828FC488: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FC48C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FC490: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828FC494: 419A0018  beq cr6, 0x828fc4ac
	if ctx.cr[6].eq {
	pc = 0x828FC4AC; continue 'dispatch;
	}
	// 828FC498: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC49C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FC4A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC4A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC4A8: 4E800421  bctrl
	ctx.lr = 0x828FC4AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC4AC: 807F039C  lwz r3, 0x39c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 828FC4B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FC4B4: 419A0008  beq cr6, 0x828fc4bc
	if ctx.cr[6].eq {
	pc = 0x828FC4BC; continue 'dispatch;
	}
	// 828FC4B8: 4B9C43D9  bl 0x822c0890
	ctx.lr = 0x828FC4BC;
	sub_822C0890(ctx, base);
	// 828FC4BC: 807F0394  lwz r3, 0x394(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828FC4C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FC4C4: 419A0008  beq cr6, 0x828fc4cc
	if ctx.cr[6].eq {
	pc = 0x828FC4CC; continue 'dispatch;
	}
	// 828FC4C8: 4B9C43C9  bl 0x822c0890
	ctx.lr = 0x828FC4CC;
	sub_822C0890(ctx, base);
	// 828FC4CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FC4D0: 48062DC9  bl 0x8295f298
	ctx.lr = 0x828FC4D4;
	sub_8295F298(ctx, base);
	// 828FC4D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC4D8: 4BEAB181  bl 0x827a7658
	ctx.lr = 0x828FC4DC;
	sub_827A7658(ctx, base);
	// 828FC4DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FC4E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC4E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC4E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FC4EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC4F8 size=8
    let mut pc: u32 = 0x828FC4F8;
    'dispatch: loop {
        match pc {
            0x828FC4F8 => {
    //   block [0x828FC4F8..0x828FC500)
	// 828FC4F8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FC4FC: 480007DC  b 0x828fccd8
	sub_828FCCD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC500 size=8
    let mut pc: u32 = 0x828FC500;
    'dispatch: loop {
        match pc {
            0x828FC500 => {
    //   block [0x828FC500..0x828FC508)
	// 828FC500: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828FC504: 480007D4  b 0x828fccd8
	sub_828FCCD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC508 size=8
    let mut pc: u32 = 0x828FC508;
    'dispatch: loop {
        match pc {
            0x828FC508 => {
    //   block [0x828FC508..0x828FC510)
	// 828FC508: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828FC50C: 480007CC  b 0x828fccd8
	sub_828FCCD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FC510 size=360
    let mut pc: u32 = 0x828FC510;
    'dispatch: loop {
        match pc {
            0x828FC510 => {
    //   block [0x828FC510..0x828FC678)
	// 828FC510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC514: 488ABC59  bl 0x831a816c
	ctx.lr = 0x828FC518;
	sub_831A8130(ctx, base);
	// 828FC518: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828FC51C: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC520: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FC524: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FC528: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FC52C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828FC530: 3BCBACA0  addi r30, r11, -0x5360
	ctx.r[30].s64 = ctx.r[11].s64 + -21344;
	// 828FC534: 816AACB0  lwz r11, -0x5350(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21328 as u32) ) } as u64;
	// 828FC538: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FC53C: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FC540: 556707FF  clrlwi. r7, r11, 0x1f
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828FC544: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FC548: 4082001C  bne 0x828fc564
	if !ctx.cr[0].eq {
	pc = 0x828FC564; continue 'dispatch;
	}
	// 828FC54C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828FC550: D3FE0000  stfs f31, 0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FC554: D3FE0004  stfs f31, 4(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828FC558: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828FC55C: 916AACB0  stw r11, -0x5350(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21328 as u32), ctx.r[11].u32 ) };
	// 828FC560: D3FE000C  stfs f31, 0xc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828FC564: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 828FC568: 556807BD  rlwinm. r8, r11, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 828FC56C: 3BE9AC90  addi r31, r9, -0x5370
	ctx.r[31].s64 = ctx.r[9].s64 + -21360;
	// 828FC570: 4082001C  bne 0x828fc58c
	if !ctx.cr[0].eq {
	pc = 0x828FC58C; continue 'dispatch;
	}
	// 828FC574: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 828FC578: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FC57C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828FC580: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828FC584: 916AACB0  stw r11, -0x5350(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21328 as u32), ctx.r[11].u32 ) };
	// 828FC588: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828FC58C: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 828FC590: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FC594: 4BC12F85  bl 0x8250f518
	ctx.lr = 0x828FC598;
	sub_8250F518(ctx, base);
	// 828FC598: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC5A0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828FC5A4: 409A0008  bne cr6, 0x828fc5ac
	if !ctx.cr[6].eq {
	pc = 0x828FC5AC; continue 'dispatch;
	}
	// 828FC5A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FC5AC: 4BC2BF85  bl 0x82528530
	ctx.lr = 0x828FC5B0;
	sub_82528530(ctx, base);
	// 828FC5B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FC5B4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828FC5B8: 4857F4B1  bl 0x82e7ba68
	ctx.lr = 0x828FC5BC;
	sub_82E7BA68(ctx, base);
	// 828FC5BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FC5C0: 484F56D1  bl 0x82df1c90
	ctx.lr = 0x828FC5C4;
	sub_82DF1C90(ctx, base);
	// 828FC5C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FC5C8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 828FC5CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828FC5D0: 4857F779  bl 0x82e7bd48
	ctx.lr = 0x828FC5D4;
	sub_82E7BD48(ctx, base);
	// 828FC5D4: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FC5D8: C1A10098  lfs f13, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FC5DC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828FC5E0: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828FC5E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FC5E8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828FC5EC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828FC5F0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828FC5F4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828FC5F8: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828FC5FC: 48580A65  bl 0x82e7d060
	ctx.lr = 0x828FC600;
	sub_82E7D060(ctx, base);
	// 828FC600: C00100E0  lfs f0, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FC604: C1A100E4  lfs f13, 0xe4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FC608: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828FC60C: C18100E8  lfs f12, 0xe8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FC610: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828FC614: C16100EC  lfs f11, 0xec(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FC618: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828FC61C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828FC620: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828FC624: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828FC628: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828FC62C: 4BA0B14D  bl 0x82307778
	ctx.lr = 0x828FC630;
	sub_82307778(ctx, base);
	// 828FC630: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FC634: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828FC638: D3E1005C  stfs f31, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828FC63C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 828FC640: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FC644: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 828FC648: C00B959C  lfs f0, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FC64C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FC650: C1AA2784  lfs f13, 0x2784(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FC654: C189CFA8  lfs f12, -0x3058(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12376 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FC658: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828FC65C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828FC660: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828FC664: 4857F665  bl 0x82e7bcc8
	ctx.lr = 0x828FC668;
	sub_82E7BCC8(ctx, base);
	// 828FC668: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FC66C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 828FC670: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828FC674: 488ABB48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FC678 size=164
    let mut pc: u32 = 0x828FC678;
    'dispatch: loop {
        match pc {
            0x828FC678 => {
    //   block [0x828FC678..0x828FC71C)
	// 828FC678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC67C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC680: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FC684: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC688: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC68C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FC690: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828FC694: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828FC698: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828FC69C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828FC6A0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828FC6A4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828FC6A8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828FC6AC: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC6B0: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 828FC6B4: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC6B8: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC6BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC6C0: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC6C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FC720 size=184
    let mut pc: u32 = 0x828FC720;
    'dispatch: loop {
        match pc {
            0x828FC720 => {
    //   block [0x828FC720..0x828FC7D8)
	// 828FC720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC724: 488ABA49  bl 0x831a816c
	ctx.lr = 0x828FC728;
	sub_831A8130(ctx, base);
	// 828FC728: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC72C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FC730: 4BEEFAB9  bl 0x827ec1e8
	ctx.lr = 0x828FC734;
	sub_827EC1E8(ctx, base);
	// 828FC734: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828FC738: 41820098  beq 0x828fc7d0
	if ctx.cr[0].eq {
	pc = 0x828FC7D0; continue 'dispatch;
	}
	// 828FC73C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FC740: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828FC744: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828FC748: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828FC74C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828FC750: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 828FC754: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 828FC758: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 828FC75C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC760: 3BA100A0  addi r29, r1, 0xa0
	ctx.r[29].s64 = ctx.r[1].s64 + 160;
	// 828FC764: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC768: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC76C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FC770: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FC7D8 size=172
    let mut pc: u32 = 0x828FC7D8;
    'dispatch: loop {
        match pc {
            0x828FC7D8 => {
    //   block [0x828FC7D8..0x828FC884)
	// 828FC7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC7DC: 488AB991  bl 0x831a816c
	ctx.lr = 0x828FC7E0;
	sub_831A8130(ctx, base);
	// 828FC7E0: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC7E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FC7E8: 4BEEFA01  bl 0x827ec1e8
	ctx.lr = 0x828FC7EC;
	sub_827EC1E8(ctx, base);
	// 828FC7EC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828FC7F0: 4182008C  beq 0x828fc87c
	if ctx.cr[0].eq {
	pc = 0x828FC87C; continue 'dispatch;
	}
	// 828FC7F4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FC7F8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828FC7FC: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828FC800: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828FC804: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828FC808: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828FC80C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828FC810: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828FC814: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC818: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 828FC81C: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC820: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC824: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FC828: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC82C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC888 size=8
    let mut pc: u32 = 0x828FC888;
    'dispatch: loop {
        match pc {
            0x828FC888 => {
    //   block [0x828FC888..0x828FC890)
	// 828FC888: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828FC88C: 4800059C  b 0x828fce28
	sub_828FCE28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC890 size=8
    let mut pc: u32 = 0x828FC890;
    'dispatch: loop {
        match pc {
            0x828FC890 => {
    //   block [0x828FC890..0x828FC898)
	// 828FC890: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828FC894: 48000594  b 0x828fce28
	sub_828FCE28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC898 size=8
    let mut pc: u32 = 0x828FC898;
    'dispatch: loop {
        match pc {
            0x828FC898 => {
    //   block [0x828FC898..0x828FC8A0)
	// 828FC898: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FC89C: 4800058C  b 0x828fce28
	sub_828FCE28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC8A0 size=8
    let mut pc: u32 = 0x828FC8A0;
    'dispatch: loop {
        match pc {
            0x828FC8A0 => {
    //   block [0x828FC8A0..0x828FC8A8)
	// 828FC8A0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FC8A4: 4800066C  b 0x828fcf10
	sub_828FCF10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC8A8 size=8
    let mut pc: u32 = 0x828FC8A8;
    'dispatch: loop {
        match pc {
            0x828FC8A8 => {
    //   block [0x828FC8A8..0x828FC8B0)
	// 828FC8A8: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828FC8AC: 48000664  b 0x828fcf10
	sub_828FCF10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC8B0 size=8
    let mut pc: u32 = 0x828FC8B0;
    'dispatch: loop {
        match pc {
            0x828FC8B0 => {
    //   block [0x828FC8B0..0x828FC8B8)
	// 828FC8B0: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828FC8B4: 4800065C  b 0x828fcf10
	sub_828FCF10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FC8B8 size=324
    let mut pc: u32 = 0x828FC8B8;
    'dispatch: loop {
        match pc {
            0x828FC8B8 => {
    //   block [0x828FC8B8..0x828FC9FC)
	// 828FC8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC8BC: 488AB8AD  bl 0x831a8168
	ctx.lr = 0x828FC8C0;
	sub_831A8130(ctx, base);
	// 828FC8C0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC8C4: 3BE40010  addi r31, r4, 0x10
	ctx.r[31].s64 = ctx.r[4].s64 + 16;
	// 828FC8C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FC8CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC8D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828FC8D4: 48116DAD  bl 0x82a13680
	ctx.lr = 0x828FC8D8;
	sub_82A13680(ctx, base);
	// 828FC8D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FC8DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC8E0: 48116DA9  bl 0x82a13688
	ctx.lr = 0x828FC8E4;
	sub_82A13688(ctx, base);
	// 828FC8E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FC8E8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828FC8EC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828FC8F0: 4BA0AE89  bl 0x82307778
	ctx.lr = 0x828FC8F4;
	sub_82307778(ctx, base);
	// 828FC8F4: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 828FC8F8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828FC8FC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828FC900: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828FC904: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 828FC908: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828FC90C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC910: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC914: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 828FC918: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 828FC91C: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC920: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FC924: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCA00 size=136
    let mut pc: u32 = 0x828FCA00;
    'dispatch: loop {
        match pc {
            0x828FCA00 => {
    //   block [0x828FCA00..0x828FCA88)
	// 828FCA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCA08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCA0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCA10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCA14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FCA18: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FCA1C: 396B4504  addi r11, r11, 0x4504
	ctx.r[11].s64 = ctx.r[11].s64 + 17668;
	// 828FCA20: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FCA24: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FCA28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCA2C: 394A435C  addi r10, r10, 0x435c
	ctx.r[10].s64 = ctx.r[10].s64 + 17244;
	// 828FCA30: 39294348  addi r9, r9, 0x4348
	ctx.r[9].s64 = ctx.r[9].s64 + 17224;
	// 828FCA34: 3968432C  addi r11, r8, 0x432c
	ctx.r[11].s64 = ctx.r[8].s64 + 17196;
	// 828FCA38: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FCA3C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FCA40: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828FCA44: 807F043C  lwz r3, 0x43c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) } as u64;
	// 828FCA48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCA4C: 419A0008  beq cr6, 0x828fca54
	if ctx.cr[6].eq {
	pc = 0x828FCA54; continue 'dispatch;
	}
	// 828FCA50: 4B9C3E41  bl 0x822c0890
	ctx.lr = 0x828FCA54;
	sub_822C0890(ctx, base);
	// 828FCA54: 807F0434  lwz r3, 0x434(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1076 as u32) ) } as u64;
	// 828FCA58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCA5C: 419A0008  beq cr6, 0x828fca64
	if ctx.cr[6].eq {
	pc = 0x828FCA64; continue 'dispatch;
	}
	// 828FCA60: 4B9C3E31  bl 0x822c0890
	ctx.lr = 0x828FCA64;
	sub_822C0890(ctx, base);
	// 828FCA64: 387F03D0  addi r3, r31, 0x3d0
	ctx.r[3].s64 = ctx.r[31].s64 + 976;
	// 828FCA68: 48560DE1  bl 0x82e5d848
	ctx.lr = 0x828FCA6C;
	sub_82E5D848(ctx, base);
	// 828FCA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCA70: 4BFFF9D1  bl 0x828fc440
	ctx.lr = 0x828FCA74;
	sub_828FC440(ctx, base);
	// 828FCA74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FCA78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCA7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCA80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCA84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FCA88 size=8
    let mut pc: u32 = 0x828FCA88;
    'dispatch: loop {
        match pc {
            0x828FCA88 => {
    //   block [0x828FCA88..0x828FCA90)
	// 828FCA88: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FCA8C: 4800088C  b 0x828fd318
	sub_828FD318(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FCA90 size=8
    let mut pc: u32 = 0x828FCA90;
    'dispatch: loop {
        match pc {
            0x828FCA90 => {
    //   block [0x828FCA90..0x828FCA98)
	// 828FCA90: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828FCA94: 48000884  b 0x828fd318
	sub_828FD318(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FCA98 size=8
    let mut pc: u32 = 0x828FCA98;
    'dispatch: loop {
        match pc {
            0x828FCA98 => {
    //   block [0x828FCA98..0x828FCAA0)
	// 828FCA98: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828FCA9C: 4800087C  b 0x828fd318
	sub_828FD318(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCAA0 size=84
    let mut pc: u32 = 0x828FCAA0;
    'dispatch: loop {
        match pc {
            0x828FCAA0 => {
    //   block [0x828FCAA0..0x828FCAF4)
	// 828FCAA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCAA4: 488AB6C9  bl 0x831a816c
	ctx.lr = 0x828FCAA8;
	sub_831A8130(ctx, base);
	// 828FCAA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCAAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FCAB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FCAB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FCAB8: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828FCABC: 409A0008  bne cr6, 0x828fcac4
	if !ctx.cr[6].eq {
	pc = 0x828FCAC4; continue 'dispatch;
	}
	// 828FCAC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FCAC4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCAC8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828FCACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FCAD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FCAD4: 4BFFF3C5  bl 0x828fbe98
	ctx.lr = 0x828FCAD8;
	sub_828FBE98(ctx, base);
	// 828FCAD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FCADC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FCAE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FCAE4: 4B9C351D  bl 0x822c0000
	ctx.lr = 0x828FCAE8;
	sub_822C0000(ctx, base);
	// 828FCAE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FCAEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCAF0: 488AB6CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCAF8 size=84
    let mut pc: u32 = 0x828FCAF8;
    'dispatch: loop {
        match pc {
            0x828FCAF8 => {
    //   block [0x828FCAF8..0x828FCB4C)
	// 828FCAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCAFC: 488AB671  bl 0x831a816c
	ctx.lr = 0x828FCB00;
	sub_831A8130(ctx, base);
	// 828FCB00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCB04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FCB08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FCB0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FCB10: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828FCB14: 409A0008  bne cr6, 0x828fcb1c
	if !ctx.cr[6].eq {
	pc = 0x828FCB1C; continue 'dispatch;
	}
	// 828FCB18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FCB1C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCB20: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828FCB24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FCB28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FCB2C: 4BFFF435  bl 0x828fbf60
	ctx.lr = 0x828FCB30;
	sub_828FBF60(ctx, base);
	// 828FCB30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FCB34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FCB38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FCB3C: 4B9C34C5  bl 0x822c0000
	ctx.lr = 0x828FCB40;
	sub_822C0000(ctx, base);
	// 828FCB40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FCB44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCB48: 488AB674  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCB50 size=84
    let mut pc: u32 = 0x828FCB50;
    'dispatch: loop {
        match pc {
            0x828FCB50 => {
    //   block [0x828FCB50..0x828FCBA4)
	// 828FCB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCB54: 488AB619  bl 0x831a816c
	ctx.lr = 0x828FCB58;
	sub_831A8130(ctx, base);
	// 828FCB58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCB5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FCB60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FCB64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FCB68: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828FCB6C: 409A0008  bne cr6, 0x828fcb74
	if !ctx.cr[6].eq {
	pc = 0x828FCB74; continue 'dispatch;
	}
	// 828FCB70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FCB74: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCB78: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828FCB7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FCB80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FCB84: 4BFFF4A5  bl 0x828fc028
	ctx.lr = 0x828FCB88;
	sub_828FC028(ctx, base);
	// 828FCB88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FCB8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FCB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FCB94: 4B9C346D  bl 0x822c0000
	ctx.lr = 0x828FCB98;
	sub_822C0000(ctx, base);
	// 828FCB98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FCB9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCBA0: 488AB61C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCBA8 size=72
    let mut pc: u32 = 0x828FCBA8;
    'dispatch: loop {
        match pc {
            0x828FCBA8 => {
    //   block [0x828FCBA8..0x828FCBF0)
	// 828FCBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCBAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCBB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCBB4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828FCBB8: 419A001C  beq cr6, 0x828fcbd4
	if ctx.cr[6].eq {
	pc = 0x828FCBD4; continue 'dispatch;
	}
	// 828FCBBC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FCBC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828FCBC4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828FCBC8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FCBCC: 4BFFEB45  bl 0x828fb710
	ctx.lr = 0x828FCBD0;
	sub_828FB710(ctx, base);
	// 828FCBD0: 48000010  b 0x828fcbe0
	pc = 0x828FCBE0; continue 'dispatch;
	// 828FCBD4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FCBD8: 396BBFC0  addi r11, r11, -0x4040
	ctx.r[11].s64 = ctx.r[11].s64 + -16448;
	// 828FCBDC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCBE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FCBE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCBE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCBF0 size=72
    let mut pc: u32 = 0x828FCBF0;
    'dispatch: loop {
        match pc {
            0x828FCBF0 => {
    //   block [0x828FCBF0..0x828FCC38)
	// 828FCBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCBF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCBFC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828FCC00: 419A001C  beq cr6, 0x828fcc1c
	if ctx.cr[6].eq {
	pc = 0x828FCC1C; continue 'dispatch;
	}
	// 828FCC04: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FCC08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828FCC0C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828FCC10: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FCC14: 4BFFEB85  bl 0x828fb798
	ctx.lr = 0x828FCC18;
	sub_828FB798(ctx, base);
	// 828FCC18: 48000010  b 0x828fcc28
	pc = 0x828FCC28; continue 'dispatch;
	// 828FCC1C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FCC20: 396BC088  addi r11, r11, -0x3f78
	ctx.r[11].s64 = ctx.r[11].s64 + -16248;
	// 828FCC24: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCC28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FCC2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCC30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCC34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FCC38 size=160
    let mut pc: u32 = 0x828FCC38;
    'dispatch: loop {
        match pc {
            0x828FCC38 => {
    //   block [0x828FCC38..0x828FCCD8)
	// 828FCC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCC3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCC40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCC44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCC48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCC4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828FCC50: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828FCC54: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828FCC58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCC5C: 480626BD  bl 0x8295f318
	ctx.lr = 0x828FCC60;
	sub_8295F318(ctx, base);
	// 828FCC60: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FCC64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FCC68: 394A3CB4  addi r10, r10, 0x3cb4
	ctx.r[10].s64 = ctx.r[10].s64 + 15540;
	// 828FCC6C: 396B3E5C  addi r11, r11, 0x3e5c
	ctx.r[11].s64 = ctx.r[11].s64 + 15964;
	// 828FCC70: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FCC74: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FCC78: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FCC7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCC80: 39293C9C  addi r9, r9, 0x3c9c
	ctx.r[9].s64 = ctx.r[9].s64 + 15516;
	// 828FCC84: 39083C80  addi r8, r8, 0x3c80
	ctx.r[8].s64 = ctx.r[8].s64 + 15488;
	// 828FCC88: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FCC8C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FCC90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FCC94: 911F0218  stw r8, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[8].u32 ) };
	// 828FCC98: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 828FCC9C: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 828FCCA0: 392003B0  li r9, 0x3b0
	ctx.r[9].s64 = 944;
	// 828FCCA4: 917F0394  stw r11, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 828FCCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCCAC: 917F0398  stw r11, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 828FCCB0: 917F039C  stw r11, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 828FCCB4: 917F03A0  stw r11, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	// 828FCCB8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCCD8 size=76
    let mut pc: u32 = 0x828FCCD8;
    'dispatch: loop {
        match pc {
            0x828FCCD8 => {
    //   block [0x828FCCD8..0x828FCD24)
	// 828FCCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCCDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCCE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FCCE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCCE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCCEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCCF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FCCF4: 4BFFF74D  bl 0x828fc440
	ctx.lr = 0x828FCCF8;
	sub_828FC440(ctx, base);
	// 828FCCF8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FCCFC: 4182000C  beq 0x828fcd08
	if ctx.cr[0].eq {
	pc = 0x828FCD08; continue 'dispatch;
	}
	// 828FCD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCD04: 484F56D5  bl 0x82df23d8
	ctx.lr = 0x828FCD08;
	sub_82DF23D8(ctx, base);
	// 828FCD08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCD0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCD10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCD14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCD18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FCD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCD28 size=148
    let mut pc: u32 = 0x828FCD28;
    'dispatch: loop {
        match pc {
            0x828FCD28 => {
    //   block [0x828FCD28..0x828FCDBC)
	// 828FCD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCD30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCD34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCD38: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828FCD3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCD40: 48062499  bl 0x8295f1d8
	ctx.lr = 0x828FCD44;
	sub_8295F1D8(ctx, base);
	// 828FCD44: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FCD48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FCD4C: 808BC210  lwz r4, -0x3df0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15856 as u32) ) } as u64;
	// 828FCD50: 484F6CB9  bl 0x82df3a08
	ctx.lr = 0x828FCD54;
	sub_82DF3A08(ctx, base);
	// 828FCD54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FCD58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FCD5C: 4BEF9115  bl 0x827f5e70
	ctx.lr = 0x828FCD60;
	sub_827F5E70(ctx, base);
	// 828FCD60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FCD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCD68: 48062671  bl 0x8295f3d8
	ctx.lr = 0x828FCD6C;
	sub_8295F3D8(ctx, base);
	// 828FCD6C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FCD70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCD74: 419A0008  beq cr6, 0x828fcd7c
	if ctx.cr[6].eq {
	pc = 0x828FCD7C; continue 'dispatch;
	}
	// 828FCD78: 4B9C3B19  bl 0x822c0890
	ctx.lr = 0x828FCD7C;
	sub_822C0890(ctx, base);
	// 828FCD7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FCD80: 484F66A9  bl 0x82df3428
	ctx.lr = 0x828FCD84;
	sub_82DF3428(ctx, base);
	// 828FCD84: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FCD88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FCD8C: 808BC238  lwz r4, -0x3dc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15816 as u32) ) } as u64;
	// 828FCD90: 484F6C79  bl 0x82df3a08
	ctx.lr = 0x828FCD94;
	sub_82DF3A08(ctx, base);
	// 828FCD94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FCD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCD9C: 48062645  bl 0x8295f3e0
	ctx.lr = 0x828FCDA0;
	sub_8295F3E0(ctx, base);
	// 828FCDA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FCDA4: 484F6685  bl 0x82df3428
	ctx.lr = 0x828FCDA8;
	sub_82DF3428(ctx, base);
	// 828FCDA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCDAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCDB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCDB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCDB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCDC0 size=100
    let mut pc: u32 = 0x828FCDC0;
    'dispatch: loop {
        match pc {
            0x828FCDC0 => {
    //   block [0x828FCDC0..0x828FCE24)
	// 828FCDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCDC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCDC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCDCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCDD0: 38C00019  li r6, 0x19
	ctx.r[6].s64 = 25;
	// 828FCDD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCDD8: 4BFFFE61  bl 0x828fcc38
	ctx.lr = 0x828FCDDC;
	sub_828FCC38(ctx, base);
	// 828FCDDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FCDE0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FCDE4: 396B4094  addi r11, r11, 0x4094
	ctx.r[11].s64 = ctx.r[11].s64 + 16532;
	// 828FCDE8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FCDEC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FCDF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCDF4: 394A3EEC  addi r10, r10, 0x3eec
	ctx.r[10].s64 = ctx.r[10].s64 + 16108;
	// 828FCDF8: 39293ED8  addi r9, r9, 0x3ed8
	ctx.r[9].s64 = ctx.r[9].s64 + 16088;
	// 828FCDFC: 39683EBC  addi r11, r8, 0x3ebc
	ctx.r[11].s64 = ctx.r[8].s64 + 16060;
	// 828FCE00: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FCE04: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FCE08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCE0C: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828FCE10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FCE14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCE18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCE1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCE28 size=124
    let mut pc: u32 = 0x828FCE28;
    'dispatch: loop {
        match pc {
            0x828FCE28 => {
    //   block [0x828FCE28..0x828FCEA4)
	// 828FCE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCE30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FCE34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCE38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCE40: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FCE44: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FCE48: 396B4094  addi r11, r11, 0x4094
	ctx.r[11].s64 = ctx.r[11].s64 + 16532;
	// 828FCE4C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FCE50: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FCE54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCE58: 394A3EEC  addi r10, r10, 0x3eec
	ctx.r[10].s64 = ctx.r[10].s64 + 16108;
	// 828FCE5C: 39293ED8  addi r9, r9, 0x3ed8
	ctx.r[9].s64 = ctx.r[9].s64 + 16088;
	// 828FCE60: 39683EBC  addi r11, r8, 0x3ebc
	ctx.r[11].s64 = ctx.r[8].s64 + 16060;
	// 828FCE64: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FCE68: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FCE6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FCE70: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828FCE74: 4BFFF5CD  bl 0x828fc440
	ctx.lr = 0x828FCE78;
	sub_828FC440(ctx, base);
	// 828FCE78: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FCE7C: 4182000C  beq 0x828fce88
	if ctx.cr[0].eq {
	pc = 0x828FCE88; continue 'dispatch;
	}
	// 828FCE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCE84: 484F5555  bl 0x82df23d8
	ctx.lr = 0x828FCE88;
	sub_82DF23D8(ctx, base);
	// 828FCE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCE8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCE90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCE94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCE98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FCE9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCEA8 size=100
    let mut pc: u32 = 0x828FCEA8;
    'dispatch: loop {
        match pc {
            0x828FCEA8 => {
    //   block [0x828FCEA8..0x828FCF0C)
	// 828FCEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCEB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCEB8: 38C0001A  li r6, 0x1a
	ctx.r[6].s64 = 26;
	// 828FCEBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCEC0: 4BFFFD79  bl 0x828fcc38
	ctx.lr = 0x828FCEC4;
	sub_828FCC38(ctx, base);
	// 828FCEC4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FCEC8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FCECC: 396B42CC  addi r11, r11, 0x42cc
	ctx.r[11].s64 = ctx.r[11].s64 + 17100;
	// 828FCED0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FCED4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FCED8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCEDC: 394A4124  addi r10, r10, 0x4124
	ctx.r[10].s64 = ctx.r[10].s64 + 16676;
	// 828FCEE0: 39294110  addi r9, r9, 0x4110
	ctx.r[9].s64 = ctx.r[9].s64 + 16656;
	// 828FCEE4: 396840F4  addi r11, r8, 0x40f4
	ctx.r[11].s64 = ctx.r[8].s64 + 16628;
	// 828FCEE8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FCEEC: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FCEF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCEF4: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828FCEF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FCEFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCF00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCF04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCF08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCF10 size=124
    let mut pc: u32 = 0x828FCF10;
    'dispatch: loop {
        match pc {
            0x828FCF10 => {
    //   block [0x828FCF10..0x828FCF8C)
	// 828FCF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCF18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FCF1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCF20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCF24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCF28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FCF2C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FCF30: 396B42CC  addi r11, r11, 0x42cc
	ctx.r[11].s64 = ctx.r[11].s64 + 17100;
	// 828FCF34: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FCF38: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FCF3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FCF40: 394A4124  addi r10, r10, 0x4124
	ctx.r[10].s64 = ctx.r[10].s64 + 16676;
	// 828FCF44: 39294110  addi r9, r9, 0x4110
	ctx.r[9].s64 = ctx.r[9].s64 + 16656;
	// 828FCF48: 396840F4  addi r11, r8, 0x40f4
	ctx.r[11].s64 = ctx.r[8].s64 + 16628;
	// 828FCF4C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FCF50: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FCF54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FCF58: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828FCF5C: 4BFFF4E5  bl 0x828fc440
	ctx.lr = 0x828FCF60;
	sub_828FC440(ctx, base);
	// 828FCF60: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FCF64: 4182000C  beq 0x828fcf70
	if ctx.cr[0].eq {
	pc = 0x828FCF70; continue 'dispatch;
	}
	// 828FCF68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCF6C: 484F546D  bl 0x82df23d8
	ctx.lr = 0x828FCF70;
	sub_82DF23D8(ctx, base);
	// 828FCF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCF74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCF78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCF7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCF80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FCF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FCF90 size=692
    let mut pc: u32 = 0x828FCF90;
    'dispatch: loop {
        match pc {
            0x828FCF90 => {
    //   block [0x828FCF90..0x828FD244)
	// 828FCF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCF94: 488AB1CD  bl 0x831a8160
	ctx.lr = 0x828FCF98;
	sub_831A8130(ctx, base);
	// 828FCF98: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD248 size=204
    let mut pc: u32 = 0x828FD248;
    'dispatch: loop {
        match pc {
            0x828FD248 => {
    //   block [0x828FD248..0x828FD314)
	// 828FD248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD24C: 488AAF1D  bl 0x831a8168
	ctx.lr = 0x828FD250;
	sub_831A8130(ctx, base);
	// 828FD250: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD254: 38C0001B  li r6, 0x1b
	ctx.r[6].s64 = 27;
	// 828FD258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FD25C: 4BFFF9DD  bl 0x828fcc38
	ctx.lr = 0x828FD260;
	sub_828FCC38(ctx, base);
	// 828FD260: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD264: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828FD268: 396B4504  addi r11, r11, 0x4504
	ctx.r[11].s64 = ctx.r[11].s64 + 17668;
	// 828FD26C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FD270: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828FD274: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FD278: 394A435C  addi r10, r10, 0x435c
	ctx.r[10].s64 = ctx.r[10].s64 + 17244;
	// 828FD27C: 39294348  addi r9, r9, 0x4348
	ctx.r[9].s64 = ctx.r[9].s64 + 17224;
	// 828FD280: 3968432C  addi r11, r8, 0x432c
	ctx.r[11].s64 = ctx.r[8].s64 + 17196;
	// 828FD284: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828FD288: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828FD28C: 387F03D0  addi r3, r31, 0x3d0
	ctx.r[3].s64 = ctx.r[31].s64 + 976;
	// 828FD290: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828FD294: 4856063D  bl 0x82e5d8d0
	ctx.lr = 0x828FD298;
	sub_82E5D8D0(ctx, base);
	// 828FD298: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD29C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FD2A0: 396B3B94  addi r11, r11, 0x3b94
	ctx.r[11].s64 = ctx.r[11].s64 + 15252;
	// 828FD2A4: 388A45A8  addi r4, r10, 0x45a8
	ctx.r[4].s64 = ctx.r[10].s64 + 17832;
	// 828FD2A8: 917F03D0  stw r11, 0x3d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), ctx.r[11].u32 ) };
	// 828FD2AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FD2B0: 38A00450  li r5, 0x450
	ctx.r[5].s64 = 1104;
	// 828FD2B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828FD2B8: 4B9C3121  bl 0x822c03d8
	ctx.lr = 0x828FD2BC;
	sub_822C03D8(ctx, base);
	// 828FD2BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828FD2C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FD2C4: 41820010  beq 0x828fd2d4
	if ctx.cr[0].eq {
	pc = 0x828FD2D4; continue 'dispatch;
	}
	// 828FD2C8: 48002901  bl 0x828ffbc8
	ctx.lr = 0x828FD2CC;
	sub_828FFBC8(ctx, base);
	// 828FD2CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FD2D0: 48000008  b 0x828fd2d8
	pc = 0x828FD2D8; continue 'dispatch;
	// 828FD2D4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828FD2D8: 93DF0430  stw r30, 0x430(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), ctx.r[30].u32 ) };
	// 828FD2DC: 397F0430  addi r11, r31, 0x430
	ctx.r[11].s64 = ctx.r[31].s64 + 1072;
	// 828FD2E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FD2E4: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 828FD2E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD2EC: 4BFFEE05  bl 0x828fc0f0
	ctx.lr = 0x828FD2F0;
	sub_828FC0F0(ctx, base);
	// 828FD2F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD2F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FD2F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD2FC: 4B9C2D05  bl 0x822c0000
	ctx.lr = 0x828FD300;
	sub_822C0000(ctx, base);
	// 828FD300: 939F0438  stw r28, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[28].u32 ) };
	// 828FD304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FD308: 939F043C  stw r28, 0x43c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1084 as u32), ctx.r[28].u32 ) };
	// 828FD30C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FD310: 488AAEA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD318 size=76
    let mut pc: u32 = 0x828FD318;
    'dispatch: loop {
        match pc {
            0x828FD318 => {
    //   block [0x828FD318..0x828FD364)
	// 828FD318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD31C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FD320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FD324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FD328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD32C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FD330: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FD334: 4BFFF6CD  bl 0x828fca00
	ctx.lr = 0x828FD338;
	sub_828FCA00(ctx, base);
	// 828FD338: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FD33C: 4182000C  beq 0x828fd348
	if ctx.cr[0].eq {
	pc = 0x828FD348; continue 'dispatch;
	}
	// 828FD340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FD344: 484F5095  bl 0x82df23d8
	ctx.lr = 0x828FD348;
	sub_82DF23D8(ctx, base);
	// 828FD348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FD34C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FD350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FD354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FD358: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FD35C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FD360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FD368 size=184
    let mut pc: u32 = 0x828FD368;
    'dispatch: loop {
        match pc {
            0x828FD368 => {
    //   block [0x828FD368..0x828FD420)
	// 828FD368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FD370: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FD374: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD378: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FD37C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FD380: 48006C39  bl 0x82903fb8
	ctx.lr = 0x828FD384;
	sub_82903FB8(ctx, base);
	// 828FD384: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD388: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FD38C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FD390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FD394: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FD398: 419A0024  beq cr6, 0x828fd3bc
	if ctx.cr[6].eq {
	pc = 0x828FD3BC; continue 'dispatch;
	}
	// 828FD39C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FD3A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FD3A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FD3A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FD3AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FD3B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FD3B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FD3B8: 4082FFE8  bne 0x828fd3a0
	if !ctx.cr[0].eq {
	pc = 0x828FD3A0; continue 'dispatch;
	}
	// 828FD3BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FD3C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FD3C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FD3C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FD3CC: 389F03D0  addi r4, r31, 0x3d0
	ctx.r[4].s64 = ctx.r[31].s64 + 976;
	// 828FD3D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD3D4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FD3D8: 485612D1  bl 0x82e5e6a8
	ctx.lr = 0x828FD3DC;
	sub_82E5E6A8(ctx, base);
	// 828FD3DC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FD3E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FD3E4: 419A0008  beq cr6, 0x828fd3ec
	if ctx.cr[6].eq {
	pc = 0x828FD3EC; continue 'dispatch;
	}
	// 828FD3E8: 4B9C34A9  bl 0x822c0890
	ctx.lr = 0x828FD3EC;
	sub_822C0890(ctx, base);
	// 828FD3EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FD3F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FD3F4: 419A0008  beq cr6, 0x828fd3fc
	if ctx.cr[6].eq {
	pc = 0x828FD3FC; continue 'dispatch;
	}
	// 828FD3F8: 4B9C3499  bl 0x822c0890
	ctx.lr = 0x828FD3FC;
	sub_822C0890(ctx, base);
	// 828FD3FC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FD400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FD404: 419A0008  beq cr6, 0x828fd40c
	if ctx.cr[6].eq {
	pc = 0x828FD40C; continue 'dispatch;
	}
	// 828FD408: 4B9C3489  bl 0x822c0890
	ctx.lr = 0x828FD40C;
	sub_822C0890(ctx, base);
	// 828FD40C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FD410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FD414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FD418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FD41C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD420 size=112
    let mut pc: u32 = 0x828FD420;
    'dispatch: loop {
        match pc {
            0x828FD420 => {
    //   block [0x828FD420..0x828FD490)
	// 828FD420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FD428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FD42C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FD430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FD438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FD43C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828FD440: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FD444: 4BFFED5D  bl 0x828fc1a0
	ctx.lr = 0x828FD448;
	sub_828FC1A0(ctx, base);
	// 828FD448: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD44C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FD450: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FD454: 4B9C2BAD  bl 0x822c0000
	ctx.lr = 0x828FD458;
	sub_822C0000(ctx, base);
	// 828FD458: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FD45C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FD460: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FD464: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FD468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FD46C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828FD470: 419A0008  beq cr6, 0x828fd478
	if ctx.cr[6].eq {
	pc = 0x828FD478; continue 'dispatch;
	}
	// 828FD474: 4B9C341D  bl 0x822c0890
	ctx.lr = 0x828FD478;
	sub_822C0890(ctx, base);
	// 828FD478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FD47C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FD480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FD484: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FD488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FD48C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD490 size=376
    let mut pc: u32 = 0x828FD490;
    'dispatch: loop {
        match pc {
            0x828FD490 => {
    //   block [0x828FD490..0x828FD608)
	// 828FD490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD494: 488AACD5  bl 0x831a8168
	ctx.lr = 0x828FD498;
	sub_831A8130(ctx, base);
	// 828FD498: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD49C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FD4A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD4A4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828FD4A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FD4AC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828FD4B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD4B4: 388B4618  addi r4, r11, 0x4618
	ctx.r[4].s64 = ctx.r[11].s64 + 17944;
	// 828FD4B8: 484F6551  bl 0x82df3a08
	ctx.lr = 0x828FD4BC;
	sub_82DF3A08(ctx, base);
	// 828FD4BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD4C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FD4C4: 388B460C  addi r4, r11, 0x460c
	ctx.r[4].s64 = ctx.r[11].s64 + 17932;
	// 828FD4C8: 484F6541  bl 0x82df3a08
	ctx.lr = 0x828FD4CC;
	sub_82DF3A08(ctx, base);
	// 828FD4CC: 38BF03C0  addi r5, r31, 0x3c0
	ctx.r[5].s64 = ctx.r[31].s64 + 960;
	// 828FD4D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FD4D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828FD4D8: 4BCA5B79  bl 0x825a3050
	ctx.lr = 0x828FD4DC;
	sub_825A3050(ctx, base);
	// 828FD4DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FD4E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FD4E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FD4E8: 4BCA4CA1  bl 0x825a2188
	ctx.lr = 0x828FD4EC;
	sub_825A2188(ctx, base);
	// 828FD4EC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828FD4F0: 484F5F39  bl 0x82df3428
	ctx.lr = 0x828FD4F4;
	sub_82DF3428(ctx, base);
	// 828FD4F4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828FD4F8: 4B9CB7C1  bl 0x822c8cb8
	ctx.lr = 0x828FD4FC;
	sub_822C8CB8(ctx, base);
	// 828FD4FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FD500: 484F5F29  bl 0x82df3428
	ctx.lr = 0x828FD504;
	sub_82DF3428(ctx, base);
	// 828FD504: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD508: 484F5F21  bl 0x82df3428
	ctx.lr = 0x828FD50C;
	sub_82DF3428(ctx, base);
	// 828FD50C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD510: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FD514: 388B45A8  addi r4, r11, 0x45a8
	ctx.r[4].s64 = ctx.r[11].s64 + 17832;
	// 828FD518: 38A001A3  li r5, 0x1a3
	ctx.r[5].s64 = 419;
	// 828FD51C: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 828FD520: 4B9C2EB9  bl 0x822c03d8
	ctx.lr = 0x828FD524;
	sub_822C03D8(ctx, base);
	// 828FD524: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FD528: 41820034  beq 0x828fd55c
	if ctx.cr[0].eq {
	pc = 0x828FD55C; continue 'dispatch;
	}
	// 828FD52C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828FD530: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD534: 388BBED0  addi r4, r11, -0x4130
	ctx.r[4].s64 = ctx.r[11].s64 + -16688;
	// 828FD538: 484F64D1  bl 0x82df3a08
	ctx.lr = 0x828FD53C;
	sub_82DF3A08(ctx, base);
	// 828FD53C: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 828FD540: 38BF03B0  addi r5, r31, 0x3b0
	ctx.r[5].s64 = ctx.r[31].s64 + 944;
	// 828FD544: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FD548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FD54C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828FD550: 4BCABFA9  bl 0x825a94f8
	ctx.lr = 0x828FD554;
	sub_825A94F8(ctx, base);
	// 828FD554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FD558: 48000008  b 0x828fd560
	pc = 0x828FD560; continue 'dispatch;
	// 828FD55C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FD560: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828FD564: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FD568: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FD56C: 4BCAA27D  bl 0x825a77e8
	ctx.lr = 0x828FD570;
	sub_825A77E8(ctx, base);
	// 828FD570: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FD574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FD578: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FD57C: 4B9C2A85  bl 0x822c0000
	ctx.lr = 0x828FD580;
	sub_822C0000(ctx, base);
	// 828FD580: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FD584: 4182000C  beq 0x828fd590
	if ctx.cr[0].eq {
	pc = 0x828FD590; continue 'dispatch;
	}
	// 828FD588: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD58C: 484F5E9D  bl 0x82df3428
	ctx.lr = 0x828FD590;
	sub_82DF3428(ctx, base);
	// 828FD590: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828FD594: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD598: 388BBEC4  addi r4, r11, -0x413c
	ctx.r[4].s64 = ctx.r[11].s64 + -16700;
	// 828FD59C: 484F646D  bl 0x82df3a08
	ctx.lr = 0x828FD5A0;
	sub_82DF3A08(ctx, base);
	// 828FD5A0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FD5A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FD5A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FD5AC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828FD5B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828FD5B4: 419A0024  beq cr6, 0x828fd5d8
	if ctx.cr[6].eq {
	pc = 0x828FD5D8; continue 'dispatch;
	}
	// 828FD5B8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828FD5BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FD5C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FD5C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FD5C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FD5CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FD5D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FD5D4: 4082FFE8  bne 0x828fd5bc
	if !ctx.cr[0].eq {
	pc = 0x828FD5BC; continue 'dispatch;
	}
	// 828FD5D8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828FD5DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FD5E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FD5E4: 4BCA4B2D  bl 0x825a2110
	ctx.lr = 0x828FD5E8;
	sub_825A2110(ctx, base);
	// 828FD5E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD5EC: 484F5E3D  bl 0x82df3428
	ctx.lr = 0x828FD5F0;
	sub_82DF3428(ctx, base);
	// 828FD5F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FD5F4: 419A000C  beq cr6, 0x828fd600
	if ctx.cr[6].eq {
	pc = 0x828FD600; continue 'dispatch;
	}
	// 828FD5F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FD5FC: 4B9C3295  bl 0x822c0890
	ctx.lr = 0x828FD600;
	sub_822C0890(ctx, base);
	// 828FD600: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828FD604: 488AABB4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FD608 size=688
    let mut pc: u32 = 0x828FD608;
    'dispatch: loop {
        match pc {
            0x828FD608 => {
    //   block [0x828FD608..0x828FD8B8)
	// 828FD608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD60C: 488AAB59  bl 0x831a8164
	ctx.lr = 0x828FD610;
	sub_831A8130(ctx, base);
	// 828FD610: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828FD614: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD618: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FD61C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FD620: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FD624: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828FD628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FD62C: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 828FD630: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828FD634: 484F63D5  bl 0x82df3a08
	ctx.lr = 0x828FD638;
	sub_82DF3A08(ctx, base);
	// 828FD638: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828FD63C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD640: 837E0398  lwz r27, 0x398(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(920 as u32) ) } as u64;
	// 828FD644: 4BEEF7BD  bl 0x827ece00
	ctx.lr = 0x828FD648;
	sub_827ECE00(ctx, base);
	// 828FD648: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FD64C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FD650: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FD654: 48024A3D  bl 0x82922090
	ctx.lr = 0x828FD658;
	sub_82922090(ctx, base);
	// 828FD658: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FD65C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828FD660: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FD664: 41820040  beq 0x828fd6a4
	if ctx.cr[0].eq {
	pc = 0x828FD6A4; continue 'dispatch;
	}
	// 828FD668: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FD66C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 828FD670: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 828FD674: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD678: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD67C: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828FD680: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FD684: 41820014  beq 0x828fd698
	if ctx.cr[0].eq {
	pc = 0x828FD698; continue 'dispatch;
	}
	// 828FD688: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FD68C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FD690: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FD694: 419AFFE0  beq cr6, 0x828fd674
	if ctx.cr[6].eq {
	pc = 0x828FD674; continue 'dispatch;
	}
	// 828FD698: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828FD69C: 41820028  beq 0x828fd6c4
	if ctx.cr[0].eq {
	pc = 0x828FD6C4; continue 'dispatch;
	}
	// 828FD6A0: 4800001C  b 0x828fd6bc
	pc = 0x828FD6BC; continue 'dispatch;
	// 828FD6A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD6A8: 4800B7B1  bl 0x82908e58
	ctx.lr = 0x828FD6AC;
	sub_82908E58(ctx, base);
	// 828FD6AC: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828FD6B0: 40990014  ble cr6, 0x828fd6c4
	if !ctx.cr[6].gt {
	pc = 0x828FD6C4; continue 'dispatch;
	}
	// 828FD6B4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FD6B8: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828FD6BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FD6C0: 484F61B9  bl 0x82df3878
	ctx.lr = 0x828FD6C4;
	sub_82DF3878(ctx, base);
	// 828FD6C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FD6C8: 484F64E1  bl 0x82df3ba8
	ctx.lr = 0x828FD6CC;
	sub_82DF3BA8(ctx, base);
	// 828FD6CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FD6D0: 408201D4  bne 0x828fd8a4
	if !ctx.cr[0].eq {
	pc = 0x828FD8A4; continue 'dispatch;
	}
	// 828FD6D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD6D8: 4BEEEA89  bl 0x827ec160
	ctx.lr = 0x828FD6DC;
	sub_827EC160(ctx, base);
	// 828FD6DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FD6E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FD6E4: 480196B5  bl 0x82916d98
	ctx.lr = 0x828FD6E8;
	sub_82916D98(ctx, base);
	// 828FD6E8: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 828FD6EC: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FD6F0: 394000E0  li r10, 0xe0
	ctx.r[10].s64 = 224;
	// 828FD6F4: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 828FD6F8: 390000D0  li r8, 0xd0
	ctx.r[8].s64 = 208;
	// 828FD6FC: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD8B8 size=100
    let mut pc: u32 = 0x828FD8B8;
    'dispatch: loop {
        match pc {
            0x828FD8B8 => {
    //   block [0x828FD8B8..0x828FD91C)
	// 828FD8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD8BC: 488AA8B1  bl 0x831a816c
	ctx.lr = 0x828FD8C0;
	sub_831A8130(ctx, base);
	// 828FD8C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD8C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD8C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FD8CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FD8D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828FD8D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FD8D8: 388B45A8  addi r4, r11, 0x45a8
	ctx.r[4].s64 = ctx.r[11].s64 + 17832;
	// 828FD8DC: 38A00378  li r5, 0x378
	ctx.r[5].s64 = 888;
	// 828FD8E0: 386003D0  li r3, 0x3d0
	ctx.r[3].s64 = 976;
	// 828FD8E4: 484F4B05  bl 0x82df23e8
	ctx.lr = 0x828FD8E8;
	sub_82DF23E8(ctx, base);
	// 828FD8E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FD8EC: 41820018  beq 0x828fd904
	if ctx.cr[0].eq {
	pc = 0x828FD904; continue 'dispatch;
	}
	// 828FD8F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD8F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FD8F8: 4BFFF4C9  bl 0x828fcdc0
	ctx.lr = 0x828FD8FC;
	sub_828FCDC0(ctx, base);
	// 828FD8FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FD900: 48000008  b 0x828fd908
	pc = 0x828FD908; continue 'dispatch;
	// 828FD904: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FD908: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD90C: 4BFFF195  bl 0x828fcaa0
	ctx.lr = 0x828FD910;
	sub_828FCAA0(ctx, base);
	// 828FD910: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FD918: 488AA8A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD920 size=100
    let mut pc: u32 = 0x828FD920;
    'dispatch: loop {
        match pc {
            0x828FD920 => {
    //   block [0x828FD920..0x828FD984)
	// 828FD920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD924: 488AA849  bl 0x831a816c
	ctx.lr = 0x828FD928;
	sub_831A8130(ctx, base);
	// 828FD928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD92C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD930: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FD934: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FD938: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828FD93C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FD940: 388B45A8  addi r4, r11, 0x45a8
	ctx.r[4].s64 = ctx.r[11].s64 + 17832;
	// 828FD944: 38A003BE  li r5, 0x3be
	ctx.r[5].s64 = 958;
	// 828FD948: 386003D0  li r3, 0x3d0
	ctx.r[3].s64 = 976;
	// 828FD94C: 484F4A9D  bl 0x82df23e8
	ctx.lr = 0x828FD950;
	sub_82DF23E8(ctx, base);
	// 828FD950: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FD954: 41820018  beq 0x828fd96c
	if ctx.cr[0].eq {
	pc = 0x828FD96C; continue 'dispatch;
	}
	// 828FD958: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD95C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FD960: 4BFFF549  bl 0x828fcea8
	ctx.lr = 0x828FD964;
	sub_828FCEA8(ctx, base);
	// 828FD964: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FD968: 48000008  b 0x828fd970
	pc = 0x828FD970; continue 'dispatch;
	// 828FD96C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FD970: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD974: 4BFFF185  bl 0x828fcaf8
	ctx.lr = 0x828FD978;
	sub_828FCAF8(ctx, base);
	// 828FD978: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD97C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FD980: 488AA83C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD988 size=100
    let mut pc: u32 = 0x828FD988;
    'dispatch: loop {
        match pc {
            0x828FD988 => {
    //   block [0x828FD988..0x828FD9EC)
	// 828FD988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD98C: 488AA7E1  bl 0x831a816c
	ctx.lr = 0x828FD990;
	sub_831A8130(ctx, base);
	// 828FD990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD994: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FD998: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FD99C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FD9A0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828FD9A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FD9A8: 388B45A8  addi r4, r11, 0x45a8
	ctx.r[4].s64 = ctx.r[11].s64 + 17832;
	// 828FD9AC: 38A00448  li r5, 0x448
	ctx.r[5].s64 = 1096;
	// 828FD9B0: 38600450  li r3, 0x450
	ctx.r[3].s64 = 1104;
	// 828FD9B4: 484F4A35  bl 0x82df23e8
	ctx.lr = 0x828FD9B8;
	sub_82DF23E8(ctx, base);
	// 828FD9B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FD9BC: 41820018  beq 0x828fd9d4
	if ctx.cr[0].eq {
	pc = 0x828FD9D4; continue 'dispatch;
	}
	// 828FD9C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD9C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FD9C8: 4BFFF881  bl 0x828fd248
	ctx.lr = 0x828FD9CC;
	sub_828FD248(ctx, base);
	// 828FD9CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FD9D0: 48000008  b 0x828fd9d8
	pc = 0x828FD9D8; continue 'dispatch;
	// 828FD9D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FD9D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD9DC: 4BFFF175  bl 0x828fcb50
	ctx.lr = 0x828FD9E0;
	sub_828FCB50(ctx, base);
	// 828FD9E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FD9E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FD9E8: 488AA7D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FD9F0 size=332
    let mut pc: u32 = 0x828FD9F0;
    'dispatch: loop {
        match pc {
            0x828FD9F0 => {
    //   block [0x828FD9F0..0x828FDB3C)
	// 828FD9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD9F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FD9F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FD9FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FDA00: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 828FDA04: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828FDA08: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDA0C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828FDA10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FDA14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FDA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FDA1C: 388BEDA0  addi r4, r11, -0x1260
	ctx.r[4].s64 = ctx.r[11].s64 + -4704;
	// 828FDA20: 484F5FE9  bl 0x82df3a08
	ctx.lr = 0x828FDA24;
	sub_82DF3A08(ctx, base);
	// 828FDA24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FDA28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FDA2C: 809F0430  lwz r4, 0x430(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) } as u64;
	// 828FDA30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FDA34: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FDA38: C3CA08AC  lfs f30, 0x8ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2220 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828FDA3C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828FDA40: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828FDA44: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FDA48: 4BCA5769  bl 0x825a31b0
	ctx.lr = 0x828FDA4C;
	sub_825A31B0(ctx, base);
	// 828FDA4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FDA50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FDA54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FDA58: 4BCA3D19  bl 0x825a1770
	ctx.lr = 0x828FDA5C;
	sub_825A1770(ctx, base);
	// 828FDA5C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828FDA60: 484F59C9  bl 0x82df3428
	ctx.lr = 0x828FDA64;
	sub_82DF3428(ctx, base);
	// 828FDA64: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828FDA68: 4B9CB251  bl 0x822c8cb8
	ctx.lr = 0x828FDA6C;
	sub_822C8CB8(ctx, base);
	// 828FDA6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FDA70: 484F59B9  bl 0x82df3428
	ctx.lr = 0x828FDA74;
	sub_82DF3428(ctx, base);
	// 828FDA74: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828FDA78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FDA7C: 388BED88  addi r4, r11, -0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + -4728;
	// 828FDA80: 484F5F89  bl 0x82df3a08
	ctx.lr = 0x828FDA84;
	sub_82DF3A08(ctx, base);
	// 828FDA84: 817F0430  lwz r11, 0x430(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) } as u64;
	// 828FDA88: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828FDA8C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828FDA90: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828FDA94: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828FDA98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FDA9C: 4BCA5715  bl 0x825a31b0
	ctx.lr = 0x828FDAA0;
	sub_825A31B0(ctx, base);
	// 828FDAA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FDAA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FDAA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FDAAC: 4BCA3CC5  bl 0x825a1770
	ctx.lr = 0x828FDAB0;
	sub_825A1770(ctx, base);
	// 828FDAB0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828FDAB4: 484F5975  bl 0x82df3428
	ctx.lr = 0x828FDAB8;
	sub_82DF3428(ctx, base);
	// 828FDAB8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828FDABC: 4B9CB1FD  bl 0x822c8cb8
	ctx.lr = 0x828FDAC0;
	sub_822C8CB8(ctx, base);
	// 828FDAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FDAC4: 484F5965  bl 0x82df3428
	ctx.lr = 0x828FDAC8;
	sub_82DF3428(ctx, base);
	// 828FDAC8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828FDACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FDAD0: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 828FDAD4: 484F5F35  bl 0x82df3a08
	ctx.lr = 0x828FDAD8;
	sub_82DF3A08(ctx, base);
	// 828FDAD8: 817F0430  lwz r11, 0x430(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) } as u64;
	// 828FDADC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828FDAE0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828FDAE4: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 828FDAE8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828FDAEC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FDAF0: 4BCA56C1  bl 0x825a31b0
	ctx.lr = 0x828FDAF4;
	sub_825A31B0(ctx, base);
	// 828FDAF4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FDAF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FDAFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FDB00: 4BCA3C71  bl 0x825a1770
	ctx.lr = 0x828FDB04;
	sub_825A1770(ctx, base);
	// 828FDB04: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828FDB08: 484F5921  bl 0x82df3428
	ctx.lr = 0x828FDB0C;
	sub_82DF3428(ctx, base);
	// 828FDB0C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828FDB10: 4B9CB1A9  bl 0x822c8cb8
	ctx.lr = 0x828FDB14;
	sub_822C8CB8(ctx, base);
	// 828FDB14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FDB18: 484F5911  bl 0x82df3428
	ctx.lr = 0x828FDB1C;
	sub_82DF3428(ctx, base);
	// 828FDB1C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 828FDB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FDB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FDB28: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828FDB2C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828FDB30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FDB34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FDB38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FDB40 size=512
    let mut pc: u32 = 0x828FDB40;
    'dispatch: loop {
        match pc {
            0x828FDB40 => {
    //   block [0x828FDB40..0x828FDD40)
	// 828FDB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FDB44: 488AA619  bl 0x831a815c
	ctx.lr = 0x828FDB48;
	sub_831A8130(ctx, base);
	// 828FDB48: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 828FDB4C: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828FDB50: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828FDB54: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDB58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FDB5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828FDB60: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828FDB64: 835F0394  lwz r26, 0x394(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828FDB68: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 828FDB6C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828FDB70: 419A0024  beq cr6, 0x828fdb94
	if ctx.cr[6].eq {
	pc = 0x828FDB94; continue 'dispatch;
	}
	// 828FDB74: 395A0004  addi r10, r26, 4
	ctx.r[10].s64 = ctx.r[26].s64 + 4;
	// 828FDB78: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828FDB7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FDB80: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828FDB84: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828FDB88: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FDB8C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FDB90: 4082FFE8  bne 0x828fdb78
	if !ctx.cr[0].eq {
	pc = 0x828FDB78; continue 'dispatch;
	}
	// 828FDB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDB98: 419A00D0  beq cr6, 0x828fdc68
	if ctx.cr[6].eq {
	pc = 0x828FDC68; continue 'dispatch;
	}
	// 828FDB9C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDBA0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828FDBA4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828FDBA8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828FDBAC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828FDBB0: 485A2B81  bl 0x82ea0730
	ctx.lr = 0x828FDBB4;
	sub_82EA0730(ctx, base);
	// 828FDBB4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828FDBB8: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 828FDBBC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828FDBC0: C02A7BC4  lfs f1, 0x7bc4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FDBC4: 4861C62D  bl 0x82f1a1f0
	ctx.lr = 0x828FDBC8;
	sub_82F1A1F0(ctx, base);
	// 828FDBC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FDBCC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FDBD0: 396BAE50  addi r11, r11, -0x51b0
	ctx.r[11].s64 = ctx.r[11].s64 + -20912;
	// 828FDBD4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FDBD8: 388A45A8  addi r4, r10, 0x45a8
	ctx.r[4].s64 = ctx.r[10].s64 + 17832;
	// 828FDBDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FDBE0: 38A004C2  li r5, 0x4c2
	ctx.r[5].s64 = 1218;
	// 828FDBE4: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 828FDBE8: C3EB0088  lfs f31, 0x88(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FDBEC: C3CB008C  lfs f30, 0x8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828FDBF0: C3AB0090  lfs f29, 0x90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828FDBF4: 484F47F5  bl 0x82df23e8
	ctx.lr = 0x828FDBF8;
	sub_82DF23E8(ctx, base);
	// 828FDBF8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FDBFC: 41820050  beq 0x828fdc4c
	if ctx.cr[0].eq {
	pc = 0x828FDC4C; continue 'dispatch;
	}
	// 828FDC00: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828FDC04: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828FDC08: 419A000C  beq cr6, 0x828fdc14
	if ctx.cr[6].eq {
	pc = 0x828FDC14; continue 'dispatch;
	}
	// 828FDC0C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FDC10: 4B9EA639  bl 0x822e8248
	ctx.lr = 0x828FDC14;
	sub_822E8248(ctx, base);
	// 828FDC14: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828FDC18: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 828FDC1C: 4870B39D  bl 0x83008fb8
	ctx.lr = 0x828FDC20;
	sub_83008FB8(ctx, base);
	// 828FDC20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDC24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FDC28: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FDC2C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828FDC30: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828FDC34: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828FDC38: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828FDC3C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828FDC40: 4BECCE19  bl 0x827caa58
	ctx.lr = 0x828FDC44;
	sub_827CAA58(ctx, base);
	// 828FDC44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDC48: 48000008  b 0x828fdc50
	pc = 0x828FDC50; continue 'dispatch;
	// 828FDC4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FDC50: 387F0438  addi r3, r31, 0x438
	ctx.r[3].s64 = ctx.r[31].s64 + 1080;
	// 828FDC54: 4BF0A81D  bl 0x82808470
	ctx.lr = 0x828FDC58;
	sub_82808470(ctx, base);
	// 828FDC58: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828FDC5C: 419A000C  beq cr6, 0x828fdc68
	if ctx.cr[6].eq {
	pc = 0x828FDC68; continue 'dispatch;
	}
	// 828FDC60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FDC64: 4B9EA605  bl 0x822e8268
	ctx.lr = 0x828FDC68;
	sub_822E8268(ctx, base);
	// 828FDC68: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828FDC6C: 419A000C  beq cr6, 0x828fdc78
	if ctx.cr[6].eq {
	pc = 0x828FDC78; continue 'dispatch;
	}
	// 828FDC70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828FDC74: 4B9C2C1D  bl 0x822c0890
	ctx.lr = 0x828FDC78;
	sub_822C0890(ctx, base);
	// 828FDC78: 817F0438  lwz r11, 0x438(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) } as u64;
	// 828FDC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDC80: 419A00AC  beq cr6, 0x828fdd2c
	if ctx.cr[6].eq {
	pc = 0x828FDD2C; continue 'dispatch;
	}
	// 828FDC84: 817F043C  lwz r11, 0x43c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) } as u64;
	// 828FDC88: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828FDC8C: 815F0438  lwz r10, 0x438(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) } as u64;
	// 828FDC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDC94: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FDC98: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828FDC9C: 419A0024  beq cr6, 0x828fdcc0
	if ctx.cr[6].eq {
	pc = 0x828FDCC0; continue 'dispatch;
	}
	// 828FDCA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FDCA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FDCA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FDCAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FDCB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FDCB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FDCB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FDCBC: 4082FFE8  bne 0x828fdca4
	if !ctx.cr[0].eq {
	pc = 0x828FDCA4; continue 'dispatch;
	}
	// 828FDCC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FDCC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FDCC8: 4BC11801  bl 0x8250f4c8
	ctx.lr = 0x828FDCCC;
	sub_8250F4C8(ctx, base);
	// 828FDCCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDCD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDCD4: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 828FDCD8: 409A0008  bne cr6, 0x828fdce0
	if !ctx.cr[6].eq {
	pc = 0x828FDCE0; continue 'dispatch;
	}
	// 828FDCDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828FDCE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FDCE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FDCE8: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828FDCEC: 4BC1182D  bl 0x8250f518
	ctx.lr = 0x828FDCF0;
	sub_8250F518(ctx, base);
	// 828FDCF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDCF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FDCF8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828FDCFC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828FDD00: 4BC0F809  bl 0x8250d508
	ctx.lr = 0x828FDD04;
	sub_8250D508(ctx, base);
	// 828FDD04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FDD08: 484F3F89  bl 0x82df1c90
	ctx.lr = 0x828FDD0C;
	sub_82DF1C90(ctx, base);
	// 828FDD0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FDD10: 484F3F81  bl 0x82df1c90
	ctx.lr = 0x828FDD14;
	sub_82DF1C90(ctx, base);
	// 828FDD14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828FDD18: 807F0438  lwz r3, 0x438(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) } as u64;
	// 828FDD1C: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FDD20: 4BECC259  bl 0x827c9f78
	ctx.lr = 0x828FDD24;
	sub_827C9F78(ctx, base);
	// 828FDD24: 807F0438  lwz r3, 0x438(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) } as u64;
	// 828FDD28: 4BECCB11  bl 0x827ca838
	ctx.lr = 0x828FDD2C;
	sub_827CA838(ctx, base);
	// 828FDD2C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828FDD30: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828FDD34: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828FDD38: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828FDD3C: 488AA470  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FDD40 size=80
    let mut pc: u32 = 0x828FDD40;
    'dispatch: loop {
        match pc {
            0x828FDD40 => {
    //   block [0x828FDD40..0x828FDD90)
	// 828FDD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FDD44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FDD48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FDD4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FDD50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDD54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FDD58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FDD5C: 807F0438  lwz r3, 0x438(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) } as u64;
	// 828FDD60: 4BECC211  bl 0x827c9f70
	ctx.lr = 0x828FDD64;
	sub_827C9F70(ctx, base);
	// 828FDD64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDD68: 40820010  bne 0x828fdd78
	if !ctx.cr[0].eq {
	pc = 0x828FDD78; continue 'dispatch;
	}
	// 828FDD6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FDD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDD74: 4BFFF895  bl 0x828fd608
	ctx.lr = 0x828FDD78;
	sub_828FD608(ctx, base);
	// 828FDD78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FDD7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FDD80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FDD84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FDD88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FDD8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FDD90 size=24
    let mut pc: u32 = 0x828FDD90;
    'dispatch: loop {
        match pc {
            0x828FDD90 => {
    //   block [0x828FDD90..0x828FDDA8)
	// 828FDD90: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FDD94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDD98: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDD9C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FDDA0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FDDA4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FDDA8 size=276
    let mut pc: u32 = 0x828FDDA8;
    'dispatch: loop {
        match pc {
            0x828FDDA8 => {
    //   block [0x828FDDA8..0x828FDEBC)
	// 828FDDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FDDAC: 488AA3BD  bl 0x831a8168
	ctx.lr = 0x828FDDB0;
	sub_831A8130(ctx, base);
	// 828FDDB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDDB4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828FDDB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FDDBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FDDC0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828FDDC4: 41820038  beq 0x828fddfc
	if ctx.cr[0].eq {
	pc = 0x828FDDFC; continue 'dispatch;
	}
	// 828FDDC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDDCC: 488ABBBD  bl 0x831a9988
	ctx.lr = 0x828FDDD0;
	sub_831A9988(ctx, base);
	// 828FDDD0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828FDDD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDDD8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828FDDDC: 488AA31D  bl 0x831a80f8
	ctx.lr = 0x828FDDE0;
	sub_831A80F8(ctx, base);
	// 828FDDE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDDE4: 41820018  beq 0x828fddfc
	if ctx.cr[0].eq {
	pc = 0x828FDDFC; continue 'dispatch;
	}
	// 828FDDE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FDDEC: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828FDDF0: 4BFFF819  bl 0x828fd608
	ctx.lr = 0x828FDDF4;
	sub_828FD608(ctx, base);
	// 828FDDF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FDDF8: 480000BC  b 0x828fdeb4
	pc = 0x828FDEB4; continue 'dispatch;
	// 828FDDFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FDE00: 419A00A4  beq cr6, 0x828fdea4
	if ctx.cr[6].eq {
	pc = 0x828FDEA4; continue 'dispatch;
	}
	// 828FDE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDE08: 488ABB81  bl 0x831a9988
	ctx.lr = 0x828FDE0C;
	sub_831A9988(ctx, base);
	// 828FDE0C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828FDE10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDE14: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828FDE18: 488AA2E1  bl 0x831a80f8
	ctx.lr = 0x828FDE1C;
	sub_831A80F8(ctx, base);
	// 828FDE1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDE20: 41820014  beq 0x828fde34
	if ctx.cr[0].eq {
	pc = 0x828FDE34; continue 'dispatch;
	}
	// 828FDE24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FDE28: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828FDE2C: 480062AD  bl 0x829040d8
	ctx.lr = 0x828FDE30;
	sub_829040D8(ctx, base);
	// 828FDE30: 4BFFFFC4  b 0x828fddf4
	pc = 0x828FDDF4; continue 'dispatch;
	// 828FDE34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FDE38: 419A006C  beq cr6, 0x828fdea4
	if ctx.cr[6].eq {
	pc = 0x828FDEA4; continue 'dispatch;
	}
	// 828FDE3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDE40: 488ABB49  bl 0x831a9988
	ctx.lr = 0x828FDE44;
	sub_831A9988(ctx, base);
	// 828FDE44: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828FDE48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDE4C: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828FDE50: 488AA2A9  bl 0x831a80f8
	ctx.lr = 0x828FDE54;
	sub_831A80F8(ctx, base);
	// 828FDE54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDE58: 41820014  beq 0x828fde6c
	if ctx.cr[0].eq {
	pc = 0x828FDE6C; continue 'dispatch;
	}
	// 828FDE5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FDE60: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828FDE64: 4BFFDCC5  bl 0x828fbb28
	ctx.lr = 0x828FDE68;
	sub_828FBB28(ctx, base);
	// 828FDE68: 4BFFFF8C  b 0x828fddf4
	pc = 0x828FDDF4; continue 'dispatch;
	// 828FDE6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FDE70: 419A0034  beq cr6, 0x828fdea4
	if ctx.cr[6].eq {
	pc = 0x828FDEA4; continue 'dispatch;
	}
	// 828FDE74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDE78: 488ABB11  bl 0x831a9988
	ctx.lr = 0x828FDE7C;
	sub_831A9988(ctx, base);
	// 828FDE7C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828FDE80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDE84: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828FDE88: 488AA271  bl 0x831a80f8
	ctx.lr = 0x828FDE8C;
	sub_831A80F8(ctx, base);
	// 828FDE8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDE90: 41820014  beq 0x828fdea4
	if ctx.cr[0].eq {
	pc = 0x828FDEA4; continue 'dispatch;
	}
	// 828FDE94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FDE98: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828FDE9C: 4BFFDDBD  bl 0x828fbc58
	ctx.lr = 0x828FDEA0;
	sub_828FBC58(ctx, base);
	// 828FDEA0: 4BFFFF54  b 0x828fddf4
	pc = 0x828FDDF4; continue 'dispatch;
	// 828FDEA4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828FDEA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FDEAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FDEB0: 480610A9  bl 0x8295ef58
	ctx.lr = 0x828FDEB4;
	sub_8295EF58(ctx, base);
	// 828FDEB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FDEB8: 488AA300  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FDEC0 size=4
    let mut pc: u32 = 0x828FDEC0;
    'dispatch: loop {
        match pc {
            0x828FDEC0 => {
    //   block [0x828FDEC0..0x828FDEC4)
	// 828FDEC0: 4BFFFEE8  b 0x828fdda8
	sub_828FDDA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FDEC8 size=108
    let mut pc: u32 = 0x828FDEC8;
    'dispatch: loop {
        match pc {
            0x828FDEC8 => {
    //   block [0x828FDEC8..0x828FDF34)
	// 828FDEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FDECC: 488AA2A1  bl 0x831a816c
	ctx.lr = 0x828FDED0;
	sub_831A8130(ctx, base);
	// 828FDED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDED4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828FDED8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FDEDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FDEE0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDEE4: 41820038  beq 0x828fdf1c
	if ctx.cr[0].eq {
	pc = 0x828FDF1C; continue 'dispatch;
	}
	// 828FDEE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDEEC: 488ABA9D  bl 0x831a9988
	ctx.lr = 0x828FDEF0;
	sub_831A9988(ctx, base);
	// 828FDEF0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828FDEF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FDEF8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828FDEFC: 488AA1FD  bl 0x831a80f8
	ctx.lr = 0x828FDF00;
	sub_831A80F8(ctx, base);
	// 828FDF00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDF04: 41820018  beq 0x828fdf1c
	if ctx.cr[0].eq {
	pc = 0x828FDF1C; continue 'dispatch;
	}
	// 828FDF08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FDF0C: 387DFFC8  addi r3, r29, -0x38
	ctx.r[3].s64 = ctx.r[29].s64 + -56;
	// 828FDF10: 4BFFFE31  bl 0x828fdd40
	ctx.lr = 0x828FDF14;
	sub_828FDD40(ctx, base);
	// 828FDF14: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FDF18: 48000014  b 0x828fdf2c
	pc = 0x828FDF2C; continue 'dispatch;
	// 828FDF1C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FDF20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FDF24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FDF28: 4BFFFE81  bl 0x828fdda8
	ctx.lr = 0x828FDF2C;
	sub_828FDDA8(ctx, base);
	// 828FDF2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FDF30: 488AA28C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FDF38 size=128
    let mut pc: u32 = 0x828FDF38;
    'dispatch: loop {
        match pc {
            0x828FDF38 => {
    //   block [0x828FDF38..0x828FDFB8)
	// 828FDF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FDF3C: 488AA231  bl 0x831a816c
	ctx.lr = 0x828FDF40;
	sub_831A8130(ctx, base);
	// 828FDF40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDF44: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FDF48: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FDF4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FDF50: 3BEBACB4  addi r31, r11, -0x534c
	ctx.r[31].s64 = ctx.r[11].s64 + -21324;
	// 828FDF54: 816AACBC  lwz r11, -0x5344(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21316 as u32) ) } as u64;
	// 828FDF58: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FDF5C: 40820024  bne 0x828fdf80
	if !ctx.cr[0].eq {
	pc = 0x828FDF80; continue 'dispatch;
	}
	// 828FDF60: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828FDF64: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 828FDF68: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828FDF6C: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828FDF70: 3908C268  addi r8, r8, -0x3d98
	ctx.r[8].s64 = ctx.r[8].s64 + -15768;
	// 828FDF74: 916AACBC  stw r11, -0x5344(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21316 as u32), ctx.r[11].u32 ) };
	// 828FDF78: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828FDF7C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FDF80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FDF84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FDF88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDF8C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828FDF90: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828FDF94: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FDF98: 4BFC9941  bl 0x828c78d8
	ctx.lr = 0x828FDF9C;
	sub_828C78D8(ctx, base);
	// 828FDF9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDFA0: 4182000C  beq 0x828fdfac
	if ctx.cr[0].eq {
	pc = 0x828FDFAC; continue 'dispatch;
	}
	// 828FDFA4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FDFA8: 48000008  b 0x828fdfb0
	pc = 0x828FDFB0; continue 'dispatch;
	// 828FDFAC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828FDFB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FDFB4: 488AA208  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FDFB8 size=492
    let mut pc: u32 = 0x828FDFB8;
    'dispatch: loop {
        match pc {
            0x828FDFB8 => {
    //   block [0x828FDFB8..0x828FE1A4)
	// 828FDFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FDFBC: 488AA1A9  bl 0x831a8164
	ctx.lr = 0x828FDFC0;
	sub_831A8130(ctx, base);
	// 828FDFC0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828FDFC4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDFC8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FDFCC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FDFD0: 3BCB45A8  addi r30, r11, 0x45a8
	ctx.r[30].s64 = ctx.r[11].s64 + 17832;
	// 828FDFD4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828FDFD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FDFDC: 38A0036F  li r5, 0x36f
	ctx.r[5].s64 = 879;
	// 828FDFE0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828FDFE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FDFE8: 386003D0  li r3, 0x3d0
	ctx.r[3].s64 = 976;
	// 828FDFEC: 484F43FD  bl 0x82df23e8
	ctx.lr = 0x828FDFF0;
	sub_82DF23E8(ctx, base);
	// 828FDFF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FDFF4: 41820020  beq 0x828fe014
	if ctx.cr[0].eq {
	pc = 0x828FE014; continue 'dispatch;
	}
	// 828FDFF8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828FDFFC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FE000: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828FE004: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828FE008: 4BFFEDB9  bl 0x828fcdc0
	ctx.lr = 0x828FE00C;
	sub_828FCDC0(ctx, base);
	// 828FE00C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FE010: 48000008  b 0x828fe018
	pc = 0x828FE018; continue 'dispatch;
	// 828FE014: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FE018: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828FE01C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE020: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE024: 4BFFDE75  bl 0x828fbe98
	ctx.lr = 0x828FE028;
	sub_828FBE98(ctx, base);
	// 828FE028: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FE02C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE030: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE034: 4B9C1FCD  bl 0x822c0000
	ctx.lr = 0x828FE038;
	sub_822C0000(ctx, base);
	// 828FE038: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE03C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FE040: 38A00370  li r5, 0x370
	ctx.r[5].s64 = 880;
	// 828FE044: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828FE048: 4B9C2391  bl 0x822c03d8
	ctx.lr = 0x828FE04C;
	sub_822C03D8(ctx, base);
	// 828FE04C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FE050: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828FE054: 418200E0  beq 0x828fe134
	if ctx.cr[0].eq {
	pc = 0x828FE134; continue 'dispatch;
	}
	// 828FE058: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FE05C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE060: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FE064: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828FE068: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828FE06C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE070: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FE074: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828FE078: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE07C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828FE080: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828FE084: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828FE088: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828FE08C: 419A0024  beq cr6, 0x828fe0b0
	if ctx.cr[6].eq {
	pc = 0x828FE0B0; continue 'dispatch;
	}
	// 828FE090: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 828FE094: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828FE098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE09C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828FE0A0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828FE0A4: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE0A8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE0AC: 4082FFE8  bne 0x828fe094
	if !ctx.cr[0].eq {
	pc = 0x828FE094; continue 'dispatch;
	}
	// 828FE0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE0B4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828FE0B8: 409A0008  bne cr6, 0x828fe0c0
	if !ctx.cr[6].eq {
	pc = 0x828FE0C0; continue 'dispatch;
	}
	// 828FE0BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FE0C0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828FE0C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE0C8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828FE0CC: 419A0024  beq cr6, 0x828fe0f0
	if ctx.cr[6].eq {
	pc = 0x828FE0F0; continue 'dispatch;
	}
	// 828FE0D0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828FE0D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FE0D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE0DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FE0E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FE0E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE0E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE0EC: 4082FFE8  bne 0x828fe0d4
	if !ctx.cr[0].eq {
	pc = 0x828FE0D4; continue 'dispatch;
	}
	// 828FE0F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828FE0F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FE0F8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FE0FC: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FE100: 4857EB41  bl 0x82e7cc40
	ctx.lr = 0x828FE104;
	sub_82E7CC40(ctx, base);
	// 828FE104: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828FE108: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FE10C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828FE110: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FE114: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828FE118: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FE11C: 4BE9AE15  bl 0x82798f30
	ctx.lr = 0x828FE120;
	sub_82798F30(ctx, base);
	// 828FE120: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FE124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FE128: 4BE9D541  bl 0x8279b668
	ctx.lr = 0x828FE12C;
	sub_8279B668(ctx, base);
	// 828FE12C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FE130: 48000008  b 0x828fe138
	pc = 0x828FE138; continue 'dispatch;
	// 828FE134: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FE138: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FE13C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828FE140: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE144: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE148: 4BC99B09  bl 0x82597c50
	ctx.lr = 0x828FE14C;
	sub_82597C50(ctx, base);
	// 828FE14C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FE150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE158: 4B9C1EA9  bl 0x822c0000
	ctx.lr = 0x828FE15C;
	sub_822C0000(ctx, base);
	// 828FE15C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE160: 41820024  beq 0x828fe184
	if ctx.cr[0].eq {
	pc = 0x828FE184; continue 'dispatch;
	}
	// 828FE164: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828FE168: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE16C: 419A0008  beq cr6, 0x828fe174
	if ctx.cr[6].eq {
	pc = 0x828FE174; continue 'dispatch;
	}
	// 828FE170: 4B9C2721  bl 0x822c0890
	ctx.lr = 0x828FE174;
	sub_822C0890(ctx, base);
	// 828FE174: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828FE178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE17C: 419A0008  beq cr6, 0x828fe184
	if ctx.cr[6].eq {
	pc = 0x828FE184; continue 'dispatch;
	}
	// 828FE180: 4B9C2711  bl 0x822c0890
	ctx.lr = 0x828FE184;
	sub_822C0890(ctx, base);
	// 828FE184: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE188: 419A000C  beq cr6, 0x828fe194
	if ctx.cr[6].eq {
	pc = 0x828FE194; continue 'dispatch;
	}
	// 828FE18C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE190: 4B9C2701  bl 0x822c0890
	ctx.lr = 0x828FE194;
	sub_822C0890(ctx, base);
	// 828FE194: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FE198: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828FE19C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828FE1A0: 488AA014  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FE1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FE1A8 size=492
    let mut pc: u32 = 0x828FE1A8;
    'dispatch: loop {
        match pc {
            0x828FE1A8 => {
    //   block [0x828FE1A8..0x828FE394)
	// 828FE1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FE1AC: 488A9FB9  bl 0x831a8164
	ctx.lr = 0x828FE1B0;
	sub_831A8130(ctx, base);
	// 828FE1B0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828FE1B4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FE1B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FE1BC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FE1C0: 3BCB45A8  addi r30, r11, 0x45a8
	ctx.r[30].s64 = ctx.r[11].s64 + 17832;
	// 828FE1C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828FE1C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FE1CC: 38A003B5  li r5, 0x3b5
	ctx.r[5].s64 = 949;
	// 828FE1D0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828FE1D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE1D8: 386003D0  li r3, 0x3d0
	ctx.r[3].s64 = 976;
	// 828FE1DC: 484F420D  bl 0x82df23e8
	ctx.lr = 0x828FE1E0;
	sub_82DF23E8(ctx, base);
	// 828FE1E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FE1E4: 41820020  beq 0x828fe204
	if ctx.cr[0].eq {
	pc = 0x828FE204; continue 'dispatch;
	}
	// 828FE1E8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828FE1EC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FE1F0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828FE1F4: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828FE1F8: 4BFFECB1  bl 0x828fcea8
	ctx.lr = 0x828FE1FC;
	sub_828FCEA8(ctx, base);
	// 828FE1FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FE200: 48000008  b 0x828fe208
	pc = 0x828FE208; continue 'dispatch;
	// 828FE204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FE208: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828FE20C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE210: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE214: 4BFFDD4D  bl 0x828fbf60
	ctx.lr = 0x828FE218;
	sub_828FBF60(ctx, base);
	// 828FE218: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FE21C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE220: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE224: 4B9C1DDD  bl 0x822c0000
	ctx.lr = 0x828FE228;
	sub_822C0000(ctx, base);
	// 828FE228: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE22C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FE230: 38A003B6  li r5, 0x3b6
	ctx.r[5].s64 = 950;
	// 828FE234: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828FE238: 4B9C21A1  bl 0x822c03d8
	ctx.lr = 0x828FE23C;
	sub_822C03D8(ctx, base);
	// 828FE23C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FE240: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828FE244: 418200E0  beq 0x828fe324
	if ctx.cr[0].eq {
	pc = 0x828FE324; continue 'dispatch;
	}
	// 828FE248: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FE24C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE250: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FE254: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828FE258: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828FE25C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE260: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FE264: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828FE268: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE26C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828FE270: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828FE274: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828FE278: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828FE27C: 419A0024  beq cr6, 0x828fe2a0
	if ctx.cr[6].eq {
	pc = 0x828FE2A0; continue 'dispatch;
	}
	// 828FE280: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 828FE284: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828FE288: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE28C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828FE290: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828FE294: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE298: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE29C: 4082FFE8  bne 0x828fe284
	if !ctx.cr[0].eq {
	pc = 0x828FE284; continue 'dispatch;
	}
	// 828FE2A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE2A4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828FE2A8: 409A0008  bne cr6, 0x828fe2b0
	if !ctx.cr[6].eq {
	pc = 0x828FE2B0; continue 'dispatch;
	}
	// 828FE2AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FE2B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828FE2B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE2B8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828FE2BC: 419A0024  beq cr6, 0x828fe2e0
	if ctx.cr[6].eq {
	pc = 0x828FE2E0; continue 'dispatch;
	}
	// 828FE2C0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828FE2C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FE2C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE2CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FE2D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FE2D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE2D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE2DC: 4082FFE8  bne 0x828fe2c4
	if !ctx.cr[0].eq {
	pc = 0x828FE2C4; continue 'dispatch;
	}
	// 828FE2E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828FE2E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FE2E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FE2EC: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FE2F0: 4857E951  bl 0x82e7cc40
	ctx.lr = 0x828FE2F4;
	sub_82E7CC40(ctx, base);
	// 828FE2F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828FE2F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FE2FC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828FE300: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FE304: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828FE308: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FE30C: 4BE9AC25  bl 0x82798f30
	ctx.lr = 0x828FE310;
	sub_82798F30(ctx, base);
	// 828FE310: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FE314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FE318: 4BE9D351  bl 0x8279b668
	ctx.lr = 0x828FE31C;
	sub_8279B668(ctx, base);
	// 828FE31C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FE320: 48000008  b 0x828fe328
	pc = 0x828FE328; continue 'dispatch;
	// 828FE324: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FE328: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FE32C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828FE330: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE338: 4BC99919  bl 0x82597c50
	ctx.lr = 0x828FE33C;
	sub_82597C50(ctx, base);
	// 828FE33C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FE340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE348: 4B9C1CB9  bl 0x822c0000
	ctx.lr = 0x828FE34C;
	sub_822C0000(ctx, base);
	// 828FE34C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE350: 41820024  beq 0x828fe374
	if ctx.cr[0].eq {
	pc = 0x828FE374; continue 'dispatch;
	}
	// 828FE354: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828FE358: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE35C: 419A0008  beq cr6, 0x828fe364
	if ctx.cr[6].eq {
	pc = 0x828FE364; continue 'dispatch;
	}
	// 828FE360: 4B9C2531  bl 0x822c0890
	ctx.lr = 0x828FE364;
	sub_822C0890(ctx, base);
	// 828FE364: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828FE368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE36C: 419A0008  beq cr6, 0x828fe374
	if ctx.cr[6].eq {
	pc = 0x828FE374; continue 'dispatch;
	}
	// 828FE370: 4B9C2521  bl 0x822c0890
	ctx.lr = 0x828FE374;
	sub_822C0890(ctx, base);
	// 828FE374: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE378: 419A000C  beq cr6, 0x828fe384
	if ctx.cr[6].eq {
	pc = 0x828FE384; continue 'dispatch;
	}
	// 828FE37C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE380: 4B9C2511  bl 0x822c0890
	ctx.lr = 0x828FE384;
	sub_822C0890(ctx, base);
	// 828FE384: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FE388: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828FE38C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828FE390: 488A9E24  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FE398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FE398 size=492
    let mut pc: u32 = 0x828FE398;
    'dispatch: loop {
        match pc {
            0x828FE398 => {
    //   block [0x828FE398..0x828FE584)
	// 828FE398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FE39C: 488A9DC9  bl 0x831a8164
	ctx.lr = 0x828FE3A0;
	sub_831A8130(ctx, base);
	// 828FE3A0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828FE3A4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FE3A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FE3AC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FE3B0: 3BCB45A8  addi r30, r11, 0x45a8
	ctx.r[30].s64 = ctx.r[11].s64 + 17832;
	// 828FE3B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828FE3B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FE3BC: 38A0043F  li r5, 0x43f
	ctx.r[5].s64 = 1087;
	// 828FE3C0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828FE3C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE3C8: 38600450  li r3, 0x450
	ctx.r[3].s64 = 1104;
	// 828FE3CC: 484F401D  bl 0x82df23e8
	ctx.lr = 0x828FE3D0;
	sub_82DF23E8(ctx, base);
	// 828FE3D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FE3D4: 41820020  beq 0x828fe3f4
	if ctx.cr[0].eq {
	pc = 0x828FE3F4; continue 'dispatch;
	}
	// 828FE3D8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828FE3DC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FE3E0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828FE3E4: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828FE3E8: 4BFFEE61  bl 0x828fd248
	ctx.lr = 0x828FE3EC;
	sub_828FD248(ctx, base);
	// 828FE3EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FE3F0: 48000008  b 0x828fe3f8
	pc = 0x828FE3F8; continue 'dispatch;
	// 828FE3F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FE3F8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828FE3FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE400: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE404: 4BFFDC25  bl 0x828fc028
	ctx.lr = 0x828FE408;
	sub_828FC028(ctx, base);
	// 828FE408: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FE40C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE410: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE414: 4B9C1BED  bl 0x822c0000
	ctx.lr = 0x828FE418;
	sub_822C0000(ctx, base);
	// 828FE418: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE41C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FE420: 38A00440  li r5, 0x440
	ctx.r[5].s64 = 1088;
	// 828FE424: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828FE428: 4B9C1FB1  bl 0x822c03d8
	ctx.lr = 0x828FE42C;
	sub_822C03D8(ctx, base);
	// 828FE42C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FE430: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828FE434: 418200E0  beq 0x828fe514
	if ctx.cr[0].eq {
	pc = 0x828FE514; continue 'dispatch;
	}
	// 828FE438: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FE43C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE440: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FE444: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828FE448: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828FE44C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE450: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FE454: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828FE458: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE45C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828FE460: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828FE464: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828FE468: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828FE46C: 419A0024  beq cr6, 0x828fe490
	if ctx.cr[6].eq {
	pc = 0x828FE490; continue 'dispatch;
	}
	// 828FE470: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 828FE474: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828FE478: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE47C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828FE480: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828FE484: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE488: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE48C: 4082FFE8  bne 0x828fe474
	if !ctx.cr[0].eq {
	pc = 0x828FE474; continue 'dispatch;
	}
	// 828FE490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE494: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828FE498: 409A0008  bne cr6, 0x828fe4a0
	if !ctx.cr[6].eq {
	pc = 0x828FE4A0; continue 'dispatch;
	}
	// 828FE49C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FE4A0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828FE4A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE4A8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828FE4AC: 419A0024  beq cr6, 0x828fe4d0
	if ctx.cr[6].eq {
	pc = 0x828FE4D0; continue 'dispatch;
	}
	// 828FE4B0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828FE4B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FE4B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE4BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FE4C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FE4C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE4C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE4CC: 4082FFE8  bne 0x828fe4b4
	if !ctx.cr[0].eq {
	pc = 0x828FE4B4; continue 'dispatch;
	}
	// 828FE4D0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828FE4D4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FE4D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FE4DC: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FE4E0: 4857E761  bl 0x82e7cc40
	ctx.lr = 0x828FE4E4;
	sub_82E7CC40(ctx, base);
	// 828FE4E4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828FE4E8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FE4EC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828FE4F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FE4F4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828FE4F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FE4FC: 4BE9AA35  bl 0x82798f30
	ctx.lr = 0x828FE500;
	sub_82798F30(ctx, base);
	// 828FE500: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FE504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FE508: 4BE9D161  bl 0x8279b668
	ctx.lr = 0x828FE50C;
	sub_8279B668(ctx, base);
	// 828FE50C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FE510: 48000008  b 0x828fe518
	pc = 0x828FE518; continue 'dispatch;
	// 828FE514: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FE518: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FE51C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828FE520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE528: 4BC99729  bl 0x82597c50
	ctx.lr = 0x828FE52C;
	sub_82597C50(ctx, base);
	// 828FE52C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FE530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE538: 4B9C1AC9  bl 0x822c0000
	ctx.lr = 0x828FE53C;
	sub_822C0000(ctx, base);
	// 828FE53C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE540: 41820024  beq 0x828fe564
	if ctx.cr[0].eq {
	pc = 0x828FE564; continue 'dispatch;
	}
	// 828FE544: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828FE548: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE54C: 419A0008  beq cr6, 0x828fe554
	if ctx.cr[6].eq {
	pc = 0x828FE554; continue 'dispatch;
	}
	// 828FE550: 4B9C2341  bl 0x822c0890
	ctx.lr = 0x828FE554;
	sub_822C0890(ctx, base);
	// 828FE554: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828FE558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE55C: 419A0008  beq cr6, 0x828fe564
	if ctx.cr[6].eq {
	pc = 0x828FE564; continue 'dispatch;
	}
	// 828FE560: 4B9C2331  bl 0x822c0890
	ctx.lr = 0x828FE564;
	sub_822C0890(ctx, base);
	// 828FE564: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE568: 419A000C  beq cr6, 0x828fe574
	if ctx.cr[6].eq {
	pc = 0x828FE574; continue 'dispatch;
	}
	// 828FE56C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE570: 4B9C2321  bl 0x822c0890
	ctx.lr = 0x828FE574;
	sub_822C0890(ctx, base);
	// 828FE574: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FE578: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828FE57C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828FE580: 488A9C34  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FE588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FE588 size=128
    let mut pc: u32 = 0x828FE588;
    'dispatch: loop {
        match pc {
            0x828FE588 => {
    //   block [0x828FE588..0x828FE608)
	// 828FE588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FE58C: 488A9BE1  bl 0x831a816c
	ctx.lr = 0x828FE590;
	sub_831A8130(ctx, base);
	// 828FE590: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FE594: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FE598: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FE59C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FE5A0: 3BEBACC0  addi r31, r11, -0x5340
	ctx.r[31].s64 = ctx.r[11].s64 + -21312;
	// 828FE5A4: 816AACC8  lwz r11, -0x5338(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21304 as u32) ) } as u64;
	// 828FE5A8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FE5AC: 40820024  bne 0x828fe5d0
	if !ctx.cr[0].eq {
	pc = 0x828FE5D0; continue 'dispatch;
	}
	// 828FE5B0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828FE5B4: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 828FE5B8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828FE5BC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828FE5C0: 3908CBA8  addi r8, r8, -0x3458
	ctx.r[8].s64 = ctx.r[8].s64 + -13400;
	// 828FE5C4: 916AACC8  stw r11, -0x5338(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21304 as u32), ctx.r[11].u32 ) };
	// 828FE5C8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828FE5CC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FE5D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FE5D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FE5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FE5DC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828FE5E0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828FE5E4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE5E8: 4BD55FD9  bl 0x826545c0
	ctx.lr = 0x828FE5EC;
	sub_826545C0(ctx, base);
	// 828FE5EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE5F0: 4182000C  beq 0x828fe5fc
	if ctx.cr[0].eq {
	pc = 0x828FE5FC; continue 'dispatch;
	}
	// 828FE5F4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FE5F8: 48000008  b 0x828fe600
	pc = 0x828FE600; continue 'dispatch;
	// 828FE5FC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828FE600: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FE604: 488A9BB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FE608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FE608 size=128
    let mut pc: u32 = 0x828FE608;
    'dispatch: loop {
        match pc {
            0x828FE608 => {
    //   block [0x828FE608..0x828FE688)
	// 828FE608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FE60C: 488A9B61  bl 0x831a816c
	ctx.lr = 0x828FE610;
	sub_831A8130(ctx, base);
	// 828FE610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FE614: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828FE618: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FE61C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FE620: 3BEBACCC  addi r31, r11, -0x5334
	ctx.r[31].s64 = ctx.r[11].s64 + -21300;
	// 828FE624: 816AACD4  lwz r11, -0x532c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21292 as u32) ) } as u64;
	// 828FE628: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FE62C: 40820024  bne 0x828fe650
	if !ctx.cr[0].eq {
	pc = 0x828FE650; continue 'dispatch;
	}
	// 828FE630: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 828FE634: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 828FE638: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828FE63C: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 828FE640: 3908CBF0  addi r8, r8, -0x3410
	ctx.r[8].s64 = ctx.r[8].s64 + -13328;
	// 828FE644: 916AACD4  stw r11, -0x532c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21292 as u32), ctx.r[11].u32 ) };
	// 828FE648: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828FE64C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FE650: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FE654: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FE658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FE65C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828FE660: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828FE664: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE668: 4BD55F59  bl 0x826545c0
	ctx.lr = 0x828FE66C;
	sub_826545C0(ctx, base);
	// 828FE66C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE670: 4182000C  beq 0x828fe67c
	if ctx.cr[0].eq {
	pc = 0x828FE67C; continue 'dispatch;
	}
	// 828FE674: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FE678: 48000008  b 0x828fe680
	pc = 0x828FE680; continue 'dispatch;
	// 828FE67C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828FE680: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FE684: 488A9B38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FE688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FE688 size=4172
    let mut pc: u32 = 0x828FE688;
    'dispatch: loop {
        match pc {
            0x828FE688 => {
    //   block [0x828FE688..0x828FF6D4)
	// 828FE688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FE68C: 488A9AA5  bl 0x831a8130
	ctx.lr = 0x828FE690;
	sub_831A8130(ctx, base);
	// 828FE690: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 828FE694: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 828FE698: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 828FE69C: 9421FC00  stwu r1, -0x400(r1)
	ea = ctx.r[1].u32.wrapping_add(-1024 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FE6A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FE6A4: 90A10424  stw r5, 0x424(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1060 as u32), ctx.r[5].u32 ) };
	// 828FE6A8: 7CCE3378  mr r14, r6
	ctx.r[14].u64 = ctx.r[6].u64;
	// 828FE6AC: 480607A5  bl 0x8295ee50
	ctx.lr = 0x828FE6B0;
	sub_8295EE50(ctx, base);
	// 828FE6B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FE6B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FE6B8: 3A2B45A8  addi r17, r11, 0x45a8
	ctx.r[17].s64 = ctx.r[11].s64 + 17832;
	// 828FE6BC: 38A000DB  li r5, 0xdb
	ctx.r[5].s64 = 219;
	// 828FE6C0: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828FE6C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828FE6C8: 484F3D21  bl 0x82df23e8
	ctx.lr = 0x828FE6CC;
	sub_82DF23E8(ctx, base);
	// 828FE6CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FE6D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FE6D4: 41820024  beq 0x828fe6f8
	if ctx.cr[0].eq {
	pc = 0x828FE6F8; continue 'dispatch;
	}
	// 828FE6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE6DC: 485137FD  bl 0x82e11ed8
	ctx.lr = 0x828FE6E0;
	sub_82E11ED8(ctx, base);
	// 828FE6E0: 397CFFF0  addi r11, r28, -0x10
	ctx.r[11].s64 = ctx.r[28].s64 + -16;
	// 828FE6E4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FE6E8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828FE6EC: 396A3B74  addi r11, r10, 0x3b74
	ctx.r[11].s64 = ctx.r[10].s64 + 15220;
	// 828FE6F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FE6F4: 48000008  b 0x828fe6fc
	pc = 0x828FE6FC; continue 'dispatch;
	// 828FE6F8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828FE6FC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828FE700: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE704: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE708: 4BFFD6C9  bl 0x828fbdd0
	ctx.lr = 0x828FE70C;
	sub_828FBDD0(ctx, base);
	// 828FE70C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FE710: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE714: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FE718: 4B9C18E9  bl 0x822c0000
	ctx.lr = 0x828FE71C;
	sub_822C0000(ctx, base);
	// 828FE71C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FE720: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE724: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FE728: 93C100AC  stw r30, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 828FE72C: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 828FE730: 419A0024  beq cr6, 0x828fe754
	if ctx.cr[6].eq {
	pc = 0x828FE754; continue 'dispatch;
	}
	// 828FE734: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828FE738: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FE73C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE740: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FE744: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FE748: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE74C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE750: 4082FFE8  bne 0x828fe738
	if !ctx.cr[0].eq {
	pc = 0x828FE738; continue 'dispatch;
	}
	// 828FE754: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828FE758: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828FE75C: 38A100A8  addi r5, r1, 0xa8
	ctx.r[5].s64 = ctx.r[1].s64 + 168;
	// 828FE760: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE764: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 828FE768: 4BC12291  bl 0x825109f8
	ctx.lr = 0x828FE76C;
	sub_825109F8(ctx, base);
	// 828FE76C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828FE770: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE774: 419A0008  beq cr6, 0x828fe77c
	if ctx.cr[6].eq {
	pc = 0x828FE77C; continue 'dispatch;
	}
	// 828FE778: 4B9C2119  bl 0x822c0890
	ctx.lr = 0x828FE77C;
	sub_822C0890(ctx, base);
	// 828FE77C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FE780: 419A000C  beq cr6, 0x828fe78c
	if ctx.cr[6].eq {
	pc = 0x828FE78C; continue 'dispatch;
	}
	// 828FE784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE788: 4B9C2109  bl 0x822c0890
	ctx.lr = 0x828FE78C;
	sub_822C0890(ctx, base);
	// 828FE78C: 817CFFF0  lwz r11, -0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828FE790: 39FCFFF0  addi r15, r28, -0x10
	ctx.r[15].s64 = ctx.r[28].s64 + -16;
	// 828FE794: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 828FE798: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE79C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FE7A0: 4E800421  bctrl
	ctx.lr = 0x828FE7A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FE7A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FE7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FE7AC: 484F525D  bl 0x82df3a08
	ctx.lr = 0x828FE7B0;
	sub_82DF3A08(ctx, base);
	// 828FE7B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FE7B4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 828FE7B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE7BC: 48011E45  bl 0x82910600
	ctx.lr = 0x828FE7C0;
	sub_82910600(ctx, base);
	// 828FE7C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FE7C4: 484F4C65  bl 0x82df3428
	ctx.lr = 0x828FE7C8;
	sub_82DF3428(ctx, base);
	// 828FE7C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE7CC: 480120F5  bl 0x829108c0
	ctx.lr = 0x828FE7D0;
	sub_829108C0(ctx, base);
	// 828FE7D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE7D4: 41820010  beq 0x828fe7e4
	if ctx.cr[0].eq {
	pc = 0x828FE7E4; continue 'dispatch;
	}
	// 828FE7D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE7DC: 4BC11DF5  bl 0x825105d0
	ctx.lr = 0x828FE7E0;
	sub_825105D0(ctx, base);
	// 828FE7E0: 48000EE0  b 0x828ff6c0
	pc = 0x828FF6C0; continue 'dispatch;
	// 828FE7E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FE7E8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828FE7EC: 4BEEDDDD  bl 0x827ec5c8
	ctx.lr = 0x828FE7F0;
	sub_827EC5C8(ctx, base);
	// 828FE7F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FE7F4: 3A0B3B40  addi r16, r11, 0x3b40
	ctx.r[16].s64 = ctx.r[11].s64 + 15168;
	// 828FE7F8: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828FE7FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE800: 419A0054  beq cr6, 0x828fe854
	if ctx.cr[6].eq {
	pc = 0x828FE854; continue 'dispatch;
	}
	// 828FE804: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828FE808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FE80C: 484F51FD  bl 0x82df3a08
	ctx.lr = 0x828FE810;
	sub_82DF3A08(ctx, base);
	// 828FE810: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FE814: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828FE818: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828FE81C: 48516815  bl 0x82e15030
	ctx.lr = 0x828FE820;
	sub_82E15030(ctx, base);
	// 828FE820: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FE824: 395C0380  addi r10, r28, 0x380
	ctx.r[10].s64 = ctx.r[28].s64 + 896;
	// 828FE828: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828FE82C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 828FE830: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE834: 917C0380  stw r11, 0x380(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 828FE838: 4B9C5C29  bl 0x822c4460
	ctx.lr = 0x828FE83C;
	sub_822C4460(ctx, base);
	// 828FE83C: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 828FE840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE844: 419A0008  beq cr6, 0x828fe84c
	if ctx.cr[6].eq {
	pc = 0x828FE84C; continue 'dispatch;
	}
	// 828FE848: 4B9C2049  bl 0x822c0890
	ctx.lr = 0x828FE84C;
	sub_822C0890(ctx, base);
	// 828FE84C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FE850: 484F4BD9  bl 0x82df3428
	ctx.lr = 0x828FE854;
	sub_82DF3428(ctx, base);
	// 828FE854: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828FE858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE85C: 419A0008  beq cr6, 0x828fe864
	if ctx.cr[6].eq {
	pc = 0x828FE864; continue 'dispatch;
	}
	// 828FE860: 4B9C2031  bl 0x822c0890
	ctx.lr = 0x828FE864;
	sub_822C0890(ctx, base);
	// 828FE864: 817C0380  lwz r11, 0x380(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(896 as u32) ) } as u64;
	// 828FE868: 3BDC0380  addi r30, r28, 0x380
	ctx.r[30].s64 = ctx.r[28].s64 + 896;
	// 828FE86C: 3FA08200  lis r29, -0x7e00
	ctx.r[29].s64 = -2113929216;
	// 828FE870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE874: 419A00E4  beq cr6, 0x828fe958
	if ctx.cr[6].eq {
	pc = 0x828FE958; continue 'dispatch;
	}
	// 828FE878: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE87C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828FE880: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828FE884: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828FE888: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828FE88C: 485A1EA5  bl 0x82ea0730
	ctx.lr = 0x828FE890;
	sub_82EA0730(ctx, base);
	// 828FE890: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828FE894: C03D08A8  lfs f1, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FE898: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828FE89C: 4861B955  bl 0x82f1a1f0
	ctx.lr = 0x828FE8A0;
	sub_82F1A1F0(ctx, base);
	// 828FE8A0: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828FE8A4: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 828FE8A8: 4182000C  beq 0x828fe8b4
	if ctx.cr[0].eq {
	pc = 0x828FE8B4; continue 'dispatch;
	}
	// 828FE8AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FE8B0: 4B9E9999  bl 0x822e8248
	ctx.lr = 0x828FE8B4;
	sub_822E8248(ctx, base);
	// 828FE8B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FE8B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FE8BC: 388B46DC  addi r4, r11, 0x46dc
	ctx.r[4].s64 = ctx.r[11].s64 + 18140;
	// 828FE8C0: 484FAC71  bl 0x82df9530
	ctx.lr = 0x828FE8C4;
	sub_82DF9530(ctx, base);
	// 828FE8C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE8C8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE8CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE8D0: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 828FE8D4: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 828FE8D8: 419A0024  beq cr6, 0x828fe8fc
	if ctx.cr[6].eq {
	pc = 0x828FE8FC; continue 'dispatch;
	}
	// 828FE8DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FE8E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FE8E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE8E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FE8EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FE8F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FE8F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FE8F8: 4082FFE8  bne 0x828fe8e0
	if !ctx.cr[0].eq {
	pc = 0x828FE8E0; continue 'dispatch;
	}
	// 828FE8FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828FE900: 38E10098  addi r7, r1, 0x98
	ctx.r[7].s64 = ctx.r[1].s64 + 152;
	// 828FE904: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 828FE908: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FE90C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE910: 80CB6820  lwz r6, 0x6820(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828FE914: 4BC147E5  bl 0x825130f8
	ctx.lr = 0x828FE918;
	sub_825130F8(ctx, base);
	// 828FE918: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FE91C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FE920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE924: 419A000C  beq cr6, 0x828fe930
	if ctx.cr[6].eq {
	pc = 0x828FE930; continue 'dispatch;
	}
	// 828FE928: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FE92C: 4B9E993D  bl 0x822e8268
	ctx.lr = 0x828FE930;
	sub_822E8268(ctx, base);
	// 828FE930: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE934: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE938: 4800A579  bl 0x82908eb0
	ctx.lr = 0x828FE93C;
	sub_82908EB0(ctx, base);
	// 828FE93C: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 828FE940: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FE944: 4BB9086D  bl 0x8248f1b0
	ctx.lr = 0x828FE948;
	sub_8248F1B0(ctx, base);
	// 828FE948: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828FE94C: 419A000C  beq cr6, 0x828fe958
	if ctx.cr[6].eq {
	pc = 0x828FE958; continue 'dispatch;
	}
	// 828FE950: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FE954: 4B9E9915  bl 0x822e8268
	ctx.lr = 0x828FE958;
	sub_822E8268(ctx, base);
	// 828FE958: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828FE95C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FE960: 3A6B7624  addi r19, r11, 0x7624
	ctx.r[19].s64 = ctx.r[11].s64 + 30244;
	// 828FE964: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828FE968: 484F50A1  bl 0x82df3a08
	ctx.lr = 0x828FE96C;
	sub_82DF3A08(ctx, base);
	// 828FE96C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FE970: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE974: 808E0000  lwz r4, 0(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE978: 48012FA9  bl 0x82911920
	ctx.lr = 0x828FE97C;
	sub_82911920(ctx, base);
	// 828FE97C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FE980: 484F4AA9  bl 0x82df3428
	ctx.lr = 0x828FE984;
	sub_82DF3428(ctx, base);
	// 828FE984: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE988: C03D08A8  lfs f1, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FE98C: 4800B15D  bl 0x82909ae8
	ctx.lr = 0x828FE990;
	sub_82909AE8(ctx, base);
	// 828FE990: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828FE994: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FE998: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 828FE99C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 828FE9A0: 4B9C1A39  bl 0x822c03d8
	ctx.lr = 0x828FE9A4;
	sub_822C03D8(ctx, base);
	// 828FE9A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FE9A8: 41820020  beq 0x828fe9c8
	if ctx.cr[0].eq {
	pc = 0x828FE9C8; continue 'dispatch;
	}
	// 828FE9AC: 357CFFF0  addic. r11, r28, -0x10
	ctx.xer.ca = (ctx.r[28].u32 > (!(-16 as u32)));
	ctx.r[11].s64 = ctx.r[28].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE9B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FE9B4: 40820008  bne 0x828fe9bc
	if !ctx.cr[0].eq {
	pc = 0x828FE9BC; continue 'dispatch;
	}
	// 828FE9B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE9BC: 4800104D  bl 0x828ffa08
	ctx.lr = 0x828FE9C0;
	sub_828FFA08(ctx, base);
	// 828FE9C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FE9C4: 48000008  b 0x828fe9cc
	pc = 0x828FE9CC; continue 'dispatch;
	// 828FE9C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FE9CC: 3A5C00E4  addi r18, r28, 0xe4
	ctx.r[18].s64 = ctx.r[28].s64 + 228;
	// 828FE9D0: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828FE9D4: 4BFFEA4D  bl 0x828fd420
	ctx.lr = 0x828FE9D8;
	sub_828FD420(ctx, base);
	// 828FE9D8: 83DC00E4  lwz r30, 0xe4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 828FE9DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FE9E0: 419A0074  beq cr6, 0x828fea54
	if ctx.cr[6].eq {
	pc = 0x828FEA54; continue 'dispatch;
	}
	// 828FE9E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FE9E8: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE9EC: 48114C95  bl 0x82a13680
	ctx.lr = 0x828FE9F0;
	sub_82A13680(ctx, base);
	// 828FE9F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FE9F4: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FE9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FE9FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FEA00: 4E800421  bctrl
	ctx.lr = 0x828FEA04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FEA04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FEA08: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEA0C: 48114C7D  bl 0x82a13688
	ctx.lr = 0x828FEA10;
	sub_82A13688(ctx, base);
	// 828FEA10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FEA14: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828FEA18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEA1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FEA20: 4E800421  bctrl
	ctx.lr = 0x828FEA24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FEA24: C07D08A8  lfs f3, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828FEA28: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828FEA2C: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 828FEA30: 38610330  addi r3, r1, 0x330
	ctx.r[3].s64 = ctx.r[1].s64 + 816;
	// 828FEA34: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 828FEA38: 48022979  bl 0x829213b0
	ctx.lr = 0x828FEA3C;
	sub_829213B0(ctx, base);
	// 828FEA3C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEA40: 38810330  addi r4, r1, 0x330
	ctx.r[4].s64 = ctx.r[1].s64 + 816;
	// 828FEA44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEA48: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FEA4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FEA50: 4E800421  bctrl
	ctx.lr = 0x828FEA54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FEA54: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FEA58: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828FEA5C: 4BEEDB6D  bl 0x827ec5c8
	ctx.lr = 0x828FEA60;
	sub_827EC5C8(ctx, base);
	// 828FEA60: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828FEA64: 82830000  lwz r20, 0(r3)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEA6C: 419A000C  beq cr6, 0x828fea78
	if ctx.cr[6].eq {
	pc = 0x828FEA78; continue 'dispatch;
	}
	// 828FEA70: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FEA74: 4B9C1E1D  bl 0x822c0890
	ctx.lr = 0x828FEA78;
	sub_822C0890(ctx, base);
	// 828FEA78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FEA7C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828FEA80: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 828FEA84: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828FEA88: C3AA964C  lfs f29, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828FEA8C: 419A0570  beq cr6, 0x828feffc
	if ctx.cr[6].eq {
	pc = 0x828FEFFC; continue 'dispatch;
	}
	// 828FEA90: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828FEA94: C01D08A8  lfs f0, 0x8a8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEA98: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FEA9C: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 828FEAA0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828FEAA4: D3C10100  stfs f30, 0x100(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 828FEAA8: 3B4B46D0  addi r26, r11, 0x46d0
	ctx.r[26].s64 = ctx.r[11].s64 + 18128;
	// 828FEAAC: 93E100FC  stw r31, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[31].u32 ) };
	// 828FEAB0: 9BE1010C  stb r31, 0x10c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[31].u8 ) };
	// 828FEAB4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828FEAB8: 817BF3F8  lwz r11, -0xc08(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828FEABC: 934100F4  stw r26, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[26].u32 ) };
	// 828FEAC0: C3EA9534  lfs f31, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FEAC4: D3E10104  stfs f31, 0x104(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 828FEAC8: D3E10108  stfs f31, 0x108(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 828FEACC: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 828FEAD0: 484FFDF9  bl 0x82dfe8c8
	ctx.lr = 0x828FEAD4;
	sub_82DFE8C8(ctx, base);
	// 828FEAD4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828FEAD8: 484FFDF1  bl 0x82dfe8c8
	ctx.lr = 0x828FEADC;
	sub_82DFE8C8(ctx, base);
	// 828FEADC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FEAE0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FEAE4: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEAE8: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 828FEAEC: 93E1012C  stw r31, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[31].u32 ) };
	// 828FEAF0: 394A46C4  addi r10, r10, 0x46c4
	ctx.r[10].s64 = ctx.r[10].s64 + 18116;
	// 828FEAF4: D3C10130  stfs f30, 0x130(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 828FEAF8: D3E10134  stfs f31, 0x134(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 828FEAFC: 9BE1013C  stb r31, 0x13c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[31].u8 ) };
	// 828FEB00: D3E10138  stfs f31, 0x138(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 828FEB04: 91410124  stw r10, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[10].u32 ) };
	// 828FEB08: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 828FEB0C: 816BF3FC  lwz r11, -0xc04(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828FEB10: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 828FEB14: 484FFDB5  bl 0x82dfe8c8
	ctx.lr = 0x828FEB18;
	sub_82DFE8C8(ctx, base);
	// 828FEB18: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828FEB1C: 484FFDAD  bl 0x82dfe8c8
	ctx.lr = 0x828FEB20;
	sub_82DFE8C8(ctx, base);
	// 828FEB20: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FEB24: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FEB28: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEB2C: D0010158  stfs f0, 0x158(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 828FEB30: 93E1015C  stw r31, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[31].u32 ) };
	// 828FEB34: 394A46B8  addi r10, r10, 0x46b8
	ctx.r[10].s64 = ctx.r[10].s64 + 18104;
	// 828FEB38: D3C10160  stfs f30, 0x160(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 828FEB3C: D3E10164  stfs f31, 0x164(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 828FEB40: 9BE1016C  stb r31, 0x16c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[31].u8 ) };
	// 828FEB44: D3E10168  stfs f31, 0x168(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 828FEB48: 91410154  stw r10, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 828FEB4C: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828FEB50: 816BF468  lwz r11, -0xb98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2968 as u32) ) } as u64;
	// 828FEB54: 91610150  stw r11, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 828FEB58: 484FFD71  bl 0x82dfe8c8
	ctx.lr = 0x828FEB5C;
	sub_82DFE8C8(ctx, base);
	// 828FEB5C: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 828FEB60: 484FFD69  bl 0x82dfe8c8
	ctx.lr = 0x828FEB64;
	sub_82DFE8C8(ctx, base);
	// 828FEB64: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FEB68: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FEB6C: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEB70: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 828FEB74: 93E1018C  stw r31, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[31].u32 ) };
	// 828FEB78: 394A46A8  addi r10, r10, 0x46a8
	ctx.r[10].s64 = ctx.r[10].s64 + 18088;
	// 828FEB7C: D3C10190  stfs f30, 0x190(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 828FEB80: D3E10194  stfs f31, 0x194(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 828FEB84: 9BE1019C  stb r31, 0x19c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), ctx.r[31].u8 ) };
	// 828FEB88: D3E10198  stfs f31, 0x198(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 828FEB8C: 91410184  stw r10, 0x184(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), ctx.r[10].u32 ) };
	// 828FEB90: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 828FEB94: 816BF470  lwz r11, -0xb90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2960 as u32) ) } as u64;
	// 828FEB98: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 828FEB9C: 484FFD2D  bl 0x82dfe8c8
	ctx.lr = 0x828FEBA0;
	sub_82DFE8C8(ctx, base);
	// 828FEBA0: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 828FEBA4: 484FFD25  bl 0x82dfe8c8
	ctx.lr = 0x828FEBA8;
	sub_82DFE8C8(ctx, base);
	// 828FEBA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FEBAC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828FEBB0: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEBB4: D00101B8  stfs f0, 0x1b8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 828FEBB8: 934101B4  stw r26, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[26].u32 ) };
	// 828FEBBC: D3C101C0  stfs f30, 0x1c0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 828FEBC0: 93C101BC  stw r30, 0x1bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), ctx.r[30].u32 ) };
	// 828FEBC4: D3E101C4  stfs f31, 0x1c4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 828FEBC8: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 828FEBCC: D3E101C8  stfs f31, 0x1c8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 828FEBD0: 816BF47C  lwz r11, -0xb84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2948 as u32) ) } as u64;
	// 828FEBD4: 9BE101CC  stb r31, 0x1cc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[31].u8 ) };
	// 828FEBD8: 916101B0  stw r11, 0x1b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 828FEBDC: 484FFCED  bl 0x82dfe8c8
	ctx.lr = 0x828FEBE0;
	sub_82DFE8C8(ctx, base);
	// 828FEBE0: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 828FEBE4: 484FFCE5  bl 0x82dfe8c8
	ctx.lr = 0x828FEBE8;
	sub_82DFE8C8(ctx, base);
	// 828FEBE8: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828FEBEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FEBF0: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEBF4: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 828FEBF8: 93E101EC  stw r31, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[31].u32 ) };
	// 828FEBFC: 394B4694  addi r10, r11, 0x4694
	ctx.r[10].s64 = ctx.r[11].s64 + 18068;
	// 828FEC00: D3C101F0  stfs f30, 0x1f0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(496 as u32), tmp.u32 ) };
	// 828FEC04: D3E101F4  stfs f31, 0x1f4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 828FEC08: 9BE101FC  stb r31, 0x1fc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(508 as u32), ctx.r[31].u8 ) };
	// 828FEC0C: D3E101F8  stfs f31, 0x1f8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 828FEC10: 914101E4  stw r10, 0x1e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), ctx.r[10].u32 ) };
	// 828FEC14: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 828FEC18: 817AF450  lwz r11, -0xbb0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-2992 as u32) ) } as u64;
	// 828FEC1C: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 828FEC20: 484FFCA9  bl 0x82dfe8c8
	ctx.lr = 0x828FEC24;
	sub_82DFE8C8(ctx, base);
	// 828FEC24: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 828FEC28: 484FFCA1  bl 0x82dfe8c8
	ctx.lr = 0x828FEC2C;
	sub_82DFE8C8(ctx, base);
	// 828FEC2C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FEC30: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FEC34: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEC38: D0010218  stfs f0, 0x218(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), tmp.u32 ) };
	// 828FEC3C: 93E1021C  stw r31, 0x21c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), ctx.r[31].u32 ) };
	// 828FEC40: 394A4688  addi r10, r10, 0x4688
	ctx.r[10].s64 = ctx.r[10].s64 + 18056;
	// 828FEC44: D3C10220  stfs f30, 0x220(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(544 as u32), tmp.u32 ) };
	// 828FEC48: D3E10224  stfs f31, 0x224(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(548 as u32), tmp.u32 ) };
	// 828FEC4C: 9BE1022C  stb r31, 0x22c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), ctx.r[31].u8 ) };
	// 828FEC50: D3E10228  stfs f31, 0x228(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(552 as u32), tmp.u32 ) };
	// 828FEC54: 91410214  stw r10, 0x214(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(532 as u32), ctx.r[10].u32 ) };
	// 828FEC58: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 828FEC5C: 816BF484  lwz r11, -0xb7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2940 as u32) ) } as u64;
	// 828FEC60: 91610210  stw r11, 0x210(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(528 as u32), ctx.r[11].u32 ) };
	// 828FEC64: 484FFC65  bl 0x82dfe8c8
	ctx.lr = 0x828FEC68;
	sub_82DFE8C8(ctx, base);
	// 828FEC68: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 828FEC6C: 484FFC5D  bl 0x82dfe8c8
	ctx.lr = 0x828FEC70;
	sub_82DFE8C8(ctx, base);
	// 828FEC70: 3F20832D  lis r25, -0x7cd3
	ctx.r[25].s64 = -2094202880;
	// 828FEC74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FEC78: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEC7C: D0010248  stfs f0, 0x248(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(584 as u32), tmp.u32 ) };
	// 828FEC80: 93C1024C  stw r30, 0x24c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(588 as u32), ctx.r[30].u32 ) };
	// 828FEC84: 394B4674  addi r10, r11, 0x4674
	ctx.r[10].s64 = ctx.r[11].s64 + 18036;
	// 828FEC88: D3C10250  stfs f30, 0x250(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(592 as u32), tmp.u32 ) };
	// 828FEC8C: D3E10254  stfs f31, 0x254(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(596 as u32), tmp.u32 ) };
	// 828FEC90: 9BE1025C  stb r31, 0x25c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[31].u8 ) };
	// 828FEC94: D3E10258  stfs f31, 0x258(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(600 as u32), tmp.u32 ) };
	// 828FEC98: 91410244  stw r10, 0x244(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(580 as u32), ctx.r[10].u32 ) };
	// 828FEC9C: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 828FECA0: 8179C204  lwz r11, -0x3dfc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-15868 as u32) ) } as u64;
	// 828FECA4: 91610240  stw r11, 0x240(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 828FECA8: 484FFC21  bl 0x82dfe8c8
	ctx.lr = 0x828FECAC;
	sub_82DFE8C8(ctx, base);
	// 828FECAC: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 828FECB0: 484FFC19  bl 0x82dfe8c8
	ctx.lr = 0x828FECB4;
	sub_82DFE8C8(ctx, base);
	// 828FECB4: 3F00832D  lis r24, -0x7cd3
	ctx.r[24].s64 = -2094202880;
	// 828FECB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FECBC: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FECC0: D0010278  stfs f0, 0x278(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), tmp.u32 ) };
	// 828FECC4: 93C1027C  stw r30, 0x27c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(636 as u32), ctx.r[30].u32 ) };
	// 828FECC8: 394B4664  addi r10, r11, 0x4664
	ctx.r[10].s64 = ctx.r[11].s64 + 18020;
	// 828FECCC: D3C10280  stfs f30, 0x280(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 828FECD0: D3E10284  stfs f31, 0x284(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), tmp.u32 ) };
	// 828FECD4: 9BE1028C  stb r31, 0x28c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(652 as u32), ctx.r[31].u8 ) };
	// 828FECD8: D3E10288  stfs f31, 0x288(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 828FECDC: 91410274  stw r10, 0x274(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(628 as u32), ctx.r[10].u32 ) };
	// 828FECE0: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 828FECE4: 8178C208  lwz r11, -0x3df8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-15864 as u32) ) } as u64;
	// 828FECE8: 91610270  stw r11, 0x270(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 828FECEC: 484FFBDD  bl 0x82dfe8c8
	ctx.lr = 0x828FECF0;
	sub_82DFE8C8(ctx, base);
	// 828FECF0: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 828FECF4: 484FFBD5  bl 0x82dfe8c8
	ctx.lr = 0x828FECF8;
	sub_82DFE8C8(ctx, base);
	// 828FECF8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828FECFC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FED00: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FED04: D00102A8  stfs f0, 0x2a8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(680 as u32), tmp.u32 ) };
	// 828FED08: 392B4650  addi r9, r11, 0x4650
	ctx.r[9].s64 = ctx.r[11].s64 + 18000;
	// 828FED0C: D3C102B0  stfs f30, 0x2b0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(688 as u32), tmp.u32 ) };
	// 828FED10: D3E102B4  stfs f31, 0x2b4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 828FED14: 816AF480  lwz r11, -0xb80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2944 as u32) ) } as u64;
	// 828FED18: D3E102B8  stfs f31, 0x2b8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(696 as u32), tmp.u32 ) };
	// 828FED1C: 93C102AC  stw r30, 0x2ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(684 as u32), ctx.r[30].u32 ) };
	// 828FED20: 912102A4  stw r9, 0x2a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(676 as u32), ctx.r[9].u32 ) };
	// 828FED24: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 828FED28: 9BE102BC  stb r31, 0x2bc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[31].u8 ) };
	// 828FED2C: 916102A0  stw r11, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[11].u32 ) };
	// 828FED30: 484FFB99  bl 0x82dfe8c8
	ctx.lr = 0x828FED34;
	sub_82DFE8C8(ctx, base);
	// 828FED34: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 828FED38: 484FFB91  bl 0x82dfe8c8
	ctx.lr = 0x828FED3C;
	sub_82DFE8C8(ctx, base);
	// 828FED3C: 3EE0832D  lis r23, -0x7cd3
	ctx.r[23].s64 = -2094202880;
	// 828FED40: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FED44: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FED48: D00102D8  stfs f0, 0x2d8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(728 as u32), tmp.u32 ) };
	// 828FED4C: 93C102DC  stw r30, 0x2dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(732 as u32), ctx.r[30].u32 ) };
	// 828FED50: 394B4644  addi r10, r11, 0x4644
	ctx.r[10].s64 = ctx.r[11].s64 + 17988;
	// 828FED54: D3C102E0  stfs f30, 0x2e0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(736 as u32), tmp.u32 ) };
	// 828FED58: D3E102E4  stfs f31, 0x2e4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), tmp.u32 ) };
	// 828FED5C: 9BE102EC  stb r31, 0x2ec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(748 as u32), ctx.r[31].u8 ) };
	// 828FED60: D3E102E8  stfs f31, 0x2e8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(744 as u32), tmp.u32 ) };
	// 828FED64: 914102D4  stw r10, 0x2d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(724 as u32), ctx.r[10].u32 ) };
	// 828FED68: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 828FED6C: 8177C214  lwz r11, -0x3dec(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-15852 as u32) ) } as u64;
	// 828FED70: 916102D0  stw r11, 0x2d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), ctx.r[11].u32 ) };
	// 828FED74: 484FFB55  bl 0x82dfe8c8
	ctx.lr = 0x828FED78;
	sub_82DFE8C8(ctx, base);
	// 828FED78: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 828FED7C: 484FFB4D  bl 0x82dfe8c8
	ctx.lr = 0x828FED80;
	sub_82DFE8C8(ctx, base);
	// 828FED80: 3EC0832D  lis r22, -0x7cd3
	ctx.r[22].s64 = -2094202880;
	// 828FED84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FED88: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FED8C: D0010308  stfs f0, 0x308(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(776 as u32), tmp.u32 ) };
	// 828FED90: 93C1030C  stw r30, 0x30c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(780 as u32), ctx.r[30].u32 ) };
	// 828FED94: 394B4638  addi r10, r11, 0x4638
	ctx.r[10].s64 = ctx.r[11].s64 + 17976;
	// 828FED98: D3C10310  stfs f30, 0x310(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(784 as u32), tmp.u32 ) };
	// 828FED9C: D3E10314  stfs f31, 0x314(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(788 as u32), tmp.u32 ) };
	// 828FEDA0: 9BE1031C  stb r31, 0x31c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(796 as u32), ctx.r[31].u8 ) };
	// 828FEDA4: D3E10318  stfs f31, 0x318(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(792 as u32), tmp.u32 ) };
	// 828FEDA8: 91410304  stw r10, 0x304(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(772 as u32), ctx.r[10].u32 ) };
	// 828FEDAC: 38610320  addi r3, r1, 0x320
	ctx.r[3].s64 = ctx.r[1].s64 + 800;
	// 828FEDB0: 8176C210  lwz r11, -0x3df0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-15856 as u32) ) } as u64;
	// 828FEDB4: 91610300  stw r11, 0x300(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(768 as u32), ctx.r[11].u32 ) };
	// 828FEDB8: 484FFB11  bl 0x82dfe8c8
	ctx.lr = 0x828FEDBC;
	sub_82DFE8C8(ctx, base);
	// 828FEDBC: 38610328  addi r3, r1, 0x328
	ctx.r[3].s64 = ctx.r[1].s64 + 808;
	// 828FEDC0: 484FFB09  bl 0x82dfe8c8
	ctx.lr = 0x828FEDC4;
	sub_82DFE8C8(ctx, base);
	// 828FEDC4: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828FEDC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FEDCC: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 828FEDD0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828FEDD4: 4B9C1605  bl 0x822c03d8
	ctx.lr = 0x828FEDD8;
	sub_822C03D8(ctx, base);
	// 828FEDD8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FEDDC: 4182001C  beq 0x828fedf8
	if ctx.cr[0].eq {
	pc = 0x828FEDF8; continue 'dispatch;
	}
	// 828FEDE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEDE4: 4BEEBECD  bl 0x827eacb0
	ctx.lr = 0x828FEDE8;
	sub_827EACB0(ctx, base);
	// 828FEDE8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828FEDEC: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828FEDF0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FEDF4: 48000008  b 0x828fedfc
	pc = 0x828FEDFC; continue 'dispatch;
	// 828FEDF8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828FEDFC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828FEE00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FEE04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FEE08: 4BF67DD9  bl 0x82866be0
	ctx.lr = 0x828FEE0C;
	sub_82866BE0(ctx, base);
	// 828FEE0C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FEE10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FEE14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FEE18: 4B9C11E9  bl 0x822c0000
	ctx.lr = 0x828FEE1C;
	sub_822C0000(ctx, base);
	// 828FEE1C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FEE20: 3BDC01CC  addi r30, r28, 0x1cc
	ctx.r[30].s64 = ctx.r[28].s64 + 460;
	// 828FEE24: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828FEE28: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 828FEE2C: 917C01CC  stw r11, 0x1cc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 828FEE30: 4B9C5631  bl 0x822c4460
	ctx.lr = 0x828FEE34;
	sub_822C4460(ctx, base);
	// 828FEE34: 817C01CC  lwz r11, 0x1cc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(460 as u32) ) } as u64;
	// 828FEE38: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FEE3C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828FEE40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FEE44: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FEE48: 69750001  xori r21, r11, 1
	ctx.r[21].u64 = ctx.r[11].u64 ^ 1;
	// 828FEE4C: 419A0008  beq cr6, 0x828fee54
	if ctx.cr[6].eq {
	pc = 0x828FEE54; continue 'dispatch;
	}
	// 828FEE50: 4B9C1A41  bl 0x822c0890
	ctx.lr = 0x828FEE54;
	sub_822C0890(ctx, base);
	// 828FEE54: 56AB063F  clrlwi. r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FEE58: 41820068  beq 0x828feec0
	if ctx.cr[0].eq {
	pc = 0x828FEEC0; continue 'dispatch;
	}
	// 828FEE5C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828FEE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEE64: 484F4BA5  bl 0x82df3a08
	ctx.lr = 0x828FEE68;
	sub_82DF3A08(ctx, base);
	// 828FEE68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FEE6C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828FEE70: 3AA10050  addi r21, r1, 0x50
	ctx.r[21].s64 = ctx.r[1].s64 + 80;
	// 828FEE74: 827E0000  lwz r19, 0(r30)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEE78: 4BC10651  bl 0x8250f4c8
	ctx.lr = 0x828FEE7C;
	sub_8250F4C8(ctx, base);
	// 828FEE7C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FEE80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FEE84: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828FEE88: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 828FEE8C: C02B3B5C  lfs f1, 0x3b5c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FEE90: 4BEEBAD9  bl 0x827ea968
	ctx.lr = 0x828FEE94;
	sub_827EA968(ctx, base);
	// 828FEE94: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828FEE98: 484F2DF9  bl 0x82df1c90
	ctx.lr = 0x828FEE9C;
	sub_82DF1C90(ctx, base);
	// 828FEE9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEEA0: 484F4589  bl 0x82df3428
	ctx.lr = 0x828FEEA4;
	sub_82DF3428(ctx, base);
	// 828FEEA4: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 828FEEA8: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 828FEEAC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEEB0: 4BEEB811  bl 0x827ea6c0
	ctx.lr = 0x828FEEB4;
	sub_827EA6C0(ctx, base);
	// 828FEEB4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828FEEB8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEEBC: 4BEEB80D  bl 0x827ea6c8
	ctx.lr = 0x828FEEC0;
	sub_827EA6C8(ctx, base);
	// 828FEEC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FEEC4: 4BEED30D  bl 0x827ec1d0
	ctx.lr = 0x828FEEC8;
	sub_827EC1D0(ctx, base);
	// 828FEEC8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FEECC: 41820130  beq 0x828feffc
	if ctx.cr[0].eq {
	pc = 0x828FEFFC; continue 'dispatch;
	}
	// 828FEED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEED4: 809BF3F8  lwz r4, -0xc08(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828FEED8: 484F4B31  bl 0x82df3a08
	ctx.lr = 0x828FEEDC;
	sub_82DF3A08(ctx, base);
	// 828FEEDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FEEE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEEE4: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828FEEE8: 4BEEB451  bl 0x827ea338
	ctx.lr = 0x828FEEEC;
	sub_827EA338(ctx, base);
	// 828FEEEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEEF0: 484F4539  bl 0x82df3428
	ctx.lr = 0x828FEEF4;
	sub_82DF3428(ctx, base);
	// 828FEEF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEEF8: 809AF450  lwz r4, -0xbb0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-2992 as u32) ) } as u64;
	// 828FEEFC: 484F4B0D  bl 0x82df3a08
	ctx.lr = 0x828FEF00;
	sub_82DF3A08(ctx, base);
	// 828FEF00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FEF04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FEF08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEF0C: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FEF10: 4BEEB429  bl 0x827ea338
	ctx.lr = 0x828FEF14;
	sub_827EA338(ctx, base);
	// 828FEF14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF18: 484F4511  bl 0x82df3428
	ctx.lr = 0x828FEF1C;
	sub_82DF3428(ctx, base);
	// 828FEF1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF20: 8097C214  lwz r4, -0x3dec(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-15852 as u32) ) } as u64;
	// 828FEF24: 484F4AE5  bl 0x82df3a08
	ctx.lr = 0x828FEF28;
	sub_82DF3A08(ctx, base);
	// 828FEF28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FEF2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEF30: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828FEF34: 4BEEB405  bl 0x827ea338
	ctx.lr = 0x828FEF38;
	sub_827EA338(ctx, base);
	// 828FEF38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF3C: 484F44ED  bl 0x82df3428
	ctx.lr = 0x828FEF40;
	sub_82DF3428(ctx, base);
	// 828FEF40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF44: 8096C210  lwz r4, -0x3df0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-15856 as u32) ) } as u64;
	// 828FEF48: 484F4AC1  bl 0x82df3a08
	ctx.lr = 0x828FEF4C;
	sub_82DF3A08(ctx, base);
	// 828FEF4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FEF50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEF54: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828FEF58: 4BEEB3E1  bl 0x827ea338
	ctx.lr = 0x828FEF5C;
	sub_827EA338(ctx, base);
	// 828FEF5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF60: 484F44C9  bl 0x82df3428
	ctx.lr = 0x828FEF64;
	sub_82DF3428(ctx, base);
	// 828FEF64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF68: 8099C204  lwz r4, -0x3dfc(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-15868 as u32) ) } as u64;
	// 828FEF6C: 484F4A9D  bl 0x82df3a08
	ctx.lr = 0x828FEF70;
	sub_82DF3A08(ctx, base);
	// 828FEF70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FEF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEF78: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828FEF7C: 4BEEB3BD  bl 0x827ea338
	ctx.lr = 0x828FEF80;
	sub_827EA338(ctx, base);
	// 828FEF80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF84: 484F44A5  bl 0x82df3428
	ctx.lr = 0x828FEF88;
	sub_82DF3428(ctx, base);
	// 828FEF88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEF8C: 8098C208  lwz r4, -0x3df8(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-15864 as u32) ) } as u64;
	// 828FEF90: 484F4A79  bl 0x82df3a08
	ctx.lr = 0x828FEF94;
	sub_82DF3A08(ctx, base);
	// 828FEF94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FEF98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEF9C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828FEFA0: 4BEEB399  bl 0x827ea338
	ctx.lr = 0x828FEFA4;
	sub_827EA338(ctx, base);
	// 828FEFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEFA8: 484F4481  bl 0x82df3428
	ctx.lr = 0x828FEFAC;
	sub_82DF3428(ctx, base);
	// 828FEFAC: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FEFB0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828FEFB4: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 828FEFB8: 396BB820  addi r11, r11, -0x47e0
	ctx.r[11].s64 = ctx.r[11].s64 + -18400;
	// 828FEFBC: 388AC15C  addi r4, r10, -0x3ea4
	ctx.r[4].s64 = ctx.r[10].s64 + -16036;
	// 828FEFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEFC4: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 828FEFC8: 484F4A41  bl 0x82df3a08
	ctx.lr = 0x828FEFCC;
	sub_82DF3A08(ctx, base);
	// 828FEFCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FEFD0: 91E10338  stw r15, 0x338(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(824 as u32), ctx.r[15].u32 ) };
	// 828FEFD4: E8810098  ld r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 828FEFD8: E8A10338  ld r5, 0x338(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(824 as u32) ) };
	// 828FEFDC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FEFE0: 4BFFF5A9  bl 0x828fe588
	ctx.lr = 0x828FEFE4;
	sub_828FE588(ctx, base);
	// 828FEFE4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828FEFE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FEFEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FEFF0: 4BEEB819  bl 0x827ea808
	ctx.lr = 0x828FEFF4;
	sub_827EA808(ctx, base);
	// 828FEFF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FEFF8: 484F4431  bl 0x82df3428
	ctx.lr = 0x828FEFFC;
	sub_82DF3428(ctx, base);
	// 828FEFFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF000: 4BEED1D1  bl 0x827ec1d0
	ctx.lr = 0x828FF004;
	sub_827EC1D0(ctx, base);
	// 828FF004: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FF008: 41820104  beq 0x828ff10c
	if ctx.cr[0].eq {
	pc = 0x828FF10C; continue 'dispatch;
	}
	// 828FF00C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF010: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF014: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FF018: 4E800421  bctrl
	ctx.lr = 0x828FF01C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FF01C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FF020: 418200EC  beq 0x828ff10c
	if ctx.cr[0].eq {
	pc = 0x828FF10C; continue 'dispatch;
	}
	// 828FF024: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828FF028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF02C: 484F49DD  bl 0x82df3a08
	ctx.lr = 0x828FF030;
	sub_82DF3A08(ctx, base);
	// 828FF030: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FF034: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF038: 482AEC29  bl 0x82badc60
	ctx.lr = 0x828FF03C;
	sub_82BADC60(ctx, base);
	// 828FF03C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FF040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF044: 484F43E5  bl 0x82df3428
	ctx.lr = 0x828FF048;
	sub_82DF3428(ctx, base);
	// 828FF048: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828FF04C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF050: 484F49B9  bl 0x82df3a08
	ctx.lr = 0x828FF054;
	sub_82DF3A08(ctx, base);
	// 828FF054: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FF058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF05C: 482AEC05  bl 0x82badc60
	ctx.lr = 0x828FF060;
	sub_82BADC60(ctx, base);
	// 828FF060: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828FF064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF068: 484F43C1  bl 0x82df3428
	ctx.lr = 0x828FF06C;
	sub_82DF3428(ctx, base);
	// 828FF06C: C01D08A8  lfs f0, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FF070: D3C100B0  stfs f30, 0xb0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 828FF074: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FF078: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828FF07C: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 828FF080: D3C100B8  stfs f30, 0xb8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 828FF084: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 828FF088: D3C100BC  stfs f30, 0xbc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 828FF08C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF090: D3C100C0  stfs f30, 0xc0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 828FF094: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828FF098: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 828FF09C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF0A0: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 828FF0A4: D3C100CC  stfs f30, 0xcc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 828FF0A8: C02BD8B0  lfs f1, -0x2750(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FF0AC: 4807E145  bl 0x8297d1f0
	ctx.lr = 0x828FF0B0;
	sub_8297D1F0(ctx, base);
	// 828FF0B0: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828FF0B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FF0B8: 38A0014C  li r5, 0x14c
	ctx.r[5].s64 = 332;
	// 828FF0BC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 828FF0C0: 4B9C1319  bl 0x822c03d8
	ctx.lr = 0x828FF0C4;
	sub_822C03D8(ctx, base);
	// 828FF0C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FF0C8: 41820018  beq 0x828ff0e0
	if ctx.cr[0].eq {
	pc = 0x828FF0E0; continue 'dispatch;
	}
	// 828FF0CC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828FF0D0: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828FF0D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FF0D8: 4807E161  bl 0x8297d238
	ctx.lr = 0x828FF0DC;
	sub_8297D238(ctx, base);
	// 828FF0DC: 48000008  b 0x828ff0e4
	pc = 0x828FF0E4; continue 'dispatch;
	// 828FF0E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF0E4: 817C0390  lwz r11, 0x390(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(912 as u32) ) } as u64;
	// 828FF0E8: 907C0390  stw r3, 0x390(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(912 as u32), ctx.r[3].u32 ) };
	// 828FF0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF0F0: 419A001C  beq cr6, 0x828ff10c
	if ctx.cr[6].eq {
	pc = 0x828FF10C; continue 'dispatch;
	}
	// 828FF0F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF0F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FF0FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FF100: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF104: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FF108: 4E800421  bctrl
	ctx.lr = 0x828FF10C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FF10C: 80920000  lwz r4, 0(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF110: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828FF114: 419A04E8  beq cr6, 0x828ff5fc
	if ctx.cr[6].eq {
	pc = 0x828FF5FC; continue 'dispatch;
	}
	// 828FF118: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF11C: 4BEECF8D  bl 0x827ec0a8
	ctx.lr = 0x828FF120;
	sub_827EC0A8(ctx, base);
	// 828FF120: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF124: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828FF128: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF12C: 388BE810  addi r4, r11, -0x17f0
	ctx.r[4].s64 = ctx.r[11].s64 + -6128;
	// 828FF130: 4BF69F79  bl 0x828690a8
	ctx.lr = 0x828FF134;
	sub_828690A8(ctx, base);
	// 828FF134: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF13C: 3BDC0164  addi r30, r28, 0x164
	ctx.r[30].s64 = ctx.r[28].s64 + 356;
	// 828FF140: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF144: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 828FF148: 484F48C1  bl 0x82df3a08
	ctx.lr = 0x828FF14C;
	sub_82DF3A08(ctx, base);
	// 828FF14C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF154: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF158: 4855D001  bl 0x82e5c158
	ctx.lr = 0x828FF15C;
	sub_82E5C158(ctx, base);
	// 828FF15C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF160: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828FF164: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF168: 388BED10  addi r4, r11, -0x12f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4848;
	// 828FF16C: 4BF69F3D  bl 0x828690a8
	ctx.lr = 0x828FF170;
	sub_828690A8(ctx, base);
	// 828FF170: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF174: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF178: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF17C: 808B0BEC  lwz r4, 0xbec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) } as u64;
	// 828FF180: 484F4889  bl 0x82df3a08
	ctx.lr = 0x828FF184;
	sub_82DF3A08(ctx, base);
	// 828FF184: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF18C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF190: 4855CFC9  bl 0x82e5c158
	ctx.lr = 0x828FF194;
	sub_82E5C158(ctx, base);
	// 828FF194: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF198: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828FF19C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF1A0: 388BE608  addi r4, r11, -0x19f8
	ctx.r[4].s64 = ctx.r[11].s64 + -6648;
	// 828FF1A4: 4BF69F05  bl 0x828690a8
	ctx.lr = 0x828FF1A8;
	sub_828690A8(ctx, base);
	// 828FF1A8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF1AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF1B0: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF1B4: 808B0BD8  lwz r4, 0xbd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828FF1B8: 484F4851  bl 0x82df3a08
	ctx.lr = 0x828FF1BC;
	sub_82DF3A08(ctx, base);
	// 828FF1BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF1C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF1C4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF1C8: 4855CF91  bl 0x82e5c158
	ctx.lr = 0x828FF1CC;
	sub_82E5C158(ctx, base);
	// 828FF1CC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF1D0: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828FF1D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF1D8: 388BE608  addi r4, r11, -0x19f8
	ctx.r[4].s64 = ctx.r[11].s64 + -6648;
	// 828FF1DC: 4BF69ECD  bl 0x828690a8
	ctx.lr = 0x828FF1E0;
	sub_828690A8(ctx, base);
	// 828FF1E0: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828FF1E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF1E8: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF1EC: 809B0BF0  lwz r4, 0xbf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3056 as u32) ) } as u64;
	// 828FF1F0: 484F4819  bl 0x82df3a08
	ctx.lr = 0x828FF1F4;
	sub_82DF3A08(ctx, base);
	// 828FF1F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF1F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF1FC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF200: 4855CF59  bl 0x82e5c158
	ctx.lr = 0x828FF204;
	sub_82E5C158(ctx, base);
	// 828FF204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF208: 809B0BF0  lwz r4, 0xbf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3056 as u32) ) } as u64;
	// 828FF20C: 484F47FD  bl 0x82df3a08
	ctx.lr = 0x828FF210;
	sub_82DF3A08(ctx, base);
	// 828FF210: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FF214: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF218: 4BEED2F1  bl 0x827ec508
	ctx.lr = 0x828FF21C;
	sub_827EC508(ctx, base);
	// 828FF21C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF220: 484F4209  bl 0x82df3428
	ctx.lr = 0x828FF224;
	sub_82DF3428(ctx, base);
	// 828FF224: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF228: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828FF22C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF230: 388B5E50  addi r4, r11, 0x5e50
	ctx.r[4].s64 = ctx.r[11].s64 + 24144;
	// 828FF234: 4BF69E75  bl 0x828690a8
	ctx.lr = 0x828FF238;
	sub_828690A8(ctx, base);
	// 828FF238: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828FF23C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF240: 3BDC00FC  addi r30, r28, 0xfc
	ctx.r[30].s64 = ctx.r[28].s64 + 252;
	// 828FF244: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF248: 809B0B50  lwz r4, 0xb50(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828FF24C: 484F47BD  bl 0x82df3a08
	ctx.lr = 0x828FF250;
	sub_82DF3A08(ctx, base);
	// 828FF250: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF258: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF25C: 4855CEFD  bl 0x82e5c158
	ctx.lr = 0x828FF260;
	sub_82E5C158(ctx, base);
	// 828FF260: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF264: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828FF268: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF26C: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 828FF270: 4BF69E39  bl 0x828690a8
	ctx.lr = 0x828FF274;
	sub_828690A8(ctx, base);
	// 828FF274: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF278: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF27C: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF280: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 828FF284: 484F4785  bl 0x82df3a08
	ctx.lr = 0x828FF288;
	sub_82DF3A08(ctx, base);
	// 828FF288: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF28C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF290: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF294: 4855CEC5  bl 0x82e5c158
	ctx.lr = 0x828FF298;
	sub_82E5C158(ctx, base);
	// 828FF298: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF29C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828FF2A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF2A4: 388B55E8  addi r4, r11, 0x55e8
	ctx.r[4].s64 = ctx.r[11].s64 + 21992;
	// 828FF2A8: 4BF69E01  bl 0x828690a8
	ctx.lr = 0x828FF2AC;
	sub_828690A8(ctx, base);
	// 828FF2AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF2B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF2B4: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF2B8: 808B0B5C  lwz r4, 0xb5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2908 as u32) ) } as u64;
	// 828FF2BC: 484F474D  bl 0x82df3a08
	ctx.lr = 0x828FF2C0;
	sub_82DF3A08(ctx, base);
	// 828FF2C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF2C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF2C8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF2CC: 4855CE8D  bl 0x82e5c158
	ctx.lr = 0x828FF2D0;
	sub_82E5C158(ctx, base);
	// 828FF2D0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF2D4: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF2D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF2DC: 388B3628  addi r4, r11, 0x3628
	ctx.r[4].s64 = ctx.r[11].s64 + 13864;
	// 828FF2E0: 4BFFEC59  bl 0x828fdf38
	ctx.lr = 0x828FF2E4;
	sub_828FDF38(ctx, base);
	// 828FF2E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF2E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF2EC: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF2F0: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 828FF2F4: 484F4715  bl 0x82df3a08
	ctx.lr = 0x828FF2F8;
	sub_82DF3A08(ctx, base);
	// 828FF2F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF2FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF300: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF304: 4855CE55  bl 0x82e5c158
	ctx.lr = 0x828FF308;
	sub_82E5C158(ctx, base);
	// 828FF308: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF30C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828FF310: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF314: 388B9EF8  addi r4, r11, -0x6108
	ctx.r[4].s64 = ctx.r[11].s64 + -24840;
	// 828FF318: 4BF69D91  bl 0x828690a8
	ctx.lr = 0x828FF31C;
	sub_828690A8(ctx, base);
	// 828FF31C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF324: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF328: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 828FF32C: 484F46DD  bl 0x82df3a08
	ctx.lr = 0x828FF330;
	sub_82DF3A08(ctx, base);
	// 828FF330: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF338: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF33C: 4855CE1D  bl 0x82e5c158
	ctx.lr = 0x828FF340;
	sub_82E5C158(ctx, base);
	// 828FF340: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF344: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828FF348: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF34C: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 828FF350: 4BF69D59  bl 0x828690a8
	ctx.lr = 0x828FF354;
	sub_828690A8(ctx, base);
	// 828FF354: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF35C: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF360: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 828FF364: 484F46A5  bl 0x82df3a08
	ctx.lr = 0x828FF368;
	sub_82DF3A08(ctx, base);
	// 828FF368: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF36C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF370: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF374: 4855CDE5  bl 0x82e5c158
	ctx.lr = 0x828FF378;
	sub_82E5C158(ctx, base);
	// 828FF378: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF37C: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF380: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF384: 388B3700  addi r4, r11, 0x3700
	ctx.r[4].s64 = ctx.r[11].s64 + 14080;
	// 828FF388: 4BFFEBB1  bl 0x828fdf38
	ctx.lr = 0x828FF38C;
	sub_828FDF38(ctx, base);
	// 828FF38C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF394: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF398: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828FF39C: 484F466D  bl 0x82df3a08
	ctx.lr = 0x828FF3A0;
	sub_82DF3A08(ctx, base);
	// 828FF3A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF3A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF3A8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF3AC: 4855CDAD  bl 0x82e5c158
	ctx.lr = 0x828FF3B0;
	sub_82E5C158(ctx, base);
	// 828FF3B0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF3B4: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF3B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF3BC: 388B3488  addi r4, r11, 0x3488
	ctx.r[4].s64 = ctx.r[11].s64 + 13448;
	// 828FF3C0: 4BFFEB79  bl 0x828fdf38
	ctx.lr = 0x828FF3C4;
	sub_828FDF38(ctx, base);
	// 828FF3C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF3C8: 809B0B50  lwz r4, 0xb50(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828FF3CC: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF3D0: 484F4639  bl 0x82df3a08
	ctx.lr = 0x828FF3D4;
	sub_82DF3A08(ctx, base);
	// 828FF3D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF3D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF3DC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF3E0: 4855CD79  bl 0x82e5c158
	ctx.lr = 0x828FF3E4;
	sub_82E5C158(ctx, base);
	// 828FF3E4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF3E8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF3EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF3F0: 388B34F8  addi r4, r11, 0x34f8
	ctx.r[4].s64 = ctx.r[11].s64 + 13560;
	// 828FF3F4: 4BFFEB45  bl 0x828fdf38
	ctx.lr = 0x828FF3F8;
	sub_828FDF38(ctx, base);
	// 828FF3F8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF400: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF404: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828FF408: 484F4601  bl 0x82df3a08
	ctx.lr = 0x828FF40C;
	sub_82DF3A08(ctx, base);
	// 828FF40C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF414: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF418: 4855CD41  bl 0x82e5c158
	ctx.lr = 0x828FF41C;
	sub_82E5C158(ctx, base);
	// 828FF41C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF420: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF424: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF428: 388B34F8  addi r4, r11, 0x34f8
	ctx.r[4].s64 = ctx.r[11].s64 + 13560;
	// 828FF42C: 4BFFEB0D  bl 0x828fdf38
	ctx.lr = 0x828FF430;
	sub_828FDF38(ctx, base);
	// 828FF430: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF438: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF43C: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828FF440: 484F45C9  bl 0x82df3a08
	ctx.lr = 0x828FF444;
	sub_82DF3A08(ctx, base);
	// 828FF444: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF448: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF44C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF450: 4855CD09  bl 0x82e5c158
	ctx.lr = 0x828FF454;
	sub_82E5C158(ctx, base);
	// 828FF454: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF458: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF45C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF460: 388B3700  addi r4, r11, 0x3700
	ctx.r[4].s64 = ctx.r[11].s64 + 14080;
	// 828FF464: 4BFFEAD5  bl 0x828fdf38
	ctx.lr = 0x828FF468;
	sub_828FDF38(ctx, base);
	// 828FF468: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF470: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF474: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828FF478: 484F4591  bl 0x82df3a08
	ctx.lr = 0x828FF47C;
	sub_82DF3A08(ctx, base);
	// 828FF47C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF484: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF488: 4855CCD1  bl 0x82e5c158
	ctx.lr = 0x828FF48C;
	sub_82E5C158(ctx, base);
	// 828FF48C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF490: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF494: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF498: 388B33A8  addi r4, r11, 0x33a8
	ctx.r[4].s64 = ctx.r[11].s64 + 13224;
	// 828FF49C: 4BFFEA9D  bl 0x828fdf38
	ctx.lr = 0x828FF4A0;
	sub_828FDF38(ctx, base);
	// 828FF4A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF4A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4A8: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF4AC: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828FF4B0: 484F4559  bl 0x82df3a08
	ctx.lr = 0x828FF4B4;
	sub_82DF3A08(ctx, base);
	// 828FF4B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF4B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF4BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF4C0: 4855CC99  bl 0x82e5c158
	ctx.lr = 0x828FF4C4;
	sub_82E5C158(ctx, base);
	// 828FF4C4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF4C8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF4CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF4D0: 388B3418  addi r4, r11, 0x3418
	ctx.r[4].s64 = ctx.r[11].s64 + 13336;
	// 828FF4D4: 4BFFEA65  bl 0x828fdf38
	ctx.lr = 0x828FF4D8;
	sub_828FDF38(ctx, base);
	// 828FF4D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF4DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4E0: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828FF4E4: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828FF4E8: 484F4521  bl 0x82df3a08
	ctx.lr = 0x828FF4EC;
	sub_82DF3A08(ctx, base);
	// 828FF4EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF4F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF4F4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FF4F8: 4855CC61  bl 0x82e5c158
	ctx.lr = 0x828FF4FC;
	sub_82E5C158(ctx, base);
	// 828FF4FC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF500: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF504: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF508: 388B3258  addi r4, r11, 0x3258
	ctx.r[4].s64 = ctx.r[11].s64 + 12888;
	// 828FF50C: 4BFFEA2D  bl 0x828fdf38
	ctx.lr = 0x828FF510;
	sub_828FDF38(ctx, base);
	// 828FF510: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828FF514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF518: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF51C: 809BC22C  lwz r4, -0x3dd4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15828 as u32) ) } as u64;
	// 828FF520: 484F44E9  bl 0x82df3a08
	ctx.lr = 0x828FF524;
	sub_82DF3A08(ctx, base);
	// 828FF524: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF52C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF530: 4855CC29  bl 0x82e5c158
	ctx.lr = 0x828FF534;
	sub_82E5C158(ctx, base);
	// 828FF534: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF538: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF53C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF540: 388B3568  addi r4, r11, 0x3568
	ctx.r[4].s64 = ctx.r[11].s64 + 13672;
	// 828FF544: 4BFFE9F5  bl 0x828fdf38
	ctx.lr = 0x828FF548;
	sub_828FDF38(ctx, base);
	// 828FF548: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF550: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF554: 808BC230  lwz r4, -0x3dd0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15824 as u32) ) } as u64;
	// 828FF558: 484F44B1  bl 0x82df3a08
	ctx.lr = 0x828FF55C;
	sub_82DF3A08(ctx, base);
	// 828FF55C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF564: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF568: 4855CBF1  bl 0x82e5c158
	ctx.lr = 0x828FF56C;
	sub_82E5C158(ctx, base);
	// 828FF56C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF570: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF574: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF578: 388B32C8  addi r4, r11, 0x32c8
	ctx.r[4].s64 = ctx.r[11].s64 + 13000;
	// 828FF57C: 4BFFE9BD  bl 0x828fdf38
	ctx.lr = 0x828FF580;
	sub_828FDF38(ctx, base);
	// 828FF580: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF588: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF58C: 808BC234  lwz r4, -0x3dcc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15820 as u32) ) } as u64;
	// 828FF590: 484F4479  bl 0x82df3a08
	ctx.lr = 0x828FF594;
	sub_82DF3A08(ctx, base);
	// 828FF594: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF59C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF5A0: 4855CBB9  bl 0x82e5c158
	ctx.lr = 0x828FF5A4;
	sub_82E5C158(ctx, base);
	// 828FF5A4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828FF5A8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828FF5AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FF5B0: 388B3338  addi r4, r11, 0x3338
	ctx.r[4].s64 = ctx.r[11].s64 + 13112;
	// 828FF5B4: 4BFFE985  bl 0x828fdf38
	ctx.lr = 0x828FF5B8;
	sub_828FDF38(ctx, base);
	// 828FF5B8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF5BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5C0: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828FF5C4: 808BC238  lwz r4, -0x3dc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15816 as u32) ) } as u64;
	// 828FF5C8: 484F4441  bl 0x82df3a08
	ctx.lr = 0x828FF5CC;
	sub_82DF3A08(ctx, base);
	// 828FF5CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF5D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF5D4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828FF5D8: 4855CB81  bl 0x82e5c158
	ctx.lr = 0x828FF5DC;
	sub_82E5C158(ctx, base);
	// 828FF5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5E0: 809BC22C  lwz r4, -0x3dd4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15828 as u32) ) } as u64;
	// 828FF5E4: 484F4425  bl 0x82df3a08
	ctx.lr = 0x828FF5E8;
	sub_82DF3A08(ctx, base);
	// 828FF5E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FF5EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF5F0: 4BEED6F9  bl 0x827ecce8
	ctx.lr = 0x828FF5F4;
	sub_827ECCE8(ctx, base);
	// 828FF5F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5F8: 484F3E31  bl 0x82df3428
	ctx.lr = 0x828FF5FC;
	sub_82DF3428(ctx, base);
	// 828FF5FC: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF600: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 828FF604: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF608: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FF60C: 4E800421  bctrl
	ctx.lr = 0x828FF610;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FF610: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FF614: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF618: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FF61C: 4800EE35  bl 0x8290e450
	ctx.lr = 0x828FF620;
	sub_8290E450(ctx, base);
	// 828FF620: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF624: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 828FF628: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF62C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FF630: 4E800421  bctrl
	ctx.lr = 0x828FF634;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FF634: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FF638: C0BD08A8  lfs f5, 0x8a8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2216 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828FF63C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF640: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 828FF644: C08B0084  lfs f4, 0x84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828FF648: C06B0080  lfs f3, 0x80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828FF64C: C04B007C  lfs f2, 0x7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828FF650: 48010C59  bl 0x829102a8
	ctx.lr = 0x828FF654;
	sub_829102A8(ctx, base);
	// 828FF654: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF658: 80810424  lwz r4, 0x424(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1060 as u32) ) } as u64;
	// 828FF65C: 4800E9A5  bl 0x8290e000
	ctx.lr = 0x828FF660;
	sub_8290E000(ctx, base);
	// 828FF660: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828FF664: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FF668: 38A00189  li r5, 0x189
	ctx.r[5].s64 = 393;
	// 828FF66C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828FF670: 4B9C0D69  bl 0x822c03d8
	ctx.lr = 0x828FF674;
	sub_822C03D8(ctx, base);
	// 828FF674: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FF678: 4182002C  beq 0x828ff6a4
	if ctx.cr[0].eq {
	pc = 0x828FF6A4; continue 'dispatch;
	}
	// 828FF67C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF680: 4BEECAE1  bl 0x827ec160
	ctx.lr = 0x828FF684;
	sub_827EC160(ctx, base);
	// 828FF684: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FF688: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828FF68C: 38AB3B20  addi r5, r11, 0x3b20
	ctx.r[5].s64 = ctx.r[11].s64 + 15136;
	// 828FF690: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 828FF694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF698: 48023129  bl 0x829227c0
	ctx.lr = 0x828FF69C;
	sub_829227C0(ctx, base);
	// 828FF69C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF6A0: 48000008  b 0x828ff6a8
	pc = 0x828FF6A8; continue 'dispatch;
	// 828FF6A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FF6A8: 387C0388  addi r3, r28, 0x388
	ctx.r[3].s64 = ctx.r[28].s64 + 904;
	// 828FF6AC: 4BF6990D  bl 0x82868fb8
	ctx.lr = 0x828FF6B0;
	sub_82868FB8(ctx, base);
	// 828FF6B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FF6B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FF6B8: 388B3B80  addi r4, r11, 0x3b80
	ctx.r[4].s64 = ctx.r[11].s64 + 15232;
	// 828FF6BC: 4805F9FD  bl 0x8295f0b8
	ctx.lr = 0x828FF6C0;
	sub_8295F0B8(ctx, base);
	// 828FF6C0: 38210400  addi r1, r1, 0x400
	ctx.r[1].s64 = ctx.r[1].s64 + 1024;
	// 828FF6C4: CBA1FF50  lfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 828FF6C8: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 828FF6CC: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 828FF6D0: 488A8AB0  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FF6D8 size=140
    let mut pc: u32 = 0x828FF6D8;
    'dispatch: loop {
        match pc {
            0x828FF6D8 => {
    //   block [0x828FF6D8..0x828FF764)
	// 828FF6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF6DC: 488A8A91  bl 0x831a816c
	ctx.lr = 0x828FF6E0;
	sub_831A8130(ctx, base);
	// 828FF6E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF6E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FF6E8: 4BFFEFA1  bl 0x828fe688
	ctx.lr = 0x828FF6EC;
	sub_828FE688(ctx, base);
	// 828FF6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF6F0: 4BEECAE1  bl 0x827ec1d0
	ctx.lr = 0x828FF6F4;
	sub_827EC1D0(ctx, base);
	// 828FF6F4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828FF6F8: 41820064  beq 0x828ff75c
	if ctx.cr[0].eq {
	pc = 0x828FF75C; continue 'dispatch;
	}
	// 828FF6FC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828FF700: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 828FF704: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828FF708: 394ACF90  addi r10, r10, -0x3070
	ctx.r[10].s64 = ctx.r[10].s64 + -12400;
	// 828FF70C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF710: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828FF714: 808BC210  lwz r4, -0x3df0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15856 as u32) ) } as u64;
	// 828FF718: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828FF71C: 484F42ED  bl 0x82df3a08
	ctx.lr = 0x828FF720;
	sub_82DF3A08(ctx, base);
	// 828FF720: 397FFFF0  addi r11, r31, -0x10
	ctx.r[11].s64 = ctx.r[31].s64 + -16;
	// 828FF724: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828FF728: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828FF72C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828FF730: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828FF734: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828FF738: 4BFFEED1  bl 0x828fe608
	ctx.lr = 0x828FF73C;
	sub_828FE608(ctx, base);
	// 828FF73C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FF740: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828FF744: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FF748: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FF74C: C02B9D1C  lfs f1, -0x62e4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FF750: 4BEEB061  bl 0x827ea7b0
	ctx.lr = 0x828FF754;
	sub_827EA7B0(ctx, base);
	// 828FF754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF758: 484F3CD1  bl 0x82df3428
	ctx.lr = 0x828FF75C;
	sub_82DF3428(ctx, base);
	// 828FF75C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828FF760: 488A8A5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FF768 size=344
    let mut pc: u32 = 0x828FF768;
    'dispatch: loop {
        match pc {
            0x828FF768 => {
    //   block [0x828FF768..0x828FF8C0)
	// 828FF768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF76C: 488A89F9  bl 0x831a8164
	ctx.lr = 0x828FF770;
	sub_831A8130(ctx, base);
	// 828FF770: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FF778: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828FF77C: 3BDFFFF0  addi r30, r31, -0x10
	ctx.r[30].s64 = ctx.r[31].s64 + -16;
	// 828FF780: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828FF784: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828FF788: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828FF78C: 387F03C0  addi r3, r31, 0x3c0
	ctx.r[3].s64 = ctx.r[31].s64 + 960;
	// 828FF790: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF794: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FF798: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FF79C: 4E800421  bctrl
	ctx.lr = 0x828FF7A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FF7A0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828FF7A4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828FF7A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF7B0: 4BFFEED9  bl 0x828fe688
	ctx.lr = 0x828FF7B4;
	sub_828FE688(ctx, base);
	// 828FF7B4: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 828FF7B8: 817F0380  lwz r11, 0x380(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(896 as u32) ) } as u64;
	// 828FF7BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF7C0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 828FF7C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FF7C8: 419A0028  beq cr6, 0x828ff7f0
	if ctx.cr[6].eq {
	pc = 0x828FF7F0; continue 'dispatch;
	}
	// 828FF7CC: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 828FF7D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FF7D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FF7D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FF7DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FF7E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FF7E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FF7E8: 4082FFE8  bne 0x828ff7d0
	if !ctx.cr[0].eq {
	pc = 0x828FF7D0; continue 'dispatch;
	}
	// 828FF7EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF7F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF7F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF7F8: 419A0018  beq cr6, 0x828ff810
	if ctx.cr[6].eq {
	pc = 0x828FF810; continue 'dispatch;
	}
	// 828FF7FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FF800: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828FF804: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF808: 4BFFE339  bl 0x828fdb40
	ctx.lr = 0x828FF80C;
	sub_828FDB40(ctx, base);
	// 828FF80C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF814: 419A0008  beq cr6, 0x828ff81c
	if ctx.cr[6].eq {
	pc = 0x828FF81C; continue 'dispatch;
	}
	// 828FF818: 4B9C1079  bl 0x822c0890
	ctx.lr = 0x828FF81C;
	sub_822C0890(ctx, base);
	// 828FF81C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FF820: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FF824: 4BEECDA5  bl 0x827ec5c8
	ctx.lr = 0x828FF828;
	sub_827EC5C8(ctx, base);
	// 828FF828: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FF82C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FF830: 419A0078  beq cr6, 0x828ff8a8
	if ctx.cr[6].eq {
	pc = 0x828FF8A8; continue 'dispatch;
	}
	// 828FF834: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FF838: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828FF83C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF840: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FF844: 419A0024  beq cr6, 0x828ff868
	if ctx.cr[6].eq {
	pc = 0x828FF868; continue 'dispatch;
	}
	// 828FF848: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FF84C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FF850: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FF854: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FF858: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FF85C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FF860: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FF864: 4082FFE8  bne 0x828ff84c
	if !ctx.cr[0].eq {
	pc = 0x828FF84C; continue 'dispatch;
	}
	// 828FF868: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FF86C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828FF870: 38ABACDC  addi r5, r11, -0x5324
	ctx.r[5].s64 = ctx.r[11].s64 + -21284;
	// 828FF874: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828FF878: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FF87C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF880: 4BEECFC1  bl 0x827ec840
	ctx.lr = 0x828FF884;
	sub_827EC840(ctx, base);
	// 828FF884: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828FF888: 41820020  beq 0x828ff8a8
	if ctx.cr[0].eq {
	pc = 0x828FF8A8; continue 'dispatch;
	}
	// 828FF88C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828FF890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF894: C02B7BC4  lfs f1, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FF898: 4BEEC9F1  bl 0x827ec288
	ctx.lr = 0x828FF89C;
	sub_827EC288(ctx, base);
	// 828FF89C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FF8A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF8A4: 4BEEC9CD  bl 0x827ec270
	ctx.lr = 0x828FF8A8;
	sub_827EC270(ctx, base);
	// 828FF8A8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FF8AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF8B0: 419A0008  beq cr6, 0x828ff8b8
	if ctx.cr[6].eq {
	pc = 0x828FF8B8; continue 'dispatch;
	}
	// 828FF8B4: 4B9C0FDD  bl 0x822c0890
	ctx.lr = 0x828FF8B8;
	sub_822C0890(ctx, base);
	// 828FF8B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828FF8BC: 488A88F8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF8C0 size=60
    let mut pc: u32 = 0x828FF8C0;
    'dispatch: loop {
        match pc {
            0x828FF8C0 => {
    //   block [0x828FF8C0..0x828FF8FC)
	// 828FF8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FF8C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF8CC: 4BEEDF4D  bl 0x827ed818
	ctx.lr = 0x828FF8D0;
	sub_827ED818(ctx, base);
	// 828FF8D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FF8D4: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FF8D8: 40820008  bne 0x828ff8e0
	if !ctx.cr[0].eq {
	pc = 0x828FF8E0; continue 'dispatch;
	}
	// 828FF8DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FF8E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF8E4: 419A0008  beq cr6, 0x828ff8ec
	if ctx.cr[6].eq {
	pc = 0x828FF8EC; continue 'dispatch;
	}
	// 828FF8E8: 4BFFD441  bl 0x828fcd28
	ctx.lr = 0x828FF8EC;
	sub_828FCD28(ctx, base);
	// 828FF8EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FF8F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FF8F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FF8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF900 size=88
    let mut pc: u32 = 0x828FF900;
    'dispatch: loop {
        match pc {
            0x828FF900 => {
    //   block [0x828FF900..0x828FF958)
	// 828FF900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FF908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FF90C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF910: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FF914: 4BEEDF05  bl 0x827ed818
	ctx.lr = 0x828FF918;
	sub_827ED818(ctx, base);
	// 828FF918: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FF91C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FF920: 40820008  bne 0x828ff928
	if !ctx.cr[0].eq {
	pc = 0x828FF928; continue 'dispatch;
	}
	// 828FF924: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FF928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF92C: 419A0018  beq cr6, 0x828ff944
	if ctx.cr[6].eq {
	pc = 0x828FF944; continue 'dispatch;
	}
	// 828FF930: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FF938: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FF93C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FF940: 4E800421  bctrl
	ctx.lr = 0x828FF944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FF944: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FF948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FF94C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FF950: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FF954: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF958 size=84
    let mut pc: u32 = 0x828FF958;
    'dispatch: loop {
        match pc {
            0x828FF958 => {
    //   block [0x828FF958..0x828FF9AC)
	// 828FF958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF95C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FF960: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF964: 4BEEDEB5  bl 0x827ed818
	ctx.lr = 0x828FF968;
	sub_827ED818(ctx, base);
	// 828FF968: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FF96C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FF970: 40820008  bne 0x828ff978
	if !ctx.cr[0].eq {
	pc = 0x828FF978; continue 'dispatch;
	}
	// 828FF974: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FF978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF97C: 419A0018  beq cr6, 0x828ff994
	if ctx.cr[6].eq {
	pc = 0x828FF994; continue 'dispatch;
	}
	// 828FF980: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF984: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FF98C: 4E800421  bctrl
	ctx.lr = 0x828FF990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FF990: 4800000C  b 0x828ff99c
	pc = 0x828FF99C; continue 'dispatch;
	// 828FF994: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FF998: 386BAEF0  addi r3, r11, -0x5110
	ctx.r[3].s64 = ctx.r[11].s64 + -20752;
	// 828FF99C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FF9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FF9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FF9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF9B0 size=60
    let mut pc: u32 = 0x828FF9B0;
    'dispatch: loop {
        match pc {
            0x828FF9B0 => {
    //   block [0x828FF9B0..0x828FF9EC)
	// 828FF9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FF9B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF9BC: 4BEEDE5D  bl 0x827ed818
	ctx.lr = 0x828FF9C0;
	sub_827ED818(ctx, base);
	// 828FF9C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FF9C4: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828FF9C8: 40820008  bne 0x828ff9d0
	if !ctx.cr[0].eq {
	pc = 0x828FF9D0; continue 'dispatch;
	}
	// 828FF9CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FF9D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF9D4: 419A0008  beq cr6, 0x828ff9dc
	if ctx.cr[6].eq {
	pc = 0x828FF9DC; continue 'dispatch;
	}
	// 828FF9D8: 4BFFBB11  bl 0x828fb4e8
	ctx.lr = 0x828FF9DC;
	sub_828FB4E8(ctx, base);
	// 828FF9DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FF9E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FF9E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FF9E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FF9F0 size=8
    let mut pc: u32 = 0x828FF9F0;
    'dispatch: loop {
        match pc {
            0x828FF9F0 => {
    //   block [0x828FF9F0..0x828FF9F8)
	// 828FF9F0: 386300C0  addi r3, r3, 0xc0
	ctx.r[3].s64 = ctx.r[3].s64 + 192;
	// 828FF9F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FF9F8 size=8
    let mut pc: u32 = 0x828FF9F8;
    'dispatch: loop {
        match pc {
            0x828FF9F8 => {
    //   block [0x828FF9F8..0x828FFA00)
	// 828FF9F8: 988300D0  stb r4, 0xd0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[4].u8 ) };
	// 828FF9FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FFA00 size=8
    let mut pc: u32 = 0x828FFA00;
    'dispatch: loop {
        match pc {
            0x828FFA00 => {
    //   block [0x828FFA00..0x828FFA08)
	// 828FFA00: 886300D0  lbz r3, 0xd0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 828FFA04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFA08 size=88
    let mut pc: u32 = 0x828FFA08;
    'dispatch: loop {
        match pc {
            0x828FFA08 => {
    //   block [0x828FFA08..0x828FFA60)
	// 828FFA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FFA10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FFA14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFA18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFA1C: 480174BD  bl 0x82916ed8
	ctx.lr = 0x828FFA20;
	sub_82916ED8(ctx, base);
	// 828FFA20: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FFA24: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828FFA28: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 828FFA2C: 392000C0  li r9, 0xc0
	ctx.r[9].s64 = 192;
	// 828FFA30: 394A46F4  addi r10, r10, 0x46f4
	ctx.r[10].s64 = ctx.r[10].s64 + 18164;
	// 828FFA34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FFA38: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828FFA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFA40: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FFA60 size=88
    let mut pc: u32 = 0x828FFA60;
    'dispatch: loop {
        match pc {
            0x828FFA60 => {
    //   block [0x828FFA60..0x828FFAB8)
	// 828FFA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FFA68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FFA6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FFA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFA74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFA78: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FFA7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FFA80: 396B46F4  addi r11, r11, 0x46f4
	ctx.r[11].s64 = ctx.r[11].s64 + 18164;
	// 828FFA84: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828FFA88: 480170E1  bl 0x82916b68
	ctx.lr = 0x828FFA8C;
	sub_82916B68(ctx, base);
	// 828FFA8C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FFA90: 4182000C  beq 0x828ffa9c
	if ctx.cr[0].eq {
	pc = 0x828FFA9C; continue 'dispatch;
	}
	// 828FFA94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFA98: 4B9C07D1  bl 0x822c0268
	ctx.lr = 0x828FFA9C;
	sub_822C0268(ctx, base);
	// 828FFA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFAA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FFAA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FFAA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FFAAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FFAB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FFAB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFAB8 size=104
    let mut pc: u32 = 0x828FFAB8;
    'dispatch: loop {
        match pc {
            0x828FFAB8 => {
    //   block [0x828FFAB8..0x828FFB20)
	// 828FFAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FFAC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FFAC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFACC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828FFAD0: 4BEEDD49  bl 0x827ed818
	ctx.lr = 0x828FFAD4;
	sub_827ED818(ctx, base);
	// 828FFAD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828FFAD8: 3883FFF0  addi r4, r3, -0x10
	ctx.r[4].s64 = ctx.r[3].s64 + -16;
	// 828FFADC: 40820008  bne 0x828ffae4
	if !ctx.cr[0].eq {
	pc = 0x828FFAE4; continue 'dispatch;
	}
	// 828FFAE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FFAE4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828FFAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFAEC: 419A0010  beq cr6, 0x828ffafc
	if ctx.cr[6].eq {
	pc = 0x828FFAFC; continue 'dispatch;
	}
	// 828FFAF0: 4BFFCA21  bl 0x828fc510
	ctx.lr = 0x828FFAF4;
	sub_828FC510(ctx, base);
	// 828FFAF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFAF8: 48000014  b 0x828ffb0c
	pc = 0x828FFB0C; continue 'dispatch;
	// 828FFAFC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FFB00: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 828FFB04: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828FFB20 size=16
    let mut pc: u32 = 0x828FFB20;
    'dispatch: loop {
        match pc {
            0x828FFB20 => {
    //   block [0x828FFB20..0x828FFB30)
	// 828FFB20: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 828FFB24: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFB30 size=152
    let mut pc: u32 = 0x828FFB30;
    'dispatch: loop {
        match pc {
            0x828FFB30 => {
    //   block [0x828FFB30..0x828FFBC8)
	// 828FFB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFB34: 488A8635  bl 0x831a8168
	ctx.lr = 0x828FFB38;
	sub_831A8130(ctx, base);
	// 828FFB38: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFB3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FFB40: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828FFB44: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 828FFB48: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828FFB4C: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 828FFB50: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 828FFB54: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFB58: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828FFB5C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828FFB60: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 828FFB64: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FFB68: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 828FFB6C: 13C95C07  vcmpneb. (lvlx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FFB70: 13A85C07  vcmpneb. (lvlx128) v29, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FFB74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FFB78: 13875C07  vcmpneb. (lvlx128) v28, v7, v11
	tmp.u32 = ctx.r[7].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828FFB7C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FFB80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828FFBC8 size=40
    let mut pc: u32 = 0x828FFBC8;
    'dispatch: loop {
        match pc {
            0x828FFBC8 => {
    //   block [0x828FFBC8..0x828FFBF0)
	// 828FFBC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FFBCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FFBD0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828FFBD4: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FFBD8: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FFBDC: C189E830  lfs f12, -0x17d0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FFBE0: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FFBE4: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828FFBE8: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828FFBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFBF0 size=100
    let mut pc: u32 = 0x828FFBF0;
    'dispatch: loop {
        match pc {
            0x828FFBF0 => {
    //   block [0x828FFBF0..0x828FFC54)
	// 828FFBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FFBF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FFBFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFC00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFC04: 4805A30D  bl 0x82959f10
	ctx.lr = 0x828FFC08;
	sub_82959F10(ctx, base);
	// 828FFC08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FFC0C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828FFC10: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828FFC14: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828FFC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFC1C: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FFC20: C18A89AC  lfs f12, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FFC24: C0096154  lfs f0, 0x6154(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FFC28: C168E0B4  lfs f11, -0x1f4c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8012 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FFC2C: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828FFC30: D19F007C  stfs f12, 0x7c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828FFC34: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828FFC38: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828FFC3C: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FFC40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FFC44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FFC48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FFC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FFC50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FFC58 size=64
    let mut pc: u32 = 0x828FFC58;
    'dispatch: loop {
        match pc {
            0x828FFC58 => {
    //   block [0x828FFC58..0x828FFC98)
	// 828FFC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FFC60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FFC64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFC68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFC6C: 4BFFFF85  bl 0x828ffbf0
	ctx.lr = 0x828FFC70;
	sub_828FFBF0(ctx, base);
	// 828FFC70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FFC74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFC78: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 828FFC7C: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828FFC80: 997F0058  stb r11, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 828FFC84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FFC88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FFC8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FFC90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FFC94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFC98 size=116
    let mut pc: u32 = 0x828FFC98;
    'dispatch: loop {
        match pc {
            0x828FFC98 => {
    //   block [0x828FFC98..0x828FFD0C)
	// 828FFC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFC9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FFCA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FFCA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFCA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFCAC: 4BFFFF45  bl 0x828ffbf0
	ctx.lr = 0x828FFCB0;
	sub_828FFBF0(ctx, base);
	// 828FFCB0: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 828FFCB4: 48056985  bl 0x82956638
	ctx.lr = 0x828FFCB8;
	sub_82956638(ctx, base);
	// 828FFCB8: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 828FFCBC: 48057F3D  bl 0x82957bf8
	ctx.lr = 0x828FFCC0;
	sub_82957BF8(ctx, base);
	// 828FFCC0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828FFCC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FFCC8: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 828FFCCC: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 828FFCD0: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 828FFCD4: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 828FFCD8: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828FFCDC: C00A959C  lfs f0, -0x6a64(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FFCE0: 997F0058  stb r11, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 828FFCE4: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828FFCE8: 913F00A4  stw r9, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 828FFCEC: 911F00A8  stw r8, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 828FFCF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFCF4: 90FF00AC  stw r7, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[7].u32 ) };
	// 828FFCF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FFCFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FFD00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FFD04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FFD08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFD10 size=96
    let mut pc: u32 = 0x828FFD10;
    'dispatch: loop {
        match pc {
            0x828FFD10 => {
    //   block [0x828FFD10..0x828FFD70)
	// 828FFD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFD14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FFD18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FFD1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFD20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFD24: 4BFFFECD  bl 0x828ffbf0
	ctx.lr = 0x828FFD28;
	sub_828FFBF0(ctx, base);
	// 828FFD28: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 828FFD2C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828FFD30: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828FFD34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FFD38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFD3C: C00ADD6C  lfs f0, -0x2294(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FFD40: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 828FFD44: C1A989AC  lfs f13, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FFD48: 997F0058  stb r11, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 828FFD4C: C1889524  lfs f12, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FFD50: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828FFD54: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828FFD58: D19F0090  stfs f12, 0x90(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828FFD5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FFD60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FFD64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FFD68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FFD6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFD70 size=292
    let mut pc: u32 = 0x828FFD70;
    'dispatch: loop {
        match pc {
            0x828FFD70 => {
    //   block [0x828FFD70..0x828FFE94)
	// 828FFD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFD74: 488A83F9  bl 0x831a816c
	ctx.lr = 0x828FFD78;
	sub_831A8130(ctx, base);
	// 828FFD78: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFD7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FFD80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FFD84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FFD88: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFD8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FFD90: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828FFD94: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828FFD98: 419A0024  beq cr6, 0x828ffdbc
	if ctx.cr[6].eq {
	pc = 0x828FFDBC; continue 'dispatch;
	}
	// 828FFD9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FFDA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FFDA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FFDA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FFDAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FFDB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FFDB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FFDB8: 4082FFE8  bne 0x828ffda0
	if !ctx.cr[0].eq {
	pc = 0x828FFDA0; continue 'dispatch;
	}
	// 828FFDBC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FFDC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFDC4: 4805AD55  bl 0x8295ab18
	ctx.lr = 0x828FFDC8;
	sub_8295AB18(ctx, base);
	// 828FFDC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828FFDCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FFDD0: 388B3D90  addi r4, r11, 0x3d90
	ctx.r[4].s64 = ctx.r[11].s64 + 15760;
	// 828FFDD4: 484F3C35  bl 0x82df3a08
	ctx.lr = 0x828FFDD8;
	sub_82DF3A08(ctx, base);
	// 828FFDD8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828FFDDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFDE0: 388B3D88  addi r4, r11, 0x3d88
	ctx.r[4].s64 = ctx.r[11].s64 + 15752;
	// 828FFDE4: 484F3C25  bl 0x82df3a08
	ctx.lr = 0x828FFDE8;
	sub_82DF3A08(ctx, base);
	// 828FFDE8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828FFDEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FFDF0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFDF4: 4BCCA70D  bl 0x825ca500
	ctx.lr = 0x828FFDF8;
	sub_825CA500(ctx, base);
	// 828FFDF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FFDFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFE00: 484F3629  bl 0x82df3428
	ctx.lr = 0x828FFE04;
	sub_82DF3428(ctx, base);
	// 828FFE04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FFE08: 484F3621  bl 0x82df3428
	ctx.lr = 0x828FFE0C;
	sub_82DF3428(ctx, base);
	// 828FFE0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FFE10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FFE14: 388BE0EC  addi r4, r11, -0x1f14
	ctx.r[4].s64 = ctx.r[11].s64 + -7956;
	// 828FFE18: 484F3BF1  bl 0x82df3a08
	ctx.lr = 0x828FFE1C;
	sub_82DF3A08(ctx, base);
	// 828FFE1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FFE20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FFE24: 388BE0E0  addi r4, r11, -0x1f20
	ctx.r[4].s64 = ctx.r[11].s64 + -7968;
	// 828FFE28: 484F3BE1  bl 0x82df3a08
	ctx.lr = 0x828FFE2C;
	sub_82DF3A08(ctx, base);
	// 828FFE2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828FFE30: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828FFE34: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FFE38: 38BE0078  addi r5, r30, 0x78
	ctx.r[5].s64 = ctx.r[30].s64 + 120;
	// 828FFE3C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FFE40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828FFE44: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828FFE48: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828FFE4C: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FFE50: 4BCA3459  bl 0x825a32a8
	ctx.lr = 0x828FFE54;
	sub_825A32A8(ctx, base);
	// 828FFE54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FFE58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FFE5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FFE60: 4BCA1911  bl 0x825a1770
	ctx.lr = 0x828FFE64;
	sub_825A1770(ctx, base);
	// 828FFE64: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828FFE68: 484F35C1  bl 0x82df3428
	ctx.lr = 0x828FFE6C;
	sub_82DF3428(ctx, base);
	// 828FFE6C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828FFE70: 4B9C8E49  bl 0x822c8cb8
	ctx.lr = 0x828FFE74;
	sub_822C8CB8(ctx, base);
	// 828FFE74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FFE78: 484F35B1  bl 0x82df3428
	ctx.lr = 0x828FFE7C;
	sub_82DF3428(ctx, base);
	// 828FFE7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FFE80: 484F35A9  bl 0x82df3428
	ctx.lr = 0x828FFE84;
	sub_82DF3428(ctx, base);
	// 828FFE84: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFE88: 4BCC9E49  bl 0x825c9cd0
	ctx.lr = 0x828FFE8C;
	sub_825C9CD0(ctx, base);
	// 828FFE8C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828FFE90: 488A832C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FFE98 size=4
    let mut pc: u32 = 0x828FFE98;
    'dispatch: loop {
        match pc {
            0x828FFE98 => {
    //   block [0x828FFE98..0x828FFE9C)
	// 828FFE98: 4BFFFED8  b 0x828ffd70
	sub_828FFD70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFEA0 size=584
    let mut pc: u32 = 0x828FFEA0;
    'dispatch: loop {
        match pc {
            0x828FFEA0 => {
    //   block [0x828FFEA0..0x829000E8)
	// 828FFEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFEA4: 488A82C9  bl 0x831a816c
	ctx.lr = 0x828FFEA8;
	sub_831A8130(ctx, base);
	// 828FFEA8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFEAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FFEB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FFEB4: 4BFFFEBD  bl 0x828ffd70
	ctx.lr = 0x828FFEB8;
	sub_828FFD70(ctx, base);
	// 828FFEB8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828FFEBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FFEC0: 388B7A1C  addi r4, r11, 0x7a1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31260;
	// 828FFEC4: 484F3B45  bl 0x82df3a08
	ctx.lr = 0x828FFEC8;
	sub_82DF3A08(ctx, base);
	// 828FFEC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828FFECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFED0: 388B1A04  addi r4, r11, 0x1a04
	ctx.r[4].s64 = ctx.r[11].s64 + 6660;
	// 828FFED4: 484F3B35  bl 0x82df3a08
	ctx.lr = 0x828FFED8;
	sub_82DF3A08(ctx, base);
	// 828FFED8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FFEDC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FFEE4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828FFEE8: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828FFEEC: 419A0024  beq cr6, 0x828fff10
	if ctx.cr[6].eq {
	pc = 0x828FFF10; continue 'dispatch;
	}
	// 828FFEF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FFEF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FFEF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FFEFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FFF00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FFF04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FFF08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FFF0C: 4082FFE8  bne 0x828ffef4
	if !ctx.cr[0].eq {
	pc = 0x828FFEF4; continue 'dispatch;
	}
	// 828FFF10: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828FFF14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FFF18: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828FFF1C: 387E00A4  addi r3, r30, 0xa4
	ctx.r[3].s64 = ctx.r[30].s64 + 164;
	// 828FFF20: 48057CF1  bl 0x82957c10
	ctx.lr = 0x828FFF24;
	sub_82957C10(ctx, base);
	// 828FFF24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFF28: 484F3501  bl 0x82df3428
	ctx.lr = 0x828FFF2C;
	sub_82DF3428(ctx, base);
	// 828FFF2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FFF30: 484F34F9  bl 0x82df3428
	ctx.lr = 0x828FFF34;
	sub_82DF3428(ctx, base);
	// 828FFF34: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FFF38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFF3C: 388B4810  addi r4, r11, 0x4810
	ctx.r[4].s64 = ctx.r[11].s64 + 18448;
	// 828FFF40: 484F3AC9  bl 0x82df3a08
	ctx.lr = 0x828FFF44;
	sub_82DF3A08(ctx, base);
	// 828FFF44: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828FFF48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FFF4C: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 828FFF50: 484F3AB9  bl 0x82df3a08
	ctx.lr = 0x828FFF54;
	sub_82DF3A08(ctx, base);
	// 828FFF54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FFF58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FFF5C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFF60: 4BCCA5A1  bl 0x825ca500
	ctx.lr = 0x828FFF64;
	sub_825CA500(ctx, base);
	// 828FFF64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FFF68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FFF6C: 484F34BD  bl 0x82df3428
	ctx.lr = 0x828FFF70;
	sub_82DF3428(ctx, base);
	// 828FFF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFF74: 484F34B5  bl 0x82df3428
	ctx.lr = 0x828FFF78;
	sub_82DF3428(ctx, base);
	// 828FFF78: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FFF7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828FFF80: 388B4800  addi r4, r11, 0x4800
	ctx.r[4].s64 = ctx.r[11].s64 + 18432;
	// 828FFF84: 484F3A85  bl 0x82df3a08
	ctx.lr = 0x828FFF88;
	sub_82DF3A08(ctx, base);
	// 828FFF88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FFF8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FFF90: 388B47F4  addi r4, r11, 0x47f4
	ctx.r[4].s64 = ctx.r[11].s64 + 18420;
	// 828FFF94: 484F3A75  bl 0x82df3a08
	ctx.lr = 0x828FFF98;
	sub_82DF3A08(ctx, base);
	// 828FFF98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FFF9C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828FFFA0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828FFFA4: 38BE00B4  addi r5, r30, 0xb4
	ctx.r[5].s64 = ctx.r[30].s64 + 180;
	// 828FFFA8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828FFFAC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FFFB0: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828FFFB4: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828FFFB8: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FFFBC: 4BCA32ED  bl 0x825a32a8
	ctx.lr = 0x828FFFC0;
	sub_825A32A8(ctx, base);
	// 828FFFC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FFFC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FFFC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FFFCC: 4BCA17A5  bl 0x825a1770
	ctx.lr = 0x828FFFD0;
	sub_825A1770(ctx, base);
	// 828FFFD0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828FFFD4: 484F3455  bl 0x82df3428
	ctx.lr = 0x828FFFD8;
	sub_82DF3428(ctx, base);
	// 828FFFD8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828FFFDC: 4B9C8CDD  bl 0x822c8cb8
	ctx.lr = 0x828FFFE0;
	sub_822C8CB8(ctx, base);
	// 828FFFE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FFFE4: 484F3445  bl 0x82df3428
	ctx.lr = 0x828FFFE8;
	sub_82DF3428(ctx, base);
	// 828FFFE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828FFFEC: 484F343D  bl 0x82df3428
	ctx.lr = 0x828FFFF0;
	sub_82DF3428(ctx, base);
	// 828FFFF0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFFF4: 4BCC9CDD  bl 0x825c9cd0
	ctx.lr = 0x828FFFF8;
	sub_825C9CD0(ctx, base);
	// 828FFFF8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828FFFFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900000: 388B6980  addi r4, r11, 0x6980
	ctx.r[4].s64 = ctx.r[11].s64 + 27008;
	// 82900004: 484F3A05  bl 0x82df3a08
	ctx.lr = 0x82900008;
	sub_82DF3A08(ctx, base);
	// 82900008: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8290000C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82900010: 388BA7FC  addi r4, r11, -0x5804
	ctx.r[4].s64 = ctx.r[11].s64 + -22532;
	// 82900014: 484F39F5  bl 0x82df3a08
	ctx.lr = 0x82900018;
	sub_82DF3A08(ctx, base);
	// 82900018: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290001C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82900020: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82900024: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82900028: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290002C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82900030: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900034: 4E800421  bctrl
	ctx.lr = 0x82900038;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900038: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8290003C: 484F33ED  bl 0x82df3428
	ctx.lr = 0x82900040;
	sub_82DF3428(ctx, base);
	// 82900040: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900044: 484F33E5  bl 0x82df3428
	ctx.lr = 0x82900048;
	sub_82DF3428(ctx, base);
	// 82900048: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8290004C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900050: 388B47EC  addi r4, r11, 0x47ec
	ctx.r[4].s64 = ctx.r[11].s64 + 18412;
	// 82900054: 484F39B5  bl 0x82df3a08
	ctx.lr = 0x82900058;
	sub_82DF3A08(ctx, base);
	// 82900058: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8290005C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82900060: 388B47E0  addi r4, r11, 0x47e0
	ctx.r[4].s64 = ctx.r[11].s64 + 18400;
	// 82900064: 484F39A5  bl 0x82df3a08
	ctx.lr = 0x82900068;
	sub_82DF3A08(ctx, base);
	// 82900068: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8290006C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82900070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900074: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82900078: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8290007C: 419A0024  beq cr6, 0x829000a0
	if ctx.cr[6].eq {
	pc = 0x829000A0; continue 'dispatch;
	}
	// 82900080: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82900084: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82900088: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290008C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82900090: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82900094: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82900098: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290009C: 4082FFE8  bne 0x82900084
	if !ctx.cr[0].eq {
	pc = 0x82900084; continue 'dispatch;
	}
	// 829000A0: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 829000A4: 387E0088  addi r3, r30, 0x88
	ctx.r[3].s64 = ctx.r[30].s64 + 136;
	// 829000A8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 829000AC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 829000B0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829000B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829000B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829000BC: 4E800421  bctrl
	ctx.lr = 0x829000C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829000C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829000C4: 484F3365  bl 0x82df3428
	ctx.lr = 0x829000C8;
	sub_82DF3428(ctx, base);
	// 829000C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829000CC: 484F335D  bl 0x82df3428
	ctx.lr = 0x829000D0;
	sub_82DF3428(ctx, base);
	// 829000D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829000D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829000D8: 419A0008  beq cr6, 0x829000e0
	if ctx.cr[6].eq {
	pc = 0x829000E0; continue 'dispatch;
	}
	// 829000DC: 4B9C07B5  bl 0x822c0890
	ctx.lr = 0x829000E0;
	sub_822C0890(ctx, base);
	// 829000E0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829000E4: 488A80D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829000E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829000E8 size=480
    let mut pc: u32 = 0x829000E8;
    'dispatch: loop {
        match pc {
            0x829000E8 => {
    //   block [0x829000E8..0x829002C8)
	// 829000E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829000EC: 488A8081  bl 0x831a816c
	ctx.lr = 0x829000F0;
	sub_831A8130(ctx, base);
	// 829000F0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 829000F4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829000F8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829000FC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900104: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82900108: 4BFFFC69  bl 0x828ffd70
	ctx.lr = 0x8290010C;
	sub_828FFD70(ctx, base);
	// 8290010C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900110: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82900114: 388B4810  addi r4, r11, 0x4810
	ctx.r[4].s64 = ctx.r[11].s64 + 18448;
	// 82900118: 484F38F1  bl 0x82df3a08
	ctx.lr = 0x8290011C;
	sub_82DF3A08(ctx, base);
	// 8290011C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82900120: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82900124: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 82900128: 484F38E1  bl 0x82df3a08
	ctx.lr = 0x8290012C;
	sub_82DF3A08(ctx, base);
	// 8290012C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82900130: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82900134: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900138: 4BCCA3C9  bl 0x825ca500
	ctx.lr = 0x8290013C;
	sub_825CA500(ctx, base);
	// 8290013C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82900140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82900144: 484F32E5  bl 0x82df3428
	ctx.lr = 0x82900148;
	sub_82DF3428(ctx, base);
	// 82900148: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8290014C: 484F32DD  bl 0x82df3428
	ctx.lr = 0x82900150;
	sub_82DF3428(ctx, base);
	// 82900150: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900154: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900158: 388BD3E4  addi r4, r11, -0x2c1c
	ctx.r[4].s64 = ctx.r[11].s64 + -11292;
	// 8290015C: 484F38AD  bl 0x82df3a08
	ctx.lr = 0x82900160;
	sub_82DF3A08(ctx, base);
	// 82900160: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900164: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82900168: 388BD3D0  addi r4, r11, -0x2c30
	ctx.r[4].s64 = ctx.r[11].s64 + -11312;
	// 8290016C: 484F389D  bl 0x82df3a08
	ctx.lr = 0x82900170;
	sub_82DF3A08(ctx, base);
	// 82900170: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82900174: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82900178: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8290017C: 38BF0088  addi r5, r31, 0x88
	ctx.r[5].s64 = ctx.r[31].s64 + 136;
	// 82900180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900184: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82900188: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290018C: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82900190: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82900194: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82900198: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8290019C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829001A0: 4BCA3109  bl 0x825a32a8
	ctx.lr = 0x829001A4;
	sub_825A32A8(ctx, base);
	// 829001A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829001A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829001AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829001B0: 4BCA15C1  bl 0x825a1770
	ctx.lr = 0x829001B4;
	sub_825A1770(ctx, base);
	// 829001B4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829001B8: 484F3271  bl 0x82df3428
	ctx.lr = 0x829001BC;
	sub_82DF3428(ctx, base);
	// 829001BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829001C0: 4B9C8AF9  bl 0x822c8cb8
	ctx.lr = 0x829001C4;
	sub_822C8CB8(ctx, base);
	// 829001C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829001C8: 484F3261  bl 0x82df3428
	ctx.lr = 0x829001CC;
	sub_82DF3428(ctx, base);
	// 829001CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829001D0: 484F3259  bl 0x82df3428
	ctx.lr = 0x829001D4;
	sub_82DF3428(ctx, base);
	// 829001D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829001D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829001DC: 388BD3BC  addi r4, r11, -0x2c44
	ctx.r[4].s64 = ctx.r[11].s64 + -11332;
	// 829001E0: 484F3829  bl 0x82df3a08
	ctx.lr = 0x829001E4;
	sub_82DF3A08(ctx, base);
	// 829001E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829001E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829001EC: 388BD3A4  addi r4, r11, -0x2c5c
	ctx.r[4].s64 = ctx.r[11].s64 + -11356;
	// 829001F0: 484F3819  bl 0x82df3a08
	ctx.lr = 0x829001F4;
	sub_82DF3A08(ctx, base);
	// 829001F4: 38BF008C  addi r5, r31, 0x8c
	ctx.r[5].s64 = ctx.r[31].s64 + 140;
	// 829001F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829001FC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82900200: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82900204: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82900208: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8290020C: 4BCA309D  bl 0x825a32a8
	ctx.lr = 0x82900210;
	sub_825A32A8(ctx, base);
	// 82900210: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82900214: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900218: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290021C: 4BCA1555  bl 0x825a1770
	ctx.lr = 0x82900220;
	sub_825A1770(ctx, base);
	// 82900220: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82900224: 484F3205  bl 0x82df3428
	ctx.lr = 0x82900228;
	sub_82DF3428(ctx, base);
	// 82900228: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8290022C: 4B9C8A8D  bl 0x822c8cb8
	ctx.lr = 0x82900230;
	sub_822C8CB8(ctx, base);
	// 82900230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900234: 484F31F5  bl 0x82df3428
	ctx.lr = 0x82900238;
	sub_82DF3428(ctx, base);
	// 82900238: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290023C: 484F31ED  bl 0x82df3428
	ctx.lr = 0x82900240;
	sub_82DF3428(ctx, base);
	// 82900240: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900244: 388BE0C8  addi r4, r11, -0x1f38
	ctx.r[4].s64 = ctx.r[11].s64 + -7992;
	// 82900248: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290024C: 484F37BD  bl 0x82df3a08
	ctx.lr = 0x82900250;
	sub_82DF3A08(ctx, base);
	// 82900250: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900258: 388BE0B0  addi r4, r11, -0x1f50
	ctx.r[4].s64 = ctx.r[11].s64 + -8016;
	// 8290025C: 484F37AD  bl 0x82df3a08
	ctx.lr = 0x82900260;
	sub_82DF3A08(ctx, base);
	// 82900260: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 82900264: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82900268: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8290026C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82900270: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82900274: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82900278: 4BCA3031  bl 0x825a32a8
	ctx.lr = 0x8290027C;
	sub_825A32A8(ctx, base);
	// 8290027C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82900280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900284: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82900288: 4BCA14E9  bl 0x825a1770
	ctx.lr = 0x8290028C;
	sub_825A1770(ctx, base);
	// 8290028C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82900290: 484F3199  bl 0x82df3428
	ctx.lr = 0x82900294;
	sub_82DF3428(ctx, base);
	// 82900294: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82900298: 4B9C8A21  bl 0x822c8cb8
	ctx.lr = 0x8290029C;
	sub_822C8CB8(ctx, base);
	// 8290029C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829002A0: 484F3189  bl 0x82df3428
	ctx.lr = 0x829002A4;
	sub_82DF3428(ctx, base);
	// 829002A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829002A8: 484F3181  bl 0x82df3428
	ctx.lr = 0x829002AC;
	sub_82DF3428(ctx, base);
	// 829002AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829002B0: 4BCC9A21  bl 0x825c9cd0
	ctx.lr = 0x829002B4;
	sub_825C9CD0(ctx, base);
	// 829002B4: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 829002B8: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829002BC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829002C0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829002C4: 488A7EF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829002C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829002C8 size=76
    let mut pc: u32 = 0x829002C8;
    'dispatch: loop {
        match pc {
            0x829002C8 => {
    //   block [0x829002C8..0x82900314)
	// 829002C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829002CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829002D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829002D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829002D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829002DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829002E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829002E4: 808BC22C  lwz r4, -0x3dd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15828 as u32) ) } as u64;
	// 829002E8: 484F3721  bl 0x82df3a08
	ctx.lr = 0x829002EC;
	sub_82DF3A08(ctx, base);
	// 829002EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829002F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829002F4: 4BEEF44D  bl 0x827ef740
	ctx.lr = 0x829002F8;
	sub_827EF740(ctx, base);
	// 829002F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829002FC: 484F312D  bl 0x82df3428
	ctx.lr = 0x82900300;
	sub_82DF3428(ctx, base);
	// 82900300: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290030C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900318 size=132
    let mut pc: u32 = 0x82900318;
    'dispatch: loop {
        match pc {
            0x82900318 => {
    //   block [0x82900318..0x8290039C)
	// 82900318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290031C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900320: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900324: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900328: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8290032C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900330: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900334: 808B0BEC  lwz r4, 0xbec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) } as u64;
	// 82900338: 484F36D1  bl 0x82df3a08
	ctx.lr = 0x8290033C;
	sub_82DF3A08(ctx, base);
	// 8290033C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900340: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900344: 4BEEF42D  bl 0x827ef770
	ctx.lr = 0x82900348;
	sub_827EF770(ctx, base);
	// 82900348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290034C: 484F30DD  bl 0x82df3428
	ctx.lr = 0x82900350;
	sub_82DF3428(ctx, base);
	// 82900350: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900358: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 8290035C: 484F36AD  bl 0x82df3a08
	ctx.lr = 0x82900360;
	sub_82DF3A08(ctx, base);
	// 82900360: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290036C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82900370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900374: 4E800421  bctrl
	ctx.lr = 0x82900378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290037C: 484F30AD  bl 0x82df3428
	ctx.lr = 0x82900380;
	sub_82DF3428(ctx, base);
	// 82900380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900384: 4BFC2345  bl 0x828c26c8
	ctx.lr = 0x82900388;
	sub_828C26C8(ctx, base);
	// 82900388: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290038C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900394: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829003A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829003A0 size=12
    let mut pc: u32 = 0x829003A0;
    'dispatch: loop {
        match pc {
            0x829003A0 => {
    //   block [0x829003A0..0x829003AC)
	// 829003A0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 829003A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829003A8: 4BFFF558  b 0x828ff900
	sub_828FF900(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829003B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829003B0 size=8
    let mut pc: u32 = 0x829003B0;
    'dispatch: loop {
        match pc {
            0x829003B0 => {
    //   block [0x829003B0..0x829003B8)
	// 829003B0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829003B4: 4BFFF50C  b 0x828ff8c0
	sub_828FF8C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829003B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829003B8 size=124
    let mut pc: u32 = 0x829003B8;
    'dispatch: loop {
        match pc {
            0x829003B8 => {
    //   block [0x829003B8..0x82900434)
	// 829003B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829003BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829003C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829003C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829003C8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829003CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829003D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829003D4: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 829003D8: 484F3631  bl 0x82df3a08
	ctx.lr = 0x829003DC;
	sub_82DF3A08(ctx, base);
	// 829003DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829003E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829003E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829003E8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829003EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829003F0: 4E800421  bctrl
	ctx.lr = 0x829003F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829003F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829003F8: 484F3031  bl 0x82df3428
	ctx.lr = 0x829003FC;
	sub_82DF3428(ctx, base);
	// 829003FC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900404: 808B0BEC  lwz r4, 0xbec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) } as u64;
	// 82900408: 484F3601  bl 0x82df3a08
	ctx.lr = 0x8290040C;
	sub_82DF3A08(ctx, base);
	// 8290040C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900414: 4BEEF35D  bl 0x827ef770
	ctx.lr = 0x82900418;
	sub_827EF770(ctx, base);
	// 82900418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290041C: 484F300D  bl 0x82df3428
	ctx.lr = 0x82900420;
	sub_82DF3428(ctx, base);
	// 82900420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290042C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900438 size=88
    let mut pc: u32 = 0x82900438;
    'dispatch: loop {
        match pc {
            0x82900438 => {
    //   block [0x82900438..0x82900490)
	// 82900438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290043C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900444: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900448: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8290044C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900450: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900454: 808BC204  lwz r4, -0x3dfc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15868 as u32) ) } as u64;
	// 82900458: 484F35B1  bl 0x82df3a08
	ctx.lr = 0x8290045C;
	sub_82DF3A08(ctx, base);
	// 8290045C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900460: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900468: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290046C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900470: 4E800421  bctrl
	ctx.lr = 0x82900474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900478: 484F2FB1  bl 0x82df3428
	ctx.lr = 0x8290047C;
	sub_82DF3428(ctx, base);
	// 8290047C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900480: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900484: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290048C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900490 size=108
    let mut pc: u32 = 0x82900490;
    'dispatch: loop {
        match pc {
            0x82900490 => {
    //   block [0x82900490..0x829004FC)
	// 82900490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900498: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290049C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829004A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829004A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829004A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829004AC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 829004B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829004B4: 4E800421  bctrl
	ctx.lr = 0x829004B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829004B8: 4BEE9E59  bl 0x827ea310
	ctx.lr = 0x829004BC;
	sub_827EA310(ctx, base);
	// 829004BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829004C0: 41820028  beq 0x829004e8
	if ctx.cr[0].eq {
	pc = 0x829004E8; continue 'dispatch;
	}
	// 829004C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829004C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829004CC: 808BC22C  lwz r4, -0x3dd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15828 as u32) ) } as u64;
	// 829004D0: 484F3539  bl 0x82df3a08
	ctx.lr = 0x829004D4;
	sub_82DF3A08(ctx, base);
	// 829004D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829004D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829004DC: 4BEEF265  bl 0x827ef740
	ctx.lr = 0x829004E0;
	sub_827EF740(ctx, base);
	// 829004E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829004E4: 484F2F45  bl 0x82df3428
	ctx.lr = 0x829004E8;
	sub_82DF3428(ctx, base);
	// 829004E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829004EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829004F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829004F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829004F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82900500 size=16
    let mut pc: u32 = 0x82900500;
    'dispatch: loop {
        match pc {
            0x82900500 => {
    //   block [0x82900500..0x82900510)
	// 82900500: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82900504: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82900508: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8290050C: 48016B14  b 0x82917020
	sub_82917020(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900510 size=120
    let mut pc: u32 = 0x82900510;
    'dispatch: loop {
        match pc {
            0x82900510 => {
    //   block [0x82900510..0x82900588)
	// 82900510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290051C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900524: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900528: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8290052C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900530: 48016239  bl 0x82916768
	ctx.lr = 0x82900534;
	sub_82916768(ctx, base);
	// 82900534: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82900538: 41820018  beq 0x82900550
	if ctx.cr[0].eq {
	pc = 0x82900550; continue 'dispatch;
	}
	// 8290053C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900540: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82900544: 816B00BC  lwz r11, 0xbc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 82900548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290054C: 4E800421  bctrl
	ctx.lr = 0x82900550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900550: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82900554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900558: 484F34B1  bl 0x82df3a08
	ctx.lr = 0x8290055C;
	sub_82DF3A08(ctx, base);
	// 8290055C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900564: 4BEEF1DD  bl 0x827ef740
	ctx.lr = 0x82900568;
	sub_827EF740(ctx, base);
	// 82900568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290056C: 484F2EBD  bl 0x82df3428
	ctx.lr = 0x82900570;
	sub_82DF3428(ctx, base);
	// 82900570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290057C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900580: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900588 size=112
    let mut pc: u32 = 0x82900588;
    'dispatch: loop {
        match pc {
            0x82900588 => {
    //   block [0x82900588..0x829005F8)
	// 82900588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290058C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900598: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290059C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829005A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829005A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829005A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829005AC: 808B0BEC  lwz r4, 0xbec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) } as u64;
	// 829005B0: 484F3459  bl 0x82df3a08
	ctx.lr = 0x829005B4;
	sub_82DF3A08(ctx, base);
	// 829005B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829005B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829005BC: 4BEEF1B5  bl 0x827ef770
	ctx.lr = 0x829005C0;
	sub_827EF770(ctx, base);
	// 829005C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829005C4: 484F2E65  bl 0x82df3428
	ctx.lr = 0x829005C8;
	sub_82DF3428(ctx, base);
	// 829005C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829005CC: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 829005D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829005D4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829005D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829005DC: 4E800421  bctrl
	ctx.lr = 0x829005E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829005E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829005E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829005E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829005EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829005F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829005F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829005F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829005F8 size=112
    let mut pc: u32 = 0x829005F8;
    'dispatch: loop {
        match pc {
            0x829005F8 => {
    //   block [0x829005F8..0x82900668)
	// 829005F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829005FC: 488A7B71  bl 0x831a816c
	ctx.lr = 0x82900600;
	sub_831A8130(ctx, base);
	// 82900600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900604: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82900608: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290060C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900610: 48016159  bl 0x82916768
	ctx.lr = 0x82900614;
	sub_82916768(ctx, base);
	// 82900614: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82900618: 41820030  beq 0x82900648
	if ctx.cr[0].eq {
	pc = 0x82900648; continue 'dispatch;
	}
	// 8290061C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900620: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82900624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900628: 816B00BC  lwz r11, 0xbc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 8290062C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900630: 4E800421  bctrl
	ctx.lr = 0x82900634;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900634: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290063C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82900640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900644: 4E800421  bctrl
	ctx.lr = 0x82900648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900648: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290064C: 389D0070  addi r4, r29, 0x70
	ctx.r[4].s64 = ctx.r[29].s64 + 112;
	// 82900650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900654: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82900658: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290065C: 4E800421  bctrl
	ctx.lr = 0x82900660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900664: 488A7B58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900668 size=64
    let mut pc: u32 = 0x82900668;
    'dispatch: loop {
        match pc {
            0x82900668 => {
    //   block [0x82900668..0x829006A8)
	// 82900668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290066C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900670: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900674: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900678: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8290067C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900680: 4E800421  bctrl
	ctx.lr = 0x82900684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900684: 4BEE9C8D  bl 0x827ea310
	ctx.lr = 0x82900688;
	sub_827EA310(ctx, base);
	// 82900688: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290068C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82900690: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82900694: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82900698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290069C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829006A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829006A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829006A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829006A8 size=12
    let mut pc: u32 = 0x829006A8;
    'dispatch: loop {
        match pc {
            0x829006A8 => {
    //   block [0x829006A8..0x829006B4)
	// 829006A8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829006AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829006B0: 4BFFF348  b 0x828ff9f8
	sub_828FF9F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829006B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829006B8 size=52
    let mut pc: u32 = 0x829006B8;
    'dispatch: loop {
        match pc {
            0x829006B8 => {
    //   block [0x829006B8..0x829006EC)
	// 829006B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829006BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829006C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829006C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829006C8: 480160A1  bl 0x82916768
	ctx.lr = 0x829006CC;
	sub_82916768(ctx, base);
	// 829006CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829006D0: 4182000C  beq 0x829006dc
	if ctx.cr[0].eq {
	pc = 0x829006DC; continue 'dispatch;
	}
	// 829006D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829006D8: 48009CD9  bl 0x8290a3b0
	ctx.lr = 0x829006DC;
	sub_8290A3B0(ctx, base);
	// 829006DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829006E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829006E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829006E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829006F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829006F0 size=136
    let mut pc: u32 = 0x829006F0;
    'dispatch: loop {
        match pc {
            0x829006F0 => {
    //   block [0x829006F0..0x82900778)
	// 829006F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829006F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829006F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829006FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900704: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900708: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290070C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82900710: 409A0020  bne cr6, 0x82900730
	if !ctx.cr[6].eq {
	pc = 0x82900730; continue 'dispatch;
	}
	// 82900714: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82900718: 419A0048  beq cr6, 0x82900760
	if ctx.cr[6].eq {
	pc = 0x82900760; continue 'dispatch;
	}
	// 8290071C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82900720: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82900724: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82900728: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8290072C: 48000034  b 0x82900760
	pc = 0x82900760; continue 'dispatch;
	// 82900730: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82900734: 419A002C  beq cr6, 0x82900760
	if ctx.cr[6].eq {
	pc = 0x82900760; continue 'dispatch;
	}
	// 82900738: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8290073C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900740: 388BC610  addi r4, r11, -0x39f0
	ctx.r[4].s64 = ctx.r[11].s64 + -14832;
	// 82900744: 488A79B5  bl 0x831a80f8
	ctx.lr = 0x82900748;
	sub_831A80F8(ctx, base);
	// 82900748: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290074C: 4182000C  beq 0x82900758
	if ctx.cr[0].eq {
	pc = 0x82900758; continue 'dispatch;
	}
	// 82900750: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82900754: 4800000C  b 0x82900760
	pc = 0x82900760; continue 'dispatch;
	// 82900758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290075C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900760: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290076C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900770: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900778 size=136
    let mut pc: u32 = 0x82900778;
    'dispatch: loop {
        match pc {
            0x82900778 => {
    //   block [0x82900778..0x82900800)
	// 82900778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290077C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290078C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900790: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900794: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82900798: 409A0020  bne cr6, 0x829007b8
	if !ctx.cr[6].eq {
	pc = 0x829007B8; continue 'dispatch;
	}
	// 8290079C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829007A0: 419A0048  beq cr6, 0x829007e8
	if ctx.cr[6].eq {
	pc = 0x829007E8; continue 'dispatch;
	}
	// 829007A4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829007A8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829007AC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829007B0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829007B4: 48000034  b 0x829007e8
	pc = 0x829007E8; continue 'dispatch;
	// 829007B8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829007BC: 419A002C  beq cr6, 0x829007e8
	if ctx.cr[6].eq {
	pc = 0x829007E8; continue 'dispatch;
	}
	// 829007C0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829007C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829007C8: 388BC6E0  addi r4, r11, -0x3920
	ctx.r[4].s64 = ctx.r[11].s64 + -14624;
	// 829007CC: 488A792D  bl 0x831a80f8
	ctx.lr = 0x829007D0;
	sub_831A80F8(ctx, base);
	// 829007D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829007D4: 4182000C  beq 0x829007e0
	if ctx.cr[0].eq {
	pc = 0x829007E0; continue 'dispatch;
	}
	// 829007D8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829007DC: 4800000C  b 0x829007e8
	pc = 0x829007E8; continue 'dispatch;
	// 829007E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829007E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829007E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829007EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829007F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829007F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829007F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829007FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900800 size=136
    let mut pc: u32 = 0x82900800;
    'dispatch: loop {
        match pc {
            0x82900800 => {
    //   block [0x82900800..0x82900888)
	// 82900800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290080C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900814: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900818: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290081C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82900820: 409A0020  bne cr6, 0x82900840
	if !ctx.cr[6].eq {
	pc = 0x82900840; continue 'dispatch;
	}
	// 82900824: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82900828: 419A0048  beq cr6, 0x82900870
	if ctx.cr[6].eq {
	pc = 0x82900870; continue 'dispatch;
	}
	// 8290082C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82900830: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82900834: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82900838: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8290083C: 48000034  b 0x82900870
	pc = 0x82900870; continue 'dispatch;
	// 82900840: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82900844: 419A002C  beq cr6, 0x82900870
	if ctx.cr[6].eq {
	pc = 0x82900870; continue 'dispatch;
	}
	// 82900848: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8290084C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900850: 388BC7B8  addi r4, r11, -0x3848
	ctx.r[4].s64 = ctx.r[11].s64 + -14408;
	// 82900854: 488A78A5  bl 0x831a80f8
	ctx.lr = 0x82900858;
	sub_831A80F8(ctx, base);
	// 82900858: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290085C: 4182000C  beq 0x82900868
	if ctx.cr[0].eq {
	pc = 0x82900868; continue 'dispatch;
	}
	// 82900860: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82900864: 4800000C  b 0x82900870
	pc = 0x82900870; continue 'dispatch;
	// 82900868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290086C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290087C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900888 size=136
    let mut pc: u32 = 0x82900888;
    'dispatch: loop {
        match pc {
            0x82900888 => {
    //   block [0x82900888..0x82900910)
	// 82900888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290088C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290089C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829008A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829008A4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829008A8: 409A0020  bne cr6, 0x829008c8
	if !ctx.cr[6].eq {
	pc = 0x829008C8; continue 'dispatch;
	}
	// 829008AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829008B0: 419A0048  beq cr6, 0x829008f8
	if ctx.cr[6].eq {
	pc = 0x829008F8; continue 'dispatch;
	}
	// 829008B4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829008B8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829008BC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829008C0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829008C4: 48000034  b 0x829008f8
	pc = 0x829008F8; continue 'dispatch;
	// 829008C8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829008CC: 419A002C  beq cr6, 0x829008f8
	if ctx.cr[6].eq {
	pc = 0x829008F8; continue 'dispatch;
	}
	// 829008D0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829008D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829008D8: 388BC890  addi r4, r11, -0x3770
	ctx.r[4].s64 = ctx.r[11].s64 + -14192;
	// 829008DC: 488A781D  bl 0x831a80f8
	ctx.lr = 0x829008E0;
	sub_831A80F8(ctx, base);
	// 829008E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829008E4: 4182000C  beq 0x829008f0
	if ctx.cr[0].eq {
	pc = 0x829008F0; continue 'dispatch;
	}
	// 829008E8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829008EC: 4800000C  b 0x829008f8
	pc = 0x829008F8; continue 'dispatch;
	// 829008F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829008F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829008F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829008FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900904: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290090C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900910 size=136
    let mut pc: u32 = 0x82900910;
    'dispatch: loop {
        match pc {
            0x82900910 => {
    //   block [0x82900910..0x82900998)
	// 82900910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290091C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900928: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290092C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82900930: 409A0020  bne cr6, 0x82900950
	if !ctx.cr[6].eq {
	pc = 0x82900950; continue 'dispatch;
	}
	// 82900934: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82900938: 419A0048  beq cr6, 0x82900980
	if ctx.cr[6].eq {
	pc = 0x82900980; continue 'dispatch;
	}
	// 8290093C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82900940: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82900944: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82900948: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8290094C: 48000034  b 0x82900980
	pc = 0x82900980; continue 'dispatch;
	// 82900950: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82900954: 419A002C  beq cr6, 0x82900980
	if ctx.cr[6].eq {
	pc = 0x82900980; continue 'dispatch;
	}
	// 82900958: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8290095C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900960: 388BC960  addi r4, r11, -0x36a0
	ctx.r[4].s64 = ctx.r[11].s64 + -13984;
	// 82900964: 488A7795  bl 0x831a80f8
	ctx.lr = 0x82900968;
	sub_831A80F8(ctx, base);
	// 82900968: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290096C: 4182000C  beq 0x82900978
	if ctx.cr[0].eq {
	pc = 0x82900978; continue 'dispatch;
	}
	// 82900970: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82900974: 4800000C  b 0x82900980
	pc = 0x82900980; continue 'dispatch;
	// 82900978: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290097C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900980: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290098C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900998 size=88
    let mut pc: u32 = 0x82900998;
    'dispatch: loop {
        match pc {
            0x82900998 => {
    //   block [0x82900998..0x829009F0)
	// 82900998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290099C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829009A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829009A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829009A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829009AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829009B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829009B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829009B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829009BC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829009C0: 48016661  bl 0x82917020
	ctx.lr = 0x829009C4;
	sub_82917020(ctx, base);
	// 829009C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829009C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829009CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829009D0: 80AB0B50  lwz r5, 0xb50(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 829009D4: 4BFFFB3D  bl 0x82900510
	ctx.lr = 0x829009D8;
	sub_82900510(ctx, base);
	// 829009D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829009DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829009E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829009E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829009E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829009EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829009F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829009F0 size=200
    let mut pc: u32 = 0x829009F0;
    'dispatch: loop {
        match pc {
            0x829009F0 => {
    //   block [0x829009F0..0x82900AB8)
	// 829009F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829009F4: 488A7779  bl 0x831a816c
	ctx.lr = 0x829009F8;
	sub_831A8130(ctx, base);
	// 829009F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829009FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900A00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900A04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900A08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900A0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82900A10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900A14: 4E800421  bctrl
	ctx.lr = 0x82900A18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900A18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82900A1C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82900A20: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900A24: 38BE0070  addi r5, r30, 0x70
	ctx.r[5].s64 = ctx.r[30].s64 + 112;
	// 82900A28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82900A2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82900A30: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900A34: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82900A38: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900A3C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82900A40: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900A44: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82900A48: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900A4C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82900A50: C02A964C  lfs f1, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82900A54: 4857C875  bl 0x82e7d2c8
	ctx.lr = 0x82900A58;
	sub_82E7D2C8(ctx, base);
	// 82900A58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900A5C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82900A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900A64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900A68: 4E800421  bctrl
	ctx.lr = 0x82900A6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900A6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900A74: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82900A78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900A7C: 4E800421  bctrl
	ctx.lr = 0x82900A80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900A80: 4BEE9891  bl 0x827ea310
	ctx.lr = 0x82900A84;
	sub_827EA310(ctx, base);
	// 82900A84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82900A88: 41820028  beq 0x82900ab0
	if ctx.cr[0].eq {
	pc = 0x82900AB0; continue 'dispatch;
	}
	// 82900A8C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900A90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900A94: 808BC22C  lwz r4, -0x3dd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15828 as u32) ) } as u64;
	// 82900A98: 484F2F71  bl 0x82df3a08
	ctx.lr = 0x82900A9C;
	sub_82DF3A08(ctx, base);
	// 82900A9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900AA4: 4BEEEC9D  bl 0x827ef740
	ctx.lr = 0x82900AA8;
	sub_827EF740(ctx, base);
	// 82900AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900AAC: 484F297D  bl 0x82df3428
	ctx.lr = 0x82900AB0;
	sub_82DF3428(ctx, base);
	// 82900AB0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82900AB4: 488A7708  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82900AB8 size=356
    let mut pc: u32 = 0x82900AB8;
    'dispatch: loop {
        match pc {
            0x82900AB8 => {
    //   block [0x82900AB8..0x82900C1C)
	// 82900AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900ABC: 488A76AD  bl 0x831a8168
	ctx.lr = 0x82900AC0;
	sub_831A8130(ctx, base);
	// 82900AC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900AC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900AC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82900ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900AD0: 48015C99  bl 0x82916768
	ctx.lr = 0x82900AD4;
	sub_82916768(ctx, base);
	// 82900AD4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82900AD8: 4182006C  beq 0x82900b44
	if ctx.cr[0].eq {
	pc = 0x82900B44; continue 'dispatch;
	}
	// 82900ADC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900AE4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82900AE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900AEC: 4E800421  bctrl
	ctx.lr = 0x82900AF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900AF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82900AF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82900AF8: 38BC0070  addi r5, r28, 0x70
	ctx.r[5].s64 = ctx.r[28].s64 + 112;
	// 82900AFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900B00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900B04: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900B08: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82900B0C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900B10: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82900B14: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900B18: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82900B1C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900B20: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82900B24: C02A964C  lfs f1, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82900B28: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900B2C: 4857C79D  bl 0x82e7d2c8
	ctx.lr = 0x82900B30;
	sub_82E7D2C8(ctx, base);
	// 82900B30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900B34: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 82900B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900B3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900B40: 4E800421  bctrl
	ctx.lr = 0x82900B44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900B48: 48015C21  bl 0x82916768
	ctx.lr = 0x82900B4C;
	sub_82916768(ctx, base);
	// 82900B4C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82900B50: 41820088  beq 0x82900bd8
	if ctx.cr[0].eq {
	pc = 0x82900BD8; continue 'dispatch;
	}
	// 82900B54: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900B58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82900B5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900B60: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 82900B64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900B68: 4E800421  bctrl
	ctx.lr = 0x82900B6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900B6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900B74: 4BEEEE1D  bl 0x827ef990
	ctx.lr = 0x82900B78;
	sub_827EF990(ctx, base);
	// 82900B78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900B7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82900B80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900B84: 816B0090  lwz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82900B88: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900B8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900B90: 4E800421  bctrl
	ctx.lr = 0x82900B94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900B94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900B98: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82900B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900BA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900BA4: 4E800421  bctrl
	ctx.lr = 0x82900BA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900BA8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900BAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82900BB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900BB4: 816B0094  lwz r11, 0x94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 82900BB8: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900BBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900BC0: 4E800421  bctrl
	ctx.lr = 0x82900BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900BC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900BC8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82900BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900BD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900BD4: 4E800421  bctrl
	ctx.lr = 0x82900BD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900BD8: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 82900BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900BE0: 419A0034  beq cr6, 0x82900c14
	if ctx.cr[6].eq {
	pc = 0x82900C14; continue 'dispatch;
	}
	// 82900BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900BE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900BEC: 4E800421  bctrl
	ctx.lr = 0x82900BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900BF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82900BF4: 41820020  beq 0x82900c14
	if ctx.cr[0].eq {
	pc = 0x82900C14; continue 'dispatch;
	}
	// 82900BF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900BFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82900C00: 917C0080  stw r11, 0x80(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82900C04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82900C08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82900C0C: C02A08A4  lfs f1, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82900C10: 4855BE29  bl 0x82e5ca38
	ctx.lr = 0x82900C14;
	sub_82E5CA38(ctx, base);
	// 82900C14: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82900C18: 488A75A0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82900C20 size=204
    let mut pc: u32 = 0x82900C20;
    'dispatch: loop {
        match pc {
            0x82900C20 => {
    //   block [0x82900C20..0x82900CEC)
	// 82900C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900C28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900C2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900C34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900C38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900C40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900C44: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82900C48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900C4C: 4E800421  bctrl
	ctx.lr = 0x82900C50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900C50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82900C54: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900C58: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82900C5C: 41990010  bgt cr6, 0x82900c6c
	if ctx.cr[6].gt {
	pc = 0x82900C6C; continue 'dispatch;
	}
	// 82900C60: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900C64: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 82900C68: 48000024  b 0x82900c8c
	pc = 0x82900C8C; continue 'dispatch;
	// 82900C6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900C70: 48558AF1  bl 0x82e59760
	ctx.lr = 0x82900C74;
	sub_82E59760(ctx, base);
	// 82900C74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900C78: C00B4858  lfs f0, 0x4858(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82900C7C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82900C80: 40990028  ble cr6, 0x82900ca8
	if !ctx.cr[6].gt {
	pc = 0x82900CA8; continue 'dispatch;
	}
	// 82900C84: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900C88: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 82900C8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900C90: 484F2D79  bl 0x82df3a08
	ctx.lr = 0x82900C94;
	sub_82DF3A08(ctx, base);
	// 82900C94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900C9C: 4BEEEAA5  bl 0x827ef740
	ctx.lr = 0x82900CA0;
	sub_827EF740(ctx, base);
	// 82900CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900CA4: 484F2785  bl 0x82df3428
	ctx.lr = 0x82900CA8;
	sub_82DF3428(ctx, base);
	// 82900CA8: 83DE006C  lwz r30, 0x6c(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82900CAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82900CB0: 419A0024  beq cr6, 0x82900cd4
	if ctx.cr[6].eq {
	pc = 0x82900CD4; continue 'dispatch;
	}
	// 82900CB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900CB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900CBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900CC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900CC4: 4E800421  bctrl
	ctx.lr = 0x82900CC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900CC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900CCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900CD0: 48245ED9  bl 0x82b46ba8
	ctx.lr = 0x82900CD4;
	sub_82B46BA8(ctx, base);
	// 82900CD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900CD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900CDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900CE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900CE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900CF0 size=84
    let mut pc: u32 = 0x82900CF0;
    'dispatch: loop {
        match pc {
            0x82900CF0 => {
    //   block [0x82900CF0..0x82900D44)
	// 82900CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900CF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900CFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900D00: 48853901  bl 0x83154600
	ctx.lr = 0x82900D04;
	sub_83154600(ctx, base);
	// 82900D04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82900D08: 41820028  beq 0x82900d30
	if ctx.cr[0].eq {
	pc = 0x82900D30; continue 'dispatch;
	}
	// 82900D0C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900D10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900D14: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 82900D18: 484F2CF1  bl 0x82df3a08
	ctx.lr = 0x82900D1C;
	sub_82DF3A08(ctx, base);
	// 82900D1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900D24: 4BEEEA1D  bl 0x827ef740
	ctx.lr = 0x82900D28;
	sub_827EF740(ctx, base);
	// 82900D28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900D2C: 484F26FD  bl 0x82df3428
	ctx.lr = 0x82900D30;
	sub_82DF3428(ctx, base);
	// 82900D30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900D3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900D48 size=88
    let mut pc: u32 = 0x82900D48;
    'dispatch: loop {
        match pc {
            0x82900D48 => {
    //   block [0x82900D48..0x82900DA0)
	// 82900D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900D4C: 488A7421  bl 0x831a816c
	ctx.lr = 0x82900D50;
	sub_831A8130(ctx, base);
	// 82900D50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900D54: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900D58: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82900D5C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900D60: 48000028  b 0x82900d88
	pc = 0x82900D88; continue 'dispatch;
	// 82900D64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82900D68: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82900D6C: 484F24CD  bl 0x82df3238
	ctx.lr = 0x82900D70;
	sub_82DF3238(ctx, base);
	// 82900D70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82900D74: 4182000C  beq 0x82900d80
	if ctx.cr[0].eq {
	pc = 0x82900D80; continue 'dispatch;
	}
	// 82900D78: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82900D7C: 4800000C  b 0x82900d88
	pc = 0x82900D88; continue 'dispatch;
	// 82900D80: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82900D84: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900D88: 897F0051  lbz r11, 0x51(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(81 as u32) ) } as u64;
	// 82900D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900D90: 419AFFD4  beq cr6, 0x82900d64
	if ctx.cr[6].eq {
	pc = 0x82900D64; continue 'dispatch;
	}
	// 82900D94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900D98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900D9C: 488A7420  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900DA0 size=196
    let mut pc: u32 = 0x82900DA0;
    'dispatch: loop {
        match pc {
            0x82900DA0 => {
    //   block [0x82900DA0..0x82900E64)
	// 82900DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900DB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900DB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900DBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82900DC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900DC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900DC8: 4B9BFB71  bl 0x822c0938
	ctx.lr = 0x82900DCC;
	sub_822C0938(ctx, base);
	// 82900DCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82900DD0: 41820028  beq 0x82900df8
	if ctx.cr[0].eq {
	pc = 0x82900DF8; continue 'dispatch;
	}
	// 82900DD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900DD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82900DDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82900DE0: 392B4860  addi r9, r11, 0x4860
	ctx.r[9].s64 = ctx.r[11].s64 + 18528;
	// 82900DE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82900DE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82900DEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82900DF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82900DF4: 48000008  b 0x82900dfc
	pc = 0x82900DFC; continue 'dispatch;
	// 82900DF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900DFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900E04: 409A0044  bne cr6, 0x82900e48
	if !ctx.cr[6].eq {
	pc = 0x82900E48; continue 'dispatch;
	}
	// 82900E08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82900E0C: 419A001C  beq cr6, 0x82900e28
	if ctx.cr[6].eq {
	pc = 0x82900E28; continue 'dispatch;
	}
	// 82900E10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900E14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82900E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900E1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900E20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900E24: 4E800421  bctrl
	ctx.lr = 0x82900E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900E28: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900E2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82900E30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900E34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82900E38: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 82900E3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82900E40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82900E44: 4B9BF1BD  bl 0x822c0000
	ctx.lr = 0x82900E48;
	sub_822C0000(ctx, base);
	// 82900E48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900E4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900E50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900E54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900E58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900E5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900E68 size=196
    let mut pc: u32 = 0x82900E68;
    'dispatch: loop {
        match pc {
            0x82900E68 => {
    //   block [0x82900E68..0x82900F2C)
	// 82900E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900E84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82900E88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900E8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900E90: 4B9BFAA9  bl 0x822c0938
	ctx.lr = 0x82900E94;
	sub_822C0938(ctx, base);
	// 82900E94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82900E98: 41820028  beq 0x82900ec0
	if ctx.cr[0].eq {
	pc = 0x82900EC0; continue 'dispatch;
	}
	// 82900E9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900EA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82900EA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82900EA8: 392B4874  addi r9, r11, 0x4874
	ctx.r[9].s64 = ctx.r[11].s64 + 18548;
	// 82900EAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82900EB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82900EB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82900EB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82900EBC: 48000008  b 0x82900ec4
	pc = 0x82900EC4; continue 'dispatch;
	// 82900EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900EC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900ECC: 409A0044  bne cr6, 0x82900f10
	if !ctx.cr[6].eq {
	pc = 0x82900F10; continue 'dispatch;
	}
	// 82900ED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82900ED4: 419A001C  beq cr6, 0x82900ef0
	if ctx.cr[6].eq {
	pc = 0x82900EF0; continue 'dispatch;
	}
	// 82900ED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900EDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82900EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900EE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900EEC: 4E800421  bctrl
	ctx.lr = 0x82900EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900EF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900EF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82900EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900EFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82900F00: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 82900F04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82900F08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82900F0C: 4B9BF0F5  bl 0x822c0000
	ctx.lr = 0x82900F10;
	sub_822C0000(ctx, base);
	// 82900F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900F14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900F18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900F1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900F20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900F24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900F28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900F30 size=196
    let mut pc: u32 = 0x82900F30;
    'dispatch: loop {
        match pc {
            0x82900F30 => {
    //   block [0x82900F30..0x82900FF4)
	// 82900F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900F44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82900F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900F4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82900F50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82900F54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900F58: 4B9BF9E1  bl 0x822c0938
	ctx.lr = 0x82900F5C;
	sub_822C0938(ctx, base);
	// 82900F5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82900F60: 41820028  beq 0x82900f88
	if ctx.cr[0].eq {
	pc = 0x82900F88; continue 'dispatch;
	}
	// 82900F64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82900F68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82900F6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82900F70: 392B4888  addi r9, r11, 0x4888
	ctx.r[9].s64 = ctx.r[11].s64 + 18568;
	// 82900F74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82900F78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82900F7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82900F80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82900F84: 48000008  b 0x82900f8c
	pc = 0x82900F8C; continue 'dispatch;
	// 82900F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900F8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82900F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900F94: 409A0044  bne cr6, 0x82900fd8
	if !ctx.cr[6].eq {
	pc = 0x82900FD8; continue 'dispatch;
	}
	// 82900F98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82900F9C: 419A001C  beq cr6, 0x82900fb8
	if ctx.cr[6].eq {
	pc = 0x82900FB8; continue 'dispatch;
	}
	// 82900FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900FA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82900FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900FAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900FB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82900FB4: 4E800421  bctrl
	ctx.lr = 0x82900FB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900FB8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82900FBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82900FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900FC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82900FC8: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 82900FCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82900FD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82900FD4: 4B9BF02D  bl 0x822c0000
	ctx.lr = 0x82900FD8;
	sub_822C0000(ctx, base);
	// 82900FD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900FDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82900FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900FE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900FEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900FF8 size=196
    let mut pc: u32 = 0x82900FF8;
    'dispatch: loop {
        match pc {
            0x82900FF8 => {
    //   block [0x82900FF8..0x829010BC)
	// 82900FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901000: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82901004: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290100C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82901010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82901014: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901018: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290101C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901020: 4B9BF919  bl 0x822c0938
	ctx.lr = 0x82901024;
	sub_822C0938(ctx, base);
	// 82901024: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82901028: 41820028  beq 0x82901050
	if ctx.cr[0].eq {
	pc = 0x82901050; continue 'dispatch;
	}
	// 8290102C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82901030: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82901034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901038: 392B489C  addi r9, r11, 0x489c
	ctx.r[9].s64 = ctx.r[11].s64 + 18588;
	// 8290103C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82901040: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82901044: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82901048: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8290104C: 48000008  b 0x82901054
	pc = 0x82901054; continue 'dispatch;
	// 82901050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82901054: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290105C: 409A0044  bne cr6, 0x829010a0
	if !ctx.cr[6].eq {
	pc = 0x829010A0; continue 'dispatch;
	}
	// 82901060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901064: 419A001C  beq cr6, 0x82901080
	if ctx.cr[6].eq {
	pc = 0x82901080; continue 'dispatch;
	}
	// 82901068: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290106C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82901070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901074: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290107C: 4E800421  bctrl
	ctx.lr = 0x82901080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901080: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901084: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82901088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290108C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82901090: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 82901094: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82901098: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8290109C: 4B9BEF65  bl 0x822c0000
	ctx.lr = 0x829010A0;
	sub_822C0000(ctx, base);
	// 829010A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829010A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829010A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829010AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829010B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829010B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829010B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829010C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829010C0 size=196
    let mut pc: u32 = 0x829010C0;
    'dispatch: loop {
        match pc {
            0x829010C0 => {
    //   block [0x829010C0..0x82901184)
	// 829010C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829010C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829010C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829010CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829010D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829010D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829010D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829010DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829010E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829010E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829010E8: 4B9BF851  bl 0x822c0938
	ctx.lr = 0x829010EC;
	sub_822C0938(ctx, base);
	// 829010EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829010F0: 41820028  beq 0x82901118
	if ctx.cr[0].eq {
	pc = 0x82901118; continue 'dispatch;
	}
	// 829010F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829010F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829010FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901100: 392B48B0  addi r9, r11, 0x48b0
	ctx.r[9].s64 = ctx.r[11].s64 + 18608;
	// 82901104: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82901108: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290110C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82901110: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82901114: 48000008  b 0x8290111c
	pc = 0x8290111C; continue 'dispatch;
	// 82901118: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290111C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901124: 409A0044  bne cr6, 0x82901168
	if !ctx.cr[6].eq {
	pc = 0x82901168; continue 'dispatch;
	}
	// 82901128: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290112C: 419A001C  beq cr6, 0x82901148
	if ctx.cr[6].eq {
	pc = 0x82901148; continue 'dispatch;
	}
	// 82901130: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901134: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82901138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290113C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82901144: 4E800421  bctrl
	ctx.lr = 0x82901148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901148: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8290114C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82901150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901154: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82901158: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 8290115C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82901160: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82901164: 4B9BEE9D  bl 0x822c0000
	ctx.lr = 0x82901168;
	sub_822C0000(ctx, base);
	// 82901168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290116C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901178: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290117C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82901180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901188 size=196
    let mut pc: u32 = 0x82901188;
    'dispatch: loop {
        match pc {
            0x82901188 => {
    //   block [0x82901188..0x8290124C)
	// 82901188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290118C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82901194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290119C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829011A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829011A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829011A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829011AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829011B0: 4B9BF789  bl 0x822c0938
	ctx.lr = 0x829011B4;
	sub_822C0938(ctx, base);
	// 829011B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829011B8: 41820028  beq 0x829011e0
	if ctx.cr[0].eq {
	pc = 0x829011E0; continue 'dispatch;
	}
	// 829011BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829011C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829011C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829011C8: 392B48C4  addi r9, r11, 0x48c4
	ctx.r[9].s64 = ctx.r[11].s64 + 18628;
	// 829011CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829011D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829011D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829011D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829011DC: 48000008  b 0x829011e4
	pc = 0x829011E4; continue 'dispatch;
	// 829011E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829011E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829011E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829011EC: 409A0044  bne cr6, 0x82901230
	if !ctx.cr[6].eq {
	pc = 0x82901230; continue 'dispatch;
	}
	// 829011F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829011F4: 419A001C  beq cr6, 0x82901210
	if ctx.cr[6].eq {
	pc = 0x82901210; continue 'dispatch;
	}
	// 829011F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829011FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82901200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901204: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901208: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290120C: 4E800421  bctrl
	ctx.lr = 0x82901210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901210: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901214: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82901218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290121C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82901220: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 82901224: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82901228: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8290122C: 4B9BEDD5  bl 0x822c0000
	ctx.lr = 0x82901230;
	sub_822C0000(ctx, base);
	// 82901230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82901234: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290123C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901240: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82901244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82901248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901250 size=196
    let mut pc: u32 = 0x82901250;
    'dispatch: loop {
        match pc {
            0x82901250 => {
    //   block [0x82901250..0x82901314)
	// 82901250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290125C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82901268: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290126C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901270: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82901274: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901278: 4B9BF6C1  bl 0x822c0938
	ctx.lr = 0x8290127C;
	sub_822C0938(ctx, base);
	// 8290127C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82901280: 41820028  beq 0x829012a8
	if ctx.cr[0].eq {
	pc = 0x829012A8; continue 'dispatch;
	}
	// 82901284: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82901288: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8290128C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901290: 392B48D8  addi r9, r11, 0x48d8
	ctx.r[9].s64 = ctx.r[11].s64 + 18648;
	// 82901294: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82901298: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290129C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829012A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829012A4: 48000008  b 0x829012ac
	pc = 0x829012AC; continue 'dispatch;
	// 829012A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829012AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829012B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829012B4: 409A0044  bne cr6, 0x829012f8
	if !ctx.cr[6].eq {
	pc = 0x829012F8; continue 'dispatch;
	}
	// 829012B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829012BC: 419A001C  beq cr6, 0x829012d8
	if ctx.cr[6].eq {
	pc = 0x829012D8; continue 'dispatch;
	}
	// 829012C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829012C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829012C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829012CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829012D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829012D4: 4E800421  bctrl
	ctx.lr = 0x829012D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829012D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829012DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829012E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829012E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829012E8: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 829012EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829012F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829012F4: 4B9BED0D  bl 0x822c0000
	ctx.lr = 0x829012F8;
	sub_822C0000(ctx, base);
	// 829012F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829012FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901308: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290130C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82901310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901318 size=196
    let mut pc: u32 = 0x82901318;
    'dispatch: loop {
        match pc {
            0x82901318 => {
    //   block [0x82901318..0x829013DC)
	// 82901318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290131C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82901324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290132C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82901330: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82901334: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901338: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290133C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901340: 4B9BF5F9  bl 0x822c0938
	ctx.lr = 0x82901344;
	sub_822C0938(ctx, base);
	// 82901344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82901348: 41820028  beq 0x82901370
	if ctx.cr[0].eq {
	pc = 0x82901370; continue 'dispatch;
	}
	// 8290134C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82901350: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82901354: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901358: 392B48EC  addi r9, r11, 0x48ec
	ctx.r[9].s64 = ctx.r[11].s64 + 18668;
	// 8290135C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82901360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82901364: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82901368: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8290136C: 48000008  b 0x82901374
	pc = 0x82901374; continue 'dispatch;
	// 82901370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82901374: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290137C: 409A0044  bne cr6, 0x829013c0
	if !ctx.cr[6].eq {
	pc = 0x829013C0; continue 'dispatch;
	}
	// 82901380: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901384: 419A001C  beq cr6, 0x829013a0
	if ctx.cr[6].eq {
	pc = 0x829013A0; continue 'dispatch;
	}
	// 82901388: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290138C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82901390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290139C: 4E800421  bctrl
	ctx.lr = 0x829013A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829013A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829013A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829013A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829013AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829013B0: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 829013B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829013B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829013BC: 4B9BEC45  bl 0x822c0000
	ctx.lr = 0x829013C0;
	sub_822C0000(ctx, base);
	// 829013C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829013C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829013C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829013CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829013D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829013D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829013D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829013E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829013E0 size=196
    let mut pc: u32 = 0x829013E0;
    'dispatch: loop {
        match pc {
            0x829013E0 => {
    //   block [0x829013E0..0x829014A4)
	// 829013E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829013E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829013E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829013EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829013F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829013F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829013F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829013FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901400: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82901404: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901408: 4B9BF531  bl 0x822c0938
	ctx.lr = 0x8290140C;
	sub_822C0938(ctx, base);
	// 8290140C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82901410: 41820028  beq 0x82901438
	if ctx.cr[0].eq {
	pc = 0x82901438; continue 'dispatch;
	}
	// 82901414: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82901418: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8290141C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901420: 392B4900  addi r9, r11, 0x4900
	ctx.r[9].s64 = ctx.r[11].s64 + 18688;
	// 82901424: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82901428: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290142C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82901430: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82901434: 48000008  b 0x8290143c
	pc = 0x8290143C; continue 'dispatch;
	// 82901438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290143C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901444: 409A0044  bne cr6, 0x82901488
	if !ctx.cr[6].eq {
	pc = 0x82901488; continue 'dispatch;
	}
	// 82901448: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290144C: 419A001C  beq cr6, 0x82901468
	if ctx.cr[6].eq {
	pc = 0x82901468; continue 'dispatch;
	}
	// 82901450: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901454: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82901458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290145C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82901464: 4E800421  bctrl
	ctx.lr = 0x82901468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901468: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8290146C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82901470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901474: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82901478: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 8290147C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82901480: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82901484: 4B9BEB7D  bl 0x822c0000
	ctx.lr = 0x82901488;
	sub_822C0000(ctx, base);
	// 82901488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290148C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901498: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290149C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829014A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829014A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829014A8 size=196
    let mut pc: u32 = 0x829014A8;
    'dispatch: loop {
        match pc {
            0x829014A8 => {
    //   block [0x829014A8..0x8290156C)
	// 829014A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829014AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829014B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829014B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829014B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829014BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829014C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829014C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829014C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829014CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829014D0: 4B9BF469  bl 0x822c0938
	ctx.lr = 0x829014D4;
	sub_822C0938(ctx, base);
	// 829014D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829014D8: 41820028  beq 0x82901500
	if ctx.cr[0].eq {
	pc = 0x82901500; continue 'dispatch;
	}
	// 829014DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829014E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829014E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829014E8: 392B4914  addi r9, r11, 0x4914
	ctx.r[9].s64 = ctx.r[11].s64 + 18708;
	// 829014EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829014F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829014F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829014F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829014FC: 48000008  b 0x82901504
	pc = 0x82901504; continue 'dispatch;
	// 82901500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82901504: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290150C: 409A0044  bne cr6, 0x82901550
	if !ctx.cr[6].eq {
	pc = 0x82901550; continue 'dispatch;
	}
	// 82901510: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901514: 419A001C  beq cr6, 0x82901530
	if ctx.cr[6].eq {
	pc = 0x82901530; continue 'dispatch;
	}
	// 82901518: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290151C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82901520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901524: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290152C: 4E800421  bctrl
	ctx.lr = 0x82901530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901530: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901534: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82901538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290153C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82901540: 816BC240  lwz r11, -0x3dc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15808 as u32) ) } as u64;
	// 82901544: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82901548: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8290154C: 4B9BEAB5  bl 0x822c0000
	ctx.lr = 0x82901550;
	sub_822C0000(ctx, base);
	// 82901550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82901554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290155C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82901564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82901568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82901570 size=252
    let mut pc: u32 = 0x82901570;
    'dispatch: loop {
        match pc {
            0x82901570 => {
    //   block [0x82901570..0x8290166C)
	// 82901570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901574: 488A6BF5  bl 0x831a8168
	ctx.lr = 0x82901578;
	sub_831A8130(ctx, base);
	// 82901578: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290157C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82901580: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82901584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901588: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 8290158C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82901590: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82901594: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82901598: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8290159C: 3BA9C250  addi r29, r9, -0x3db0
	ctx.r[29].s64 = ctx.r[9].s64 + -15792;
	// 829015A0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829015A4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 829015A8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829015AC: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829015B0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829015B4: 4BEEE1FD  bl 0x827ef7b0
	ctx.lr = 0x829015B8;
	sub_827EF7B0(ctx, base);
	// 829015B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829015BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829015C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829015C4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 829015C8: 4857BA99  bl 0x82e7d060
	ctx.lr = 0x829015CC;
	sub_82E7D060(ctx, base);
	// 829015CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829015D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829015D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829015D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829015DC: 4E800421  bctrl
	ctx.lr = 0x829015E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82901670 size=344
    let mut pc: u32 = 0x82901670;
    'dispatch: loop {
        match pc {
            0x82901670 => {
    //   block [0x82901670..0x829017C8)
	// 82901670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901674: 488A6AF5  bl 0x831a8168
	ctx.lr = 0x82901678;
	sub_831A8130(ctx, base);
	// 82901678: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290167C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82901680: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82901684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901688: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 8290168C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82901690: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82901694: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82901698: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8290169C: 3BA9C260  addi r29, r9, -0x3da0
	ctx.r[29].s64 = ctx.r[9].s64 + -15776;
	// 829016A0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829016A4: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 829016A8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829016AC: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829016B0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829016B4: 4BEEE0FD  bl 0x827ef7b0
	ctx.lr = 0x829016B8;
	sub_827EF7B0(ctx, base);
	// 829016B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829016BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829016C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829016C4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 829016C8: 4857B999  bl 0x82e7d060
	ctx.lr = 0x829016CC;
	sub_82E7D060(ctx, base);
	// 829016CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829016D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829016D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829016D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829016DC: 4E800421  bctrl
	ctx.lr = 0x829016E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829017C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829017C8 size=548
    let mut pc: u32 = 0x829017C8;
    'dispatch: loop {
        match pc {
            0x829017C8 => {
    //   block [0x829017C8..0x829019EC)
	// 829017C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829017CC: 488A699D  bl 0x831a8168
	ctx.lr = 0x829017D0;
	sub_831A8130(ctx, base);
	// 829017D0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829017D4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829017D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829017DC: D02100EC  stfs f1, 0xec(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 829017E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829017E4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829017E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 829017EC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 829017F0: C1BE0094  lfs f13, 0x94(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829017F4: C01E0090  lfs f0, 0x90(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829017F8: C3EB9524  lfs f31, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829017FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82901800: 4098000C  bge cr6, 0x8290180c
	if !ctx.cr[6].lt {
	pc = 0x8290180C; continue 'dispatch;
	}
	// 82901804: EC0107FA  fmadds f0, f1, f31, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82901808: D01E0090  stfs f0, 0x90(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8290180C: C01E0090  lfs f0, 0x90(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82901810: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82901814: 40990008  ble cr6, 0x8290181c
	if !ctx.cr[6].gt {
	pc = 0x8290181C; continue 'dispatch;
	}
	// 82901818: D1BE0090  stfs f13, 0x90(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8290181C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901824: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901828: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290182C: 4E800421  bctrl
	ctx.lr = 0x82901830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901830: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82901834: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82901838: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8290183C: 13C0E8C7  vcmpequd (lvx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82901840: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829019F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829019F0 size=108
    let mut pc: u32 = 0x829019F0;
    'dispatch: loop {
        match pc {
            0x829019F0 => {
    //   block [0x829019F0..0x82901A5C)
	// 829019F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829019F4: 488A6779  bl 0x831a816c
	ctx.lr = 0x829019F8;
	sub_831A8130(ctx, base);
	// 829019F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829019FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82901A00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82901A04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82901A08: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82901A0C: 41820038  beq 0x82901a44
	if ctx.cr[0].eq {
	pc = 0x82901A44; continue 'dispatch;
	}
	// 82901A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901A14: 488A7F75  bl 0x831a9988
	ctx.lr = 0x82901A18;
	sub_831A9988(ctx, base);
	// 82901A18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901A1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82901A20: 386BCA30  addi r3, r11, -0x35d0
	ctx.r[3].s64 = ctx.r[11].s64 + -13776;
	// 82901A24: 488A66D5  bl 0x831a80f8
	ctx.lr = 0x82901A28;
	sub_831A80F8(ctx, base);
	// 82901A28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82901A2C: 41820018  beq 0x82901a44
	if ctx.cr[0].eq {
	pc = 0x82901A44; continue 'dispatch;
	}
	// 82901A30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82901A34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901A38: 4BFFF2B9  bl 0x82900cf0
	ctx.lr = 0x82901A3C;
	sub_82900CF0(ctx, base);
	// 82901A3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82901A40: 48000014  b 0x82901a54
	pc = 0x82901A54; continue 'dispatch;
	// 82901A44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82901A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82901A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901A50: 4887CA39  bl 0x8317e488
	ctx.lr = 0x82901A54;
	sub_8317E488(ctx, base);
	// 82901A54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901A58: 488A6764  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82901A60 size=104
    let mut pc: u32 = 0x82901A60;
    'dispatch: loop {
        match pc {
            0x82901A60 => {
    //   block [0x82901A60..0x82901AC8)
	// 82901A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82901A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901A78: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82901A7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82901A80: 396B6514  addi r11, r11, 0x6514
	ctx.r[11].s64 = ctx.r[11].s64 + 25876;
	// 82901A84: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82901A88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901A8C: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82901A90: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82901A94: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82901A98: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82901A9C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82901AA0: 4BC8A471  bl 0x8258bf10
	ctx.lr = 0x82901AA4;
	sub_8258BF10(ctx, base);
	// 82901AA4: 897E0030  lbz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82901AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901AAC: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82901AB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901ABC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82901AC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82901AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901AC8 size=72
    let mut pc: u32 = 0x82901AC8;
    'dispatch: loop {
        match pc {
            0x82901AC8 => {
    //   block [0x82901AC8..0x82901B10)
	// 82901AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901AD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901AD4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82901AD8: 419A001C  beq cr6, 0x82901af4
	if ctx.cr[6].eq {
	pc = 0x82901AF4; continue 'dispatch;
	}
	// 82901ADC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82901AE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901AE4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82901AE8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82901AEC: 4BFFEC05  bl 0x829006f0
	ctx.lr = 0x82901AF0;
	sub_829006F0(ctx, base);
	// 82901AF0: 48000010  b 0x82901b00
	pc = 0x82901B00; continue 'dispatch;
	// 82901AF4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901AF8: 396BC610  addi r11, r11, -0x39f0
	ctx.r[11].s64 = ctx.r[11].s64 + -14832;
	// 82901AFC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901B00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82901B04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901B08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901B0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901B10 size=72
    let mut pc: u32 = 0x82901B10;
    'dispatch: loop {
        match pc {
            0x82901B10 => {
    //   block [0x82901B10..0x82901B58)
	// 82901B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901B18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901B1C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82901B20: 419A001C  beq cr6, 0x82901b3c
	if ctx.cr[6].eq {
	pc = 0x82901B3C; continue 'dispatch;
	}
	// 82901B24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82901B28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901B2C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82901B30: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82901B34: 4BFFEC45  bl 0x82900778
	ctx.lr = 0x82901B38;
	sub_82900778(ctx, base);
	// 82901B38: 48000010  b 0x82901b48
	pc = 0x82901B48; continue 'dispatch;
	// 82901B3C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901B40: 396BC6E0  addi r11, r11, -0x3920
	ctx.r[11].s64 = ctx.r[11].s64 + -14624;
	// 82901B44: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901B48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82901B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901B58 size=72
    let mut pc: u32 = 0x82901B58;
    'dispatch: loop {
        match pc {
            0x82901B58 => {
    //   block [0x82901B58..0x82901BA0)
	// 82901B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901B60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901B64: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82901B68: 419A001C  beq cr6, 0x82901b84
	if ctx.cr[6].eq {
	pc = 0x82901B84; continue 'dispatch;
	}
	// 82901B6C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82901B70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901B74: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82901B78: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82901B7C: 4BFFEC85  bl 0x82900800
	ctx.lr = 0x82901B80;
	sub_82900800(ctx, base);
	// 82901B80: 48000010  b 0x82901b90
	pc = 0x82901B90; continue 'dispatch;
	// 82901B84: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901B88: 396BC7B8  addi r11, r11, -0x3848
	ctx.r[11].s64 = ctx.r[11].s64 + -14408;
	// 82901B8C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82901B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901BA0 size=72
    let mut pc: u32 = 0x82901BA0;
    'dispatch: loop {
        match pc {
            0x82901BA0 => {
    //   block [0x82901BA0..0x82901BE8)
	// 82901BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901BA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901BAC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82901BB0: 419A001C  beq cr6, 0x82901bcc
	if ctx.cr[6].eq {
	pc = 0x82901BCC; continue 'dispatch;
	}
	// 82901BB4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82901BB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901BBC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82901BC0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82901BC4: 4BFFECC5  bl 0x82900888
	ctx.lr = 0x82901BC8;
	sub_82900888(ctx, base);
	// 82901BC8: 48000010  b 0x82901bd8
	pc = 0x82901BD8; continue 'dispatch;
	// 82901BCC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901BD0: 396BC890  addi r11, r11, -0x3770
	ctx.r[11].s64 = ctx.r[11].s64 + -14192;
	// 82901BD4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901BD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82901BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901BE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901BE8 size=72
    let mut pc: u32 = 0x82901BE8;
    'dispatch: loop {
        match pc {
            0x82901BE8 => {
    //   block [0x82901BE8..0x82901C30)
	// 82901BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901BF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901BF4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82901BF8: 419A001C  beq cr6, 0x82901c14
	if ctx.cr[6].eq {
	pc = 0x82901C14; continue 'dispatch;
	}
	// 82901BFC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82901C00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901C04: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82901C08: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82901C0C: 4BFFED05  bl 0x82900910
	ctx.lr = 0x82901C10;
	sub_82900910(ctx, base);
	// 82901C10: 48000010  b 0x82901c20
	pc = 0x82901C20; continue 'dispatch;
	// 82901C14: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901C18: 396BC960  addi r11, r11, -0x36a0
	ctx.r[11].s64 = ctx.r[11].s64 + -13984;
	// 82901C1C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901C20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82901C24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901C28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901C2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82901C30 size=264
    let mut pc: u32 = 0x82901C30;
    'dispatch: loop {
        match pc {
            0x82901C30 => {
    //   block [0x82901C30..0x82901D38)
	// 82901C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901C34: 488A6539  bl 0x831a816c
	ctx.lr = 0x82901C38;
	sub_831A8130(ctx, base);
	// 82901C38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901C3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82901C40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82901C44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901C48: 48014B21  bl 0x82916768
	ctx.lr = 0x82901C4C;
	sub_82916768(ctx, base);
	// 82901C4C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82901C50: 4182008C  beq 0x82901cdc
	if ctx.cr[0].eq {
	pc = 0x82901CDC; continue 'dispatch;
	}
	// 82901C54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82901C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901C5C: 388B3B40  addi r4, r11, 0x3b40
	ctx.r[4].s64 = ctx.r[11].s64 + 15168;
	// 82901C60: 484F1DA9  bl 0x82df3a08
	ctx.lr = 0x82901C64;
	sub_82DF3A08(ctx, base);
	// 82901C64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82901C68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82901C6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82901C70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901C74: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82901C78: 4800AA09  bl 0x8290c680
	ctx.lr = 0x82901C7C;
	sub_8290C680(ctx, base);
	// 82901C7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901C80: 484F17A9  bl 0x82df3428
	ctx.lr = 0x82901C84;
	sub_82DF3428(ctx, base);
	// 82901C84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82901C88: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 82901C8C: C02B4858  lfs f1, 0x4858(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18520 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82901C90: 48015781  bl 0x82917410
	ctx.lr = 0x82901C94;
	sub_82917410(ctx, base);
	// 82901C94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901C98: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82901C9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82901CA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901CA4: 816B018C  lwz r11, 0x18c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(396 as u32) ) } as u64;
	// 82901CA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82901CAC: 4E800421  bctrl
	ctx.lr = 0x82901CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901CB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82901CB4: 395E006C  addi r10, r30, 0x6c
	ctx.r[10].s64 = ctx.r[30].s64 + 108;
	// 82901CB8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82901CBC: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82901CC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901CC4: 917E006C  stw r11, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82901CC8: 4B9C2799  bl 0x822c4460
	ctx.lr = 0x82901CCC;
	sub_822C4460(ctx, base);
	// 82901CCC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82901CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82901CD4: 419A0008  beq cr6, 0x82901cdc
	if ctx.cr[6].eq {
	pc = 0x82901CDC; continue 'dispatch;
	}
	// 82901CD8: 4B9BEBB9  bl 0x822c0890
	ctx.lr = 0x82901CDC;
	sub_822C0890(ctx, base);
	// 82901CDC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82901CE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82901CE4: 38AB2B00  addi r5, r11, 0x2b00
	ctx.r[5].s64 = ctx.r[11].s64 + 11008;
	// 82901CE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901CEC: 4BEEDFDD  bl 0x827efcc8
	ctx.lr = 0x82901CF0;
	sub_827EFCC8(ctx, base);
	// 82901CF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82901CF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82901CF8: 419A0008  beq cr6, 0x82901d00
	if ctx.cr[6].eq {
	pc = 0x82901D00; continue 'dispatch;
	}
	// 82901CFC: 4B9BEB95  bl 0x822c0890
	ctx.lr = 0x82901D00;
	sub_822C0890(ctx, base);
	// 82901D00: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901D04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901D08: 808BF470  lwz r4, -0xb90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2960 as u32) ) } as u64;
	// 82901D0C: 484F1CFD  bl 0x82df3a08
	ctx.lr = 0x82901D10;
	sub_82DF3A08(ctx, base);
	// 82901D10: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82901D18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901D1C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82901D20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82901D24: 4E800421  bctrl
	ctx.lr = 0x82901D28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901D28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901D2C: 484F16FD  bl 0x82df3428
	ctx.lr = 0x82901D30;
	sub_82DF3428(ctx, base);
	// 82901D30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82901D34: 488A6488  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901D38 size=112
    let mut pc: u32 = 0x82901D38;
    'dispatch: loop {
        match pc {
            0x82901D38 => {
    //   block [0x82901D38..0x82901DA8)
	// 82901D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901D3C: 488A6431  bl 0x831a816c
	ctx.lr = 0x82901D40;
	sub_831A8130(ctx, base);
	// 82901D40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901D44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82901D48: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82901D4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82901D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901D58: 4BFFEFF1  bl 0x82900d48
	ctx.lr = 0x82901D5C;
	sub_82900D48(ctx, base);
	// 82901D5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901D60: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82901D64: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82901D68: 419A0020  beq cr6, 0x82901d88
	if ctx.cr[6].eq {
	pc = 0x82901D88; continue 'dispatch;
	}
	// 82901D6C: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 82901D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82901D74: 484F14C5  bl 0x82df3238
	ctx.lr = 0x82901D78;
	sub_82DF3238(ctx, base);
	// 82901D78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82901D7C: 4082000C  bne 0x82901d88
	if !ctx.cr[0].eq {
	pc = 0x82901D88; continue 'dispatch;
	}
	// 82901D80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82901D84: 48000010  b 0x82901d94
	pc = 0x82901D94; continue 'dispatch;
	// 82901D88: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901D8C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82901D90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82901D94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901D98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901D9C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82901DA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82901DA4: 488A6418  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901DA8 size=96
    let mut pc: u32 = 0x82901DA8;
    'dispatch: loop {
        match pc {
            0x82901DA8 => {
    //   block [0x82901DA8..0x82901E08)
	// 82901DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901DB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901DB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901DB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901DC0: 484F1C49  bl 0x82df3a08
	ctx.lr = 0x82901DC4;
	sub_82DF3A08(ctx, base);
	// 82901DC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901DC8: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 82901DCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901DD0: 4BFFFF69  bl 0x82901d38
	ctx.lr = 0x82901DD4;
	sub_82901D38(ctx, base);
	// 82901DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901DD8: 484F1651  bl 0x82df3428
	ctx.lr = 0x82901DDC;
	sub_82DF3428(ctx, base);
	// 82901DDC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82901DE0: 815F0064  lwz r10, 0x64(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82901DE4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82901DE8: 419A000C  beq cr6, 0x82901df4
	if ctx.cr[6].eq {
	pc = 0x82901DF4; continue 'dispatch;
	}
	// 82901DEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901DF0: 994B0048  stb r10, 0x48(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[10].u8 ) };
	// 82901DF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82901DF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901DFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901E00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82901E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82901E08 size=172
    let mut pc: u32 = 0x82901E08;
    'dispatch: loop {
        match pc {
            0x82901E08 => {
    //   block [0x82901E08..0x82901EB4)
	// 82901E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901E10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82901E14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901E18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82901E20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901E24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82901E28: 4BEED989  bl 0x827ef7b0
	ctx.lr = 0x82901E2C;
	sub_827EF7B0(ctx, base);
	// 82901E2C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901E30: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82901E34: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82901E38: 396BC250  addi r11, r11, -0x3db0
	ctx.r[11].s64 = ctx.r[11].s64 + -15792;
	// 82901E3C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82901E40: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82901EB8 size=184
    let mut pc: u32 = 0x82901EB8;
    'dispatch: loop {
        match pc {
            0x82901EB8 => {
    //   block [0x82901EB8..0x82901F70)
	// 82901EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901EC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82901EC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901EC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82901ED0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901ED4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82901ED8: 4BEED8D9  bl 0x827ef7b0
	ctx.lr = 0x82901EDC;
	sub_827EF7B0(ctx, base);
	// 82901EDC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82901EE0: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82901EE4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82901EE8: 396BC260  addi r11, r11, -0x3da0
	ctx.r[11].s64 = ctx.r[11].s64 + -15776;
	// 82901EEC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82901EF0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901F70 size=112
    let mut pc: u32 = 0x82901F70;
    'dispatch: loop {
        match pc {
            0x82901F70 => {
    //   block [0x82901F70..0x82901FE0)
	// 82901F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901F74: 488A61F1  bl 0x831a8164
	ctx.lr = 0x82901F78;
	sub_831A8130(ctx, base);
	// 82901F78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901F7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82901F80: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82901F84: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82901F88: 897E0051  lbz r11, 0x51(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(81 as u32) ) } as u64;
	// 82901F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901F90: 409A0048  bne cr6, 0x82901fd8
	if !ctx.cr[6].eq {
	pc = 0x82901FD8; continue 'dispatch;
	}
	// 82901F94: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82901F98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82901F9C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901FA0: 4BFFFFD1  bl 0x82901f70
	ctx.lr = 0x82901FA4;
	sub_82901F70(ctx, base);
	// 82901FA4: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 82901FA8: 387D0018  addi r3, r29, 0x18
	ctx.r[3].s64 = ctx.r[29].s64 + 24;
	// 82901FAC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901FB0: 4B9C6D09  bl 0x822c8cb8
	ctx.lr = 0x82901FB4;
	sub_822C8CB8(ctx, base);
	// 82901FB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901FB8: 484F1471  bl 0x82df3428
	ctx.lr = 0x82901FBC;
	sub_82DF3428(ctx, base);
	// 82901FBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901FC0: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82901FC4: 484F01C5  bl 0x82df2188
	ctx.lr = 0x82901FC8;
	sub_82DF2188(ctx, base);
	// 82901FC8: 897F0051  lbz r11, 0x51(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(81 as u32) ) } as u64;
	// 82901FCC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82901FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901FD4: 419AFFC4  beq cr6, 0x82901f98
	if ctx.cr[6].eq {
	pc = 0x82901F98; continue 'dispatch;
	}
	// 82901FD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82901FDC: 488A61D8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901FE0 size=84
    let mut pc: u32 = 0x82901FE0;
    'dispatch: loop {
        match pc {
            0x82901FE0 => {
    //   block [0x82901FE0..0x82902034)
	// 82901FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901FE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901FEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901FF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901FF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901FF8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901FFC: 4BFFFF75  bl 0x82901f70
	ctx.lr = 0x82902000;
	sub_82901F70(ctx, base);
	// 82902000: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902008: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8290200C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82902010: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902014: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82902018: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290201C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82902020: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82902024: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902028: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290202C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902038 size=128
    let mut pc: u32 = 0x82902038;
    'dispatch: loop {
        match pc {
            0x82902038 => {
    //   block [0x82902038..0x829020B8)
	// 82902038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290203C: 488A6131  bl 0x831a816c
	ctx.lr = 0x82902040;
	sub_831A8130(ctx, base);
	// 82902040: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902044: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82902048: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8290204C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82902050: 3BEBAF78  addi r31, r11, -0x5088
	ctx.r[31].s64 = ctx.r[11].s64 + -20616;
	// 82902054: 816AAF80  lwz r11, -0x5080(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20608 as u32) ) } as u64;
	// 82902058: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8290205C: 40820024  bne 0x82902080
	if !ctx.cr[0].eq {
	pc = 0x82902080; continue 'dispatch;
	}
	// 82902060: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82902064: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 82902068: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8290206C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82902070: 39081AC8  addi r8, r8, 0x1ac8
	ctx.r[8].s64 = ctx.r[8].s64 + 6856;
	// 82902074: 916AAF80  stw r11, -0x5080(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20608 as u32), ctx.r[11].u32 ) };
	// 82902078: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290207C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82902080: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82902084: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82902088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290208C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82902090: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82902094: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82902098: 4BD52529  bl 0x826545c0
	ctx.lr = 0x8290209C;
	sub_826545C0(ctx, base);
	// 8290209C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829020A0: 4182000C  beq 0x829020ac
	if ctx.cr[0].eq {
	pc = 0x829020AC; continue 'dispatch;
	}
	// 829020A4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829020A8: 48000008  b 0x829020b0
	pc = 0x829020B0; continue 'dispatch;
	// 829020AC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829020B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829020B4: 488A6108  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829020B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829020B8 size=128
    let mut pc: u32 = 0x829020B8;
    'dispatch: loop {
        match pc {
            0x829020B8 => {
    //   block [0x829020B8..0x82902138)
	// 829020B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829020BC: 488A60B1  bl 0x831a816c
	ctx.lr = 0x829020C0;
	sub_831A8130(ctx, base);
	// 829020C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829020C4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829020C8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829020CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829020D0: 3BEBAF84  addi r31, r11, -0x507c
	ctx.r[31].s64 = ctx.r[11].s64 + -20604;
	// 829020D4: 816AAF8C  lwz r11, -0x5074(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20596 as u32) ) } as u64;
	// 829020D8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829020DC: 40820024  bne 0x82902100
	if !ctx.cr[0].eq {
	pc = 0x82902100; continue 'dispatch;
	}
	// 829020E0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829020E4: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 829020E8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829020EC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829020F0: 39081B10  addi r8, r8, 0x1b10
	ctx.r[8].s64 = ctx.r[8].s64 + 6928;
	// 829020F4: 916AAF8C  stw r11, -0x5074(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20596 as u32), ctx.r[11].u32 ) };
	// 829020F8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829020FC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82902100: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82902104: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82902108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290210C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82902110: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82902114: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82902118: 4BD524A9  bl 0x826545c0
	ctx.lr = 0x8290211C;
	sub_826545C0(ctx, base);
	// 8290211C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902120: 4182000C  beq 0x8290212c
	if ctx.cr[0].eq {
	pc = 0x8290212C; continue 'dispatch;
	}
	// 82902124: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82902128: 48000008  b 0x82902130
	pc = 0x82902130; continue 'dispatch;
	// 8290212C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82902130: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82902134: 488A6088  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902138 size=128
    let mut pc: u32 = 0x82902138;
    'dispatch: loop {
        match pc {
            0x82902138 => {
    //   block [0x82902138..0x829021B8)
	// 82902138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290213C: 488A6031  bl 0x831a816c
	ctx.lr = 0x82902140;
	sub_831A8130(ctx, base);
	// 82902140: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902144: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82902148: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8290214C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82902150: 3BEBAF90  addi r31, r11, -0x5070
	ctx.r[31].s64 = ctx.r[11].s64 + -20592;
	// 82902154: 816AAF98  lwz r11, -0x5068(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20584 as u32) ) } as u64;
	// 82902158: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8290215C: 40820024  bne 0x82902180
	if !ctx.cr[0].eq {
	pc = 0x82902180; continue 'dispatch;
	}
	// 82902160: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82902164: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 82902168: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8290216C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82902170: 39081B58  addi r8, r8, 0x1b58
	ctx.r[8].s64 = ctx.r[8].s64 + 7000;
	// 82902174: 916AAF98  stw r11, -0x5068(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20584 as u32), ctx.r[11].u32 ) };
	// 82902178: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290217C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82902180: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82902184: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82902188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290218C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82902190: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82902194: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82902198: 4BD52429  bl 0x826545c0
	ctx.lr = 0x8290219C;
	sub_826545C0(ctx, base);
	// 8290219C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829021A0: 4182000C  beq 0x829021ac
	if ctx.cr[0].eq {
	pc = 0x829021AC; continue 'dispatch;
	}
	// 829021A4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829021A8: 48000008  b 0x829021b0
	pc = 0x829021B0; continue 'dispatch;
	// 829021AC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829021B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829021B4: 488A6008  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829021B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829021B8 size=128
    let mut pc: u32 = 0x829021B8;
    'dispatch: loop {
        match pc {
            0x829021B8 => {
    //   block [0x829021B8..0x82902238)
	// 829021B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829021BC: 488A5FB1  bl 0x831a816c
	ctx.lr = 0x829021C0;
	sub_831A8130(ctx, base);
	// 829021C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829021C4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829021C8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829021CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829021D0: 3BEBAF9C  addi r31, r11, -0x5064
	ctx.r[31].s64 = ctx.r[11].s64 + -20580;
	// 829021D4: 816AAFA4  lwz r11, -0x505c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20572 as u32) ) } as u64;
	// 829021D8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829021DC: 40820024  bne 0x82902200
	if !ctx.cr[0].eq {
	pc = 0x82902200; continue 'dispatch;
	}
	// 829021E0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829021E4: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 829021E8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829021EC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829021F0: 39081BA0  addi r8, r8, 0x1ba0
	ctx.r[8].s64 = ctx.r[8].s64 + 7072;
	// 829021F4: 916AAFA4  stw r11, -0x505c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20572 as u32), ctx.r[11].u32 ) };
	// 829021F8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829021FC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82902200: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82902204: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82902208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290220C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82902210: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82902214: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82902218: 4BD523A9  bl 0x826545c0
	ctx.lr = 0x8290221C;
	sub_826545C0(ctx, base);
	// 8290221C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902220: 4182000C  beq 0x8290222c
	if ctx.cr[0].eq {
	pc = 0x8290222C; continue 'dispatch;
	}
	// 82902224: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82902228: 48000008  b 0x82902230
	pc = 0x82902230; continue 'dispatch;
	// 8290222C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82902230: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82902234: 488A5F88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902238 size=128
    let mut pc: u32 = 0x82902238;
    'dispatch: loop {
        match pc {
            0x82902238 => {
    //   block [0x82902238..0x829022B8)
	// 82902238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290223C: 488A5F31  bl 0x831a816c
	ctx.lr = 0x82902240;
	sub_831A8130(ctx, base);
	// 82902240: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902244: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82902248: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8290224C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82902250: 3BEBAFA8  addi r31, r11, -0x5058
	ctx.r[31].s64 = ctx.r[11].s64 + -20568;
	// 82902254: 816AAFB0  lwz r11, -0x5050(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20560 as u32) ) } as u64;
	// 82902258: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8290225C: 40820024  bne 0x82902280
	if !ctx.cr[0].eq {
	pc = 0x82902280; continue 'dispatch;
	}
	// 82902260: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82902264: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 82902268: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8290226C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82902270: 39081BE8  addi r8, r8, 0x1be8
	ctx.r[8].s64 = ctx.r[8].s64 + 7144;
	// 82902274: 916AAFB0  stw r11, -0x5050(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20560 as u32), ctx.r[11].u32 ) };
	// 82902278: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290227C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82902280: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82902284: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82902288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290228C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82902290: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82902294: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82902298: 4BD52329  bl 0x826545c0
	ctx.lr = 0x8290229C;
	sub_826545C0(ctx, base);
	// 8290229C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829022A0: 4182000C  beq 0x829022ac
	if ctx.cr[0].eq {
	pc = 0x829022AC; continue 'dispatch;
	}
	// 829022A4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829022A8: 48000008  b 0x829022b0
	pc = 0x829022B0; continue 'dispatch;
	// 829022AC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829022B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829022B4: 488A5F08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829022B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829022B8 size=164
    let mut pc: u32 = 0x829022B8;
    'dispatch: loop {
        match pc {
            0x829022B8 => {
    //   block [0x829022B8..0x8290235C)
	// 829022B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829022BC: 488A5EB1  bl 0x831a816c
	ctx.lr = 0x829022C0;
	sub_831A8130(ctx, base);
	// 829022C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829022C4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 829022C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829022CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829022D0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829022D4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829022D8: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 829022DC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82902360 size=252
    let mut pc: u32 = 0x82902360;
    'dispatch: loop {
        match pc {
            0x82902360 => {
    //   block [0x82902360..0x8290245C)
	// 82902360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290236C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902370: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82902374: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902378: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290237C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82902380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902384: 4BEED3AD  bl 0x827ef730
	ctx.lr = 0x82902388;
	sub_827EF730(ctx, base);
	// 82902388: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290238C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902390: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82902394: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902398: 4E800421  bctrl
	ctx.lr = 0x8290239C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290239C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829023A0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829023A4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829023A8: 40990074  ble cr6, 0x8290241c
	if !ctx.cr[6].gt {
	pc = 0x8290241C; continue 'dispatch;
	}
	// 829023AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829023B0: 4BFFD5A9  bl 0x828ff958
	ctx.lr = 0x829023B4;
	sub_828FF958(ctx, base);
	// 829023B4: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829023B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829023BC: C3E30078  lfs f31, 0x78(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829023C0: 394A0998  addi r10, r10, 0x998
	ctx.r[10].s64 = ctx.r[10].s64 + 2456;
	// 829023C4: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 829023C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829023CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829023D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829023D4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829023D8: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829023DC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829023E0: 4BFFFD59  bl 0x82902138
	ctx.lr = 0x829023E4;
	sub_82902138(ctx, base);
	// 829023E4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829023E8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829023EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829023F0: C04B7BC8  lfs f2, 0x7bc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829023F4: 4BEF3B2D  bl 0x827f5f20
	ctx.lr = 0x829023F8;
	sub_827F5F20(ctx, base);
	// 829023F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829023FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82902400: 388BB730  addi r4, r11, -0x48d0
	ctx.r[4].s64 = ctx.r[11].s64 + -18640;
	// 82902404: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82902408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290240C: 4BFC3DE5  bl 0x828c61f0
	ctx.lr = 0x82902410;
	sub_828C61F0(ctx, base);
	// 82902410: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82902414: 4B9C68A5  bl 0x822c8cb8
	ctx.lr = 0x82902418;
	sub_822C8CB8(ctx, base);
	// 82902418: 48000018  b 0x82902430
	pc = 0x82902430; continue 'dispatch;
	// 8290241C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82902420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82902424: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82902428: 80AB0B2C  lwz r5, 0xb2c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8290242C: 4BFFE0E5  bl 0x82900510
	ctx.lr = 0x82902430;
	sub_82900510(ctx, base);
	// 82902430: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82902438: 388B4938  addi r4, r11, 0x4938
	ctx.r[4].s64 = ctx.r[11].s64 + 18744;
	// 8290243C: 4BFFF96D  bl 0x82901da8
	ctx.lr = 0x82902440;
	sub_82901DA8(ctx, base);
	// 82902440: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82902444: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902448: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290244C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82902450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82902454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82902460 size=712
    let mut pc: u32 = 0x82902460;
    'dispatch: loop {
        match pc {
            0x82902460 => {
    //   block [0x82902460..0x82902728)
	// 82902460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902464: 488A5D01  bl 0x831a8164
	ctx.lr = 0x82902468;
	sub_831A8130(ctx, base);
	// 82902468: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8290246C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82902470: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82902728 size=816
    let mut pc: u32 = 0x82902728;
    'dispatch: loop {
        match pc {
            0x82902728 => {
    //   block [0x82902728..0x82902A58)
	// 82902728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290272C: 488A5A3D  bl 0x831a8168
	ctx.lr = 0x82902730;
	sub_831A8130(ctx, base);
	// 82902730: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82902734: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82902738: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902A58 size=168
    let mut pc: u32 = 0x82902A58;
    'dispatch: loop {
        match pc {
            0x82902A58 => {
    //   block [0x82902A58..0x82902B00)
	// 82902A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902A5C: 488A5711  bl 0x831a816c
	ctx.lr = 0x82902A60;
	sub_831A8130(ctx, base);
	// 82902A60: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82902A64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902A68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82902A6C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82902A70: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82902A74: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82902A78: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902A7C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82902A80: 4800006C  b 0x82902aec
	pc = 0x82902AEC; continue 'dispatch;
	// 82902A84: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82902A88: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82902A8C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82902A90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902A94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902A98: 4E800421  bctrl
	ctx.lr = 0x82902A9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82902A9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902AA0: 41820014  beq 0x82902ab4
	if ctx.cr[0].eq {
	pc = 0x82902AB4; continue 'dispatch;
	}
	// 82902AA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82902AA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82902AAC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82902AB0: 480013C1  bl 0x82903e70
	ctx.lr = 0x82902AB4;
	sub_82903E70(ctx, base);
	// 82902AB4: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902AB8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82902ABC: 41820020  beq 0x82902adc
	if ctx.cr[0].eq {
	pc = 0x82902ADC; continue 'dispatch;
	}
	// 82902AC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902AC4: 389E0060  addi r4, r30, 0x60
	ctx.r[4].s64 = ctx.r[30].s64 + 96;
	// 82902AC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82902ACC: 48000E6D  bl 0x82903938
	ctx.lr = 0x82902AD0;
	sub_82903938(ctx, base);
	// 82902AD0: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902AD4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82902AD8: 48000010  b 0x82902ae8
	pc = 0x82902AE8; continue 'dispatch;
	// 82902ADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902AE0: 48004C89  bl 0x82907768
	ctx.lr = 0x82902AE4;
	sub_82907768(ctx, base);
	// 82902AE4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82902AE8: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82902AEC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82902AF0: 409AFF94  bne cr6, 0x82902a84
	if !ctx.cr[6].eq {
	pc = 0x82902A84; continue 'dispatch;
	}
	// 82902AF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82902AF8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82902AFC: 488A56C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902B00 size=80
    let mut pc: u32 = 0x82902B00;
    'dispatch: loop {
        match pc {
            0x82902B00 => {
    //   block [0x82902B00..0x82902B50)
	// 82902B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902B08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902B0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902B10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902B14: 48559E15  bl 0x82e5c928
	ctx.lr = 0x82902B18;
	sub_82E5C928(ctx, base);
	// 82902B18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902B1C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82902B20: 396B49B4  addi r11, r11, 0x49b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18868;
	// 82902B24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82902B28: 4BFC8FF9  bl 0x828cbb20
	ctx.lr = 0x82902B2C;
	sub_828CBB20(ctx, base);
	// 82902B2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902B34: 396B49EC  addi r11, r11, 0x49ec
	ctx.r[11].s64 = ctx.r[11].s64 + 18924;
	// 82902B38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82902B3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82902B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902B48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902B4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82902B50 size=196
    let mut pc: u32 = 0x82902B50;
    'dispatch: loop {
        match pc {
            0x82902B50 => {
    //   block [0x82902B50..0x82902C14)
	// 82902B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902B58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902B5C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902B64: 4BFFFF9D  bl 0x82902b00
	ctx.lr = 0x82902B68;
	sub_82902B00(ctx, base);
	// 82902B68: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902B6C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82902B70: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82902B74: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82902B78: 392B4A30  addi r9, r11, 0x4a30
	ctx.r[9].s64 = ctx.r[11].s64 + 18992;
	// 82902B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902B80: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82902B84: 394A03A0  addi r10, r10, 0x3a0
	ctx.r[10].s64 = ctx.r[10].s64 + 928;
	// 82902B88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902B8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82902B90: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82902B94: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902B98: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82902B9C: 4BFFF49D  bl 0x82902038
	ctx.lr = 0x82902BA0;
	sub_82902038(ctx, base);
	// 82902BA0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82902BA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82902BA8: C04B7BC8  lfs f2, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82902BAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902BB0: C02A08A4  lfs f1, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82902BB4: 4BEF336D  bl 0x827f5f20
	ctx.lr = 0x82902BB8;
	sub_827F5F20(ctx, base);
	// 82902BB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902BBC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82902BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902BC4: 388B4A20  addi r4, r11, 0x4a20
	ctx.r[4].s64 = ctx.r[11].s64 + 18976;
	// 82902BC8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82902BCC: 4BFC3625  bl 0x828c61f0
	ctx.lr = 0x82902BD0;
	sub_828C61F0(ctx, base);
	// 82902BD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902BD4: 4B9C60E5  bl 0x822c8cb8
	ctx.lr = 0x82902BD8;
	sub_822C8CB8(ctx, base);
	// 82902BD8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82902BDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902BE0: 808BC22C  lwz r4, -0x3dd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15828 as u32) ) } as u64;
	// 82902BE4: 484F0E25  bl 0x82df3a08
	ctx.lr = 0x82902BE8;
	sub_82DF3A08(ctx, base);
	// 82902BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902BEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902BF0: 48556AF9  bl 0x82e596e8
	ctx.lr = 0x82902BF4;
	sub_82E596E8(ctx, base);
	// 82902BF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902BF8: 484F0831  bl 0x82df3428
	ctx.lr = 0x82902BFC;
	sub_82DF3428(ctx, base);
	// 82902BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902C00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82902C04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902C08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902C18 size=96
    let mut pc: u32 = 0x82902C18;
    'dispatch: loop {
        match pc {
            0x82902C18 => {
    //   block [0x82902C18..0x82902C78)
	// 82902C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902C24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902C2C: 4BFFFED5  bl 0x82902b00
	ctx.lr = 0x82902C30;
	sub_82902B00(ctx, base);
	// 82902C30: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902C34: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 82902C38: 396B4A68  addi r11, r11, 0x4a68
	ctx.r[11].s64 = ctx.r[11].s64 + 19048;
	// 82902C3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902C40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82902C44: 808AC234  lwz r4, -0x3dcc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15820 as u32) ) } as u64;
	// 82902C48: 484F0DC1  bl 0x82df3a08
	ctx.lr = 0x82902C4C;
	sub_82DF3A08(ctx, base);
	// 82902C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902C50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902C54: 48556A95  bl 0x82e596e8
	ctx.lr = 0x82902C58;
	sub_82E596E8(ctx, base);
	// 82902C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902C5C: 484F07CD  bl 0x82df3428
	ctx.lr = 0x82902C60;
	sub_82DF3428(ctx, base);
	// 82902C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902C64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82902C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82902C78 size=196
    let mut pc: u32 = 0x82902C78;
    'dispatch: loop {
        match pc {
            0x82902C78 => {
    //   block [0x82902C78..0x82902D3C)
	// 82902C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902C84: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902C88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902C8C: 4BFFFE75  bl 0x82902b00
	ctx.lr = 0x82902C90;
	sub_82902B00(ctx, base);
	// 82902C90: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902C94: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82902C98: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82902C9C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82902CA0: 392B4AA0  addi r9, r11, 0x4aa0
	ctx.r[9].s64 = ctx.r[11].s64 + 19104;
	// 82902CA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902CA8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82902CAC: 394A02C8  addi r10, r10, 0x2c8
	ctx.r[10].s64 = ctx.r[10].s64 + 712;
	// 82902CB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902CB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82902CB8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82902CBC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902CC0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82902CC4: 4BFFF3F5  bl 0x829020b8
	ctx.lr = 0x82902CC8;
	sub_829020B8(ctx, base);
	// 82902CC8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82902CCC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82902CD0: C04B7BC8  lfs f2, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82902CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902CD8: C02AA1C4  lfs f1, -0x5e3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82902CDC: 4BEF3245  bl 0x827f5f20
	ctx.lr = 0x82902CE0;
	sub_827F5F20(ctx, base);
	// 82902CE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902CE4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82902CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902CEC: 388B4938  addi r4, r11, 0x4938
	ctx.r[4].s64 = ctx.r[11].s64 + 18744;
	// 82902CF0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82902CF4: 4BFC34FD  bl 0x828c61f0
	ctx.lr = 0x82902CF8;
	sub_828C61F0(ctx, base);
	// 82902CF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902CFC: 4B9C5FBD  bl 0x822c8cb8
	ctx.lr = 0x82902D00;
	sub_822C8CB8(ctx, base);
	// 82902D00: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82902D04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902D08: 808BC238  lwz r4, -0x3dc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15816 as u32) ) } as u64;
	// 82902D0C: 484F0CFD  bl 0x82df3a08
	ctx.lr = 0x82902D10;
	sub_82DF3A08(ctx, base);
	// 82902D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902D18: 485569D1  bl 0x82e596e8
	ctx.lr = 0x82902D1C;
	sub_82E596E8(ctx, base);
	// 82902D1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902D20: 484F0709  bl 0x82df3428
	ctx.lr = 0x82902D24;
	sub_82DF3428(ctx, base);
	// 82902D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902D28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82902D2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902D30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902D34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902D40 size=96
    let mut pc: u32 = 0x82902D40;
    'dispatch: loop {
        match pc {
            0x82902D40 => {
    //   block [0x82902D40..0x82902DA0)
	// 82902D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902D4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902D54: 4BFFFDAD  bl 0x82902b00
	ctx.lr = 0x82902D58;
	sub_82902B00(ctx, base);
	// 82902D58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902D5C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 82902D60: 396B4AD8  addi r11, r11, 0x4ad8
	ctx.r[11].s64 = ctx.r[11].s64 + 19160;
	// 82902D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902D68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82902D6C: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 82902D70: 484F0C99  bl 0x82df3a08
	ctx.lr = 0x82902D74;
	sub_82DF3A08(ctx, base);
	// 82902D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902D78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902D7C: 4855696D  bl 0x82e596e8
	ctx.lr = 0x82902D80;
	sub_82E596E8(ctx, base);
	// 82902D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902D84: 484F06A5  bl 0x82df3428
	ctx.lr = 0x82902D88;
	sub_82DF3428(ctx, base);
	// 82902D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902D8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82902D90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902D94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902D98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902D9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82902DA0 size=196
    let mut pc: u32 = 0x82902DA0;
    'dispatch: loop {
        match pc {
            0x82902DA0 => {
    //   block [0x82902DA0..0x82902E64)
	// 82902DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902DA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902DAC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902DB4: 4BFFFD4D  bl 0x82902b00
	ctx.lr = 0x82902DB8;
	sub_82902B00(ctx, base);
	// 82902DB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902DBC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82902DC0: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82902DC4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82902DC8: 392B4B10  addi r9, r11, 0x4b10
	ctx.r[9].s64 = ctx.r[11].s64 + 19216;
	// 82902DCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902DD0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82902DD4: 394A2360  addi r10, r10, 0x2360
	ctx.r[10].s64 = ctx.r[10].s64 + 9056;
	// 82902DD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902DDC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82902DE0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82902DE4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902DE8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82902DEC: 4BFFF34D  bl 0x82902138
	ctx.lr = 0x82902DF0;
	sub_82902138(ctx, base);
	// 82902DF0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82902DF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82902DF8: C04B7BC8  lfs f2, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82902DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902E00: C02A9524  lfs f1, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82902E04: 4BEF311D  bl 0x827f5f20
	ctx.lr = 0x82902E08;
	sub_827F5F20(ctx, base);
	// 82902E08: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902E0C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82902E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902E14: 388B4938  addi r4, r11, 0x4938
	ctx.r[4].s64 = ctx.r[11].s64 + 18744;
	// 82902E18: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82902E1C: 4BFC33D5  bl 0x828c61f0
	ctx.lr = 0x82902E20;
	sub_828C61F0(ctx, base);
	// 82902E20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902E24: 4B9C5E95  bl 0x822c8cb8
	ctx.lr = 0x82902E28;
	sub_822C8CB8(ctx, base);
	// 82902E28: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82902E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902E30: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 82902E34: 484F0BD5  bl 0x82df3a08
	ctx.lr = 0x82902E38;
	sub_82DF3A08(ctx, base);
	// 82902E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902E3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902E40: 485568A9  bl 0x82e596e8
	ctx.lr = 0x82902E44;
	sub_82E596E8(ctx, base);
	// 82902E44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902E48: 484F05E1  bl 0x82df3428
	ctx.lr = 0x82902E4C;
	sub_82DF3428(ctx, base);
	// 82902E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902E50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82902E54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902E58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902E5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82902E68 size=236
    let mut pc: u32 = 0x82902E68;
    'dispatch: loop {
        match pc {
            0x82902E68 => {
    //   block [0x82902E68..0x82902F54)
	// 82902E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902E70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902E74: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902E78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902E7C: 4BFFFC85  bl 0x82902b00
	ctx.lr = 0x82902E80;
	sub_82902B00(ctx, base);
	// 82902E80: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82902E84: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82902E88: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82902E8C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82902E90: 392BBA80  addi r9, r11, -0x4580
	ctx.r[9].s64 = ctx.r[11].s64 + -17792;
	// 82902E94: 394A4B48  addi r10, r10, 0x4b48
	ctx.r[10].s64 = ctx.r[10].s64 + 19272;
	// 82902E98: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 82902E9C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82902EA0: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902EA4: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82902EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902EAC: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902EB0: 39481E08  addi r10, r8, 0x1e08
	ctx.r[10].s64 = ctx.r[8].s64 + 7688;
	// 82902EB4: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82902EB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82902EBC: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902EC0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82902EC4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82902EC8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902ECC: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902ED0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902ED4: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82902ED8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82902EDC: 4BFFF2DD  bl 0x829021b8
	ctx.lr = 0x82902EE0;
	sub_829021B8(ctx, base);
	// 82902EE0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82902EE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82902EE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902EEC: C04B7BC8  lfs f2, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82902EF0: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82902EF4: 4BEF302D  bl 0x827f5f20
	ctx.lr = 0x82902EF8;
	sub_827F5F20(ctx, base);
	// 82902EF8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902EFC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82902F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902F04: 388BD948  addi r4, r11, -0x26b8
	ctx.r[4].s64 = ctx.r[11].s64 + -9912;
	// 82902F08: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82902F0C: 4BFC32E5  bl 0x828c61f0
	ctx.lr = 0x82902F10;
	sub_828C61F0(ctx, base);
	// 82902F10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902F14: 4B9C5DA5  bl 0x822c8cb8
	ctx.lr = 0x82902F18;
	sub_822C8CB8(ctx, base);
	// 82902F18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82902F1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902F20: 808B0B50  lwz r4, 0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 82902F24: 484F0AE5  bl 0x82df3a08
	ctx.lr = 0x82902F28;
	sub_82DF3A08(ctx, base);
	// 82902F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902F2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902F30: 485567B9  bl 0x82e596e8
	ctx.lr = 0x82902F34;
	sub_82E596E8(ctx, base);
	// 82902F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902F38: 484F04F1  bl 0x82df3428
	ctx.lr = 0x82902F3C;
	sub_82DF3428(ctx, base);
	// 82902F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902F40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82902F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82902F58 size=240
    let mut pc: u32 = 0x82902F58;
    'dispatch: loop {
        match pc {
            0x82902F58 => {
    //   block [0x82902F58..0x82903048)
	// 82902F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902F60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902F64: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902F6C: 4BFFFB95  bl 0x82902b00
	ctx.lr = 0x82902F70;
	sub_82902B00(ctx, base);
	// 82902F70: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82902F74: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82902F78: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82902F7C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82902F80: 392BBA80  addi r9, r11, -0x4580
	ctx.r[9].s64 = ctx.r[11].s64 + -17792;
	// 82902F84: 394A4B80  addi r10, r10, 0x4b80
	ctx.r[10].s64 = ctx.r[10].s64 + 19328;
	// 82902F88: 3D008290  lis r8, -0x7d70
	ctx.r[8].s64 = -2104492032;
	// 82902F8C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82902F90: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902F94: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82902F98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902F9C: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902FA0: 39481EB8  addi r10, r8, 0x1eb8
	ctx.r[10].s64 = ctx.r[8].s64 + 7864;
	// 82902FA4: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82902FA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82902FAC: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902FB0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82902FB4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82902FB8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902FBC: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82902FC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902FC4: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82902FC8: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82902FCC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82902FD0: 4BFFF269  bl 0x82902238
	ctx.lr = 0x82902FD4;
	sub_82902238(ctx, base);
	// 82902FD4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82902FD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82902FDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902FE0: C04B7BC8  lfs f2, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82902FE4: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82902FE8: 4BEF2F39  bl 0x827f5f20
	ctx.lr = 0x82902FEC;
	sub_827F5F20(ctx, base);
	// 82902FEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82902FF0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82902FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82902FF8: 388BD948  addi r4, r11, -0x26b8
	ctx.r[4].s64 = ctx.r[11].s64 + -9912;
	// 82902FFC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82903000: 4BFC31F1  bl 0x828c61f0
	ctx.lr = 0x82903004;
	sub_828C61F0(ctx, base);
	// 82903004: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82903008: 4B9C5CB1  bl 0x822c8cb8
	ctx.lr = 0x8290300C;
	sub_822C8CB8(ctx, base);
	// 8290300C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82903010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903014: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 82903018: 484F09F1  bl 0x82df3a08
	ctx.lr = 0x8290301C;
	sub_82DF3A08(ctx, base);
	// 8290301C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82903024: 485566C5  bl 0x82e596e8
	ctx.lr = 0x82903028;
	sub_82E596E8(ctx, base);
	// 82903028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290302C: 484F03FD  bl 0x82df3428
	ctx.lr = 0x82903030;
	sub_82DF3428(ctx, base);
	// 82903030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903034: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82903038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290303C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82903048 size=216
    let mut pc: u32 = 0x82903048;
    'dispatch: loop {
        match pc {
            0x82903048 => {
    //   block [0x82903048..0x82903120)
	// 82903048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290304C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82903054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290305C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903060: 4BFFFAA1  bl 0x82902b00
	ctx.lr = 0x82903064;
	sub_82902B00(ctx, base);
	// 82903064: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903068: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8290306C: 396B4BB8  addi r11, r11, 0x4bb8
	ctx.r[11].s64 = ctx.r[11].s64 + 19384;
	// 82903070: 388A4940  addi r4, r10, 0x4940
	ctx.r[4].s64 = ctx.r[10].s64 + 18752;
	// 82903074: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82903078: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8290307C: 38A00272  li r5, 0x272
	ctx.r[5].s64 = 626;
	// 82903080: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82903084: 4B9BD355  bl 0x822c03d8
	ctx.lr = 0x82903088;
	sub_822C03D8(ctx, base);
	// 82903088: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8290308C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903090: 4182000C  beq 0x8290309c
	if ctx.cr[0].eq {
	pc = 0x8290309C; continue 'dispatch;
	}
	// 82903094: 4BEF25E5  bl 0x827f5678
	ctx.lr = 0x82903098;
	sub_827F5678(ctx, base);
	// 82903098: 48000008  b 0x829030a0
	pc = 0x829030A0; continue 'dispatch;
	// 8290309C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829030A0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829030A4: 907F006C  stw r3, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 829030A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829030AC: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 829030B0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 829030B4: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 829030B8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829030BC: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 829030C0: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 829030C4: 3CE0832D  lis r7, -0x7cd3
	ctx.r[7].s64 = -2094202880;
	// 829030C8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829030CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829030D0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829030D4: C1A99450  lfs f13, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903120 size=100
    let mut pc: u32 = 0x82903120;
    'dispatch: loop {
        match pc {
            0x82903120 => {
    //   block [0x82903120..0x82903184)
	// 82903120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290312C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903138: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 8290313C: 4BBAE165  bl 0x824b12a0
	ctx.lr = 0x82903140;
	sub_824B12A0(ctx, base);
	// 82903140: 83DF006C  lwz r30, 0x6c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82903144: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82903148: 419A0014  beq cr6, 0x8290315c
	if ctx.cr[6].eq {
	pc = 0x8290315C; continue 'dispatch;
	}
	// 8290314C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903150: 4BEF2579  bl 0x827f56c8
	ctx.lr = 0x82903154;
	sub_827F56C8(ctx, base);
	// 82903154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903158: 4B9BD111  bl 0x822c0268
	ctx.lr = 0x8290315C;
	sub_822C0268(ctx, base);
	// 8290315C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82903160: 48000C71  bl 0x82903dd0
	ctx.lr = 0x82903164;
	sub_82903DD0(ctx, base);
	// 82903164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903168: 48559421  bl 0x82e5c588
	ctx.lr = 0x8290316C;
	sub_82E5C588(ctx, base);
	// 8290316C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903178: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290317C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903188 size=108
    let mut pc: u32 = 0x82903188;
    'dispatch: loop {
        match pc {
            0x82903188 => {
    //   block [0x82903188..0x829031F4)
	// 82903188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290318C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903194: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290319C: 4BFFF965  bl 0x82902b00
	ctx.lr = 0x829031A0;
	sub_82902B00(ctx, base);
	// 829031A0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 829031A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829031A8: 394A4BF0  addi r10, r10, 0x4bf0
	ctx.r[10].s64 = ctx.r[10].s64 + 19440;
	// 829031AC: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 829031B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829031B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829031B8: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829031BC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829031C0: 80890B58  lwz r4, 0xb58(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2904 as u32) ) } as u64;
	// 829031C4: 484F0845  bl 0x82df3a08
	ctx.lr = 0x829031C8;
	sub_82DF3A08(ctx, base);
	// 829031C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829031CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829031D0: 48556519  bl 0x82e596e8
	ctx.lr = 0x829031D4;
	sub_82E596E8(ctx, base);
	// 829031D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829031D8: 484F0251  bl 0x82df3428
	ctx.lr = 0x829031DC;
	sub_82DF3428(ctx, base);
	// 829031DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829031E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829031E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829031E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829031EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829031F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829031F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829031F8 size=96
    let mut pc: u32 = 0x829031F8;
    'dispatch: loop {
        match pc {
            0x829031F8 => {
    //   block [0x829031F8..0x82903258)
	// 829031F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829031FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903200: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903204: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290320C: 4BFFF8F5  bl 0x82902b00
	ctx.lr = 0x82903210;
	sub_82902B00(ctx, base);
	// 82903210: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903214: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 82903218: 396B4C28  addi r11, r11, 0x4c28
	ctx.r[11].s64 = ctx.r[11].s64 + 19496;
	// 8290321C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903220: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82903224: 808A0AF8  lwz r4, 0xaf8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2808 as u32) ) } as u64;
	// 82903228: 484F07E1  bl 0x82df3a08
	ctx.lr = 0x8290322C;
	sub_82DF3A08(ctx, base);
	// 8290322C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82903234: 485564B5  bl 0x82e596e8
	ctx.lr = 0x82903238;
	sub_82E596E8(ctx, base);
	// 82903238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290323C: 484F01ED  bl 0x82df3428
	ctx.lr = 0x82903240;
	sub_82DF3428(ctx, base);
	// 82903240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903244: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290324C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903258 size=112
    let mut pc: u32 = 0x82903258;
    'dispatch: loop {
        match pc {
            0x82903258 => {
    //   block [0x82903258..0x829032C8)
	// 82903258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290325C: 488A4F11  bl 0x831a816c
	ctx.lr = 0x82903260;
	sub_831A8130(ctx, base);
	// 82903260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903264: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903268: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290326C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82903270: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 82903274: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 82903278: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 8290327C: 484EF16D  bl 0x82df23e8
	ctx.lr = 0x82903280;
	sub_82DF23E8(ctx, base);
	// 82903280: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903284: 41820010  beq 0x82903294
	if ctx.cr[0].eq {
	pc = 0x82903294; continue 'dispatch;
	}
	// 82903288: 4BFFF8C9  bl 0x82902b50
	ctx.lr = 0x8290328C;
	sub_82902B50(ctx, base);
	// 8290328C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903290: 48000008  b 0x82903298
	pc = 0x82903298; continue 'dispatch;
	// 82903294: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82903298: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8290329C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829032A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829032A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829032A8: 4BFFDBC1  bl 0x82900e68
	ctx.lr = 0x829032AC;
	sub_82900E68(ctx, base);
	// 829032AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829032B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829032B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829032B8: 4B9BCD49  bl 0x822c0000
	ctx.lr = 0x829032BC;
	sub_822C0000(ctx, base);
	// 829032BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829032C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829032C4: 488A4EF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829032C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829032C8 size=112
    let mut pc: u32 = 0x829032C8;
    'dispatch: loop {
        match pc {
            0x829032C8 => {
    //   block [0x829032C8..0x82903338)
	// 829032C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829032CC: 488A4EA1  bl 0x831a816c
	ctx.lr = 0x829032D0;
	sub_831A8130(ctx, base);
	// 829032D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829032D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829032D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829032DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829032E0: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 829032E4: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 829032E8: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 829032EC: 484EF0FD  bl 0x82df23e8
	ctx.lr = 0x829032F0;
	sub_82DF23E8(ctx, base);
	// 829032F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829032F4: 41820010  beq 0x82903304
	if ctx.cr[0].eq {
	pc = 0x82903304; continue 'dispatch;
	}
	// 829032F8: 4BFFF921  bl 0x82902c18
	ctx.lr = 0x829032FC;
	sub_82902C18(ctx, base);
	// 829032FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903300: 48000008  b 0x82903308
	pc = 0x82903308; continue 'dispatch;
	// 82903304: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82903308: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8290330C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82903310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903318: 4BFFDC19  bl 0x82900f30
	ctx.lr = 0x8290331C;
	sub_82900F30(ctx, base);
	// 8290331C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903328: 4B9BCCD9  bl 0x822c0000
	ctx.lr = 0x8290332C;
	sub_822C0000(ctx, base);
	// 8290332C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903334: 488A4E88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903338 size=112
    let mut pc: u32 = 0x82903338;
    'dispatch: loop {
        match pc {
            0x82903338 => {
    //   block [0x82903338..0x829033A8)
	// 82903338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290333C: 488A4E31  bl 0x831a816c
	ctx.lr = 0x82903340;
	sub_831A8130(ctx, base);
	// 82903340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903344: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903348: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290334C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82903350: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 82903354: 38A000B9  li r5, 0xb9
	ctx.r[5].s64 = 185;
	// 82903358: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 8290335C: 484EF08D  bl 0x82df23e8
	ctx.lr = 0x82903360;
	sub_82DF23E8(ctx, base);
	// 82903360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903364: 41820010  beq 0x82903374
	if ctx.cr[0].eq {
	pc = 0x82903374; continue 'dispatch;
	}
	// 82903368: 4BFFF911  bl 0x82902c78
	ctx.lr = 0x8290336C;
	sub_82902C78(ctx, base);
	// 8290336C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903370: 48000008  b 0x82903378
	pc = 0x82903378; continue 'dispatch;
	// 82903374: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82903378: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8290337C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82903380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903384: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903388: 4BFFDC71  bl 0x82900ff8
	ctx.lr = 0x8290338C;
	sub_82900FF8(ctx, base);
	// 8290338C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903398: 4B9BCC69  bl 0x822c0000
	ctx.lr = 0x8290339C;
	sub_822C0000(ctx, base);
	// 8290339C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829033A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829033A4: 488A4E18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829033A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829033A8 size=112
    let mut pc: u32 = 0x829033A8;
    'dispatch: loop {
        match pc {
            0x829033A8 => {
    //   block [0x829033A8..0x82903418)
	// 829033A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829033AC: 488A4DC1  bl 0x831a816c
	ctx.lr = 0x829033B0;
	sub_831A8130(ctx, base);
	// 829033B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829033B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829033B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829033BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829033C0: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 829033C4: 38A000EC  li r5, 0xec
	ctx.r[5].s64 = 236;
	// 829033C8: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 829033CC: 484EF01D  bl 0x82df23e8
	ctx.lr = 0x829033D0;
	sub_82DF23E8(ctx, base);
	// 829033D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829033D4: 41820010  beq 0x829033e4
	if ctx.cr[0].eq {
	pc = 0x829033E4; continue 'dispatch;
	}
	// 829033D8: 4BFFF969  bl 0x82902d40
	ctx.lr = 0x829033DC;
	sub_82902D40(ctx, base);
	// 829033DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829033E0: 48000008  b 0x829033e8
	pc = 0x829033E8; continue 'dispatch;
	// 829033E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829033E8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829033EC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829033F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829033F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829033F8: 4BFFDCC9  bl 0x829010c0
	ctx.lr = 0x829033FC;
	sub_829010C0(ctx, base);
	// 829033FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903408: 4B9BCBF9  bl 0x822c0000
	ctx.lr = 0x8290340C;
	sub_822C0000(ctx, base);
	// 8290340C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903410: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903414: 488A4DA8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903418 size=112
    let mut pc: u32 = 0x82903418;
    'dispatch: loop {
        match pc {
            0x82903418 => {
    //   block [0x82903418..0x82903488)
	// 82903418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290341C: 488A4D51  bl 0x831a816c
	ctx.lr = 0x82903420;
	sub_831A8130(ctx, base);
	// 82903420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903424: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903428: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290342C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82903430: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 82903434: 38A00119  li r5, 0x119
	ctx.r[5].s64 = 281;
	// 82903438: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 8290343C: 484EEFAD  bl 0x82df23e8
	ctx.lr = 0x82903440;
	sub_82DF23E8(ctx, base);
	// 82903440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903444: 41820010  beq 0x82903454
	if ctx.cr[0].eq {
	pc = 0x82903454; continue 'dispatch;
	}
	// 82903448: 4BFFF959  bl 0x82902da0
	ctx.lr = 0x8290344C;
	sub_82902DA0(ctx, base);
	// 8290344C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903450: 48000008  b 0x82903458
	pc = 0x82903458; continue 'dispatch;
	// 82903454: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82903458: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8290345C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82903460: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903468: 4BFFDD21  bl 0x82901188
	ctx.lr = 0x8290346C;
	sub_82901188(ctx, base);
	// 8290346C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903478: 4B9BCB89  bl 0x822c0000
	ctx.lr = 0x8290347C;
	sub_822C0000(ctx, base);
	// 8290347C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903484: 488A4D38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903488 size=112
    let mut pc: u32 = 0x82903488;
    'dispatch: loop {
        match pc {
            0x82903488 => {
    //   block [0x82903488..0x829034F8)
	// 82903488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290348C: 488A4CE1  bl 0x831a816c
	ctx.lr = 0x82903490;
	sub_831A8130(ctx, base);
	// 82903490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903494: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903498: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290349C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829034A0: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 829034A4: 38A001BD  li r5, 0x1bd
	ctx.r[5].s64 = 445;
	// 829034A8: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 829034AC: 484EEF3D  bl 0x82df23e8
	ctx.lr = 0x829034B0;
	sub_82DF23E8(ctx, base);
	// 829034B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829034B4: 41820010  beq 0x829034c4
	if ctx.cr[0].eq {
	pc = 0x829034C4; continue 'dispatch;
	}
	// 829034B8: 4BFFF9B1  bl 0x82902e68
	ctx.lr = 0x829034BC;
	sub_82902E68(ctx, base);
	// 829034BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829034C0: 48000008  b 0x829034c8
	pc = 0x829034C8; continue 'dispatch;
	// 829034C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829034C8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829034CC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829034D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829034D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829034D8: 4BFFDD79  bl 0x82901250
	ctx.lr = 0x829034DC;
	sub_82901250(ctx, base);
	// 829034DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829034E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829034E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829034E8: 4B9BCB19  bl 0x822c0000
	ctx.lr = 0x829034EC;
	sub_822C0000(ctx, base);
	// 829034EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829034F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829034F4: 488A4CC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829034F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829034F8 size=112
    let mut pc: u32 = 0x829034F8;
    'dispatch: loop {
        match pc {
            0x829034F8 => {
    //   block [0x829034F8..0x82903568)
	// 829034F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829034FC: 488A4C71  bl 0x831a816c
	ctx.lr = 0x82903500;
	sub_831A8130(ctx, base);
	// 82903500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903504: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903508: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290350C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82903510: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 82903514: 38A00205  li r5, 0x205
	ctx.r[5].s64 = 517;
	// 82903518: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 8290351C: 484EEECD  bl 0x82df23e8
	ctx.lr = 0x82903520;
	sub_82DF23E8(ctx, base);
	// 82903520: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903524: 41820010  beq 0x82903534
	if ctx.cr[0].eq {
	pc = 0x82903534; continue 'dispatch;
	}
	// 82903528: 4BFFFA31  bl 0x82902f58
	ctx.lr = 0x8290352C;
	sub_82902F58(ctx, base);
	// 8290352C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903530: 48000008  b 0x82903538
	pc = 0x82903538; continue 'dispatch;
	// 82903534: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82903538: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8290353C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82903540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903548: 4BFFDDD1  bl 0x82901318
	ctx.lr = 0x8290354C;
	sub_82901318(ctx, base);
	// 8290354C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903558: 4B9BCAA9  bl 0x822c0000
	ctx.lr = 0x8290355C;
	sub_822C0000(ctx, base);
	// 8290355C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903564: 488A4C58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903568 size=112
    let mut pc: u32 = 0x82903568;
    'dispatch: loop {
        match pc {
            0x82903568 => {
    //   block [0x82903568..0x829035D8)
	// 82903568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290356C: 488A4C01  bl 0x831a816c
	ctx.lr = 0x82903570;
	sub_831A8130(ctx, base);
	// 82903570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903574: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903578: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290357C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82903580: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 82903584: 38A0026B  li r5, 0x26b
	ctx.r[5].s64 = 619;
	// 82903588: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 8290358C: 484EEE5D  bl 0x82df23e8
	ctx.lr = 0x82903590;
	sub_82DF23E8(ctx, base);
	// 82903590: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903594: 41820010  beq 0x829035a4
	if ctx.cr[0].eq {
	pc = 0x829035A4; continue 'dispatch;
	}
	// 82903598: 4BFFFAB1  bl 0x82903048
	ctx.lr = 0x8290359C;
	sub_82903048(ctx, base);
	// 8290359C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829035A0: 48000008  b 0x829035a8
	pc = 0x829035A8; continue 'dispatch;
	// 829035A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829035A8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829035AC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829035B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829035B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829035B8: 4BFFDE29  bl 0x829013e0
	ctx.lr = 0x829035BC;
	sub_829013E0(ctx, base);
	// 829035BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829035C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829035C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829035C8: 4B9BCA39  bl 0x822c0000
	ctx.lr = 0x829035CC;
	sub_822C0000(ctx, base);
	// 829035CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829035D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829035D4: 488A4BE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829035D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829035D8 size=76
    let mut pc: u32 = 0x829035D8;
    'dispatch: loop {
        match pc {
            0x829035D8 => {
    //   block [0x829035D8..0x82903624)
	// 829035D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829035DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829035E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829035E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829035E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829035EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829035F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829035F4: 4BFFFB2D  bl 0x82903120
	ctx.lr = 0x829035F8;
	sub_82903120(ctx, base);
	// 829035F8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829035FC: 4182000C  beq 0x82903608
	if ctx.cr[0].eq {
	pc = 0x82903608; continue 'dispatch;
	}
	// 82903600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903604: 484EEDD5  bl 0x82df23d8
	ctx.lr = 0x82903608;
	sub_82DF23D8(ctx, base);
	// 82903608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290360C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290361C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903628 size=112
    let mut pc: u32 = 0x82903628;
    'dispatch: loop {
        match pc {
            0x82903628 => {
    //   block [0x82903628..0x82903698)
	// 82903628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290362C: 488A4B41  bl 0x831a816c
	ctx.lr = 0x82903630;
	sub_831A8130(ctx, base);
	// 82903630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903634: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903638: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290363C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82903640: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 82903644: 38A00325  li r5, 0x325
	ctx.r[5].s64 = 805;
	// 82903648: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 8290364C: 484EED9D  bl 0x82df23e8
	ctx.lr = 0x82903650;
	sub_82DF23E8(ctx, base);
	// 82903650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903654: 41820010  beq 0x82903664
	if ctx.cr[0].eq {
	pc = 0x82903664; continue 'dispatch;
	}
	// 82903658: 4BFFFB31  bl 0x82903188
	ctx.lr = 0x8290365C;
	sub_82903188(ctx, base);
	// 8290365C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903660: 48000008  b 0x82903668
	pc = 0x82903668; continue 'dispatch;
	// 82903664: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82903668: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8290366C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82903670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903678: 4BFFDE31  bl 0x829014a8
	ctx.lr = 0x8290367C;
	sub_829014A8(ctx, base);
	// 8290367C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903688: 4B9BC979  bl 0x822c0000
	ctx.lr = 0x8290368C;
	sub_822C0000(ctx, base);
	// 8290368C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903694: 488A4B28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903698 size=104
    let mut pc: u32 = 0x82903698;
    'dispatch: loop {
        match pc {
            0x82903698 => {
    //   block [0x82903698..0x82903700)
	// 82903698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290369C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829036A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829036A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829036A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829036AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829036B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829036B4: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 829036B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829036BC: 419A0008  beq cr6, 0x829036c4
	if ctx.cr[6].eq {
	pc = 0x829036C4; continue 'dispatch;
	}
	// 829036C0: 4B9BD1D1  bl 0x822c0890
	ctx.lr = 0x829036C4;
	sub_822C0890(ctx, base);
	// 829036C4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 829036C8: 48000709  bl 0x82903dd0
	ctx.lr = 0x829036CC;
	sub_82903DD0(ctx, base);
	// 829036CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829036D0: 48558EB9  bl 0x82e5c588
	ctx.lr = 0x829036D4;
	sub_82E5C588(ctx, base);
	// 829036D4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829036D8: 4182000C  beq 0x829036e4
	if ctx.cr[0].eq {
	pc = 0x829036E4; continue 'dispatch;
	}
	// 829036DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829036E0: 484EECF9  bl 0x82df23d8
	ctx.lr = 0x829036E4;
	sub_82DF23D8(ctx, base);
	// 829036E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829036E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829036EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829036F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829036F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829036F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829036FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903700 size=112
    let mut pc: u32 = 0x82903700;
    'dispatch: loop {
        match pc {
            0x82903700 => {
    //   block [0x82903700..0x82903770)
	// 82903700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903704: 488A4A69  bl 0x831a816c
	ctx.lr = 0x82903708;
	sub_831A8130(ctx, base);
	// 82903708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290370C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903710: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82903714: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82903718: 388B4940  addi r4, r11, 0x4940
	ctx.r[4].s64 = ctx.r[11].s64 + 18752;
	// 8290371C: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82903720: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 82903724: 484EECC5  bl 0x82df23e8
	ctx.lr = 0x82903728;
	sub_82DF23E8(ctx, base);
	// 82903728: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8290372C: 41820010  beq 0x8290373c
	if ctx.cr[0].eq {
	pc = 0x8290373C; continue 'dispatch;
	}
	// 82903730: 4BFFFAC9  bl 0x829031f8
	ctx.lr = 0x82903734;
	sub_829031F8(ctx, base);
	// 82903734: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903738: 48000008  b 0x82903740
	pc = 0x82903740; continue 'dispatch;
	// 8290373C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82903740: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82903744: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82903748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8290374C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903750: 4BFFD651  bl 0x82900da0
	ctx.lr = 0x82903754;
	sub_82900DA0(ctx, base);
	// 82903754: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903758: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8290375C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903760: 4B9BC8A1  bl 0x822c0000
	ctx.lr = 0x82903764;
	sub_822C0000(ctx, base);
	// 82903764: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903768: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290376C: 488A4A50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82903770 size=12
    let mut pc: u32 = 0x82903770;
    'dispatch: loop {
        match pc {
            0x82903770 => {
    //   block [0x82903770..0x8290377C)
	// 82903770: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82903774: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82903778: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290377C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290377C size=8
    let mut pc: u32 = 0x8290377C;
    'dispatch: loop {
        match pc {
            0x8290377C => {
    //   block [0x8290377C..0x82903784)
	// 8290377C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82903780: 4BFF8600  b 0x828fbd80
	sub_828FBD80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903784(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82903784 size=4
    let mut pc: u32 = 0x82903784;
    'dispatch: loop {
        match pc {
            0x82903784 => {
    //   block [0x82903784..0x82903788)
	// 82903784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82903788 size=140
    let mut pc: u32 = 0x82903788;
    'dispatch: loop {
        match pc {
            0x82903788 => {
    //   block [0x82903788..0x82903814)
	// 82903788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290378C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903794: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290379C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829037A0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829037A4: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829037A8: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 829037AC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829037B0: D1BF0074  stfs f13, 0x74(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829037B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829037B8: 41990048  bgt cr6, 0x82903800
	if ctx.cr[6].gt {
	pc = 0x82903800; continue 'dispatch;
	}
	// 829037BC: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 829037C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829037C4: 409A001C  bne cr6, 0x829037e0
	if !ctx.cr[6].eq {
	pc = 0x829037E0; continue 'dispatch;
	}
	// 829037C8: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 829037CC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829037D0: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829037D4: 4BFF85AD  bl 0x828fbd80
	ctx.lr = 0x829037D8;
	sub_828FBD80(ctx, base);
	// 829037D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829037DC: 48000020  b 0x829037fc
	pc = 0x829037FC; continue 'dispatch;
	// 829037E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829037E4: 409A001C  bne cr6, 0x82903800
	if !ctx.cr[6].eq {
	pc = 0x82903800; continue 'dispatch;
	}
	// 829037E8: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 829037EC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829037F0: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829037F4: 4BFF853D  bl 0x828fbd30
	ctx.lr = 0x829037F8;
	sub_828FBD30(ctx, base);
	// 829037F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829037FC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82903800: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82903804: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903808: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290380C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903818 size=196
    let mut pc: u32 = 0x82903818;
    'dispatch: loop {
        match pc {
            0x82903818 => {
    //   block [0x82903818..0x829038DC)
	// 82903818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290381C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82903824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290382C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82903830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82903834: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82903838: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290383C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82903840: 4B9BD0F9  bl 0x822c0938
	ctx.lr = 0x82903844;
	sub_822C0938(ctx, base);
	// 82903844: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82903848: 41820028  beq 0x82903870
	if ctx.cr[0].eq {
	pc = 0x82903870; continue 'dispatch;
	}
	// 8290384C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903850: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82903854: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903858: 392B4C60  addi r9, r11, 0x4c60
	ctx.r[9].s64 = ctx.r[11].s64 + 19552;
	// 8290385C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82903860: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82903864: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82903868: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8290386C: 48000008  b 0x82903874
	pc = 0x82903874; continue 'dispatch;
	// 82903870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82903874: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82903878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290387C: 409A0044  bne cr6, 0x829038c0
	if !ctx.cr[6].eq {
	pc = 0x829038C0; continue 'dispatch;
	}
	// 82903880: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82903884: 419A001C  beq cr6, 0x829038a0
	if ctx.cr[6].eq {
	pc = 0x829038A0; continue 'dispatch;
	}
	// 82903888: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290388C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82903890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290389C: 4E800421  bctrl
	ctx.lr = 0x829038A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829038A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829038A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829038A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829038AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829038B0: 816BCCB4  lwz r11, -0x334c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13132 as u32) ) } as u64;
	// 829038B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829038B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829038BC: 4B9BC745  bl 0x822c0000
	ctx.lr = 0x829038C0;
	sub_822C0000(ctx, base);
	// 829038C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829038C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829038C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829038CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829038D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829038D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829038D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829038E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829038E0 size=88
    let mut pc: u32 = 0x829038E0;
    'dispatch: loop {
        match pc {
            0x829038E0 => {
    //   block [0x829038E0..0x82903938)
	// 829038E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829038E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829038E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829038EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829038F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829038F4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829038F8: 4BFF7D91  bl 0x828fb688
	ctx.lr = 0x829038FC;
	sub_828FB688(ctx, base);
	// 829038FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82903900: 395F006C  addi r10, r31, 0x6c
	ctx.r[10].s64 = ctx.r[31].s64 + 108;
	// 82903904: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82903908: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 8290390C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903910: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82903914: 4B9C0B4D  bl 0x822c4460
	ctx.lr = 0x82903918;
	sub_822C4460(ctx, base);
	// 82903918: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8290391C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82903920: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82903924: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82903928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290392C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903938 size=1036
    let mut pc: u32 = 0x82903938;
    'dispatch: loop {
        match pc {
            0x82903938 => {
    //   block [0x82903938..0x82903D44)
	// 82903938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290393C: 488A481D  bl 0x831a8158
	ctx.lr = 0x82903940;
	sub_831A8130(ctx, base);
	// 82903940: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903944: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82903948: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8290394C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82903950: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 82903954: 897F0051  lbz r11, 0x51(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290395C: 419A0048  beq cr6, 0x829039a4
	if ctx.cr[6].eq {
	pc = 0x829039A4; continue 'dispatch;
	}
	// 82903960: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82903964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903968: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 8290396C: 4B9C1F5D  bl 0x822c58c8
	ctx.lr = 0x82903970;
	sub_822C58C8(ctx, base);
	// 82903970: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82903974: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82903978: 4B9C6539  bl 0x822c9eb0
	ctx.lr = 0x8290397C;
	sub_822C9EB0(ctx, base);
	// 8290397C: 4B9C0935  bl 0x822c42b0
	ctx.lr = 0x82903980;
	sub_822C42B0(ctx, base);
	// 82903980: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82903984: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82903988: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 8290398C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82903990: 4B9C1AE1  bl 0x822c5470
	ctx.lr = 0x82903994;
	sub_822C5470(ctx, base);
	// 82903994: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82903998: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8290399C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829039A0: 4B9C1341  bl 0x822c4ce0
	ctx.lr = 0x829039A4;
	sub_822C4CE0(ctx, base);
	// 829039A4: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 829039A8: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 829039AC: 48003DBD  bl 0x82907768
	ctx.lr = 0x829039B0;
	sub_82907768(ctx, base);
	// 829039B0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829039B4: 894B0051  lbz r10, 0x51(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(81 as u32) ) } as u64;
	// 829039B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829039BC: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 829039C0: 419A000C  beq cr6, 0x829039cc
	if ctx.cr[6].eq {
	pc = 0x829039CC; continue 'dispatch;
	}
	// 829039C4: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829039C8: 48000028  b 0x829039f0
	pc = 0x829039F0; continue 'dispatch;
	// 829039CC: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829039D0: 894A0051  lbz r10, 0x51(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 829039D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829039D8: 419A000C  beq cr6, 0x829039e4
	if ctx.cr[6].eq {
	pc = 0x829039E4; continue 'dispatch;
	}
	// 829039DC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 829039E0: 48000010  b 0x829039f0
	pc = 0x829039F0; continue 'dispatch;
	// 829039E4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 829039E8: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 829039EC: 409A00DC  bne cr6, 0x82903ac8
	if !ctx.cr[6].eq {
	pc = 0x82903AC8; continue 'dispatch;
	}
	// 829039F0: 897C0051  lbz r11, 0x51(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(81 as u32) ) } as u64;
	// 829039F4: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829039F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829039FC: 409A0008  bne cr6, 0x82903a04
	if !ctx.cr[6].eq {
	pc = 0x82903A04; continue 'dispatch;
	}
	// 82903A00: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82903A04: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903A08: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903A0C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82903A10: 409A000C  bne cr6, 0x82903a1c
	if !ctx.cr[6].eq {
	pc = 0x82903A1C; continue 'dispatch;
	}
	// 82903A14: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82903A18: 4800001C  b 0x82903a34
	pc = 0x82903A34; continue 'dispatch;
	// 82903A1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903A20: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82903A24: 409A000C  bne cr6, 0x82903a30
	if !ctx.cr[6].eq {
	pc = 0x82903A30; continue 'dispatch;
	}
	// 82903A28: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82903A2C: 48000008  b 0x82903a34
	pc = 0x82903A34; continue 'dispatch;
	// 82903A30: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82903A34: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903A38: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903A3C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82903A40: 409A003C  bne cr6, 0x82903a7c
	if !ctx.cr[6].eq {
	pc = 0x82903A7C; continue 'dispatch;
	}
	// 82903A44: 897C0051  lbz r11, 0x51(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903A4C: 419A000C  beq cr6, 0x82903a58
	if ctx.cr[6].eq {
	pc = 0x82903A58; continue 'dispatch;
	}
	// 82903A50: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82903A54: 48000024  b 0x82903a78
	pc = 0x82903A78; continue 'dispatch;
	// 82903A58: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903A5C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82903A60: 4800000C  b 0x82903a6c
	pc = 0x82903A6C; continue 'dispatch;
	// 82903A64: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82903A68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903A6C: 890B0051  lbz r8, 0x51(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903A70: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82903A74: 419AFFF0  beq cr6, 0x82903a64
	if ctx.cr[6].eq {
	pc = 0x82903A64; continue 'dispatch;
	}
	// 82903A78: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82903A7C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903A80: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903A84: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82903A88: 409A00D4  bne cr6, 0x82903b5c
	if !ctx.cr[6].eq {
	pc = 0x82903B5C; continue 'dispatch;
	}
	// 82903A8C: 897C0051  lbz r11, 0x51(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903A94: 419A000C  beq cr6, 0x82903aa0
	if ctx.cr[6].eq {
	pc = 0x82903AA0; continue 'dispatch;
	}
	// 82903A98: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82903A9C: 48000024  b 0x82903ac0
	pc = 0x82903AC0; continue 'dispatch;
	// 82903AA0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903AA4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82903AA8: 4800000C  b 0x82903ab4
	pc = 0x82903AB4; continue 'dispatch;
	// 82903AAC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82903AB0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903AB4: 890B0051  lbz r8, 0x51(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903AB8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82903ABC: 419AFFF0  beq cr6, 0x82903aac
	if ctx.cr[6].eq {
	pc = 0x82903AAC; continue 'dispatch;
	}
	// 82903AC0: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82903AC4: 48000098  b 0x82903b5c
	pc = 0x82903B5C; continue 'dispatch;
	// 82903AC8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82903ACC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903AD0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82903AD4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903AD8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82903ADC: 409A000C  bne cr6, 0x82903ae8
	if !ctx.cr[6].eq {
	pc = 0x82903AE8; continue 'dispatch;
	}
	// 82903AE0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82903AE4: 4800002C  b 0x82903b10
	pc = 0x82903B10; continue 'dispatch;
	// 82903AE8: 897C0051  lbz r11, 0x51(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903AEC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903AF4: 409A0008  bne cr6, 0x82903afc
	if !ctx.cr[6].eq {
	pc = 0x82903AFC; continue 'dispatch;
	}
	// 82903AF8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82903AFC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82903B00: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903B04: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82903B08: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903B0C: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82903B10: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903B14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903B18: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82903B1C: 409A000C  bne cr6, 0x82903b28
	if !ctx.cr[6].eq {
	pc = 0x82903B28; continue 'dispatch;
	}
	// 82903B20: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82903B24: 48000020  b 0x82903b44
	pc = 0x82903B44; continue 'dispatch;
	// 82903B28: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903B2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903B30: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82903B34: 409A000C  bne cr6, 0x82903b40
	if !ctx.cr[6].eq {
	pc = 0x82903B40; continue 'dispatch;
	}
	// 82903B38: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82903B3C: 48000008  b 0x82903b44
	pc = 0x82903B44; continue 'dispatch;
	// 82903B40: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82903B44: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903B48: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82903B4C: 897B0050  lbz r11, 0x50(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903B50: 89590050  lbz r10, 0x50(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903B54: 99790050  stb r11, 0x50(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82903B58: 995B0050  stb r10, 0x50(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82903B5C: 897B0050  lbz r11, 0x50(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903B60: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82903B64: 409A0198  bne cr6, 0x82903cfc
	if !ctx.cr[6].eq {
	pc = 0x82903CFC; continue 'dispatch;
	}
	// 82903B68: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903B6C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82903B70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903B74: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82903B78: 419A0180  beq cr6, 0x82903cf8
	if ctx.cr[6].eq {
	pc = 0x82903CF8; continue 'dispatch;
	}
	// 82903B7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82903B80: 897C0050  lbz r11, 0x50(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903B84: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82903B88: 409A0170  bne cr6, 0x82903cf8
	if !ctx.cr[6].eq {
	pc = 0x82903CF8; continue 'dispatch;
	}
	// 82903B8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903B90: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82903B94: 409A00A8  bne cr6, 0x82903c3c
	if !ctx.cr[6].eq {
	pc = 0x82903C3C; continue 'dispatch;
	}
	// 82903B98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903B9C: 894B0050  lbz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903BA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903BA4: 409A001C  bne cr6, 0x82903bc0
	if !ctx.cr[6].eq {
	pc = 0x82903BC0; continue 'dispatch;
	}
	// 82903BA8: 9BCB0050  stb r30, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903BAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903BB0: 9BBF0050  stb r29, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82903BB4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903BB8: 4BFBF9D9  bl 0x828c3590
	ctx.lr = 0x82903BBC;
	sub_828C3590(ctx, base);
	// 82903BBC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903BC0: 894B0051  lbz r10, 0x51(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903BC8: 409A00C8  bne cr6, 0x82903c90
	if !ctx.cr[6].eq {
	pc = 0x82903C90; continue 'dispatch;
	}
	// 82903BCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903BD0: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903BD4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82903BD8: 409A0014  bne cr6, 0x82903bec
	if !ctx.cr[6].eq {
	pc = 0x82903BEC; continue 'dispatch;
	}
	// 82903BDC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903BE0: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903BE4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82903BE8: 419A00A4  beq cr6, 0x82903c8c
	if ctx.cr[6].eq {
	pc = 0x82903C8C; continue 'dispatch;
	}
	// 82903BEC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903BF0: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903BF4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82903BF8: 409A0020  bne cr6, 0x82903c18
	if !ctx.cr[6].eq {
	pc = 0x82903C18; continue 'dispatch;
	}
	// 82903BFC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903C00: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82903C04: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903C08: 9BCA0050  stb r30, 0x50(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903C0C: 9BAB0050  stb r29, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82903C10: 4BFBF919  bl 0x828c3528
	ctx.lr = 0x82903C14;
	sub_828C3528(ctx, base);
	// 82903C14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903C18: 895F0050  lbz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903C1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903C20: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903C24: 994B0050  stb r10, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82903C28: 9BDF0050  stb r30, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903C2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903C30: 9BCB0050  stb r30, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903C34: 4BFBF95D  bl 0x828c3590
	ctx.lr = 0x82903C38;
	sub_828C3590(ctx, base);
	// 82903C38: 480000C0  b 0x82903cf8
	pc = 0x82903CF8; continue 'dispatch;
	// 82903C3C: 894B0050  lbz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903C44: 409A001C  bne cr6, 0x82903c60
	if !ctx.cr[6].eq {
	pc = 0x82903C60; continue 'dispatch;
	}
	// 82903C48: 9BCB0050  stb r30, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903C50: 9BBF0050  stb r29, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82903C54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903C58: 4BFBF8D1  bl 0x828c3528
	ctx.lr = 0x82903C5C;
	sub_828C3528(ctx, base);
	// 82903C5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903C60: 894B0051  lbz r10, 0x51(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(81 as u32) ) } as u64;
	// 82903C64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903C68: 409A0028  bne cr6, 0x82903c90
	if !ctx.cr[6].eq {
	pc = 0x82903C90; continue 'dispatch;
	}
	// 82903C6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903C70: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903C74: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82903C78: 409A0034  bne cr6, 0x82903cac
	if !ctx.cr[6].eq {
	pc = 0x82903CAC; continue 'dispatch;
	}
	// 82903C7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903C80: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903C84: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82903C88: 409A0024  bne cr6, 0x82903cac
	if !ctx.cr[6].eq {
	pc = 0x82903CAC; continue 'dispatch;
	}
	// 82903C8C: 9BAB0050  stb r29, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82903C90: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903C94: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82903C98: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903C9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903CA0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82903CA4: 409AFEDC  bne cr6, 0x82903b80
	if !ctx.cr[6].eq {
	pc = 0x82903B80; continue 'dispatch;
	}
	// 82903CA8: 48000050  b 0x82903cf8
	pc = 0x82903CF8; continue 'dispatch;
	// 82903CAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903CB0: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903CB4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82903CB8: 409A0020  bne cr6, 0x82903cd8
	if !ctx.cr[6].eq {
	pc = 0x82903CD8; continue 'dispatch;
	}
	// 82903CBC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903CC0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82903CC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903CC8: 9BCA0050  stb r30, 0x50(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903CCC: 9BAB0050  stb r29, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82903CD0: 4BFBF8C1  bl 0x828c3590
	ctx.lr = 0x82903CD4;
	sub_828C3590(ctx, base);
	// 82903CD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903CD8: 895F0050  lbz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903CE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903CE4: 994B0050  stb r10, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82903CE8: 9BDF0050  stb r30, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903CEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903CF0: 9BCB0050  stb r30, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903CF4: 4BFBF835  bl 0x828c3528
	ctx.lr = 0x82903CF8;
	sub_828C3528(ctx, base);
	// 82903CF8: 9BDC0050  stb r30, 0x50(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82903CFC: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 82903D00: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82903D04: 4B9C4FB5  bl 0x822c8cb8
	ctx.lr = 0x82903D08;
	sub_822C8CB8(ctx, base);
	// 82903D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903D0C: 484EF71D  bl 0x82df3428
	ctx.lr = 0x82903D10;
	sub_82DF3428(ctx, base);
	// 82903D10: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82903D14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82903D18: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82903D1C: 484EE46D  bl 0x82df2188
	ctx.lr = 0x82903D20;
	sub_82DF2188(ctx, base);
	// 82903D20: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903D28: 419A000C  beq cr6, 0x82903d34
	if ctx.cr[6].eq {
	pc = 0x82903D34; continue 'dispatch;
	}
	// 82903D2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82903D30: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82903D34: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82903D38: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82903D3C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82903D40: 488A4468  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903D48 size=132
    let mut pc: u32 = 0x82903D48;
    'dispatch: loop {
        match pc {
            0x82903D48 => {
    //   block [0x82903D48..0x82903DCC)
	// 82903D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903D4C: 488A441D  bl 0x831a8168
	ctx.lr = 0x82903D50;
	sub_831A8130(ctx, base);
	// 82903D50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903D54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82903D58: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82903D5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82903D60: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82903D64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903D68: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903D6C: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82903D70: 409A0044  bne cr6, 0x82903db4
	if !ctx.cr[6].eq {
	pc = 0x82903DB4; continue 'dispatch;
	}
	// 82903D74: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82903D78: 409A003C  bne cr6, 0x82903db4
	if !ctx.cr[6].eq {
	pc = 0x82903DB4; continue 'dispatch;
	}
	// 82903D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903D80: 4BFFE261  bl 0x82901fe0
	ctx.lr = 0x82903D84;
	sub_82901FE0(ctx, base);
	// 82903D84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903D88: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903D8C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82903D90: 48000030  b 0x82903dc0
	pc = 0x82903DC0; continue 'dispatch;
	// 82903D94: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82903D98: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82903D9C: 480039CD  bl 0x82907768
	ctx.lr = 0x82903DA0;
	sub_82907768(ctx, base);
	// 82903DA0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82903DA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903DAC: 4BFFFB8D  bl 0x82903938
	ctx.lr = 0x82903DB0;
	sub_82903938(ctx, base);
	// 82903DB0: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82903DB4: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82903DB8: 409AFFDC  bne cr6, 0x82903d94
	if !ctx.cr[6].eq {
	pc = 0x82903D94; continue 'dispatch;
	}
	// 82903DBC: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82903DC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903DC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82903DC8: 488A43F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903DD0 size=88
    let mut pc: u32 = 0x82903DD0;
    'dispatch: loop {
        match pc {
            0x82903DD0 => {
    //   block [0x82903DD0..0x82903E28)
	// 82903DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903DD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903DDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903DE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903DE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903DE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82903DEC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903DF0: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903DF4: 4BFFFF55  bl 0x82903d48
	ctx.lr = 0x82903DF8;
	sub_82903D48(ctx, base);
	// 82903DF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82903DFC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903E00: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82903E04: 484EE385  bl 0x82df2188
	ctx.lr = 0x82903E08;
	sub_82DF2188(ctx, base);
	// 82903E08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82903E0C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82903E10: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82903E14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903E18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903E1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903E20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903E24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903E28 size=68
    let mut pc: u32 = 0x82903E28;
    'dispatch: loop {
        match pc {
            0x82903E28 => {
    //   block [0x82903E28..0x82903E6C)
	// 82903E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903E2C: 488A4341  bl 0x831a816c
	ctx.lr = 0x82903E30;
	sub_831A8130(ctx, base);
	// 82903E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903E34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903E38: 488507C9  bl 0x83154600
	ctx.lr = 0x82903E3C;
	sub_83154600(ctx, base);
	// 82903E3C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82903E40: 41820024  beq 0x82903e64
	if ctx.cr[0].eq {
	pc = 0x82903E64; continue 'dispatch;
	}
	// 82903E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903E48: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903E4C: 4855592D  bl 0x82e59778
	ctx.lr = 0x82903E50;
	sub_82E59778(ctx, base);
	// 82903E50: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 82903E54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903E5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82903E60: 4E800421  bctrl
	ctx.lr = 0x82903E64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82903E64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903E68: 488A4354  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903E70 size=124
    let mut pc: u32 = 0x82903E70;
    'dispatch: loop {
        match pc {
            0x82903E70 => {
    //   block [0x82903E70..0x82903EEC)
	// 82903E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903E78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82903E7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903E80: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82903E84: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903E8C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82903E90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82903E94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903E9C: 409A0018  bne cr6, 0x82903eb4
	if !ctx.cr[6].eq {
	pc = 0x82903EB4; continue 'dispatch;
	}
	// 82903EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903EA4: 4B9CF735  bl 0x822d35d8
	ctx.lr = 0x82903EA8;
	sub_822D35D8(ctx, base);
	// 82903EA8: 4B9BC159  bl 0x822c0000
	ctx.lr = 0x82903EAC;
	sub_822C0000(ctx, base);
	// 82903EAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903EB0: 4B9CE961  bl 0x822d2810
	ctx.lr = 0x82903EB4;
	sub_822D2810(ctx, base);
	// 82903EB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903EB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82903EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903EC0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82903EC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82903ECC: 4E800421  bctrl
	ctx.lr = 0x82903ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82903ED0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82903ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903EDC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82903EE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82903EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903EF0 size=88
    let mut pc: u32 = 0x82903EF0;
    'dispatch: loop {
        match pc {
            0x82903EF0 => {
    //   block [0x82903EF0..0x82903F48)
	// 82903EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82903EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903F08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82903F0C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82903F10: 4BFFFEC1  bl 0x82903dd0
	ctx.lr = 0x82903F14;
	sub_82903DD0(ctx, base);
	// 82903F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903F18: 48558671  bl 0x82e5c588
	ctx.lr = 0x82903F1C;
	sub_82E5C588(ctx, base);
	// 82903F1C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903F20: 4182000C  beq 0x82903f2c
	if ctx.cr[0].eq {
	pc = 0x82903F2C; continue 'dispatch;
	}
	// 82903F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903F28: 484EE4B1  bl 0x82df23d8
	ctx.lr = 0x82903F2C;
	sub_82DF23D8(ctx, base);
	// 82903F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903F30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903F34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903F38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903F3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82903F40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903F44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


