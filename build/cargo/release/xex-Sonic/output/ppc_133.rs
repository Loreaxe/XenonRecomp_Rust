pub fn sub_82A7EBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A7EBE8 size=8
    let mut pc: u32 = 0x82A7EBE8;
    'dispatch: loop {
        match pc {
            0x82A7EBE8 => {
    //   block [0x82A7EBE8..0x82A7EBF0)
	// 82A7EBE8: D0230110  stfs f1, 0x110(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82A7EBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7EBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A7EBF0 size=36
    let mut pc: u32 = 0x82A7EBF0;
    'dispatch: loop {
        match pc {
            0x82A7EBF0 => {
    //   block [0x82A7EBF0..0x82A7EC14)
	// 82A7EBF0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7EBF4: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82A7EBF8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7EBFC: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A7EC00: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7EC04: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A7EC08: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7EC0C: D003010C  stfs f0, 0x10c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A7EC10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7EC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7EC18 size=152
    let mut pc: u32 = 0x82A7EC18;
    'dispatch: loop {
        match pc {
            0x82A7EC18 => {
    //   block [0x82A7EC18..0x82A7ECB0)
	// 82A7EC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7EC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7EC20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7EC24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7EC28: 83E30114  lwz r31, 0x114(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A7EC2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A7EC30: 419A0060  beq cr6, 0x82a7ec90
	if ctx.cr[6].eq {
	pc = 0x82A7EC90; continue 'dispatch;
	}
	// 82A7EC34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7EC38: C1BF0004  lfs f13, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7EC3C: C00B17A0  lfs f0, 0x17a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7EC40: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A7EC44: 4199004C  bgt cr6, 0x82a7ec90
	if ctx.cr[6].gt {
	pc = 0x82A7EC90; continue 'dispatch;
	}
	// 82A7EC48: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A7EC4C: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7EC50: 41820058  beq 0x82a7eca8
	if ctx.cr[0].eq {
	pc = 0x82A7ECA8; continue 'dispatch;
	}
	// 82A7EC54: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82A7EC58: 419A0050  beq cr6, 0x82a7eca8
	if ctx.cr[6].eq {
	pc = 0x82A7ECA8; continue 'dispatch;
	}
	// 82A7EC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7EC60: 48403311  bl 0x82e81f70
	ctx.lr = 0x82A7EC64;
	sub_82E81F70(ctx, base);
	// 82A7EC64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7EC68: 41820040  beq 0x82a7eca8
	if ctx.cr[0].eq {
	pc = 0x82A7ECA8; continue 'dispatch;
	}
	// 82A7EC6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7EC70: C03F0008  lfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A7EC74: 48403285  bl 0x82e81ef8
	ctx.lr = 0x82A7EC78;
	sub_82E81EF8(ctx, base);
	// 82A7EC78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7EC7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7EC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7EC84: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A7EC88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A7EC8C: 4E800421  bctrl
	ctx.lr = 0x82A7EC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7EC90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A7EC94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A7EC98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7EC9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7ECA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7ECA4: 4E800020  blr
	return;
	// 82A7ECA8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A7ECAC: 4BFFFFE8  b 0x82a7ec94
	pc = 0x82A7EC94; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7ECB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7ECB0 size=196
    let mut pc: u32 = 0x82A7ECB0;
    'dispatch: loop {
        match pc {
            0x82A7ECB0 => {
    //   block [0x82A7ECB0..0x82A7ED74)
	// 82A7ECB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7ECB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7ECB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7ECBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7ECC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7ECC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A7ECC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7ECCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A7ECD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7ECD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7ECD8: 4B841C61  bl 0x822c0938
	ctx.lr = 0x82A7ECDC;
	sub_822C0938(ctx, base);
	// 82A7ECDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7ECE0: 41820028  beq 0x82a7ed08
	if ctx.cr[0].eq {
	pc = 0x82A7ED08; continue 'dispatch;
	}
	// 82A7ECE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7ECE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A7ECEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A7ECF0: 392B1768  addi r9, r11, 0x1768
	ctx.r[9].s64 = ctx.r[11].s64 + 5992;
	// 82A7ECF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A7ECF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A7ECFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A7ED00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A7ED04: 48000008  b 0x82a7ed0c
	pc = 0x82A7ED0C; continue 'dispatch;
	// 82A7ED08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7ED0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7ED10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7ED14: 409A0044  bne cr6, 0x82a7ed58
	if !ctx.cr[6].eq {
	pc = 0x82A7ED58; continue 'dispatch;
	}
	// 82A7ED18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A7ED1C: 419A001C  beq cr6, 0x82a7ed38
	if ctx.cr[6].eq {
	pc = 0x82A7ED38; continue 'dispatch;
	}
	// 82A7ED20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7ED24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A7ED28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7ED2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7ED30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A7ED34: 4E800421  bctrl
	ctx.lr = 0x82A7ED38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7ED38: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A7ED3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A7ED40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7ED44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A7ED48: 816B8DD0  lwz r11, -0x7230(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29232 as u32) ) } as u64;
	// 82A7ED4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A7ED50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A7ED54: 4B8412AD  bl 0x822c0000
	ctx.lr = 0x82A7ED58;
	sub_822C0000(ctx, base);
	// 82A7ED58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7ED5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7ED60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7ED64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7ED68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7ED6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7ED70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7ED78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7ED78 size=196
    let mut pc: u32 = 0x82A7ED78;
    'dispatch: loop {
        match pc {
            0x82A7ED78 => {
    //   block [0x82A7ED78..0x82A7EE3C)
	// 82A7ED78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7ED7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7ED80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7ED84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7ED88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7ED8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A7ED90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7ED94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A7ED98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7ED9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7EDA0: 4B841B99  bl 0x822c0938
	ctx.lr = 0x82A7EDA4;
	sub_822C0938(ctx, base);
	// 82A7EDA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7EDA8: 41820028  beq 0x82a7edd0
	if ctx.cr[0].eq {
	pc = 0x82A7EDD0; continue 'dispatch;
	}
	// 82A7EDAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7EDB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A7EDB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A7EDB8: 392B177C  addi r9, r11, 0x177c
	ctx.r[9].s64 = ctx.r[11].s64 + 6012;
	// 82A7EDBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A7EDC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A7EDC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A7EDC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A7EDCC: 48000008  b 0x82a7edd4
	pc = 0x82A7EDD4; continue 'dispatch;
	// 82A7EDD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7EDD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7EDD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7EDDC: 409A0044  bne cr6, 0x82a7ee20
	if !ctx.cr[6].eq {
	pc = 0x82A7EE20; continue 'dispatch;
	}
	// 82A7EDE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A7EDE4: 419A001C  beq cr6, 0x82a7ee00
	if ctx.cr[6].eq {
	pc = 0x82A7EE00; continue 'dispatch;
	}
	// 82A7EDE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7EDEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A7EDF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7EDF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7EDF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A7EDFC: 4E800421  bctrl
	ctx.lr = 0x82A7EE00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7EE00: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A7EE04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A7EE08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7EE0C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A7EE10: 816B8DD0  lwz r11, -0x7230(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29232 as u32) ) } as u64;
	// 82A7EE14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A7EE18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A7EE1C: 4B8411E5  bl 0x822c0000
	ctx.lr = 0x82A7EE20;
	sub_822C0000(ctx, base);
	// 82A7EE20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7EE24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7EE28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7EE2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7EE30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7EE34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7EE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7EE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7EE40 size=196
    let mut pc: u32 = 0x82A7EE40;
    'dispatch: loop {
        match pc {
            0x82A7EE40 => {
    //   block [0x82A7EE40..0x82A7EF04)
	// 82A7EE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7EE44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7EE48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7EE4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7EE50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7EE54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A7EE58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7EE5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A7EE60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7EE64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7EE68: 4B841AD1  bl 0x822c0938
	ctx.lr = 0x82A7EE6C;
	sub_822C0938(ctx, base);
	// 82A7EE6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7EE70: 41820028  beq 0x82a7ee98
	if ctx.cr[0].eq {
	pc = 0x82A7EE98; continue 'dispatch;
	}
	// 82A7EE74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7EE78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A7EE7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A7EE80: 392B1790  addi r9, r11, 0x1790
	ctx.r[9].s64 = ctx.r[11].s64 + 6032;
	// 82A7EE84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A7EE88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A7EE8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A7EE90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A7EE94: 48000008  b 0x82a7ee9c
	pc = 0x82A7EE9C; continue 'dispatch;
	// 82A7EE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7EE9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7EEA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7EEA4: 409A0044  bne cr6, 0x82a7eee8
	if !ctx.cr[6].eq {
	pc = 0x82A7EEE8; continue 'dispatch;
	}
	// 82A7EEA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A7EEAC: 419A001C  beq cr6, 0x82a7eec8
	if ctx.cr[6].eq {
	pc = 0x82A7EEC8; continue 'dispatch;
	}
	// 82A7EEB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7EEB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A7EEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7EEBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7EEC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A7EEC4: 4E800421  bctrl
	ctx.lr = 0x82A7EEC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7EEC8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A7EECC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A7EED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7EED4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A7EED8: 816B8DD0  lwz r11, -0x7230(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29232 as u32) ) } as u64;
	// 82A7EEDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A7EEE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A7EEE4: 4B84111D  bl 0x822c0000
	ctx.lr = 0x82A7EEE8;
	sub_822C0000(ctx, base);
	// 82A7EEE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7EEEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7EEF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7EEF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7EEF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7EEFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7EF00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7EF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7EF08 size=180
    let mut pc: u32 = 0x82A7EF08;
    'dispatch: loop {
        match pc {
            0x82A7EF08 => {
    //   block [0x82A7EF08..0x82A7EFBC)
	// 82A7EF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7EF0C: 48729259  bl 0x831a8164
	ctx.lr = 0x82A7EF10;
	sub_831A8130(ctx, base);
	// 82A7EF10: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A7EF14: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7EF18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7EF1C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A7EF20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A7EF24: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A7EF28: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A7EF2C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82A7EF30: 4BA93401  bl 0x82512330
	ctx.lr = 0x82A7EF34;
	sub_82512330(ctx, base);
	// 82A7EF34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7EF38: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82A7EF3C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7EF40: 396B17BC  addi r11, r11, 0x17bc
	ctx.r[11].s64 = ctx.r[11].s64 + 6076;
	// 82A7EF44: 394A17A8  addi r10, r10, 0x17a8
	ctx.r[10].s64 = ctx.r[10].s64 + 6056;
	// 82A7EF48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A7EF4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7EF50: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A7EF54: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 82A7EF58: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82A7EF5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A7EF60: 48374AA9  bl 0x82df3a08
	ctx.lr = 0x82A7EF64;
	sub_82DF3A08(ctx, base);
	// 82A7EF64: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 82A7EF68: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A7EF6C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7EF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7EFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A7EFC0 size=8
    let mut pc: u32 = 0x82A7EFC0;
    'dispatch: loop {
        match pc {
            0x82A7EFC0 => {
    //   block [0x82A7EFC0..0x82A7EFC8)
	// 82A7EFC0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A7EFC4: 480001B4  b 0x82a7f178
	sub_82A7F178(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7EFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7EFC8 size=96
    let mut pc: u32 = 0x82A7EFC8;
    'dispatch: loop {
        match pc {
            0x82A7EFC8 => {
    //   block [0x82A7EFC8..0x82A7F028)
	// 82A7EFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7EFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7EFD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7EFD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7EFD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7EFDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7EFE0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7EFE4: 396B17BC  addi r11, r11, 0x17bc
	ctx.r[11].s64 = ctx.r[11].s64 + 6076;
	// 82A7EFE8: 394A17A8  addi r10, r10, 0x17a8
	ctx.r[10].s64 = ctx.r[10].s64 + 6056;
	// 82A7EFEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7EFF0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A7EFF4: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A7EFF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7EFFC: 419A0008  beq cr6, 0x82a7f004
	if ctx.cr[6].eq {
	pc = 0x82A7F004; continue 'dispatch;
	}
	// 82A7F000: 4B841891  bl 0x822c0890
	ctx.lr = 0x82A7F004;
	sub_822C0890(ctx, base);
	// 82A7F004: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 82A7F008: 48374421  bl 0x82df3428
	ctx.lr = 0x82A7F00C;
	sub_82DF3428(ctx, base);
	// 82A7F00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F010: 4B8D0341  bl 0x8234f350
	ctx.lr = 0x82A7F014;
	sub_8234F350(ctx, base);
	// 82A7F014: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A7F018: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F01C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F020: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F028 size=176
    let mut pc: u32 = 0x82A7F028;
    'dispatch: loop {
        match pc {
            0x82A7F028 => {
    //   block [0x82A7F028..0x82A7F0D8)
	// 82A7F028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F038: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F03C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F040: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7F044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F048: 4BA90481  bl 0x8250f4c8
	ctx.lr = 0x82A7F04C;
	sub_8250F4C8(ctx, base);
	// 82A7F04C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F050: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A7F054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F058: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A7F05C: 409A0008  bne cr6, 0x82a7f064
	if !ctx.cr[6].eq {
	pc = 0x82A7F064; continue 'dispatch;
	}
	// 82A7F060: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A7F064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F068: 4BA8B8E9  bl 0x8250a950
	ctx.lr = 0x82A7F06C;
	sub_8250A950(ctx, base);
	// 82A7F06C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7F070: 48372C21  bl 0x82df1c90
	ctx.lr = 0x82A7F074;
	sub_82DF1C90(ctx, base);
	// 82A7F074: 3BFF0114  addi r31, r31, 0x114
	ctx.r[31].s64 = ctx.r[31].s64 + 276;
	// 82A7F078: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F07C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F080: 419A0038  beq cr6, 0x82a7f0b8
	if ctx.cr[6].eq {
	pc = 0x82A7F0B8; continue 'dispatch;
	}
	// 82A7F084: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A7F088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F08C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A7F090: 409A0008  bne cr6, 0x82a7f098
	if !ctx.cr[6].eq {
	pc = 0x82A7F098; continue 'dispatch;
	}
	// 82A7F094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F09C: 4BD54965  bl 0x827d3a00
	ctx.lr = 0x82A7F0A0;
	sub_827D3A00(ctx, base);
	// 82A7F0A0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A7F0A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7F0A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F0AC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A7F0B0: 419A0008  beq cr6, 0x82a7f0b8
	if ctx.cr[6].eq {
	pc = 0x82A7F0B8; continue 'dispatch;
	}
	// 82A7F0B4: 4B8417DD  bl 0x822c0890
	ctx.lr = 0x82A7F0B8;
	sub_822C0890(ctx, base);
	// 82A7F0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F0BC: 48372BD5  bl 0x82df1c90
	ctx.lr = 0x82A7F0C0;
	sub_82DF1C90(ctx, base);
	// 82A7F0C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A7F0C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F0C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F0CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7F0D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F0D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F0D8 size=160
    let mut pc: u32 = 0x82A7F0D8;
    'dispatch: loop {
        match pc {
            0x82A7F0D8 => {
    //   block [0x82A7F0D8..0x82A7F178)
	// 82A7F0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F0DC: 48729089  bl 0x831a8164
	ctx.lr = 0x82A7F0E0;
	sub_831A8130(ctx, base);
	// 82A7F0E0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A7F0E4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F0E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7F0EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A7F0F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A7F0F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7F0F8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A7F0FC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A7F100: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A7F104: 388B1800  addi r4, r11, 0x1800
	ctx.r[4].s64 = ctx.r[11].s64 + 6144;
	// 82A7F108: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 82A7F10C: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 82A7F110: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A7F114: 483732D5  bl 0x82df23e8
	ctx.lr = 0x82A7F118;
	sub_82DF23E8(ctx, base);
	// 82A7F118: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7F11C: 41820024  beq 0x82a7f140
	if ctx.cr[0].eq {
	pc = 0x82A7F140; continue 'dispatch;
	}
	// 82A7F120: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A7F124: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A7F128: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A7F12C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A7F130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F134: 4BFFFDD5  bl 0x82a7ef08
	ctx.lr = 0x82A7F138;
	sub_82A7EF08(ctx, base);
	// 82A7F138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F13C: 48000008  b 0x82a7f144
	pc = 0x82A7F144; continue 'dispatch;
	// 82A7F140: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A7F144: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A7F148: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82A7F14C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F154: 4BFFFB5D  bl 0x82a7ecb0
	ctx.lr = 0x82A7F158;
	sub_82A7ECB0(ctx, base);
	// 82A7F158: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A7F15C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F164: 4B840E9D  bl 0x822c0000
	ctx.lr = 0x82A7F168;
	sub_822C0000(ctx, base);
	// 82A7F168: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A7F16C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A7F170: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A7F174: 48729040  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F178 size=76
    let mut pc: u32 = 0x82A7F178;
    'dispatch: loop {
        match pc {
            0x82A7F178 => {
    //   block [0x82A7F178..0x82A7F1C4)
	// 82A7F178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F17C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F18C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F190: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A7F194: 4BFFFE35  bl 0x82a7efc8
	ctx.lr = 0x82A7F198;
	sub_82A7EFC8(ctx, base);
	// 82A7F198: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7F19C: 4182000C  beq 0x82a7f1a8
	if ctx.cr[0].eq {
	pc = 0x82A7F1A8; continue 'dispatch;
	}
	// 82A7F1A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F1A4: 48373235  bl 0x82df23d8
	ctx.lr = 0x82A7F1A8;
	sub_82DF23D8(ctx, base);
	// 82A7F1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F1AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7F1B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F1B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F1B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7F1BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F1C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7F1C8 size=404
    let mut pc: u32 = 0x82A7F1C8;
    'dispatch: loop {
        match pc {
            0x82A7F1C8 => {
    //   block [0x82A7F1C8..0x82A7F35C)
	// 82A7F1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F1CC: 48728F99  bl 0x831a8164
	ctx.lr = 0x82A7F1D0;
	sub_831A8130(ctx, base);
	// 82A7F1D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F1D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A7F1D8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A7F1DC: 3BBE0114  addi r29, r30, 0x114
	ctx.r[29].s64 = ctx.r[30].s64 + 276;
	// 82A7F1E0: 807E0114  lwz r3, 0x114(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A7F1E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F1E8: 419A0018  beq cr6, 0x82a7f200
	if ctx.cr[6].eq {
	pc = 0x82A7F200; continue 'dispatch;
	}
	// 82A7F1EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F1F0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A7F1F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A7F1F8: 4E800421  bctrl
	ctx.lr = 0x82A7F1FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7F1FC: 48000158  b 0x82a7f354
	pc = 0x82A7F354; continue 'dispatch;
	// 82A7F200: 389E00F0  addi r4, r30, 0xf0
	ctx.r[4].s64 = ctx.r[30].s64 + 240;
	// 82A7F204: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A7F208: 483FCDD1  bl 0x82e7bfd8
	ctx.lr = 0x82A7F20C;
	sub_82E7BFD8(ctx, base);
	// 82A7F20C: 389E0100  addi r4, r30, 0x100
	ctx.r[4].s64 = ctx.r[30].s64 + 256;
	// 82A7F210: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A7F214: 483FD095  bl 0x82e7c2a8
	ctx.lr = 0x82A7F218;
	sub_82E7C2A8(ctx, base);
	// 82A7F218: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A7F21C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7F220: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82A7F224: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A7F228: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A7F22C: 388B1800  addi r4, r11, 0x1800
	ctx.r[4].s64 = ctx.r[11].s64 + 6144;
	// 82A7F230: 38A000C4  li r5, 0xc4
	ctx.r[5].s64 = 196;
	// 82A7F234: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A7F238: 483731B1  bl 0x82df23e8
	ctx.lr = 0x82A7F23C;
	sub_82DF23E8(ctx, base);
	// 82A7F23C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7F240: 41820014  beq 0x82a7f254
	if ctx.cr[0].eq {
	pc = 0x82A7F254; continue 'dispatch;
	}
	// 82A7F244: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A7F248: 48393EA9  bl 0x82e130f0
	ctx.lr = 0x82A7F24C;
	sub_82E130F0(ctx, base);
	// 82A7F24C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F250: 48000008  b 0x82a7f258
	pc = 0x82A7F258; continue 'dispatch;
	// 82A7F254: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A7F258: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A7F25C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A7F264: 4B861DB5  bl 0x822e1018
	ctx.lr = 0x82A7F268;
	sub_822E1018(ctx, base);
	// 82A7F268: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A7F26C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F270: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A7F274: 4B840D8D  bl 0x822c0000
	ctx.lr = 0x82A7F278;
	sub_822C0000(ctx, base);
	// 82A7F278: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A7F27C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A7F280: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A7F284: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A7F288: 4B8451D9  bl 0x822c4460
	ctx.lr = 0x82A7F28C;
	sub_822C4460(ctx, base);
	// 82A7F28C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A7F290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F294: 419A0008  beq cr6, 0x82a7f29c
	if ctx.cr[6].eq {
	pc = 0x82A7F29C; continue 'dispatch;
	}
	// 82A7F298: 4B8415F9  bl 0x822c0890
	ctx.lr = 0x82A7F29C;
	sub_822C0890(ctx, base);
	// 82A7F29C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A7F2A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A7F2A4: 4BA90225  bl 0x8250f4c8
	ctx.lr = 0x82A7F2A8;
	sub_8250F4C8(ctx, base);
	// 82A7F2A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F2AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F2B0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A7F2B4: 409A0008  bne cr6, 0x82a7f2bc
	if !ctx.cr[6].eq {
	pc = 0x82A7F2BC; continue 'dispatch;
	}
	// 82A7F2B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A7F2BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A7F2C0: 4BA8B691  bl 0x8250a950
	ctx.lr = 0x82A7F2C4;
	sub_8250A950(ctx, base);
	// 82A7F2C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A7F2C8: 483729C9  bl 0x82df1c90
	ctx.lr = 0x82A7F2CC;
	sub_82DF1C90(ctx, base);
	// 82A7F2CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A7F2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F2D4: 48374735  bl 0x82df3a08
	ctx.lr = 0x82A7F2D8;
	sub_82DF3A08(ctx, base);
	// 82A7F2D8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A7F2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F2E0: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82A7F2E4: 409A0008  bne cr6, 0x82a7f2ec
	if !ctx.cr[6].eq {
	pc = 0x82A7F2EC; continue 'dispatch;
	}
	// 82A7F2E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A7F2EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A7F2F0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A7F2F4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A7F2F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A7F2FC: 4BD559B5  bl 0x827d4cb0
	ctx.lr = 0x82A7F300;
	sub_827D4CB0(ctx, base);
	// 82A7F300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A7F304: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82A7F308: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A7F30C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F310: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7F314: 4B84514D  bl 0x822c4460
	ctx.lr = 0x82A7F318;
	sub_822C4460(ctx, base);
	// 82A7F318: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A7F31C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F320: 419A0008  beq cr6, 0x82a7f328
	if ctx.cr[6].eq {
	pc = 0x82A7F328; continue 'dispatch;
	}
	// 82A7F324: 4B84156D  bl 0x822c0890
	ctx.lr = 0x82A7F328;
	sub_822C0890(ctx, base);
	// 82A7F328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F32C: 483740FD  bl 0x82df3428
	ctx.lr = 0x82A7F330;
	sub_82DF3428(ctx, base);
	// 82A7F330: C03E0110  lfs f1, 0x110(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A7F334: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F338: 484021B9  bl 0x82e814f0
	ctx.lr = 0x82A7F33C;
	sub_82E814F0(ctx, base);
	// 82A7F33C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A7F340: 48372951  bl 0x82df1c90
	ctx.lr = 0x82A7F344;
	sub_82DF1C90(ctx, base);
	// 82A7F344: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A7F348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F34C: 419A0008  beq cr6, 0x82a7f354
	if ctx.cr[6].eq {
	pc = 0x82A7F354; continue 'dispatch;
	}
	// 82A7F350: 4B841541  bl 0x822c0890
	ctx.lr = 0x82A7F354;
	sub_822C0890(ctx, base);
	// 82A7F354: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A7F358: 48728E5C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F360 size=120
    let mut pc: u32 = 0x82A7F360;
    'dispatch: loop {
        match pc {
            0x82A7F360 => {
    //   block [0x82A7F360..0x82A7F3D8)
	// 82A7F360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F364: 48728E09  bl 0x831a816c
	ctx.lr = 0x82A7F368;
	sub_831A8130(ctx, base);
	// 82A7F368: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F36C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A7F370: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A7F374: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7F378: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A7F37C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A7F380: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A7F384: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A7F388: 48373061  bl 0x82df23e8
	ctx.lr = 0x82A7F38C;
	sub_82DF23E8(ctx, base);
	// 82A7F38C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7F390: 41820014  beq 0x82a7f3a4
	if ctx.cr[0].eq {
	pc = 0x82A7F3A4; continue 'dispatch;
	}
	// 82A7F394: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F398: 4803D001  bl 0x82abc398
	ctx.lr = 0x82A7F39C;
	sub_82ABC398(ctx, base);
	// 82A7F39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F3A0: 48000008  b 0x82a7f3a8
	pc = 0x82A7F3A8; continue 'dispatch;
	// 82A7F3A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A7F3A8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A7F3AC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A7F3B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F3B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F3B8: 4BFFF9C1  bl 0x82a7ed78
	ctx.lr = 0x82A7F3BC;
	sub_82A7ED78(ctx, base);
	// 82A7F3BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A7F3C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F3C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F3C8: 4B840C39  bl 0x822c0000
	ctx.lr = 0x82A7F3CC;
	sub_822C0000(ctx, base);
	// 82A7F3CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A7F3D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7F3D4: 48728DE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F3D8 size=120
    let mut pc: u32 = 0x82A7F3D8;
    'dispatch: loop {
        match pc {
            0x82A7F3D8 => {
    //   block [0x82A7F3D8..0x82A7F450)
	// 82A7F3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F3DC: 48728D91  bl 0x831a816c
	ctx.lr = 0x82A7F3E0;
	sub_831A8130(ctx, base);
	// 82A7F3E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F3E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A7F3E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A7F3EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7F3F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A7F3F4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A7F3F8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A7F3FC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A7F400: 48372FE9  bl 0x82df23e8
	ctx.lr = 0x82A7F404;
	sub_82DF23E8(ctx, base);
	// 82A7F404: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7F408: 41820014  beq 0x82a7f41c
	if ctx.cr[0].eq {
	pc = 0x82A7F41C; continue 'dispatch;
	}
	// 82A7F40C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F410: 4803CFD9  bl 0x82abc3e8
	ctx.lr = 0x82A7F414;
	sub_82ABC3E8(ctx, base);
	// 82A7F414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F418: 48000008  b 0x82a7f420
	pc = 0x82A7F420; continue 'dispatch;
	// 82A7F41C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A7F420: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A7F424: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A7F428: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F42C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F430: 4BFFFA11  bl 0x82a7ee40
	ctx.lr = 0x82A7F434;
	sub_82A7EE40(ctx, base);
	// 82A7F434: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A7F438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F43C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F440: 4B840BC1  bl 0x822c0000
	ctx.lr = 0x82A7F444;
	sub_822C0000(ctx, base);
	// 82A7F444: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A7F448: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7F44C: 48728D70  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7F450 size=268
    let mut pc: u32 = 0x82A7F450;
    'dispatch: loop {
        match pc {
            0x82A7F450 => {
    //   block [0x82A7F450..0x82A7F55C)
	// 82A7F450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F45C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F460: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F468: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A7F46C: 4BA9256D  bl 0x825119d8
	ctx.lr = 0x82A7F470;
	sub_825119D8(ctx, base);
	// 82A7F470: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A7F474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F478: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A7F47C: 4837458D  bl 0x82df3a08
	ctx.lr = 0x82A7F480;
	sub_82DF3A08(ctx, base);
	// 82A7F480: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A7F484: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A7F488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F48C: 4BA892F5  bl 0x82508780
	ctx.lr = 0x82A7F490;
	sub_82508780(ctx, base);
	// 82A7F490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F494: 48373F95  bl 0x82df3428
	ctx.lr = 0x82A7F498;
	sub_82DF3428(ctx, base);
	// 82A7F498: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A7F49C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A7F4A0: 409A0008  bne cr6, 0x82a7f4a8
	if !ctx.cr[6].eq {
	pc = 0x82A7F4A8; continue 'dispatch;
	}
	// 82A7F4A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A7F4A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F4AC: 4BA892F5  bl 0x825087a0
	ctx.lr = 0x82A7F4B0;
	sub_825087A0(ctx, base);
	// 82A7F4B0: 4BFE3F69  bl 0x82a63418
	ctx.lr = 0x82A7F4B4;
	sub_82A63418(ctx, base);
	// 82A7F4B4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A7F4B8: 4182008C  beq 0x82a7f544
	if ctx.cr[0].eq {
	pc = 0x82A7F544; continue 'dispatch;
	}
	// 82A7F4BC: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 82A7F4C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A7F4C4: 4BFFFE9D  bl 0x82a7f360
	ctx.lr = 0x82A7F4C8;
	sub_82A7F360(ctx, base);
	// 82A7F4C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F4CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A7F4D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7F4D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F4D8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A7F4DC: 419A0024  beq cr6, 0x82a7f500
	if ctx.cr[6].eq {
	pc = 0x82A7F500; continue 'dispatch;
	}
	// 82A7F4E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A7F4E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A7F4E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A7F4EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A7F4F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A7F4F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A7F4F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A7F4FC: 4082FFE8  bne 0x82a7f4e4
	if !ctx.cr[0].eq {
	pc = 0x82A7F4E4; continue 'dispatch;
	}
	// 82A7F500: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A7F504: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7F508: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A7F50C: 388A1800  addi r4, r10, 0x1800
	ctx.r[4].s64 = ctx.r[10].s64 + 6144;
	// 82A7F510: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A7F514: 38A00066  li r5, 0x66
	ctx.r[5].s64 = 102;
	// 82A7F518: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A7F51C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A7F520: 483D9521  bl 0x82e58a40
	ctx.lr = 0x82A7F524;
	sub_82E58A40(ctx, base);
	// 82A7F524: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A7F528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F52C: 419A0008  beq cr6, 0x82a7f534
	if ctx.cr[6].eq {
	pc = 0x82A7F534; continue 'dispatch;
	}
	// 82A7F530: 4B841361  bl 0x822c0890
	ctx.lr = 0x82A7F534;
	sub_822C0890(ctx, base);
	// 82A7F534: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A7F538: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F53C: 419A0008  beq cr6, 0x82a7f544
	if ctx.cr[6].eq {
	pc = 0x82A7F544; continue 'dispatch;
	}
	// 82A7F540: 4B841351  bl 0x822c0890
	ctx.lr = 0x82A7F544;
	sub_822C0890(ctx, base);
	// 82A7F544: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A7F548: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F54C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F550: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7F554: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7F560 size=196
    let mut pc: u32 = 0x82A7F560;
    'dispatch: loop {
        match pc {
            0x82A7F560 => {
    //   block [0x82A7F560..0x82A7F624)
	// 82A7F560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F56C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F570: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F578: 4BFE3EA1  bl 0x82a63418
	ctx.lr = 0x82A7F57C;
	sub_82A63418(ctx, base);
	// 82A7F57C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A7F580: 4182008C  beq 0x82a7f60c
	if ctx.cr[0].eq {
	pc = 0x82A7F60C; continue 'dispatch;
	}
	// 82A7F584: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 82A7F588: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7F58C: 4BFFFE4D  bl 0x82a7f3d8
	ctx.lr = 0x82A7F590;
	sub_82A7F3D8(ctx, base);
	// 82A7F590: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F594: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A7F598: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7F59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F5A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A7F5A4: 419A0024  beq cr6, 0x82a7f5c8
	if ctx.cr[6].eq {
	pc = 0x82A7F5C8; continue 'dispatch;
	}
	// 82A7F5A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A7F5AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A7F5B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A7F5B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A7F5B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A7F5BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A7F5C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A7F5C4: 4082FFE8  bne 0x82a7f5ac
	if !ctx.cr[0].eq {
	pc = 0x82A7F5AC; continue 'dispatch;
	}
	// 82A7F5C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A7F5CC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7F5D0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A7F5D4: 388A1800  addi r4, r10, 0x1800
	ctx.r[4].s64 = ctx.r[10].s64 + 6144;
	// 82A7F5D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A7F5DC: 38A0007B  li r5, 0x7b
	ctx.r[5].s64 = 123;
	// 82A7F5E0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A7F5E4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A7F5E8: 483D9459  bl 0x82e58a40
	ctx.lr = 0x82A7F5EC;
	sub_82E58A40(ctx, base);
	// 82A7F5EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A7F5F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F5F4: 419A0008  beq cr6, 0x82a7f5fc
	if ctx.cr[6].eq {
	pc = 0x82A7F5FC; continue 'dispatch;
	}
	// 82A7F5F8: 4B841299  bl 0x822c0890
	ctx.lr = 0x82A7F5FC;
	sub_822C0890(ctx, base);
	// 82A7F5FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A7F600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7F604: 419A0008  beq cr6, 0x82a7f60c
	if ctx.cr[6].eq {
	pc = 0x82A7F60C; continue 'dispatch;
	}
	// 82A7F608: 4B841289  bl 0x822c0890
	ctx.lr = 0x82A7F60C;
	sub_822C0890(ctx, base);
	// 82A7F60C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A7F610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7F61C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F628 size=120
    let mut pc: u32 = 0x82A7F628;
    'dispatch: loop {
        match pc {
            0x82A7F628 => {
    //   block [0x82A7F628..0x82A7F6A0)
	// 82A7F628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F62C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F630: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F634: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F63C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A7F640: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A7F644: 4198002C  blt cr6, 0x82a7f670
	if ctx.cr[6].lt {
	pc = 0x82A7F670; continue 'dispatch;
	}
	// 82A7F648: 409A0044  bne cr6, 0x82a7f68c
	if !ctx.cr[6].eq {
	pc = 0x82A7F68C; continue 'dispatch;
	}
	// 82A7F64C: 4BFFF5CD  bl 0x82a7ec18
	ctx.lr = 0x82A7F650;
	sub_82A7EC18(ctx, base);
	// 82A7F650: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A7F654: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A7F658: 409A0034  bne cr6, 0x82a7f68c
	if !ctx.cr[6].eq {
	pc = 0x82A7F68C; continue 'dispatch;
	}
	// 82A7F65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F660: 4BFFF9C9  bl 0x82a7f028
	ctx.lr = 0x82A7F664;
	sub_82A7F028(ctx, base);
	// 82A7F664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F668: 4BA90F69  bl 0x825105d0
	ctx.lr = 0x82A7F66C;
	sub_825105D0(ctx, base);
	// 82A7F66C: 48000020  b 0x82a7f68c
	pc = 0x82A7F68C; continue 'dispatch;
	// 82A7F670: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 82A7F674: 48373B3D  bl 0x82df31b0
	ctx.lr = 0x82A7F678;
	sub_82DF31B0(ctx, base);
	// 82A7F678: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A7F67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F680: 4BFFFB49  bl 0x82a7f1c8
	ctx.lr = 0x82A7F684;
	sub_82A7F1C8(ctx, base);
	// 82A7F684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A7F688: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A7F68C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A7F690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F6A0 size=60
    let mut pc: u32 = 0x82A7F6A0;
    'dispatch: loop {
        match pc {
            0x82A7F6A0 => {
    //   block [0x82A7F6A0..0x82A7F6DC)
	// 82A7F6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F6A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F6AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F6B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F6B4: 4BA929B5  bl 0x82512068
	ctx.lr = 0x82A7F6B8;
	sub_82512068(ctx, base);
	// 82A7F6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F6BC: 4BFFF96D  bl 0x82a7f028
	ctx.lr = 0x82A7F6C0;
	sub_82A7F028(ctx, base);
	// 82A7F6C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F6C4: 4BFFFE9D  bl 0x82a7f560
	ctx.lr = 0x82A7F6C8;
	sub_82A7F560(ctx, base);
	// 82A7F6C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A7F6CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F6D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F6D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A7F6E0 size=8
    let mut pc: u32 = 0x82A7F6E0;
    'dispatch: loop {
        match pc {
            0x82A7F6E0 => {
    //   block [0x82A7F6E0..0x82A7F6E8)
	// 82A7F6E0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A7F6E4: 480000CC  b 0x82a7f7b0
	sub_82A7F7B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7F6E8 size=196
    let mut pc: u32 = 0x82A7F6E8;
    'dispatch: loop {
        match pc {
            0x82A7F6E8 => {
    //   block [0x82A7F6E8..0x82A7F7AC)
	// 82A7F6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F6F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F6F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F6F8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A7F6FC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F704: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A7F708: 4BFFF801  bl 0x82a7ef08
	ctx.lr = 0x82A7F70C;
	sub_82A7EF08(ctx, base);
	// 82A7F70C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A7F710: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7F714: D3FF0124  stfs f31, 0x124(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82A7F718: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A7F71C: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A7F720: 39291884  addi r9, r9, 0x1884
	ctx.r[9].s64 = ctx.r[9].s64 + 6276;
	// 82A7F724: 39081870  addi r8, r8, 0x1870
	ctx.r[8].s64 = ctx.r[8].s64 + 6256;
	// 82A7F728: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7F72C: C1AA1868  lfs f13, 0x1868(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7F730: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A7F734: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A7F738: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82A7F73C: D1BF0128  stfs f13, 0x128(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82A7F740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F744: 4BA6B345  bl 0x824eaa88
	ctx.lr = 0x82A7F748;
	sub_824EAA88(ctx, base);
	// 82A7F748: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F74C: 4BA6A105  bl 0x824e9850
	ctx.lr = 0x82A7F750;
	sub_824E9850(ctx, base);
	// 82A7F750: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A7F754: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A7F758: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7F75C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A7F760: 41990008  bgt cr6, 0x82a7f768
	if ctx.cr[6].gt {
	pc = 0x82A7F768; continue 'dispatch;
	}
	// 82A7F764: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A7F768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F76C: 48372525  bl 0x82df1c90
	ctx.lr = 0x82A7F770;
	sub_82DF1C90(ctx, base);
	// 82A7F770: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7F774: 41820018  beq 0x82a7f78c
	if ctx.cr[0].eq {
	pc = 0x82A7F78C; continue 'dispatch;
	}
	// 82A7F778: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A7F77C: C1BF0128  lfs f13, 0x128(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7F780: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7F784: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A7F788: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82A7F78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F790: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A7F794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F79C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A7F7A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7F7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F7B0 size=100
    let mut pc: u32 = 0x82A7F7B0;
    'dispatch: loop {
        match pc {
            0x82A7F7B0 => {
    //   block [0x82A7F7B0..0x82A7F814)
	// 82A7F7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F7C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F7C8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7F7CC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7F7D0: 396B1884  addi r11, r11, 0x1884
	ctx.r[11].s64 = ctx.r[11].s64 + 6276;
	// 82A7F7D4: 394A1870  addi r10, r10, 0x1870
	ctx.r[10].s64 = ctx.r[10].s64 + 6256;
	// 82A7F7D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7F7DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A7F7E0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A7F7E4: 4BFFF7E5  bl 0x82a7efc8
	ctx.lr = 0x82A7F7E8;
	sub_82A7EFC8(ctx, base);
	// 82A7F7E8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7F7EC: 4182000C  beq 0x82a7f7f8
	if ctx.cr[0].eq {
	pc = 0x82A7F7F8; continue 'dispatch;
	}
	// 82A7F7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F7F4: 48372BE5  bl 0x82df23d8
	ctx.lr = 0x82A7F7F8;
	sub_82DF23D8(ctx, base);
	// 82A7F7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F7FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7F800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7F80C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7F818 size=196
    let mut pc: u32 = 0x82A7F818;
    'dispatch: loop {
        match pc {
            0x82A7F818 => {
    //   block [0x82A7F818..0x82A7F8DC)
	// 82A7F818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F82C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A7F830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7F834: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A7F838: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7F83C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7F840: 4B8410F9  bl 0x822c0938
	ctx.lr = 0x82A7F844;
	sub_822C0938(ctx, base);
	// 82A7F844: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7F848: 41820028  beq 0x82a7f870
	if ctx.cr[0].eq {
	pc = 0x82A7F870; continue 'dispatch;
	}
	// 82A7F84C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7F850: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A7F854: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A7F858: 392B18C8  addi r9, r11, 0x18c8
	ctx.r[9].s64 = ctx.r[11].s64 + 6344;
	// 82A7F85C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A7F860: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A7F864: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A7F868: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A7F86C: 48000008  b 0x82a7f874
	pc = 0x82A7F874; continue 'dispatch;
	// 82A7F870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7F874: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7F878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F87C: 409A0044  bne cr6, 0x82a7f8c0
	if !ctx.cr[6].eq {
	pc = 0x82A7F8C0; continue 'dispatch;
	}
	// 82A7F880: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A7F884: 419A001C  beq cr6, 0x82a7f8a0
	if ctx.cr[6].eq {
	pc = 0x82A7F8A0; continue 'dispatch;
	}
	// 82A7F888: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F88C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A7F890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7F894: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A7F89C: 4E800421  bctrl
	ctx.lr = 0x82A7F8A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7F8A0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A7F8A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A7F8A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7F8AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A7F8B0: 816B8F20  lwz r11, -0x70e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28896 as u32) ) } as u64;
	// 82A7F8B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A7F8B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A7F8BC: 4B840745  bl 0x822c0000
	ctx.lr = 0x82A7F8C0;
	sub_822C0000(ctx, base);
	// 82A7F8C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7F8C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7F8C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7F8CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7F8D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7F8D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7F8D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7F8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7F8E0 size=404
    let mut pc: u32 = 0x82A7F8E0;
    'dispatch: loop {
        match pc {
            0x82A7F8E0 => {
    //   block [0x82A7F8E0..0x82A7FA74)
	// 82A7F8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7F8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7F8E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7F8EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7F8F0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A7F8F4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A7F8F8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7F8FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7F900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7F904: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7F908: 4BA8FC11  bl 0x8250f518
	ctx.lr = 0x82A7F90C;
	sub_8250F518(ctx, base);
	// 82A7F90C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7F910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7F914: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A7F918: 409A0008  bne cr6, 0x82a7f920
	if !ctx.cr[6].eq {
	pc = 0x82A7F920; continue 'dispatch;
	}
	// 82A7F91C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A7F920: 4BAA8CB1  bl 0x825285d0
	ctx.lr = 0x82A7F924;
	sub_825285D0(ctx, base);
	// 82A7F924: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A7F928: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A7F92C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A7F930: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82A7F934: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7F938: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7F93C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A7F940: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7FA78 size=160
    let mut pc: u32 = 0x82A7FA78;
    'dispatch: loop {
        match pc {
            0x82A7FA78 => {
    //   block [0x82A7FA78..0x82A7FB18)
	// 82A7FA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FA7C: 487286E9  bl 0x831a8164
	ctx.lr = 0x82A7FA80;
	sub_831A8130(ctx, base);
	// 82A7FA80: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A7FA84: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FA88: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7FA8C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A7FA90: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A7FA94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7FA98: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A7FA9C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A7FAA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A7FAA4: 388B18D8  addi r4, r11, 0x18d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6360;
	// 82A7FAA8: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 82A7FAAC: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 82A7FAB0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A7FAB4: 48372935  bl 0x82df23e8
	ctx.lr = 0x82A7FAB8;
	sub_82DF23E8(ctx, base);
	// 82A7FAB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7FABC: 41820024  beq 0x82a7fae0
	if ctx.cr[0].eq {
	pc = 0x82A7FAE0; continue 'dispatch;
	}
	// 82A7FAC0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A7FAC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A7FAC8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A7FACC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A7FAD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7FAD4: 4BFFFC15  bl 0x82a7f6e8
	ctx.lr = 0x82A7FAD8;
	sub_82A7F6E8(ctx, base);
	// 82A7FAD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7FADC: 48000008  b 0x82a7fae4
	pc = 0x82A7FAE4; continue 'dispatch;
	// 82A7FAE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A7FAE4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A7FAE8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82A7FAEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7FAF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7FAF4: 4BFFFD25  bl 0x82a7f818
	ctx.lr = 0x82A7FAF8;
	sub_82A7F818(ctx, base);
	// 82A7FAF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A7FAFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7FB00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7FB04: 4B8404FD  bl 0x822c0000
	ctx.lr = 0x82A7FB08;
	sub_822C0000(ctx, base);
	// 82A7FB08: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A7FB0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A7FB10: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A7FB14: 487286A0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7FB18 size=296
    let mut pc: u32 = 0x82A7FB18;
    'dispatch: loop {
        match pc {
            0x82A7FB18 => {
    //   block [0x82A7FB18..0x82A7FC40)
	// 82A7FB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7FB20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7FB24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7FB28: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A7FB2C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7FB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7FB38: 4BA6AF51  bl 0x824eaa88
	ctx.lr = 0x82A7FB3C;
	sub_824EAA88(ctx, base);
	// 82A7FB3C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7FB40: 4BA69D11  bl 0x824e9850
	ctx.lr = 0x82A7FB44;
	sub_824E9850(ctx, base);
	// 82A7FB44: 3FC0820B  lis r30, -0x7df5
	ctx.r[30].s64 = -2113208320;
	// 82A7FB48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7FB4C: 397E1858  addi r11, r30, 0x1858
	ctx.r[11].s64 = ctx.r[30].s64 + 6232;
	// 82A7FB50: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7FB54: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A7FB58: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A7FB5C: 48372135  bl 0x82df1c90
	ctx.lr = 0x82A7FB60;
	sub_82DF1C90(ctx, base);
	// 82A7FB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FB64: 4BFFFD7D  bl 0x82a7f8e0
	ctx.lr = 0x82A7FB68;
	sub_82A7F8E0(ctx, base);
	// 82A7FB68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7FB6C: 4BA6AF1D  bl 0x824eaa88
	ctx.lr = 0x82A7FB70;
	sub_824EAA88(ctx, base);
	// 82A7FB70: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7FB74: 4BA69CDD  bl 0x824e9850
	ctx.lr = 0x82A7FB78;
	sub_824E9850(ctx, base);
	// 82A7FB78: C1BF0124  lfs f13, 0x124(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7FB7C: C01E1858  lfs f0, 0x1858(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(6232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7FB80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7FB84: EFE1037A  fmadds f31, f1, f13, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A7FB88: 48372109  bl 0x82df1c90
	ctx.lr = 0x82A7FB8C;
	sub_82DF1C90(ctx, base);
	// 82A7FB8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FB90: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A7FB94: 4BFFF055  bl 0x82a7ebe8
	ctx.lr = 0x82A7FB98;
	sub_82A7EBE8(ctx, base);
	// 82A7FB98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7FB9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A7FBA0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A7FBA4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A7FBA8: 4BA6AEE1  bl 0x824eaa88
	ctx.lr = 0x82A7FBAC;
	sub_824EAA88(ctx, base);
	// 82A7FBAC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7FBB0: 4BA69CA1  bl 0x824e9850
	ctx.lr = 0x82A7FBB4;
	sub_824E9850(ctx, base);
	// 82A7FBB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A7FBB8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7FBBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A7FBC0: C00BD200  lfs f0, -0x2e00(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7FBC4: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A7FBC8: C00AF774  lfs f0, -0x88c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7FBCC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A7FBD0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A7FBD4: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 82A7FBD8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A7FBDC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A7FBE0: 483720B1  bl 0x82df1c90
	ctx.lr = 0x82A7FBE4;
	sub_82DF1C90(ctx, base);
	// 82A7FBE4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A7FBE8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A7FBEC: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 82A7FBF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A7FBF4: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7FBF8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A7FBFC: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7FC00: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A7FC04: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A7FC08: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A7FC0C: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A7FC10: D161008C  stfs f11, 0x8c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A7FC14: 4802E72D  bl 0x82aae340
	ctx.lr = 0x82A7FC18;
	sub_82AAE340(ctx, base);
	// 82A7FC18: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A7FC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FC20: 4BFFEFD1  bl 0x82a7ebf0
	ctx.lr = 0x82A7FC24;
	sub_82A7EBF0(ctx, base);
	// 82A7FC24: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A7FC28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7FC2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7FC30: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A7FC34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7FC38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7FC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7FC40 size=200
    let mut pc: u32 = 0x82A7FC40;
    'dispatch: loop {
        match pc {
            0x82A7FC40 => {
    //   block [0x82A7FC40..0x82A7FD08)
	// 82A7FC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7FC48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7FC4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7FC50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FC54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7FC58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A7FC5C: 4BD6C505  bl 0x827ec160
	ctx.lr = 0x82A7FC60;
	sub_827EC160(ctx, base);
	// 82A7FC60: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82A7FC64: 41980078  blt cr6, 0x82a7fcdc
	if ctx.cr[6].lt {
	pc = 0x82A7FCDC; continue 'dispatch;
	}
	// 82A7FC68: 419A002C  beq cr6, 0x82a7fc94
	if ctx.cr[6].eq {
	pc = 0x82A7FC94; continue 'dispatch;
	}
	// 82A7FC6C: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82A7FC70: 40980080  bge cr6, 0x82a7fcf0
	if !ctx.cr[6].lt {
	pc = 0x82A7FCF0; continue 'dispatch;
	}
	// 82A7FC74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FC78: 4BFFEFA1  bl 0x82a7ec18
	ctx.lr = 0x82A7FC7C;
	sub_82A7EC18(ctx, base);
	// 82A7FC7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7FC80: 41820070  beq 0x82a7fcf0
	if ctx.cr[0].eq {
	pc = 0x82A7FCF0; continue 'dispatch;
	}
	// 82A7FC84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FC88: 4BFFF3A1  bl 0x82a7f028
	ctx.lr = 0x82A7FC8C;
	sub_82A7F028(ctx, base);
	// 82A7FC8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A7FC90: 48000058  b 0x82a7fce8
	pc = 0x82A7FCE8; continue 'dispatch;
	// 82A7FC94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A7FC98: C1BF0120  lfs f13, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7FC9C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7FCA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A7FCA4: 41990024  bgt cr6, 0x82a7fcc8
	if ctx.cr[6].gt {
	pc = 0x82A7FCC8; continue 'dispatch;
	}
	// 82A7FCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FCAC: 48058995  bl 0x82ad8640
	ctx.lr = 0x82A7FCB0;
	sub_82AD8640(ctx, base);
	// 82A7FCB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A7FCB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FCB8: 4BFFF511  bl 0x82a7f1c8
	ctx.lr = 0x82A7FCBC;
	sub_82A7F1C8(ctx, base);
	// 82A7FCBC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A7FCC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FCC4: 4BC1409D  bl 0x82693d60
	ctx.lr = 0x82A7FCC8;
	sub_82693D60(ctx, base);
	// 82A7FCC8: C01F0120  lfs f0, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A7FCCC: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7FCD0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A7FCD4: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A7FCD8: 48000018  b 0x82a7fcf0
	pc = 0x82A7FCF0; continue 'dispatch;
	// 82A7FCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FCE0: 4BFFFE39  bl 0x82a7fb18
	ctx.lr = 0x82A7FCE4;
	sub_82A7FB18(ctx, base);
	// 82A7FCE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A7FCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FCEC: 4BC14075  bl 0x82693d60
	ctx.lr = 0x82A7FCF0;
	sub_82693D60(ctx, base);
	// 82A7FCF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7FCF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7FCF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7FCFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7FD00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7FD04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7FD08 size=164
    let mut pc: u32 = 0x82A7FD08;
    'dispatch: loop {
        match pc {
            0x82A7FD08 => {
    //   block [0x82A7FD08..0x82A7FDAC)
	// 82A7FD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FD0C: 4872845D  bl 0x831a8168
	ctx.lr = 0x82A7FD10;
	sub_831A8130(ctx, base);
	// 82A7FD10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FD14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A7FD18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A7FD1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7FD20: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A7FD24: 41820038  beq 0x82a7fd5c
	if ctx.cr[0].eq {
	pc = 0x82A7FD5C; continue 'dispatch;
	}
	// 82A7FD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FD2C: 48729C5D  bl 0x831a9988
	ctx.lr = 0x82A7FD30;
	sub_831A9988(ctx, base);
	// 82A7FD30: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A7FD34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A7FD38: 386B6630  addi r3, r11, 0x6630
	ctx.r[3].s64 = ctx.r[11].s64 + 26160;
	// 82A7FD3C: 487283BD  bl 0x831a80f8
	ctx.lr = 0x82A7FD40;
	sub_831A80F8(ctx, base);
	// 82A7FD40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7FD44: 41820018  beq 0x82a7fd5c
	if ctx.cr[0].eq {
	pc = 0x82A7FD5C; continue 'dispatch;
	}
	// 82A7FD48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7FD4C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A7FD50: 4808CA51  bl 0x82b0c7a0
	ctx.lr = 0x82A7FD54;
	sub_82B0C7A0(ctx, base);
	// 82A7FD54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A7FD58: 4800004C  b 0x82a7fda4
	pc = 0x82A7FDA4; continue 'dispatch;
	// 82A7FD5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A7FD60: 409A0034  bne cr6, 0x82a7fd94
	if !ctx.cr[6].eq {
	pc = 0x82A7FD94; continue 'dispatch;
	}
	// 82A7FD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FD68: 48729C21  bl 0x831a9988
	ctx.lr = 0x82A7FD6C;
	sub_831A9988(ctx, base);
	// 82A7FD6C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A7FD70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A7FD74: 386B5A88  addi r3, r11, 0x5a88
	ctx.r[3].s64 = ctx.r[11].s64 + 23176;
	// 82A7FD78: 48728381  bl 0x831a80f8
	ctx.lr = 0x82A7FD7C;
	sub_831A80F8(ctx, base);
	// 82A7FD7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7FD80: 41820014  beq 0x82a7fd94
	if ctx.cr[0].eq {
	pc = 0x82A7FD94; continue 'dispatch;
	}
	// 82A7FD84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7FD88: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A7FD8C: 4BFE379D  bl 0x82a63528
	ctx.lr = 0x82A7FD90;
	sub_82A63528(ctx, base);
	// 82A7FD90: 4BFFFFC4  b 0x82a7fd54
	pc = 0x82A7FD54; continue 'dispatch;
	// 82A7FD94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A7FD98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7FD9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7FDA0: 4BA92879  bl 0x82512618
	ctx.lr = 0x82A7FDA4;
	sub_82512618(ctx, base);
	// 82A7FDA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A7FDA8: 48728410  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7FDB0 size=116
    let mut pc: u32 = 0x82A7FDB0;
    'dispatch: loop {
        match pc {
            0x82A7FDB0 => {
    //   block [0x82A7FDB0..0x82A7FE24)
	// 82A7FDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FDB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7FDB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7FDBC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FDC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7FDC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7FDC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7FDCC: 4BA8F6FD  bl 0x8250f4c8
	ctx.lr = 0x82A7FDD0;
	sub_8250F4C8(ctx, base);
	// 82A7FDD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7FDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7FDD8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A7FDDC: 409A0008  bne cr6, 0x82a7fde4
	if !ctx.cr[6].eq {
	pc = 0x82A7FDE4; continue 'dispatch;
	}
	// 82A7FDE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A7FDE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7FDE8: 4BA8AB69  bl 0x8250a950
	ctx.lr = 0x82A7FDEC;
	sub_8250A950(ctx, base);
	// 82A7FDEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7FDF0: 48371EA1  bl 0x82df1c90
	ctx.lr = 0x82A7FDF4;
	sub_82DF1C90(ctx, base);
	// 82A7FDF4: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A7FDF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A7FDFC: 419A000C  beq cr6, 0x82a7fe08
	if ctx.cr[6].eq {
	pc = 0x82A7FE08; continue 'dispatch;
	}
	// 82A7FE00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A7FE04: 4840193D  bl 0x82e81740
	ctx.lr = 0x82A7FE08;
	sub_82E81740(ctx, base);
	// 82A7FE08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A7FE0C: 48371E85  bl 0x82df1c90
	ctx.lr = 0x82A7FE10;
	sub_82DF1C90(ctx, base);
	// 82A7FE10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7FE14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7FE18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7FE1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7FE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7FE28 size=196
    let mut pc: u32 = 0x82A7FE28;
    'dispatch: loop {
        match pc {
            0x82A7FE28 => {
    //   block [0x82A7FE28..0x82A7FEEC)
	// 82A7FE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7FE30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7FE34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7FE38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FE3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A7FE40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7FE44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A7FE48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A7FE4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7FE50: 4B840AE9  bl 0x822c0938
	ctx.lr = 0x82A7FE54;
	sub_822C0938(ctx, base);
	// 82A7FE54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A7FE58: 41820028  beq 0x82a7fe80
	if ctx.cr[0].eq {
	pc = 0x82A7FE80; continue 'dispatch;
	}
	// 82A7FE5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7FE60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A7FE64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A7FE68: 392B198C  addi r9, r11, 0x198c
	ctx.r[9].s64 = ctx.r[11].s64 + 6540;
	// 82A7FE6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A7FE70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A7FE74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A7FE78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A7FE7C: 48000008  b 0x82a7fe84
	pc = 0x82A7FE84; continue 'dispatch;
	// 82A7FE80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7FE84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7FE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7FE8C: 409A0044  bne cr6, 0x82a7fed0
	if !ctx.cr[6].eq {
	pc = 0x82A7FED0; continue 'dispatch;
	}
	// 82A7FE90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A7FE94: 419A001C  beq cr6, 0x82a7feb0
	if ctx.cr[6].eq {
	pc = 0x82A7FEB0; continue 'dispatch;
	}
	// 82A7FE98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7FE9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A7FEA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7FEA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7FEA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A7FEAC: 4E800421  bctrl
	ctx.lr = 0x82A7FEB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7FEB0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A7FEB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A7FEB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A7FEBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A7FEC0: 816B8FCC  lwz r11, -0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28724 as u32) ) } as u64;
	// 82A7FEC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A7FEC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A7FECC: 4B840135  bl 0x822c0000
	ctx.lr = 0x82A7FED0;
	sub_822C0000(ctx, base);
	// 82A7FED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A7FED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7FED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7FEDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7FEE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7FEE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A7FEE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A7FEF0 size=216
    let mut pc: u32 = 0x82A7FEF0;
    'dispatch: loop {
        match pc {
            0x82A7FEF0 => {
    //   block [0x82A7FEF0..0x82A7FFC8)
	// 82A7FEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FEF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7FEF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A7FEFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7FF00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FF04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7FF08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A7FF0C: 4BA92425  bl 0x82512330
	ctx.lr = 0x82A7FF10;
	sub_82512330(ctx, base);
	// 82A7FF10: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A7FF14: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82A7FF18: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7FF1C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A7FF20: 390B6910  addi r8, r11, 0x6910
	ctx.r[8].s64 = ctx.r[11].s64 + 26896;
	// 82A7FF24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7FF28: 394A19B4  addi r10, r10, 0x19b4
	ctx.r[10].s64 = ctx.r[10].s64 + 6580;
	// 82A7FF2C: 392919A0  addi r9, r9, 0x19a0
	ctx.r[9].s64 = ctx.r[9].s64 + 6560;
	// 82A7FF30: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A7FF34: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A7FF38: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 82A7FF3C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A7FF40: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A7FFC8 size=8
    let mut pc: u32 = 0x82A7FFC8;
    'dispatch: loop {
        match pc {
            0x82A7FFC8 => {
    //   block [0x82A7FFC8..0x82A7FFD0)
	// 82A7FFC8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A7FFCC: 48000194  b 0x82a80160
	sub_82A80160(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A7FFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A7FFD0 size=104
    let mut pc: u32 = 0x82A7FFD0;
    'dispatch: loop {
        match pc {
            0x82A7FFD0 => {
    //   block [0x82A7FFD0..0x82A80038)
	// 82A7FFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7FFD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A7FFD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7FFDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7FFE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7FFE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A7FFE8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A7FFEC: 396B19B4  addi r11, r11, 0x19b4
	ctx.r[11].s64 = ctx.r[11].s64 + 6580;
	// 82A7FFF0: 394A19A0  addi r10, r10, 0x19a0
	ctx.r[10].s64 = ctx.r[10].s64 + 6560;
	// 82A7FFF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A7FFF8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A7FFFC: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82A80000: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80004: 419A0008  beq cr6, 0x82a8000c
	if ctx.cr[6].eq {
	pc = 0x82A8000C; continue 'dispatch;
	}
	// 82A80008: 4B840889  bl 0x822c0890
	ctx.lr = 0x82A8000C;
	sub_822C0890(ctx, base);
	// 82A8000C: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 82A80010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80014: 419A0008  beq cr6, 0x82a8001c
	if ctx.cr[6].eq {
	pc = 0x82A8001C; continue 'dispatch;
	}
	// 82A80018: 4B840879  bl 0x822c0890
	ctx.lr = 0x82A8001C;
	sub_822C0890(ctx, base);
	// 82A8001C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80020: 4B8CF331  bl 0x8234f350
	ctx.lr = 0x82A80024;
	sub_8234F350(ctx, base);
	// 82A80024: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A80028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8002C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A80030: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A80034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A80038 size=176
    let mut pc: u32 = 0x82A80038;
    'dispatch: loop {
        match pc {
            0x82A80038 => {
    //   block [0x82A80038..0x82A800E8)
	// 82A80038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8003C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A80044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80048: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8004C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A80050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A80054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A80058: 4BA8F471  bl 0x8250f4c8
	ctx.lr = 0x82A8005C;
	sub_8250F4C8(ctx, base);
	// 82A8005C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80060: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A80064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80068: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A8006C: 409A0008  bne cr6, 0x82a80074
	if !ctx.cr[6].eq {
	pc = 0x82A80074; continue 'dispatch;
	}
	// 82A80070: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A80074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A80078: 4BA8A8D9  bl 0x8250a950
	ctx.lr = 0x82A8007C;
	sub_8250A950(ctx, base);
	// 82A8007C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A80080: 48371C11  bl 0x82df1c90
	ctx.lr = 0x82A80084;
	sub_82DF1C90(ctx, base);
	// 82A80084: 3BFF0148  addi r31, r31, 0x148
	ctx.r[31].s64 = ctx.r[31].s64 + 328;
	// 82A80088: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8008C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80090: 419A0038  beq cr6, 0x82a800c8
	if ctx.cr[6].eq {
	pc = 0x82A800C8; continue 'dispatch;
	}
	// 82A80094: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A80098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8009C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A800A0: 409A0008  bne cr6, 0x82a800a8
	if !ctx.cr[6].eq {
	pc = 0x82A800A8; continue 'dispatch;
	}
	// 82A800A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A800A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A800AC: 4BD53955  bl 0x827d3a00
	ctx.lr = 0x82A800B0;
	sub_827D3A00(ctx, base);
	// 82A800B0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A800B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A800B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A800BC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A800C0: 419A0008  beq cr6, 0x82a800c8
	if ctx.cr[6].eq {
	pc = 0x82A800C8; continue 'dispatch;
	}
	// 82A800C4: 4B8407CD  bl 0x822c0890
	ctx.lr = 0x82A800C8;
	sub_822C0890(ctx, base);
	// 82A800C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A800CC: 48371BC5  bl 0x82df1c90
	ctx.lr = 0x82A800D0;
	sub_82DF1C90(ctx, base);
	// 82A800D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A800D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A800D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A800DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A800E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A800E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A800E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A800E8 size=120
    let mut pc: u32 = 0x82A800E8;
    'dispatch: loop {
        match pc {
            0x82A800E8 => {
    //   block [0x82A800E8..0x82A80160)
	// 82A800E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A800EC: 48728081  bl 0x831a816c
	ctx.lr = 0x82A800F0;
	sub_831A8130(ctx, base);
	// 82A800F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A800F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A800F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A800FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A80100: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A80104: 388B19F0  addi r4, r11, 0x19f0
	ctx.r[4].s64 = ctx.r[11].s64 + 6640;
	// 82A80108: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 82A8010C: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82A80110: 483722D9  bl 0x82df23e8
	ctx.lr = 0x82A80114;
	sub_82DF23E8(ctx, base);
	// 82A80114: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A80118: 41820014  beq 0x82a8012c
	if ctx.cr[0].eq {
	pc = 0x82A8012C; continue 'dispatch;
	}
	// 82A8011C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A80120: 4BFFFDD1  bl 0x82a7fef0
	ctx.lr = 0x82A80124;
	sub_82A7FEF0(ctx, base);
	// 82A80124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A80128: 48000008  b 0x82a80130
	pc = 0x82A80130; continue 'dispatch;
	// 82A8012C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A80130: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A80134: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A80138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A8013C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A80140: 4BFFFCE9  bl 0x82a7fe28
	ctx.lr = 0x82A80144;
	sub_82A7FE28(ctx, base);
	// 82A80144: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A80148: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A8014C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A80150: 4B83FEB1  bl 0x822c0000
	ctx.lr = 0x82A80154;
	sub_822C0000(ctx, base);
	// 82A80154: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A80158: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8015C: 48728060  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A80160 size=76
    let mut pc: u32 = 0x82A80160;
    'dispatch: loop {
        match pc {
            0x82A80160 => {
    //   block [0x82A80160..0x82A801AC)
	// 82A80160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8016C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80174: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A80178: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8017C: 4BFFFE55  bl 0x82a7ffd0
	ctx.lr = 0x82A80180;
	sub_82A7FFD0(ctx, base);
	// 82A80180: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A80184: 4182000C  beq 0x82a80190
	if ctx.cr[0].eq {
	pc = 0x82A80190; continue 'dispatch;
	}
	// 82A80188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8018C: 4837224D  bl 0x82df23d8
	ctx.lr = 0x82A80190;
	sub_82DF23D8(ctx, base);
	// 82A80190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80194: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A80198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8019C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A801A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A801A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A801A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A801B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A801B0 size=52
    let mut pc: u32 = 0x82A801B0;
    'dispatch: loop {
        match pc {
            0x82A801B0 => {
    //   block [0x82A801B0..0x82A801E4)
	// 82A801B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A801B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A801B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A801BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A801C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A801C4: 4BA91EA5  bl 0x82512068
	ctx.lr = 0x82A801C8;
	sub_82512068(ctx, base);
	// 82A801C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A801CC: 4BFFFE6D  bl 0x82a80038
	ctx.lr = 0x82A801D0;
	sub_82A80038(ctx, base);
	// 82A801D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A801D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A801D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A801DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A801E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A801E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A801E8 size=520
    let mut pc: u32 = 0x82A801E8;
    'dispatch: loop {
        match pc {
            0x82A801E8 => {
    //   block [0x82A801E8..0x82A803F0)
	// 82A801E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A801EC: 48727F7D  bl 0x831a8168
	ctx.lr = 0x82A801F0;
	sub_831A8130(ctx, base);
	// 82A801F0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A801F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A801F8: 3BBE0148  addi r29, r30, 0x148
	ctx.r[29].s64 = ctx.r[30].s64 + 328;
	// 82A801FC: 807E0148  lwz r3, 0x148(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A80200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80204: 419A0018  beq cr6, 0x82a8021c
	if ctx.cr[6].eq {
	pc = 0x82A8021C; continue 'dispatch;
	}
	// 82A80208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8020C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A80210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A80214: 4E800421  bctrl
	ctx.lr = 0x82A80218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A80218: 480001D0  b 0x82a803e8
	pc = 0x82A803E8; continue 'dispatch;
	// 82A8021C: 389E00F0  addi r4, r30, 0xf0
	ctx.r[4].s64 = ctx.r[30].s64 + 240;
	// 82A80220: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A80224: 483FBDB5  bl 0x82e7bfd8
	ctx.lr = 0x82A80228;
	sub_82E7BFD8(ctx, base);
	// 82A80228: 389E0100  addi r4, r30, 0x100
	ctx.r[4].s64 = ctx.r[30].s64 + 256;
	// 82A8022C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A80230: 483FC079  bl 0x82e7c2a8
	ctx.lr = 0x82A80234;
	sub_82E7C2A8(ctx, base);
	// 82A80234: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A80238: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A8023C: 388B19F0  addi r4, r11, 0x19f0
	ctx.r[4].s64 = ctx.r[11].s64 + 6640;
	// 82A80240: 38A00165  li r5, 0x165
	ctx.r[5].s64 = 357;
	// 82A80244: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A80248: 483721A1  bl 0x82df23e8
	ctx.lr = 0x82A8024C;
	sub_82DF23E8(ctx, base);
	// 82A8024C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A80250: 41820014  beq 0x82a80264
	if ctx.cr[0].eq {
	pc = 0x82A80264; continue 'dispatch;
	}
	// 82A80254: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A80258: 48392E99  bl 0x82e130f0
	ctx.lr = 0x82A8025C;
	sub_82E130F0(ctx, base);
	// 82A8025C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A80260: 48000008  b 0x82a80268
	pc = 0x82A80268; continue 'dispatch;
	// 82A80264: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A80268: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A8026C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A80270: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A80274: 4B860DA5  bl 0x822e1018
	ctx.lr = 0x82A80278;
	sub_822E1018(ctx, base);
	// 82A80278: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A8027C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A80280: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A80284: 4B83FD7D  bl 0x822c0000
	ctx.lr = 0x82A80288;
	sub_822C0000(ctx, base);
	// 82A80288: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8028C: 3BFE0140  addi r31, r30, 0x140
	ctx.r[31].s64 = ctx.r[30].s64 + 320;
	// 82A80290: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A80294: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A80298: 917E0140  stw r11, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82A8029C: 4B8441C5  bl 0x822c4460
	ctx.lr = 0x82A802A0;
	sub_822C4460(ctx, base);
	// 82A802A0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A802A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A802A8: 419A0008  beq cr6, 0x82a802b0
	if ctx.cr[6].eq {
	pc = 0x82A802B0; continue 'dispatch;
	}
	// 82A802AC: 4B8405E5  bl 0x822c0890
	ctx.lr = 0x82A802B0;
	sub_822C0890(ctx, base);
	// 82A802B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A802B4: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A802B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A802BC: 4BA91E5D  bl 0x82512118
	ctx.lr = 0x82A802C0;
	sub_82512118(ctx, base);
	// 82A802C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A802C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A802C8: 48392B69  bl 0x82e12e30
	ctx.lr = 0x82A802CC;
	sub_82E12E30(ctx, base);
	// 82A802CC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A802D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A802D4: 419A0008  beq cr6, 0x82a802dc
	if ctx.cr[6].eq {
	pc = 0x82A802DC; continue 'dispatch;
	}
	// 82A802D8: 4B8405B9  bl 0x822c0890
	ctx.lr = 0x82A802DC;
	sub_822C0890(ctx, base);
	// 82A802DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A802E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A802E4: 4BA8F1E5  bl 0x8250f4c8
	ctx.lr = 0x82A802E8;
	sub_8250F4C8(ctx, base);
	// 82A802E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A802EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A802F0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A802F4: 409A0008  bne cr6, 0x82a802fc
	if !ctx.cr[6].eq {
	pc = 0x82A802FC; continue 'dispatch;
	}
	// 82A802F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A802FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A80300: 4BA8A651  bl 0x8250a950
	ctx.lr = 0x82A80304;
	sub_8250A950(ctx, base);
	// 82A80304: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A80308: 48371989  bl 0x82df1c90
	ctx.lr = 0x82A8030C;
	sub_82DF1C90(ctx, base);
	// 82A8030C: 815E00E8  lwz r10, 0xe8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A80310: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A80314: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A80318: 396B8FC0  addi r11, r11, -0x7040
	ctx.r[11].s64 = ctx.r[11].s64 + -28736;
	// 82A8031C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A80320: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A80324: 483736E5  bl 0x82df3a08
	ctx.lr = 0x82A80328;
	sub_82DF3A08(ctx, base);
	// 82A80328: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8032C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80334: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A80338: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A8033C: 419A0024  beq cr6, 0x82a80360
	if ctx.cr[6].eq {
	pc = 0x82A80360; continue 'dispatch;
	}
	// 82A80340: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A80344: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A80348: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8034C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A80350: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A80354: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A80358: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8035C: 4082FFE8  bne 0x82a80344
	if !ctx.cr[0].eq {
	pc = 0x82A80344; continue 'dispatch;
	}
	// 82A80360: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A80364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80368: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82A8036C: 409A0008  bne cr6, 0x82a80374
	if !ctx.cr[6].eq {
	pc = 0x82A80374; continue 'dispatch;
	}
	// 82A80370: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A80374: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A80378: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A8037C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A80380: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A80384: 4BD5492D  bl 0x827d4cb0
	ctx.lr = 0x82A80388;
	sub_827D4CB0(ctx, base);
	// 82A80388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8038C: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82A80390: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A80394: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80398: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8039C: 4B8440C5  bl 0x822c4460
	ctx.lr = 0x82A803A0;
	sub_822C4460(ctx, base);
	// 82A803A0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A803A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A803A8: 419A0008  beq cr6, 0x82a803b0
	if ctx.cr[6].eq {
	pc = 0x82A803B0; continue 'dispatch;
	}
	// 82A803AC: 4B8404E5  bl 0x822c0890
	ctx.lr = 0x82A803B0;
	sub_822C0890(ctx, base);
	// 82A803B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A803B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A803B8: 419A0008  beq cr6, 0x82a803c0
	if ctx.cr[6].eq {
	pc = 0x82A803C0; continue 'dispatch;
	}
	// 82A803BC: 4B8404D5  bl 0x822c0890
	ctx.lr = 0x82A803C0;
	sub_822C0890(ctx, base);
	// 82A803C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A803C4: 48373065  bl 0x82df3428
	ctx.lr = 0x82A803C8;
	sub_82DF3428(ctx, base);
	// 82A803C8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A803CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A803D0: 419A0010  beq cr6, 0x82a803e0
	if ctx.cr[6].eq {
	pc = 0x82A803E0; continue 'dispatch;
	}
	// 82A803D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A803D8: C02B1980  lfs f1, 0x1980(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6528 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A803DC: 48401115  bl 0x82e814f0
	ctx.lr = 0x82A803E0;
	sub_82E814F0(ctx, base);
	// 82A803E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A803E4: 483718AD  bl 0x82df1c90
	ctx.lr = 0x82A803E8;
	sub_82DF1C90(ctx, base);
	// 82A803E8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A803EC: 48727DCC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A803F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A803F0 size=472
    let mut pc: u32 = 0x82A803F0;
    'dispatch: loop {
        match pc {
            0x82A803F0 => {
    //   block [0x82A803F0..0x82A805C8)
	// 82A803F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A803F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A803F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A803FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80400: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A805C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A805C8 size=560
    let mut pc: u32 = 0x82A805C8;
    'dispatch: loop {
        match pc {
            0x82A805C8 => {
    //   block [0x82A805C8..0x82A807F8)
	// 82A805C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A805CC: 48727B99  bl 0x831a8164
	ctx.lr = 0x82A805D0;
	sub_831A8130(ctx, base);
	// 82A805D0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A805D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A805D8: 817E00E4  lwz r11, 0xe4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A805DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A805E0: 41980108  blt cr6, 0x82a806e8
	if ctx.cr[6].lt {
	pc = 0x82A806E8; continue 'dispatch;
	}
	// 82A805E4: 409A020C  bne cr6, 0x82a807f0
	if !ctx.cr[6].eq {
	pc = 0x82A807F0; continue 'dispatch;
	}
	// 82A805E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A805EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A805F0: 4BD87E11  bl 0x82808400
	ctx.lr = 0x82A805F4;
	sub_82808400(ctx, base);
	// 82A805F4: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A805F8: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A805FC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A80600: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A80604: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82A80608: 419A0024  beq cr6, 0x82a8062c
	if ctx.cr[6].eq {
	pc = 0x82A8062C; continue 'dispatch;
	}
	// 82A8060C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82A80610: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A80614: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80618: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8061C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A80620: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A80624: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80628: 4082FFE8  bne 0x82a80610
	if !ctx.cr[0].eq {
	pc = 0x82A80610; continue 'dispatch;
	}
	// 82A8062C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A80630: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A80634: 4BA8EE95  bl 0x8250f4c8
	ctx.lr = 0x82A80638;
	sub_8250F4C8(ctx, base);
	// 82A80638: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8063C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80640: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A80644: 409A0008  bne cr6, 0x82a8064c
	if !ctx.cr[6].eq {
	pc = 0x82A8064C; continue 'dispatch;
	}
	// 82A80648: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A8064C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A80650: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82A80654: 4BA883C5  bl 0x82508a18
	ctx.lr = 0x82A80658;
	sub_82508A18(ctx, base);
	// 82A80658: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8065C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A80660: 388B19F0  addi r4, r11, 0x19f0
	ctx.r[4].s64 = ctx.r[11].s64 + 6640;
	// 82A80664: 38A00111  li r5, 0x111
	ctx.r[5].s64 = 273;
	// 82A80668: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A8066C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A80670: 483D6979  bl 0x82e56fe8
	ctx.lr = 0x82A80674;
	sub_82E56FE8(ctx, base);
	// 82A80674: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A80678: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A8067C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82A80680: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A80684: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A80688: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 82A8068C: 48371605  bl 0x82df1c90
	ctx.lr = 0x82A80690;
	sub_82DF1C90(ctx, base);
	// 82A80690: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A80694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80698: 419A0008  beq cr6, 0x82a806a0
	if ctx.cr[6].eq {
	pc = 0x82A806A0; continue 'dispatch;
	}
	// 82A8069C: 4B8401F5  bl 0x822c0890
	ctx.lr = 0x82A806A0;
	sub_822C0890(ctx, base);
	// 82A806A0: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A806A4: 41820008  beq 0x82a806ac
	if ctx.cr[0].eq {
	pc = 0x82A806AC; continue 'dispatch;
	}
	// 82A806A8: 8BBC0018  lbz r29, 0x18(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A806AC: 57BF063F  clrlwi. r31, r29, 0x18
	ctx.r[31].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A806B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A806B4: 4082000C  bne 0x82a806c0
	if !ctx.cr[0].eq {
	pc = 0x82A806C0; continue 'dispatch;
	}
	// 82A806B8: 4BFFF6F9  bl 0x82a7fdb0
	ctx.lr = 0x82A806BC;
	sub_82A7FDB0(ctx, base);
	// 82A806BC: 48000008  b 0x82a806c4
	pc = 0x82A806C4; continue 'dispatch;
	// 82A806C0: 4BFFFB29  bl 0x82a801e8
	ctx.lr = 0x82A806C4;
	sub_82A801E8(ctx, base);
	// 82A806C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A806C8: 419A000C  beq cr6, 0x82a806d4
	if ctx.cr[6].eq {
	pc = 0x82A806D4; continue 'dispatch;
	}
	// 82A806CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A806D0: 4BFFFD21  bl 0x82a803f0
	ctx.lr = 0x82A806D4;
	sub_82A803F0(ctx, base);
	// 82A806D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A806D8: 419A0118  beq cr6, 0x82a807f0
	if ctx.cr[6].eq {
	pc = 0x82A807F0; continue 'dispatch;
	}
	// 82A806DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A806E0: 4B8401B1  bl 0x822c0890
	ctx.lr = 0x82A806E4;
	sub_822C0890(ctx, base);
	// 82A806E4: 4800010C  b 0x82a807f0
	pc = 0x82A807F0; continue 'dispatch;
	// 82A806E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A806EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A806F0: 4BA8EE29  bl 0x8250f518
	ctx.lr = 0x82A806F4;
	sub_8250F518(ctx, base);
	// 82A806F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A806F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A806FC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A80700: 409A0008  bne cr6, 0x82a80708
	if !ctx.cr[6].eq {
	pc = 0x82A80708; continue 'dispatch;
	}
	// 82A80704: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A80708: 4BAA7E79  bl 0x82528580
	ctx.lr = 0x82A8070C;
	sub_82528580(ctx, base);
	// 82A8070C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A80710: 39400120  li r10, 0x120
	ctx.r[10].s64 = 288;
	// 82A80714: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A80718: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A807F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A807F8 size=216
    let mut pc: u32 = 0x82A807F8;
    'dispatch: loop {
        match pc {
            0x82A807F8 => {
    //   block [0x82A807F8..0x82A808D0)
	// 82A807F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A807FC: 4872796D  bl 0x831a8168
	ctx.lr = 0x82A80800;
	sub_831A8130(ctx, base);
	// 82A80800: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80804: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A80808: 4BFE8961  bl 0x82a69168
	ctx.lr = 0x82A8080C;
	sub_82A69168(ctx, base);
	// 82A8080C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A80810: 4082000C  bne 0x82a8081c
	if !ctx.cr[0].eq {
	pc = 0x82A8081C; continue 'dispatch;
	}
	// 82A80814: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A80818: 480000B0  b 0x82a808c8
	pc = 0x82A808C8; continue 'dispatch;
	// 82A8081C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A80820: 4B9ED2D1  bl 0x8246daf0
	ctx.lr = 0x82A80824;
	sub_8246DAF0(ctx, base);
	// 82A80824: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A80828: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A8082C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A80830: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A80834: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A80838: 419A0024  beq cr6, 0x82a8085c
	if ctx.cr[6].eq {
	pc = 0x82A8085C; continue 'dispatch;
	}
	// 82A8083C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A80840: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A80844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80848: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8084C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A80850: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A80854: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80858: 4082FFE8  bne 0x82a80840
	if !ctx.cr[0].eq {
	pc = 0x82A80840; continue 'dispatch;
	}
	// 82A8085C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A80860: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A80864: 388B19F0  addi r4, r11, 0x19f0
	ctx.r[4].s64 = ctx.r[11].s64 + 6640;
	// 82A80868: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A8086C: 38A00149  li r5, 0x149
	ctx.r[5].s64 = 329;
	// 82A80870: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82A80874: 483D6775  bl 0x82e56fe8
	ctx.lr = 0x82A80878;
	sub_82E56FE8(ctx, base);
	// 82A80878: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A8087C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A80880: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82A80884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80888: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A8088C: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A80890: 419A0008  beq cr6, 0x82a80898
	if ctx.cr[6].eq {
	pc = 0x82A80898; continue 'dispatch;
	}
	// 82A80894: 4B83FFFD  bl 0x822c0890
	ctx.lr = 0x82A80898;
	sub_822C0890(ctx, base);
	// 82A80898: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8089C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A808A0: 41820014  beq 0x82a808b4
	if ctx.cr[0].eq {
	pc = 0x82A808B4; continue 'dispatch;
	}
	// 82A808A4: 419AFF70  beq cr6, 0x82a80814
	if ctx.cr[6].eq {
	pc = 0x82A80814; continue 'dispatch;
	}
	// 82A808A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A808AC: 4B83FFE5  bl 0x822c0890
	ctx.lr = 0x82A808B0;
	sub_822C0890(ctx, base);
	// 82A808B0: 4BFFFF64  b 0x82a80814
	pc = 0x82A80814; continue 'dispatch;
	// 82A808B4: 83DC0018  lwz r30, 0x18(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A808B8: 419A000C  beq cr6, 0x82a808c4
	if ctx.cr[6].eq {
	pc = 0x82A808C4; continue 'dispatch;
	}
	// 82A808BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A808C0: 4B83FFD1  bl 0x822c0890
	ctx.lr = 0x82A808C4;
	sub_822C0890(ctx, base);
	// 82A808C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A808C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A808CC: 487278EC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A808D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A808D0 size=76
    let mut pc: u32 = 0x82A808D0;
    'dispatch: loop {
        match pc {
            0x82A808D0 => {
    //   block [0x82A808D0..0x82A8091C)
	// 82A808D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A808D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A808D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A808DC: 4BFFFF1D  bl 0x82a807f8
	ctx.lr = 0x82A808E0;
	sub_82A807F8(ctx, base);
	// 82A808E0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82A808E4: 419A0024  beq cr6, 0x82a80908
	if ctx.cr[6].eq {
	pc = 0x82A80908; continue 'dispatch;
	}
	// 82A808E8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82A808EC: 40990014  ble cr6, 0x82a80900
	if !ctx.cr[6].gt {
	pc = 0x82A80900; continue 'dispatch;
	}
	// 82A808F0: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 82A808F4: 40990014  ble cr6, 0x82a80908
	if !ctx.cr[6].gt {
	pc = 0x82A80908; continue 'dispatch;
	}
	// 82A808F8: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 82A808FC: 419A000C  beq cr6, 0x82a80908
	if ctx.cr[6].eq {
	pc = 0x82A80908; continue 'dispatch;
	}
	// 82A80900: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A80904: 48000008  b 0x82a8090c
	pc = 0x82A8090C; continue 'dispatch;
	// 82A80908: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A8090C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A80910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A80914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A80918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A80920 size=172
    let mut pc: u32 = 0x82A80920;
    'dispatch: loop {
        match pc {
            0x82A80920 => {
    //   block [0x82A80920..0x82A809CC)
	// 82A80920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8092C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A80934: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A80938: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A8093C: 41980030  blt cr6, 0x82a8096c
	if ctx.cr[6].lt {
	pc = 0x82A8096C; continue 'dispatch;
	}
	// 82A80940: 409A0078  bne cr6, 0x82a809b8
	if !ctx.cr[6].eq {
	pc = 0x82A809B8; continue 'dispatch;
	}
	// 82A80944: 4BFFFF8D  bl 0x82a808d0
	ctx.lr = 0x82A80948;
	sub_82A808D0(ctx, base);
	// 82A80948: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8094C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80950: 4182000C  beq 0x82a8095c
	if ctx.cr[0].eq {
	pc = 0x82A8095C; continue 'dispatch;
	}
	// 82A80954: 4BFFF45D  bl 0x82a7fdb0
	ctx.lr = 0x82A80958;
	sub_82A7FDB0(ctx, base);
	// 82A80958: 48000008  b 0x82a80960
	pc = 0x82A80960; continue 'dispatch;
	// 82A8095C: 4BFFF88D  bl 0x82a801e8
	ctx.lr = 0x82A80960;
	sub_82A801E8(ctx, base);
	// 82A80960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80964: 4BFFFA8D  bl 0x82a803f0
	ctx.lr = 0x82A80968;
	sub_82A803F0(ctx, base);
	// 82A80968: 48000050  b 0x82a809b8
	pc = 0x82A809B8; continue 'dispatch;
	// 82A8096C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A80970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A80974: 4BA8EBA5  bl 0x8250f518
	ctx.lr = 0x82A80978;
	sub_8250F518(ctx, base);
	// 82A80978: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8097C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80980: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A80984: 409A0008  bne cr6, 0x82a8098c
	if !ctx.cr[6].eq {
	pc = 0x82A8098C; continue 'dispatch;
	}
	// 82A80988: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A8098C: 4BAA7BF5  bl 0x82528580
	ctx.lr = 0x82A80990;
	sub_82528580(ctx, base);
	// 82A80990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A80994: 39400120  li r10, 0x120
	ctx.r[10].s64 = 288;
	// 82A80998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8099C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A809D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A809D0 size=172
    let mut pc: u32 = 0x82A809D0;
    'dispatch: loop {
        match pc {
            0x82A809D0 => {
    //   block [0x82A809D0..0x82A80A7C)
	// 82A809D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A809D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A809D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A809DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A809E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A809E4: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A809E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A809EC: 41980030  blt cr6, 0x82a80a1c
	if ctx.cr[6].lt {
	pc = 0x82A80A1C; continue 'dispatch;
	}
	// 82A809F0: 409A0078  bne cr6, 0x82a80a68
	if !ctx.cr[6].eq {
	pc = 0x82A80A68; continue 'dispatch;
	}
	// 82A809F4: 4BFFFEDD  bl 0x82a808d0
	ctx.lr = 0x82A809F8;
	sub_82A808D0(ctx, base);
	// 82A809F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A809FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80A00: 4082000C  bne 0x82a80a0c
	if !ctx.cr[0].eq {
	pc = 0x82A80A0C; continue 'dispatch;
	}
	// 82A80A04: 4BFFF3AD  bl 0x82a7fdb0
	ctx.lr = 0x82A80A08;
	sub_82A7FDB0(ctx, base);
	// 82A80A08: 48000008  b 0x82a80a10
	pc = 0x82A80A10; continue 'dispatch;
	// 82A80A0C: 4BFFF7DD  bl 0x82a801e8
	ctx.lr = 0x82A80A10;
	sub_82A801E8(ctx, base);
	// 82A80A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80A14: 4BFFF9DD  bl 0x82a803f0
	ctx.lr = 0x82A80A18;
	sub_82A803F0(ctx, base);
	// 82A80A18: 48000050  b 0x82a80a68
	pc = 0x82A80A68; continue 'dispatch;
	// 82A80A1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A80A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A80A24: 4BA8EAF5  bl 0x8250f518
	ctx.lr = 0x82A80A28;
	sub_8250F518(ctx, base);
	// 82A80A28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80A30: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A80A34: 409A0008  bne cr6, 0x82a80a3c
	if !ctx.cr[6].eq {
	pc = 0x82A80A3C; continue 'dispatch;
	}
	// 82A80A38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A80A3C: 4BAA7B45  bl 0x82528580
	ctx.lr = 0x82A80A40;
	sub_82528580(ctx, base);
	// 82A80A40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A80A44: 39400120  li r10, 0x120
	ctx.r[10].s64 = 288;
	// 82A80A48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A80A4C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A80A80 size=140
    let mut pc: u32 = 0x82A80A80;
    'dispatch: loop {
        match pc {
            0x82A80A80 => {
    //   block [0x82A80A80..0x82A80B0C)
	// 82A80A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A80A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80A94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A80A98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A80A9C: 4BA8FC6D  bl 0x82510708
	ctx.lr = 0x82A80AA0;
	sub_82510708(ctx, base);
	// 82A80AA0: 4BFDB799  bl 0x82a5c238
	ctx.lr = 0x82A80AA4;
	sub_82A5C238(ctx, base);
	// 82A80AA4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82A80AA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A80AAC: 41820048  beq 0x82a80af4
	if ctx.cr[0].eq {
	pc = 0x82A80AF4; continue 'dispatch;
	}
	// 82A80AB0: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A80AB4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A80AB8: 41980030  blt cr6, 0x82a80ae8
	if ctx.cr[6].lt {
	pc = 0x82A80AE8; continue 'dispatch;
	}
	// 82A80ABC: 419A001C  beq cr6, 0x82a80ad8
	if ctx.cr[6].eq {
	pc = 0x82A80AD8; continue 'dispatch;
	}
	// 82A80AC0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A80AC4: 40980030  bge cr6, 0x82a80af4
	if !ctx.cr[6].lt {
	pc = 0x82A80AF4; continue 'dispatch;
	}
	// 82A80AC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A80ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80AD0: 4BFFFAF9  bl 0x82a805c8
	ctx.lr = 0x82A80AD4;
	sub_82A805C8(ctx, base);
	// 82A80AD4: 48000020  b 0x82a80af4
	pc = 0x82A80AF4; continue 'dispatch;
	// 82A80AD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A80ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80AE0: 4BFFFEF1  bl 0x82a809d0
	ctx.lr = 0x82A80AE4;
	sub_82A809D0(ctx, base);
	// 82A80AE4: 48000010  b 0x82a80af4
	pc = 0x82A80AF4; continue 'dispatch;
	// 82A80AE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A80AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80AF0: 4BFFFE31  bl 0x82a80920
	ctx.lr = 0x82A80AF4;
	sub_82A80920(ctx, base);
	// 82A80AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A80AF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A80AFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A80B00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A80B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A80B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A80B10 size=360
    let mut pc: u32 = 0x82A80B10;
    'dispatch: loop {
        match pc {
            0x82A80B10 => {
    //   block [0x82A80B10..0x82A80C78)
	// 82A80B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80B18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80B1C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A80B20: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A80C78 size=236
    let mut pc: u32 = 0x82A80C78;
    'dispatch: loop {
        match pc {
            0x82A80C78 => {
    //   block [0x82A80C78..0x82A80D64)
	// 82A80C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A80C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80C88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80C8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A80C90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A80C94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A80C98: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80C9C: 4BA8E82D  bl 0x8250f4c8
	ctx.lr = 0x82A80CA0;
	sub_8250F4C8(ctx, base);
	// 82A80CA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80CA8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A80CAC: 409A0008  bne cr6, 0x82a80cb4
	if !ctx.cr[6].eq {
	pc = 0x82A80CB4; continue 'dispatch;
	}
	// 82A80CB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A80CB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A80CB8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80CBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A80CC0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A80CC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A80CC8: 480C61D9  bl 0x82b46ea0
	ctx.lr = 0x82A80CCC;
	sub_82B46EA0(ctx, base);
	// 82A80CCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A80CD0: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 82A80CD4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A80CD8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A80CDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80CE0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A80CE4: 4B84377D  bl 0x822c4460
	ctx.lr = 0x82A80CE8;
	sub_822C4460(ctx, base);
	// 82A80CE8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A80CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80CF0: 419A0008  beq cr6, 0x82a80cf8
	if ctx.cr[6].eq {
	pc = 0x82A80CF8; continue 'dispatch;
	}
	// 82A80CF4: 4B83FB9D  bl 0x822c0890
	ctx.lr = 0x82A80CF8;
	sub_822C0890(ctx, base);
	// 82A80CF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A80CFC: 48370F95  bl 0x82df1c90
	ctx.lr = 0x82A80D00;
	sub_82DF1C90(ctx, base);
	// 82A80D00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80D04: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A80D08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A80D0C: 419A0030  beq cr6, 0x82a80d3c
	if ctx.cr[6].eq {
	pc = 0x82A80D3C; continue 'dispatch;
	}
	// 82A80D10: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A80D14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80D18: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A80D1C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A80D20: 394A1D68  addi r10, r10, 0x1d68
	ctx.r[10].s64 = ctx.r[10].s64 + 7528;
	// 82A80D24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A80D28: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80D2C: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A80D30: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A80D38: 4E800421  bctrl
	ctx.lr = 0x82A80D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A80D3C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80D40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80D44: 419A0008  beq cr6, 0x82a80d4c
	if ctx.cr[6].eq {
	pc = 0x82A80D4C; continue 'dispatch;
	}
	// 82A80D48: 4B83FB49  bl 0x822c0890
	ctx.lr = 0x82A80D4C;
	sub_822C0890(ctx, base);
	// 82A80D4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A80D50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A80D54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A80D58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A80D5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A80D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A80D68 size=280
    let mut pc: u32 = 0x82A80D68;
    'dispatch: loop {
        match pc {
            0x82A80D68 => {
    //   block [0x82A80D68..0x82A80E80)
	// 82A80D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80D6C: 48727401  bl 0x831a816c
	ctx.lr = 0x82A80D70;
	sub_831A8130(ctx, base);
	// 82A80D70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80D74: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A80D78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A80D7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A80D80: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80D84: 4BA8E745  bl 0x8250f4c8
	ctx.lr = 0x82A80D88;
	sub_8250F4C8(ctx, base);
	// 82A80D88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80D90: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A80D94: 409A0008  bne cr6, 0x82a80d9c
	if !ctx.cr[6].eq {
	pc = 0x82A80D9C; continue 'dispatch;
	}
	// 82A80D98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A80D9C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A80DA0: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80DA4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A80DA8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A80DAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A80DB0: 480C60F1  bl 0x82b46ea0
	ctx.lr = 0x82A80DB4;
	sub_82B46EA0(ctx, base);
	// 82A80DB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A80DB8: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 82A80DBC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A80DC0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A80DC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80DC8: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A80DCC: 4B843695  bl 0x822c4460
	ctx.lr = 0x82A80DD0;
	sub_822C4460(ctx, base);
	// 82A80DD0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A80DD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80DD8: 419A0008  beq cr6, 0x82a80de0
	if ctx.cr[6].eq {
	pc = 0x82A80DE0; continue 'dispatch;
	}
	// 82A80DDC: 4B83FAB5  bl 0x822c0890
	ctx.lr = 0x82A80DE0;
	sub_822C0890(ctx, base);
	// 82A80DE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A80DE4: 48370EAD  bl 0x82df1c90
	ctx.lr = 0x82A80DE8;
	sub_82DF1C90(ctx, base);
	// 82A80DE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80DEC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A80DF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A80DF4: 419A0074  beq cr6, 0x82a80e68
	if ctx.cr[6].eq {
	pc = 0x82A80E68; continue 'dispatch;
	}
	// 82A80DF8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A80DFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80E00: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A80E04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A80E08: 394A1D68  addi r10, r10, 0x1d68
	ctx.r[10].s64 = ctx.r[10].s64 + 7528;
	// 82A80E0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A80E10: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80E14: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A80E18: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80E1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A80E20: 4E800421  bctrl
	ctx.lr = 0x82A80E24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A80E24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80E28: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80E30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A80E34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A80E38: 419A0024  beq cr6, 0x82a80e5c
	if ctx.cr[6].eq {
	pc = 0x82A80E5C; continue 'dispatch;
	}
	// 82A80E3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A80E40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A80E44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80E48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A80E4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A80E50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A80E54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80E58: 4082FFE8  bne 0x82a80e40
	if !ctx.cr[0].eq {
	pc = 0x82A80E40; continue 'dispatch;
	}
	// 82A80E5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A80E60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A80E64: 4BFFFCAD  bl 0x82a80b10
	ctx.lr = 0x82A80E68;
	sub_82A80B10(ctx, base);
	// 82A80E68: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80E6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80E70: 419A0008  beq cr6, 0x82a80e78
	if ctx.cr[6].eq {
	pc = 0x82A80E78; continue 'dispatch;
	}
	// 82A80E74: 4B83FA1D  bl 0x822c0890
	ctx.lr = 0x82A80E78;
	sub_822C0890(ctx, base);
	// 82A80E78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A80E7C: 48727340  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A80E80 size=184
    let mut pc: u32 = 0x82A80E80;
    'dispatch: loop {
        match pc {
            0x82A80E80 => {
    //   block [0x82A80E80..0x82A80F38)
	// 82A80E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80E88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80E8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80E90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A80E94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80E98: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A80E9C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A80EA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80EA4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A80EA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A80EAC: 419A0038  beq cr6, 0x82a80ee4
	if ctx.cr[6].eq {
	pc = 0x82A80EE4; continue 'dispatch;
	}
	// 82A80EB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80EB4: 419A0024  beq cr6, 0x82a80ed8
	if ctx.cr[6].eq {
	pc = 0x82A80ED8; continue 'dispatch;
	}
	// 82A80EB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A80EBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A80EC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80EC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A80EC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A80ECC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A80ED0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80ED4: 4082FFE8  bne 0x82a80ebc
	if !ctx.cr[0].eq {
	pc = 0x82A80EBC; continue 'dispatch;
	}
	// 82A80ED8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A80EDC: 4BFFFE8D  bl 0x82a80d68
	ctx.lr = 0x82A80EE0;
	sub_82A80D68(ctx, base);
	// 82A80EE0: 48000034  b 0x82a80f14
	pc = 0x82A80F14; continue 'dispatch;
	// 82A80EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A80EE8: 419A0024  beq cr6, 0x82a80f0c
	if ctx.cr[6].eq {
	pc = 0x82A80F0C; continue 'dispatch;
	}
	// 82A80EEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A80EF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A80EF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80EF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A80EFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A80F00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A80F04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A80F08: 4082FFE8  bne 0x82a80ef0
	if !ctx.cr[0].eq {
	pc = 0x82A80EF0; continue 'dispatch;
	}
	// 82A80F0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A80F10: 4BFFFD69  bl 0x82a80c78
	ctx.lr = 0x82A80F14;
	sub_82A80C78(ctx, base);
	// 82A80F14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A80F18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80F1C: 419A0008  beq cr6, 0x82a80f24
	if ctx.cr[6].eq {
	pc = 0x82A80F24; continue 'dispatch;
	}
	// 82A80F20: 4B83F971  bl 0x822c0890
	ctx.lr = 0x82A80F24;
	sub_822C0890(ctx, base);
	// 82A80F24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A80F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A80F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A80F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A80F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A80F38 size=88
    let mut pc: u32 = 0x82A80F38;
    'dispatch: loop {
        match pc {
            0x82A80F38 => {
    //   block [0x82A80F38..0x82A80F90)
	// 82A80F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A80F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80F48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A80F50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A80F54: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A80F58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A80F5C: 419A0008  beq cr6, 0x82a80f64
	if ctx.cr[6].eq {
	pc = 0x82A80F64; continue 'dispatch;
	}
	// 82A80F60: 4B83F931  bl 0x822c0890
	ctx.lr = 0x82A80F64;
	sub_822C0890(ctx, base);
	// 82A80F64: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A80F68: 4182000C  beq 0x82a80f74
	if ctx.cr[0].eq {
	pc = 0x82A80F74; continue 'dispatch;
	}
	// 82A80F6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80F70: 4B83F2F9  bl 0x822c0268
	ctx.lr = 0x82A80F74;
	sub_822C0268(ctx, base);
	// 82A80F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A80F78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A80F7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A80F80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A80F84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A80F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A80F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A80F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A80F90 size=188
    let mut pc: u32 = 0x82A80F90;
    'dispatch: loop {
        match pc {
            0x82A80F90 => {
    //   block [0x82A80F90..0x82A8104C)
	// 82A80F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A80F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A80F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A80F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A80FA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A80FA4: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82A80FA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A80FAC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A80FB0: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82A80FB4: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 82A80FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A80FBC: 4BE9DF0D  bl 0x8291eec8
	ctx.lr = 0x82A80FC0;
	sub_8291EEC8(ctx, base);
	// 82A80FC0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A80FC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A80FC8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A80FCC: 409A000C  bne cr6, 0x82a80fd8
	if !ctx.cr[6].eq {
	pc = 0x82A80FD8; continue 'dispatch;
	}
	// 82A80FD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A80FD4: 48000060  b 0x82a81034
	pc = 0x82A81034; continue 'dispatch;
	// 82A80FD8: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A80FDC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82A80FE0: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A80FE4: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81050 size=104
    let mut pc: u32 = 0x82A81050;
    'dispatch: loop {
        match pc {
            0x82A81050 => {
    //   block [0x82A81050..0x82A810B8)
	// 82A81050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81058: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8105C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A81064: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A81068: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8106C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A81070: 4800002C  b 0x82a8109c
	pc = 0x82A8109C; continue 'dispatch;
	// 82A81074: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A81078: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A8107C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A81080: 419A000C  beq cr6, 0x82a8108c
	if ctx.cr[6].eq {
	pc = 0x82A8108C; continue 'dispatch;
	}
	// 82A81084: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A81088: 480C5641  bl 0x82b466c8
	ctx.lr = 0x82A8108C;
	sub_82B466C8(ctx, base);
	// 82A8108C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A81090: 4B9205F9  bl 0x823a1688
	ctx.lr = 0x82A81094;
	sub_823A1688(ctx, base);
	// 82A81094: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A81098: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8109C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A810A0: 409AFFD4  bne cr6, 0x82a81074
	if !ctx.cr[6].eq {
	pc = 0x82A81074; continue 'dispatch;
	}
	// 82A810A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A810A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A810AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A810B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A810B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A810B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A810B8 size=120
    let mut pc: u32 = 0x82A810B8;
    'dispatch: loop {
        match pc {
            0x82A810B8 => {
    //   block [0x82A810B8..0x82A81130)
	// 82A810B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A810BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A810C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A810C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A810C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A810CC: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82A810D0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A810D4: 409A000C  bne cr6, 0x82a810e0
	if !ctx.cr[6].eq {
	pc = 0x82A810E0; continue 'dispatch;
	}
	// 82A810D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A810DC: 48000040  b 0x82a8111c
	pc = 0x82A8111C; continue 'dispatch;
	// 82A810E0: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82A810E4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82A810E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A810EC: 4BE9DDDD  bl 0x8291eec8
	ctx.lr = 0x82A810F0;
	sub_8291EEC8(ctx, base);
	// 82A810F0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A810F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A810F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A810FC: 419AFFDC  beq cr6, 0x82a810d8
	if ctx.cr[6].eq {
	pc = 0x82A810D8; continue 'dispatch;
	}
	// 82A81100: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A81104: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A81108: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A8110C: 419A000C  beq cr6, 0x82a81118
	if ctx.cr[6].eq {
	pc = 0x82A81118; continue 'dispatch;
	}
	// 82A81110: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A81114: 480C55B5  bl 0x82b466c8
	ctx.lr = 0x82A81118;
	sub_82B466C8(ctx, base);
	// 82A81118: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A8111C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8112C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81130 size=184
    let mut pc: u32 = 0x82A81130;
    'dispatch: loop {
        match pc {
            0x82A81130 => {
    //   block [0x82A81130..0x82A811E8)
	// 82A81130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81138: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8113C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81140: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81144: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8114C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A81150: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81154: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81158: 4B83F7E1  bl 0x822c0938
	ctx.lr = 0x82A8115C;
	sub_822C0938(ctx, base);
	// 82A8115C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A81160: 41820028  beq 0x82a81188
	if ctx.cr[0].eq {
	pc = 0x82A81188; continue 'dispatch;
	}
	// 82A81164: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81168: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8116C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A81170: 392B1DF8  addi r9, r11, 0x1df8
	ctx.r[9].s64 = ctx.r[11].s64 + 7672;
	// 82A81174: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A81178: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8117C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A81180: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A81184: 48000008  b 0x82a8118c
	pc = 0x82A8118C; continue 'dispatch;
	// 82A81188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8118C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A81194: 409A0038  bne cr6, 0x82a811cc
	if !ctx.cr[6].eq {
	pc = 0x82A811CC; continue 'dispatch;
	}
	// 82A81198: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A8119C: 419A0010  beq cr6, 0x82a811ac
	if ctx.cr[6].eq {
	pc = 0x82A811AC; continue 'dispatch;
	}
	// 82A811A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A811A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A811A8: 4BFFFD91  bl 0x82a80f38
	ctx.lr = 0x82A811AC;
	sub_82A80F38(ctx, base);
	// 82A811AC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A811B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A811B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A811B8: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A811BC: 816B906C  lwz r11, -0x6f94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28564 as u32) ) } as u64;
	// 82A811C0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A811C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A811C8: 4B83EE39  bl 0x822c0000
	ctx.lr = 0x82A811CC;
	sub_822C0000(ctx, base);
	// 82A811CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A811D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A811D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A811D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A811DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A811E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A811E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A811E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A811E8 size=12
    let mut pc: u32 = 0x82A811E8;
    'dispatch: loop {
        match pc {
            0x82A811E8 => {
    //   block [0x82A811E8..0x82A811F4)
	// 82A811E8: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A811EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A811F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A811F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A811F4 size=8
    let mut pc: u32 = 0x82A811F4;
    'dispatch: loop {
        match pc {
            0x82A811F4 => {
    //   block [0x82A811F4..0x82A811FC)
	// 82A811F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A811F8: 4BFFFD40  b 0x82a80f38
	sub_82A80F38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A811FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A811FC size=4
    let mut pc: u32 = 0x82A811FC;
    'dispatch: loop {
        match pc {
            0x82A811FC => {
    //   block [0x82A811FC..0x82A81200)
	// 82A811FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A81200 size=520
    let mut pc: u32 = 0x82A81200;
    'dispatch: loop {
        match pc {
            0x82A81200 => {
    //   block [0x82A81200..0x82A81408)
	// 82A81200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81204: 48726F59  bl 0x831a815c
	ctx.lr = 0x82A81208;
	sub_831A8130(ctx, base);
	// 82A81208: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82A8120C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A81210: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81214: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81218: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A8121C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A81220: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82A81224: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A81228: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A8122C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A81230: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A81234: 388B1E08  addi r4, r11, 0x1e08
	ctx.r[4].s64 = ctx.r[11].s64 + 7688;
	// 82A81238: 38A000C2  li r5, 0xc2
	ctx.r[5].s64 = 194;
	// 82A8123C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82A81240: 4B83F199  bl 0x822c03d8
	ctx.lr = 0x82A81244;
	sub_822C03D8(ctx, base);
	// 82A81244: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 82A81248: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8124C: 4182004C  beq 0x82a81298
	if ctx.cr[0].eq {
	pc = 0x82A81298; continue 'dispatch;
	}
	// 82A81250: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A81254: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81258: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82A8125C: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82A81260: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81264: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 82A81268: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A8126C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A81270: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81408 size=276
    let mut pc: u32 = 0x82A81408;
    'dispatch: loop {
        match pc {
            0x82A81408 => {
    //   block [0x82A81408..0x82A8151C)
	// 82A81408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8140C: 48726D5D  bl 0x831a8168
	ctx.lr = 0x82A81410;
	sub_831A8130(ctx, base);
	// 82A81410: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81414: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A81418: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A8141C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82A81420: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A81424: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82A81428: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A8142C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A81430: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81434: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A81438: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A8143C: 419A0094  beq cr6, 0x82a814d0
	if ctx.cr[6].eq {
	pc = 0x82A814D0; continue 'dispatch;
	}
	// 82A81440: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A81444: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A81448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8144C: 419A0068  beq cr6, 0x82a814b4
	if ctx.cr[6].eq {
	pc = 0x82A814B4; continue 'dispatch;
	}
	// 82A81450: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A81454: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A81458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8145C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A81460: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A81464: 419A0024  beq cr6, 0x82a81488
	if ctx.cr[6].eq {
	pc = 0x82A81488; continue 'dispatch;
	}
	// 82A81468: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A8146C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A81470: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A81474: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A81478: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A8147C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A81480: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A81484: 4082FFE8  bne 0x82a8146c
	if !ctx.cr[0].eq {
	pc = 0x82A8146C; continue 'dispatch;
	}
	// 82A81488: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A8148C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A81490: 4BFFF681  bl 0x82a80b10
	ctx.lr = 0x82A81494;
	sub_82A80B10(ctx, base);
	// 82A81494: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A81498: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A8149C: 480C56F5  bl 0x82b46b90
	ctx.lr = 0x82A814A0;
	sub_82B46B90(ctx, base);
	// 82A814A0: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82A814A4: 409A0010  bne cr6, 0x82a814b4
	if !ctx.cr[6].eq {
	pc = 0x82A814B4; continue 'dispatch;
	}
	// 82A814A8: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82A814AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A814B0: 4BA37C61  bl 0x824b9110
	ctx.lr = 0x82A814B4;
	sub_824B9110(ctx, base);
	// 82A814B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A814B8: 4B9201D1  bl 0x823a1688
	ctx.lr = 0x82A814BC;
	sub_823A1688(ctx, base);
	// 82A814BC: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A814C0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A814C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A814C8: 409AFF78  bne cr6, 0x82a81440
	if !ctx.cr[6].eq {
	pc = 0x82A81440; continue 'dispatch;
	}
	// 82A814CC: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A814D0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82A814D4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A814D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A814DC: 419A0030  beq cr6, 0x82a8150c
	if ctx.cr[6].eq {
	pc = 0x82A8150C; continue 'dispatch;
	}
	// 82A814E0: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A814E4: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A814E8: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A814EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A814F0: 4098001C  bge cr6, 0x82a8150c
	if !ctx.cr[6].lt {
	pc = 0x82A8150C; continue 'dispatch;
	}
	// 82A814F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A814F8: 387C000C  addi r3, r28, 0xc
	ctx.r[3].s64 = ctx.r[28].s64 + 12;
	// 82A814FC: 4BD9A1FD  bl 0x8281b6f8
	ctx.lr = 0x82A81500;
	sub_8281B6F8(ctx, base);
	// 82A81500: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A81504: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A81508: 4BFFFFD0  b 0x82a814d8
	pc = 0x82A814D8; continue 'dispatch;
	// 82A8150C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A81510: 4B9E8AF1  bl 0x8246a000
	ctx.lr = 0x82A81514;
	sub_8246A000(ctx, base);
	// 82A81514: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A81518: 48726CA0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81520 size=76
    let mut pc: u32 = 0x82A81520;
    'dispatch: loop {
        match pc {
            0x82A81520 => {
    //   block [0x82A81520..0x82A8156C)
	// 82A81520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8152C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A81534: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81538: 396B1E5C  addi r11, r11, 0x1e5c
	ctx.r[11].s64 = ctx.r[11].s64 + 7772;
	// 82A8153C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81540: 4BFFFB11  bl 0x82a81050
	ctx.lr = 0x82A81544;
	sub_82A81050(ctx, base);
	// 82A81544: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A81548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8154C: 4BB3122D  bl 0x825b2778
	ctx.lr = 0x82A81550;
	sub_825B2778(ctx, base);
	// 82A81550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81554: 4806BDA5  bl 0x82aed2f8
	ctx.lr = 0x82A81558;
	sub_82AED2F8(ctx, base);
	// 82A81558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A8155C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81570 size=76
    let mut pc: u32 = 0x82A81570;
    'dispatch: loop {
        match pc {
            0x82A81570 => {
    //   block [0x82A81570..0x82A815BC)
	// 82A81570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81578: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8157C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A81584: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81588: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A8158C: 396B1E5C  addi r11, r11, 0x1e5c
	ctx.r[11].s64 = ctx.r[11].s64 + 7772;
	// 82A81590: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82A81594: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A81598: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8159C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A815A0: 4BD1A659  bl 0x8279bbf8
	ctx.lr = 0x82A815A4;
	sub_8279BBF8(ctx, base);
	// 82A815A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A815A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A815AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A815B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A815B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A815B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A815C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A815C0 size=76
    let mut pc: u32 = 0x82A815C0;
    'dispatch: loop {
        match pc {
            0x82A815C0 => {
    //   block [0x82A815C0..0x82A8160C)
	// 82A815C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A815C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A815C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A815CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A815D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A815D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A815D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A815DC: 4BFFFF45  bl 0x82a81520
	ctx.lr = 0x82A815E0;
	sub_82A81520(ctx, base);
	// 82A815E0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A815E4: 4182000C  beq 0x82a815f0
	if ctx.cr[0].eq {
	pc = 0x82A815F0; continue 'dispatch;
	}
	// 82A815E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A815EC: 4B83EC7D  bl 0x822c0268
	ctx.lr = 0x82A815F0;
	sub_822C0268(ctx, base);
	// 82A815F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A815F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A815F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A815FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81600: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81604: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81610 size=12
    let mut pc: u32 = 0x82A81610;
    'dispatch: loop {
        match pc {
            0x82A81610 => {
    //   block [0x82A81610..0x82A8161C)
	// 82A81610: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A81614: 386BE0D8  addi r3, r11, -0x1f28
	ctx.r[3].s64 = ctx.r[11].s64 + -7976;
	// 82A81618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81620 size=64
    let mut pc: u32 = 0x82A81620;
    'dispatch: loop {
        match pc {
            0x82A81620 => {
    //   block [0x82A81620..0x82A81660)
	// 82A81620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81628: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8162C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81630: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A81634: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A81638: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82A8163C: 4BB09A65  bl 0x8258b0a0
	ctx.lr = 0x82A81640;
	sub_8258B0A0(ctx, base);
	// 82A81640: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A81644: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A81648: 4BA8DD71  bl 0x8250f3b8
	ctx.lr = 0x82A8164C;
	sub_8250F3B8(ctx, base);
	// 82A8164C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A81650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8165C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81660 size=8
    let mut pc: u32 = 0x82A81660;
    'dispatch: loop {
        match pc {
            0x82A81660 => {
    //   block [0x82A81660..0x82A81668)
	// 82A81660: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82A81664: 4BA8E3EC  b 0x8250fa50
	sub_8250FA50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81668 size=64
    let mut pc: u32 = 0x82A81668;
    'dispatch: loop {
        match pc {
            0x82A81668 => {
    //   block [0x82A81668..0x82A816A8)
	// 82A81668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8166C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81674: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8167C: 4BE876AD  bl 0x82908d28
	ctx.lr = 0x82A81680;
	sub_82908D28(ctx, base);
	// 82A81680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81684: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A81688: 4BD6ABE9  bl 0x827ec270
	ctx.lr = 0x82A8168C;
	sub_827EC270(ctx, base);
	// 82A8168C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81690: 4BA8EF41  bl 0x825105d0
	ctx.lr = 0x82A81694;
	sub_825105D0(ctx, base);
	// 82A81694: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A81698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8169C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A816A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A816A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816A8 size=8
    let mut pc: u32 = 0x82A816A8;
    'dispatch: loop {
        match pc {
            0x82A816A8 => {
    //   block [0x82A816A8..0x82A816B0)
	// 82A816A8: 386303E8  addi r3, r3, 0x3e8
	ctx.r[3].s64 = ctx.r[3].s64 + 1000;
	// 82A816AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816B0 size=8
    let mut pc: u32 = 0x82A816B0;
    'dispatch: loop {
        match pc {
            0x82A816B0 => {
    //   block [0x82A816B0..0x82A816B8)
	// 82A816B0: 386303EC  addi r3, r3, 0x3ec
	ctx.r[3].s64 = ctx.r[3].s64 + 1004;
	// 82A816B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816B8 size=8
    let mut pc: u32 = 0x82A816B8;
    'dispatch: loop {
        match pc {
            0x82A816B8 => {
    //   block [0x82A816B8..0x82A816C0)
	// 82A816B8: 80630408  lwz r3, 0x408(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82A816BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816C0 size=8
    let mut pc: u32 = 0x82A816C0;
    'dispatch: loop {
        match pc {
            0x82A816C0 => {
    //   block [0x82A816C0..0x82A816C8)
	// 82A816C0: 90830408  stw r4, 0x408(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1032 as u32), ctx.r[4].u32 ) };
	// 82A816C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816C8 size=8
    let mut pc: u32 = 0x82A816C8;
    'dispatch: loop {
        match pc {
            0x82A816C8 => {
    //   block [0x82A816C8..0x82A816D0)
	// 82A816C8: 90830414  stw r4, 0x414(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1044 as u32), ctx.r[4].u32 ) };
	// 82A816CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816D0 size=8
    let mut pc: u32 = 0x82A816D0;
    'dispatch: loop {
        match pc {
            0x82A816D0 => {
    //   block [0x82A816D0..0x82A816D8)
	// 82A816D0: 80630414  lwz r3, 0x414(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82A816D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816D8 size=8
    let mut pc: u32 = 0x82A816D8;
    'dispatch: loop {
        match pc {
            0x82A816D8 => {
    //   block [0x82A816D8..0x82A816E0)
	// 82A816D8: 90830418  stw r4, 0x418(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1048 as u32), ctx.r[4].u32 ) };
	// 82A816DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816E0 size=8
    let mut pc: u32 = 0x82A816E0;
    'dispatch: loop {
        match pc {
            0x82A816E0 => {
    //   block [0x82A816E0..0x82A816E8)
	// 82A816E0: 80630418  lwz r3, 0x418(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1048 as u32) ) } as u64;
	// 82A816E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816E8 size=8
    let mut pc: u32 = 0x82A816E8;
    'dispatch: loop {
        match pc {
            0x82A816E8 => {
    //   block [0x82A816E8..0x82A816F0)
	// 82A816E8: 8063041C  lwz r3, 0x41c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1052 as u32) ) } as u64;
	// 82A816EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816F0 size=8
    let mut pc: u32 = 0x82A816F0;
    'dispatch: loop {
        match pc {
            0x82A816F0 => {
    //   block [0x82A816F0..0x82A816F8)
	// 82A816F0: 90830420  stw r4, 0x420(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1056 as u32), ctx.r[4].u32 ) };
	// 82A816F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A816F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A816F8 size=8
    let mut pc: u32 = 0x82A816F8;
    'dispatch: loop {
        match pc {
            0x82A816F8 => {
    //   block [0x82A816F8..0x82A81700)
	// 82A816F8: 80630420  lwz r3, 0x420(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1056 as u32) ) } as u64;
	// 82A816FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81700 size=8
    let mut pc: u32 = 0x82A81700;
    'dispatch: loop {
        match pc {
            0x82A81700 => {
    //   block [0x82A81700..0x82A81708)
	// 82A81700: 80630424  lwz r3, 0x424(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1060 as u32) ) } as u64;
	// 82A81704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A81708 size=8
    let mut pc: u32 = 0x82A81708;
    'dispatch: loop {
        match pc {
            0x82A81708 => {
    //   block [0x82A81708..0x82A81710)
	// 82A81708: C023040C  lfs f1, 0x40c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1036 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A8170C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A81710 size=16
    let mut pc: u32 = 0x82A81710;
    'dispatch: loop {
        match pc {
            0x82A81710 => {
    //   block [0x82A81710..0x82A81720)
	// 82A81710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A81714: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A81718: D003040C  stfs f0, 0x40c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82A8171C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A81720 size=104
    let mut pc: u32 = 0x82A81720;
    'dispatch: loop {
        match pc {
            0x82A81720 => {
    //   block [0x82A81720..0x82A81788)
	// 82A81720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81728: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8172C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A81730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81734: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A81738: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A8173C: 4BE8771D  bl 0x82908e58
	ctx.lr = 0x82A81740;
	sub_82908E58(ctx, base);
	// 82A81740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81744: EC21F828  fsubs f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A81748: 4BE87E21  bl 0x82909568
	ctx.lr = 0x82A8174C;
	sub_82909568(ctx, base);
	// 82A8174C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81750: 4BE87709  bl 0x82908e58
	ctx.lr = 0x82A81754;
	sub_82908E58(ctx, base);
	// 82A81754: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A81758: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A8175C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A81760: 40980010  bge cr6, 0x82a81770
	if !ctx.cr[6].lt {
	pc = 0x82A81770; continue 'dispatch;
	}
	// 82A81764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81768: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82A8176C: 4BE87DFD  bl 0x82909568
	ctx.lr = 0x82A81770;
	sub_82909568(ctx, base);
	// 82A81770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8177C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81780: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81788 size=232
    let mut pc: u32 = 0x82A81788;
    'dispatch: loop {
        match pc {
            0x82A81788 => {
    //   block [0x82A81788..0x82A81870)
	// 82A81788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8178C: 487269D9  bl 0x831a8164
	ctx.lr = 0x82A81790;
	sub_831A8130(ctx, base);
	// 82A81790: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81794: 3863010C  addi r3, r3, 0x10c
	ctx.r[3].s64 = ctx.r[3].s64 + 268;
	// 82A81798: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A8179C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A817A0: 483D8F31  bl 0x82e5a6d0
	ctx.lr = 0x82A817A4;
	sub_82E5A6D0(ctx, base);
	// 82A817A4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A817A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A817AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A817B0: 808BC9E0  lwz r4, -0x3620(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13856 as u32) ) } as u64;
	// 82A817B4: 48372255  bl 0x82df3a08
	ctx.lr = 0x82A817B8;
	sub_82DF3A08(ctx, base);
	// 82A817B8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A817BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A817C0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A817C4: 48371B45  bl 0x82df3308
	ctx.lr = 0x82A817C8;
	sub_82DF3308(ctx, base);
	// 82A817C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A817CC: 40820030  bne 0x82a817fc
	if !ctx.cr[0].eq {
	pc = 0x82A817FC; continue 'dispatch;
	}
	// 82A817D0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A817D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A817D8: 808BC9E8  lwz r4, -0x3618(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13848 as u32) ) } as u64;
	// 82A817DC: 4837222D  bl 0x82df3a08
	ctx.lr = 0x82A817E0;
	sub_82DF3A08(ctx, base);
	// 82A817E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A817E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A817E8: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 82A817EC: 48371B1D  bl 0x82df3308
	ctx.lr = 0x82A817F0;
	sub_82DF3308(ctx, base);
	// 82A817F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A817F4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82A817F8: 41820008  beq 0x82a81800
	if ctx.cr[0].eq {
	pc = 0x82A81800; continue 'dispatch;
	}
	// 82A817FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A81800: 57EA07BD  rlwinm. r10, r31, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A81804: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A81808: 41820010  beq 0x82a81818
	if ctx.cr[0].eq {
	pc = 0x82A81818; continue 'dispatch;
	}
	// 82A8180C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A81810: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82A81814: 48371C15  bl 0x82df3428
	ctx.lr = 0x82A81818;
	sub_82DF3428(ctx, base);
	// 82A81818: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8181C: 4182000C  beq 0x82a81828
	if ctx.cr[0].eq {
	pc = 0x82A81828; continue 'dispatch;
	}
	// 82A81820: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A81824: 48371C05  bl 0x82df3428
	ctx.lr = 0x82A81828;
	sub_82DF3428(ctx, base);
	// 82A81828: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8182C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81830: 41820010  beq 0x82a81840
	if ctx.cr[0].eq {
	pc = 0x82A81840; continue 'dispatch;
	}
	// 82A81834: 9B7C0000  stb r27, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 82A81838: 806BC9E4  lwz r3, -0x361c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13852 as u32) ) } as u64;
	// 82A8183C: 4800002C  b 0x82a81868
	pc = 0x82A81868; continue 'dispatch;
	// 82A81840: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A81844: 808BC9E4  lwz r4, -0x361c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13852 as u32) ) } as u64;
	// 82A81848: 483721C1  bl 0x82df3a08
	ctx.lr = 0x82A8184C;
	sub_82DF3A08(ctx, base);
	// 82A8184C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A81850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A81854: 48371A4D  bl 0x82df32a0
	ctx.lr = 0x82A81858;
	sub_82DF32A0(ctx, base);
	// 82A81858: 987C0000  stb r3, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 82A8185C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A81860: 48371BC9  bl 0x82df3428
	ctx.lr = 0x82A81864;
	sub_82DF3428(ctx, base);
	// 82A81864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A81868: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A8186C: 48726948  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A81870 size=76
    let mut pc: u32 = 0x82A81870;
    'dispatch: loop {
        match pc {
            0x82A81870 => {
    //   block [0x82A81870..0x82A818BC)
	// 82A81870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81878: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8187C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81884: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 82A81888: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8188C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81890: 4BE875D1  bl 0x82908e60
	ctx.lr = 0x82A81894;
	sub_82908E60(ctx, base);
	// 82A81894: D03E001C  stfs f1, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A81898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8189C: 4BE875BD  bl 0x82908e58
	ctx.lr = 0x82A818A0;
	sub_82908E58(ctx, base);
	// 82A818A0: D03E0018  stfs f1, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A818A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A818A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A818AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A818B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A818B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A818B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A818C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A818C0 size=116
    let mut pc: u32 = 0x82A818C0;
    'dispatch: loop {
        match pc {
            0x82A818C0 => {
    //   block [0x82A818C0..0x82A81934)
	// 82A818C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A818C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A818C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A818CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A818D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A818D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A818D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A818DC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A818E0: 409A000C  bne cr6, 0x82a818ec
	if !ctx.cr[6].eq {
	pc = 0x82A818EC; continue 'dispatch;
	}
	// 82A818E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A818E8: 48000030  b 0x82a81918
	pc = 0x82A81918; continue 'dispatch;
	// 82A818EC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A818F0: 419A0024  beq cr6, 0x82a81914
	if ctx.cr[6].eq {
	pc = 0x82A81914; continue 'dispatch;
	}
	// 82A818F4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A818F8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A818FC: 388B9538  addi r4, r11, -0x6ac8
	ctx.r[4].s64 = ctx.r[11].s64 + -27336;
	// 82A81900: 487267F9  bl 0x831a80f8
	ctx.lr = 0x82A81904;
	sub_831A80F8(ctx, base);
	// 82A81904: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A81908: 4182000C  beq 0x82a81914
	if ctx.cr[0].eq {
	pc = 0x82A81914; continue 'dispatch;
	}
	// 82A8190C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A81910: 4800000C  b 0x82a8191c
	pc = 0x82A8191C; continue 'dispatch;
	// 82A81914: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81918: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8191C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8192C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81938 size=136
    let mut pc: u32 = 0x82A81938;
    'dispatch: loop {
        match pc {
            0x82A81938 => {
    //   block [0x82A81938..0x82A819C0)
	// 82A81938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8193C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8194C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81950: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81954: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A81958: 409A0020  bne cr6, 0x82a81978
	if !ctx.cr[6].eq {
	pc = 0x82A81978; continue 'dispatch;
	}
	// 82A8195C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A81960: 419A0048  beq cr6, 0x82a819a8
	if ctx.cr[6].eq {
	pc = 0x82A819A8; continue 'dispatch;
	}
	// 82A81964: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A81968: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A8196C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A81970: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A81974: 48000034  b 0x82a819a8
	pc = 0x82A819A8; continue 'dispatch;
	// 82A81978: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A8197C: 419A002C  beq cr6, 0x82a819a8
	if ctx.cr[6].eq {
	pc = 0x82A819A8; continue 'dispatch;
	}
	// 82A81980: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81984: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81988: 388B9580  addi r4, r11, -0x6a80
	ctx.r[4].s64 = ctx.r[11].s64 + -27264;
	// 82A8198C: 4872676D  bl 0x831a80f8
	ctx.lr = 0x82A81990;
	sub_831A80F8(ctx, base);
	// 82A81990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A81994: 4182000C  beq 0x82a819a0
	if ctx.cr[0].eq {
	pc = 0x82A819A0; continue 'dispatch;
	}
	// 82A81998: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A8199C: 4800000C  b 0x82a819a8
	pc = 0x82A819A8; continue 'dispatch;
	// 82A819A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A819A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A819A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A819AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A819B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A819B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A819B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A819BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A819C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A819C0 size=144
    let mut pc: u32 = 0x82A819C0;
    'dispatch: loop {
        match pc {
            0x82A819C0 => {
    //   block [0x82A819C0..0x82A81A50)
	// 82A819C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A819C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A819C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A819CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A819D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A819D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A819D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A819DC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A819E0: 409A0028  bne cr6, 0x82a81a08
	if !ctx.cr[6].eq {
	pc = 0x82A81A08; continue 'dispatch;
	}
	// 82A819E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A819E8: 419A0050  beq cr6, 0x82a81a38
	if ctx.cr[6].eq {
	pc = 0x82A81A38; continue 'dispatch;
	}
	// 82A819EC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A819F0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A819F4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A819F8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A819FC: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 82A81A00: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82A81A04: 48000034  b 0x82a81a38
	pc = 0x82A81A38; continue 'dispatch;
	// 82A81A08: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A81A0C: 419A002C  beq cr6, 0x82a81a38
	if ctx.cr[6].eq {
	pc = 0x82A81A38; continue 'dispatch;
	}
	// 82A81A10: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81A14: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81A18: 388B9658  addi r4, r11, -0x69a8
	ctx.r[4].s64 = ctx.r[11].s64 + -27048;
	// 82A81A1C: 487266DD  bl 0x831a80f8
	ctx.lr = 0x82A81A20;
	sub_831A80F8(ctx, base);
	// 82A81A20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A81A24: 4182000C  beq 0x82a81a30
	if ctx.cr[0].eq {
	pc = 0x82A81A30; continue 'dispatch;
	}
	// 82A81A28: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A81A2C: 4800000C  b 0x82a81a38
	pc = 0x82A81A38; continue 'dispatch;
	// 82A81A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81A34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81A38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81A44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81A48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81A4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81A50 size=136
    let mut pc: u32 = 0x82A81A50;
    'dispatch: loop {
        match pc {
            0x82A81A50 => {
    //   block [0x82A81A50..0x82A81AD8)
	// 82A81A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81A58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81A5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81A60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81A68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81A6C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A81A70: 409A0020  bne cr6, 0x82a81a90
	if !ctx.cr[6].eq {
	pc = 0x82A81A90; continue 'dispatch;
	}
	// 82A81A74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A81A78: 419A0048  beq cr6, 0x82a81ac0
	if ctx.cr[6].eq {
	pc = 0x82A81AC0; continue 'dispatch;
	}
	// 82A81A7C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A81A80: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A81A84: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A81A88: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A81A8C: 48000034  b 0x82a81ac0
	pc = 0x82A81AC0; continue 'dispatch;
	// 82A81A90: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A81A94: 419A002C  beq cr6, 0x82a81ac0
	if ctx.cr[6].eq {
	pc = 0x82A81AC0; continue 'dispatch;
	}
	// 82A81A98: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81A9C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81AA0: 388B9718  addi r4, r11, -0x68e8
	ctx.r[4].s64 = ctx.r[11].s64 + -26856;
	// 82A81AA4: 48726655  bl 0x831a80f8
	ctx.lr = 0x82A81AA8;
	sub_831A80F8(ctx, base);
	// 82A81AA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A81AAC: 4182000C  beq 0x82a81ab8
	if ctx.cr[0].eq {
	pc = 0x82A81AB8; continue 'dispatch;
	}
	// 82A81AB0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A81AB4: 4800000C  b 0x82a81ac0
	pc = 0x82A81AC0; continue 'dispatch;
	// 82A81AB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81ABC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81AC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81AC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81AC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81ACC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81AD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81AD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81AD8 size=136
    let mut pc: u32 = 0x82A81AD8;
    'dispatch: loop {
        match pc {
            0x82A81AD8 => {
    //   block [0x82A81AD8..0x82A81B60)
	// 82A81AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81AE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81AE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81AE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81AEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81AF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81AF4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A81AF8: 409A0020  bne cr6, 0x82a81b18
	if !ctx.cr[6].eq {
	pc = 0x82A81B18; continue 'dispatch;
	}
	// 82A81AFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A81B00: 419A0048  beq cr6, 0x82a81b48
	if ctx.cr[6].eq {
	pc = 0x82A81B48; continue 'dispatch;
	}
	// 82A81B04: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A81B08: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A81B0C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A81B10: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A81B14: 48000034  b 0x82a81b48
	pc = 0x82A81B48; continue 'dispatch;
	// 82A81B18: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A81B1C: 419A002C  beq cr6, 0x82a81b48
	if ctx.cr[6].eq {
	pc = 0x82A81B48; continue 'dispatch;
	}
	// 82A81B20: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81B24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81B28: 388B97C0  addi r4, r11, -0x6840
	ctx.r[4].s64 = ctx.r[11].s64 + -26688;
	// 82A81B2C: 487265CD  bl 0x831a80f8
	ctx.lr = 0x82A81B30;
	sub_831A80F8(ctx, base);
	// 82A81B30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A81B34: 4182000C  beq 0x82a81b40
	if ctx.cr[0].eq {
	pc = 0x82A81B40; continue 'dispatch;
	}
	// 82A81B38: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A81B3C: 4800000C  b 0x82a81b48
	pc = 0x82A81B48; continue 'dispatch;
	// 82A81B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81B44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81B48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81B54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81B60 size=16
    let mut pc: u32 = 0x82A81B60;
    'dispatch: loop {
        match pc {
            0x82A81B60 => {
    //   block [0x82A81B60..0x82A81B70)
	// 82A81B60: 396400FC  addi r11, r4, 0xfc
	ctx.r[11].s64 = ctx.r[4].s64 + 252;
	// 82A81B64: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A81B68: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82A81B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81B70 size=24
    let mut pc: u32 = 0x82A81B70;
    'dispatch: loop {
        match pc {
            0x82A81B70 => {
    //   block [0x82A81B70..0x82A81B88)
	// 82A81B70: 396400FC  addi r11, r4, 0xfc
	ctx.r[11].s64 = ctx.r[4].s64 + 252;
	// 82A81B74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A81B78: 7D4B182E  lwzx r10, r11, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82A81B7C: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82A81B80: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 82A81B84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81B88 size=8
    let mut pc: u32 = 0x82A81B88;
    'dispatch: loop {
        match pc {
            0x82A81B88 => {
    //   block [0x82A81B88..0x82A81B90)
	// 82A81B88: 80630378  lwz r3, 0x378(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(888 as u32) ) } as u64;
	// 82A81B8C: 4800975C  b 0x82a8b2e8
	sub_82A8B2E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81B90 size=136
    let mut pc: u32 = 0x82A81B90;
    'dispatch: loop {
        match pc {
            0x82A81B90 => {
    //   block [0x82A81B90..0x82A81C18)
	// 82A81B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81B94: 487265D5  bl 0x831a8168
	ctx.lr = 0x82A81B98;
	sub_831A8130(ctx, base);
	// 82A81B98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81B9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81BA0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A81BA4: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 82A81BA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A81BAC: 4BA8DF95  bl 0x8250fb40
	ctx.lr = 0x82A81BB0;
	sub_8250FB40(ctx, base);
	// 82A81BB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A81BB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A81BB8: 807E0370  lwz r3, 0x370(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(880 as u32) ) } as u64;
	// 82A81BBC: 48006165  bl 0x82a87d20
	ctx.lr = 0x82A81BC0;
	sub_82A87D20(ctx, base);
	// 82A81BC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A81BC4: 4BA0D785  bl 0x8248f348
	ctx.lr = 0x82A81BC8;
	sub_8248F348(ctx, base);
	// 82A81BC8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A81BCC: 2F1F0007  cmpwi cr6, r31, 7
	ctx.cr[6].compare_i32(ctx.r[31].s32, 7, &mut ctx.xer);
	// 82A81BD0: 4198FFE4  blt cr6, 0x82a81bb4
	if ctx.cr[6].lt {
	pc = 0x82A81BB4; continue 'dispatch;
	}
	// 82A81BD4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A81BD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A81BDC: 4182001C  beq 0x82a81bf8
	if ctx.cr[0].eq {
	pc = 0x82A81BF8; continue 'dispatch;
	}
	// 82A81BE0: 4BA900C9  bl 0x82511ca8
	ctx.lr = 0x82A81BE4;
	sub_82511CA8(ctx, base);
	// 82A81BE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A81BE8: 4BD6A699  bl 0x827ec280
	ctx.lr = 0x82A81BEC;
	sub_827EC280(ctx, base);
	// 82A81BEC: 807E0320  lwz r3, 0x320(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(800 as u32) ) } as u64;
	// 82A81BF0: 480C40C9  bl 0x82b45cb8
	ctx.lr = 0x82A81BF4;
	sub_82B45CB8(ctx, base);
	// 82A81BF4: 4800001C  b 0x82a81c10
	pc = 0x82A81C10; continue 'dispatch;
	// 82A81BF8: 4BA90091  bl 0x82511c88
	ctx.lr = 0x82A81BFC;
	sub_82511C88(ctx, base);
	// 82A81BFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A81C00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A81C04: 4BD6A66D  bl 0x827ec270
	ctx.lr = 0x82A81C08;
	sub_827EC270(ctx, base);
	// 82A81C08: 807E0320  lwz r3, 0x320(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(800 as u32) ) } as u64;
	// 82A81C0C: 480C404D  bl 0x82b45c58
	ctx.lr = 0x82A81C10;
	sub_82B45C58(ctx, base);
	// 82A81C10: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A81C14: 487265A4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81C18 size=8
    let mut pc: u32 = 0x82A81C18;
    'dispatch: loop {
        match pc {
            0x82A81C18 => {
    //   block [0x82A81C18..0x82A81C20)
	// 82A81C18: 806303D8  lwz r3, 0x3d8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(984 as u32) ) } as u64;
	// 82A81C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A81C20 size=12
    let mut pc: u32 = 0x82A81C20;
    'dispatch: loop {
        match pc {
            0x82A81C20 => {
    //   block [0x82A81C20..0x82A81C2C)
	// 82A81C20: 806300F4  lwz r3, 0xf4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A81C24: 38840020  addi r4, r4, 0x20
	ctx.r[4].s64 = ctx.r[4].s64 + 32;
	// 82A81C28: 48006AE8  b 0x82a88710
	sub_82A88710(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81C30 size=196
    let mut pc: u32 = 0x82A81C30;
    'dispatch: loop {
        match pc {
            0x82A81C30 => {
    //   block [0x82A81C30..0x82A81CF4)
	// 82A81C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81C40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81C4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A81C50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81C54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81C58: 4B83ECE1  bl 0x822c0938
	ctx.lr = 0x82A81C5C;
	sub_822C0938(ctx, base);
	// 82A81C5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A81C60: 41820028  beq 0x82a81c88
	if ctx.cr[0].eq {
	pc = 0x82A81C88; continue 'dispatch;
	}
	// 82A81C64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81C68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A81C6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A81C70: 392B1ECC  addi r9, r11, 0x1ecc
	ctx.r[9].s64 = ctx.r[11].s64 + 7884;
	// 82A81C74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A81C78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A81C7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A81C80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A81C84: 48000008  b 0x82a81c8c
	pc = 0x82A81C8C; continue 'dispatch;
	// 82A81C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81C8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A81C94: 409A0044  bne cr6, 0x82a81cd8
	if !ctx.cr[6].eq {
	pc = 0x82A81CD8; continue 'dispatch;
	}
	// 82A81C98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A81C9C: 419A001C  beq cr6, 0x82a81cb8
	if ctx.cr[6].eq {
	pc = 0x82A81CB8; continue 'dispatch;
	}
	// 82A81CA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81CA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A81CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81CAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A81CB4: 4E800421  bctrl
	ctx.lr = 0x82A81CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A81CB8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81CBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A81CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A81CC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A81CC8: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A81CCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A81CD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A81CD4: 4B83E32D  bl 0x822c0000
	ctx.lr = 0x82A81CD8;
	sub_822C0000(ctx, base);
	// 82A81CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A81CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81CF8 size=196
    let mut pc: u32 = 0x82A81CF8;
    'dispatch: loop {
        match pc {
            0x82A81CF8 => {
    //   block [0x82A81CF8..0x82A81DBC)
	// 82A81CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81D0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81D10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81D14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A81D18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81D1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81D20: 4B83EC19  bl 0x822c0938
	ctx.lr = 0x82A81D24;
	sub_822C0938(ctx, base);
	// 82A81D24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A81D28: 41820028  beq 0x82a81d50
	if ctx.cr[0].eq {
	pc = 0x82A81D50; continue 'dispatch;
	}
	// 82A81D2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81D30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A81D34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A81D38: 392B1EE0  addi r9, r11, 0x1ee0
	ctx.r[9].s64 = ctx.r[11].s64 + 7904;
	// 82A81D3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A81D40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A81D44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A81D48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A81D4C: 48000008  b 0x82a81d54
	pc = 0x82A81D54; continue 'dispatch;
	// 82A81D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81D54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A81D5C: 409A0044  bne cr6, 0x82a81da0
	if !ctx.cr[6].eq {
	pc = 0x82A81DA0; continue 'dispatch;
	}
	// 82A81D60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A81D64: 419A001C  beq cr6, 0x82a81d80
	if ctx.cr[6].eq {
	pc = 0x82A81D80; continue 'dispatch;
	}
	// 82A81D68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81D6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A81D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81D74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A81D7C: 4E800421  bctrl
	ctx.lr = 0x82A81D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A81D80: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81D84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A81D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A81D8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A81D90: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A81D94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A81D98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A81D9C: 4B83E265  bl 0x822c0000
	ctx.lr = 0x82A81DA0;
	sub_822C0000(ctx, base);
	// 82A81DA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A81DA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81DB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81DC0 size=168
    let mut pc: u32 = 0x82A81DC0;
    'dispatch: loop {
        match pc {
            0x82A81DC0 => {
    //   block [0x82A81DC0..0x82A81E68)
	// 82A81DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81DD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A81DD8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81DDC: 3D408325  lis r10, -0x7cdb
	ctx.r[10].s64 = -2094727168;
	// 82A81DE0: 38CB98BC  addi r6, r11, -0x6744
	ctx.r[6].s64 = ctx.r[11].s64 + -26436;
	// 82A81DE4: 38AA4E38  addi r5, r10, 0x4e38
	ctx.r[5].s64 = ctx.r[10].s64 + 20024;
	// 82A81DE8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A81DEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A81DF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A81DF4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81DF8: 48728151  bl 0x831a9f48
	ctx.lr = 0x82A81DFC;
	sub_831A9F48(ctx, base);
	// 82A81DFC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A81E00: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A81E04: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A81E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A81E0C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A81E10: 419A0024  beq cr6, 0x82a81e34
	if ctx.cr[6].eq {
	pc = 0x82A81E34; continue 'dispatch;
	}
	// 82A81E14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A81E18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A81E1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A81E20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A81E24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A81E28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A81E2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A81E30: 4082FFE8  bne 0x82a81e18
	if !ctx.cr[0].eq {
	pc = 0x82A81E18; continue 'dispatch;
	}
	// 82A81E34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A81E3C: 409A0010  bne cr6, 0x82a81e4c
	if !ctx.cr[6].eq {
	pc = 0x82A81E4C; continue 'dispatch;
	}
	// 82A81E40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A81E44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A81E48: 4B842619  bl 0x822c4460
	ctx.lr = 0x82A81E4C;
	sub_822C4460(ctx, base);
	// 82A81E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81E50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81E54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81E58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81E5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81E60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81E68 size=196
    let mut pc: u32 = 0x82A81E68;
    'dispatch: loop {
        match pc {
            0x82A81E68 => {
    //   block [0x82A81E68..0x82A81F2C)
	// 82A81E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81E84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A81E88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81E8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81E90: 4B83EAA9  bl 0x822c0938
	ctx.lr = 0x82A81E94;
	sub_822C0938(ctx, base);
	// 82A81E94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A81E98: 41820028  beq 0x82a81ec0
	if ctx.cr[0].eq {
	pc = 0x82A81EC0; continue 'dispatch;
	}
	// 82A81E9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81EA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A81EA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A81EA8: 392B1EF4  addi r9, r11, 0x1ef4
	ctx.r[9].s64 = ctx.r[11].s64 + 7924;
	// 82A81EAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A81EB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A81EB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A81EB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A81EBC: 48000008  b 0x82a81ec4
	pc = 0x82A81EC4; continue 'dispatch;
	// 82A81EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81EC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A81ECC: 409A0044  bne cr6, 0x82a81f10
	if !ctx.cr[6].eq {
	pc = 0x82A81F10; continue 'dispatch;
	}
	// 82A81ED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A81ED4: 419A001C  beq cr6, 0x82a81ef0
	if ctx.cr[6].eq {
	pc = 0x82A81EF0; continue 'dispatch;
	}
	// 82A81ED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81EDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A81EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81EE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A81EEC: 4E800421  bctrl
	ctx.lr = 0x82A81EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A81EF0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81EF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A81EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A81EFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A81F00: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A81F04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A81F08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A81F0C: 4B83E0F5  bl 0x822c0000
	ctx.lr = 0x82A81F10;
	sub_822C0000(ctx, base);
	// 82A81F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A81F14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81F18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81F1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81F20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81F24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81F28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81F30 size=196
    let mut pc: u32 = 0x82A81F30;
    'dispatch: loop {
        match pc {
            0x82A81F30 => {
    //   block [0x82A81F30..0x82A81FF4)
	// 82A81F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A81F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A81F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A81F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A81F44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A81F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81F4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A81F50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A81F54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81F58: 4B83E9E1  bl 0x822c0938
	ctx.lr = 0x82A81F5C;
	sub_822C0938(ctx, base);
	// 82A81F5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A81F60: 41820028  beq 0x82a81f88
	if ctx.cr[0].eq {
	pc = 0x82A81F88; continue 'dispatch;
	}
	// 82A81F64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A81F68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A81F6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A81F70: 392B1F08  addi r9, r11, 0x1f08
	ctx.r[9].s64 = ctx.r[11].s64 + 7944;
	// 82A81F74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A81F78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A81F7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A81F80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A81F84: 48000008  b 0x82a81f8c
	pc = 0x82A81F8C; continue 'dispatch;
	// 82A81F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A81F8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A81F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A81F94: 409A0044  bne cr6, 0x82a81fd8
	if !ctx.cr[6].eq {
	pc = 0x82A81FD8; continue 'dispatch;
	}
	// 82A81F98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A81F9C: 419A001C  beq cr6, 0x82a81fb8
	if ctx.cr[6].eq {
	pc = 0x82A81FB8; continue 'dispatch;
	}
	// 82A81FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81FA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A81FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A81FAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A81FB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A81FB4: 4E800421  bctrl
	ctx.lr = 0x82A81FB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A81FB8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A81FBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A81FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A81FC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A81FC8: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A81FCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A81FD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A81FD4: 4B83E02D  bl 0x822c0000
	ctx.lr = 0x82A81FD8;
	sub_822C0000(ctx, base);
	// 82A81FD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A81FDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A81FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A81FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A81FE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A81FEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A81FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A81FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A81FF8 size=196
    let mut pc: u32 = 0x82A81FF8;
    'dispatch: loop {
        match pc {
            0x82A81FF8 => {
    //   block [0x82A81FF8..0x82A820BC)
	// 82A81FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A81FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82000: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82004: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8200C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A82010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A82014: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A82018: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8201C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82020: 4B83E919  bl 0x822c0938
	ctx.lr = 0x82A82024;
	sub_822C0938(ctx, base);
	// 82A82024: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A82028: 41820028  beq 0x82a82050
	if ctx.cr[0].eq {
	pc = 0x82A82050; continue 'dispatch;
	}
	// 82A8202C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A82030: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A82034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A82038: 392B1F1C  addi r9, r11, 0x1f1c
	ctx.r[9].s64 = ctx.r[11].s64 + 7964;
	// 82A8203C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A82040: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A82044: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A82048: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8204C: 48000008  b 0x82a82054
	pc = 0x82A82054; continue 'dispatch;
	// 82A82050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A82054: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8205C: 409A0044  bne cr6, 0x82a820a0
	if !ctx.cr[6].eq {
	pc = 0x82A820A0; continue 'dispatch;
	}
	// 82A82060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A82064: 419A001C  beq cr6, 0x82a82080
	if ctx.cr[6].eq {
	pc = 0x82A82080; continue 'dispatch;
	}
	// 82A82068: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8206C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A82070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A82074: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8207C: 4E800421  bctrl
	ctx.lr = 0x82A82080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82080: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82084: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A82088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8208C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A82090: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A82094: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A82098: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8209C: 4B83DF65  bl 0x822c0000
	ctx.lr = 0x82A820A0;
	sub_822C0000(ctx, base);
	// 82A820A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A820A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A820A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A820AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A820B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A820B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A820B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A820C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A820C0 size=196
    let mut pc: u32 = 0x82A820C0;
    'dispatch: loop {
        match pc {
            0x82A820C0 => {
    //   block [0x82A820C0..0x82A82184)
	// 82A820C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A820C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A820C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A820CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A820D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A820D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A820D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A820DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A820E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A820E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A820E8: 4B83E851  bl 0x822c0938
	ctx.lr = 0x82A820EC;
	sub_822C0938(ctx, base);
	// 82A820EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A820F0: 41820028  beq 0x82a82118
	if ctx.cr[0].eq {
	pc = 0x82A82118; continue 'dispatch;
	}
	// 82A820F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A820F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A820FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A82100: 392B1F30  addi r9, r11, 0x1f30
	ctx.r[9].s64 = ctx.r[11].s64 + 7984;
	// 82A82104: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A82108: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8210C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A82110: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A82114: 48000008  b 0x82a8211c
	pc = 0x82A8211C; continue 'dispatch;
	// 82A82118: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8211C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82124: 409A0044  bne cr6, 0x82a82168
	if !ctx.cr[6].eq {
	pc = 0x82A82168; continue 'dispatch;
	}
	// 82A82128: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A8212C: 419A001C  beq cr6, 0x82a82148
	if ctx.cr[6].eq {
	pc = 0x82A82148; continue 'dispatch;
	}
	// 82A82130: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82134: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A82138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8213C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A82144: 4E800421  bctrl
	ctx.lr = 0x82A82148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82148: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8214C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A82150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82154: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A82158: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A8215C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A82160: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A82164: 4B83DE9D  bl 0x822c0000
	ctx.lr = 0x82A82168;
	sub_822C0000(ctx, base);
	// 82A82168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8216C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82178: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8217C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A82180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82188 size=196
    let mut pc: u32 = 0x82A82188;
    'dispatch: loop {
        match pc {
            0x82A82188 => {
    //   block [0x82A82188..0x82A8224C)
	// 82A82188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8218C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8219C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A821A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A821A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A821A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A821AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A821B0: 4B83E789  bl 0x822c0938
	ctx.lr = 0x82A821B4;
	sub_822C0938(ctx, base);
	// 82A821B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A821B8: 41820028  beq 0x82a821e0
	if ctx.cr[0].eq {
	pc = 0x82A821E0; continue 'dispatch;
	}
	// 82A821BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A821C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A821C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A821C8: 392B1F44  addi r9, r11, 0x1f44
	ctx.r[9].s64 = ctx.r[11].s64 + 8004;
	// 82A821CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A821D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A821D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A821D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A821DC: 48000008  b 0x82a821e4
	pc = 0x82A821E4; continue 'dispatch;
	// 82A821E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A821E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A821E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A821EC: 409A0044  bne cr6, 0x82a82230
	if !ctx.cr[6].eq {
	pc = 0x82A82230; continue 'dispatch;
	}
	// 82A821F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A821F4: 419A001C  beq cr6, 0x82a82210
	if ctx.cr[6].eq {
	pc = 0x82A82210; continue 'dispatch;
	}
	// 82A821F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A821FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A82200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A82204: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82208: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8220C: 4E800421  bctrl
	ctx.lr = 0x82A82210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82210: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82214: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A82218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8221C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A82220: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A82224: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A82228: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8222C: 4B83DDD5  bl 0x822c0000
	ctx.lr = 0x82A82230;
	sub_822C0000(ctx, base);
	// 82A82230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A82234: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8223C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82240: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A82244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A82248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82250 size=196
    let mut pc: u32 = 0x82A82250;
    'dispatch: loop {
        match pc {
            0x82A82250 => {
    //   block [0x82A82250..0x82A82314)
	// 82A82250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8225C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A82268: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8226C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A82270: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A82274: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82278: 4B83E6C1  bl 0x822c0938
	ctx.lr = 0x82A8227C;
	sub_822C0938(ctx, base);
	// 82A8227C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A82280: 41820028  beq 0x82a822a8
	if ctx.cr[0].eq {
	pc = 0x82A822A8; continue 'dispatch;
	}
	// 82A82284: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A82288: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8228C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A82290: 392B1F58  addi r9, r11, 0x1f58
	ctx.r[9].s64 = ctx.r[11].s64 + 8024;
	// 82A82294: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A82298: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8229C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A822A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A822A4: 48000008  b 0x82a822ac
	pc = 0x82A822AC; continue 'dispatch;
	// 82A822A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A822AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A822B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A822B4: 409A0044  bne cr6, 0x82a822f8
	if !ctx.cr[6].eq {
	pc = 0x82A822F8; continue 'dispatch;
	}
	// 82A822B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A822BC: 419A001C  beq cr6, 0x82a822d8
	if ctx.cr[6].eq {
	pc = 0x82A822D8; continue 'dispatch;
	}
	// 82A822C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A822C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A822C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A822CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A822D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A822D4: 4E800421  bctrl
	ctx.lr = 0x82A822D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A822D8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A822DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A822E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A822E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A822E8: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A822EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A822F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A822F4: 4B83DD0D  bl 0x822c0000
	ctx.lr = 0x82A822F8;
	sub_822C0000(ctx, base);
	// 82A822F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A822FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82308: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8230C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A82310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82318 size=196
    let mut pc: u32 = 0x82A82318;
    'dispatch: loop {
        match pc {
            0x82A82318 => {
    //   block [0x82A82318..0x82A823DC)
	// 82A82318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8231C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8232C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A82330: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A82334: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A82338: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8233C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82340: 4B83E5F9  bl 0x822c0938
	ctx.lr = 0x82A82344;
	sub_822C0938(ctx, base);
	// 82A82344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A82348: 41820028  beq 0x82a82370
	if ctx.cr[0].eq {
	pc = 0x82A82370; continue 'dispatch;
	}
	// 82A8234C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A82350: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A82354: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A82358: 392B1F6C  addi r9, r11, 0x1f6c
	ctx.r[9].s64 = ctx.r[11].s64 + 8044;
	// 82A8235C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A82360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A82364: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A82368: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8236C: 48000008  b 0x82a82374
	pc = 0x82A82374; continue 'dispatch;
	// 82A82370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A82374: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8237C: 409A0044  bne cr6, 0x82a823c0
	if !ctx.cr[6].eq {
	pc = 0x82A823C0; continue 'dispatch;
	}
	// 82A82380: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A82384: 419A001C  beq cr6, 0x82a823a0
	if ctx.cr[6].eq {
	pc = 0x82A823A0; continue 'dispatch;
	}
	// 82A82388: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8238C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A82390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A82394: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8239C: 4E800421  bctrl
	ctx.lr = 0x82A823A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A823A0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A823A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A823A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A823AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A823B0: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A823B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A823B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A823BC: 4B83DC45  bl 0x822c0000
	ctx.lr = 0x82A823C0;
	sub_822C0000(ctx, base);
	// 82A823C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A823C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A823C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A823CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A823D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A823D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A823D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A823E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A823E0 size=196
    let mut pc: u32 = 0x82A823E0;
    'dispatch: loop {
        match pc {
            0x82A823E0 => {
    //   block [0x82A823E0..0x82A824A4)
	// 82A823E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A823E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A823E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A823EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A823F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A823F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A823F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A823FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A82400: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A82404: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82408: 4B83E531  bl 0x822c0938
	ctx.lr = 0x82A8240C;
	sub_822C0938(ctx, base);
	// 82A8240C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A82410: 41820028  beq 0x82a82438
	if ctx.cr[0].eq {
	pc = 0x82A82438; continue 'dispatch;
	}
	// 82A82414: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A82418: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8241C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A82420: 392B1F80  addi r9, r11, 0x1f80
	ctx.r[9].s64 = ctx.r[11].s64 + 8064;
	// 82A82424: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A82428: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8242C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A82430: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A82434: 48000008  b 0x82a8243c
	pc = 0x82A8243C; continue 'dispatch;
	// 82A82438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8243C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82444: 409A0044  bne cr6, 0x82a82488
	if !ctx.cr[6].eq {
	pc = 0x82A82488; continue 'dispatch;
	}
	// 82A82448: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A8244C: 419A001C  beq cr6, 0x82a82468
	if ctx.cr[6].eq {
	pc = 0x82A82468; continue 'dispatch;
	}
	// 82A82450: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82454: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A82458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8245C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A82464: 4E800421  bctrl
	ctx.lr = 0x82A82468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82468: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8246C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A82470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82474: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A82478: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A8247C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A82480: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A82484: 4B83DB7D  bl 0x822c0000
	ctx.lr = 0x82A82488;
	sub_822C0000(ctx, base);
	// 82A82488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8248C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82498: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8249C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A824A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A824A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A824A8 size=196
    let mut pc: u32 = 0x82A824A8;
    'dispatch: loop {
        match pc {
            0x82A824A8 => {
    //   block [0x82A824A8..0x82A8256C)
	// 82A824A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A824AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A824B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A824B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A824B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A824BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A824C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A824C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A824C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A824CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A824D0: 4B83E469  bl 0x822c0938
	ctx.lr = 0x82A824D4;
	sub_822C0938(ctx, base);
	// 82A824D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A824D8: 41820028  beq 0x82a82500
	if ctx.cr[0].eq {
	pc = 0x82A82500; continue 'dispatch;
	}
	// 82A824DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A824E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A824E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A824E8: 392B1F94  addi r9, r11, 0x1f94
	ctx.r[9].s64 = ctx.r[11].s64 + 8084;
	// 82A824EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A824F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A824F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A824F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A824FC: 48000008  b 0x82a82504
	pc = 0x82A82504; continue 'dispatch;
	// 82A82500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A82504: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8250C: 409A0044  bne cr6, 0x82a82550
	if !ctx.cr[6].eq {
	pc = 0x82A82550; continue 'dispatch;
	}
	// 82A82510: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A82514: 419A001C  beq cr6, 0x82a82530
	if ctx.cr[6].eq {
	pc = 0x82A82530; continue 'dispatch;
	}
	// 82A82518: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8251C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A82520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A82524: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A82528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8252C: 4E800421  bctrl
	ctx.lr = 0x82A82530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82530: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82534: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A82538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8253C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A82540: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A82544: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A82548: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8254C: 4B83DAB5  bl 0x822c0000
	ctx.lr = 0x82A82550;
	sub_822C0000(ctx, base);
	// 82A82550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A82554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8255C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A82564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A82568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82570 size=196
    let mut pc: u32 = 0x82A82570;
    'dispatch: loop {
        match pc {
            0x82A82570 => {
    //   block [0x82A82570..0x82A82634)
	// 82A82570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8257C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82584: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A82588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8258C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A82590: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A82594: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82598: 4B83E3A1  bl 0x822c0938
	ctx.lr = 0x82A8259C;
	sub_822C0938(ctx, base);
	// 82A8259C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A825A0: 41820028  beq 0x82a825c8
	if ctx.cr[0].eq {
	pc = 0x82A825C8; continue 'dispatch;
	}
	// 82A825A4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A825A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A825AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A825B0: 392B1FA8  addi r9, r11, 0x1fa8
	ctx.r[9].s64 = ctx.r[11].s64 + 8104;
	// 82A825B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A825B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A825BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A825C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A825C4: 48000008  b 0x82a825cc
	pc = 0x82A825CC; continue 'dispatch;
	// 82A825C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A825CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A825D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A825D4: 409A0044  bne cr6, 0x82a82618
	if !ctx.cr[6].eq {
	pc = 0x82A82618; continue 'dispatch;
	}
	// 82A825D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A825DC: 419A001C  beq cr6, 0x82a825f8
	if ctx.cr[6].eq {
	pc = 0x82A825F8; continue 'dispatch;
	}
	// 82A825E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A825E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A825E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A825EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A825F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A825F4: 4E800421  bctrl
	ctx.lr = 0x82A825F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A825F8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A825FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A82600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82604: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A82608: 816B9124  lwz r11, -0x6edc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28380 as u32) ) } as u64;
	// 82A8260C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A82610: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A82614: 4B83D9ED  bl 0x822c0000
	ctx.lr = 0x82A82618;
	sub_822C0000(ctx, base);
	// 82A82618: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8261C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82620: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82624: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82628: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8262C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A82630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82638 size=72
    let mut pc: u32 = 0x82A82638;
    'dispatch: loop {
        match pc {
            0x82A82638 => {
    //   block [0x82A82638..0x82A82680)
	// 82A82638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8263C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82640: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82644: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A82648: 419A001C  beq cr6, 0x82a82664
	if ctx.cr[6].eq {
	pc = 0x82A82664; continue 'dispatch;
	}
	// 82A8264C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A82650: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A82654: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A82658: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8265C: 4BFFF265  bl 0x82a818c0
	ctx.lr = 0x82A82660;
	sub_82A818C0(ctx, base);
	// 82A82660: 48000010  b 0x82a82670
	pc = 0x82A82670; continue 'dispatch;
	// 82A82664: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82668: 396B9538  addi r11, r11, -0x6ac8
	ctx.r[11].s64 = ctx.r[11].s64 + -27336;
	// 82A8266C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A82674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8267C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A82680 size=112
    let mut pc: u32 = 0x82A82680;
    'dispatch: loop {
        match pc {
            0x82A82680 => {
    //   block [0x82A82680..0x82A826F0)
	// 82A82680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82688: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8268C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82690: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A82694: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A82698: 396BE0D8  addi r11, r11, -0x1f28
	ctx.r[11].s64 = ctx.r[11].s64 + -7976;
	// 82A8269C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A826A0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A826A4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A826A8: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A826AC: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A826B0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A826B4: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A826B8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A826BC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A826C0: 4BF90FC1  bl 0x82a13680
	ctx.lr = 0x82A826C4;
	sub_82A13680(ctx, base);
	// 82A826C4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A826C8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A826CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A826D0: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A826F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A826F0 size=228
    let mut pc: u32 = 0x82A826F0;
    'dispatch: loop {
        match pc {
            0x82A826F0 => {
    //   block [0x82A826F0..0x82A827D4)
	// 82A826F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A826F4: 48725A79  bl 0x831a816c
	ctx.lr = 0x82A826F8;
	sub_831A8130(ctx, base);
	// 82A826F8: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A826FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A82700: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A82704: 4BB27E35  bl 0x825aa538
	ctx.lr = 0x82A82708;
	sub_825AA538(ctx, base);
	// 82A82708: 807E00E4  lwz r3, 0xe4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A8270C: 4BE7D2E5  bl 0x828ff9f0
	ctx.lr = 0x82A82710;
	sub_828FF9F0(ctx, base);
	// 82A82710: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 82A82714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A82718: 4BF90F69  bl 0x82a13680
	ctx.lr = 0x82A8271C;
	sub_82A13680(ctx, base);
	// 82A8271C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A82720: 13C0E8C7  vcmpequd (lvx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A82724: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A827D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A827D8 size=224
    let mut pc: u32 = 0x82A827D8;
    'dispatch: loop {
        match pc {
            0x82A827D8 => {
    //   block [0x82A827D8..0x82A828B8)
	// 82A827D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A827DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A827E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A827E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A827E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A827EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A827F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A827F4: 817FFEE4  lwz r11, -0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-284 as u32) ) } as u64;
	// 82A827F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A827FC: 419A008C  beq cr6, 0x82a82888
	if ctx.cr[6].eq {
	pc = 0x82A82888; continue 'dispatch;
	}
	// 82A82800: 2B050002  cmplwi cr6, r5, 2
	ctx.cr[6].compare_u32(ctx.r[5].u32, 2 as u32, &mut ctx.xer);
	// 82A82804: 40980084  bge cr6, 0x82a82888
	if !ctx.cr[6].lt {
	pc = 0x82A82888; continue 'dispatch;
	}
	// 82A82808: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8280C: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A82810: 396B911C  addi r11, r11, -0x6ee4
	ctx.r[11].s64 = ctx.r[11].s64 + -28388;
	// 82A82814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82818: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A8281C: 483711ED  bl 0x82df3a08
	ctx.lr = 0x82A82820;
	sub_82DF3A08(ctx, base);
	// 82A82820: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A82824: 809FFEE4  lwz r4, -0x11c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-284 as u32) ) } as u64;
	// 82A82828: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8282C: 48392805  bl 0x82e15030
	ctx.lr = 0x82A82830;
	sub_82E15030(ctx, base);
	// 82A82830: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82838: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8283C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A82840: 4E800421  bctrl
	ctx.lr = 0x82A82844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82844: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A82848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8284C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82850: 419A000C  beq cr6, 0x82a8285c
	if ctx.cr[6].eq {
	pc = 0x82A8285C; continue 'dispatch;
	}
	// 82A82854: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A82858: 4B83E039  bl 0x822c0890
	ctx.lr = 0x82A8285C;
	sub_822C0890(ctx, base);
	// 82A8285C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82860: 48370BC9  bl 0x82df3428
	ctx.lr = 0x82A82864;
	sub_82DF3428(ctx, base);
	// 82A82864: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A82868: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A8286C: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A82870: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A82874: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A82878: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A8287C: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A82880: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A82884: 48000018  b 0x82a8289c
	pc = 0x82A8289C; continue 'dispatch;
	// 82A82888: 387FFDF8  addi r3, r31, -0x208
	ctx.r[3].s64 = ctx.r[31].s64 + -520;
	// 82A8288C: 4BF90DF5  bl 0x82a13680
	ctx.lr = 0x82A82890;
	sub_82A13680(ctx, base);
	// 82A82890: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A82894: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A828B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A828B8 size=112
    let mut pc: u32 = 0x82A828B8;
    'dispatch: loop {
        match pc {
            0x82A828B8 => {
    //   block [0x82A828B8..0x82A82928)
	// 82A828B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A828BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A828C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A828C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A828C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A828CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A828D0: 809F03D8  lwz r4, 0x3d8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) } as u64;
	// 82A828D4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A828D8: 419A0038  beq cr6, 0x82a82910
	if ctx.cr[6].eq {
	pc = 0x82A82910; continue 'dispatch;
	}
	// 82A828DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A828E0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A828E4: 4BA7C9B5  bl 0x824ff298
	ctx.lr = 0x82A828E8;
	sub_824FF298(ctx, base);
	// 82A828E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A828EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A828F0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A828F4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A828F8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A828FC: 4BA8D8F5  bl 0x825101f0
	ctx.lr = 0x82A82900;
	sub_825101F0(ctx, base);
	// 82A82900: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A82904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A82908: 419A0008  beq cr6, 0x82a82910
	if ctx.cr[6].eq {
	pc = 0x82A82910; continue 'dispatch;
	}
	// 82A8290C: 4B83DF85  bl 0x822c0890
	ctx.lr = 0x82A82910;
	sub_822C0890(ctx, base);
	// 82A82910: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8291C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A82920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A82924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82928 size=112
    let mut pc: u32 = 0x82A82928;
    'dispatch: loop {
        match pc {
            0x82A82928 => {
    //   block [0x82A82928..0x82A82998)
	// 82A82928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8292C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8293C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A82940: 809F03D8  lwz r4, 0x3d8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) } as u64;
	// 82A82944: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A82948: 419A0038  beq cr6, 0x82a82980
	if ctx.cr[6].eq {
	pc = 0x82A82980; continue 'dispatch;
	}
	// 82A8294C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82950: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A82954: 4BA7C945  bl 0x824ff298
	ctx.lr = 0x82A82958;
	sub_824FF298(ctx, base);
	// 82A82958: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A8295C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A82960: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A82964: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A82968: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A8296C: 4BA8E1ED  bl 0x82510b58
	ctx.lr = 0x82A82970;
	sub_82510B58(ctx, base);
	// 82A82970: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A82974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A82978: 419A0008  beq cr6, 0x82a82980
	if ctx.cr[6].eq {
	pc = 0x82A82980; continue 'dispatch;
	}
	// 82A8297C: 4B83DF15  bl 0x822c0890
	ctx.lr = 0x82A82980;
	sub_822C0890(ctx, base);
	// 82A82980: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A82984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8298C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A82990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A82994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82998 size=184
    let mut pc: u32 = 0x82A82998;
    'dispatch: loop {
        match pc {
            0x82A82998 => {
    //   block [0x82A82998..0x82A82A50)
	// 82A82998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8299C: 487257CD  bl 0x831a8168
	ctx.lr = 0x82A829A0;
	sub_831A8130(ctx, base);
	// 82A829A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A829A4: 81630100  lwz r11, 0x100(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A829A8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A829AC: 814300FC  lwz r10, 0xfc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A829B0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A829B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A829B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A829BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A829C0: 419A0024  beq cr6, 0x82a829e4
	if ctx.cr[6].eq {
	pc = 0x82A829E4; continue 'dispatch;
	}
	// 82A829C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A829C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A829CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A829D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A829D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A829D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A829DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A829E0: 4082FFE8  bne 0x82a829c8
	if !ctx.cr[0].eq {
	pc = 0x82A829C8; continue 'dispatch;
	}
	// 82A829E4: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82A829E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A829EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A829F0: 4BA8CAD9  bl 0x8250f4c8
	ctx.lr = 0x82A829F4;
	sub_8250F4C8(ctx, base);
	// 82A829F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A829F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A829FC: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A82A00: 409A0008  bne cr6, 0x82a82a08
	if !ctx.cr[6].eq {
	pc = 0x82A82A08; continue 'dispatch;
	}
	// 82A82A04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A82A08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A82A0C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A82A10: 4BE87A21  bl 0x8290a430
	ctx.lr = 0x82A82A14;
	sub_8290A430(ctx, base);
	// 82A82A14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A82A18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A82A1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A82A20: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A82A24: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A82A28: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82A82A2C: 480C316D  bl 0x82b45b98
	ctx.lr = 0x82A82A30;
	sub_82B45B98(ctx, base);
	// 82A82A30: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A82A34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A82A38: 419A0008  beq cr6, 0x82a82a40
	if ctx.cr[6].eq {
	pc = 0x82A82A40; continue 'dispatch;
	}
	// 82A82A3C: 4B83DE55  bl 0x822c0890
	ctx.lr = 0x82A82A40;
	sub_822C0890(ctx, base);
	// 82A82A40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A82A44: 4836F24D  bl 0x82df1c90
	ctx.lr = 0x82A82A48;
	sub_82DF1C90(ctx, base);
	// 82A82A48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A82A4C: 4872576C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A82A50 size=220
    let mut pc: u32 = 0x82A82A50;
    'dispatch: loop {
        match pc {
            0x82A82A50 => {
    //   block [0x82A82A50..0x82A82B2C)
	// 82A82A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82A58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82A5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82A60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82A64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A82A68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A82A6C: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A82A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82A74: 419A008C  beq cr6, 0x82a82b00
	if ctx.cr[6].eq {
	pc = 0x82A82B00; continue 'dispatch;
	}
	// 82A82A78: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82A7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82A80: 808B911C  lwz r4, -0x6ee4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28388 as u32) ) } as u64;
	// 82A82A84: 48370F85  bl 0x82df3a08
	ctx.lr = 0x82A82A88;
	sub_82DF3A08(ctx, base);
	// 82A82A88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A82A8C: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A82A90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A82A94: 4839259D  bl 0x82e15030
	ctx.lr = 0x82A82A98;
	sub_82E15030(ctx, base);
	// 82A82A98: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82A9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82AA0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A82AA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A82AA8: 4E800421  bctrl
	ctx.lr = 0x82A82AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82AAC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A82AB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A82AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82AB8: 419A000C  beq cr6, 0x82a82ac4
	if ctx.cr[6].eq {
	pc = 0x82A82AC4; continue 'dispatch;
	}
	// 82A82ABC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A82AC0: 4B83DDD1  bl 0x822c0890
	ctx.lr = 0x82A82AC4;
	sub_822C0890(ctx, base);
	// 82A82AC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82AC8: 48370961  bl 0x82df3428
	ctx.lr = 0x82A82ACC;
	sub_82DF3428(ctx, base);
	// 82A82ACC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A82AD0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A82AD4: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A82AD8: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A82ADC: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A82AE0: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A82AE4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A82AE8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A82AEC: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A82AF0: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A82AF4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A82B30 size=180
    let mut pc: u32 = 0x82A82B30;
    'dispatch: loop {
        match pc {
            0x82A82B30 => {
    //   block [0x82A82B30..0x82A82BE4)
	// 82A82B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82B38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82B3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82B40: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A82BE8 size=220
    let mut pc: u32 = 0x82A82BE8;
    'dispatch: loop {
        match pc {
            0x82A82BE8 => {
    //   block [0x82A82BE8..0x82A82CC4)
	// 82A82BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82BF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82BF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82BF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A82C00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A82C04: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A82C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82C0C: 419A008C  beq cr6, 0x82a82c98
	if ctx.cr[6].eq {
	pc = 0x82A82C98; continue 'dispatch;
	}
	// 82A82C10: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A82C14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82C18: 388B1FD8  addi r4, r11, 0x1fd8
	ctx.r[4].s64 = ctx.r[11].s64 + 8152;
	// 82A82C1C: 48370DED  bl 0x82df3a08
	ctx.lr = 0x82A82C20;
	sub_82DF3A08(ctx, base);
	// 82A82C20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A82C24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A82C28: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A82C2C: 48392405  bl 0x82e15030
	ctx.lr = 0x82A82C30;
	sub_82E15030(ctx, base);
	// 82A82C30: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82C34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82C38: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A82C3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A82C40: 4E800421  bctrl
	ctx.lr = 0x82A82C44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A82C44: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A82C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A82C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82C50: 419A000C  beq cr6, 0x82a82c5c
	if ctx.cr[6].eq {
	pc = 0x82A82C5C; continue 'dispatch;
	}
	// 82A82C54: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A82C58: 4B83DC39  bl 0x822c0890
	ctx.lr = 0x82A82C5C;
	sub_822C0890(ctx, base);
	// 82A82C5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82C60: 483707C9  bl 0x82df3428
	ctx.lr = 0x82A82C64;
	sub_82DF3428(ctx, base);
	// 82A82C64: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A82C68: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A82C6C: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A82C70: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A82C74: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A82C78: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A82C7C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A82C80: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A82C84: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A82C88: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A82C8C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A82CC8 size=104
    let mut pc: u32 = 0x82A82CC8;
    'dispatch: loop {
        match pc {
            0x82A82CC8 => {
    //   block [0x82A82CC8..0x82A82D30)
	// 82A82CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82CCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82CD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82CD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82CD8: 806300F4  lwz r3, 0xf4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A82CDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A82CE0: 4BE7CD11  bl 0x828ff9f0
	ctx.lr = 0x82A82CE4;
	sub_828FF9F0(ctx, base);
	// 82A82CE4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A82CE8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82CEC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82A82CF0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A82CF4: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82D30 size=72
    let mut pc: u32 = 0x82A82D30;
    'dispatch: loop {
        match pc {
            0x82A82D30 => {
    //   block [0x82A82D30..0x82A82D78)
	// 82A82D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82D38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82D3C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A82D40: 419A001C  beq cr6, 0x82a82d5c
	if ctx.cr[6].eq {
	pc = 0x82A82D5C; continue 'dispatch;
	}
	// 82A82D44: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A82D48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A82D4C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A82D50: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A82D54: 4BFFEBE5  bl 0x82a81938
	ctx.lr = 0x82A82D58;
	sub_82A81938(ctx, base);
	// 82A82D58: 48000010  b 0x82a82d68
	pc = 0x82A82D68; continue 'dispatch;
	// 82A82D5C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82D60: 396B9580  addi r11, r11, -0x6a80
	ctx.r[11].s64 = ctx.r[11].s64 + -27264;
	// 82A82D64: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82D68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A82D6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82D70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82D78 size=72
    let mut pc: u32 = 0x82A82D78;
    'dispatch: loop {
        match pc {
            0x82A82D78 => {
    //   block [0x82A82D78..0x82A82DC0)
	// 82A82D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82D80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82D84: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A82D88: 419A001C  beq cr6, 0x82a82da4
	if ctx.cr[6].eq {
	pc = 0x82A82DA4; continue 'dispatch;
	}
	// 82A82D8C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A82D90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A82D94: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A82D98: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A82D9C: 4BFFEC25  bl 0x82a819c0
	ctx.lr = 0x82A82DA0;
	sub_82A819C0(ctx, base);
	// 82A82DA0: 48000010  b 0x82a82db0
	pc = 0x82A82DB0; continue 'dispatch;
	// 82A82DA4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82DA8: 396B9658  addi r11, r11, -0x69a8
	ctx.r[11].s64 = ctx.r[11].s64 + -27048;
	// 82A82DAC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82DB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A82DB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82DB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82DBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82DC0 size=72
    let mut pc: u32 = 0x82A82DC0;
    'dispatch: loop {
        match pc {
            0x82A82DC0 => {
    //   block [0x82A82DC0..0x82A82E08)
	// 82A82DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82DC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82DCC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A82DD0: 419A001C  beq cr6, 0x82a82dec
	if ctx.cr[6].eq {
	pc = 0x82A82DEC; continue 'dispatch;
	}
	// 82A82DD4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A82DD8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A82DDC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A82DE0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A82DE4: 4BFFEC6D  bl 0x82a81a50
	ctx.lr = 0x82A82DE8;
	sub_82A81A50(ctx, base);
	// 82A82DE8: 48000010  b 0x82a82df8
	pc = 0x82A82DF8; continue 'dispatch;
	// 82A82DEC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82DF0: 396B9718  addi r11, r11, -0x68e8
	ctx.r[11].s64 = ctx.r[11].s64 + -26856;
	// 82A82DF4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A82DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82E08 size=72
    let mut pc: u32 = 0x82A82E08;
    'dispatch: loop {
        match pc {
            0x82A82E08 => {
    //   block [0x82A82E08..0x82A82E50)
	// 82A82E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82E10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82E14: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A82E18: 419A001C  beq cr6, 0x82a82e34
	if ctx.cr[6].eq {
	pc = 0x82A82E34; continue 'dispatch;
	}
	// 82A82E1C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A82E20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A82E24: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A82E28: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A82E2C: 4BFFECAD  bl 0x82a81ad8
	ctx.lr = 0x82A82E30;
	sub_82A81AD8(ctx, base);
	// 82A82E30: 48000010  b 0x82a82e40
	pc = 0x82A82E40; continue 'dispatch;
	// 82A82E34: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A82E38: 396B97C0  addi r11, r11, -0x6840
	ctx.r[11].s64 = ctx.r[11].s64 + -26688;
	// 82A82E3C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A82E40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A82E44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A82E48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A82E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A82E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A82E50 size=1100
    let mut pc: u32 = 0x82A82E50;
    'dispatch: loop {
        match pc {
            0x82A82E50 => {
    //   block [0x82A82E50..0x82A8329C)
	// 82A82E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A82E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A82E58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A82E5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A82E60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A82E64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A82E68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A82E6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A82E70: 388B1FF4  addi r4, r11, 0x1ff4
	ctx.r[4].s64 = ctx.r[11].s64 + 8180;
	// 82A82E74: 48370B95  bl 0x82df3a08
	ctx.lr = 0x82A82E78;
	sub_82DF3A08(ctx, base);
	// 82A82E78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A82E7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82E80: 388B1FE0  addi r4, r11, 0x1fe0
	ctx.r[4].s64 = ctx.r[11].s64 + 8160;
	// 82A82E84: 48370B85  bl 0x82df3a08
	ctx.lr = 0x82A82E88;
	sub_82DF3A08(ctx, base);
	// 82A82E88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A82E8C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82E90: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A82E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82E98: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A82E9C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A82EA0: 419A0024  beq cr6, 0x82a82ec4
	if ctx.cr[6].eq {
	pc = 0x82A82EC4; continue 'dispatch;
	}
	// 82A82EA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A82EA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A82EAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82EB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A82EB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A82EB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A82EBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82EC0: 4082FFE8  bne 0x82a82ea8
	if !ctx.cr[0].eq {
	pc = 0x82A82EA8; continue 'dispatch;
	}
	// 82A82EC4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A82EC8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A82ECC: 386BE118  addi r3, r11, -0x1ee8
	ctx.r[3].s64 = ctx.r[11].s64 + -7912;
	// 82A82ED0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A82ED4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A82ED8: 4B9311D1  bl 0x823b40a8
	ctx.lr = 0x82A82EDC;
	sub_823B40A8(ctx, base);
	// 82A82EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A82EE0: 48370549  bl 0x82df3428
	ctx.lr = 0x82A82EE4;
	sub_82DF3428(ctx, base);
	// 82A82EE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A82EE8: 48370541  bl 0x82df3428
	ctx.lr = 0x82A82EEC;
	sub_82DF3428(ctx, base);
	// 82A82EEC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82EF0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82EF8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A82EFC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A82F00: 419A0024  beq cr6, 0x82a82f24
	if ctx.cr[6].eq {
	pc = 0x82A82F24; continue 'dispatch;
	}
	// 82A82F04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A82F08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A82F0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82F10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A82F14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A82F18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A82F1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82F20: 4082FFE8  bne 0x82a82f08
	if !ctx.cr[0].eq {
	pc = 0x82A82F08; continue 'dispatch;
	}
	// 82A82F24: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A82F28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A82F2C: 386BE0D8  addi r3, r11, -0x1f28
	ctx.r[3].s64 = ctx.r[11].s64 + -7976;
	// 82A82F30: 48007C31  bl 0x82a8ab60
	ctx.lr = 0x82A82F34;
	sub_82A8AB60(ctx, base);
	// 82A82F34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82F38: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82F40: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A82F44: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A82F48: 419A0024  beq cr6, 0x82a82f6c
	if ctx.cr[6].eq {
	pc = 0x82A82F6C; continue 'dispatch;
	}
	// 82A82F4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A82F50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A82F54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82F58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A82F5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A82F60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A82F64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82F68: 4082FFE8  bne 0x82a82f50
	if !ctx.cr[0].eq {
	pc = 0x82A82F50; continue 'dispatch;
	}
	// 82A82F6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A82F70: 480072B9  bl 0x82a8a228
	ctx.lr = 0x82A82F74;
	sub_82A8A228(ctx, base);
	// 82A82F74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82F78: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82F80: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A82F84: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A82F88: 419A0024  beq cr6, 0x82a82fac
	if ctx.cr[6].eq {
	pc = 0x82A82FAC; continue 'dispatch;
	}
	// 82A82F8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A82F90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A82F94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82F98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A82F9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A82FA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A82FA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82FA8: 4082FFE8  bne 0x82a82f90
	if !ctx.cr[0].eq {
	pc = 0x82A82F90; continue 'dispatch;
	}
	// 82A82FAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A82FB0: 48018C81  bl 0x82a9bc30
	ctx.lr = 0x82A82FB4;
	sub_82A9BC30(ctx, base);
	// 82A82FB4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82FB8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A82FC0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A82FC4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A82FC8: 419A0024  beq cr6, 0x82a82fec
	if ctx.cr[6].eq {
	pc = 0x82A82FEC; continue 'dispatch;
	}
	// 82A82FCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A82FD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A82FD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82FD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A82FDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A82FE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A82FE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A82FE8: 4082FFE8  bne 0x82a82fd0
	if !ctx.cr[0].eq {
	pc = 0x82A82FD0; continue 'dispatch;
	}
	// 82A82FEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A82FF0: 48019A29  bl 0x82a9ca18
	ctx.lr = 0x82A82FF4;
	sub_82A9CA18(ctx, base);
	// 82A82FF4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82FF8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A82FFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83000: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83004: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83008: 419A0024  beq cr6, 0x82a8302c
	if ctx.cr[6].eq {
	pc = 0x82A8302C; continue 'dispatch;
	}
	// 82A8300C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83010: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83014: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83018: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8301C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83020: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83024: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83028: 4082FFE8  bne 0x82a83010
	if !ctx.cr[0].eq {
	pc = 0x82A83010; continue 'dispatch;
	}
	// 82A8302C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83030: 48024FC9  bl 0x82aa7ff8
	ctx.lr = 0x82A83034;
	sub_82AA7FF8(ctx, base);
	// 82A83034: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83038: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8303C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83040: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83044: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83048: 419A0024  beq cr6, 0x82a8306c
	if ctx.cr[6].eq {
	pc = 0x82A8306C; continue 'dispatch;
	}
	// 82A8304C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83050: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83054: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83058: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8305C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83060: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83064: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83068: 4082FFE8  bne 0x82a83050
	if !ctx.cr[0].eq {
	pc = 0x82A83050; continue 'dispatch;
	}
	// 82A8306C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83070: 48020E21  bl 0x82aa3e90
	ctx.lr = 0x82A83074;
	sub_82AA3E90(ctx, base);
	// 82A83074: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83078: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8307C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83080: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83084: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83088: 419A0024  beq cr6, 0x82a830ac
	if ctx.cr[6].eq {
	pc = 0x82A830AC; continue 'dispatch;
	}
	// 82A8308C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83090: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83094: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83098: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8309C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A830A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A830A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A830A8: 4082FFE8  bne 0x82a83090
	if !ctx.cr[0].eq {
	pc = 0x82A83090; continue 'dispatch;
	}
	// 82A830AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A830B0: 48026211  bl 0x82aa92c0
	ctx.lr = 0x82A830B4;
	sub_82AA92C0(ctx, base);
	// 82A830B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A830B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A830BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A830C0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A830C4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A830C8: 419A0024  beq cr6, 0x82a830ec
	if ctx.cr[6].eq {
	pc = 0x82A830EC; continue 'dispatch;
	}
	// 82A830CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A830D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A830D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A830D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A830DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A830E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A830E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A830E8: 4082FFE8  bne 0x82a830d0
	if !ctx.cr[0].eq {
	pc = 0x82A830D0; continue 'dispatch;
	}
	// 82A830EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A830F0: 48015C21  bl 0x82a98d10
	ctx.lr = 0x82A830F4;
	sub_82A98D10(ctx, base);
	// 82A830F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A830F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A830FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83100: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83104: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83108: 419A0024  beq cr6, 0x82a8312c
	if ctx.cr[6].eq {
	pc = 0x82A8312C; continue 'dispatch;
	}
	// 82A8310C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83110: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83114: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83118: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8311C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83120: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83124: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83128: 4082FFE8  bne 0x82a83110
	if !ctx.cr[0].eq {
	pc = 0x82A83110; continue 'dispatch;
	}
	// 82A8312C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83130: 48017641  bl 0x82a9a770
	ctx.lr = 0x82A83134;
	sub_82A9A770(ctx, base);
	// 82A83134: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83138: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8313C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83140: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83144: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83148: 419A0024  beq cr6, 0x82a8316c
	if ctx.cr[6].eq {
	pc = 0x82A8316C; continue 'dispatch;
	}
	// 82A8314C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83150: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83158: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8315C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83160: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83164: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83168: 4082FFE8  bne 0x82a83150
	if !ctx.cr[0].eq {
	pc = 0x82A83150; continue 'dispatch;
	}
	// 82A8316C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83170: 4801CC51  bl 0x82a9fdc0
	ctx.lr = 0x82A83174;
	sub_82A9FDC0(ctx, base);
	// 82A83174: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83178: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8317C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83180: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83184: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83188: 419A0024  beq cr6, 0x82a831ac
	if ctx.cr[6].eq {
	pc = 0x82A831AC; continue 'dispatch;
	}
	// 82A8318C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83190: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83194: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83198: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8319C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A831A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A831A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A831A8: 4082FFE8  bne 0x82a83190
	if !ctx.cr[0].eq {
	pc = 0x82A83190; continue 'dispatch;
	}
	// 82A831AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A831B0: 4801B441  bl 0x82a9e5f0
	ctx.lr = 0x82A831B4;
	sub_82A9E5F0(ctx, base);
	// 82A831B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A831B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A831BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A831C0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A831C4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A831C8: 419A0024  beq cr6, 0x82a831ec
	if ctx.cr[6].eq {
	pc = 0x82A831EC; continue 'dispatch;
	}
	// 82A831CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A831D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A831D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A831D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A831DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A831E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A831E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A831E8: 4082FFE8  bne 0x82a831d0
	if !ctx.cr[0].eq {
	pc = 0x82A831D0; continue 'dispatch;
	}
	// 82A831EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A831F0: 4801E8D9  bl 0x82aa1ac8
	ctx.lr = 0x82A831F4;
	sub_82AA1AC8(ctx, base);
	// 82A831F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A831F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A831FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83200: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83204: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83208: 419A0024  beq cr6, 0x82a8322c
	if ctx.cr[6].eq {
	pc = 0x82A8322C; continue 'dispatch;
	}
	// 82A8320C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83210: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83218: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8321C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83220: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83224: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83228: 4082FFE8  bne 0x82a83210
	if !ctx.cr[0].eq {
	pc = 0x82A83210; continue 'dispatch;
	}
	// 82A8322C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83230: 48022A59  bl 0x82aa5c88
	ctx.lr = 0x82A83234;
	sub_82AA5C88(ctx, base);
	// 82A83234: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83238: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8323C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83240: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83244: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A83248: 419A0024  beq cr6, 0x82a8326c
	if ctx.cr[6].eq {
	pc = 0x82A8326C; continue 'dispatch;
	}
	// 82A8324C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83250: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83254: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83258: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8325C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83260: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83264: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83268: 4082FFE8  bne 0x82a83250
	if !ctx.cr[0].eq {
	pc = 0x82A83250; continue 'dispatch;
	}
	// 82A8326C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83270: 48023CA9  bl 0x82aa6f18
	ctx.lr = 0x82A83274;
	sub_82AA6F18(ctx, base);
	// 82A83274: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8327C: 419A0008  beq cr6, 0x82a83284
	if ctx.cr[6].eq {
	pc = 0x82A83284; continue 'dispatch;
	}
	// 82A83280: 4B83D611  bl 0x822c0890
	ctx.lr = 0x82A83284;
	sub_822C0890(ctx, base);
	// 82A83284: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A83288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8328C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A83290: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A83294: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A83298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A832A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A832A0 size=52
    let mut pc: u32 = 0x82A832A0;
    'dispatch: loop {
        match pc {
            0x82A832A0 => {
    //   block [0x82A832A0..0x82A832D4)
	// 82A832A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A832A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A832A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A832AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A832B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A832B4: 4BE860FD  bl 0x829093b0
	ctx.lr = 0x82A832B8;
	sub_829093B0(ctx, base);
	// 82A832B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A832BC: 917F03DC  stw r11, 0x3dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(988 as u32), ctx.r[11].u32 ) };
	// 82A832C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A832C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A832C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A832CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A832D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A832D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A832D8 size=68
    let mut pc: u32 = 0x82A832D8;
    'dispatch: loop {
        match pc {
            0x82A832D8 => {
    //   block [0x82A832D8..0x82A8331C)
	// 82A832D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A832DC: 48724E91  bl 0x831a816c
	ctx.lr = 0x82A832E0;
	sub_831A8130(ctx, base);
	// 82A832E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A832E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A832E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A832EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A832F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A832F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A832F8: 4BB08C19  bl 0x8258bf10
	ctx.lr = 0x82A832FC;
	sub_8258BF10(ctx, base);
	// 82A832FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A83300: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A83304: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A83308: 4BA8DB39  bl 0x82510e40
	ctx.lr = 0x82A8330C;
	sub_82510E40(ctx, base);
	// 82A8330C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A83310: 4B8459A9  bl 0x822c8cb8
	ctx.lr = 0x82A83314;
	sub_822C8CB8(ctx, base);
	// 82A83314: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A83318: 48724EA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A83320 size=148
    let mut pc: u32 = 0x82A83320;
    'dispatch: loop {
        match pc {
            0x82A83320 => {
    //   block [0x82A83320..0x82A833B4)
	// 82A83320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83324: 48724E45  bl 0x831a8168
	ctx.lr = 0x82A83328;
	sub_831A8130(ctx, base);
	// 82A83328: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8332C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A83330: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A83334: 3BFD0380  addi r31, r29, 0x380
	ctx.r[31].s64 = ctx.r[29].s64 + 896;
	// 82A83338: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82A8333C: 817D0380  lwz r11, 0x380(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(896 as u32) ) } as u64;
	// 82A83340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83344: 419A0030  beq cr6, 0x82a83374
	if ctx.cr[6].eq {
	pc = 0x82A83374; continue 'dispatch;
	}
	// 82A83348: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A8334C: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A83350: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A83354: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 82A83358: 4BA8CE99  bl 0x825101f0
	ctx.lr = 0x82A8335C;
	sub_825101F0(ctx, base);
	// 82A8335C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A83360: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A83364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83368: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A8336C: 419A0008  beq cr6, 0x82a83374
	if ctx.cr[6].eq {
	pc = 0x82A83374; continue 'dispatch;
	}
	// 82A83370: 4B83D521  bl 0x822c0890
	ctx.lr = 0x82A83374;
	sub_822C0890(ctx, base);
	// 82A83374: 817D0388  lwz r11, 0x388(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 82A83378: 38BD0388  addi r5, r29, 0x388
	ctx.r[5].s64 = ctx.r[29].s64 + 904;
	// 82A8337C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83380: 419A002C  beq cr6, 0x82a833ac
	if ctx.cr[6].eq {
	pc = 0x82A833AC; continue 'dispatch;
	}
	// 82A83384: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A83388: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A8338C: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 82A83390: 4BA8CE61  bl 0x825101f0
	ctx.lr = 0x82A83394;
	sub_825101F0(ctx, base);
	// 82A83394: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A83398: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8339C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A833A0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A833A4: 419A0008  beq cr6, 0x82a833ac
	if ctx.cr[6].eq {
	pc = 0x82A833AC; continue 'dispatch;
	}
	// 82A833A8: 4B83D4E9  bl 0x822c0890
	ctx.lr = 0x82A833AC;
	sub_822C0890(ctx, base);
	// 82A833AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A833B0: 48724E08  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A833B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A833B8 size=416
    let mut pc: u32 = 0x82A833B8;
    'dispatch: loop {
        match pc {
            0x82A833B8 => {
    //   block [0x82A833B8..0x82A83558)
	// 82A833B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A833BC: 48724DAD  bl 0x831a8168
	ctx.lr = 0x82A833C0;
	sub_831A8130(ctx, base);
	// 82A833C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A833C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A833C8: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A833CC: 4BE7C625  bl 0x828ff9f0
	ctx.lr = 0x82A833D0;
	sub_828FF9F0(ctx, base);
	// 82A833D0: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 82A833D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A833D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A833DC: 4BF902A5  bl 0x82a13680
	ctx.lr = 0x82A833E0;
	sub_82A13680(ctx, base);
	// 82A833E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A833E4: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82A833E8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A833EC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A833F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A833F4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A833F8: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A83558 size=212
    let mut pc: u32 = 0x82A83558;
    'dispatch: loop {
        match pc {
            0x82A83558 => {
    //   block [0x82A83558..0x82A8362C)
	// 82A83558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8355C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A83560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A83564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A83568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8356C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A83570: 817F03A8  lwz r11, 0x3a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 82A83574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83578: 419A009C  beq cr6, 0x82a83614
	if ctx.cr[6].eq {
	pc = 0x82A83614; continue 'dispatch;
	}
	// 82A8357C: 817F03AC  lwz r11, 0x3ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) } as u64;
	// 82A83580: 815F03A8  lwz r10, 0x3a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 82A83584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83588: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8358C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A83590: 419A0024  beq cr6, 0x82a835b4
	if ctx.cr[6].eq {
	pc = 0x82A835B4; continue 'dispatch;
	}
	// 82A83594: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83598: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A8359C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A835A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A835A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A835A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A835AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A835B0: 4082FFE8  bne 0x82a83598
	if !ctx.cr[0].eq {
	pc = 0x82A83598; continue 'dispatch;
	}
	// 82A835B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A835B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A835BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A835C0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A835C4: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A835C8: 4BA8CAF9  bl 0x825100c0
	ctx.lr = 0x82A835CC;
	sub_825100C0(ctx, base);
	// 82A835CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A835D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A835D4: 419A0008  beq cr6, 0x82a835dc
	if ctx.cr[6].eq {
	pc = 0x82A835DC; continue 'dispatch;
	}
	// 82A835D8: 4B83D2B9  bl 0x822c0890
	ctx.lr = 0x82A835DC;
	sub_822C0890(ctx, base);
	// 82A835DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A835E0: 93DF03A8  stw r30, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[30].u32 ) };
	// 82A835E4: 807F03AC  lwz r3, 0x3ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) } as u64;
	// 82A835E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A835EC: 93DF03AC  stw r30, 0x3ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), ctx.r[30].u32 ) };
	// 82A835F0: 419A0008  beq cr6, 0x82a835f8
	if ctx.cr[6].eq {
	pc = 0x82A835F8; continue 'dispatch;
	}
	// 82A835F4: 4B83D29D  bl 0x822c0890
	ctx.lr = 0x82A835F8;
	sub_822C0890(ctx, base);
	// 82A835F8: 93DF03B0  stw r30, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[30].u32 ) };
	// 82A835FC: 397F03B0  addi r11, r31, 0x3b0
	ctx.r[11].s64 = ctx.r[31].s64 + 944;
	// 82A83600: 807F03B4  lwz r3, 0x3b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 82A83604: 93DF03B4  stw r30, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[30].u32 ) };
	// 82A83608: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8360C: 419A0008  beq cr6, 0x82a83614
	if ctx.cr[6].eq {
	pc = 0x82A83614; continue 'dispatch;
	}
	// 82A83610: 4B83D281  bl 0x822c0890
	ctx.lr = 0x82A83614;
	sub_822C0890(ctx, base);
	// 82A83614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A83618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8361C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A83620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A83624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A83628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A83630 size=112
    let mut pc: u32 = 0x82A83630;
    'dispatch: loop {
        match pc {
            0x82A83630 => {
    //   block [0x82A83630..0x82A836A0)
	// 82A83630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A83638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8363C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A83640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A83644: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A83648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8364C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A83650: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A83654: 4BFFEA6D  bl 0x82a820c0
	ctx.lr = 0x82A83658;
	sub_82A820C0(ctx, base);
	// 82A83658: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A8365C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A83660: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A83664: 4B83C99D  bl 0x822c0000
	ctx.lr = 0x82A83668;
	sub_822C0000(ctx, base);
	// 82A83668: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8366C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A83670: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A83674: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A83678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8367C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A83680: 419A0008  beq cr6, 0x82a83688
	if ctx.cr[6].eq {
	pc = 0x82A83688; continue 'dispatch;
	}
	// 82A83684: 4B83D20D  bl 0x822c0890
	ctx.lr = 0x82A83688;
	sub_822C0890(ctx, base);
	// 82A83688: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8368C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A83690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A83694: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A83698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8369C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A836A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A836A0 size=112
    let mut pc: u32 = 0x82A836A0;
    'dispatch: loop {
        match pc {
            0x82A836A0 => {
    //   block [0x82A836A0..0x82A83710)
	// 82A836A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A836A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A836A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A836AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A836B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A836B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A836B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A836BC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A836C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A836C4: 4BFFEAC5  bl 0x82a82188
	ctx.lr = 0x82A836C8;
	sub_82A82188(ctx, base);
	// 82A836C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A836CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A836D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A836D4: 4B83C92D  bl 0x822c0000
	ctx.lr = 0x82A836D8;
	sub_822C0000(ctx, base);
	// 82A836D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A836DC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A836E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A836E4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A836E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A836EC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A836F0: 419A0008  beq cr6, 0x82a836f8
	if ctx.cr[6].eq {
	pc = 0x82A836F8; continue 'dispatch;
	}
	// 82A836F4: 4B83D19D  bl 0x822c0890
	ctx.lr = 0x82A836F8;
	sub_822C0890(ctx, base);
	// 82A836F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A836FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A83700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A83704: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A83708: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8370C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A83710 size=112
    let mut pc: u32 = 0x82A83710;
    'dispatch: loop {
        match pc {
            0x82A83710 => {
    //   block [0x82A83710..0x82A83780)
	// 82A83710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A83718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8371C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A83720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A83724: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A83728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8372C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A83730: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A83734: 4BFFEB1D  bl 0x82a82250
	ctx.lr = 0x82A83738;
	sub_82A82250(ctx, base);
	// 82A83738: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A8373C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A83740: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A83744: 4B83C8BD  bl 0x822c0000
	ctx.lr = 0x82A83748;
	sub_822C0000(ctx, base);
	// 82A83748: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8374C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A83750: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A83754: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A83758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8375C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A83760: 419A0008  beq cr6, 0x82a83768
	if ctx.cr[6].eq {
	pc = 0x82A83768; continue 'dispatch;
	}
	// 82A83764: 4B83D12D  bl 0x822c0890
	ctx.lr = 0x82A83768;
	sub_822C0890(ctx, base);
	// 82A83768: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8376C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A83770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A83774: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A83778: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8377C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A83780 size=128
    let mut pc: u32 = 0x82A83780;
    'dispatch: loop {
        match pc {
            0x82A83780 => {
    //   block [0x82A83780..0x82A83800)
	// 82A83780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83784: 487249E9  bl 0x831a816c
	ctx.lr = 0x82A83788;
	sub_831A8130(ctx, base);
	// 82A83788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8378C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A83790: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A83794: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A83798: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A8379C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A837A0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A837A4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A837A8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82A837AC: 4836EC3D  bl 0x82df23e8
	ctx.lr = 0x82A837B0;
	sub_82DF23E8(ctx, base);
	// 82A837B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A837B4: 41820018  beq 0x82a837cc
	if ctx.cr[0].eq {
	pc = 0x82A837CC; continue 'dispatch;
	}
	// 82A837B8: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A837BC: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A837C0: 4BF00E29  bl 0x829845e8
	ctx.lr = 0x82A837C4;
	sub_829845E8(ctx, base);
	// 82A837C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A837C8: 48000008  b 0x82a837d0
	pc = 0x82A837D0; continue 'dispatch;
	// 82A837CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A837D0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A837D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A837D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A837DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A837E0: 4BFFEB39  bl 0x82a82318
	ctx.lr = 0x82A837E4;
	sub_82A82318(ctx, base);
	// 82A837E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A837E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A837EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A837F0: 4B83C811  bl 0x822c0000
	ctx.lr = 0x82A837F4;
	sub_822C0000(ctx, base);
	// 82A837F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A837F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A837FC: 487249C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A83800 size=120
    let mut pc: u32 = 0x82A83800;
    'dispatch: loop {
        match pc {
            0x82A83800 => {
    //   block [0x82A83800..0x82A83878)
	// 82A83800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83804: 48724969  bl 0x831a816c
	ctx.lr = 0x82A83808;
	sub_831A8130(ctx, base);
	// 82A83808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8380C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A83810: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A83814: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A83818: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A8381C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A83820: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A83824: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A83828: 4836EBC1  bl 0x82df23e8
	ctx.lr = 0x82A8382C;
	sub_82DF23E8(ctx, base);
	// 82A8382C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A83830: 41820014  beq 0x82a83844
	if ctx.cr[0].eq {
	pc = 0x82A83844; continue 'dispatch;
	}
	// 82A83834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A83838: 480CFEF9  bl 0x82b53730
	ctx.lr = 0x82A8383C;
	sub_82B53730(ctx, base);
	// 82A8383C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A83840: 48000008  b 0x82a83848
	pc = 0x82A83848; continue 'dispatch;
	// 82A83844: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A83848: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A8384C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A83850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A83854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A83858: 4BFFEB89  bl 0x82a823e0
	ctx.lr = 0x82A8385C;
	sub_82A823E0(ctx, base);
	// 82A8385C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A83860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A83864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A83868: 4B83C799  bl 0x822c0000
	ctx.lr = 0x82A8386C;
	sub_822C0000(ctx, base);
	// 82A8386C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A83870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A83874: 48724948  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A83878 size=112
    let mut pc: u32 = 0x82A83878;
    'dispatch: loop {
        match pc {
            0x82A83878 => {
    //   block [0x82A83878..0x82A838E8)
	// 82A83878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8387C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A83880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A83884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A83888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8388C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A83890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A83894: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A83898: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8389C: 4BFFEC0D  bl 0x82a824a8
	ctx.lr = 0x82A838A0;
	sub_82A824A8(ctx, base);
	// 82A838A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A838A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A838A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A838AC: 4B83C755  bl 0x822c0000
	ctx.lr = 0x82A838B0;
	sub_822C0000(ctx, base);
	// 82A838B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A838B4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A838B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A838BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A838C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A838C4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A838C8: 419A0008  beq cr6, 0x82a838d0
	if ctx.cr[6].eq {
	pc = 0x82A838D0; continue 'dispatch;
	}
	// 82A838CC: 4B83CFC5  bl 0x822c0890
	ctx.lr = 0x82A838D0;
	sub_822C0890(ctx, base);
	// 82A838D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A838D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A838D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A838DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A838E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A838E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A838E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A838E8 size=180
    let mut pc: u32 = 0x82A838E8;
    'dispatch: loop {
        match pc {
            0x82A838E8 => {
    //   block [0x82A838E8..0x82A8399C)
	// 82A838E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A838EC: 48724875  bl 0x831a8160
	ctx.lr = 0x82A838F0;
	sub_831A8130(ctx, base);
	// 82A838F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A838F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A838F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A838FC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A83900: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A83904: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A83908: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A8390C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A83910: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A83914: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A83918: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A8391C: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82A83920: 4836EAC9  bl 0x82df23e8
	ctx.lr = 0x82A83924;
	sub_82DF23E8(ctx, base);
	// 82A83924: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A83928: 41820030  beq 0x82a83958
	if ctx.cr[0].eq {
	pc = 0x82A83958; continue 'dispatch;
	}
	// 82A8392C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A83930: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83934: 483700D5  bl 0x82df3a08
	ctx.lr = 0x82A83938;
	sub_82DF3A08(ctx, base);
	// 82A83938: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8393C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A83940: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83944: 88BC0000  lbz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83948: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A8394C: 480D81A5  bl 0x82b5baf0
	ctx.lr = 0x82A83950;
	sub_82B5BAF0(ctx, base);
	// 82A83950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A83954: 48000008  b 0x82a8395c
	pc = 0x82A8395C; continue 'dispatch;
	// 82A83958: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A8395C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A83960: 3BBA0004  addi r29, r26, 4
	ctx.r[29].s64 = ctx.r[26].s64 + 4;
	// 82A83964: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A83968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8396C: 4B9CA555  bl 0x8244dec0
	ctx.lr = 0x82A83970;
	sub_8244DEC0(ctx, base);
	// 82A83970: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A83974: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A83978: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8397C: 4B83C685  bl 0x822c0000
	ctx.lr = 0x82A83980;
	sub_822C0000(ctx, base);
	// 82A83980: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A83984: 4182000C  beq 0x82a83990
	if ctx.cr[0].eq {
	pc = 0x82A83990; continue 'dispatch;
	}
	// 82A83988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8398C: 4836FA9D  bl 0x82df3428
	ctx.lr = 0x82A83990;
	sub_82DF3428(ctx, base);
	// 82A83990: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A83994: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A83998: 48724818  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A839A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A839A0 size=112
    let mut pc: u32 = 0x82A839A0;
    'dispatch: loop {
        match pc {
            0x82A839A0 => {
    //   block [0x82A839A0..0x82A83A10)
	// 82A839A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A839A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A839A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A839AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A839B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A839B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A839B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A839BC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A839C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A839C4: 4BFFEBAD  bl 0x82a82570
	ctx.lr = 0x82A839C8;
	sub_82A82570(ctx, base);
	// 82A839C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A839CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A839D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A839D4: 4B83C62D  bl 0x822c0000
	ctx.lr = 0x82A839D8;
	sub_822C0000(ctx, base);
	// 82A839D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A839DC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A839E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A839E4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A839E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A839EC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A839F0: 419A0008  beq cr6, 0x82a839f8
	if ctx.cr[6].eq {
	pc = 0x82A839F8; continue 'dispatch;
	}
	// 82A839F4: 4B83CE9D  bl 0x822c0890
	ctx.lr = 0x82A839F8;
	sub_822C0890(ctx, base);
	// 82A839F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A839FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A83A00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A83A04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A83A08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A83A0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A83A10 size=224
    let mut pc: u32 = 0x82A83A10;
    'dispatch: loop {
        match pc {
            0x82A83A10 => {
    //   block [0x82A83A10..0x82A83AF0)
	// 82A83A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83A14: 48724759  bl 0x831a816c
	ctx.lr = 0x82A83A18;
	sub_831A8130(ctx, base);
	// 82A83A18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A83A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A83A20: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A83A24: 4BD686FD  bl 0x827ec120
	ctx.lr = 0x82A83A28;
	sub_827EC120(ctx, base);
	// 82A83A28: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 82A83A2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83A30: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A83A34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A83A38: 4E800421  bctrl
	ctx.lr = 0x82A83A3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A83A3C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82A83A40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A83A44: 4BA84C3D  bl 0x82508680
	ctx.lr = 0x82A83A48;
	sub_82508680(ctx, base);
	// 82A83A48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A83A4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83A50: 4BDF2CD9  bl 0x82876728
	ctx.lr = 0x82A83A54;
	sub_82876728(ctx, base);
	// 82A83A54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83A58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A83A5C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A83A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83A64: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A83A68: 419A0024  beq cr6, 0x82a83a8c
	if ctx.cr[6].eq {
	pc = 0x82A83A8C; continue 'dispatch;
	}
	// 82A83A6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83A70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83A74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83A78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A83A7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83A80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83A84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83A88: 4082FFE8  bne 0x82a83a70
	if !ctx.cr[0].eq {
	pc = 0x82A83A70; continue 'dispatch;
	}
	// 82A83A8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A83A90: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A83A94: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A83A98: 388A2010  addi r4, r10, 0x2010
	ctx.r[4].s64 = ctx.r[10].s64 + 8208;
	// 82A83A9C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A83AA0: 38A001E1  li r5, 0x1e1
	ctx.r[5].s64 = 481;
	// 82A83AA4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A83AA8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A83AAC: 483D4F95  bl 0x82e58a40
	ctx.lr = 0x82A83AB0;
	sub_82E58A40(ctx, base);
	// 82A83AB0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A83AB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83AB8: 419A0008  beq cr6, 0x82a83ac0
	if ctx.cr[6].eq {
	pc = 0x82A83AC0; continue 'dispatch;
	}
	// 82A83ABC: 4B83CDD5  bl 0x822c0890
	ctx.lr = 0x82A83AC0;
	sub_822C0890(ctx, base);
	// 82A83AC0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A83AC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83AC8: 419A0008  beq cr6, 0x82a83ad0
	if ctx.cr[6].eq {
	pc = 0x82A83AD0; continue 'dispatch;
	}
	// 82A83ACC: 4B83CDC5  bl 0x822c0890
	ctx.lr = 0x82A83AD0;
	sub_822C0890(ctx, base);
	// 82A83AD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A83AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A83AD8: 4BE8A659  bl 0x8290e130
	ctx.lr = 0x82A83ADC;
	sub_8290E130(ctx, base);
	// 82A83ADC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A83AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A83AE4: 4BE8D69D  bl 0x82911180
	ctx.lr = 0x82A83AE8;
	sub_82911180(ctx, base);
	// 82A83AE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A83AEC: 487246D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A83AF0 size=340
    let mut pc: u32 = 0x82A83AF0;
    'dispatch: loop {
        match pc {
            0x82A83AF0 => {
    //   block [0x82A83AF0..0x82A83C44)
	// 82A83AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83AF4: 48724671  bl 0x831a8164
	ctx.lr = 0x82A83AF8;
	sub_831A8130(ctx, base);
	// 82A83AF8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A83AFC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A83B00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A83B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A83B08: 3BAB2010  addi r29, r11, 0x2010
	ctx.r[29].s64 = ctx.r[11].s64 + 8208;
	// 82A83B0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A83B10: 38A002FA  li r5, 0x2fa
	ctx.r[5].s64 = 762;
	// 82A83B14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A83B18: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82A83B1C: 4836E8CD  bl 0x82df23e8
	ctx.lr = 0x82A83B20;
	sub_82DF23E8(ctx, base);
	// 82A83B20: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A83B24: 41820038  beq 0x82a83b5c
	if ctx.cr[0].eq {
	pc = 0x82A83B5C; continue 'dispatch;
	}
	// 82A83B28: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A83B2C: 839F0414  lwz r28, 0x414(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82A83B30: 4BE7BEC1  bl 0x828ff9f0
	ctx.lr = 0x82A83B34;
	sub_828FF9F0(ctx, base);
	// 82A83B34: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A83B38: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82A83B3C: 4858547D  bl 0x83008fb8
	ctx.lr = 0x82A83B40;
	sub_83008FB8(ctx, base);
	// 82A83B40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A83B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A83B48: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A83B4C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A83B50: 4B9E89F9  bl 0x8246c548
	ctx.lr = 0x82A83B54;
	sub_8246C548(ctx, base);
	// 82A83B54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A83B58: 48000008  b 0x82a83b60
	pc = 0x82A83B60; continue 'dispatch;
	// 82A83B5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A83B60: 3BDF03E0  addi r30, r31, 0x3e0
	ctx.r[30].s64 = ctx.r[31].s64 + 992;
	// 82A83B64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A83B68: 4BFFFD11  bl 0x82a83878
	ctx.lr = 0x82A83B6C;
	sub_82A83878(ctx, base);
	// 82A83B6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A83B70: 394007CF  li r10, 0x7cf
	ctx.r[10].s64 = 1999;
	// 82A83B74: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A83B78: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A83B7C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A83B80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A83B84: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A83B88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A83B8C: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A83B90: 4BBE5BC9  bl 0x82669758
	ctx.lr = 0x82A83B94;
	sub_82669758(ctx, base);
	// 82A83B94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83B98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A83B9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A83BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83BA4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83BA8: 419A0024  beq cr6, 0x82a83bcc
	if ctx.cr[6].eq {
	pc = 0x82A83BCC; continue 'dispatch;
	}
	// 82A83BAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83BB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83BB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83BB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A83BBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83BC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83BC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83BC8: 4082FFE8  bne 0x82a83bb0
	if !ctx.cr[0].eq {
	pc = 0x82A83BB0; continue 'dispatch;
	}
	// 82A83BCC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82A83BD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A83BD4: 4BA8B945  bl 0x8250f518
	ctx.lr = 0x82A83BD8;
	sub_8250F518(ctx, base);
	// 82A83BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83BE0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A83BE4: 409A0008  bne cr6, 0x82a83bec
	if !ctx.cr[6].eq {
	pc = 0x82A83BEC; continue 'dispatch;
	}
	// 82A83BE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A83BEC: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A83BF0: 4BAA4461  bl 0x82528050
	ctx.lr = 0x82A83BF4;
	sub_82528050(ctx, base);
	// 82A83BF4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A83BF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A83BFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A83C00: 38A002FE  li r5, 0x2fe
	ctx.r[5].s64 = 766;
	// 82A83C04: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82A83C08: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A83C0C: 483D4E35  bl 0x82e58a40
	ctx.lr = 0x82A83C10;
	sub_82E58A40(ctx, base);
	// 82A83C10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A83C14: 4836E07D  bl 0x82df1c90
	ctx.lr = 0x82A83C18;
	sub_82DF1C90(ctx, base);
	// 82A83C18: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A83C1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83C20: 419A0008  beq cr6, 0x82a83c28
	if ctx.cr[6].eq {
	pc = 0x82A83C28; continue 'dispatch;
	}
	// 82A83C24: 4B83CC6D  bl 0x822c0890
	ctx.lr = 0x82A83C28;
	sub_822C0890(ctx, base);
	// 82A83C28: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A83C2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83C30: 419A0008  beq cr6, 0x82a83c38
	if ctx.cr[6].eq {
	pc = 0x82A83C38; continue 'dispatch;
	}
	// 82A83C34: 4B83CC5D  bl 0x822c0890
	ctx.lr = 0x82A83C38;
	sub_822C0890(ctx, base);
	// 82A83C38: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A83C3C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A83C40: 48724574  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A83C48 size=268
    let mut pc: u32 = 0x82A83C48;
    'dispatch: loop {
        match pc {
            0x82A83C48 => {
    //   block [0x82A83C48..0x82A83D54)
	// 82A83C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83C4C: 48724521  bl 0x831a816c
	ctx.lr = 0x82A83C50;
	sub_831A8130(ctx, base);
	// 82A83C50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A83C54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A83C58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A83C5C: 817F03E0  lwz r11, 0x3e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(992 as u32) ) } as u64;
	// 82A83C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83C64: 419A00D0  beq cr6, 0x82a83d34
	if ctx.cr[6].eq {
	pc = 0x82A83D34; continue 'dispatch;
	}
	// 82A83C68: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A83C6C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A83C70: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A83C74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A83C78: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A83C7C: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A83C80: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A83C84: 4BDC298D  bl 0x82846610
	ctx.lr = 0x82A83C88;
	sub_82846610(ctx, base);
	// 82A83C88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83C8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A83C90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A83C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83C98: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A83C9C: 419A0024  beq cr6, 0x82a83cc0
	if ctx.cr[6].eq {
	pc = 0x82A83CC0; continue 'dispatch;
	}
	// 82A83CA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A83CA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A83CA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83CAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A83CB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A83CB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A83CB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A83CBC: 4082FFE8  bne 0x82a83ca4
	if !ctx.cr[0].eq {
	pc = 0x82A83CA4; continue 'dispatch;
	}
	// 82A83CC0: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82A83CC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A83CC8: 4BA8B851  bl 0x8250f518
	ctx.lr = 0x82A83CCC;
	sub_8250F518(ctx, base);
	// 82A83CCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83CD4: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A83CD8: 409A0008  bne cr6, 0x82a83ce0
	if !ctx.cr[6].eq {
	pc = 0x82A83CE0; continue 'dispatch;
	}
	// 82A83CDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A83CE0: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82A83CE4: 4BAA436D  bl 0x82528050
	ctx.lr = 0x82A83CE8;
	sub_82528050(ctx, base);
	// 82A83CE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A83CEC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A83CF0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A83CF4: 388A2010  addi r4, r10, 0x2010
	ctx.r[4].s64 = ctx.r[10].s64 + 8208;
	// 82A83CF8: 38A00307  li r5, 0x307
	ctx.r[5].s64 = 775;
	// 82A83CFC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82A83D00: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A83D04: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A83D08: 483D4D39  bl 0x82e58a40
	ctx.lr = 0x82A83D0C;
	sub_82E58A40(ctx, base);
	// 82A83D0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A83D10: 4836DF81  bl 0x82df1c90
	ctx.lr = 0x82A83D14;
	sub_82DF1C90(ctx, base);
	// 82A83D14: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A83D18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83D1C: 419A0008  beq cr6, 0x82a83d24
	if ctx.cr[6].eq {
	pc = 0x82A83D24; continue 'dispatch;
	}
	// 82A83D20: 4B83CB71  bl 0x822c0890
	ctx.lr = 0x82A83D24;
	sub_822C0890(ctx, base);
	// 82A83D24: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A83D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83D2C: 419A0008  beq cr6, 0x82a83d34
	if ctx.cr[6].eq {
	pc = 0x82A83D34; continue 'dispatch;
	}
	// 82A83D30: 4B83CB61  bl 0x822c0890
	ctx.lr = 0x82A83D34;
	sub_822C0890(ctx, base);
	// 82A83D34: 93DF03E0  stw r30, 0x3e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(992 as u32), ctx.r[30].u32 ) };
	// 82A83D38: 807F03E4  lwz r3, 0x3e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82A83D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A83D40: 93DF03E4  stw r30, 0x3e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), ctx.r[30].u32 ) };
	// 82A83D44: 419A0008  beq cr6, 0x82a83d4c
	if ctx.cr[6].eq {
	pc = 0x82A83D4C; continue 'dispatch;
	}
	// 82A83D48: 4B83CB49  bl 0x822c0890
	ctx.lr = 0x82A83D4C;
	sub_822C0890(ctx, base);
	// 82A83D4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A83D50: 4872446C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A83D58 size=460
    let mut pc: u32 = 0x82A83D58;
    'dispatch: loop {
        match pc {
            0x82A83D58 => {
    //   block [0x82A83D58..0x82A83F24)
	// 82A83D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83D5C: 48724405  bl 0x831a8160
	ctx.lr = 0x82A83D60;
	sub_831A8130(ctx, base);
	// 82A83D60: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A83D64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A83D68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A83D6C: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	// 82A83D70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A83D74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A83D78: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A83D7C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A83D80: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82A83D84: 4BA8B745  bl 0x8250f4c8
	ctx.lr = 0x82A83D88;
	sub_8250F4C8(ctx, base);
	// 82A83D88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A83D90: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A83D94: 409A0008  bne cr6, 0x82a83d9c
	if !ctx.cr[6].eq {
	pc = 0x82A83D9C; continue 'dispatch;
	}
	// 82A83D98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A83D9C: 4BA8478D  bl 0x82508528
	ctx.lr = 0x82A83DA0;
	sub_82508528(ctx, base);
	// 82A83DA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A83DA4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A83DA8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83DAC: 483A6D3D  bl 0x82e2aae8
	ctx.lr = 0x82A83DB0;
	sub_82E2AAE8(ctx, base);
	// 82A83DB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A83DB4: 4836DEDD  bl 0x82df1c90
	ctx.lr = 0x82A83DB8;
	sub_82DF1C90(ctx, base);
	// 82A83DB8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A83DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A83DC0: 4836FC49  bl 0x82df3a08
	ctx.lr = 0x82A83DC4;
	sub_82DF3A08(ctx, base);
	// 82A83DC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A83DC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A83DCC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A83DD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A83DD4: 483AB09D  bl 0x82e2ee70
	ctx.lr = 0x82A83DD8;
	sub_82E2EE70(ctx, base);
	// 82A83DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A83DDC: 4836F64D  bl 0x82df3428
	ctx.lr = 0x82A83DE0;
	sub_82DF3428(ctx, base);
	// 82A83DE0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A83DE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A83DE8: 388B2010  addi r4, r11, 0x2010
	ctx.r[4].s64 = ctx.r[11].s64 + 8208;
	// 82A83DEC: 38A003DC  li r5, 0x3dc
	ctx.r[5].s64 = 988;
	// 82A83DF0: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A83DF4: 4836E5F5  bl 0x82df23e8
	ctx.lr = 0x82A83DF8;
	sub_82DF23E8(ctx, base);
	// 82A83DF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A83DFC: 41820014  beq 0x82a83e10
	if ctx.cr[0].eq {
	pc = 0x82A83E10; continue 'dispatch;
	}
	// 82A83E00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A83E04: 48392A8D  bl 0x82e16890
	ctx.lr = 0x82A83E08;
	sub_82E16890(ctx, base);
	// 82A83E08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A83E0C: 48000008  b 0x82a83e14
	pc = 0x82A83E14; continue 'dispatch;
	// 82A83E10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A83E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A83E18: 4B8D9559  bl 0x8235d370
	ctx.lr = 0x82A83E1C;
	sub_8235D370(ctx, base);
	// 82A83E1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A83E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A83E24: 4836FBE5  bl 0x82df3a08
	ctx.lr = 0x82A83E28;
	sub_82DF3A08(ctx, base);
	// 82A83E28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A83E2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A83E30: 809E00FC  lwz r4, 0xfc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A83E34: 483911FD  bl 0x82e15030
	ctx.lr = 0x82A83E38;
	sub_82E15030(ctx, base);
	// 82A83E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A83E3C: 4836F5ED  bl 0x82df3428
	ctx.lr = 0x82A83E40;
	sub_82DF3428(ctx, base);
	// 82A83E40: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A83E44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83E48: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A83E4C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A83E50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A83E54: 4E800421  bctrl
	ctx.lr = 0x82A83E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A83E58: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A83E5C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A83E60: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A83E64: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82A83E68: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A83E6C: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82A83E70: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A83E74: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A83E78: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A83E7C: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A83E80: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A83F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A83F28 size=316
    let mut pc: u32 = 0x82A83F28;
    'dispatch: loop {
        match pc {
            0x82A83F28 => {
    //   block [0x82A83F28..0x82A84064)
	// 82A83F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A83F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A83F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A83F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A83F38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A83F3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A83F40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A83F44: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A83F48: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A83F4C: 41820028  beq 0x82a83f74
	if ctx.cr[0].eq {
	pc = 0x82A83F74; continue 'dispatch;
	}
	// 82A83F50: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82A83F54: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82A83F58: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82A83F5C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82A83F60: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A83F64: 13DF50C7  vcmpequd (lvx128) v30, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A84068 size=688
    let mut pc: u32 = 0x82A84068;
    'dispatch: loop {
        match pc {
            0x82A84068 => {
    //   block [0x82A84068..0x82A84318)
	// 82A84068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8406C: 487240F1  bl 0x831a815c
	ctx.lr = 0x82A84070;
	sub_831A8130(ctx, base);
	// 82A84070: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A84074: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84078: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A8407C: 83FD00F4  lwz r31, 0xf4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A84080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A84084: 4BE7B96D  bl 0x828ff9f0
	ctx.lr = 0x82A84088;
	sub_828FF9F0(ctx, base);
	// 82A84088: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8408C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A84090: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82A84094: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A84098: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A8409C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A840A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A840A4: 91010090  stw r8, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u32 ) };
	// 82A840A8: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A84318 size=8
    let mut pc: u32 = 0x82A84318;
    'dispatch: loop {
        match pc {
            0x82A84318 => {
    //   block [0x82A84318..0x82A84320)
	// 82A84318: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8431C: 4800004C  b 0x82a84368
	sub_82A84320(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A84320 size=88
    let mut pc: u32 = 0x82A84320;
    'dispatch: loop {
        match pc {
            0x82A84320 => {
    //   block [0x82A84320..0x82A84378)
	// 82A84320: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A84324: 419A003C  beq cr6, 0x82a84360
	if ctx.cr[6].eq {
	pc = 0x82A84360; continue 'dispatch;
	}
	// 82A84328: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8432C: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A84330: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A84334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A84338: 91450004  stw r10, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8433C: 419A0024  beq cr6, 0x82a84360
	if ctx.cr[6].eq {
	pc = 0x82A84360; continue 'dispatch;
	}
	// 82A84340: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A84344: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A84348: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8434C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A84350: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A84354: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A84358: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8435C: 4082FFE8  bne 0x82a84344
	if !ctx.cr[0].eq {
	pc = 0x82A84344; continue 'dispatch;
	}
	// 82A84360: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A84364: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82A84368: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A8436C: 409AFFB4  bne cr6, 0x82a84320
	if !ctx.cr[6].eq {
	pc = 0x82A84320; continue 'dispatch;
	}
	// 82A84370: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A84374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A84378 size=36
    let mut pc: u32 = 0x82A84378;
    'dispatch: loop {
        match pc {
            0x82A84378 => {
    //   block [0x82A84378..0x82A8439C)
	// 82A84378: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A8437C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A84380: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A84384: 80A90010  lwz r5, 0x10(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A84388: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A8438C: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A84390: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A84394: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A84398: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A843A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A843A0 size=100
    let mut pc: u32 = 0x82A843A0;
    'dispatch: loop {
        match pc {
            0x82A843A0 => {
    //   block [0x82A843A0..0x82A84404)
	// 82A843A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A843A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A843A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A843AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A843B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A843B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A843B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A843BC: 388B2010  addi r4, r11, 0x2010
	ctx.r[4].s64 = ctx.r[11].s64 + 8208;
	// 82A843C0: 38A00299  li r5, 0x299
	ctx.r[5].s64 = 665;
	// 82A843C4: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A843C8: 4B83C011  bl 0x822c03d8
	ctx.lr = 0x82A843CC;
	sub_822C03D8(ctx, base);
	// 82A843CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A843D0: 41820014  beq 0x82a843e4
	if ctx.cr[0].eq {
	pc = 0x82A843E4; continue 'dispatch;
	}
	// 82A843D4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A843D8: 480C2059  bl 0x82b46430
	ctx.lr = 0x82A843DC;
	sub_82B46430(ctx, base);
	// 82A843DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A843E0: 48000008  b 0x82a843e8
	pc = 0x82A843E8; continue 'dispatch;
	// 82A843E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A843E8: 387F0310  addi r3, r31, 0x310
	ctx.r[3].s64 = ctx.r[31].s64 + 784;
	// 82A843EC: 4BDD0FE5  bl 0x828553d0
	ctx.lr = 0x82A843F0;
	sub_828553D0(ctx, base);
	// 82A843F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A843F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A843F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A843FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A84400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84408 size=128
    let mut pc: u32 = 0x82A84408;
    'dispatch: loop {
        match pc {
            0x82A84408 => {
    //   block [0x82A84408..0x82A84488)
	// 82A84408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8440C: 48723D61  bl 0x831a816c
	ctx.lr = 0x82A84410;
	sub_831A8130(ctx, base);
	// 82A84410: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84414: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A84418: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A8441C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A84420: 3BEBE02C  addi r31, r11, -0x1fd4
	ctx.r[31].s64 = ctx.r[11].s64 + -8148;
	// 82A84424: 816AE034  lwz r11, -0x1fcc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8140 as u32) ) } as u64;
	// 82A84428: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A8442C: 40820024  bne 0x82a84450
	if !ctx.cr[0].eq {
	pc = 0x82A84450; continue 'dispatch;
	}
	// 82A84430: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 82A84434: 3D0082A8  lis r8, -0x7d58
	ctx.r[8].s64 = -2102919168;
	// 82A84438: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A8443C: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 82A84440: 39082638  addi r8, r8, 0x2638
	ctx.r[8].s64 = ctx.r[8].s64 + 9784;
	// 82A84444: 916AE034  stw r11, -0x1fcc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8140 as u32), ctx.r[11].u32 ) };
	// 82A84448: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A8444C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A84450: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A84454: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A84458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8445C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82A84460: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A84464: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A84468: 4BE43471  bl 0x828c78d8
	ctx.lr = 0x82A8446C;
	sub_828C78D8(ctx, base);
	// 82A8446C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84470: 4182000C  beq 0x82a8447c
	if ctx.cr[0].eq {
	pc = 0x82A8447C; continue 'dispatch;
	}
	// 82A84474: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A84478: 48000008  b 0x82a84480
	pc = 0x82A84480; continue 'dispatch;
	// 82A8447C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A84480: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A84484: 48723D38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84488 size=128
    let mut pc: u32 = 0x82A84488;
    'dispatch: loop {
        match pc {
            0x82A84488 => {
    //   block [0x82A84488..0x82A84508)
	// 82A84488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8448C: 48723CE1  bl 0x831a816c
	ctx.lr = 0x82A84490;
	sub_831A8130(ctx, base);
	// 82A84490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84494: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A84498: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A8449C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A844A0: 3BEBE038  addi r31, r11, -0x1fc8
	ctx.r[31].s64 = ctx.r[11].s64 + -8136;
	// 82A844A4: 816AE040  lwz r11, -0x1fc0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8128 as u32) ) } as u64;
	// 82A844A8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A844AC: 40820024  bne 0x82a844d0
	if !ctx.cr[0].eq {
	pc = 0x82A844D0; continue 'dispatch;
	}
	// 82A844B0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82A844B4: 3D0082A8  lis r8, -0x7d58
	ctx.r[8].s64 = -2102919168;
	// 82A844B8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A844BC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82A844C0: 39082D30  addi r8, r8, 0x2d30
	ctx.r[8].s64 = ctx.r[8].s64 + 11568;
	// 82A844C4: 916AE040  stw r11, -0x1fc0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8128 as u32), ctx.r[11].u32 ) };
	// 82A844C8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A844CC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A844D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A844D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A844D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A844DC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A844E0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A844E4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A844E8: 4BBD00D9  bl 0x826545c0
	ctx.lr = 0x82A844EC;
	sub_826545C0(ctx, base);
	// 82A844EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A844F0: 4182000C  beq 0x82a844fc
	if ctx.cr[0].eq {
	pc = 0x82A844FC; continue 'dispatch;
	}
	// 82A844F4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A844F8: 48000008  b 0x82a84500
	pc = 0x82A84500; continue 'dispatch;
	// 82A844FC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A84500: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A84504: 48723CB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84508 size=128
    let mut pc: u32 = 0x82A84508;
    'dispatch: loop {
        match pc {
            0x82A84508 => {
    //   block [0x82A84508..0x82A84588)
	// 82A84508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8450C: 48723C61  bl 0x831a816c
	ctx.lr = 0x82A84510;
	sub_831A8130(ctx, base);
	// 82A84510: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84514: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A84518: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A8451C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A84520: 3BEBE044  addi r31, r11, -0x1fbc
	ctx.r[31].s64 = ctx.r[11].s64 + -8124;
	// 82A84524: 816AE04C  lwz r11, -0x1fb4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8116 as u32) ) } as u64;
	// 82A84528: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A8452C: 40820024  bne 0x82a84550
	if !ctx.cr[0].eq {
	pc = 0x82A84550; continue 'dispatch;
	}
	// 82A84530: 3D2082A8  lis r9, -0x7d58
	ctx.r[9].s64 = -2102919168;
	// 82A84534: 3D0082A8  lis r8, -0x7d58
	ctx.r[8].s64 = -2102919168;
	// 82A84538: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A8453C: 39294378  addi r9, r9, 0x4378
	ctx.r[9].s64 = ctx.r[9].s64 + 17272;
	// 82A84540: 39082D78  addi r8, r8, 0x2d78
	ctx.r[8].s64 = ctx.r[8].s64 + 11640;
	// 82A84544: 916AE04C  stw r11, -0x1fb4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8116 as u32), ctx.r[11].u32 ) };
	// 82A84548: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A8454C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A84550: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A84554: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A84558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8455C: 38FE0008  addi r7, r30, 8
	ctx.r[7].s64 = ctx.r[30].s64 + 8;
	// 82A84560: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A84564: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A84568: 4BE5F469  bl 0x828e39d0
	ctx.lr = 0x82A8456C;
	sub_828E39D0(ctx, base);
	// 82A8456C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84570: 4182000C  beq 0x82a8457c
	if ctx.cr[0].eq {
	pc = 0x82A8457C; continue 'dispatch;
	}
	// 82A84574: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A84578: 48000008  b 0x82a84580
	pc = 0x82A84580; continue 'dispatch;
	// 82A8457C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A84580: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A84584: 48723C38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84588 size=128
    let mut pc: u32 = 0x82A84588;
    'dispatch: loop {
        match pc {
            0x82A84588 => {
    //   block [0x82A84588..0x82A84608)
	// 82A84588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8458C: 48723BE1  bl 0x831a816c
	ctx.lr = 0x82A84590;
	sub_831A8130(ctx, base);
	// 82A84590: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84594: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A84598: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A8459C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A845A0: 3BEBE050  addi r31, r11, -0x1fb0
	ctx.r[31].s64 = ctx.r[11].s64 + -8112;
	// 82A845A4: 816AE058  lwz r11, -0x1fa8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8104 as u32) ) } as u64;
	// 82A845A8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A845AC: 40820024  bne 0x82a845d0
	if !ctx.cr[0].eq {
	pc = 0x82A845D0; continue 'dispatch;
	}
	// 82A845B0: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 82A845B4: 3D0082A8  lis r8, -0x7d58
	ctx.r[8].s64 = -2102919168;
	// 82A845B8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A845BC: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 82A845C0: 39082DC0  addi r8, r8, 0x2dc0
	ctx.r[8].s64 = ctx.r[8].s64 + 11712;
	// 82A845C4: 916AE058  stw r11, -0x1fa8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8104 as u32), ctx.r[11].u32 ) };
	// 82A845C8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A845CC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A845D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A845D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A845D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A845DC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A845E0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A845E4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A845E8: 4BBCFFD9  bl 0x826545c0
	ctx.lr = 0x82A845EC;
	sub_826545C0(ctx, base);
	// 82A845EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A845F0: 4182000C  beq 0x82a845fc
	if ctx.cr[0].eq {
	pc = 0x82A845FC; continue 'dispatch;
	}
	// 82A845F4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A845F8: 48000008  b 0x82a84600
	pc = 0x82A84600; continue 'dispatch;
	// 82A845FC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A84600: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A84604: 48723BB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84608 size=128
    let mut pc: u32 = 0x82A84608;
    'dispatch: loop {
        match pc {
            0x82A84608 => {
    //   block [0x82A84608..0x82A84688)
	// 82A84608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8460C: 48723B61  bl 0x831a816c
	ctx.lr = 0x82A84610;
	sub_831A8130(ctx, base);
	// 82A84610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84614: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A84618: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A8461C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A84620: 3BEBE05C  addi r31, r11, -0x1fa4
	ctx.r[31].s64 = ctx.r[11].s64 + -8100;
	// 82A84624: 816AE064  lwz r11, -0x1f9c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8092 as u32) ) } as u64;
	// 82A84628: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A8462C: 40820024  bne 0x82a84650
	if !ctx.cr[0].eq {
	pc = 0x82A84650; continue 'dispatch;
	}
	// 82A84630: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 82A84634: 3D0082A8  lis r8, -0x7d58
	ctx.r[8].s64 = -2102919168;
	// 82A84638: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A8463C: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 82A84640: 39082E08  addi r8, r8, 0x2e08
	ctx.r[8].s64 = ctx.r[8].s64 + 11784;
	// 82A84644: 916AE064  stw r11, -0x1f9c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8092 as u32), ctx.r[11].u32 ) };
	// 82A84648: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A8464C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A84650: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A84654: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A84658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8465C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A84660: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A84664: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A84668: 4BBCFF59  bl 0x826545c0
	ctx.lr = 0x82A8466C;
	sub_826545C0(ctx, base);
	// 82A8466C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84670: 4182000C  beq 0x82a8467c
	if ctx.cr[0].eq {
	pc = 0x82A8467C; continue 'dispatch;
	}
	// 82A84674: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A84678: 48000008  b 0x82a84680
	pc = 0x82A84680; continue 'dispatch;
	// 82A8467C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A84680: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A84684: 48723B38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84688 size=308
    let mut pc: u32 = 0x82A84688;
    'dispatch: loop {
        match pc {
            0x82A84688 => {
    //   block [0x82A84688..0x82A847BC)
	// 82A84688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8468C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A84690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A84694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A84698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8469C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A846A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A846A4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A846A8: 396B2244  addi r11, r11, 0x2244
	ctx.r[11].s64 = ctx.r[11].s64 + 8772;
	// 82A846AC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A846B0: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A846B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A846B8: 394A209C  addi r10, r10, 0x209c
	ctx.r[10].s64 = ctx.r[10].s64 + 8348;
	// 82A846BC: 39292084  addi r9, r9, 0x2084
	ctx.r[9].s64 = ctx.r[9].s64 + 8324;
	// 82A846C0: 39682068  addi r11, r8, 0x2068
	ctx.r[11].s64 = ctx.r[8].s64 + 8296;
	// 82A846C4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A846C8: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82A846CC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82A846D0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82A846D4: 807F03E4  lwz r3, 0x3e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(996 as u32) ) } as u64;
	// 82A846D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A846DC: 419A0008  beq cr6, 0x82a846e4
	if ctx.cr[6].eq {
	pc = 0x82A846E4; continue 'dispatch;
	}
	// 82A846E0: 4B83C1B1  bl 0x822c0890
	ctx.lr = 0x82A846E4;
	sub_822C0890(ctx, base);
	// 82A846E4: 807F03DC  lwz r3, 0x3dc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(988 as u32) ) } as u64;
	// 82A846E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A846EC: 419A0008  beq cr6, 0x82a846f4
	if ctx.cr[6].eq {
	pc = 0x82A846F4; continue 'dispatch;
	}
	// 82A846F0: 4B83C1A1  bl 0x822c0890
	ctx.lr = 0x82A846F4;
	sub_822C0890(ctx, base);
	// 82A846F4: 387F03C8  addi r3, r31, 0x3c8
	ctx.r[3].s64 = ctx.r[31].s64 + 968;
	// 82A846F8: 4BA2CBA9  bl 0x824b12a0
	ctx.lr = 0x82A846FC;
	sub_824B12A0(ctx, base);
	// 82A846FC: 387F03B8  addi r3, r31, 0x3b8
	ctx.r[3].s64 = ctx.r[31].s64 + 952;
	// 82A84700: 4BA2CBA1  bl 0x824b12a0
	ctx.lr = 0x82A84704;
	sub_824B12A0(ctx, base);
	// 82A84704: 807F03B4  lwz r3, 0x3b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 82A84708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8470C: 419A0008  beq cr6, 0x82a84714
	if ctx.cr[6].eq {
	pc = 0x82A84714; continue 'dispatch;
	}
	// 82A84710: 4B83C181  bl 0x822c0890
	ctx.lr = 0x82A84714;
	sub_822C0890(ctx, base);
	// 82A84714: 807F03AC  lwz r3, 0x3ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) } as u64;
	// 82A84718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8471C: 419A0008  beq cr6, 0x82a84724
	if ctx.cr[6].eq {
	pc = 0x82A84724; continue 'dispatch;
	}
	// 82A84720: 4B83C171  bl 0x822c0890
	ctx.lr = 0x82A84724;
	sub_822C0890(ctx, base);
	// 82A84724: 807F03A4  lwz r3, 0x3a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 82A84728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8472C: 419A0008  beq cr6, 0x82a84734
	if ctx.cr[6].eq {
	pc = 0x82A84734; continue 'dispatch;
	}
	// 82A84730: 4B83C161  bl 0x822c0890
	ctx.lr = 0x82A84734;
	sub_822C0890(ctx, base);
	// 82A84734: 807F039C  lwz r3, 0x39c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82A84738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8473C: 419A0008  beq cr6, 0x82a84744
	if ctx.cr[6].eq {
	pc = 0x82A84744; continue 'dispatch;
	}
	// 82A84740: 4B83C151  bl 0x822c0890
	ctx.lr = 0x82A84744;
	sub_822C0890(ctx, base);
	// 82A84744: 807F0394  lwz r3, 0x394(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82A84748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8474C: 419A0008  beq cr6, 0x82a84754
	if ctx.cr[6].eq {
	pc = 0x82A84754; continue 'dispatch;
	}
	// 82A84750: 4B83C141  bl 0x822c0890
	ctx.lr = 0x82A84754;
	sub_822C0890(ctx, base);
	// 82A84754: 807F038C  lwz r3, 0x38c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 82A84758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8475C: 419A0008  beq cr6, 0x82a84764
	if ctx.cr[6].eq {
	pc = 0x82A84764; continue 'dispatch;
	}
	// 82A84760: 4B83C131  bl 0x822c0890
	ctx.lr = 0x82A84764;
	sub_822C0890(ctx, base);
	// 82A84764: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 82A84768: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8476C: 419A0008  beq cr6, 0x82a84774
	if ctx.cr[6].eq {
	pc = 0x82A84774; continue 'dispatch;
	}
	// 82A84770: 4B83C121  bl 0x822c0890
	ctx.lr = 0x82A84774;
	sub_822C0890(ctx, base);
	// 82A84774: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 82A84778: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8477C: 419A0008  beq cr6, 0x82a84784
	if ctx.cr[6].eq {
	pc = 0x82A84784; continue 'dispatch;
	}
	// 82A84780: 4B83C111  bl 0x822c0890
	ctx.lr = 0x82A84784;
	sub_822C0890(ctx, base);
	// 82A84784: 807F0374  lwz r3, 0x374(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 82A84788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8478C: 419A0008  beq cr6, 0x82a84794
	if ctx.cr[6].eq {
	pc = 0x82A84794; continue 'dispatch;
	}
	// 82A84790: 4B83C101  bl 0x822c0890
	ctx.lr = 0x82A84794;
	sub_822C0890(ctx, base);
	// 82A84794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84798: 4BE8C4F9  bl 0x82910c90
	ctx.lr = 0x82A8479C;
	sub_82910C90(ctx, base);
	// 82A8479C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A847A0: 4BD22EB9  bl 0x827a7658
	ctx.lr = 0x82A847A4;
	sub_827A7658(ctx, base);
	// 82A847A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A847A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A847AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A847B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A847B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A847B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A847C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A847C0 size=8
    let mut pc: u32 = 0x82A847C0;
    'dispatch: loop {
        match pc {
            0x82A847C0 => {
    //   block [0x82A847C0..0x82A847C8)
	// 82A847C0: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 82A847C4: 48000524  b 0x82a84ce8
	sub_82A84CE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A847C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A847C8 size=8
    let mut pc: u32 = 0x82A847C8;
    'dispatch: loop {
        match pc {
            0x82A847C8 => {
    //   block [0x82A847C8..0x82A847D0)
	// 82A847C8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82A847CC: 4800051C  b 0x82a84ce8
	sub_82A84CE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A847D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A847D0 size=8
    let mut pc: u32 = 0x82A847D0;
    'dispatch: loop {
        match pc {
            0x82A847D0 => {
    //   block [0x82A847D0..0x82A847D8)
	// 82A847D0: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 82A847D4: 48000514  b 0x82a84ce8
	sub_82A84CE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A847D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A847D8 size=400
    let mut pc: u32 = 0x82A847D8;
    'dispatch: loop {
        match pc {
            0x82A847D8 => {
    //   block [0x82A847D8..0x82A84968)
	// 82A847D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A847DC: 48723991  bl 0x831a816c
	ctx.lr = 0x82A847E0;
	sub_831A8130(ctx, base);
	// 82A847E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A847E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A847E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A847EC: 4BE8CA35  bl 0x82911220
	ctx.lr = 0x82A847F0;
	sub_82911220(ctx, base);
	// 82A847F0: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A847F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A847F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A847FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A84800: 4E800421  bctrl
	ctx.lr = 0x82A84804;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A84804: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A84808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8480C: 4803D785  bl 0x82ac1f90
	ctx.lr = 0x82A84810;
	sub_82AC1F90(ctx, base);
	// 82A84810: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A84814: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A84818: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8481C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A84820: 4E800421  bctrl
	ctx.lr = 0x82A84824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A84824: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A84828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8482C: 48026CAD  bl 0x82aab4d8
	ctx.lr = 0x82A84830;
	sub_82AAB4D8(ctx, base);
	// 82A84830: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 82A84834: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A84838: 483D5CE9  bl 0x82e5a520
	ctx.lr = 0x82A8483C;
	sub_82E5A520(ctx, base);
	// 82A8483C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A84840: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A84844: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A84848: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8484C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A84850: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A84854: 4BFFD56D  bl 0x82a81dc0
	ctx.lr = 0x82A84858;
	sub_82A81DC0(ctx, base);
	// 82A84858: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A8485C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A84860: 419A0008  beq cr6, 0x82a84868
	if ctx.cr[6].eq {
	pc = 0x82A84868; continue 'dispatch;
	}
	// 82A84864: 4B83C02D  bl 0x822c0890
	ctx.lr = 0x82A84868;
	sub_822C0890(ctx, base);
	// 82A84868: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A8486C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A84870: 419A0014  beq cr6, 0x82a84884
	if ctx.cr[6].eq {
	pc = 0x82A84884; continue 'dispatch;
	}
	// 82A84874: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A84878: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A8487C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A84880: 4E800421  bctrl
	ctx.lr = 0x82A84884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A84884: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A84888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8488C: 419A0008  beq cr6, 0x82a84894
	if ctx.cr[6].eq {
	pc = 0x82A84894; continue 'dispatch;
	}
	// 82A84890: 4B83C001  bl 0x822c0890
	ctx.lr = 0x82A84894;
	sub_822C0890(ctx, base);
	// 82A84894: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A84898: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A8489C: 4BD658F5  bl 0x827ea190
	ctx.lr = 0x82A848A0;
	sub_827EA190(ctx, base);
	// 82A848A0: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 82A848A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A848A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A848AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A848B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A848B4: 4E800421  bctrl
	ctx.lr = 0x82A848B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A848B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A848BC: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 82A848C0: 48007511  bl 0x82a8bdd0
	ctx.lr = 0x82A848C4;
	sub_82A8BDD0(ctx, base);
	// 82A848C4: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82A848C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A848CC: 419A000C  beq cr6, 0x82a848d8
	if ctx.cr[6].eq {
	pc = 0x82A848D8; continue 'dispatch;
	}
	// 82A848D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A848D4: 4BD6D4E5  bl 0x827f1db8
	ctx.lr = 0x82A848D8;
	sub_827F1DB8(ctx, base);
	// 82A848D8: 83DF03BC  lwz r30, 0x3bc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 82A848DC: 48000014  b 0x82a848f0
	pc = 0x82A848F0; continue 'dispatch;
	// 82A848E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A848E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A848E8: 48004499  bl 0x82a88d80
	ctx.lr = 0x82A848EC;
	sub_82A88D80(ctx, base);
	// 82A848EC: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A848F0: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 82A848F4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A848F8: 409AFFE8  bne cr6, 0x82a848e0
	if !ctx.cr[6].eq {
	pc = 0x82A848E0; continue 'dispatch;
	}
	// 82A848FC: 807F03C8  lwz r3, 0x3c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 82A84900: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A84904: 419A000C  beq cr6, 0x82a84910
	if ctx.cr[6].eq {
	pc = 0x82A84910; continue 'dispatch;
	}
	// 82A84908: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A8490C: 48003F5D  bl 0x82a88868
	ctx.lr = 0x82A84910;
	sub_82A88868(ctx, base);
	// 82A84910: 3BFF03A8  addi r31, r31, 0x3a8
	ctx.r[31].s64 = ctx.r[31].s64 + 936;
	// 82A84914: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A84918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8491C: 419A0044  beq cr6, 0x82a84960
	if ctx.cr[6].eq {
	pc = 0x82A84960; continue 'dispatch;
	}
	// 82A84920: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A84924: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A84928: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8492C: 41820034  beq 0x82a84960
	if ctx.cr[0].eq {
	pc = 0x82A84960; continue 'dispatch;
	}
	// 82A84930: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A84934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A84938: 4BB1CB99  bl 0x825a14d0
	ctx.lr = 0x82A8493C;
	sub_825A14D0(ctx, base);
	// 82A8493C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A84940: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A84944: 48005595  bl 0x82a89ed8
	ctx.lr = 0x82A84948;
	sub_82A89ED8(ctx, base);
	// 82A84948: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A8494C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A84950: 4BB1CB81  bl 0x825a14d0
	ctx.lr = 0x82A84954;
	sub_825A14D0(ctx, base);
	// 82A84954: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A84958: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8495C: 4800557D  bl 0x82a89ed8
	ctx.lr = 0x82A84960;
	sub_82A89ED8(ctx, base);
	// 82A84960: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A84964: 48723858  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84968 size=156
    let mut pc: u32 = 0x82A84968;
    'dispatch: loop {
        match pc {
            0x82A84968 => {
    //   block [0x82A84968..0x82A84A04)
	// 82A84968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8496C: 48723801  bl 0x831a816c
	ctx.lr = 0x82A84970;
	sub_831A8130(ctx, base);
	// 82A84970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A84978: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A8497C: 817F0410  lwz r11, 0x410(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82A84980: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A84984: 419A0078  beq cr6, 0x82a849fc
	if ctx.cr[6].eq {
	pc = 0x82A849FC; continue 'dispatch;
	}
	// 82A84988: 817F03BC  lwz r11, 0x3bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 82A8498C: 3BDF03B8  addi r30, r31, 0x3b8
	ctx.r[30].s64 = ctx.r[31].s64 + 952;
	// 82A84990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A84994: 419A0064  beq cr6, 0x82a849f8
	if ctx.cr[6].eq {
	pc = 0x82A849F8; continue 'dispatch;
	}
	// 82A84998: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8499C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A849A0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A849A4: 41820054  beq 0x82a849f8
	if ctx.cr[0].eq {
	pc = 0x82A849F8; continue 'dispatch;
	}
	// 82A849A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A849AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A849B0: 4BB1CB21  bl 0x825a14d0
	ctx.lr = 0x82A849B4;
	sub_825A14D0(ctx, base);
	// 82A849B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A849B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A849BC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A849C0: 48005A09  bl 0x82a8a3c8
	ctx.lr = 0x82A849C4;
	sub_82A8A3C8(ctx, base);
	// 82A849C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A849C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A849CC: 4BB1CB05  bl 0x825a14d0
	ctx.lr = 0x82A849D0;
	sub_825A14D0(ctx, base);
	// 82A849D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A849D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A849D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A849DC: 480059ED  bl 0x82a8a3c8
	ctx.lr = 0x82A849E0;
	sub_82A8A3C8(ctx, base);
	// 82A849E0: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82A849E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A849E8: 4BA8A9F1  bl 0x8250f3d8
	ctx.lr = 0x82A849EC;
	sub_8250F3D8(ctx, base);
	// 82A849EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A849F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A849F4: 4BA8B14D  bl 0x8250fb40
	ctx.lr = 0x82A849F8;
	sub_8250FB40(ctx, base);
	// 82A849F8: 93BF0410  stw r29, 0x410(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), ctx.r[29].u32 ) };
	// 82A849FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A84A00: 487237BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A84A08 size=208
    let mut pc: u32 = 0x82A84A08;
    'dispatch: loop {
        match pc {
            0x82A84A08 => {
    //   block [0x82A84A08..0x82A84AD8)
	// 82A84A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A84A0C: 48723761  bl 0x831a816c
	ctx.lr = 0x82A84A10;
	sub_831A8130(ctx, base);
	// 82A84A10: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A84A14: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A84A1C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82A84A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84A24: 4BE84435  bl 0x82908e58
	ctx.lr = 0x82A84A28;
	sub_82908E58(ctx, base);
	// 82A84A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84A2C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A84A30: 4BE84431  bl 0x82908e60
	ctx.lr = 0x82A84A34;
	sub_82908E60(ctx, base);
	// 82A84A34: 817F03E8  lwz r11, 0x3e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82A84A38: EC1F0824  fdivs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 82A84A3C: 556AE7FF  rlwinm. r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A84A40: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A84A44: 3BAAE0D8  addi r29, r10, -0x1f28
	ctx.r[29].s64 = ctx.r[10].s64 + -7976;
	// 82A84A48: 41820040  beq 0x82a84a88
	if ctx.cr[0].eq {
	pc = 0x82A84A88; continue 'dispatch;
	}
	// 82A84A4C: C1BD0028  lfs f13, 0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A84A50: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A84A54: 41990078  bgt cr6, 0x82a84acc
	if ctx.cr[6].gt {
	pc = 0x82A84ACC; continue 'dispatch;
	}
	// 82A84A58: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84A5C: 40820010  bne 0x82a84a6c
	if !ctx.cr[0].eq {
	pc = 0x82A84A6C; continue 'dispatch;
	}
	// 82A84A60: 817F03EC  lwz r11, 0x3ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) } as u64;
	// 82A84A64: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 82A84A68: 917F03EC  stw r11, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[11].u32 ) };
	// 82A84A6C: 817F03E8  lwz r11, 0x3e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82A84A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84A74: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 82A84A78: 917F03E8  stw r11, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[11].u32 ) };
	// 82A84A7C: 4BE843E5  bl 0x82908e60
	ctx.lr = 0x82A84A80;
	sub_82908E60(ctx, base);
	// 82A84A80: C01D0028  lfs f0, 0x28(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A84A84: 4800003C  b 0x82a84ac0
	pc = 0x82A84AC0; continue 'dispatch;
	// 82A84A88: C1BD0020  lfs f13, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A84A8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A84A90: 4199003C  bgt cr6, 0x82a84acc
	if ctx.cr[6].gt {
	pc = 0x82A84ACC; continue 'dispatch;
	}
	// 82A84A94: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84A98: 40820010  bne 0x82a84aa8
	if !ctx.cr[0].eq {
	pc = 0x82A84AA8; continue 'dispatch;
	}
	// 82A84A9C: 817F03EC  lwz r11, 0x3ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) } as u64;
	// 82A84AA0: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 82A84AA4: 917F03EC  stw r11, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[11].u32 ) };
	// 82A84AA8: 817F03E8  lwz r11, 0x3e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82A84AAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84AB0: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 82A84AB4: 917F03E8  stw r11, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[11].u32 ) };
	// 82A84AB8: 4BE843A9  bl 0x82908e60
	ctx.lr = 0x82A84ABC;
	sub_82908E60(ctx, base);
	// 82A84ABC: C01D0020  lfs f0, 0x20(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A84AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84AC4: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A84AC8: 4BE84AA1  bl 0x82909568
	ctx.lr = 0x82A84ACC;
	sub_82909568(ctx, base);
	// 82A84ACC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A84AD0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A84AD4: 487236E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84AD8 size=140
    let mut pc: u32 = 0x82A84AD8;
    'dispatch: loop {
        match pc {
            0x82A84AD8 => {
    //   block [0x82A84AD8..0x82A84B64)
	// 82A84AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A84ADC: 48723691  bl 0x831a816c
	ctx.lr = 0x82A84AE0;
	sub_831A8130(ctx, base);
	// 82A84AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84AE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A84AE8: 3BBE03E8  addi r29, r30, 0x3e8
	ctx.r[29].s64 = ctx.r[30].s64 + 1000;
	// 82A84AEC: 817E03E8  lwz r11, 0x3e8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82A84AF0: 556BD7FF  rlwinm. r11, r11, 0x1a, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84AF4: 40820068  bne 0x82a84b5c
	if !ctx.cr[0].eq {
	pc = 0x82A84B5C; continue 'dispatch;
	}
	// 82A84AF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A84AFC: 3BFE03A0  addi r31, r30, 0x3a0
	ctx.r[31].s64 = ctx.r[30].s64 + 928;
	// 82A84B00: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A84B04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A84B08: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 82A84B0C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A84B10: 4BA8B6E1  bl 0x825101f0
	ctx.lr = 0x82A84B14;
	sub_825101F0(ctx, base);
	// 82A84B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A84B18: 917E03A0  stw r11, 0x3a0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	// 82A84B1C: 807E03A4  lwz r3, 0x3a4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(932 as u32) ) } as u64;
	// 82A84B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A84B24: 917E03A4  stw r11, 0x3a4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(932 as u32), ctx.r[11].u32 ) };
	// 82A84B28: 419A0008  beq cr6, 0x82a84b30
	if ctx.cr[6].eq {
	pc = 0x82A84B30; continue 'dispatch;
	}
	// 82A84B2C: 4B83BD65  bl 0x822c0890
	ctx.lr = 0x82A84B30;
	sub_822C0890(ctx, base);
	// 82A84B30: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A84B34: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A84B38: 38CB229C  addi r6, r11, 0x229c
	ctx.r[6].s64 = ctx.r[11].s64 + 8860;
	// 82A84B3C: 38AA228C  addi r5, r10, 0x228c
	ctx.r[5].s64 = ctx.r[10].s64 + 8844;
	// 82A84B40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A84B44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A84B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84B4C: 4BFFF20D  bl 0x82a83d58
	ctx.lr = 0x82A84B50;
	sub_82A83D58(ctx, base);
	// 82A84B50: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A84B54: 616B0040  ori r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 64;
	// 82A84B58: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A84B5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A84B60: 4872365C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A84B68 size=384
    let mut pc: u32 = 0x82A84B68;
    'dispatch: loop {
        match pc {
            0x82A84B68 => {
    //   block [0x82A84B68..0x82A84CE8)
	// 82A84B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A84B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A84B70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A84B74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A84B78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84B7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A84B80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A84B84: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A84B88: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82A84B8C: 38C0001E  li r6, 0x1e
	ctx.r[6].s64 = 30;
	// 82A84B90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A84B94: 4BE8BF85  bl 0x82910b18
	ctx.lr = 0x82A84B98;
	sub_82910B18(ctx, base);
	// 82A84B98: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A84B9C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A84BA0: 394A2244  addi r10, r10, 0x2244
	ctx.r[10].s64 = ctx.r[10].s64 + 8772;
	// 82A84BA4: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A84BA8: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 82A84BAC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A84BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A84BB4: 39082084  addi r8, r8, 0x2084
	ctx.r[8].s64 = ctx.r[8].s64 + 8324;
	// 82A84BB8: 3929209C  addi r9, r9, 0x209c
	ctx.r[9].s64 = ctx.r[9].s64 + 8348;
	// 82A84BBC: 39472068  addi r10, r7, 0x2068
	ctx.r[10].s64 = ctx.r[7].s64 + 8296;
	// 82A84BC0: 911F0038  stw r8, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[8].u32 ) };
	// 82A84BC4: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82A84BC8: 5568003E  slwi r8, r11, 0
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A84BCC: 915F0218  stw r10, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[10].u32 ) };
	// 82A84BD0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A84BD4: 917F0370  stw r11, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[11].u32 ) };
	// 82A84BD8: 550805FE  clrlwi r8, r8, 0x17
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000001FFu64;
	// 82A84BDC: 917F0374  stw r11, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[11].u32 ) };
	// 82A84BE0: 395F03F0  addi r10, r31, 0x3f0
	ctx.r[10].s64 = ctx.r[31].s64 + 1008;
	// 82A84BE4: 917F0378  stw r11, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[11].u32 ) };
	// 82A84BE8: 387F03B8  addi r3, r31, 0x3b8
	ctx.r[3].s64 = ctx.r[31].s64 + 952;
	// 82A84BEC: 917F037C  stw r11, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[11].u32 ) };
	// 82A84BF0: 3BDF03C8  addi r30, r31, 0x3c8
	ctx.r[30].s64 = ctx.r[31].s64 + 968;
	// 82A84BF4: 917F0380  stw r11, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 82A84BF8: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A84BFC: 917F0384  stw r11, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 82A84C00: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A84C04: 917F0388  stw r11, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	// 82A84C08: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 82A84C0C: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82A84C10: 917F0394  stw r11, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 82A84C14: 917F0398  stw r11, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82A84C18: 917F039C  stw r11, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 82A84C1C: 917F03A0  stw r11, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	// 82A84C20: 917F03A4  stw r11, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[11].u32 ) };
	// 82A84C24: 917F03A8  stw r11, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[11].u32 ) };
	// 82A84C28: 917F03AC  stw r11, 0x3ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), ctx.r[11].u32 ) };
	// 82A84C2C: 917F03B0  stw r11, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[11].u32 ) };
	// 82A84C30: 917F03B4  stw r11, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[11].u32 ) };
	// 82A84C34: 917F03BC  stw r11, 0x3bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[11].u32 ) };
	// 82A84C38: 917F03C0  stw r11, 0x3c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), ctx.r[11].u32 ) };
	// 82A84C3C: 917F03C4  stw r11, 0x3c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[11].u32 ) };
	// 82A84C40: 917F03CC  stw r11, 0x3cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(972 as u32), ctx.r[11].u32 ) };
	// 82A84C44: 917F03D0  stw r11, 0x3d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), ctx.r[11].u32 ) };
	// 82A84C48: 917F03D4  stw r11, 0x3d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), ctx.r[11].u32 ) };
	// 82A84C4C: 917F03D8  stw r11, 0x3d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(984 as u32), ctx.r[11].u32 ) };
	// 82A84C50: 917F03DC  stw r11, 0x3dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(988 as u32), ctx.r[11].u32 ) };
	// 82A84C54: 917F03E0  stw r11, 0x3e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(992 as u32), ctx.r[11].u32 ) };
	// 82A84C58: 917F03E4  stw r11, 0x3e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), ctx.r[11].u32 ) };
	// 82A84C5C: 917F03E8  stw r11, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[11].u32 ) };
	// 82A84C60: 917F03E8  stw r11, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[11].u32 ) };
	// 82A84C64: 911F03E8  stw r8, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[8].u32 ) };
	// 82A84C68: 5568003E  slwi r8, r11, 0
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A84C6C: 917F03EC  stw r11, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[11].u32 ) };
	// 82A84C70: 5508073E  clrlwi r8, r8, 0x1c
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000000Fu64;
	// 82A84C74: 917F03EC  stw r11, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[11].u32 ) };
	// 82A84C78: 911F03EC  stw r8, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[8].u32 ) };
	// 82A84C7C: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82A84C80: 917F0408  stw r11, 0x408(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	// 82A84C84: 917F0410  stw r11, 0x410(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), ctx.r[11].u32 ) };
	// 82A84C88: 917F0414  stw r11, 0x414(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1044 as u32), ctx.r[11].u32 ) };
	// 82A84C8C: 917F0418  stw r11, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 82A84C90: 917F041C  stw r11, 0x41c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1052 as u32), ctx.r[11].u32 ) };
	// 82A84C94: 917F0420  stw r11, 0x420(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), ctx.r[11].u32 ) };
	// 82A84C98: 917F0424  stw r11, 0x424(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), ctx.r[11].u32 ) };
	// 82A84C9C: 917F0428  stw r11, 0x428(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), ctx.r[11].u32 ) };
	// 82A84CA0: 917F042C  stw r11, 0x42c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), ctx.r[11].u32 ) };
	// 82A84CA4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A84CA8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A84CAC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A84CB0: 4200FFF8  bdnz 0x82a84ca8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A84CA8; continue 'dispatch;
	}
	// 82A84CB4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A84CB8: 4BA7E009  bl 0x82502cc0
	ctx.lr = 0x82A84CBC;
	sub_82502CC0(ctx, base);
	// 82A84CBC: 4BA945C5  bl 0x82519280
	ctx.lr = 0x82A84CC0;
	sub_82519280(ctx, base);
	// 82A84CC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A84CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84CC8: 4BA7DFF9  bl 0x82502cc0
	ctx.lr = 0x82A84CCC;
	sub_82502CC0(ctx, base);
	// 82A84CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A84CD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A84CD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A84CD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A84CDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A84CE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A84CE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A84CE8 size=76
    let mut pc: u32 = 0x82A84CE8;
    'dispatch: loop {
        match pc {
            0x82A84CE8 => {
    //   block [0x82A84CE8..0x82A84D34)
	// 82A84CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A84CEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A84CF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A84CF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A84CF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84CFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A84D00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A84D04: 4BFFF985  bl 0x82a84688
	ctx.lr = 0x82A84D08;
	sub_82A84688(ctx, base);
	// 82A84D08: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84D0C: 4182000C  beq 0x82a84d18
	if ctx.cr[0].eq {
	pc = 0x82A84D18; continue 'dispatch;
	}
	// 82A84D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A84D14: 4836D6C5  bl 0x82df23d8
	ctx.lr = 0x82A84D18;
	sub_82DF23D8(ctx, base);
	// 82A84D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A84D1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A84D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A84D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A84D28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A84D2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A84D30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A84D38 size=456
    let mut pc: u32 = 0x82A84D38;
    'dispatch: loop {
        match pc {
            0x82A84D38 => {
    //   block [0x82A84D38..0x82A84F00)
	// 82A84D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A84D3C: 48723429  bl 0x831a8164
	ctx.lr = 0x82A84D40;
	sub_831A8130(ctx, base);
	// 82A84D40: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84D44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A84D48: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A84D4C: 3BCB2010  addi r30, r11, 0x2010
	ctx.r[30].s64 = ctx.r[11].s64 + 8208;
	// 82A84D50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A84D54: 38A000E0  li r5, 0xe0
	ctx.r[5].s64 = 224;
	// 82A84D58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A84D5C: 38600430  li r3, 0x430
	ctx.r[3].s64 = 1072;
	// 82A84D60: 4836D689  bl 0x82df23e8
	ctx.lr = 0x82A84D64;
	sub_82DF23E8(ctx, base);
	// 82A84D64: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A84D68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A84D6C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 82A84D70: 4182001C  beq 0x82a84d8c
	if ctx.cr[0].eq {
	pc = 0x82A84D8C; continue 'dispatch;
	}
	// 82A84D74: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A84D78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A84D7C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82A84D80: 4BFFFDE9  bl 0x82a84b68
	ctx.lr = 0x82A84D84;
	sub_82A84B68(ctx, base);
	// 82A84D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A84D88: 48000008  b 0x82a84d90
	pc = 0x82A84D90; continue 'dispatch;
	// 82A84D8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A84D90: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A84D94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A84D98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A84D9C: 4BFFCE95  bl 0x82a81c30
	ctx.lr = 0x82A84DA0;
	sub_82A81C30(ctx, base);
	// 82A84DA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A84DA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A84DA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A84DAC: 4B83B255  bl 0x822c0000
	ctx.lr = 0x82A84DB0;
	sub_822C0000(ctx, base);
	// 82A84DB0: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A84DB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A84DB8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A84DBC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82A84DC0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A84DC4: 419A0024  beq cr6, 0x82a84de8
	if ctx.cr[6].eq {
	pc = 0x82A84DE8; continue 'dispatch;
	}
	// 82A84DC8: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 82A84DCC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A84DD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A84DD4: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A84DD8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A84DDC: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A84DE0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A84DE4: 4082FFE8  bne 0x82a84dcc
	if !ctx.cr[0].eq {
	pc = 0x82A84DCC; continue 'dispatch;
	}
	// 82A84DE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A84DEC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A84DF0: 409A0008  bne cr6, 0x82a84df8
	if !ctx.cr[6].eq {
	pc = 0x82A84DF8; continue 'dispatch;
	}
	// 82A84DF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A84DF8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A84DFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A84E00: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A84E04: 419A0024  beq cr6, 0x82a84e28
	if ctx.cr[6].eq {
	pc = 0x82A84E28; continue 'dispatch;
	}
	// 82A84E08: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82A84E0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A84E10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A84E14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A84E18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A84E1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A84E20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A84E24: 4082FFE8  bne 0x82a84e0c
	if !ctx.cr[0].eq {
	pc = 0x82A84E0C; continue 'dispatch;
	}
	// 82A84E28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A84E2C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A84E30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A84E34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A84E38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A84E3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A84E40: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A84E44: 4BD140ED  bl 0x82798f30
	ctx.lr = 0x82A84E48;
	sub_82798F30(ctx, base);
	// 82A84E48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A84E4C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A84E50: C1810090  lfs f12, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A84E54: C1610094  lfs f11, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A84E58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A84E5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A84E60: 38A000E5  li r5, 0xe5
	ctx.r[5].s64 = 229;
	// 82A84E64: C00B95F4  lfs f0, -0x6a0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A84E68: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A84E6C: C1AA9664  lfs f13, -0x699c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A84E70: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A84E74: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A84E78: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A84E7C: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A84E80: 4B83B559  bl 0x822c03d8
	ctx.lr = 0x82A84E84;
	sub_822C03D8(ctx, base);
	// 82A84E84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A84E88: 41820014  beq 0x82a84e9c
	if ctx.cr[0].eq {
	pc = 0x82A84E9C; continue 'dispatch;
	}
	// 82A84E8C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A84E90: 4BD167D9  bl 0x8279b668
	ctx.lr = 0x82A84E94;
	sub_8279B668(ctx, base);
	// 82A84E94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A84E98: 48000008  b 0x82a84ea0
	pc = 0x82A84EA0; continue 'dispatch;
	// 82A84E9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A84EA0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A84EA4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82A84EA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A84EAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84EB0: 4BB12DA1  bl 0x82597c50
	ctx.lr = 0x82A84EB4;
	sub_82597C50(ctx, base);
	// 82A84EB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A84EB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A84EBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84EC0: 4B83B141  bl 0x822c0000
	ctx.lr = 0x82A84EC4;
	sub_822C0000(ctx, base);
	// 82A84EC4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A84EC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A84ECC: 419A0008  beq cr6, 0x82a84ed4
	if ctx.cr[6].eq {
	pc = 0x82A84ED4; continue 'dispatch;
	}
	// 82A84ED0: 4B83B9C1  bl 0x822c0890
	ctx.lr = 0x82A84ED4;
	sub_822C0890(ctx, base);
	// 82A84ED4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A84ED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A84EDC: 419A0008  beq cr6, 0x82a84ee4
	if ctx.cr[6].eq {
	pc = 0x82A84EE4; continue 'dispatch;
	}
	// 82A84EE0: 4B83B9B1  bl 0x822c0890
	ctx.lr = 0x82A84EE4;
	sub_822C0890(ctx, base);
	// 82A84EE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A84EE8: 419A000C  beq cr6, 0x82a84ef4
	if ctx.cr[6].eq {
	pc = 0x82A84EF4; continue 'dispatch;
	}
	// 82A84EEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A84EF0: 4B83B9A1  bl 0x822c0890
	ctx.lr = 0x82A84EF4;
	sub_822C0890(ctx, base);
	// 82A84EF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A84EF8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A84EFC: 487232B8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A84F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A84F00 size=868
    let mut pc: u32 = 0x82A84F00;
    'dispatch: loop {
        match pc {
            0x82A84F00 => {
    //   block [0x82A84F00..0x82A85264)
	// 82A84F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A84F04: 48723265  bl 0x831a8168
	ctx.lr = 0x82A84F08;
	sub_831A8130(ctx, base);
	// 82A84F08: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A84F0C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A84F10: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A84F14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A84F18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A84F1C: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 82A84F20: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A84F24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84F28: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A84F2C: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A84F30: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82A84F34: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82A84F38: 4BE83F21  bl 0x82908e58
	ctx.lr = 0x82A84F3C;
	sub_82908E58(ctx, base);
	// 82A84F3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A84F40: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A84F44: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A84F48: 4099001C  ble cr6, 0x82a84f64
	if !ctx.cr[6].gt {
	pc = 0x82A84F64; continue 'dispatch;
	}
	// 82A84F4C: 817C03EC  lwz r11, 0x3ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1004 as u32) ) } as u64;
	// 82A84F50: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84F54: 40820010  bne 0x82a84f64
	if !ctx.cr[0].eq {
	pc = 0x82A84F64; continue 'dispatch;
	}
	// 82A84F58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A84F5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84F60: 4BE89D59  bl 0x8290ecb8
	ctx.lr = 0x82A84F64;
	sub_8290ECB8(ctx, base);
	// 82A84F64: 817C03EC  lwz r11, 0x3ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1004 as u32) ) } as u64;
	// 82A84F68: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A84F6C: 41820014  beq 0x82a84f80
	if ctx.cr[0].eq {
	pc = 0x82A84F80; continue 'dispatch;
	}
	// 82A84F70: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A84F74: 396BE0D8  addi r11, r11, -0x1f28
	ctx.r[11].s64 = ctx.r[11].s64 + -7976;
	// 82A84F78: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A84F7C: 48000018  b 0x82a84f94
	pc = 0x82A84F94; continue 'dispatch;
	// 82A84F80: 556BF7FF  rlwinm. r11, r11, 0x1e, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84F84: 41820014  beq 0x82a84f98
	if ctx.cr[0].eq {
	pc = 0x82A84F98; continue 'dispatch;
	}
	// 82A84F88: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A84F8C: 396BE0D8  addi r11, r11, -0x1f28
	ctx.r[11].s64 = ctx.r[11].s64 + -7976;
	// 82A84F90: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A84F94: EFC007B2  fmuls f30, f0, f30
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A84F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84F9C: 4BE83EBD  bl 0x82908e58
	ctx.lr = 0x82A84FA0;
	sub_82908E58(ctx, base);
	// 82A84FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84FA4: EC21F028  fsubs f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A84FA8: 4BE845C1  bl 0x82909568
	ctx.lr = 0x82A84FAC;
	sub_82909568(ctx, base);
	// 82A84FAC: C01C040C  lfs f0, 0x40c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A84FB0: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82A84FB4: D01C040C  stfs f0, 0x40c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82A84FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84FBC: 4BE83E9D  bl 0x82908e58
	ctx.lr = 0x82A84FC0;
	sub_82908E58(ctx, base);
	// 82A84FC0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A84FC4: 40980010  bge cr6, 0x82a84fd4
	if !ctx.cr[6].lt {
	pc = 0x82A84FD4; continue 'dispatch;
	}
	// 82A84FC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A84FCC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A84FD0: 4BE84599  bl 0x82909568
	ctx.lr = 0x82A84FD4;
	sub_82909568(ctx, base);
	// 82A84FD4: 817C03EC  lwz r11, 0x3ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1004 as u32) ) } as u64;
	// 82A84FD8: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A84FDC: 41820228  beq 0x82a85204
	if ctx.cr[0].eq {
	pc = 0x82A85204; continue 'dispatch;
	}
	// 82A84FE0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A84FE4: 556BF7FF  rlwinm. r11, r11, 0x1e, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A84FE8: C3C908A8  lfs f30, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A84FEC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A84FF0: 41820058  beq 0x82a85048
	if ctx.cr[0].eq {
	pc = 0x82A85048; continue 'dispatch;
	}
	// 82A84FF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A84FF8: 3BEBE098  addi r31, r11, -0x1f68
	ctx.r[31].s64 = ctx.r[11].s64 + -8040;
	// 82A84FFC: 816AE0C8  lwz r11, -0x1f38(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7992 as u32) ) } as u64;
	// 82A85000: 556807FF  clrlwi. r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82A85004: 408200BC  bne 0x82a850c0
	if !ctx.cr[0].eq {
	pc = 0x82A850C0; continue 'dispatch;
	}
	// 82A85008: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A8500C: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82A85010: 916AE0C8  stw r11, -0x1f38(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7992 as u32), ctx.r[11].u32 ) };
	// 82A85014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85018: 8089911C  lwz r4, -0x6ee4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28388 as u32) ) } as u64;
	// 82A8501C: 4836E9ED  bl 0x82df3a08
	ctx.lr = 0x82A85020;
	sub_82DF3A08(ctx, base);
	// 82A85020: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A85024: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A85028: 388B22B0  addi r4, r11, 0x22b0
	ctx.r[4].s64 = ctx.r[11].s64 + 8880;
	// 82A8502C: 4836E9DD  bl 0x82df3a08
	ctx.lr = 0x82A85030;
	sub_82DF3A08(ctx, base);
	// 82A85030: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82A85034: 3D208324  lis r9, -0x7cdc
	ctx.r[9].s64 = -2094792704;
	// 82A85038: 386913E0  addi r3, r9, 0x13e0
	ctx.r[3].s64 = ctx.r[9].s64 + 5088;
	// 82A8503C: C00A7BC4  lfs f0, 0x7bc4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A85040: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A85044: 48000050  b 0x82a85094
	pc = 0x82A85094; continue 'dispatch;
	// 82A85048: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A8504C: 3BEBE068  addi r31, r11, -0x1f98
	ctx.r[31].s64 = ctx.r[11].s64 + -8088;
	// 82A85050: 816AE0C8  lwz r11, -0x1f38(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7992 as u32) ) } as u64;
	// 82A85054: 556807BD  rlwinm. r8, r11, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82A85058: 40820068  bne 0x82a850c0
	if !ctx.cr[0].eq {
	pc = 0x82A850C0; continue 'dispatch;
	}
	// 82A8505C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82A85060: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82A85064: 916AE0C8  stw r11, -0x1f38(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7992 as u32), ctx.r[11].u32 ) };
	// 82A85068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8506C: 3969911C  addi r11, r9, -0x6ee4
	ctx.r[11].s64 = ctx.r[9].s64 + -28388;
	// 82A85070: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A85074: 4836E995  bl 0x82df3a08
	ctx.lr = 0x82A85078;
	sub_82DF3A08(ctx, base);
	// 82A85078: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8507C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A85080: 388B22B0  addi r4, r11, 0x22b0
	ctx.r[4].s64 = ctx.r[11].s64 + 8880;
	// 82A85084: 4836E985  bl 0x82df3a08
	ctx.lr = 0x82A85088;
	sub_82DF3A08(ctx, base);
	// 82A85088: 3D408324  lis r10, -0x7cdc
	ctx.r[10].s64 = -2094792704;
	// 82A8508C: D3DF0014  stfs f30, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A85090: 386A13A0  addi r3, r10, 0x13a0
	ctx.r[3].s64 = ctx.r[10].s64 + 5024;
	// 82A85094: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A85098: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A8509C: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A850A0: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A850A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A850A8: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A850AC: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A850B0: D3DF0024  stfs f30, 0x24(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A850B4: D3DF0028  stfs f30, 0x28(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82A850B8: D3DF002C  stfs f30, 0x2c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A850BC: 4872341D  bl 0x831a84d8
	ctx.lr = 0x82A850C0;
	sub_831A84D8(ctx, base);
	// 82A850C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A850C4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A850C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A850CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A850D0: 4BD67539  bl 0x827ec608
	ctx.lr = 0x82A850D4;
	sub_827EC608(ctx, base);
	// 82A850D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A850D8: 389D0040  addi r4, r29, 0x40
	ctx.r[4].s64 = ctx.r[29].s64 + 64;
	// 82A850DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A850E0: 816B00F8  lwz r11, 0xf8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A850E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A850E8: 4E800421  bctrl
	ctx.lr = 0x82A850EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A850EC: 817C03E8  lwz r11, 0x3e8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1000 as u32) ) } as u64;
	// 82A850F0: 3BBC03E8  addi r29, r28, 0x3e8
	ctx.r[29].s64 = ctx.r[28].s64 + 1000;
	// 82A850F4: 556BCFFF  rlwinm. r11, r11, 0x19, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A850F8: 40820154  bne 0x82a8524c
	if !ctx.cr[0].eq {
	pc = 0x82A8524C; continue 'dispatch;
	}
	// 82A850FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A85100: 815C03F8  lwz r10, 0x3f8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82A85104: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A85108: 396B22A4  addi r11, r11, 0x22a4
	ctx.r[11].s64 = ctx.r[11].s64 + 8868;
	// 82A8510C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A85110: 3929FE24  addi r9, r9, -0x1dc
	ctx.r[9].s64 = ctx.r[9].s64 + -476;
	// 82A85114: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A85118: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A8511C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A85120: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82A85124: 554A177A  rlwinm r10, r10, 2, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 82A85128: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82A8512C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A85130: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A85134: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A85138: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A8513C: 4BFFE7AD  bl 0x82a838e8
	ctx.lr = 0x82A85140;
	sub_82A838E8(ctx, base);
	// 82A85140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85144: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A85148: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8514C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A85150: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A85154: 419A0024  beq cr6, 0x82a85178
	if ctx.cr[6].eq {
	pc = 0x82A85178; continue 'dispatch;
	}
	// 82A85158: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A8515C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A85160: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A85164: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A85168: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A8516C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A85170: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A85174: 4082FFE8  bne 0x82a8515c
	if !ctx.cr[0].eq {
	pc = 0x82A8515C; continue 'dispatch;
	}
	// 82A85178: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A8517C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A85180: 4BA8A349  bl 0x8250f4c8
	ctx.lr = 0x82A85184;
	sub_8250F4C8(ctx, base);
	// 82A85184: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8518C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A85190: 409A0008  bne cr6, 0x82a85198
	if !ctx.cr[6].eq {
	pc = 0x82A85198; continue 'dispatch;
	}
	// 82A85194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85198: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82A8519C: 4BA8347D  bl 0x82508618
	ctx.lr = 0x82A851A0;
	sub_82508618(ctx, base);
	// 82A851A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A851A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A851A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A851AC: 388B2010  addi r4, r11, 0x2010
	ctx.r[4].s64 = ctx.r[11].s64 + 8208;
	// 82A851B0: 38A00449  li r5, 0x449
	ctx.r[5].s64 = 1097;
	// 82A851B4: 387C0038  addi r3, r28, 0x38
	ctx.r[3].s64 = ctx.r[28].s64 + 56;
	// 82A851B8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A851BC: 483D3885  bl 0x82e58a40
	ctx.lr = 0x82A851C0;
	sub_82E58A40(ctx, base);
	// 82A851C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A851C4: 4836CACD  bl 0x82df1c90
	ctx.lr = 0x82A851C8;
	sub_82DF1C90(ctx, base);
	// 82A851C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A851CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A851D0: 419A0008  beq cr6, 0x82a851d8
	if ctx.cr[6].eq {
	pc = 0x82A851D8; continue 'dispatch;
	}
	// 82A851D4: 4B83B6BD  bl 0x822c0890
	ctx.lr = 0x82A851D8;
	sub_822C0890(ctx, base);
	// 82A851D8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A851DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A851E0: 419A0008  beq cr6, 0x82a851e8
	if ctx.cr[6].eq {
	pc = 0x82A851E8; continue 'dispatch;
	}
	// 82A851E4: 4B83B6AD  bl 0x822c0890
	ctx.lr = 0x82A851E8;
	sub_822C0890(ctx, base);
	// 82A851E8: 817C03F8  lwz r11, 0x3f8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1016 as u32) ) } as u64;
	// 82A851EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A851F0: 917C03F8  stw r11, 0x3f8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1016 as u32), ctx.r[11].u32 ) };
	// 82A851F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A851F8: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 82A851FC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A85200: 4800004C  b 0x82a8524c
	pc = 0x82A8524C; continue 'dispatch;
	// 82A85204: 389D0040  addi r4, r29, 0x40
	ctx.r[4].s64 = ctx.r[29].s64 + 64;
	// 82A85208: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8520C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A85210: 483F6DC9  bl 0x82e7bfd8
	ctx.lr = 0x82A85214;
	sub_82E7BFD8(ctx, base);
	// 82A85214: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85218: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A8521C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A85220: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A85224: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A85228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8522C: 4E800421  bctrl
	ctx.lr = 0x82A85230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A85230: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85234: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A85238: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A8523C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A85240: 816B00F4  lwz r11, 0xf4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A85244: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A85248: 4E800421  bctrl
	ctx.lr = 0x82A8524C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A8524C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A85250: 4BFFF7B9  bl 0x82a84a08
	ctx.lr = 0x82A85254;
	sub_82A84A08(ctx, base);
	// 82A85254: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A85258: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A8525C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A85260: 48722F58  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A85268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A85268 size=848
    let mut pc: u32 = 0x82A85268;
    'dispatch: loop {
        match pc {
            0x82A85268 => {
    //   block [0x82A85268..0x82A855B8)
	// 82A85268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8526C: 48722EF5  bl 0x831a8160
	ctx.lr = 0x82A85270;
	sub_831A8130(ctx, base);
	// 82A85270: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A85274: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A85278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8527C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A85280: 807F0370  lwz r3, 0x370(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(880 as u32) ) } as u64;
	// 82A85284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A85288: 419A0324  beq cr6, 0x82a855ac
	if ctx.cr[6].eq {
	pc = 0x82A855AC; continue 'dispatch;
	}
	// 82A8528C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A85290: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A85294: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A85298: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8529C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A852A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A852A4: 4E800421  bctrl
	ctx.lr = 0x82A852A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A852A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A852AC: 41820300  beq 0x82a855ac
	if ctx.cr[0].eq {
	pc = 0x82A855AC; continue 'dispatch;
	}
	// 82A852B0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A852B4: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A852B8: 4BE91AE1  bl 0x82916d98
	ctx.lr = 0x82A852BC;
	sub_82916D98(ctx, base);
	// 82A852BC: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 82A852C0: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A852C4: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 82A852C8: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A852CC: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82A852D0: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 82A852D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A852D8: 13FB58C7  vcmpequd (lvx128) v31, v27, v11
	tmp.u32 = ctx.r[27].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A852DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A855B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A855B8 size=84
    let mut pc: u32 = 0x82A855B8;
    'dispatch: loop {
        match pc {
            0x82A855B8 => {
    //   block [0x82A855B8..0x82A8560C)
	// 82A855B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A855BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A855C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A855C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A855C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A855CC: 4BE8C215  bl 0x829117e0
	ctx.lr = 0x82A855D0;
	sub_829117E0(ctx, base);
	// 82A855D0: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 82A855D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A855D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A855DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A855E0: 4BA2FBF9  bl 0x824b51d8
	ctx.lr = 0x82A855E4;
	sub_824B51D8(ctx, base);
	// 82A855E4: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 82A855E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A855EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A855F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A855F4: 4BA2FBE5  bl 0x824b51d8
	ctx.lr = 0x82A855F8;
	sub_824B51D8(ctx, base);
	// 82A855F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A855FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A85600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A85604: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A85608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A85610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A85610 size=512
    let mut pc: u32 = 0x82A85610;
    'dispatch: loop {
        match pc {
            0x82A85610 => {
    //   block [0x82A85610..0x82A85810)
	// 82A85610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A85614: 48722B45  bl 0x831a8158
	ctx.lr = 0x82A85618;
	sub_831A8130(ctx, base);
	// 82A85618: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8561C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A85620: 3BFC0390  addi r31, r28, 0x390
	ctx.r[31].s64 = ctx.r[28].s64 + 912;
	// 82A85624: 817C0390  lwz r11, 0x390(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(912 as u32) ) } as u64;
	// 82A85628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8562C: 419A01DC  beq cr6, 0x82a85808
	if ctx.cr[6].eq {
	pc = 0x82A85808; continue 'dispatch;
	}
	// 82A85630: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82A85634: 3B7C0010  addi r27, r28, 0x10
	ctx.r[27].s64 = ctx.r[28].s64 + 16;
	// 82A85638: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A8563C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A85640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A85644: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A85648: 4BA8ABA9  bl 0x825101f0
	ctx.lr = 0x82A8564C;
	sub_825101F0(ctx, base);
	// 82A8564C: 3BDC0398  addi r30, r28, 0x398
	ctx.r[30].s64 = ctx.r[28].s64 + 920;
	// 82A85650: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A85654: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A85658: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A8565C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A85660: 4BA8AB91  bl 0x825101f0
	ctx.lr = 0x82A85664;
	sub_825101F0(ctx, base);
	// 82A85664: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A85668: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A8566C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A85670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A85674: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A85678: 419A0008  beq cr6, 0x82a85680
	if ctx.cr[6].eq {
	pc = 0x82A85680; continue 'dispatch;
	}
	// 82A8567C: 4B83B215  bl 0x822c0890
	ctx.lr = 0x82A85680;
	sub_822C0890(ctx, base);
	// 82A85680: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A85684: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A85688: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8568C: 935E0004  stw r26, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A85690: 419A0008  beq cr6, 0x82a85698
	if ctx.cr[6].eq {
	pc = 0x82A85698; continue 'dispatch;
	}
	// 82A85694: 4B83B1FD  bl 0x822c0890
	ctx.lr = 0x82A85698;
	sub_822C0890(ctx, base);
	// 82A85698: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A8569C: 4BA93BE5  bl 0x82519280
	ctx.lr = 0x82A856A0;
	sub_82519280(ctx, base);
	// 82A856A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A856A4: 418200D0  beq 0x82a85774
	if ctx.cr[0].eq {
	pc = 0x82A85774; continue 'dispatch;
	}
	// 82A856A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A856AC: 3B1C03C8  addi r24, r28, 0x3c8
	ctx.r[24].s64 = ctx.r[28].s64 + 968;
	// 82A856B0: 3B2B2010  addi r25, r11, 0x2010
	ctx.r[25].s64 = ctx.r[11].s64 + 8208;
	// 82A856B4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A856B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A856BC: 38A003AA  li r5, 0x3aa
	ctx.r[5].s64 = 938;
	// 82A856C0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A856C4: 4B83AD15  bl 0x822c03d8
	ctx.lr = 0x82A856C8;
	sub_822C03D8(ctx, base);
	// 82A856C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A856CC: 41820014  beq 0x82a856e0
	if ctx.cr[0].eq {
	pc = 0x82A856E0; continue 'dispatch;
	}
	// 82A856D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A856D4: 4800371D  bl 0x82a88df0
	ctx.lr = 0x82A856D8;
	sub_82A88DF0(ctx, base);
	// 82A856D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A856DC: 48000008  b 0x82a856e4
	pc = 0x82A856E4; continue 'dispatch;
	// 82A856E0: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82A856E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A856E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A856EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A856F0: 4BFFC779  bl 0x82a81e68
	ctx.lr = 0x82A856F4;
	sub_82A81E68(ctx, base);
	// 82A856F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A856F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A856FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A85700: 4B83A901  bl 0x822c0000
	ctx.lr = 0x82A85704;
	sub_822C0000(ctx, base);
	// 82A85704: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A85708: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A8570C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85710: 48003769  bl 0x82a88e78
	ctx.lr = 0x82A85714;
	sub_82A88E78(ctx, base);
	// 82A85714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85718: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8571C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A85720: 4BEBCFB1  bl 0x829426d0
	ctx.lr = 0x82A85724;
	sub_829426D0(ctx, base);
	// 82A85724: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A85728: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A8572C: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A85730: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A85734: 4BA8B425  bl 0x82510b58
	ctx.lr = 0x82A85738;
	sub_82510B58(ctx, base);
	// 82A85738: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A8573C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A85740: 419A0008  beq cr6, 0x82a85748
	if ctx.cr[6].eq {
	pc = 0x82A85748; continue 'dispatch;
	}
	// 82A85744: 4B83B14D  bl 0x822c0890
	ctx.lr = 0x82A85748;
	sub_822C0890(ctx, base);
	// 82A85748: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8574C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A85750: 4812D9B9  bl 0x82bb3108
	ctx.lr = 0x82A85754;
	sub_82BB3108(ctx, base);
	// 82A85754: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A85758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8575C: 419A0008  beq cr6, 0x82a85764
	if ctx.cr[6].eq {
	pc = 0x82A85764; continue 'dispatch;
	}
	// 82A85760: 4B83B131  bl 0x822c0890
	ctx.lr = 0x82A85764;
	sub_822C0890(ctx, base);
	// 82A85764: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A85768: 4BA93B19  bl 0x82519280
	ctx.lr = 0x82A8576C;
	sub_82519280(ctx, base);
	// 82A8576C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A85770: 4198FF44  blt cr6, 0x82a856b4
	if ctx.cr[6].lt {
	pc = 0x82A856B4; continue 'dispatch;
	}
	// 82A85774: 817C0100  lwz r11, 0x100(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A85778: 815C00FC  lwz r10, 0xfc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A8577C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A85780: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A85784: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A85788: 419A0024  beq cr6, 0x82a857ac
	if ctx.cr[6].eq {
	pc = 0x82A857AC; continue 'dispatch;
	}
	// 82A8578C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A85790: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A85794: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A85798: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8579C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A857A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A857A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A857A8: 4082FFE8  bne 0x82a85790
	if !ctx.cr[0].eq {
	pc = 0x82A85790; continue 'dispatch;
	}
	// 82A857AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A857B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A857B4: 4BA89D15  bl 0x8250f4c8
	ctx.lr = 0x82A857B8;
	sub_8250F4C8(ctx, base);
	// 82A857B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A857BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A857C0: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A857C4: 409A0008  bne cr6, 0x82a857cc
	if !ctx.cr[6].eq {
	pc = 0x82A857CC; continue 'dispatch;
	}
	// 82A857C8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82A857CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A857D0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A857D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A857D8: 3BCB1FD8  addi r30, r11, 0x1fd8
	ctx.r[30].s64 = ctx.r[11].s64 + 8152;
	// 82A857DC: 3BAA22C8  addi r29, r10, 0x22c8
	ctx.r[29].s64 = ctx.r[10].s64 + 8904;
	// 82A857E0: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A857E4: 4BE84C4D  bl 0x8290a430
	ctx.lr = 0x82A857E8;
	sub_8290A430(ctx, base);
	// 82A857E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A857EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A857F0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A857F4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A857F8: 480C0AF1  bl 0x82b462e8
	ctx.lr = 0x82A857FC;
	sub_82B462E8(ctx, base);
	// 82A857FC: 907C042C  stw r3, 0x42c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1068 as u32), ctx.r[3].u32 ) };
	// 82A85800: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A85804: 4836C48D  bl 0x82df1c90
	ctx.lr = 0x82A85808;
	sub_82DF1C90(ctx, base);
	// 82A85808: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A8580C: 4872299C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A85810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A85810 size=256
    let mut pc: u32 = 0x82A85810;
    'dispatch: loop {
        match pc {
            0x82A85810 => {
    //   block [0x82A85810..0x82A85910)
	// 82A85810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A85814: 48722959  bl 0x831a816c
	ctx.lr = 0x82A85818;
	sub_831A8130(ctx, base);
	// 82A85818: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8581C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A85820: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A85824: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A85828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8582C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A85830: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A85834: 388A22D8  addi r4, r10, 0x22d8
	ctx.r[4].s64 = ctx.r[10].s64 + 8920;
	// 82A85838: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A8583C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A85840: 4BFEE389  bl 0x82a73bc8
	ctx.lr = 0x82A85844;
	sub_82A73BC8(ctx, base);
	// 82A85844: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85848: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A8584C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A85850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A85854: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A85858: 419A0024  beq cr6, 0x82a8587c
	if ctx.cr[6].eq {
	pc = 0x82A8587C; continue 'dispatch;
	}
	// 82A8585C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A85860: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A85864: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A85868: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8586C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A85870: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A85874: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A85878: 4082FFE8  bne 0x82a85860
	if !ctx.cr[0].eq {
	pc = 0x82A85860; continue 'dispatch;
	}
	// 82A8587C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82A85880: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A85884: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A85888: 4BA89C41  bl 0x8250f4c8
	ctx.lr = 0x82A8588C;
	sub_8250F4C8(ctx, base);
	// 82A8588C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A85894: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A85898: 409A0008  bne cr6, 0x82a858a0
	if !ctx.cr[6].eq {
	pc = 0x82A858A0; continue 'dispatch;
	}
	// 82A8589C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A858A0: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82A858A4: 4BA82D75  bl 0x82508618
	ctx.lr = 0x82A858A8;
	sub_82508618(ctx, base);
	// 82A858A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A858AC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A858B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A858B4: 388A2010  addi r4, r10, 0x2010
	ctx.r[4].s64 = ctx.r[10].s64 + 8208;
	// 82A858B8: 38A005D1  li r5, 0x5d1
	ctx.r[5].s64 = 1489;
	// 82A858BC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82A858C0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A858C4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A858C8: 483D3179  bl 0x82e58a40
	ctx.lr = 0x82A858CC;
	sub_82E58A40(ctx, base);
	// 82A858CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A858D0: 4836C3C1  bl 0x82df1c90
	ctx.lr = 0x82A858D4;
	sub_82DF1C90(ctx, base);
	// 82A858D4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A858D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A858DC: 419A0008  beq cr6, 0x82a858e4
	if ctx.cr[6].eq {
	pc = 0x82A858E4; continue 'dispatch;
	}
	// 82A858E0: 4B83AFB1  bl 0x822c0890
	ctx.lr = 0x82A858E4;
	sub_822C0890(ctx, base);
	// 82A858E4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A858E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A858EC: 419A0008  beq cr6, 0x82a858f4
	if ctx.cr[6].eq {
	pc = 0x82A858F4; continue 'dispatch;
	}
	// 82A858F0: 4B83AFA1  bl 0x822c0890
	ctx.lr = 0x82A858F4;
	sub_822C0890(ctx, base);
	// 82A858F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A858F8: 4BFFFD19  bl 0x82a85610
	ctx.lr = 0x82A858FC;
	sub_82A85610(ctx, base);
	// 82A858FC: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82A85900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A85904: 4BA8A14D  bl 0x8250fa50
	ctx.lr = 0x82A85908;
	sub_8250FA50(ctx, base);
	// 82A85908: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A8590C: 487228B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A85910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A85910 size=612
    let mut pc: u32 = 0x82A85910;
    'dispatch: loop {
        match pc {
            0x82A85910 => {
    //   block [0x82A85910..0x82A85B74)
	// 82A85910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A85914: 48722855  bl 0x831a8168
	ctx.lr = 0x82A85918;
	sub_831A8130(ctx, base);
	// 82A85918: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8591C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A85920: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A85924: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A85928: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A8592C: 41820038  beq 0x82a85964
	if ctx.cr[0].eq {
	pc = 0x82A85964; continue 'dispatch;
	}
	// 82A85930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85934: 48724055  bl 0x831a9988
	ctx.lr = 0x82A85938;
	sub_831A9988(ctx, base);
	// 82A85938: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A8593C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85940: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 82A85944: 487227B5  bl 0x831a80f8
	ctx.lr = 0x82A85948;
	sub_831A80F8(ctx, base);
	// 82A85948: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8594C: 41820018  beq 0x82a85964
	if ctx.cr[0].eq {
	pc = 0x82A85964; continue 'dispatch;
	}
	// 82A85950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85954: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85958: 4BFFD0F9  bl 0x82a82a50
	ctx.lr = 0x82A8595C;
	sub_82A82A50(ctx, base);
	// 82A8595C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A85960: 4800020C  b 0x82a85b6c
	pc = 0x82A85B6C; continue 'dispatch;
	// 82A85964: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A85968: 419A01F4  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A8596C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85970: 48724019  bl 0x831a9988
	ctx.lr = 0x82A85974;
	sub_831A9988(ctx, base);
	// 82A85974: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A85978: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A8597C: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82A85980: 48722779  bl 0x831a80f8
	ctx.lr = 0x82A85984;
	sub_831A80F8(ctx, base);
	// 82A85984: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A85988: 41820014  beq 0x82a8599c
	if ctx.cr[0].eq {
	pc = 0x82A8599C; continue 'dispatch;
	}
	// 82A8598C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85990: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85994: 4BFFF8D5  bl 0x82a85268
	ctx.lr = 0x82A85998;
	sub_82A85268(ctx, base);
	// 82A85998: 4BFFFFC4  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A8599C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A859A0: 419A01BC  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A859A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A859A8: 48723FE1  bl 0x831a9988
	ctx.lr = 0x82A859AC;
	sub_831A9988(ctx, base);
	// 82A859AC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A859B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A859B4: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A859B8: 48722741  bl 0x831a80f8
	ctx.lr = 0x82A859BC;
	sub_831A80F8(ctx, base);
	// 82A859BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A859C0: 41820014  beq 0x82a859d4
	if ctx.cr[0].eq {
	pc = 0x82A859D4; continue 'dispatch;
	}
	// 82A859C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A859C8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A859CC: 4BE54515  bl 0x828d9ee0
	ctx.lr = 0x82A859D0;
	sub_828D9EE0(ctx, base);
	// 82A859D0: 4BFFFF8C  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A859D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A859D8: 419A0184  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A859DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A859E0: 48723FA9  bl 0x831a9988
	ctx.lr = 0x82A859E4;
	sub_831A9988(ctx, base);
	// 82A859E4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A859E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A859EC: 386B5AB4  addi r3, r11, 0x5ab4
	ctx.r[3].s64 = ctx.r[11].s64 + 23220;
	// 82A859F0: 48722709  bl 0x831a80f8
	ctx.lr = 0x82A859F4;
	sub_831A80F8(ctx, base);
	// 82A859F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A859F8: 41820014  beq 0x82a85a0c
	if ctx.cr[0].eq {
	pc = 0x82A85A0C; continue 'dispatch;
	}
	// 82A859FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85A00: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85A04: 4BFFD12D  bl 0x82a82b30
	ctx.lr = 0x82A85A08;
	sub_82A82B30(ctx, base);
	// 82A85A08: 4BFFFF54  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A85A0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A85A10: 419A014C  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A85A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85A18: 48723F71  bl 0x831a9988
	ctx.lr = 0x82A85A1C;
	sub_831A9988(ctx, base);
	// 82A85A1C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A85A20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85A24: 386B31EC  addi r3, r11, 0x31ec
	ctx.r[3].s64 = ctx.r[11].s64 + 12780;
	// 82A85A28: 487226D1  bl 0x831a80f8
	ctx.lr = 0x82A85A2C;
	sub_831A80F8(ctx, base);
	// 82A85A2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A85A30: 41820014  beq 0x82a85a44
	if ctx.cr[0].eq {
	pc = 0x82A85A44; continue 'dispatch;
	}
	// 82A85A34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85A38: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85A3C: 4BFFD1AD  bl 0x82a82be8
	ctx.lr = 0x82A85A40;
	sub_82A82BE8(ctx, base);
	// 82A85A40: 4BFFFF1C  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A85A44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A85A48: 419A0114  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A85A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85A50: 48723F39  bl 0x831a9988
	ctx.lr = 0x82A85A54;
	sub_831A9988(ctx, base);
	// 82A85A54: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A85A58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85A5C: 386B2F78  addi r3, r11, 0x2f78
	ctx.r[3].s64 = ctx.r[11].s64 + 12152;
	// 82A85A60: 48722699  bl 0x831a80f8
	ctx.lr = 0x82A85A64;
	sub_831A80F8(ctx, base);
	// 82A85A64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A85A68: 41820014  beq 0x82a85a7c
	if ctx.cr[0].eq {
	pc = 0x82A85A7C; continue 'dispatch;
	}
	// 82A85A6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85A70: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85A74: 4BFFBDFD  bl 0x82a81870
	ctx.lr = 0x82A85A78;
	sub_82A81870(ctx, base);
	// 82A85A78: 4BFFFEE4  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A85A7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A85A80: 419A00DC  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A85A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85A88: 48723F01  bl 0x831a9988
	ctx.lr = 0x82A85A8C;
	sub_831A9988(ctx, base);
	// 82A85A8C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A85A90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85A94: 386B99A8  addi r3, r11, -0x6658
	ctx.r[3].s64 = ctx.r[11].s64 + -26200;
	// 82A85A98: 48722661  bl 0x831a80f8
	ctx.lr = 0x82A85A9C;
	sub_831A80F8(ctx, base);
	// 82A85A9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A85AA0: 41820014  beq 0x82a85ab4
	if ctx.cr[0].eq {
	pc = 0x82A85AB4; continue 'dispatch;
	}
	// 82A85AA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85AA8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85AAC: 4BFFC175  bl 0x82a81c20
	ctx.lr = 0x82A85AB0;
	sub_82A81C20(ctx, base);
	// 82A85AB0: 4BFFFEAC  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A85AB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A85AB8: 419A00A4  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A85ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85AC0: 48723EC9  bl 0x831a9988
	ctx.lr = 0x82A85AC4;
	sub_831A9988(ctx, base);
	// 82A85AC4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A85AC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85ACC: 386B9978  addi r3, r11, -0x6688
	ctx.r[3].s64 = ctx.r[11].s64 + -26248;
	// 82A85AD0: 48722629  bl 0x831a80f8
	ctx.lr = 0x82A85AD4;
	sub_831A80F8(ctx, base);
	// 82A85AD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A85AD8: 41820014  beq 0x82a85aec
	if ctx.cr[0].eq {
	pc = 0x82A85AEC; continue 'dispatch;
	}
	// 82A85ADC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85AE0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85AE4: 4BFFD1E5  bl 0x82a82cc8
	ctx.lr = 0x82A85AE8;
	sub_82A82CC8(ctx, base);
	// 82A85AE8: 4BFFFE74  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A85AEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A85AF0: 419A006C  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A85AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85AF8: 48723E91  bl 0x831a9988
	ctx.lr = 0x82A85AFC;
	sub_831A9988(ctx, base);
	// 82A85AFC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A85B00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85B04: 386B9948  addi r3, r11, -0x66b8
	ctx.r[3].s64 = ctx.r[11].s64 + -26296;
	// 82A85B08: 487225F1  bl 0x831a80f8
	ctx.lr = 0x82A85B0C;
	sub_831A80F8(ctx, base);
	// 82A85B0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A85B10: 41820014  beq 0x82a85b24
	if ctx.cr[0].eq {
	pc = 0x82A85B24; continue 'dispatch;
	}
	// 82A85B14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85B18: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85B1C: 4BFFE54D  bl 0x82a84068
	ctx.lr = 0x82A85B20;
	sub_82A84068(ctx, base);
	// 82A85B20: 4BFFFE3C  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A85B24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A85B28: 419A0034  beq cr6, 0x82a85b5c
	if ctx.cr[6].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A85B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A85B30: 48723E59  bl 0x831a9988
	ctx.lr = 0x82A85B34;
	sub_831A9988(ctx, base);
	// 82A85B34: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A85B38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85B3C: 386B991C  addi r3, r11, -0x66e4
	ctx.r[3].s64 = ctx.r[11].s64 + -26340;
	// 82A85B40: 487225B9  bl 0x831a80f8
	ctx.lr = 0x82A85B44;
	sub_831A80F8(ctx, base);
	// 82A85B44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A85B48: 41820014  beq 0x82a85b5c
	if ctx.cr[0].eq {
	pc = 0x82A85B5C; continue 'dispatch;
	}
	// 82A85B4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85B50: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82A85B54: 4BFFFCBD  bl 0x82a85810
	ctx.lr = 0x82A85B58;
	sub_82A85810(ctx, base);
	// 82A85B58: 4BFFFE04  b 0x82a8595c
	pc = 0x82A8595C; continue 'dispatch;
	// 82A85B5C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A85B60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A85B64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A85B68: 4BE89F29  bl 0x8290fa90
	ctx.lr = 0x82A85B6C;
	sub_8290FA90(ctx, base);
	// 82A85B6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A85B70: 48722648  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A85B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A85B78 size=1012
    let mut pc: u32 = 0x82A85B78;
    'dispatch: loop {
        match pc {
            0x82A85B78 => {
    //   block [0x82A85B78..0x82A85F6C)
	// 82A85B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A85B7C: 487225D9  bl 0x831a8154
	ctx.lr = 0x82A85B80;
	sub_831A8130(ctx, base);
	// 82A85B80: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A85B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A85B88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A85B8C: 3B1F0010  addi r24, r31, 0x10
	ctx.r[24].s64 = ctx.r[31].s64 + 16;
	// 82A85B90: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A85B94: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A85B98: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82A85B9C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A85BA0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A85BA4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82A85BA8: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 82A85BAC: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82A85BB0: 4BA89919  bl 0x8250f4c8
	ctx.lr = 0x82A85BB4;
	sub_8250F4C8(ctx, base);
	// 82A85BB4: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A85BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A85BBC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A85BC0: 409A0008  bne cr6, 0x82a85bc8
	if !ctx.cr[6].eq {
	pc = 0x82A85BC8; continue 'dispatch;
	}
	// 82A85BC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A85BC8: 4BA82961  bl 0x82508528
	ctx.lr = 0x82A85BCC;
	sub_82508528(ctx, base);
	// 82A85BCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85BD0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A85BD4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A85BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A85BDC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A85BE0: 419A0024  beq cr6, 0x82a85c04
	if ctx.cr[6].eq {
	pc = 0x82A85C04; continue 'dispatch;
	}
	// 82A85BE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A85BE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A85BEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A85BF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A85BF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A85BF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A85BFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A85C00: 4082FFE8  bne 0x82a85be8
	if !ctx.cr[0].eq {
	pc = 0x82A85BE8; continue 'dispatch;
	}
	// 82A85C04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A85C08: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A85C0C: 483A4EDD  bl 0x82e2aae8
	ctx.lr = 0x82A85C10;
	sub_82E2AAE8(ctx, base);
	// 82A85C10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A85C14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A85C18: 4836DDF1  bl 0x82df3a08
	ctx.lr = 0x82A85C1C;
	sub_82DF3A08(ctx, base);
	// 82A85C1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A85C20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A85C24: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A85C28: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A85C2C: 483A9245  bl 0x82e2ee70
	ctx.lr = 0x82A85C30;
	sub_82E2EE70(ctx, base);
	// 82A85C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A85C34: 4836D7F5  bl 0x82df3428
	ctx.lr = 0x82A85C38;
	sub_82DF3428(ctx, base);
	// 82A85C38: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A85C3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A85C40: 3BAB2010  addi r29, r11, 0x2010
	ctx.r[29].s64 = ctx.r[11].s64 + 8208;
	// 82A85C44: 38A003EF  li r5, 0x3ef
	ctx.r[5].s64 = 1007;
	// 82A85C48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A85C4C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A85C50: 4836C799  bl 0x82df23e8
	ctx.lr = 0x82A85C54;
	sub_82DF23E8(ctx, base);
	// 82A85C54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A85C58: 41820014  beq 0x82a85c6c
	if ctx.cr[0].eq {
	pc = 0x82A85C6C; continue 'dispatch;
	}
	// 82A85C5C: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82A85C60: 48390C31  bl 0x82e16890
	ctx.lr = 0x82A85C64;
	sub_82E16890(ctx, base);
	// 82A85C64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A85C68: 48000008  b 0x82a85c70
	pc = 0x82A85C70; continue 'dispatch;
	// 82A85C6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A85C70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A85C74: 4B8D76FD  bl 0x8235d370
	ctx.lr = 0x82A85C78;
	sub_8235D370(ctx, base);
	// 82A85C78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A85C7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A85C80: 4836DD89  bl 0x82df3a08
	ctx.lr = 0x82A85C84;
	sub_82DF3A08(ctx, base);
	// 82A85C84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A85C88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A85C8C: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A85C90: 4838F3A1  bl 0x82e15030
	ctx.lr = 0x82A85C94;
	sub_82E15030(ctx, base);
	// 82A85C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A85C98: 4836D791  bl 0x82df3428
	ctx.lr = 0x82A85C9C;
	sub_82DF3428(ctx, base);
	// 82A85C9C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A85CA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85CA4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A85CA8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A85CAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A85CB0: 4E800421  bctrl
	ctx.lr = 0x82A85CB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A85CB4: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A85CB8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A85CBC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A85CC0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82A85CC4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A85CC8: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82A85CCC: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A85CD0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A85CD4: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A85CD8: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A85CDC: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A85F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A85F70 size=1560
    let mut pc: u32 = 0x82A85F70;
    'dispatch: loop {
        match pc {
            0x82A85F70 => {
    //   block [0x82A85F70..0x82A86588)
	// 82A85F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A85F74: 487221F1  bl 0x831a8164
	ctx.lr = 0x82A85F78;
	sub_831A8130(ctx, base);
	// 82A85F78: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82A85F7C: 48722AF9  bl 0x831a8a74
	ctx.lr = 0x82A85F80;
	sub_831A8A40(ctx, base);
	// 82A85F80: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A85F84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A85F88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A85F8C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A85F90: 3BEB24A4  addi r31, r11, 0x24a4
	ctx.r[31].s64 = ctx.r[11].s64 + 9380;
	// 82A85F94: 38CA248C  addi r6, r10, 0x248c
	ctx.r[6].s64 = ctx.r[10].s64 + 9356;
	// 82A85F98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A85F9C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A85FA0: 389E0380  addi r4, r30, 0x380
	ctx.r[4].s64 = ctx.r[30].s64 + 896;
	// 82A85FA4: 4BFFDDB5  bl 0x82a83d58
	ctx.lr = 0x82A85FA8;
	sub_82A83D58(ctx, base);
	// 82A85FA8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A85FAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A85FB0: 38CB2474  addi r6, r11, 0x2474
	ctx.r[6].s64 = ctx.r[11].s64 + 9332;
	// 82A85FB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A85FB8: 389E0388  addi r4, r30, 0x388
	ctx.r[4].s64 = ctx.r[30].s64 + 904;
	// 82A85FBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A85FC0: 4BFFDD99  bl 0x82a83d58
	ctx.lr = 0x82A85FC4;
	sub_82A83D58(ctx, base);
	// 82A85FC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A85FC8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A85FCC: 38CB245C  addi r6, r11, 0x245c
	ctx.r[6].s64 = ctx.r[11].s64 + 9308;
	// 82A85FD0: 38AA244C  addi r5, r10, 0x244c
	ctx.r[5].s64 = ctx.r[10].s64 + 9292;
	// 82A85FD4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A85FD8: 389E0390  addi r4, r30, 0x390
	ctx.r[4].s64 = ctx.r[30].s64 + 912;
	// 82A85FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A85FE0: 4BFFDD79  bl 0x82a83d58
	ctx.lr = 0x82A85FE4;
	sub_82A83D58(ctx, base);
	// 82A85FE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A85FE8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A85FEC: 38CB2434  addi r6, r11, 0x2434
	ctx.r[6].s64 = ctx.r[11].s64 + 9268;
	// 82A85FF0: 38AA2424  addi r5, r10, 0x2424
	ctx.r[5].s64 = ctx.r[10].s64 + 9252;
	// 82A85FF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A85FF8: 389E0398  addi r4, r30, 0x398
	ctx.r[4].s64 = ctx.r[30].s64 + 920;
	// 82A85FFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A86000: 4BFFDD59  bl 0x82a83d58
	ctx.lr = 0x82A86004;
	sub_82A83D58(ctx, base);
	// 82A86004: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86008: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A8600C: 38CB229C  addi r6, r11, 0x229c
	ctx.r[6].s64 = ctx.r[11].s64 + 8860;
	// 82A86010: 38AA2414  addi r5, r10, 0x2414
	ctx.r[5].s64 = ctx.r[10].s64 + 9236;
	// 82A86014: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A86018: 389E03A0  addi r4, r30, 0x3a0
	ctx.r[4].s64 = ctx.r[30].s64 + 928;
	// 82A8601C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A86020: 4BFFDD39  bl 0x82a83d58
	ctx.lr = 0x82A86024;
	sub_82A83D58(ctx, base);
	// 82A86024: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A86028: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8602C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82A86030: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82A86034: 390A2400  addi r8, r10, 0x2400
	ctx.r[8].s64 = ctx.r[10].s64 + 9216;
	// 82A86038: 392B23E4  addi r9, r11, 0x23e4
	ctx.r[9].s64 = ctx.r[11].s64 + 9188;
	// 82A8603C: 38E77868  addi r7, r7, 0x7868
	ctx.r[7].s64 = ctx.r[7].s64 + 30824;
	// 82A86040: 38C623D0  addi r6, r6, 0x23d0
	ctx.r[6].s64 = ctx.r[6].s64 + 9168;
	// 82A86044: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A86048: 38BE03B0  addi r5, r30, 0x3b0
	ctx.r[5].s64 = ctx.r[30].s64 + 944;
	// 82A8604C: 389E03A8  addi r4, r30, 0x3a8
	ctx.r[4].s64 = ctx.r[30].s64 + 936;
	// 82A86050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A86054: 4BFFFB25  bl 0x82a85b78
	ctx.lr = 0x82A86058;
	sub_82A85B78(ctx, base);
	// 82A86058: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8605C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A86060: 3B9E03B8  addi r28, r30, 0x3b8
	ctx.r[28].s64 = ctx.r[30].s64 + 952;
	// 82A86064: 3B6B2010  addi r27, r11, 0x2010
	ctx.r[27].s64 = ctx.r[11].s64 + 8208;
	// 82A86068: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A8606C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A86070: 38A004AA  li r5, 0x4aa
	ctx.r[5].s64 = 1194;
	// 82A86074: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82A86078: 4B83A361  bl 0x822c03d8
	ctx.lr = 0x82A8607C;
	sub_822C03D8(ctx, base);
	// 82A8607C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A86080: 41820014  beq 0x82a86094
	if ctx.cr[0].eq {
	pc = 0x82A86094; continue 'dispatch;
	}
	// 82A86084: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A86088: 48004011  bl 0x82a8a098
	ctx.lr = 0x82A8608C;
	sub_82A8A098(ctx, base);
	// 82A8608C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A86090: 48000008  b 0x82a86098
	pc = 0x82A86098; continue 'dispatch;
	// 82A86094: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A86098: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A8609C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A860A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A860A4: 4BFFBE8D  bl 0x82a81f30
	ctx.lr = 0x82A860A8;
	sub_82A81F30(ctx, base);
	// 82A860A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A860AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A860B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A860B4: 4B839F4D  bl 0x822c0000
	ctx.lr = 0x82A860B8;
	sub_822C0000(ctx, base);
	// 82A860B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A860BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A860C0: 480048E1  bl 0x82a8a9a0
	ctx.lr = 0x82A860C4;
	sub_82A8A9A0(ctx, base);
	// 82A860C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A860C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A860CC: 4812D03D  bl 0x82bb3108
	ctx.lr = 0x82A860D0;
	sub_82BB3108(ctx, base);
	// 82A860D0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A860D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A860D8: 419A0008  beq cr6, 0x82a860e0
	if ctx.cr[6].eq {
	pc = 0x82A860E0; continue 'dispatch;
	}
	// 82A860DC: 4B83A7B5  bl 0x822c0890
	ctx.lr = 0x82A860E0;
	sub_822C0890(ctx, base);
	// 82A860E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A860E4: 2F1D0008  cmpwi cr6, r29, 8
	ctx.cr[6].compare_i32(ctx.r[29].s32, 8, &mut ctx.xer);
	// 82A860E8: 4198FF80  blt cr6, 0x82a86068
	if ctx.cr[6].lt {
	pc = 0x82A86068; continue 'dispatch;
	}
	// 82A860EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A860F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A860F4: 38A004B3  li r5, 0x4b3
	ctx.r[5].s64 = 1203;
	// 82A860F8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A860FC: 4B83A2DD  bl 0x822c03d8
	ctx.lr = 0x82A86100;
	sub_822C03D8(ctx, base);
	// 82A86100: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A86104: 41820010  beq 0x82a86114
	if ctx.cr[0].eq {
	pc = 0x82A86114; continue 'dispatch;
	}
	// 82A86108: 48002821  bl 0x82a88928
	ctx.lr = 0x82A8610C;
	sub_82A88928(ctx, base);
	// 82A8610C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A86110: 48000008  b 0x82a86118
	pc = 0x82A86118; continue 'dispatch;
	// 82A86114: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A86118: 387E03D8  addi r3, r30, 0x3d8
	ctx.r[3].s64 = ctx.r[30].s64 + 984;
	// 82A8611C: 4BFFD885  bl 0x82a839a0
	ctx.lr = 0x82A86120;
	sub_82A839A0(ctx, base);
	// 82A86120: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A86124: 807E03D8  lwz r3, 0x3d8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(984 as u32) ) } as u64;
	// 82A86128: 48002879  bl 0x82a889a0
	ctx.lr = 0x82A8612C;
	sub_82A889A0(ctx, base);
	// 82A8612C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A86130: 809E03D8  lwz r4, 0x3d8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(984 as u32) ) } as u64;
	// 82A86134: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A86138: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 82A8613C: 4BA7915D  bl 0x824ff298
	ctx.lr = 0x82A86140;
	sub_824FF298(ctx, base);
	// 82A86140: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A86144: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A86148: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A8614C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A86150: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A86154: 4BA8AA05  bl 0x82510b58
	ctx.lr = 0x82A86158;
	sub_82510B58(ctx, base);
	// 82A86158: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A8615C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A86160: 419A0008  beq cr6, 0x82a86168
	if ctx.cr[6].eq {
	pc = 0x82A86168; continue 'dispatch;
	}
	// 82A86164: 4B83A72D  bl 0x822c0890
	ctx.lr = 0x82A86168;
	sub_822C0890(ctx, base);
	// 82A86168: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A8616C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A86170: 3BEBE130  addi r31, r11, -0x1ed0
	ctx.r[31].s64 = ctx.r[11].s64 + -7888;
	// 82A86174: 816AE2E0  lwz r11, -0x1d20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7456 as u32) ) } as u64;
	// 82A86178: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A8617C: 40820314  bne 0x82a86490
	if !ctx.cr[0].eq {
	pc = 0x82A86490; continue 'dispatch;
	}
	// 82A86180: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A86184: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A86188: 916AE2E0  stw r11, -0x1d20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7456 as u32), ctx.r[11].u32 ) };
	// 82A8618C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A86190: 388923C4  addi r4, r9, 0x23c4
	ctx.r[4].s64 = ctx.r[9].s64 + 9156;
	// 82A86194: 4836D875  bl 0x82df3a08
	ctx.lr = 0x82A86198;
	sub_82DF3A08(ctx, base);
	// 82A86198: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8619C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A861A0: 388B23A8  addi r4, r11, 0x23a8
	ctx.r[4].s64 = ctx.r[11].s64 + 9128;
	// 82A861A4: 4836D865  bl 0x82df3a08
	ctx.lr = 0x82A861A8;
	sub_82DF3A08(ctx, base);
	// 82A861A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A861AC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A861B0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A861B4: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A861B8: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 82A861BC: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A861C0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A861C4: C00995A0  lfs f0, -0x6a60(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A861C8: 3887239C  addi r4, r7, 0x239c
	ctx.r[4].s64 = ctx.r[7].s64 + 9116;
	// 82A861CC: C3C808A8  lfs f30, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A861D0: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82A861D4: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A861D8: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A861DC: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A861E0: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A861E4: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A861E8: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A861EC: D3DF0024  stfs f30, 0x24(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A861F0: D3DF0028  stfs f30, 0x28(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82A861F4: D3DF002C  stfs f30, 0x2c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A861F8: 4836D811  bl 0x82df3a08
	ctx.lr = 0x82A861FC;
	sub_82DF3A08(ctx, base);
	// 82A861FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86200: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82A86204: 3BAB2384  addi r29, r11, 0x2384
	ctx.r[29].s64 = ctx.r[11].s64 + 9092;
	// 82A86208: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A8620C: 4836D7FD  bl 0x82df3a08
	ctx.lr = 0x82A86210;
	sub_82DF3A08(ctx, base);
	// 82A86210: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A86214: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A86218: D3FF003C  stfs f31, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82A8621C: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A86220: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82A86224: D3FF0044  stfs f31, 0x44(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82A86228: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A8622C: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82A86230: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82A86234: C38A2380  lfs f28, 0x2380(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9088 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A86238: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82A8623C: C3A9093C  lfs f29, 0x93c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2364 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A86240: 38882374  addi r4, r8, 0x2374
	ctx.r[4].s64 = ctx.r[8].s64 + 9076;
	// 82A86244: D39F0048  stfs f28, 0x48(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82A86248: D3BF0050  stfs f29, 0x50(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A8624C: D3DF0054  stfs f30, 0x54(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A86250: D3DF0058  stfs f30, 0x58(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A86254: D3DF005C  stfs f30, 0x5c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A86258: 4836D7B1  bl 0x82df3a08
	ctx.lr = 0x82A8625C;
	sub_82DF3A08(ctx, base);
	// 82A8625C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A86260: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82A86264: 4836D7A5  bl 0x82df3a08
	ctx.lr = 0x82A86268;
	sub_82DF3A08(ctx, base);
	// 82A86268: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A8626C: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A86270: D3FF006C  stfs f31, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A86274: D3FF0070  stfs f31, 0x70(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A86278: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A8627C: D3FF0074  stfs f31, 0x74(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A86280: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A86284: D39F0078  stfs f28, 0x78(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A86288: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 82A8628C: C00AF524  lfs f0, -0xadc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A86290: 38892368  addi r4, r9, 0x2368
	ctx.r[4].s64 = ctx.r[9].s64 + 9064;
	// 82A86294: D3FF007C  stfs f31, 0x7c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A86298: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A8629C: D3DF0084  stfs f30, 0x84(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A862A0: D3DF0088  stfs f30, 0x88(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A862A4: D3DF008C  stfs f30, 0x8c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A862A8: 4836D761  bl 0x82df3a08
	ctx.lr = 0x82A862AC;
	sub_82DF3A08(ctx, base);
	// 82A862AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A862B0: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 82A862B4: 3BAB2350  addi r29, r11, 0x2350
	ctx.r[29].s64 = ctx.r[11].s64 + 9040;
	// 82A862B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A862BC: 4836D74D  bl 0x82df3a08
	ctx.lr = 0x82A862C0;
	sub_82DF3A08(ctx, base);
	// 82A862C0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A862C4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A862C8: C38AD0F8  lfs f28, -0x2f08(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A862CC: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A862D0: D3FF009C  stfs f31, 0x9c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A862D4: D3FF00A0  stfs f31, 0xa0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A862D8: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A862DC: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A862E0: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82A862E4: D3FF00AC  stfs f31, 0xac(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A862E8: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 82A862EC: C369C5F0  lfs f27, -0x3a10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14864 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82A862F0: 38882344  addi r4, r8, 0x2344
	ctx.r[4].s64 = ctx.r[8].s64 + 9028;
	// 82A862F4: D3DF00B4  stfs f30, 0xb4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82A862F8: D39F00A8  stfs f28, 0xa8(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A862FC: D37F00B0  stfs f27, 0xb0(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82A86300: D3DF00B8  stfs f30, 0xb8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82A86304: D3DF00BC  stfs f30, 0xbc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82A86308: 4836D701  bl 0x82df3a08
	ctx.lr = 0x82A8630C;
	sub_82DF3A08(ctx, base);
	// 82A8630C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A86310: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 82A86314: 4836D6F5  bl 0x82df3a08
	ctx.lr = 0x82A86318;
	sub_82DF3A08(ctx, base);
	// 82A86318: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A8631C: D3FF00CC  stfs f31, 0xcc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82A86320: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A86324: D3FF00D0  stfs f31, 0xd0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82A86328: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82A8632C: D3FF00D4  stfs f31, 0xd4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82A86330: 388A2338  addi r4, r10, 0x2338
	ctx.r[4].s64 = ctx.r[10].s64 + 9016;
	// 82A86334: D39F00D8  stfs f28, 0xd8(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82A86338: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 82A8633C: D3FF00DC  stfs f31, 0xdc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82A86340: D37F00E0  stfs f27, 0xe0(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82A86344: D3DF00E4  stfs f30, 0xe4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A86348: D3DF00E8  stfs f30, 0xe8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82A8634C: D3DF00EC  stfs f30, 0xec(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82A86350: 4836D6B9  bl 0x82df3a08
	ctx.lr = 0x82A86354;
	sub_82DF3A08(ctx, base);
	// 82A86354: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86358: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 82A8635C: 3BAB2320  addi r29, r11, 0x2320
	ctx.r[29].s64 = ctx.r[11].s64 + 8992;
	// 82A86360: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A86364: 4836D6A5  bl 0x82df3a08
	ctx.lr = 0x82A86368;
	sub_82DF3A08(ctx, base);
	// 82A86368: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A8636C: D3FF00FC  stfs f31, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82A86370: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A86374: D3FF0100  stfs f31, 0x100(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82A86378: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A8637C: D3FF0104  stfs f31, 0x104(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A86380: 387F0120  addi r3, r31, 0x120
	ctx.r[3].s64 = ctx.r[31].s64 + 288;
	// 82A86384: D3BF0108  stfs f29, 0x108(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A86388: 388A2314  addi r4, r10, 0x2314
	ctx.r[4].s64 = ctx.r[10].s64 + 8980;
	// 82A8638C: D3FF010C  stfs f31, 0x10c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A86390: D3FF0110  stfs f31, 0x110(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82A86394: D3DF0114  stfs f30, 0x114(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82A86398: D3DF0118  stfs f30, 0x118(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82A8639C: D3DF011C  stfs f30, 0x11c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82A863A0: 4836D669  bl 0x82df3a08
	ctx.lr = 0x82A863A4;
	sub_82DF3A08(ctx, base);
	// 82A863A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A863A8: 387F0124  addi r3, r31, 0x124
	ctx.r[3].s64 = ctx.r[31].s64 + 292;
	// 82A863AC: 4836D65D  bl 0x82df3a08
	ctx.lr = 0x82A863B0;
	sub_82DF3A08(ctx, base);
	// 82A863B0: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A863B4: D3FF012C  stfs f31, 0x12c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82A863B8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A863BC: D3FF0130  stfs f31, 0x130(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82A863C0: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82A863C4: D3FF0134  stfs f31, 0x134(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82A863C8: 387F0150  addi r3, r31, 0x150
	ctx.r[3].s64 = ctx.r[31].s64 + 336;
	// 82A863CC: D3BF0138  stfs f29, 0x138(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82A863D0: 388A2304  addi r4, r10, 0x2304
	ctx.r[4].s64 = ctx.r[10].s64 + 8964;
	// 82A863D4: D3FF013C  stfs f31, 0x13c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82A863D8: D3FF0140  stfs f31, 0x140(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82A863DC: D3DF0144  stfs f30, 0x144(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82A863E0: D3DF0148  stfs f30, 0x148(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82A863E4: D3DF014C  stfs f30, 0x14c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82A863E8: 4836D621  bl 0x82df3a08
	ctx.lr = 0x82A863EC;
	sub_82DF3A08(ctx, base);
	// 82A863EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A863F0: 387F0154  addi r3, r31, 0x154
	ctx.r[3].s64 = ctx.r[31].s64 + 340;
	// 82A863F4: 4836D615  bl 0x82df3a08
	ctx.lr = 0x82A863F8;
	sub_82DF3A08(ctx, base);
	// 82A863F8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A863FC: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82A86400: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A86404: C009D72C  lfs f0, -0x28d4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A86408: C3AA6974  lfs f29, 0x6974(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26996 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A8640C: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82A86410: D3FF015C  stfs f31, 0x15c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 82A86414: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86418: D3FF0160  stfs f31, 0x160(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82A8641C: 387F0180  addi r3, r31, 0x180
	ctx.r[3].s64 = ctx.r[31].s64 + 384;
	// 82A86420: D3FF0164  stfs f31, 0x164(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82A86424: 388B22F4  addi r4, r11, 0x22f4
	ctx.r[4].s64 = ctx.r[11].s64 + 8948;
	// 82A86428: D3BF0168  stfs f29, 0x168(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82A8642C: D01F016C  stfs f0, 0x16c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82A86430: D3FF0170  stfs f31, 0x170(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 82A86434: D3DF0174  stfs f30, 0x174(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82A86438: D3DF0178  stfs f30, 0x178(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 82A8643C: D3DF017C  stfs f30, 0x17c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 82A86440: 4836D5C9  bl 0x82df3a08
	ctx.lr = 0x82A86444;
	sub_82DF3A08(ctx, base);
	// 82A86444: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A86448: 387F0184  addi r3, r31, 0x184
	ctx.r[3].s64 = ctx.r[31].s64 + 388;
	// 82A8644C: 4836D5BD  bl 0x82df3a08
	ctx.lr = 0x82A86450;
	sub_82DF3A08(ctx, base);
	// 82A86450: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A86454: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A86458: D3FF018C  stfs f31, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A8645C: D3FF0190  stfs f31, 0x190(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A86460: 3D208324  lis r9, -0x7cdc
	ctx.r[9].s64 = -2094792704;
	// 82A86464: D3FF0194  stfs f31, 0x194(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82A86468: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82A8646C: D3BF0198  stfs f29, 0x198(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82A86470: 38691420  addi r3, r9, 0x1420
	ctx.r[3].s64 = ctx.r[9].s64 + 5152;
	// 82A86474: C00A0E88  lfs f0, 0xe88(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3720 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A86478: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82A8647C: D3FF01A0  stfs f31, 0x1a0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82A86480: D3DF01A4  stfs f30, 0x1a4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82A86484: D3DF01A8  stfs f30, 0x1a8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A86488: D3DF01AC  stfs f30, 0x1ac(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82A8648C: 4872204D  bl 0x831a84d8
	ctx.lr = 0x82A86490;
	sub_831A84D8(ctx, base);
	// 82A86490: 817E0100  lwz r11, 0x100(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A86494: 3BBE00FC  addi r29, r30, 0xfc
	ctx.r[29].s64 = ctx.r[30].s64 + 252;
	// 82A86498: 815E00FC  lwz r10, 0xfc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A8649C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A864A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A864A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A864A8: 419A0024  beq cr6, 0x82a864cc
	if ctx.cr[6].eq {
	pc = 0x82A864CC; continue 'dispatch;
	}
	// 82A864AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A864B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A864B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A864B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A864BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A864C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A864C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A864C8: 4082FFE8  bne 0x82a864b0
	if !ctx.cr[0].eq {
	pc = 0x82A864B0; continue 'dispatch;
	}
	// 82A864CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A864D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A864D4: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 82A864D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A864DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A864E0: 4BD66361  bl 0x827ec840
	ctx.lr = 0x82A864E4;
	sub_827EC840(ctx, base);
	// 82A864E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A864E8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A864EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A864F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A864F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A864F8: 419A0024  beq cr6, 0x82a8651c
	if ctx.cr[6].eq {
	pc = 0x82A8651C; continue 'dispatch;
	}
	// 82A864FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A86500: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A86504: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A86508: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8650C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A86510: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A86514: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A86518: 4082FFE8  bne 0x82a86500
	if !ctx.cr[0].eq {
	pc = 0x82A86500; continue 'dispatch;
	}
	// 82A8651C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A86520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A86524: 4BA88FA5  bl 0x8250f4c8
	ctx.lr = 0x82A86528;
	sub_8250F4C8(ctx, base);
	// 82A86528: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8652C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A86530: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A86534: 409A0008  bne cr6, 0x82a8653c
	if !ctx.cr[6].eq {
	pc = 0x82A8653C; continue 'dispatch;
	}
	// 82A86538: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A8653C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86540: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A86544: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A86548: 3BAB1FD8  addi r29, r11, 0x1fd8
	ctx.r[29].s64 = ctx.r[11].s64 + 8152;
	// 82A8654C: 3B8A22E4  addi r28, r10, 0x22e4
	ctx.r[28].s64 = ctx.r[10].s64 + 8932;
	// 82A86550: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A86554: 4BE83EDD  bl 0x8290a430
	ctx.lr = 0x82A86558;
	sub_8290A430(ctx, base);
	// 82A86558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A8655C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A86560: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A86564: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A86568: 480BFD81  bl 0x82b462e8
	ctx.lr = 0x82A8656C;
	sub_82B462E8(ctx, base);
	// 82A8656C: 907E0428  stw r3, 0x428(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1064 as u32), ctx.r[3].u32 ) };
	// 82A86570: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A86574: 4836B71D  bl 0x82df1c90
	ctx.lr = 0x82A86578;
	sub_82DF1C90(ctx, base);
	// 82A86578: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A8657C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82A86580: 48722541  bl 0x831a8ac0
	ctx.lr = 0x82A86584;
	sub_831A8A8C(ctx, base);
	// 82A86584: 48721C30  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A86588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A86588 size=5880
    let mut pc: u32 = 0x82A86588;
    'dispatch: loop {
        match pc {
            0x82A86588 => {
    //   block [0x82A86588..0x82A87C80)
	// 82A86588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8658C: 48721BA9  bl 0x831a8134
	ctx.lr = 0x82A86590;
	sub_831A8130(ctx, base);
	// 82A86590: DBA1FF58  stfd f29, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[29].u64 ) };
	// 82A86594: DBC1FF60  stfd f30, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 82A86598: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 82A8659C: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A865A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A865A4: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 82A865A8: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 82A865AC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A865B0: 4BE8A7E1  bl 0x82910d90
	ctx.lr = 0x82A865B4;
	sub_82910D90(ctx, base);
	// 82A865B4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A865B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A865BC: 4BA88DB5  bl 0x8250f370
	ctx.lr = 0x82A865C0;
	sub_8250F370(ctx, base);
	// 82A865C0: 367CFFF0  addic. r19, r28, -0x10
	ctx.xer.ca = (ctx.r[28].u32 > (!(-16 as u32)));
	ctx.r[19].s64 = ctx.r[28].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 82A865C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A865C8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A865CC: 40820008  bne 0x82a865d4
	if !ctx.cr[0].eq {
	pc = 0x82A865D4; continue 'dispatch;
	}
	// 82A865D0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A865D4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A865D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A865DC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A865E0: 4836D429  bl 0x82df3a08
	ctx.lr = 0x82A865E4;
	sub_82DF3A08(ctx, base);
	// 82A865E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A865E8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A865EC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A865F0: 4BA82191  bl 0x82508780
	ctx.lr = 0x82A865F4;
	sub_82508780(ctx, base);
	// 82A865F4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A865F8: 4836CE31  bl 0x82df3428
	ctx.lr = 0x82A865FC;
	sub_82DF3428(ctx, base);
	// 82A865FC: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A86600: 389C0028  addi r4, r28, 0x28
	ctx.r[4].s64 = ctx.r[28].s64 + 40;
	// 82A86604: 409A0008  bne cr6, 0x82a8660c
	if !ctx.cr[6].eq {
	pc = 0x82A8660C; continue 'dispatch;
	}
	// 82A86608: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A8660C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A86610: 4BA82191  bl 0x825087a0
	ctx.lr = 0x82A86614;
	sub_825087A0(ctx, base);
	// 82A86614: 3FA0832F  lis r29, -0x7cd1
	ctx.r[29].s64 = -2094071808;
	// 82A86618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8661C: 397D9114  addi r11, r29, -0x6eec
	ctx.r[11].s64 = ctx.r[29].s64 + -28396;
	// 82A86620: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A86624: 4836D3E5  bl 0x82df3a08
	ctx.lr = 0x82A86628;
	sub_82DF3A08(ctx, base);
	// 82A86628: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A8662C: 809D9114  lwz r4, -0x6eec(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-28396 as u32) ) } as u64;
	// 82A86630: 4836D3D9  bl 0x82df3a08
	ctx.lr = 0x82A86634;
	sub_82DF3A08(ctx, base);
	// 82A86634: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86638: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A8663C: 808BA080  lwz r4, -0x5f80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24448 as u32) ) } as u64;
	// 82A86640: 4836D3C9  bl 0x82df3a08
	ctx.lr = 0x82A86644;
	sub_82DF3A08(ctx, base);
	// 82A86644: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82A86648: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82A8664C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82A86650: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A86654: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A86658: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A8665C: 4BE8B49D  bl 0x82911af8
	ctx.lr = 0x82A86660;
	sub_82911AF8(ctx, base);
	// 82A86660: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A86664: 4836CDC5  bl 0x82df3428
	ctx.lr = 0x82A86668;
	sub_82DF3428(ctx, base);
	// 82A86668: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A8666C: 4836CDBD  bl 0x82df3428
	ctx.lr = 0x82A86670;
	sub_82DF3428(ctx, base);
	// 82A86670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86674: 4836CDB5  bl 0x82df3428
	ctx.lr = 0x82A86678;
	sub_82DF3428(ctx, base);
	// 82A86678: 3D4082A8  lis r10, -0x7d58
	ctx.r[10].s64 = -2102919168;
	// 82A8667C: 817C00EC  lwz r11, 0xec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A86680: 394A5F70  addi r10, r10, 0x5f70
	ctx.r[10].s64 = ctx.r[10].s64 + 24432;
	// 82A86684: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A86688: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A8668C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A86690: 914100D0  stw r10, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82A86694: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A86698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8669C: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82A866A0: 419A0024  beq cr6, 0x82a866c4
	if ctx.cr[6].eq {
	pc = 0x82A866C4; continue 'dispatch;
	}
	// 82A866A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A866A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A866AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A866B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A866B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A866B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A866BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A866C0: 4082FFE8  bne 0x82a866a8
	if !ctx.cr[0].eq {
	pc = 0x82A866A8; continue 'dispatch;
	}
	// 82A866C4: 3BBCFFF0  addi r29, r28, -0x10
	ctx.r[29].s64 = ctx.r[28].s64 + -16;
	// 82A866C8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A866CC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A866D0: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 82A866D4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A866D8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A866DC: 4BFFDDAD  bl 0x82a84488
	ctx.lr = 0x82A866E0;
	sub_82A84488(ctx, base);
	// 82A866E0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A866E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A866E8: 4BB05829  bl 0x8258bf10
	ctx.lr = 0x82A866EC;
	sub_8258BF10(ctx, base);
	// 82A866EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A866F0: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82A866F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A866F8: 4BA8A749  bl 0x82510e40
	ctx.lr = 0x82A866FC;
	sub_82510E40(ctx, base);
	// 82A866FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A86700: 4B8425B9  bl 0x822c8cb8
	ctx.lr = 0x82A86704;
	sub_822C8CB8(ctx, base);
	// 82A86704: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A86708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8670C: 419A0008  beq cr6, 0x82a86714
	if ctx.cr[6].eq {
	pc = 0x82A86714; continue 'dispatch;
	}
	// 82A86710: 4B83A181  bl 0x822c0890
	ctx.lr = 0x82A86714;
	sub_822C0890(ctx, base);
	// 82A86714: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86718: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A8671C: 3B0B2010  addi r24, r11, 0x2010
	ctx.r[24].s64 = ctx.r[11].s64 + 8208;
	// 82A86720: 38A000FC  li r5, 0xfc
	ctx.r[5].s64 = 252;
	// 82A86724: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A86728: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A8672C: 4B839CAD  bl 0x822c03d8
	ctx.lr = 0x82A86730;
	sub_822C03D8(ctx, base);
	// 82A86730: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A86734: 41820020  beq 0x82a86754
	if ctx.cr[0].eq {
	pc = 0x82A86754; continue 'dispatch;
	}
	// 82A86738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8673C: 4BD64575  bl 0x827eacb0
	ctx.lr = 0x82A86740;
	sub_827EACB0(ctx, base);
	// 82A86740: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A86744: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A86748: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 82A8674C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A86750: 48000008  b 0x82a86758
	pc = 0x82A86758; continue 'dispatch;
	// 82A86754: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A86758: 3BFC01CC  addi r31, r28, 0x1cc
	ctx.r[31].s64 = ctx.r[28].s64 + 460;
	// 82A8675C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A86760: 4BDE1B21  bl 0x82868280
	ctx.lr = 0x82A86764;
	sub_82868280(ctx, base);
	// 82A86764: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8676C: 808BA084  lwz r4, -0x5f7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24444 as u32) ) } as u64;
	// 82A86770: 4836D299  bl 0x82df3a08
	ctx.lr = 0x82A86774;
	sub_82DF3A08(ctx, base);
	// 82A86774: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A86778: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A8677C: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A86780: 835C01CC  lwz r26, 0x1cc(r28)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A86784: 4BA88D45  bl 0x8250f4c8
	ctx.lr = 0x82A86788;
	sub_8250F4C8(ctx, base);
	// 82A86788: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A8678C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A86790: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A86794: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A86798: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A8679C: 4BD641CD  bl 0x827ea968
	ctx.lr = 0x82A867A0;
	sub_827EA968(ctx, base);
	// 82A867A0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A867A4: 4836B4ED  bl 0x82df1c90
	ctx.lr = 0x82A867A8;
	sub_82DF1C90(ctx, base);
	// 82A867A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A867AC: 4836CC7D  bl 0x82df3428
	ctx.lr = 0x82A867B0;
	sub_82DF3428(ctx, base);
	// 82A867B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A867B4: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82A867B8: 807C01CC  lwz r3, 0x1cc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A867BC: 388AA0A0  addi r4, r10, -0x5f60
	ctx.r[4].s64 = ctx.r[10].s64 + -24416;
	// 82A867C0: 80AB30F8  lwz r5, 0x30f8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12536 as u32) ) } as u64;
	// 82A867C4: 4BD63EFD  bl 0x827ea6c0
	ctx.lr = 0x82A867C8;
	sub_827EA6C0(ctx, base);
	// 82A867C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A867CC: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82A867D0: 4BD65DF9  bl 0x827ec5c8
	ctx.lr = 0x82A867D4;
	sub_827EC5C8(ctx, base);
	// 82A867D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A867D8: 807C01CC  lwz r3, 0x1cc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(460 as u32) ) } as u64;
	// 82A867DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A867E0: 4BD63EE9  bl 0x827ea6c8
	ctx.lr = 0x82A867E4;
	sub_827EA6C8(ctx, base);
	// 82A867E4: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A867E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A867EC: 419A0008  beq cr6, 0x82a867f4
	if ctx.cr[6].eq {
	pc = 0x82A867F4; continue 'dispatch;
	}
	// 82A867F0: 4B83A0A1  bl 0x822c0890
	ctx.lr = 0x82A867F4;
	sub_822C0890(ctx, base);
	// 82A867F4: 3F60832F  lis r27, -0x7cd1
	ctx.r[27].s64 = -2094071808;
	// 82A867F8: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A867FC: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A86800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86804: 396B2998  addi r11, r11, 0x2998
	ctx.r[11].s64 = ctx.r[11].s64 + 10648;
	// 82A86808: 809B9F64  lwz r4, -0x609c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24732 as u32) ) } as u64;
	// 82A8680C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A86810: 4836D1F9  bl 0x82df3a08
	ctx.lr = 0x82A86814;
	sub_82DF3A08(ctx, base);
	// 82A86814: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86818: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A8681C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A86820: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A86824: 3B4B24E4  addi r26, r11, 0x24e4
	ctx.r[26].s64 = ctx.r[11].s64 + 9444;
	// 82A86828: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A8682C: 3B2A1FD8  addi r25, r10, 0x1fd8
	ctx.r[25].s64 = ctx.r[10].s64 + 8152;
	// 82A86830: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86834: 934100AC  stw r26, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[26].u32 ) };
	// 82A86838: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82A8683C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A86840: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A86844: 4BFFDCC5  bl 0x82a84508
	ctx.lr = 0x82A86848;
	sub_82A84508(ctx, base);
	// 82A86848: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A8684C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86850: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A86854: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86858: C3EB093C  lfs f31, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A8685C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86860: 4BD63F51  bl 0x827ea7b0
	ctx.lr = 0x82A86864;
	sub_827EA7B0(ctx, base);
	// 82A86864: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86868: 4836CBC1  bl 0x82df3428
	ctx.lr = 0x82A8686C;
	sub_82DF3428(ctx, base);
	// 82A8686C: 3EE0832F  lis r23, -0x7cd1
	ctx.r[23].s64 = -2094071808;
	// 82A86870: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A86874: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8687C: 396B2998  addi r11, r11, 0x2998
	ctx.r[11].s64 = ctx.r[11].s64 + 10648;
	// 82A86880: 80979F68  lwz r4, -0x6098(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24728 as u32) ) } as u64;
	// 82A86884: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A86888: 4836D181  bl 0x82df3a08
	ctx.lr = 0x82A8688C;
	sub_82DF3A08(ctx, base);
	// 82A8688C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86890: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A86894: 934100AC  stw r26, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[26].u32 ) };
	// 82A86898: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82A8689C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A868A0: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A868A4: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A868A8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A868AC: 4BFFDC5D  bl 0x82a84508
	ctx.lr = 0x82A868B0;
	sub_82A84508(ctx, base);
	// 82A868B0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A868B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A868B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A868BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A868C0: 4BD63EF1  bl 0x827ea7b0
	ctx.lr = 0x82A868C4;
	sub_827EA7B0(ctx, base);
	// 82A868C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A868C8: 4836CB61  bl 0x82df3428
	ctx.lr = 0x82A868CC;
	sub_82DF3428(ctx, base);
	// 82A868CC: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A868D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A868D4: 809B9F64  lwz r4, -0x609c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24732 as u32) ) } as u64;
	// 82A868D8: 396B33B8  addi r11, r11, 0x33b8
	ctx.r[11].s64 = ctx.r[11].s64 + 13240;
	// 82A868DC: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A868E0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A868E4: 4836D125  bl 0x82df3a08
	ctx.lr = 0x82A868E8;
	sub_82DF3A08(ctx, base);
	// 82A868E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A868EC: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A868F0: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A868F4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A868F8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A868FC: 4BFFDC8D  bl 0x82a84588
	ctx.lr = 0x82A86900;
	sub_82A84588(ctx, base);
	// 82A86900: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A86904: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86908: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A8690C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86910: C3CB336C  lfs f30, 0x336c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13164 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A86914: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86918: 4BD63E99  bl 0x827ea7b0
	ctx.lr = 0x82A8691C;
	sub_827EA7B0(ctx, base);
	// 82A8691C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86920: 4836CB09  bl 0x82df3428
	ctx.lr = 0x82A86924;
	sub_82DF3428(ctx, base);
	// 82A86924: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A86928: 80979F68  lwz r4, -0x6098(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24728 as u32) ) } as u64;
	// 82A8692C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86930: 396B33B8  addi r11, r11, 0x33b8
	ctx.r[11].s64 = ctx.r[11].s64 + 13240;
	// 82A86934: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86938: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A8693C: 4836D0CD  bl 0x82df3a08
	ctx.lr = 0x82A86940;
	sub_82DF3A08(ctx, base);
	// 82A86940: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A86944: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86948: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A8694C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A86950: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A86954: 4BFFDC35  bl 0x82a84588
	ctx.lr = 0x82A86958;
	sub_82A84588(ctx, base);
	// 82A86958: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A8695C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86960: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86964: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86968: 4BD63E49  bl 0x827ea7b0
	ctx.lr = 0x82A8696C;
	sub_827EA7B0(ctx, base);
	// 82A8696C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86970: 4836CAB9  bl 0x82df3428
	ctx.lr = 0x82A86974;
	sub_82DF3428(ctx, base);
	// 82A86974: 3F40832F  lis r26, -0x7cd1
	ctx.r[26].s64 = -2094071808;
	// 82A86978: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A8697C: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86984: 396B2998  addi r11, r11, 0x2998
	ctx.r[11].s64 = ctx.r[11].s64 + 10648;
	// 82A86988: 809A9F9C  lwz r4, -0x6064(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24676 as u32) ) } as u64;
	// 82A8698C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A86990: 4836D079  bl 0x82df3a08
	ctx.lr = 0x82A86994;
	sub_82DF3A08(ctx, base);
	// 82A86994: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86998: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A8699C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A869A0: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82A869A4: 3ACB24CC  addi r22, r11, 0x24cc
	ctx.r[22].s64 = ctx.r[11].s64 + 9420;
	// 82A869A8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A869AC: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A869B0: 92C100AC  stw r22, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[22].u32 ) };
	// 82A869B4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A869B8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A869BC: 4BFFDB4D  bl 0x82a84508
	ctx.lr = 0x82A869C0;
	sub_82A84508(ctx, base);
	// 82A869C0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A869C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A869C8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A869CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A869D0: C3CBE830  lfs f30, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A869D4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A869D8: 4BD63DD9  bl 0x827ea7b0
	ctx.lr = 0x82A869DC;
	sub_827EA7B0(ctx, base);
	// 82A869DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A869E0: 4836CA49  bl 0x82df3428
	ctx.lr = 0x82A869E4;
	sub_82DF3428(ctx, base);
	// 82A869E4: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A869E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A869EC: 809A9F9C  lwz r4, -0x6064(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24676 as u32) ) } as u64;
	// 82A869F0: 396B2998  addi r11, r11, 0x2998
	ctx.r[11].s64 = ctx.r[11].s64 + 10648;
	// 82A869F4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A869F8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A869FC: 4836D00D  bl 0x82df3a08
	ctx.lr = 0x82A86A00;
	sub_82DF3A08(ctx, base);
	// 82A86A00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A86A04: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A86A08: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86A0C: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82A86A10: 3A4B24B4  addi r18, r11, 0x24b4
	ctx.r[18].s64 = ctx.r[11].s64 + 9396;
	// 82A86A14: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A86A18: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A86A1C: 924100AC  stw r18, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[18].u32 ) };
	// 82A86A20: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A86A24: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A86A28: 4BFFDAE1  bl 0x82a84508
	ctx.lr = 0x82A86A2C;
	sub_82A84508(ctx, base);
	// 82A86A2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A86A30: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86A34: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A86A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86A3C: C02B9C44  lfs f1, -0x63bc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25532 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A86A40: 4BD63D71  bl 0x827ea7b0
	ctx.lr = 0x82A86A44;
	sub_827EA7B0(ctx, base);
	// 82A86A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86A48: 4836C9E1  bl 0x82df3428
	ctx.lr = 0x82A86A4C;
	sub_82DF3428(ctx, base);
	// 82A86A4C: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A86A50: 3E20832F  lis r17, -0x7cd1
	ctx.r[17].s64 = -2094071808;
	// 82A86A54: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86A58: 396B2998  addi r11, r11, 0x2998
	ctx.r[11].s64 = ctx.r[11].s64 + 10648;
	// 82A86A5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86A60: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A86A64: 80919FA4  lwz r4, -0x605c(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24668 as u32) ) } as u64;
	// 82A86A68: 4836CFA1  bl 0x82df3a08
	ctx.lr = 0x82A86A6C;
	sub_82DF3A08(ctx, base);
	// 82A86A6C: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82A86A70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86A74: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A86A78: 92C100AC  stw r22, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[22].u32 ) };
	// 82A86A7C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A86A80: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A86A84: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A86A88: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A86A8C: 4BFFDA7D  bl 0x82a84508
	ctx.lr = 0x82A86A90;
	sub_82A84508(ctx, base);
	// 82A86A90: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A86A94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86A98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86A9C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86AA0: 4BD63D11  bl 0x827ea7b0
	ctx.lr = 0x82A86AA4;
	sub_827EA7B0(ctx, base);
	// 82A86AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86AA8: 4836C981  bl 0x82df3428
	ctx.lr = 0x82A86AAC;
	sub_82DF3428(ctx, base);
	// 82A86AAC: 3D6082A8  lis r11, -0x7d58
	ctx.r[11].s64 = -2102919168;
	// 82A86AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86AB4: 80919FA4  lwz r4, -0x605c(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24668 as u32) ) } as u64;
	// 82A86AB8: 396B2998  addi r11, r11, 0x2998
	ctx.r[11].s64 = ctx.r[11].s64 + 10648;
	// 82A86ABC: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86AC0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A86AC4: 4836CF45  bl 0x82df3a08
	ctx.lr = 0x82A86AC8;
	sub_82DF3A08(ctx, base);
	// 82A86AC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86ACC: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A86AD0: 924100AC  stw r18, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[18].u32 ) };
	// 82A86AD4: 932100B0  stw r25, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u32 ) };
	// 82A86AD8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A86ADC: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A86AE0: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A86AE4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A86AE8: 4BFFDA21  bl 0x82a84508
	ctx.lr = 0x82A86AEC;
	sub_82A84508(ctx, base);
	// 82A86AEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A86AF0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86AF4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A86AF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86AFC: C02B3364  lfs f1, 0x3364(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A86B00: 4BD63CB1  bl 0x827ea7b0
	ctx.lr = 0x82A86B04;
	sub_827EA7B0(ctx, base);
	// 82A86B04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86B08: 4836C921  bl 0x82df3428
	ctx.lr = 0x82A86B0C;
	sub_82DF3428(ctx, base);
	// 82A86B0C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86B10: 3D4082A8  lis r10, -0x7d58
	ctx.r[10].s64 = -2102919168;
	// 82A86B14: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86B1C: 394A4968  addi r10, r10, 0x4968
	ctx.r[10].s64 = ctx.r[10].s64 + 18792;
	// 82A86B20: 808B9FAC  lwz r4, -0x6054(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24660 as u32) ) } as u64;
	// 82A86B24: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A86B28: 4836CEE1  bl 0x82df3a08
	ctx.lr = 0x82A86B2C;
	sub_82DF3A08(ctx, base);
	// 82A86B2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86B30: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 82A86B34: 93C100A4  stw r30, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82A86B38: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A86B3C: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82A86B40: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A86B44: 4BFFDAC5  bl 0x82a84608
	ctx.lr = 0x82A86B48;
	sub_82A84608(ctx, base);
	// 82A86B48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A86B4C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86B50: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A86B54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86B58: C3AB08A4  lfs f29, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A86B5C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A86B60: 4BD63C51  bl 0x827ea7b0
	ctx.lr = 0x82A86B64;
	sub_827EA7B0(ctx, base);
	// 82A86B64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86B68: 4836C8C1  bl 0x82df3428
	ctx.lr = 0x82A86B6C;
	sub_82DF3428(ctx, base);
	// 82A86B6C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86B70: 3D4082A8  lis r10, -0x7d58
	ctx.r[10].s64 = -2102919168;
	// 82A86B74: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86B78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86B7C: 394A3558  addi r10, r10, 0x3558
	ctx.r[10].s64 = ctx.r[10].s64 + 13656;
	// 82A86B80: 808B9FF8  lwz r4, -0x6008(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24584 as u32) ) } as u64;
	// 82A86B84: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A86B88: 4836CE81  bl 0x82df3a08
	ctx.lr = 0x82A86B8C;
	sub_82DF3A08(ctx, base);
	// 82A86B8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86B90: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A86B94: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A86B98: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A86B9C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A86BA0: 4BFFD9E9  bl 0x82a84588
	ctx.lr = 0x82A86BA4;
	sub_82A84588(ctx, base);
	// 82A86BA4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A86BA8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86BAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86BB0: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A86BB4: 4BD63BFD  bl 0x827ea7b0
	ctx.lr = 0x82A86BB8;
	sub_827EA7B0(ctx, base);
	// 82A86BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86BBC: 4836C86D  bl 0x82df3428
	ctx.lr = 0x82A86BC0;
	sub_82DF3428(ctx, base);
	// 82A86BC0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86BC4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A86BC8: 3D4082A8  lis r10, -0x7d58
	ctx.r[10].s64 = -2102919168;
	// 82A86BCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86BD0: 394A4AD8  addi r10, r10, 0x4ad8
	ctx.r[10].s64 = ctx.r[10].s64 + 19160;
	// 82A86BD4: 808BA038  lwz r4, -0x5fc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24520 as u32) ) } as u64;
	// 82A86BD8: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A86BDC: 4836CE2D  bl 0x82df3a08
	ctx.lr = 0x82A86BE0;
	sub_82DF3A08(ctx, base);
	// 82A86BE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A86BE4: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 82A86BE8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A86BEC: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A86BF0: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A86BF4: 4BFFD995  bl 0x82a84588
	ctx.lr = 0x82A86BF8;
	sub_82A84588(ctx, base);
	// 82A86BF8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A86BFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86C00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86C04: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86C08: 4BD63BA9  bl 0x827ea7b0
	ctx.lr = 0x82A86C0C;
	sub_827EA7B0(ctx, base);
	// 82A86C0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C10: 4836C819  bl 0x82df3428
	ctx.lr = 0x82A86C14;
	sub_82DF3428(ctx, base);
	// 82A86C14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C18: 809A9F9C  lwz r4, -0x6064(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24676 as u32) ) } as u64;
	// 82A86C1C: 4836CDED  bl 0x82df3a08
	ctx.lr = 0x82A86C20;
	sub_82DF3A08(ctx, base);
	// 82A86C20: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A86C24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86C28: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86C2C: C3CB6150  lfs f30, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A86C30: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86C34: 4BD63705  bl 0x827ea338
	ctx.lr = 0x82A86C38;
	sub_827EA338(ctx, base);
	// 82A86C38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C3C: 4836C7ED  bl 0x82df3428
	ctx.lr = 0x82A86C40;
	sub_82DF3428(ctx, base);
	// 82A86C40: 3F40832F  lis r26, -0x7cd1
	ctx.r[26].s64 = -2094071808;
	// 82A86C44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C48: 809A9F10  lwz r4, -0x60f0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24816 as u32) ) } as u64;
	// 82A86C4C: 4836CDBD  bl 0x82df3a08
	ctx.lr = 0x82A86C50;
	sub_82DF3A08(ctx, base);
	// 82A86C50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86C54: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86C58: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86C5C: 4BD636DD  bl 0x827ea338
	ctx.lr = 0x82A86C60;
	sub_827EA338(ctx, base);
	// 82A86C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C64: 4836C7C5  bl 0x82df3428
	ctx.lr = 0x82A86C68;
	sub_82DF3428(ctx, base);
	// 82A86C68: 3F20832F  lis r25, -0x7cd1
	ctx.r[25].s64 = -2094071808;
	// 82A86C6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C70: 80999F30  lwz r4, -0x60d0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24784 as u32) ) } as u64;
	// 82A86C74: 4836CD95  bl 0x82df3a08
	ctx.lr = 0x82A86C78;
	sub_82DF3A08(ctx, base);
	// 82A86C78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86C7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86C80: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86C84: 4BD636B5  bl 0x827ea338
	ctx.lr = 0x82A86C88;
	sub_827EA338(ctx, base);
	// 82A86C88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C8C: 4836C79D  bl 0x82df3428
	ctx.lr = 0x82A86C90;
	sub_82DF3428(ctx, base);
	// 82A86C90: 3EC0832F  lis r22, -0x7cd1
	ctx.r[22].s64 = -2094071808;
	// 82A86C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86C98: 80969F34  lwz r4, -0x60cc(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-24780 as u32) ) } as u64;
	// 82A86C9C: 4836CD6D  bl 0x82df3a08
	ctx.lr = 0x82A86CA0;
	sub_82DF3A08(ctx, base);
	// 82A86CA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86CA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86CA8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86CAC: 4BD6368D  bl 0x827ea338
	ctx.lr = 0x82A86CB0;
	sub_827EA338(ctx, base);
	// 82A86CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86CB4: 4836C775  bl 0x82df3428
	ctx.lr = 0x82A86CB8;
	sub_82DF3428(ctx, base);
	// 82A86CB8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86CBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86CC0: 808B9F48  lwz r4, -0x60b8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24760 as u32) ) } as u64;
	// 82A86CC4: 4836CD45  bl 0x82df3a08
	ctx.lr = 0x82A86CC8;
	sub_82DF3A08(ctx, base);
	// 82A86CC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A86CCC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86CD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86CD4: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A86CD8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86CDC: 4BD6365D  bl 0x827ea338
	ctx.lr = 0x82A86CE0;
	sub_827EA338(ctx, base);
	// 82A86CE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86CE4: 4836C745  bl 0x82df3428
	ctx.lr = 0x82A86CE8;
	sub_82DF3428(ctx, base);
	// 82A86CE8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86CEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86CF0: 808B9F50  lwz r4, -0x60b0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24752 as u32) ) } as u64;
	// 82A86CF4: 4836CD15  bl 0x82df3a08
	ctx.lr = 0x82A86CF8;
	sub_82DF3A08(ctx, base);
	// 82A86CF8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86CFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86D00: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86D04: 4BD63635  bl 0x827ea338
	ctx.lr = 0x82A86D08;
	sub_827EA338(ctx, base);
	// 82A86D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D0C: 4836C71D  bl 0x82df3428
	ctx.lr = 0x82A86D10;
	sub_82DF3428(ctx, base);
	// 82A86D10: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D18: 808B9F58  lwz r4, -0x60a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24744 as u32) ) } as u64;
	// 82A86D1C: 4836CCED  bl 0x82df3a08
	ctx.lr = 0x82A86D20;
	sub_82DF3A08(ctx, base);
	// 82A86D20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86D24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86D28: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86D2C: 4BD6360D  bl 0x827ea338
	ctx.lr = 0x82A86D30;
	sub_827EA338(ctx, base);
	// 82A86D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D34: 4836C6F5  bl 0x82df3428
	ctx.lr = 0x82A86D38;
	sub_82DF3428(ctx, base);
	// 82A86D38: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86D3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D40: 808B9F5C  lwz r4, -0x60a4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24740 as u32) ) } as u64;
	// 82A86D44: 4836CCC5  bl 0x82df3a08
	ctx.lr = 0x82A86D48;
	sub_82DF3A08(ctx, base);
	// 82A86D48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86D4C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86D50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86D54: 4BD635E5  bl 0x827ea338
	ctx.lr = 0x82A86D58;
	sub_827EA338(ctx, base);
	// 82A86D58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D5C: 4836C6CD  bl 0x82df3428
	ctx.lr = 0x82A86D60;
	sub_82DF3428(ctx, base);
	// 82A86D60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D64: 809B9F64  lwz r4, -0x609c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24732 as u32) ) } as u64;
	// 82A86D68: 4836CCA1  bl 0x82df3a08
	ctx.lr = 0x82A86D6C;
	sub_82DF3A08(ctx, base);
	// 82A86D6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86D70: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86D74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86D78: 4BD635C1  bl 0x827ea338
	ctx.lr = 0x82A86D7C;
	sub_827EA338(ctx, base);
	// 82A86D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D80: 4836C6A9  bl 0x82df3428
	ctx.lr = 0x82A86D84;
	sub_82DF3428(ctx, base);
	// 82A86D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86D88: 80979F68  lwz r4, -0x6098(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24728 as u32) ) } as u64;
	// 82A86D8C: 4836CC7D  bl 0x82df3a08
	ctx.lr = 0x82A86D90;
	sub_82DF3A08(ctx, base);
	// 82A86D90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86D94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86D98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86D9C: 4BD6359D  bl 0x827ea338
	ctx.lr = 0x82A86DA0;
	sub_827EA338(ctx, base);
	// 82A86DA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86DA4: 4836C685  bl 0x82df3428
	ctx.lr = 0x82A86DA8;
	sub_82DF3428(ctx, base);
	// 82A86DA8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86DB0: 808B9F6C  lwz r4, -0x6094(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24724 as u32) ) } as u64;
	// 82A86DB4: 4836CC55  bl 0x82df3a08
	ctx.lr = 0x82A86DB8;
	sub_82DF3A08(ctx, base);
	// 82A86DB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86DBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86DC0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86DC4: 4BD63575  bl 0x827ea338
	ctx.lr = 0x82A86DC8;
	sub_827EA338(ctx, base);
	// 82A86DC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86DCC: 4836C65D  bl 0x82df3428
	ctx.lr = 0x82A86DD0;
	sub_82DF3428(ctx, base);
	// 82A86DD0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86DD8: 808B9F70  lwz r4, -0x6090(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24720 as u32) ) } as u64;
	// 82A86DDC: 4836CC2D  bl 0x82df3a08
	ctx.lr = 0x82A86DE0;
	sub_82DF3A08(ctx, base);
	// 82A86DE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86DE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86DE8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86DEC: 4BD6354D  bl 0x827ea338
	ctx.lr = 0x82A86DF0;
	sub_827EA338(ctx, base);
	// 82A86DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86DF4: 4836C635  bl 0x82df3428
	ctx.lr = 0x82A86DF8;
	sub_82DF3428(ctx, base);
	// 82A86DF8: 3F60832F  lis r27, -0x7cd1
	ctx.r[27].s64 = -2094071808;
	// 82A86DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86E00: 809B9F98  lwz r4, -0x6068(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24680 as u32) ) } as u64;
	// 82A86E04: 4836CC05  bl 0x82df3a08
	ctx.lr = 0x82A86E08;
	sub_82DF3A08(ctx, base);
	// 82A86E08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86E0C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86E10: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86E14: 4BD63525  bl 0x827ea338
	ctx.lr = 0x82A86E18;
	sub_827EA338(ctx, base);
	// 82A86E18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86E1C: 4836C60D  bl 0x82df3428
	ctx.lr = 0x82A86E20;
	sub_82DF3428(ctx, base);
	// 82A86E20: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86E24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86E28: 808B9FA0  lwz r4, -0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24672 as u32) ) } as u64;
	// 82A86E2C: 4836CBDD  bl 0x82df3a08
	ctx.lr = 0x82A86E30;
	sub_82DF3A08(ctx, base);
	// 82A86E30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86E34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86E38: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A86E3C: 4BD634FD  bl 0x827ea338
	ctx.lr = 0x82A86E40;
	sub_827EA338(ctx, base);
	// 82A86E40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86E44: 4836C5E5  bl 0x82df3428
	ctx.lr = 0x82A86E48;
	sub_82DF3428(ctx, base);
	// 82A86E48: 3EE0832F  lis r23, -0x7cd1
	ctx.r[23].s64 = -2094071808;
	// 82A86E4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86E50: 80979F14  lwz r4, -0x60ec(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24812 as u32) ) } as u64;
	// 82A86E54: 4836CBB5  bl 0x82df3a08
	ctx.lr = 0x82A86E58;
	sub_82DF3A08(ctx, base);
	// 82A86E58: 3E40832F  lis r18, -0x7cd1
	ctx.r[18].s64 = -2094071808;
	// 82A86E5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86E60: 80929F20  lwz r4, -0x60e0(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-24800 as u32) ) } as u64;
	// 82A86E64: 4836CBA5  bl 0x82df3a08
	ctx.lr = 0x82A86E68;
	sub_82DF3A08(ctx, base);
	// 82A86E68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A86E6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86E70: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A86E74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86E78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86E7C: 4BD634DD  bl 0x827ea358
	ctx.lr = 0x82A86E80;
	sub_827EA358(ctx, base);
	// 82A86E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86E84: 4836C5A5  bl 0x82df3428
	ctx.lr = 0x82A86E88;
	sub_82DF3428(ctx, base);
	// 82A86E88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86E8C: 4836C59D  bl 0x82df3428
	ctx.lr = 0x82A86E90;
	sub_82DF3428(ctx, base);
	// 82A86E90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86E94: 80979F14  lwz r4, -0x60ec(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24812 as u32) ) } as u64;
	// 82A86E98: 4836CB71  bl 0x82df3a08
	ctx.lr = 0x82A86E9C;
	sub_82DF3A08(ctx, base);
	// 82A86E9C: 3E20832F  lis r17, -0x7cd1
	ctx.r[17].s64 = -2094071808;
	// 82A86EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86EA4: 80919F24  lwz r4, -0x60dc(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24796 as u32) ) } as u64;
	// 82A86EA8: 4836CB61  bl 0x82df3a08
	ctx.lr = 0x82A86EAC;
	sub_82DF3A08(ctx, base);
	// 82A86EAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A86EB0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86EB4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A86EB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86EBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86EC0: 4BD63499  bl 0x827ea358
	ctx.lr = 0x82A86EC4;
	sub_827EA358(ctx, base);
	// 82A86EC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86EC8: 4836C561  bl 0x82df3428
	ctx.lr = 0x82A86ECC;
	sub_82DF3428(ctx, base);
	// 82A86ECC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86ED0: 4836C559  bl 0x82df3428
	ctx.lr = 0x82A86ED4;
	sub_82DF3428(ctx, base);
	// 82A86ED4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86ED8: 80979F14  lwz r4, -0x60ec(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24812 as u32) ) } as u64;
	// 82A86EDC: 4836CB2D  bl 0x82df3a08
	ctx.lr = 0x82A86EE0;
	sub_82DF3A08(ctx, base);
	// 82A86EE0: 3E00832F  lis r16, -0x7cd1
	ctx.r[16].s64 = -2094071808;
	// 82A86EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86EE8: 80909F28  lwz r4, -0x60d8(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24792 as u32) ) } as u64;
	// 82A86EEC: 4836CB1D  bl 0x82df3a08
	ctx.lr = 0x82A86EF0;
	sub_82DF3A08(ctx, base);
	// 82A86EF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A86EF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86EF8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A86EFC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86F00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86F04: 4BD63455  bl 0x827ea358
	ctx.lr = 0x82A86F08;
	sub_827EA358(ctx, base);
	// 82A86F08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86F0C: 4836C51D  bl 0x82df3428
	ctx.lr = 0x82A86F10;
	sub_82DF3428(ctx, base);
	// 82A86F10: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86F14: 4836C515  bl 0x82df3428
	ctx.lr = 0x82A86F18;
	sub_82DF3428(ctx, base);
	// 82A86F18: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86F1C: 80979F14  lwz r4, -0x60ec(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24812 as u32) ) } as u64;
	// 82A86F20: 4836CAE9  bl 0x82df3a08
	ctx.lr = 0x82A86F24;
	sub_82DF3A08(ctx, base);
	// 82A86F24: 3DE0832F  lis r15, -0x7cd1
	ctx.r[15].s64 = -2094071808;
	// 82A86F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86F2C: 808F9F2C  lwz r4, -0x60d4(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-24788 as u32) ) } as u64;
	// 82A86F30: 4836CAD9  bl 0x82df3a08
	ctx.lr = 0x82A86F34;
	sub_82DF3A08(ctx, base);
	// 82A86F34: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A86F38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86F3C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A86F40: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86F44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86F48: 4BD63411  bl 0x827ea358
	ctx.lr = 0x82A86F4C;
	sub_827EA358(ctx, base);
	// 82A86F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86F50: 4836C4D9  bl 0x82df3428
	ctx.lr = 0x82A86F54;
	sub_82DF3428(ctx, base);
	// 82A86F54: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86F58: 4836C4D1  bl 0x82df3428
	ctx.lr = 0x82A86F5C;
	sub_82DF3428(ctx, base);
	// 82A86F5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86F60: 80979F14  lwz r4, -0x60ec(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24812 as u32) ) } as u64;
	// 82A86F64: 4836CAA5  bl 0x82df3a08
	ctx.lr = 0x82A86F68;
	sub_82DF3A08(ctx, base);
	// 82A86F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86F6C: 80999F30  lwz r4, -0x60d0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24784 as u32) ) } as u64;
	// 82A86F70: 4836CA99  bl 0x82df3a08
	ctx.lr = 0x82A86F74;
	sub_82DF3A08(ctx, base);
	// 82A86F74: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A86F78: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A86F7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86F80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86F84: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86F88: 4BD633D1  bl 0x827ea358
	ctx.lr = 0x82A86F8C;
	sub_827EA358(ctx, base);
	// 82A86F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86F90: 4836C499  bl 0x82df3428
	ctx.lr = 0x82A86F94;
	sub_82DF3428(ctx, base);
	// 82A86F94: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86F98: 4836C491  bl 0x82df3428
	ctx.lr = 0x82A86F9C;
	sub_82DF3428(ctx, base);
	// 82A86F9C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86FA0: 80979F14  lwz r4, -0x60ec(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24812 as u32) ) } as u64;
	// 82A86FA4: 4836CA65  bl 0x82df3a08
	ctx.lr = 0x82A86FA8;
	sub_82DF3A08(ctx, base);
	// 82A86FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86FAC: 80969F34  lwz r4, -0x60cc(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-24780 as u32) ) } as u64;
	// 82A86FB0: 4836CA59  bl 0x82df3a08
	ctx.lr = 0x82A86FB4;
	sub_82DF3A08(ctx, base);
	// 82A86FB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A86FB8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A86FBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A86FC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A86FC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A86FC8: 4BD63391  bl 0x827ea358
	ctx.lr = 0x82A86FCC;
	sub_827EA358(ctx, base);
	// 82A86FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86FD0: 4836C459  bl 0x82df3428
	ctx.lr = 0x82A86FD4;
	sub_82DF3428(ctx, base);
	// 82A86FD4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86FD8: 4836C451  bl 0x82df3428
	ctx.lr = 0x82A86FDC;
	sub_82DF3428(ctx, base);
	// 82A86FDC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A86FE0: 809A9F10  lwz r4, -0x60f0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24816 as u32) ) } as u64;
	// 82A86FE4: 4836CA25  bl 0x82df3a08
	ctx.lr = 0x82A86FE8;
	sub_82DF3A08(ctx, base);
	// 82A86FE8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A86FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A86FF0: 808BA05C  lwz r4, -0x5fa4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24484 as u32) ) } as u64;
	// 82A86FF4: 4836CA15  bl 0x82df3a08
	ctx.lr = 0x82A86FF8;
	sub_82DF3A08(ctx, base);
	// 82A86FF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A86FFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87000: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A87004: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A87008: 4BD63359  bl 0x827ea360
	ctx.lr = 0x82A8700C;
	sub_827EA360(ctx, base);
	// 82A8700C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87010: 4836C419  bl 0x82df3428
	ctx.lr = 0x82A87014;
	sub_82DF3428(ctx, base);
	// 82A87014: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87018: 4836C411  bl 0x82df3428
	ctx.lr = 0x82A8701C;
	sub_82DF3428(ctx, base);
	// 82A8701C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87020: 809A9F10  lwz r4, -0x60f0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24816 as u32) ) } as u64;
	// 82A87024: 4836C9E5  bl 0x82df3a08
	ctx.lr = 0x82A87028;
	sub_82DF3A08(ctx, base);
	// 82A87028: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8702C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87030: 808BA060  lwz r4, -0x5fa0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24480 as u32) ) } as u64;
	// 82A87034: 4836C9D5  bl 0x82df3a08
	ctx.lr = 0x82A87038;
	sub_82DF3A08(ctx, base);
	// 82A87038: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A8703C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87040: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A87044: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A87048: 4BD63319  bl 0x827ea360
	ctx.lr = 0x82A8704C;
	sub_827EA360(ctx, base);
	// 82A8704C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87050: 4836C3D9  bl 0x82df3428
	ctx.lr = 0x82A87054;
	sub_82DF3428(ctx, base);
	// 82A87054: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87058: 4836C3D1  bl 0x82df3428
	ctx.lr = 0x82A8705C;
	sub_82DF3428(ctx, base);
	// 82A8705C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87060: 80909F28  lwz r4, -0x60d8(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24792 as u32) ) } as u64;
	// 82A87064: 4836C9A5  bl 0x82df3a08
	ctx.lr = 0x82A87068;
	sub_82DF3A08(ctx, base);
	// 82A87068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8706C: 80929F20  lwz r4, -0x60e0(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(-24800 as u32) ) } as u64;
	// 82A87070: 4836C999  bl 0x82df3a08
	ctx.lr = 0x82A87074;
	sub_82DF3A08(ctx, base);
	// 82A87074: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A87078: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8707C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87080: 4BD632A1  bl 0x827ea320
	ctx.lr = 0x82A87084;
	sub_827EA320(ctx, base);
	// 82A87084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87088: 4836C3A1  bl 0x82df3428
	ctx.lr = 0x82A8708C;
	sub_82DF3428(ctx, base);
	// 82A8708C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87090: 4836C399  bl 0x82df3428
	ctx.lr = 0x82A87094;
	sub_82DF3428(ctx, base);
	// 82A87094: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87098: 808F9F2C  lwz r4, -0x60d4(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-24788 as u32) ) } as u64;
	// 82A8709C: 4836C96D  bl 0x82df3a08
	ctx.lr = 0x82A870A0;
	sub_82DF3A08(ctx, base);
	// 82A870A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A870A4: 80919F24  lwz r4, -0x60dc(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24796 as u32) ) } as u64;
	// 82A870A8: 4836C961  bl 0x82df3a08
	ctx.lr = 0x82A870AC;
	sub_82DF3A08(ctx, base);
	// 82A870AC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A870B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A870B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A870B8: 4BD63269  bl 0x827ea320
	ctx.lr = 0x82A870BC;
	sub_827EA320(ctx, base);
	// 82A870BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A870C0: 4836C369  bl 0x82df3428
	ctx.lr = 0x82A870C4;
	sub_82DF3428(ctx, base);
	// 82A870C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A870C8: 4836C361  bl 0x82df3428
	ctx.lr = 0x82A870CC;
	sub_82DF3428(ctx, base);
	// 82A870CC: 809A9F10  lwz r4, -0x60f0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24816 as u32) ) } as u64;
	// 82A870D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A870D4: 4836C935  bl 0x82df3a08
	ctx.lr = 0x82A870D8;
	sub_82DF3A08(ctx, base);
	// 82A870D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A870DC: 809B9F98  lwz r4, -0x6068(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24680 as u32) ) } as u64;
	// 82A870E0: 4836C929  bl 0x82df3a08
	ctx.lr = 0x82A870E4;
	sub_82DF3A08(ctx, base);
	// 82A870E4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A870E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A870EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A870F0: 4BD63231  bl 0x827ea320
	ctx.lr = 0x82A870F4;
	sub_827EA320(ctx, base);
	// 82A870F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A870F8: 4836C331  bl 0x82df3428
	ctx.lr = 0x82A870FC;
	sub_82DF3428(ctx, base);
	// 82A870FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87100: 4836C329  bl 0x82df3428
	ctx.lr = 0x82A87104;
	sub_82DF3428(ctx, base);
	// 82A87104: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A87108: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A8710C: 38A00142  li r5, 0x142
	ctx.r[5].s64 = 322;
	// 82A87110: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82A87114: 4B8392C5  bl 0x822c03d8
	ctx.lr = 0x82A87118;
	sub_822C03D8(ctx, base);
	// 82A87118: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8711C: 41820020  beq 0x82a8713c
	if ctx.cr[0].eq {
	pc = 0x82A8713C; continue 'dispatch;
	}
	// 82A87120: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A87124: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A87128: 409A0008  bne cr6, 0x82a87130
	if !ctx.cr[6].eq {
	pc = 0x82A87130; continue 'dispatch;
	}
	// 82A8712C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A87130: 48001511  bl 0x82a88640
	ctx.lr = 0x82A87134;
	sub_82A88640(ctx, base);
	// 82A87134: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87138: 48000008  b 0x82a87140
	pc = 0x82A87140; continue 'dispatch;
	// 82A8713C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A87140: 3B7C00E4  addi r27, r28, 0xe4
	ctx.r[27].s64 = ctx.r[28].s64 + 228;
	// 82A87144: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A87148: 4BFFC4E9  bl 0x82a83630
	ctx.lr = 0x82A8714C;
	sub_82A83630(ctx, base);
	// 82A8714C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A87150: 835C00E4  lwz r26, 0xe4(r28)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A87154: 83FA0000  lwz r31, 0(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87158: 4BF8C529  bl 0x82a13680
	ctx.lr = 0x82A8715C;
	sub_82A13680(ctx, base);
	// 82A8715C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87160: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A87164: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A87168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8716C: 4E800421  bctrl
	ctx.lr = 0x82A87170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A87170: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A87174: 83FA0000  lwz r31, 0(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87178: 4BF8C511  bl 0x82a13688
	ctx.lr = 0x82A8717C;
	sub_82A13688(ctx, base);
	// 82A8717C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87180: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A87184: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A87188: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8718C: 4E800421  bctrl
	ctx.lr = 0x82A87190;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A87190: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A87194: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A87198: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A8719C: 4BE8FE85  bl 0x82917020
	ctx.lr = 0x82A871A0;
	sub_82917020(ctx, base);
	// 82A871A0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A871A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A871A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A871AC: 4BE8FE75  bl 0x82917020
	ctx.lr = 0x82A871B0;
	sub_82917020(ctx, base);
	// 82A871B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A871B4: 4BE9A1C5  bl 0x82921378
	ctx.lr = 0x82A871B8;
	sub_82921378(ctx, base);
	// 82A871B8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A871BC: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82A871C0: 392B1EBC  addi r9, r11, 0x1ebc
	ctx.r[9].s64 = ctx.r[11].s64 + 7868;
	// 82A871C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A871C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A871CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A871D0: C00B1EBC  lfs f0, 0x1ebc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A871D4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A871D8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A871DC: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A871E0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A871E4: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A871E8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A871EC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A871F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A871F4: 4E800421  bctrl
	ctx.lr = 0x82A871F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A871F8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A871FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A87200: 38A00156  li r5, 0x156
	ctx.r[5].s64 = 342;
	// 82A87204: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82A87208: 4B8391D1  bl 0x822c03d8
	ctx.lr = 0x82A8720C;
	sub_822C03D8(ctx, base);
	// 82A8720C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A87210: 41820014  beq 0x82a87224
	if ctx.cr[0].eq {
	pc = 0x82A87224; continue 'dispatch;
	}
	// 82A87214: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87218: 48005759  bl 0x82a8c970
	ctx.lr = 0x82A8721C;
	sub_82A8C970(ctx, base);
	// 82A8721C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87220: 48000008  b 0x82a87228
	pc = 0x82A87228; continue 'dispatch;
	// 82A87224: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A87228: 387C0368  addi r3, r28, 0x368
	ctx.r[3].s64 = ctx.r[28].s64 + 872;
	// 82A8722C: 4BFFC475  bl 0x82a836a0
	ctx.lr = 0x82A87230;
	sub_82A836A0(ctx, base);
	// 82A87230: 817C00FC  lwz r11, 0xfc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A87234: 3BFC00FC  addi r31, r28, 0xfc
	ctx.r[31].s64 = ctx.r[28].s64 + 252;
	// 82A87238: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8723C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87240: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A87244: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A87248: 4E800421  bctrl
	ctx.lr = 0x82A8724C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A8724C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87250: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A87254: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87258: 388BB8A8  addi r4, r11, -0x4758
	ctx.r[4].s64 = ctx.r[11].s64 + -18264;
	// 82A8725C: 4BFFD1AD  bl 0x82a84408
	ctx.lr = 0x82A87260;
	sub_82A84408(ctx, base);
	// 82A87260: 3EC0832F  lis r22, -0x7cd1
	ctx.r[22].s64 = -2094071808;
	// 82A87264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87268: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A8726C: 8096C9DC  lwz r4, -0x3624(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-13860 as u32) ) } as u64;
	// 82A87270: 4836C799  bl 0x82df3a08
	ctx.lr = 0x82A87274;
	sub_82DF3A08(ctx, base);
	// 82A87274: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8727C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87280: 483D4ED9  bl 0x82e5c158
	ctx.lr = 0x82A87284;
	sub_82E5C158(ctx, base);
	// 82A87284: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87288: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82A8728C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87290: 388BA898  addi r4, r11, -0x5768
	ctx.r[4].s64 = ctx.r[11].s64 + -22376;
	// 82A87294: 4BFFD175  bl 0x82a84408
	ctx.lr = 0x82A87298;
	sub_82A84408(ctx, base);
	// 82A87298: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8729C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A872A0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A872A4: 808BC9E0  lwz r4, -0x3620(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13856 as u32) ) } as u64;
	// 82A872A8: 4836C761  bl 0x82df3a08
	ctx.lr = 0x82A872AC;
	sub_82DF3A08(ctx, base);
	// 82A872AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A872B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A872B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A872B8: 483D4EA1  bl 0x82e5c158
	ctx.lr = 0x82A872BC;
	sub_82E5C158(ctx, base);
	// 82A872BC: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A872C0: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A872C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A872C8: 388BC9A8  addi r4, r11, -0x3658
	ctx.r[4].s64 = ctx.r[11].s64 + -13912;
	// 82A872CC: 4BFFD13D  bl 0x82a84408
	ctx.lr = 0x82A872D0;
	sub_82A84408(ctx, base);
	// 82A872D0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A872D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A872D8: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A872DC: 808BC9E4  lwz r4, -0x361c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13852 as u32) ) } as u64;
	// 82A872E0: 4836C729  bl 0x82df3a08
	ctx.lr = 0x82A872E4;
	sub_82DF3A08(ctx, base);
	// 82A872E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A872E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A872EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A872F0: 483D4E69  bl 0x82e5c158
	ctx.lr = 0x82A872F4;
	sub_82E5C158(ctx, base);
	// 82A872F4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A872F8: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A872FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87300: 388B3A18  addi r4, r11, 0x3a18
	ctx.r[4].s64 = ctx.r[11].s64 + 14872;
	// 82A87304: 4BFFD105  bl 0x82a84408
	ctx.lr = 0x82A87308;
	sub_82A84408(ctx, base);
	// 82A87308: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8730C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87310: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A87314: 808BC9E8  lwz r4, -0x3618(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13848 as u32) ) } as u64;
	// 82A87318: 4836C6F1  bl 0x82df3a08
	ctx.lr = 0x82A8731C;
	sub_82DF3A08(ctx, base);
	// 82A8731C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87324: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87328: 483D4E31  bl 0x82e5c158
	ctx.lr = 0x82A8732C;
	sub_82E5C158(ctx, base);
	// 82A8732C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87330: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A87334: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87338: 388B7CD0  addi r4, r11, 0x7cd0
	ctx.r[4].s64 = ctx.r[11].s64 + 31952;
	// 82A8733C: 4BFFD0CD  bl 0x82a84408
	ctx.lr = 0x82A87340;
	sub_82A84408(ctx, base);
	// 82A87340: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87348: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A8734C: 808BCA04  lwz r4, -0x35fc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13820 as u32) ) } as u64;
	// 82A87350: 4836C6B9  bl 0x82df3a08
	ctx.lr = 0x82A87354;
	sub_82DF3A08(ctx, base);
	// 82A87354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8735C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87360: 483D4DF9  bl 0x82e5c158
	ctx.lr = 0x82A87364;
	sub_82E5C158(ctx, base);
	// 82A87364: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87368: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82A8736C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87370: 388B9340  addi r4, r11, -0x6cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -27840;
	// 82A87374: 4BFFD095  bl 0x82a84408
	ctx.lr = 0x82A87378;
	sub_82A84408(ctx, base);
	// 82A87378: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8737C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87380: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A87384: 808BC9EC  lwz r4, -0x3614(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13844 as u32) ) } as u64;
	// 82A87388: 4836C681  bl 0x82df3a08
	ctx.lr = 0x82A8738C;
	sub_82DF3A08(ctx, base);
	// 82A8738C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87394: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87398: 483D4DC1  bl 0x82e5c158
	ctx.lr = 0x82A8739C;
	sub_82E5C158(ctx, base);
	// 82A8739C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A873A0: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A873A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A873A8: 388BA160  addi r4, r11, -0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -24224;
	// 82A873AC: 4BFFD05D  bl 0x82a84408
	ctx.lr = 0x82A873B0;
	sub_82A84408(ctx, base);
	// 82A873B0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A873B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A873B8: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A873BC: 808BC9F0  lwz r4, -0x3610(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13840 as u32) ) } as u64;
	// 82A873C0: 4836C649  bl 0x82df3a08
	ctx.lr = 0x82A873C4;
	sub_82DF3A08(ctx, base);
	// 82A873C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A873C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A873CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A873D0: 483D4D89  bl 0x82e5c158
	ctx.lr = 0x82A873D4;
	sub_82E5C158(ctx, base);
	// 82A873D4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A873D8: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A873DC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A873E0: 388BF928  addi r4, r11, -0x6d8
	ctx.r[4].s64 = ctx.r[11].s64 + -1752;
	// 82A873E4: 4BFFD025  bl 0x82a84408
	ctx.lr = 0x82A873E8;
	sub_82A84408(ctx, base);
	// 82A873E8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A873EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A873F0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A873F4: 808BC9F4  lwz r4, -0x360c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13836 as u32) ) } as u64;
	// 82A873F8: 4836C611  bl 0x82df3a08
	ctx.lr = 0x82A873FC;
	sub_82DF3A08(ctx, base);
	// 82A873FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87404: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87408: 483D4D51  bl 0x82e5c158
	ctx.lr = 0x82A8740C;
	sub_82E5C158(ctx, base);
	// 82A8740C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87410: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A87414: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87418: 388BE0A8  addi r4, r11, -0x1f58
	ctx.r[4].s64 = ctx.r[11].s64 + -8024;
	// 82A8741C: 4BFFCFED  bl 0x82a84408
	ctx.lr = 0x82A87420;
	sub_82A84408(ctx, base);
	// 82A87420: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87428: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A8742C: 808BC9F8  lwz r4, -0x3608(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13832 as u32) ) } as u64;
	// 82A87430: 4836C5D9  bl 0x82df3a08
	ctx.lr = 0x82A87434;
	sub_82DF3A08(ctx, base);
	// 82A87434: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8743C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87440: 483D4D19  bl 0x82e5c158
	ctx.lr = 0x82A87444;
	sub_82E5C158(ctx, base);
	// 82A87444: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87448: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A8744C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87450: 388B1A58  addi r4, r11, 0x1a58
	ctx.r[4].s64 = ctx.r[11].s64 + 6744;
	// 82A87454: 4BFFCFB5  bl 0x82a84408
	ctx.lr = 0x82A87458;
	sub_82A84408(ctx, base);
	// 82A87458: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8745C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87460: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A87464: 808BC9FC  lwz r4, -0x3604(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13828 as u32) ) } as u64;
	// 82A87468: 4836C5A1  bl 0x82df3a08
	ctx.lr = 0x82A8746C;
	sub_82DF3A08(ctx, base);
	// 82A8746C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87474: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87478: 483D4CE1  bl 0x82e5c158
	ctx.lr = 0x82A8747C;
	sub_82E5C158(ctx, base);
	// 82A8747C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87480: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A87484: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87488: 388B2D88  addi r4, r11, 0x2d88
	ctx.r[4].s64 = ctx.r[11].s64 + 11656;
	// 82A8748C: 4BFFCF7D  bl 0x82a84408
	ctx.lr = 0x82A87490;
	sub_82A84408(ctx, base);
	// 82A87490: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87494: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87498: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A8749C: 808BCA00  lwz r4, -0x3600(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13824 as u32) ) } as u64;
	// 82A874A0: 4836C569  bl 0x82df3a08
	ctx.lr = 0x82A874A4;
	sub_82DF3A08(ctx, base);
	// 82A874A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A874A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A874AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A874B0: 483D4CA9  bl 0x82e5c158
	ctx.lr = 0x82A874B4;
	sub_82E5C158(ctx, base);
	// 82A874B4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A874B8: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A874BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A874C0: 388B5C18  addi r4, r11, 0x5c18
	ctx.r[4].s64 = ctx.r[11].s64 + 23576;
	// 82A874C4: 4BFFCF45  bl 0x82a84408
	ctx.lr = 0x82A874C8;
	sub_82A84408(ctx, base);
	// 82A874C8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A874CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A874D0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A874D4: 808BCA0C  lwz r4, -0x35f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13812 as u32) ) } as u64;
	// 82A874D8: 4836C531  bl 0x82df3a08
	ctx.lr = 0x82A874DC;
	sub_82DF3A08(ctx, base);
	// 82A874DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A874E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A874E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A874E8: 483D4C71  bl 0x82e5c158
	ctx.lr = 0x82A874EC;
	sub_82E5C158(ctx, base);
	// 82A874EC: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A874F0: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A874F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A874F8: 388B47D0  addi r4, r11, 0x47d0
	ctx.r[4].s64 = ctx.r[11].s64 + 18384;
	// 82A874FC: 4BFFCF0D  bl 0x82a84408
	ctx.lr = 0x82A87500;
	sub_82A84408(ctx, base);
	// 82A87500: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87508: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A8750C: 808BCA08  lwz r4, -0x35f8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13816 as u32) ) } as u64;
	// 82A87510: 4836C4F9  bl 0x82df3a08
	ctx.lr = 0x82A87514;
	sub_82DF3A08(ctx, base);
	// 82A87514: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8751C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87520: 483D4C39  bl 0x82e5c158
	ctx.lr = 0x82A87524;
	sub_82E5C158(ctx, base);
	// 82A87524: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87528: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A8752C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87530: 388B6CC8  addi r4, r11, 0x6cc8
	ctx.r[4].s64 = ctx.r[11].s64 + 27848;
	// 82A87534: 4BFFCED5  bl 0x82a84408
	ctx.lr = 0x82A87538;
	sub_82A84408(ctx, base);
	// 82A87538: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8753C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87540: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A87544: 808BCA10  lwz r4, -0x35f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13808 as u32) ) } as u64;
	// 82A87548: 4836C4C1  bl 0x82df3a08
	ctx.lr = 0x82A8754C;
	sub_82DF3A08(ctx, base);
	// 82A8754C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87554: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87558: 483D4C01  bl 0x82e5c158
	ctx.lr = 0x82A8755C;
	sub_82E5C158(ctx, base);
	// 82A8755C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A87560: 3D6082AA  lis r11, -0x7d56
	ctx.r[11].s64 = -2102788096;
	// 82A87564: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A87568: 388BD4D0  addi r4, r11, -0x2b30
	ctx.r[4].s64 = ctx.r[11].s64 + -11056;
	// 82A8756C: 4BFFCE9D  bl 0x82a84408
	ctx.lr = 0x82A87570;
	sub_82A84408(ctx, base);
	// 82A87570: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87578: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A8757C: 808BCA14  lwz r4, -0x35ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13804 as u32) ) } as u64;
	// 82A87580: 4836C489  bl 0x82df3a08
	ctx.lr = 0x82A87584;
	sub_82DF3A08(ctx, base);
	// 82A87584: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8758C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87590: 483D4BC9  bl 0x82e5c158
	ctx.lr = 0x82A87594;
	sub_82E5C158(ctx, base);
	// 82A87594: 817C0164  lwz r11, 0x164(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(356 as u32) ) } as u64;
	// 82A87598: 3BBC0164  addi r29, r28, 0x164
	ctx.r[29].s64 = ctx.r[28].s64 + 356;
	// 82A8759C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A875A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A875A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A875A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A875AC: 4E800421  bctrl
	ctx.lr = 0x82A875B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A875B0: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A875B4: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82A875B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A875BC: 388BB428  addi r4, r11, -0x4bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -19416;
	// 82A875C0: 4BFFCE49  bl 0x82a84408
	ctx.lr = 0x82A875C4;
	sub_82A84408(ctx, base);
	// 82A875C4: 3F60832F  lis r27, -0x7cd1
	ctx.r[27].s64 = -2094071808;
	// 82A875C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A875CC: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 82A875D0: 809BCA18  lwz r4, -0x35e8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82A875D4: 4836C435  bl 0x82df3a08
	ctx.lr = 0x82A875D8;
	sub_82DF3A08(ctx, base);
	// 82A875D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A875DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A875E0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A875E4: 483D4B75  bl 0x82e5c158
	ctx.lr = 0x82A875E8;
	sub_82E5C158(ctx, base);
	// 82A875E8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A875EC: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82A875F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A875F4: 388BAEF8  addi r4, r11, -0x5108
	ctx.r[4].s64 = ctx.r[11].s64 + -20744;
	// 82A875F8: 4BDE1AB1  bl 0x828690a8
	ctx.lr = 0x82A875FC;
	sub_828690A8(ctx, base);
	// 82A875FC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87604: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 82A87608: 808BCA1C  lwz r4, -0x35e4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13796 as u32) ) } as u64;
	// 82A8760C: 4836C3FD  bl 0x82df3a08
	ctx.lr = 0x82A87610;
	sub_82DF3A08(ctx, base);
	// 82A87610: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A87618: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A8761C: 483D4B3D  bl 0x82e5c158
	ctx.lr = 0x82A87620;
	sub_82E5C158(ctx, base);
	// 82A87620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87624: 809BCA18  lwz r4, -0x35e8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82A87628: 4836C3E1  bl 0x82df3a08
	ctx.lr = 0x82A8762C;
	sub_82DF3A08(ctx, base);
	// 82A8762C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A87630: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87634: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A87638: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A8763C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A87640: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A87644: 483D731D  bl 0x82e5e960
	ctx.lr = 0x82A87648;
	sub_82E5E960(ctx, base);
	// 82A87648: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A8764C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87650: 419A0008  beq cr6, 0x82a87658
	if ctx.cr[6].eq {
	pc = 0x82A87658; continue 'dispatch;
	}
	// 82A87654: 4B83923D  bl 0x822c0890
	ctx.lr = 0x82A87658;
	sub_822C0890(ctx, base);
	// 82A87658: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A8765C: 4BA8B43D  bl 0x82512a98
	ctx.lr = 0x82A87660;
	sub_82512A98(ctx, base);
	// 82A87660: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A87664: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A87668: 38A0018C  li r5, 0x18c
	ctx.r[5].s64 = 396;
	// 82A8766C: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A87670: 4B838D69  bl 0x822c03d8
	ctx.lr = 0x82A87674;
	sub_822C03D8(ctx, base);
	// 82A87674: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A87678: 41820020  beq 0x82a87698
	if ctx.cr[0].eq {
	pc = 0x82A87698; continue 'dispatch;
	}
	// 82A8767C: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A87680: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A87684: 409A0008  bne cr6, 0x82a8768c
	if !ctx.cr[6].eq {
	pc = 0x82A8768C; continue 'dispatch;
	}
	// 82A87688: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A8768C: 480006BD  bl 0x82a87d48
	ctx.lr = 0x82A87690;
	sub_82A87D48(ctx, base);
	// 82A87690: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87694: 48000008  b 0x82a8769c
	pc = 0x82A8769C; continue 'dispatch;
	// 82A87698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A8769C: 387C0360  addi r3, r28, 0x360
	ctx.r[3].s64 = ctx.r[28].s64 + 864;
	// 82A876A0: 4BFFC071  bl 0x82a83710
	ctx.lr = 0x82A876A4;
	sub_82A83710(ctx, base);
	// 82A876A4: 807C0360  lwz r3, 0x360(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(864 as u32) ) } as u64;
	// 82A876A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A876AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A876B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A876B4: 4E800421  bctrl
	ctx.lr = 0x82A876B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A876B8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A876BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A876C0: 3B6BE0D8  addi r27, r11, -0x1f28
	ctx.r[27].s64 = ctx.r[11].s64 + -7976;
	// 82A876C4: C02BE0D8  lfs f1, -0x1f28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7976 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A876C8: 4BE86D89  bl 0x8290e450
	ctx.lr = 0x82A876CC;
	sub_8290E450(ctx, base);
	// 82A876CC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A876D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A876D4: 38A00194  li r5, 0x194
	ctx.r[5].s64 = 404;
	// 82A876D8: 38600118  li r3, 0x118
	ctx.r[3].s64 = 280;
	// 82A876DC: 4836AD0D  bl 0x82df23e8
	ctx.lr = 0x82A876E0;
	sub_82DF23E8(ctx, base);
	// 82A876E0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A876E4: 41820020  beq 0x82a87704
	if ctx.cr[0].eq {
	pc = 0x82A87704; continue 'dispatch;
	}
	// 82A876E8: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 82A876EC: 485818CD  bl 0x83008fb8
	ctx.lr = 0x82A876F0;
	sub_83008FB8(ctx, base);
	// 82A876F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A876F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A876F8: 4BEFE359  bl 0x82985a50
	ctx.lr = 0x82A876FC;
	sub_82985A50(ctx, base);
	// 82A876FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A87700: 48000008  b 0x82a87708
	pc = 0x82A87708; continue 'dispatch;
	// 82A87704: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A87708: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A8770C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87710: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A87714: 4BF002BD  bl 0x829879d0
	ctx.lr = 0x82A87718;
	sub_829879D0(ctx, base);
	// 82A87718: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A8771C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87720: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A87724: 4B8388DD  bl 0x822c0000
	ctx.lr = 0x82A87728;
	sub_822C0000(ctx, base);
	// 82A87728: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A8772C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A87730: 409A0008  bne cr6, 0x82a87738
	if !ctx.cr[6].eq {
	pc = 0x82A87738; continue 'dispatch;
	}
	// 82A87734: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A87738: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A8773C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A87740: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A87744: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A87748: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A8774C: 419A0024  beq cr6, 0x82a87770
	if ctx.cr[6].eq {
	pc = 0x82A87770; continue 'dispatch;
	}
	// 82A87750: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82A87754: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A87758: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8775C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A87760: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A87764: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A87768: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8776C: 4082FFE8  bne 0x82a87754
	if !ctx.cr[0].eq {
	pc = 0x82A87754; continue 'dispatch;
	}
	// 82A87770: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A87774: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82A87778: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A8777C: 4BA85D8D  bl 0x8250d508
	ctx.lr = 0x82A87780;
	sub_8250D508(ctx, base);
	// 82A87780: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82A87784: 48581835  bl 0x83008fb8
	ctx.lr = 0x82A87788;
	sub_83008FB8(ctx, base);
	// 82A87788: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 82A8778C: 907C040C  stw r3, 0x40c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1036 as u32), ctx.r[3].u32 ) };
	// 82A87790: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A87794: 9AE10090  stb r23, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[23].u8 ) };
	// 82A87798: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82A8779C: 38BB0020  addi r5, r27, 0x20
	ctx.r[5].s64 = ctx.r[27].s64 + 32;
	// 82A877A0: 4BFFBFE1  bl 0x82a83780
	ctx.lr = 0x82A877A4;
	sub_82A83780(ctx, base);
	// 82A877A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A877A8: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82A877AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A877B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A877B4: 916100DC  stw r11, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82A877B8: 419A0024  beq cr6, 0x82a877dc
	if ctx.cr[6].eq {
	pc = 0x82A877DC; continue 'dispatch;
	}
	// 82A877BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A877C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A877C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A877C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A877CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A877D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A877D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A877D8: 4082FFE8  bne 0x82a877c0
	if !ctx.cr[0].eq {
	pc = 0x82A877C0; continue 'dispatch;
	}
	// 82A877DC: 3B3C0028  addi r25, r28, 0x28
	ctx.r[25].s64 = ctx.r[28].s64 + 40;
	// 82A877E0: 80DC040C  lwz r6, 0x40c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1036 as u32) ) } as u64;
	// 82A877E4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A877E8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A877EC: 38E100D8  addi r7, r1, 0xd8
	ctx.r[7].s64 = ctx.r[1].s64 + 216;
	// 82A877F0: 38A0019A  li r5, 0x19a
	ctx.r[5].s64 = 410;
	// 82A877F4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A877F8: 483D1249  bl 0x82e58a40
	ctx.lr = 0x82A877FC;
	sub_82E58A40(ctx, base);
	// 82A877FC: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A87800: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87804: 419A0008  beq cr6, 0x82a8780c
	if ctx.cr[6].eq {
	pc = 0x82A8780C; continue 'dispatch;
	}
	// 82A87808: 4B839089  bl 0x822c0890
	ctx.lr = 0x82A8780C;
	sub_822C0890(ctx, base);
	// 82A8780C: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82A87810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87814: 419A0008  beq cr6, 0x82a8781c
	if ctx.cr[6].eq {
	pc = 0x82A8781C; continue 'dispatch;
	}
	// 82A87818: 4B839079  bl 0x822c0890
	ctx.lr = 0x82A8781C;
	sub_822C0890(ctx, base);
	// 82A8781C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A87820: 419A000C  beq cr6, 0x82a8782c
	if ctx.cr[6].eq {
	pc = 0x82A8782C; continue 'dispatch;
	}
	// 82A87824: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A87828: 4B839069  bl 0x822c0890
	ctx.lr = 0x82A8782C;
	sub_822C0890(ctx, base);
	// 82A8782C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A87830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87834: 388BE118  addi r4, r11, -0x1ee8
	ctx.r[4].s64 = ctx.r[11].s64 + -7912;
	// 82A87838: 4BFFBFC9  bl 0x82a83800
	ctx.lr = 0x82A8783C;
	sub_82A83800(ctx, base);
	// 82A8783C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A87840: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82A87844: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A87848: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A8784C: 93A100E4  stw r29, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 82A87850: 419A0024  beq cr6, 0x82a87874
	if ctx.cr[6].eq {
	pc = 0x82A87874; continue 'dispatch;
	}
	// 82A87854: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A87858: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A8785C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87860: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A87864: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A87868: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A8786C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87870: 4082FFE8  bne 0x82a87858
	if !ctx.cr[0].eq {
	pc = 0x82A87858; continue 'dispatch;
	}
	// 82A87874: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A87878: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82A8787C: 4BA87C4D  bl 0x8250f4c8
	ctx.lr = 0x82A87880;
	sub_8250F4C8(ctx, base);
	// 82A87880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A87888: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A8788C: 409A0008  bne cr6, 0x82a87894
	if !ctx.cr[6].eq {
	pc = 0x82A87894; continue 'dispatch;
	}
	// 82A87890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A87894: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A87898: 3B6100E0  addi r27, r1, 0xe0
	ctx.r[27].s64 = ctx.r[1].s64 + 224;
	// 82A8789C: 4BA8117D  bl 0x82508a18
	ctx.lr = 0x82A878A0;
	sub_82508A18(ctx, base);
	// 82A878A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A878A4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A878A8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A878AC: 38A001A0  li r5, 0x1a0
	ctx.r[5].s64 = 416;
	// 82A878B0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A878B4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A878B8: 483D1189  bl 0x82e58a40
	ctx.lr = 0x82A878BC;
	sub_82E58A40(ctx, base);
	// 82A878BC: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82A878C0: 4836A3D1  bl 0x82df1c90
	ctx.lr = 0x82A878C4;
	sub_82DF1C90(ctx, base);
	// 82A878C4: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A878C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A878CC: 419A0008  beq cr6, 0x82a878d4
	if ctx.cr[6].eq {
	pc = 0x82A878D4; continue 'dispatch;
	}
	// 82A878D0: 4B838FC1  bl 0x822c0890
	ctx.lr = 0x82A878D4;
	sub_822C0890(ctx, base);
	// 82A878D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A878D8: 419A000C  beq cr6, 0x82a878e4
	if ctx.cr[6].eq {
	pc = 0x82A878E4; continue 'dispatch;
	}
	// 82A878DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A878E0: 4B838FB1  bl 0x822c0890
	ctx.lr = 0x82A878E4;
	sub_822C0890(ctx, base);
	// 82A878E4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A878E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A878EC: 38A001A5  li r5, 0x1a5
	ctx.r[5].s64 = 421;
	// 82A878F0: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 82A878F4: 4836AAF5  bl 0x82df23e8
	ctx.lr = 0x82A878F8;
	sub_82DF23E8(ctx, base);
	// 82A878F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A878FC: 41820020  beq 0x82a8791c
	if ctx.cr[0].eq {
	pc = 0x82A8791C; continue 'dispatch;
	}
	// 82A87900: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A87904: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A87908: 409A0008  bne cr6, 0x82a87910
	if !ctx.cr[6].eq {
	pc = 0x82A87910; continue 'dispatch;
	}
	// 82A8790C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A87910: 48009D31  bl 0x82a91640
	ctx.lr = 0x82A87914;
	sub_82A91640(ctx, base);
	// 82A87914: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A87918: 48000008  b 0x82a87920
	pc = 0x82A87920; continue 'dispatch;
	// 82A8791C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A87920: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A87924: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87928: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8792C: 4BFFA3CD  bl 0x82a81cf8
	ctx.lr = 0x82A87930;
	sub_82A81CF8(ctx, base);
	// 82A87930: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87934: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87938: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8793C: 4B8386C5  bl 0x822c0000
	ctx.lr = 0x82A87940;
	sub_822C0000(ctx, base);
	// 82A87940: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A87944: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A87948: 409A0008  bne cr6, 0x82a87950
	if !ctx.cr[6].eq {
	pc = 0x82A87950; continue 'dispatch;
	}
	// 82A8794C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A87950: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A87954: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A87958: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A8795C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A87960: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82A87964: 419A0024  beq cr6, 0x82a87988
	if ctx.cr[6].eq {
	pc = 0x82A87988; continue 'dispatch;
	}
	// 82A87968: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A8796C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A87970: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87974: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A87978: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A8797C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A87980: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87984: 4082FFE8  bne 0x82a8796c
	if !ctx.cr[0].eq {
	pc = 0x82A8796C; continue 'dispatch;
	}
	// 82A87988: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A8798C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82A87990: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A87994: 4BA85B75  bl 0x8250d508
	ctx.lr = 0x82A87998;
	sub_8250D508(ctx, base);
	// 82A87998: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 82A8799C: 4858161D  bl 0x83008fb8
	ctx.lr = 0x82A879A0;
	sub_83008FB8(ctx, base);
	// 82A879A0: 907C0408  stw r3, 0x408(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1032 as u32), ctx.r[3].u32 ) };
	// 82A879A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A879A8: 419A000C  beq cr6, 0x82a879b4
	if ctx.cr[6].eq {
	pc = 0x82A879B4; continue 'dispatch;
	}
	// 82A879AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A879B0: 4B838EE1  bl 0x822c0890
	ctx.lr = 0x82A879B4;
	sub_822C0890(ctx, base);
	// 82A879B4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82A879B8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A879BC: 4BA80CC5  bl 0x82508680
	ctx.lr = 0x82A879C0;
	sub_82508680(ctx, base);
	// 82A879C0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A879C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A879C8: 388BCA28  addi r4, r11, -0x35d8
	ctx.r[4].s64 = ctx.r[11].s64 + -13784;
	// 82A879CC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A879D0: 4BF4FF21  bl 0x829d78f0
	ctx.lr = 0x82A879D4;
	sub_829D78F0(ctx, base);
	// 82A879D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A879D8: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82A879DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A879E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A879E4: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82A879E8: 419A0024  beq cr6, 0x82a87a0c
	if ctx.cr[6].eq {
	pc = 0x82A87A0C; continue 'dispatch;
	}
	// 82A879EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A879F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A879F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A879F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A879FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A87A00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A87A04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87A08: 4082FFE8  bne 0x82a879f0
	if !ctx.cr[0].eq {
	pc = 0x82A879F0; continue 'dispatch;
	}
	// 82A87A0C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A87A10: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A87A14: 38E100C8  addi r7, r1, 0xc8
	ctx.r[7].s64 = ctx.r[1].s64 + 200;
	// 82A87A18: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A87A1C: 38A001AF  li r5, 0x1af
	ctx.r[5].s64 = 431;
	// 82A87A20: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A87A24: 483D101D  bl 0x82e58a40
	ctx.lr = 0x82A87A28;
	sub_82E58A40(ctx, base);
	// 82A87A28: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A87A2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87A30: 419A0008  beq cr6, 0x82a87a38
	if ctx.cr[6].eq {
	pc = 0x82A87A38; continue 'dispatch;
	}
	// 82A87A34: 4B838E5D  bl 0x822c0890
	ctx.lr = 0x82A87A38;
	sub_822C0890(ctx, base);
	// 82A87A38: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A87A3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87A40: 419A0008  beq cr6, 0x82a87a48
	if ctx.cr[6].eq {
	pc = 0x82A87A48; continue 'dispatch;
	}
	// 82A87A44: 4B838E4D  bl 0x822c0890
	ctx.lr = 0x82A87A48;
	sub_822C0890(ctx, base);
	// 82A87A48: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A87A4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A87A50: 38A001B5  li r5, 0x1b5
	ctx.r[5].s64 = 437;
	// 82A87A54: 38600158  li r3, 0x158
	ctx.r[3].s64 = 344;
	// 82A87A58: 4836A991  bl 0x82df23e8
	ctx.lr = 0x82A87A5C;
	sub_82DF23E8(ctx, base);
	// 82A87A5C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A87A60: 41820020  beq 0x82a87a80
	if ctx.cr[0].eq {
	pc = 0x82A87A80; continue 'dispatch;
	}
	// 82A87A64: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A87A68: 48581551  bl 0x83008fb8
	ctx.lr = 0x82A87A6C;
	sub_83008FB8(ctx, base);
	// 82A87A6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A87A70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A87A74: 4BEC8EAD  bl 0x82950920
	ctx.lr = 0x82A87A78;
	sub_82950920(ctx, base);
	// 82A87A78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A87A7C: 48000008  b 0x82a87a84
	pc = 0x82A87A84; continue 'dispatch;
	// 82A87A80: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A87A84: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A87A88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87A8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A87A90: 4BECB249  bl 0x82952cd8
	ctx.lr = 0x82A87A94;
	sub_82952CD8(ctx, base);
	// 82A87A94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A87A98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A87A9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A87AA0: 4B838561  bl 0x822c0000
	ctx.lr = 0x82A87AA4;
	sub_822C0000(ctx, base);
	// 82A87AA4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A87AA8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A87AAC: 409A0008  bne cr6, 0x82a87ab4
	if !ctx.cr[6].eq {
	pc = 0x82A87AB4; continue 'dispatch;
	}
	// 82A87AB0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A87AB4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A87AB8: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A87ABC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A87AC0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A87AC4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82A87AC8: 419A0024  beq cr6, 0x82a87aec
	if ctx.cr[6].eq {
	pc = 0x82A87AEC; continue 'dispatch;
	}
	// 82A87ACC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A87AD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A87AD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87AD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A87ADC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A87AE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A87AE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87AE8: 4082FFE8  bne 0x82a87ad0
	if !ctx.cr[0].eq {
	pc = 0x82A87AD0; continue 'dispatch;
	}
	// 82A87AEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A87AF0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82A87AF4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A87AF8: 4BA85A11  bl 0x8250d508
	ctx.lr = 0x82A87AFC;
	sub_8250D508(ctx, base);
	// 82A87AFC: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 82A87B00: 485814B9  bl 0x83008fb8
	ctx.lr = 0x82A87B04;
	sub_83008FB8(ctx, base);
	// 82A87B04: 907C0414  stw r3, 0x414(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1044 as u32), ctx.r[3].u32 ) };
	// 82A87B08: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A87B0C: 419A000C  beq cr6, 0x82a87b18
	if ctx.cr[6].eq {
	pc = 0x82A87B18; continue 'dispatch;
	}
	// 82A87B10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A87B14: 4B838D7D  bl 0x822c0890
	ctx.lr = 0x82A87B18;
	sub_822C0890(ctx, base);
	// 82A87B18: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82A87B1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A87B20: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A87B24: 4BF03095  bl 0x8298abb8
	ctx.lr = 0x82A87B28;
	sub_8298ABB8(ctx, base);
	// 82A87B28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87B2C: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82A87B30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A87B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A87B38: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82A87B3C: 419A0024  beq cr6, 0x82a87b60
	if ctx.cr[6].eq {
	pc = 0x82A87B60; continue 'dispatch;
	}
	// 82A87B40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A87B44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A87B48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87B4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A87B50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A87B54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A87B58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A87B5C: 4082FFE8  bne 0x82a87b44
	if !ctx.cr[0].eq {
	pc = 0x82A87B44; continue 'dispatch;
	}
	// 82A87B60: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A87B64: 3BC100C0  addi r30, r1, 0xc0
	ctx.r[30].s64 = ctx.r[1].s64 + 192;
	// 82A87B68: 4BA80AB1  bl 0x82508618
	ctx.lr = 0x82A87B6C;
	sub_82508618(ctx, base);
	// 82A87B6C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A87B70: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A87B74: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A87B78: 38A001BC  li r5, 0x1bc
	ctx.r[5].s64 = 444;
	// 82A87B7C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A87B80: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A87B84: 483D0EBD  bl 0x82e58a40
	ctx.lr = 0x82A87B88;
	sub_82E58A40(ctx, base);
	// 82A87B88: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A87B8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87B90: 419A0008  beq cr6, 0x82a87b98
	if ctx.cr[6].eq {
	pc = 0x82A87B98; continue 'dispatch;
	}
	// 82A87B94: 4B838CFD  bl 0x822c0890
	ctx.lr = 0x82A87B98;
	sub_822C0890(ctx, base);
	// 82A87B98: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A87B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87BA0: 419A0008  beq cr6, 0x82a87ba8
	if ctx.cr[6].eq {
	pc = 0x82A87BA8; continue 'dispatch;
	}
	// 82A87BA4: 4B838CED  bl 0x822c0890
	ctx.lr = 0x82A87BA8;
	sub_822C0890(ctx, base);
	// 82A87BA8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87BAC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A87BB0: 396B99D8  addi r11, r11, -0x6628
	ctx.r[11].s64 = ctx.r[11].s64 + -26152;
	// 82A87BB4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A87BB8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A87BBC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A87BC0: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87BC4: 80C80004  lwz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A87BC8: 80A80008  lwz r5, 8(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A87BCC: 8108000C  lwz r8, 0xc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A87BD0: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A87BD4: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A87BD8: 90AA0008  stw r5, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A87BDC: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A87BE0: 9AE10050  stb r23, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u8 ) };
	// 82A87BE4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87BE8: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A87BEC: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A87BF0: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A87BF4: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A87BF8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A87BFC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A87C00: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A87C04: 4BA80AD5  bl 0x825086d8
	ctx.lr = 0x82A87C08;
	sub_825086D8(ctx, base);
	// 82A87C08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A87C0C: 4B9D4915  bl 0x8245c520
	ctx.lr = 0x82A87C10;
	sub_8245C520(ctx, base);
	// 82A87C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A87C14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A87C18: 4B9D5541  bl 0x8245d158
	ctx.lr = 0x82A87C1C;
	sub_8245D158(ctx, base);
	// 82A87C1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A87C20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A87C24: 4B9D5535  bl 0x8245d158
	ctx.lr = 0x82A87C28;
	sub_8245D158(ctx, base);
	// 82A87C28: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A87C2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A87C30: 4BE863D1  bl 0x8290e000
	ctx.lr = 0x82A87C34;
	sub_8290E000(ctx, base);
	// 82A87C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87C38: 8096C9DC  lwz r4, -0x3624(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-13860 as u32) ) } as u64;
	// 82A87C3C: 4836BDCD  bl 0x82df3a08
	ctx.lr = 0x82A87C40;
	sub_82DF3A08(ctx, base);
	// 82A87C40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A87C44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A87C48: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A87C4C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82A87C50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A87C54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A87C58: 483D6D09  bl 0x82e5e960
	ctx.lr = 0x82A87C5C;
	sub_82E5E960(ctx, base);
	// 82A87C5C: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A87C60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A87C64: 419A0008  beq cr6, 0x82a87c6c
	if ctx.cr[6].eq {
	pc = 0x82A87C6C; continue 'dispatch;
	}
	// 82A87C68: 4B838C29  bl 0x822c0890
	ctx.lr = 0x82A87C6C;
	sub_822C0890(ctx, base);
	// 82A87C6C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82A87C70: CBA1FF58  lfd f29, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 82A87C74: CBC1FF60  lfd f30, -0xa0(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82A87C78: CBE1FF68  lfd f31, -0x98(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 82A87C7C: 48720508  b 0x831a8184
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A87C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A87C80 size=88
    let mut pc: u32 = 0x82A87C80;
    'dispatch: loop {
        match pc {
            0x82A87C80 => {
    //   block [0x82A87C80..0x82A87CD8)
	// 82A87C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A87C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A87C88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A87C8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A87C90: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A87C94: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A87C98: 396B99E8  addi r11, r11, -0x6618
	ctx.r[11].s64 = ctx.r[11].s64 + -26136;
	// 82A87C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A87CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A87CA4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A87CA8: 48371889  bl 0x82df9530
	ctx.lr = 0x82A87CAC;
	sub_82DF9530(ctx, base);
	// 82A87CAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A87CB0: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82A87CB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A87CB8: 4BDE33A9  bl 0x8286b060
	ctx.lr = 0x82A87CBC;
	sub_8286B060(ctx, base);
	// 82A87CBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A87CC0: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A87CC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A87CC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A87CCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A87CD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A87CD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A87CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A87CD8 size=68
    let mut pc: u32 = 0x82A87CD8;
    'dispatch: loop {
        match pc {
            0x82A87CD8 => {
    //   block [0x82A87CD8..0x82A87D1C)
	// 82A87CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A87CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A87CE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A87CE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A87CE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A87CEC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A87CF0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82A87CF4: 396B2530  addi r11, r11, 0x2530
	ctx.r[11].s64 = ctx.r[11].s64 + 9520;
	// 82A87CF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A87CFC: 4BA295A5  bl 0x824b12a0
	ctx.lr = 0x82A87D00;
	sub_824B12A0(ctx, base);
	// 82A87D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87D04: 4BE8D885  bl 0x82915588
	ctx.lr = 0x82A87D08;
	sub_82915588(ctx, base);
	// 82A87D08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A87D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A87D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A87D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A87D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A87D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A87D20 size=40
    let mut pc: u32 = 0x82A87D20;
    'dispatch: loop {
        match pc {
            0x82A87D20 => {
    //   block [0x82A87D20..0x82A87D48)
	// 82A87D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A87D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A87D28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A87D2C: 38630018  addi r3, r3, 0x18
	ctx.r[3].s64 = ctx.r[3].s64 + 24;
	// 82A87D30: 4BB197A1  bl 0x825a14d0
	ctx.lr = 0x82A87D34;
	sub_825A14D0(ctx, base);
	// 82A87D34: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87D38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A87D3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A87D40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A87D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A87D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A87D48 size=88
    let mut pc: u32 = 0x82A87D48;
    'dispatch: loop {
        match pc {
            0x82A87D48 => {
    //   block [0x82A87D48..0x82A87DA0)
	// 82A87D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A87D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A87D50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A87D54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A87D58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A87D5C: 4BE8D845  bl 0x829155a0
	ctx.lr = 0x82A87D60;
	sub_829155A0(ctx, base);
	// 82A87D60: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A87D64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A87D68: 394A2530  addi r10, r10, 0x2530
	ctx.r[10].s64 = ctx.r[10].s64 + 9520;
	// 82A87D6C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82A87D70: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A87D74: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82A87D78: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A87D7C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A87D80: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A87D84: 4BA7AF3D  bl 0x82502cc0
	ctx.lr = 0x82A87D88;
	sub_82502CC0(ctx, base);
	// 82A87D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87D8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A87D90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A87D94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A87D98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A87D9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A87DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A87DA0 size=76
    let mut pc: u32 = 0x82A87DA0;
    'dispatch: loop {
        match pc {
            0x82A87DA0 => {
    //   block [0x82A87DA0..0x82A87DEC)
	// 82A87DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A87DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A87DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A87DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A87DB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A87DB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A87DB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A87DBC: 4BFFFF1D  bl 0x82a87cd8
	ctx.lr = 0x82A87DC0;
	sub_82A87CD8(ctx, base);
	// 82A87DC0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A87DC4: 4182000C  beq 0x82a87dd0
	if ctx.cr[0].eq {
	pc = 0x82A87DD0; continue 'dispatch;
	}
	// 82A87DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87DCC: 4B83849D  bl 0x822c0268
	ctx.lr = 0x82A87DD0;
	sub_822C0268(ctx, base);
	// 82A87DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A87DD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A87DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A87DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A87DE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A87DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A87DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A87DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A87DF0 size=2124
    let mut pc: u32 = 0x82A87DF0;
    'dispatch: loop {
        match pc {
            0x82A87DF0 => {
    //   block [0x82A87DF0..0x82A8863C)
	// 82A87DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A87DF4: 4872033D  bl 0x831a8130
	ctx.lr = 0x82A87DF8;
	sub_831A8130(ctx, base);
	// 82A87DF8: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82A87DFC: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A87E00: 7C8F2378  mr r15, r4
	ctx.r[15].u64 = ctx.r[4].u64;
	// 82A87E04: 90A10354  stw r5, 0x354(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(852 as u32), ctx.r[5].u32 ) };
	// 82A87E08: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 82A87E0C: 2B0F0000  cmplwi cr6, r15, 0
	ctx.cr[6].compare_u32(ctx.r[15].u32, 0 as u32, &mut ctx.xer);
	// 82A87E10: 39CFFFF0  addi r14, r15, -0x10
	ctx.r[14].s64 = ctx.r[15].s64 + -16;
	// 82A87E14: 409A0008  bne cr6, 0x82a87e1c
	if !ctx.cr[6].eq {
	pc = 0x82A87E1C; continue 'dispatch;
	}
	// 82A87E18: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 82A87E1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A87E20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A87E24: 3B2B1E74  addi r25, r11, 0x1e74
	ctx.r[25].s64 = ctx.r[11].s64 + 7796;
	// 82A87E28: 93210080  stw r25, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 82A87E2C: 4B85D095  bl 0x822e4ec0
	ctx.lr = 0x82A87E30;
	sub_822E4EC0(ctx, base);
	// 82A87E30: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A87E34: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82A87E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A87E3C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A87E40: 80AB6890  lwz r5, 0x6890(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26768 as u32) ) } as u64;
	// 82A87E44: 809B67D4  lwz r4, 0x67d4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26580 as u32) ) } as u64;
	// 82A87E48: 4B86F959  bl 0x822f77a0
	ctx.lr = 0x82A87E4C;
	sub_822F77A0(ctx, base);
	// 82A87E4C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A87E50: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 82A87E54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A87E58: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A87E5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A87E60: 4BA04429  bl 0x8248c288
	ctx.lr = 0x82A87E64;
	sub_8248C288(ctx, base);
	// 82A87E64: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A87E68: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 82A87E6C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82A87E70: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A87E74: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 82A87E78: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A87E7C: 484188B5  bl 0x82ea0730
	ctx.lr = 0x82A87E80;
	sub_82EA0730(ctx, base);
	// 82A87E80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A87E84: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A87E88: 3B4BBC40  addi r26, r11, -0x43c0
	ctx.r[26].s64 = ctx.r[11].s64 + -17344;
	// 82A87E8C: 396A2660  addi r11, r10, 0x2660
	ctx.r[11].s64 = ctx.r[10].s64 + 9824;
	// 82A87E90: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 82A87E94: 392101B0  addi r9, r1, 0x1b0
	ctx.r[9].s64 = ctx.r[1].s64 + 432;
	// 82A87E98: 3B800060  li r28, 0x60
	ctx.r[28].s64 = 96;
	// 82A87E9C: 13E0D0C7  vcmpequd (lvx128) v31, v0, v26
	tmp.u32 = ctx.r[26].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A87EA0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A87EA4: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A87EA8: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A88640 size=68
    let mut pc: u32 = 0x82A88640;
    'dispatch: loop {
        match pc {
            0x82A88640 => {
    //   block [0x82A88640..0x82A88684)
	// 82A88640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A88644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A88648: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8864C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A88650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A88654: 4BE8E885  bl 0x82916ed8
	ctx.lr = 0x82A88658;
	sub_82916ED8(ctx, base);
	// 82A88658: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8865C: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 82A88660: 396B2674  addi r11, r11, 0x2674
	ctx.r[11].s64 = ctx.r[11].s64 + 9844;
	// 82A88664: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A88668: 4800C149  bl 0x82a947b0
	ctx.lr = 0x82A8866C;
	sub_82A947B0(ctx, base);
	// 82A8866C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A88670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A88674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A88678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8867C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A88680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88688 size=4
    let mut pc: u32 = 0x82A88688;
    'dispatch: loop {
        match pc {
            0x82A88688 => {
    //   block [0x82A88688..0x82A8868C)
	// 82A88688: 4BD670F8  b 0x827ef780
	sub_827EF780(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88690 size=40
    let mut pc: u32 = 0x82A88690;
    'dispatch: loop {
        match pc {
            0x82A88690 => {
    //   block [0x82A88690..0x82A886B8)
	// 82A88690: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A88694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A88698: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 82A8869C: 409A0008  bne cr6, 0x82a886a4
	if !ctx.cr[6].eq {
	pc = 0x82A886A4; continue 'dispatch;
	}
	// 82A886A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A886A4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A886A8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82A886AC: 816A00D0  lwz r11, 0xd0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A886B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A886B4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A886B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A886B8 size=88
    let mut pc: u32 = 0x82A886B8;
    'dispatch: loop {
        match pc {
            0x82A886B8 => {
    //   block [0x82A886B8..0x82A88710)
	// 82A886B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A886BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A886C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A886C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A886C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A886CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A886D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A886D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A886D8: 396B2674  addi r11, r11, 0x2674
	ctx.r[11].s64 = ctx.r[11].s64 + 9844;
	// 82A886DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A886E0: 4BE8E489  bl 0x82916b68
	ctx.lr = 0x82A886E4;
	sub_82916B68(ctx, base);
	// 82A886E4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A886E8: 4182000C  beq 0x82a886f4
	if ctx.cr[0].eq {
	pc = 0x82A886F4; continue 'dispatch;
	}
	// 82A886EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A886F0: 4B837B79  bl 0x822c0268
	ctx.lr = 0x82A886F4;
	sub_822C0268(ctx, base);
	// 82A886F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A886F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A886FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A88700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A88704: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A88708: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8870C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A88710 size=60
    let mut pc: u32 = 0x82A88710;
    'dispatch: loop {
        match pc {
            0x82A88710 => {
    //   block [0x82A88710..0x82A8874C)
	// 82A88710: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88714: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A88718: 396300C0  addi r11, r3, 0xc0
	ctx.r[11].s64 = ctx.r[3].s64 + 192;
	// 82A8871C: 912300C0  stw r9, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 82A88720: 13E450C7  vcmpequd (lvx128) v31, v4, v10
	tmp.u32 = ctx.r[4].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A88750 size=276
    let mut pc: u32 = 0x82A88750;
    'dispatch: loop {
        match pc {
            0x82A88750 => {
    //   block [0x82A88750..0x82A88864)
	// 82A88750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A88754: 4871FA19  bl 0x831a816c
	ctx.lr = 0x82A88758;
	sub_831A8130(ctx, base);
	// 82A88758: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A8875C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A88760: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A88764: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A88768: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A8876C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A88770: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A88774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A88778: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 82A8877C: 409A0008  bne cr6, 0x82a88784
	if !ctx.cr[6].eq {
	pc = 0x82A88784; continue 'dispatch;
	}
	// 82A88780: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A88784: 4BFF8F25  bl 0x82a816a8
	ctx.lr = 0x82A88788;
	sub_82A816A8(ctx, base);
	// 82A88788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8878C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A88790: 41820010  beq 0x82a887a0
	if ctx.cr[0].eq {
	pc = 0x82A887A0; continue 'dispatch;
	}
	// 82A88794: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A88798: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A8879C: 480000AC  b 0x82a88848
	pc = 0x82A88848; continue 'dispatch;
	// 82A887A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A887A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A887A8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A887AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A887B0: 4E800421  bctrl
	ctx.lr = 0x82A887B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A887B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A887B8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A887BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A887C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A887C4: 4E800421  bctrl
	ctx.lr = 0x82A887C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A887C8: 4BD6AEB9  bl 0x827f3680
	ctx.lr = 0x82A887CC;
	sub_827F3680(ctx, base);
	// 82A887CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A887D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A887D4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A887D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A887DC: 4BD61BA5  bl 0x827ea380
	ctx.lr = 0x82A887E0;
	sub_827EA380(ctx, base);
	// 82A887E0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82A887E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A887E8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A887EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A887F0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88868 size=12
    let mut pc: u32 = 0x82A88868;
    'dispatch: loop {
        match pc {
            0x82A88868 => {
    //   block [0x82A88868..0x82A88874)
	// 82A88868: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8886C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88870: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88874(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88874 size=8
    let mut pc: u32 = 0x82A88874;
    'dispatch: loop {
        match pc {
            0x82A88874 => {
    //   block [0x82A88874..0x82A8887C)
	// 82A88874: 4BD6191C  b 0x827ea190
	sub_827EA190(ctx, base);
	return;
	// 82A88878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A88880 size=80
    let mut pc: u32 = 0x82A88880;
    'dispatch: loop {
        match pc {
            0x82A88880 => {
    //   block [0x82A88880..0x82A888D0)
	// 82A88880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A88884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A88888: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8888C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A88890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A88894: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A88898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8889C: 419A0020  beq cr6, 0x82a888bc
	if ctx.cr[6].eq {
	pc = 0x82A888BC; continue 'dispatch;
	}
	// 82A888A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A888A4: 4836B165  bl 0x82df3a08
	ctx.lr = 0x82A888A8;
	sub_82DF3A08(ctx, base);
	// 82A888A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A888AC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A888B0: 4BD61C31  bl 0x827ea4e0
	ctx.lr = 0x82A888B4;
	sub_827EA4E0(ctx, base);
	// 82A888B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A888B8: 4836AB71  bl 0x82df3428
	ctx.lr = 0x82A888BC;
	sub_82DF3428(ctx, base);
	// 82A888BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A888C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A888C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A888C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A888CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A888D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A888D0 size=84
    let mut pc: u32 = 0x82A888D0;
    'dispatch: loop {
        match pc {
            0x82A888D0 => {
    //   block [0x82A888D0..0x82A88924)
	// 82A888D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A888D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A888D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A888DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A888E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A888E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A888E8: 396B2714  addi r11, r11, 0x2714
	ctx.r[11].s64 = ctx.r[11].s64 + 10004;
	// 82A888EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A888F0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A888F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A888F8: 419A0008  beq cr6, 0x82a88900
	if ctx.cr[6].eq {
	pc = 0x82A88900; continue 'dispatch;
	}
	// 82A888FC: 4B837F95  bl 0x822c0890
	ctx.lr = 0x82A88900;
	sub_822C0890(ctx, base);
	// 82A88900: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A88904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88908: 419A0008  beq cr6, 0x82a88910
	if ctx.cr[6].eq {
	pc = 0x82A88910; continue 'dispatch;
	}
	// 82A8890C: 4B837F85  bl 0x822c0890
	ctx.lr = 0x82A88910;
	sub_822C0890(ctx, base);
	// 82A88910: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A88914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A88918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8891C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A88920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88928 size=36
    let mut pc: u32 = 0x82A88928;
    'dispatch: loop {
        match pc {
            0x82A88928 => {
    //   block [0x82A88928..0x82A8894C)
	// 82A88928: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A8892C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A88930: 394A2714  addi r10, r10, 0x2714
	ctx.r[10].s64 = ctx.r[10].s64 + 10004;
	// 82A88934: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A88938: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A8893C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A88940: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A88944: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A88948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A88950 size=76
    let mut pc: u32 = 0x82A88950;
    'dispatch: loop {
        match pc {
            0x82A88950 => {
    //   block [0x82A88950..0x82A8899C)
	// 82A88950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A88954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A88958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8895C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A88960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A88964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A88968: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8896C: 4BFFFF65  bl 0x82a888d0
	ctx.lr = 0x82A88970;
	sub_82A888D0(ctx, base);
	// 82A88970: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A88974: 4182000C  beq 0x82a88980
	if ctx.cr[0].eq {
	pc = 0x82A88980; continue 'dispatch;
	}
	// 82A88978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8897C: 4B8378ED  bl 0x822c0268
	ctx.lr = 0x82A88980;
	sub_822C0268(ctx, base);
	// 82A88980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A88984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A88988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8898C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A88990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A88994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A88998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A889A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A889A0 size=992
    let mut pc: u32 = 0x82A889A0;
    'dispatch: loop {
        match pc {
            0x82A889A0 => {
    //   block [0x82A889A0..0x82A88D80)
	// 82A889A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A889A4: 4871F7C1  bl 0x831a8164
	ctx.lr = 0x82A889A8;
	sub_831A8130(ctx, base);
	// 82A889A8: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A889AC: 3BA40010  addi r29, r4, 0x10
	ctx.r[29].s64 = ctx.r[4].s64 + 16;
	// 82A889B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A889B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A889B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A889BC: 4BA86B0D  bl 0x8250f4c8
	ctx.lr = 0x82A889C0;
	sub_8250F4C8(ctx, base);
	// 82A889C0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A889C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A889C8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A889CC: 409A0008  bne cr6, 0x82a889d4
	if !ctx.cr[6].eq {
	pc = 0x82A889D4; continue 'dispatch;
	}
	// 82A889D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A889D4: 4BA7FB55  bl 0x82508528
	ctx.lr = 0x82A889D8;
	sub_82508528(ctx, base);
	// 82A889D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A889DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A889E0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A889E4: 483A2105  bl 0x82e2aae8
	ctx.lr = 0x82A889E8;
	sub_82E2AAE8(ctx, base);
	// 82A889E8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A889EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A889F0: 808BA090  lwz r4, -0x5f70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24432 as u32) ) } as u64;
	// 82A889F4: 4836B015  bl 0x82df3a08
	ctx.lr = 0x82A889F8;
	sub_82DF3A08(ctx, base);
	// 82A889F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A889FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A88A00: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A88A04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A88A08: 483A6469  bl 0x82e2ee70
	ctx.lr = 0x82A88A0C;
	sub_82E2EE70(ctx, base);
	// 82A88A0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A88A10: 4836AA19  bl 0x82df3428
	ctx.lr = 0x82A88A14;
	sub_82DF3428(ctx, base);
	// 82A88A14: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A88A18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A88A1C: 3B6B2720  addi r27, r11, 0x2720
	ctx.r[27].s64 = ctx.r[11].s64 + 10016;
	// 82A88A20: 38A00039  li r5, 0x39
	ctx.r[5].s64 = 57;
	// 82A88A24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A88A28: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A88A2C: 483699BD  bl 0x82df23e8
	ctx.lr = 0x82A88A30;
	sub_82DF23E8(ctx, base);
	// 82A88A30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A88A34: 41820014  beq 0x82a88a48
	if ctx.cr[0].eq {
	pc = 0x82A88A48; continue 'dispatch;
	}
	// 82A88A38: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A88A3C: 4838DE55  bl 0x82e16890
	ctx.lr = 0x82A88A40;
	sub_82E16890(ctx, base);
	// 82A88A40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A88A44: 48000008  b 0x82a88a4c
	pc = 0x82A88A4C; continue 'dispatch;
	// 82A88A48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A88A4C: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 82A88A50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A88A54: 4B8D491D  bl 0x8235d370
	ctx.lr = 0x82A88A58;
	sub_8235D370(ctx, base);
	// 82A88A58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A88A5C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A88A60: C02B271C  lfs f1, 0x271c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10012 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A88A64: 483F3F25  bl 0x82e7c988
	ctx.lr = 0x82A88A68;
	sub_82E7C988(ctx, base);
	// 82A88A68: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A88A6C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A88A70: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A88A74: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82A88A78: C06B3F00  lfs f3, 0x3f00(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16128 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A88A7C: C04A2718  lfs f2, 0x2718(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10008 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A88A80: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A88A84: 483F3595  bl 0x82e7c018
	ctx.lr = 0x82A88A88;
	sub_82E7C018(ctx, base);
	// 82A88A88: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A88A8C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A88A90: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A88A94: 4B83BE6D  bl 0x822c4900
	ctx.lr = 0x82A88A98;
	sub_822C4900(ctx, base);
	// 82A88A98: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A88A9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A88AA0: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 82A88AA4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A88AA8: 48369941  bl 0x82df23e8
	ctx.lr = 0x82A88AAC;
	sub_82DF23E8(ctx, base);
	// 82A88AAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A88AB0: 41820014  beq 0x82a88ac4
	if ctx.cr[0].eq {
	pc = 0x82A88AC4; continue 'dispatch;
	}
	// 82A88AB4: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82A88AB8: 4838A639  bl 0x82e130f0
	ctx.lr = 0x82A88ABC;
	sub_82E130F0(ctx, base);
	// 82A88ABC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A88AC0: 48000008  b 0x82a88ac8
	pc = 0x82A88AC8; continue 'dispatch;
	// 82A88AC4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A88AC8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A88ACC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A88AD0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A88AD4: 4B858545  bl 0x822e1018
	ctx.lr = 0x82A88AD8;
	sub_822E1018(ctx, base);
	// 82A88AD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A88ADC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A88AE0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A88AE4: 4B83751D  bl 0x822c0000
	ctx.lr = 0x82A88AE8;
	sub_822C0000(ctx, base);
	// 82A88AE8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A88AEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A88AF0: 388BB334  addi r4, r11, -0x4ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -19660;
	// 82A88AF4: 4836AF15  bl 0x82df3a08
	ctx.lr = 0x82A88AF8;
	sub_82DF3A08(ctx, base);
	// 82A88AF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A88AFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A88B00: 4BD63AC9  bl 0x827ec5c8
	ctx.lr = 0x82A88B04;
	sub_827EC5C8(ctx, base);
	// 82A88B04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A88B08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A88B0C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A88B10: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88B14: 4838C51D  bl 0x82e15030
	ctx.lr = 0x82A88B18;
	sub_82E15030(ctx, base);
	// 82A88B18: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A88B1C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88B20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A88B24: 4838A30D  bl 0x82e12e30
	ctx.lr = 0x82A88B28;
	sub_82E12E30(ctx, base);
	// 82A88B28: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A88B2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88B30: 419A0008  beq cr6, 0x82a88b38
	if ctx.cr[6].eq {
	pc = 0x82A88B38; continue 'dispatch;
	}
	// 82A88B34: 4B837D5D  bl 0x822c0890
	ctx.lr = 0x82A88B38;
	sub_822C0890(ctx, base);
	// 82A88B38: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A88B3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88B40: 419A0008  beq cr6, 0x82a88b48
	if ctx.cr[6].eq {
	pc = 0x82A88B48; continue 'dispatch;
	}
	// 82A88B44: 4B837D4D  bl 0x822c0890
	ctx.lr = 0x82A88B48;
	sub_822C0890(ctx, base);
	// 82A88B48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A88B4C: 4836A8DD  bl 0x82df3428
	ctx.lr = 0x82A88B50;
	sub_82DF3428(ctx, base);
	// 82A88B50: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88B54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A88B58: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A88B5C: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88B60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A88B64: 4E800421  bctrl
	ctx.lr = 0x82A88B68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A88B68: 815D0084  lwz r10, 0x84(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A88B6C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A88B70: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A88B74: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82A88B78: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A88B7C: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82A88B80: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A88B84: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A88B88: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A88B8C: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A88B90: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88D80 size=12
    let mut pc: u32 = 0x82A88D80;
    'dispatch: loop {
        match pc {
            0x82A88D80 => {
    //   block [0x82A88D80..0x82A88D8C)
	// 82A88D80: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A88D84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88D88: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88D8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88D8C size=8
    let mut pc: u32 = 0x82A88D8C;
    'dispatch: loop {
        match pc {
            0x82A88D8C => {
    //   block [0x82A88D8C..0x82A88D94)
	// 82A88D8C: 4BD61404  b 0x827ea190
	sub_827EA190(ctx, base);
	return;
	// 82A88D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A88D98 size=84
    let mut pc: u32 = 0x82A88D98;
    'dispatch: loop {
        match pc {
            0x82A88D98 => {
    //   block [0x82A88D98..0x82A88DEC)
	// 82A88D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A88D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A88DA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A88DA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A88DA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A88DAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A88DB0: 396B2770  addi r11, r11, 0x2770
	ctx.r[11].s64 = ctx.r[11].s64 + 10096;
	// 82A88DB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A88DB8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A88DBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88DC0: 419A0008  beq cr6, 0x82a88dc8
	if ctx.cr[6].eq {
	pc = 0x82A88DC8; continue 'dispatch;
	}
	// 82A88DC4: 4B837ACD  bl 0x822c0890
	ctx.lr = 0x82A88DC8;
	sub_822C0890(ctx, base);
	// 82A88DC8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A88DCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88DD0: 419A0008  beq cr6, 0x82a88dd8
	if ctx.cr[6].eq {
	pc = 0x82A88DD8; continue 'dispatch;
	}
	// 82A88DD4: 4B837ABD  bl 0x822c0890
	ctx.lr = 0x82A88DD8;
	sub_822C0890(ctx, base);
	// 82A88DD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A88DDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A88DE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A88DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A88DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A88DF0 size=56
    let mut pc: u32 = 0x82A88DF0;
    'dispatch: loop {
        match pc {
            0x82A88DF0 => {
    //   block [0x82A88DF0..0x82A88E28)
	// 82A88DF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A88DF4: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A88DF8: 394BE318  addi r10, r11, -0x1ce8
	ctx.r[10].s64 = ctx.r[11].s64 + -7400;
	// 82A88DFC: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A88E00: 39082770  addi r8, r8, 0x2770
	ctx.r[8].s64 = ctx.r[8].s64 + 10096;
	// 82A88E04: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A88E08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A88E0C: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A88E10: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A88E14: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A88E18: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A88E1C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A88E20: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A88E24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A88E28 size=76
    let mut pc: u32 = 0x82A88E28;
    'dispatch: loop {
        match pc {
            0x82A88E28 => {
    //   block [0x82A88E28..0x82A88E74)
	// 82A88E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A88E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A88E30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A88E34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A88E38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A88E3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A88E40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A88E44: 4BFFFF55  bl 0x82a88d98
	ctx.lr = 0x82A88E48;
	sub_82A88D98(ctx, base);
	// 82A88E48: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A88E4C: 4182000C  beq 0x82a88e58
	if ctx.cr[0].eq {
	pc = 0x82A88E58; continue 'dispatch;
	}
	// 82A88E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A88E54: 4B837415  bl 0x822c0268
	ctx.lr = 0x82A88E58;
	sub_822C0268(ctx, base);
	// 82A88E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A88E5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A88E60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A88E64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A88E68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A88E6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A88E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A88E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A88E78 size=868
    let mut pc: u32 = 0x82A88E78;
    'dispatch: loop {
        match pc {
            0x82A88E78 => {
    //   block [0x82A88E78..0x82A891DC)
	// 82A88E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A88E7C: 4871F2E9  bl 0x831a8164
	ctx.lr = 0x82A88E80;
	sub_831A8130(ctx, base);
	// 82A88E80: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A88E84: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A88E88: 3B840010  addi r28, r4, 0x10
	ctx.r[28].s64 = ctx.r[4].s64 + 16;
	// 82A88E8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A88E90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A88E94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A88E98: 4BA86631  bl 0x8250f4c8
	ctx.lr = 0x82A88E9C;
	sub_8250F4C8(ctx, base);
	// 82A88E9C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A88EA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A88EA4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A88EA8: 409A0008  bne cr6, 0x82a88eb0
	if !ctx.cr[6].eq {
	pc = 0x82A88EB0; continue 'dispatch;
	}
	// 82A88EAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A88EB0: 4BA7F679  bl 0x82508528
	ctx.lr = 0x82A88EB4;
	sub_82508528(ctx, base);
	// 82A88EB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A88EB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A88EBC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88EC0: 483A1C29  bl 0x82e2aae8
	ctx.lr = 0x82A88EC4;
	sub_82E2AAE8(ctx, base);
	// 82A88EC4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A88EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A88ECC: 808BA088  lwz r4, -0x5f78(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24440 as u32) ) } as u64;
	// 82A88ED0: 4836AB39  bl 0x82df3a08
	ctx.lr = 0x82A88ED4;
	sub_82DF3A08(ctx, base);
	// 82A88ED4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A88ED8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A88EDC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A88EE0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A88EE4: 483A5F8D  bl 0x82e2ee70
	ctx.lr = 0x82A88EE8;
	sub_82E2EE70(ctx, base);
	// 82A88EE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A88EEC: 4836A53D  bl 0x82df3428
	ctx.lr = 0x82A88EF0;
	sub_82DF3428(ctx, base);
	// 82A88EF0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A88EF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A88EF8: 3BAB2790  addi r29, r11, 0x2790
	ctx.r[29].s64 = ctx.r[11].s64 + 10128;
	// 82A88EFC: 38A00055  li r5, 0x55
	ctx.r[5].s64 = 85;
	// 82A88F00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A88F04: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A88F08: 483694E1  bl 0x82df23e8
	ctx.lr = 0x82A88F0C;
	sub_82DF23E8(ctx, base);
	// 82A88F0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A88F10: 41820014  beq 0x82a88f24
	if ctx.cr[0].eq {
	pc = 0x82A88F24; continue 'dispatch;
	}
	// 82A88F14: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A88F18: 4838D979  bl 0x82e16890
	ctx.lr = 0x82A88F1C;
	sub_82E16890(ctx, base);
	// 82A88F1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A88F20: 48000008  b 0x82a88f28
	pc = 0x82A88F28; continue 'dispatch;
	// 82A88F24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A88F28: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82A88F2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A88F30: 4B8D4441  bl 0x8235d370
	ctx.lr = 0x82A88F34;
	sub_8235D370(ctx, base);
	// 82A88F34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A88F38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A88F3C: 388B1FD8  addi r4, r11, 0x1fd8
	ctx.r[4].s64 = ctx.r[11].s64 + 8152;
	// 82A88F40: 4836AAC9  bl 0x82df3a08
	ctx.lr = 0x82A88F44;
	sub_82DF3A08(ctx, base);
	// 82A88F44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A88F48: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A88F4C: 4BD6367D  bl 0x827ec5c8
	ctx.lr = 0x82A88F50;
	sub_827EC5C8(ctx, base);
	// 82A88F50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A88F54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A88F58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A88F5C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88F60: 4838C0D1  bl 0x82e15030
	ctx.lr = 0x82A88F64;
	sub_82E15030(ctx, base);
	// 82A88F64: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A88F68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A88F6C: 419A0008  beq cr6, 0x82a88f74
	if ctx.cr[6].eq {
	pc = 0x82A88F74; continue 'dispatch;
	}
	// 82A88F70: 4B837921  bl 0x822c0890
	ctx.lr = 0x82A88F74;
	sub_822C0890(ctx, base);
	// 82A88F74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A88F78: 4836A4B1  bl 0x82df3428
	ctx.lr = 0x82A88F7C;
	sub_82DF3428(ctx, base);
	// 82A88F7C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A88F80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88F84: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A88F88: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A88F8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A88F90: 4E800421  bctrl
	ctx.lr = 0x82A88F94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A88F94: 815B0084  lwz r10, 0x84(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A88F98: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A88F9C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A88FA0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82A88FA4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A88FA8: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82A88FAC: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A88FB0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A88FB4: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A88FB8: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A88FBC: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A891E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A891E0 size=24
    let mut pc: u32 = 0x82A891E0;
    'dispatch: loop {
        match pc {
            0x82A891E0 => {
    //   block [0x82A891E0..0x82A891F8)
	// 82A891E0: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A891E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A891E8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A891EC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A891F0: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82A891F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A891F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A891F8 size=136
    let mut pc: u32 = 0x82A891F8;
    'dispatch: loop {
        match pc {
            0x82A891F8 => {
    //   block [0x82A891F8..0x82A89280)
	// 82A891F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A891FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8920C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A89210: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A89214: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A89218: 409A0020  bne cr6, 0x82a89238
	if !ctx.cr[6].eq {
	pc = 0x82A89238; continue 'dispatch;
	}
	// 82A8921C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A89220: 419A0048  beq cr6, 0x82a89268
	if ctx.cr[6].eq {
	pc = 0x82A89268; continue 'dispatch;
	}
	// 82A89224: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89228: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8922C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89230: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A89234: 48000034  b 0x82a89268
	pc = 0x82A89268; continue 'dispatch;
	// 82A89238: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A8923C: 419A002C  beq cr6, 0x82a89268
	if ctx.cr[6].eq {
	pc = 0x82A89268; continue 'dispatch;
	}
	// 82A89240: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A89244: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89248: 388B9D58  addi r4, r11, -0x62a8
	ctx.r[4].s64 = ctx.r[11].s64 + -25256;
	// 82A8924C: 4871EEAD  bl 0x831a80f8
	ctx.lr = 0x82A89250;
	sub_831A80F8(ctx, base);
	// 82A89250: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A89254: 4182000C  beq 0x82a89260
	if ctx.cr[0].eq {
	pc = 0x82A89260; continue 'dispatch;
	}
	// 82A89258: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A8925C: 4800000C  b 0x82a89268
	pc = 0x82A89268; continue 'dispatch;
	// 82A89260: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A89264: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A89268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8926C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A89270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A89274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A89278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8927C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A89280 size=72
    let mut pc: u32 = 0x82A89280;
    'dispatch: loop {
        match pc {
            0x82A89280 => {
    //   block [0x82A89280..0x82A892C8)
	// 82A89280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89288: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8928C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A89290: 419A001C  beq cr6, 0x82a892ac
	if ctx.cr[6].eq {
	pc = 0x82A892AC; continue 'dispatch;
	}
	// 82A89294: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A89298: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A8929C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A892A0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A892A4: 4BFFFF55  bl 0x82a891f8
	ctx.lr = 0x82A892A8;
	sub_82A891F8(ctx, base);
	// 82A892A8: 48000010  b 0x82a892b8
	pc = 0x82A892B8; continue 'dispatch;
	// 82A892AC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A892B0: 396B9D58  addi r11, r11, -0x62a8
	ctx.r[11].s64 = ctx.r[11].s64 + -25256;
	// 82A892B4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A892B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A892BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A892C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A892C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A892C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A892C8 size=248
    let mut pc: u32 = 0x82A892C8;
    'dispatch: loop {
        match pc {
            0x82A892C8 => {
    //   block [0x82A892C8..0x82A893C0)
	// 82A892C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A892CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A892D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A892D4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A892D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A892DC: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A892E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A892E4: 419A0008  beq cr6, 0x82a892ec
	if ctx.cr[6].eq {
	pc = 0x82A892EC; continue 'dispatch;
	}
	// 82A892E8: 48105239  bl 0x82b8e520
	ctx.lr = 0x82A892EC;
	sub_82B8E520(ctx, base);
	// 82A892EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A892F0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A892F4: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A892F8: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82A892FC: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82A89300: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89304: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82A89308: 4BD62EC9  bl 0x827ec1d0
	ctx.lr = 0x82A8930C;
	sub_827EC1D0(ctx, base);
	// 82A8930C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A89310: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A89314: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A89318: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8931C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A89320: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A89324: 4E800421  bctrl
	ctx.lr = 0x82A89328;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A89328: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8932C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A89330: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89338: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8933C: 419A0024  beq cr6, 0x82a89360
	if ctx.cr[6].eq {
	pc = 0x82A89360; continue 'dispatch;
	}
	// 82A89340: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A89344: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A89348: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8934C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A89350: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A89354: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A89358: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8935C: 4082FFE8  bne 0x82a89344
	if !ctx.cr[0].eq {
	pc = 0x82A89344; continue 'dispatch;
	}
	// 82A89360: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89364: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A89368: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A8936C: 4BD6325D  bl 0x827ec5c8
	ctx.lr = 0x82A89370;
	sub_827EC5C8(ctx, base);
	// 82A89370: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A89374: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89378: 4838BBF9  bl 0x82e14f70
	ctx.lr = 0x82A8937C;
	sub_82E14F70(ctx, base);
	// 82A8937C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A89380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89384: 419A0008  beq cr6, 0x82a8938c
	if ctx.cr[6].eq {
	pc = 0x82A8938C; continue 'dispatch;
	}
	// 82A89388: 4B837509  bl 0x822c0890
	ctx.lr = 0x82A8938C;
	sub_822C0890(ctx, base);
	// 82A8938C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A89390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89394: 419A0008  beq cr6, 0x82a8939c
	if ctx.cr[6].eq {
	pc = 0x82A8939C; continue 'dispatch;
	}
	// 82A89398: 4B8374F9  bl 0x822c0890
	ctx.lr = 0x82A8939C;
	sub_822C0890(ctx, base);
	// 82A8939C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A893A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A893A4: 419A0008  beq cr6, 0x82a893ac
	if ctx.cr[6].eq {
	pc = 0x82A893AC; continue 'dispatch;
	}
	// 82A893A8: 4B8374E9  bl 0x822c0890
	ctx.lr = 0x82A893AC;
	sub_822C0890(ctx, base);
	// 82A893AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A893B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A893B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A893B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A893BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A893C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A893C0 size=268
    let mut pc: u32 = 0x82A893C0;
    'dispatch: loop {
        match pc {
            0x82A893C0 => {
    //   block [0x82A893C0..0x82A894CC)
	// 82A893C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A893C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A893C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A893CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A893D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A893D4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A893D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A893DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A893E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A893E4: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82A893E8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82A893EC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A893F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A893F4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A893F8: 4BFD5179  bl 0x82a5e570
	ctx.lr = 0x82A893FC;
	sub_82A5E570(ctx, base);
	// 82A893FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89400: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A89404: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8940C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A89410: 419A0024  beq cr6, 0x82a89434
	if ctx.cr[6].eq {
	pc = 0x82A89434; continue 'dispatch;
	}
	// 82A89414: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A89418: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A8941C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A89420: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A89424: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A89428: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A8942C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A89430: 4082FFE8  bne 0x82a89418
	if !ctx.cr[0].eq {
	pc = 0x82A89418; continue 'dispatch;
	}
	// 82A89434: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89438: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8943C: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A89440: 4BA86089  bl 0x8250f4c8
	ctx.lr = 0x82A89444;
	sub_8250F4C8(ctx, base);
	// 82A89444: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8944C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A89450: 409A0008  bne cr6, 0x82a89458
	if !ctx.cr[6].eq {
	pc = 0x82A89458; continue 'dispatch;
	}
	// 82A89454: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A89458: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A8945C: 4BA7F1BD  bl 0x82508618
	ctx.lr = 0x82A89460;
	sub_82508618(ctx, base);
	// 82A89460: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A89464: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89468: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A8946C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A89470: 38892908  addi r4, r9, 0x2908
	ctx.r[4].s64 = ctx.r[9].s64 + 10504;
	// 82A89474: 38A001F5  li r5, 0x1f5
	ctx.r[5].s64 = 501;
	// 82A89478: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A8947C: C02A08A4  lfs f1, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A89480: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A89484: 483CF5BD  bl 0x82e58a40
	ctx.lr = 0x82A89488;
	sub_82E58A40(ctx, base);
	// 82A89488: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8948C: 48368805  bl 0x82df1c90
	ctx.lr = 0x82A89490;
	sub_82DF1C90(ctx, base);
	// 82A89490: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A89494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89498: 419A0008  beq cr6, 0x82a894a0
	if ctx.cr[6].eq {
	pc = 0x82A894A0; continue 'dispatch;
	}
	// 82A8949C: 4B8373F5  bl 0x822c0890
	ctx.lr = 0x82A894A0;
	sub_822C0890(ctx, base);
	// 82A894A0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A894A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A894A8: 419A0008  beq cr6, 0x82a894b0
	if ctx.cr[6].eq {
	pc = 0x82A894B0; continue 'dispatch;
	}
	// 82A894AC: 4B8373E5  bl 0x822c0890
	ctx.lr = 0x82A894B0;
	sub_822C0890(ctx, base);
	// 82A894B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A894B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A894B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A894BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A894C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A894C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A894C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A894D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A894D0 size=248
    let mut pc: u32 = 0x82A894D0;
    'dispatch: loop {
        match pc {
            0x82A894D0 => {
    //   block [0x82A894D0..0x82A895C8)
	// 82A894D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A894D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A894D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A894DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A894E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A894E4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A894E8: 394A2960  addi r10, r10, 0x2960
	ctx.r[10].s64 = ctx.r[10].s64 + 10592;
	// 82A894EC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A894F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A894F4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82A894F8: 4BD62CD9  bl 0x827ec1d0
	ctx.lr = 0x82A894FC;
	sub_827EC1D0(ctx, base);
	// 82A894FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A89500: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A89504: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A89508: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8950C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A89510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A89514: 4E800421  bctrl
	ctx.lr = 0x82A89518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A89518: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8951C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A89520: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89528: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8952C: 419A0024  beq cr6, 0x82a89550
	if ctx.cr[6].eq {
	pc = 0x82A89550; continue 'dispatch;
	}
	// 82A89530: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A89534: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A89538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8953C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A89540: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A89544: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A89548: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8954C: 4082FFE8  bne 0x82a89534
	if !ctx.cr[0].eq {
	pc = 0x82A89534; continue 'dispatch;
	}
	// 82A89550: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89554: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A89558: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A8955C: 4BD6306D  bl 0x827ec5c8
	ctx.lr = 0x82A89560;
	sub_827EC5C8(ctx, base);
	// 82A89560: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A89564: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89568: 4838BA09  bl 0x82e14f70
	ctx.lr = 0x82A8956C;
	sub_82E14F70(ctx, base);
	// 82A8956C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A89570: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89574: 419A0008  beq cr6, 0x82a8957c
	if ctx.cr[6].eq {
	pc = 0x82A8957C; continue 'dispatch;
	}
	// 82A89578: 4B837319  bl 0x822c0890
	ctx.lr = 0x82A8957C;
	sub_822C0890(ctx, base);
	// 82A8957C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A89580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89584: 419A0008  beq cr6, 0x82a8958c
	if ctx.cr[6].eq {
	pc = 0x82A8958C; continue 'dispatch;
	}
	// 82A89588: 4B837309  bl 0x822c0890
	ctx.lr = 0x82A8958C;
	sub_822C0890(ctx, base);
	// 82A8958C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A89590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89594: 419A0008  beq cr6, 0x82a8959c
	if ctx.cr[6].eq {
	pc = 0x82A8959C; continue 'dispatch;
	}
	// 82A89598: 4B8372F9  bl 0x822c0890
	ctx.lr = 0x82A8959C;
	sub_822C0890(ctx, base);
	// 82A8959C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A895A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A895A4: 419A0008  beq cr6, 0x82a895ac
	if ctx.cr[6].eq {
	pc = 0x82A895AC; continue 'dispatch;
	}
	// 82A895A8: 4B8372E9  bl 0x822c0890
	ctx.lr = 0x82A895AC;
	sub_822C0890(ctx, base);
	// 82A895AC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82A895B0: 4BA27CF1  bl 0x824b12a0
	ctx.lr = 0x82A895B4;
	sub_824B12A0(ctx, base);
	// 82A895B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A895B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A895BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A895C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A895C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A895C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A895C8 size=128
    let mut pc: u32 = 0x82A895C8;
    'dispatch: loop {
        match pc {
            0x82A895C8 => {
    //   block [0x82A895C8..0x82A89648)
	// 82A895C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A895CC: 4871EBA1  bl 0x831a816c
	ctx.lr = 0x82A895D0;
	sub_831A8130(ctx, base);
	// 82A895D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A895D4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A895D8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A895DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A895E0: 3BEBE320  addi r31, r11, -0x1ce0
	ctx.r[31].s64 = ctx.r[11].s64 + -7392;
	// 82A895E4: 816AE328  lwz r11, -0x1cd8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7384 as u32) ) } as u64;
	// 82A895E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A895EC: 40820024  bne 0x82a89610
	if !ctx.cr[0].eq {
	pc = 0x82A89610; continue 'dispatch;
	}
	// 82A895F0: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 82A895F4: 3D0082A9  lis r8, -0x7d57
	ctx.r[8].s64 = -2102853632;
	// 82A895F8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A895FC: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 82A89600: 39089280  addi r8, r8, -0x6d80
	ctx.r[8].s64 = ctx.r[8].s64 + -28032;
	// 82A89604: 916AE328  stw r11, -0x1cd8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7384 as u32), ctx.r[11].u32 ) };
	// 82A89608: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A8960C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A89610: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A89614: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A89618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8961C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82A89620: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A89624: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A89628: 4BB492F9  bl 0x825d2920
	ctx.lr = 0x82A8962C;
	sub_825D2920(ctx, base);
	// 82A8962C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A89630: 4182000C  beq 0x82a8963c
	if ctx.cr[0].eq {
	pc = 0x82A8963C; continue 'dispatch;
	}
	// 82A89634: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A89638: 48000008  b 0x82a89640
	pc = 0x82A89640; continue 'dispatch;
	// 82A8963C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A89640: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A89644: 4871EB78  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A89648 size=76
    let mut pc: u32 = 0x82A89648;
    'dispatch: loop {
        match pc {
            0x82A89648 => {
    //   block [0x82A89648..0x82A89694)
	// 82A89648: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8964C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A89650: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A89654: 394B2960  addi r10, r11, 0x2960
	ctx.r[10].s64 = ctx.r[11].s64 + 10592;
	// 82A89658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8965C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A89660: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A89664: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A89668: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A8966C: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A89670: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A89674: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A89678: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A8967C: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A89680: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82A89684: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A89688: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82A8968C: 91430030  stw r10, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82A89690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A89698 size=76
    let mut pc: u32 = 0x82A89698;
    'dispatch: loop {
        match pc {
            0x82A89698 => {
    //   block [0x82A89698..0x82A896E4)
	// 82A89698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8969C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A896A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A896A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A896A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A896AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A896B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A896B4: 4BFFFE1D  bl 0x82a894d0
	ctx.lr = 0x82A896B8;
	sub_82A894D0(ctx, base);
	// 82A896B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A896BC: 4182000C  beq 0x82a896c8
	if ctx.cr[0].eq {
	pc = 0x82A896C8; continue 'dispatch;
	}
	// 82A896C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A896C4: 4B836BA5  bl 0x822c0268
	ctx.lr = 0x82A896C8;
	sub_822C0268(ctx, base);
	// 82A896C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A896CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A896D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A896D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A896D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A896DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A896E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A896E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A896E8 size=244
    let mut pc: u32 = 0x82A896E8;
    'dispatch: loop {
        match pc {
            0x82A896E8 => {
    //   block [0x82A896E8..0x82A897DC)
	// 82A896E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A896EC: 4871EA6D  bl 0x831a8158
	ctx.lr = 0x82A896F0;
	sub_831A8130(ctx, base);
	// 82A896F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A896F4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A896F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A896FC: 3B590008  addi r26, r25, 8
	ctx.r[26].s64 = ctx.r[25].s64 + 8;
	// 82A89700: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A89704: 4B83D4A5  bl 0x822c6ba8
	ctx.lr = 0x82A89708;
	sub_822C6BA8(ctx, base);
	// 82A89708: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8970C: 3B00002F  li r24, 0x2f
	ctx.r[24].s64 = 47;
	// 82A89710: 3B6B9B20  addi r27, r11, -0x64e0
	ctx.r[27].s64 = ctx.r[11].s64 + -25824;
	// 82A89714: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 82A89718: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 82A8971C: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 82A89720: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89724: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A89728: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A8972C: 4BA85D9D  bl 0x8250f4c8
	ctx.lr = 0x82A89730;
	sub_8250F4C8(ctx, base);
	// 82A89730: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89738: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A8973C: 409A0008  bne cr6, 0x82a89744
	if !ctx.cr[6].eq {
	pc = 0x82A89744; continue 'dispatch;
	}
	// 82A89740: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A89744: 4BA7EDE5  bl 0x82508528
	ctx.lr = 0x82A89748;
	sub_82508528(ctx, base);
	// 82A89748: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8974C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A89750: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89754: 4BE8B71D  bl 0x82914e70
	ctx.lr = 0x82A89758;
	sub_82914E70(ctx, base);
	// 82A89758: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8975C: 48368535  bl 0x82df1c90
	ctx.lr = 0x82A89760;
	sub_82DF1C90(ctx, base);
	// 82A89760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89764: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89768: 4836A2A1  bl 0x82df3a08
	ctx.lr = 0x82A8976C;
	sub_82DF3A08(ctx, base);
	// 82A8976C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A89770: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A89774: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A89778: 480F6269  bl 0x82b7f9e0
	ctx.lr = 0x82A8977C;
	sub_82B7F9E0(ctx, base);
	// 82A8977C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89780: 48369CA9  bl 0x82df3428
	ctx.lr = 0x82A89784;
	sub_82DF3428(ctx, base);
	// 82A89784: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A89788: 13FCFC07  vcmpneb. (lvlx128) v31, v28, v31
	tmp.u32 = ctx.r[28].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8978C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A89790: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82A89794: 13DDFC07  vcmpneb. (lvlx128) v30, v29, v31
	tmp.u32 = ctx.r[29].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A89798: 13BEFC07  vcmpneb. (lvlx128) v29, v30, v31
	tmp.u32 = ctx.r[30].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8979C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A897A0: 1380FC07  vcmpneb. (lvlx128) v28, v0, v31
	tmp.u32 = ctx.r[31].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A897E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A897E0 size=524
    let mut pc: u32 = 0x82A897E0;
    'dispatch: loop {
        match pc {
            0x82A897E0 => {
    //   block [0x82A897E0..0x82A899EC)
	// 82A897E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A897E4: 4871E981  bl 0x831a8164
	ctx.lr = 0x82A897E8;
	sub_831A8130(ctx, base);
	// 82A897E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A897EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A897F0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A897F4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A897F8: 409A000C  bne cr6, 0x82a89804
	if !ctx.cr[6].eq {
	pc = 0x82A89804; continue 'dispatch;
	}
	// 82A897FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A89800: 480001E4  b 0x82a899e4
	pc = 0x82A899E4; continue 'dispatch;
	// 82A89804: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A89808: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A8980C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A89810: 7F8B502E  lwzx r28, r11, r10
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A89814: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 82A89818: 419AFFE4  beq cr6, 0x82a897fc
	if ctx.cr[6].eq {
	pc = 0x82A897FC; continue 'dispatch;
	}
	// 82A8981C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89820: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A89824: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A89828: 4BA85CA1  bl 0x8250f4c8
	ctx.lr = 0x82A8982C;
	sub_8250F4C8(ctx, base);
	// 82A8982C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89830: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A89834: 388B2908  addi r4, r11, 0x2908
	ctx.r[4].s64 = ctx.r[11].s64 + 10504;
	// 82A89838: 38A001A7  li r5, 0x1a7
	ctx.r[5].s64 = 423;
	// 82A8983C: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 82A89840: 48368BA9  bl 0x82df23e8
	ctx.lr = 0x82A89844;
	sub_82DF23E8(ctx, base);
	// 82A89844: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A89848: 41820030  beq 0x82a89878
	if ctx.cr[0].eq {
	pc = 0x82A89878; continue 'dispatch;
	}
	// 82A8984C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A89850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89854: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A89858: 409A0008  bne cr6, 0x82a89860
	if !ctx.cr[6].eq {
	pc = 0x82A89860; continue 'dispatch;
	}
	// 82A8985C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A89860: 4BA7ECC9  bl 0x82508528
	ctx.lr = 0x82A89864;
	sub_82508528(ctx, base);
	// 82A89864: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A89868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8986C: 481084D5  bl 0x82b91d40
	ctx.lr = 0x82A89870;
	sub_82B91D40(ctx, base);
	// 82A89870: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A89874: 48000008  b 0x82a8987c
	pc = 0x82A8987C; continue 'dispatch;
	// 82A89878: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A8987C: 3BFD0018  addi r31, r29, 0x18
	ctx.r[31].s64 = ctx.r[29].s64 + 24;
	// 82A89880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89884: 4BF3231D  bl 0x829bbba0
	ctx.lr = 0x82A89888;
	sub_829BBBA0(ctx, base);
	// 82A89888: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A8988C: 48104DF5  bl 0x82b8e680
	ctx.lr = 0x82A89890;
	sub_82B8E680(ctx, base);
	// 82A89890: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A89894: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A89898: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A8989C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A898A0: 48108161  bl 0x82b91a00
	ctx.lr = 0x82A898A4;
	sub_82B91A00(ctx, base);
	// 82A898A4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A898A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A898AC: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82A898B0: 4836A159  bl 0x82df3a08
	ctx.lr = 0x82A898B4;
	sub_82DF3A08(ctx, base);
	// 82A898B4: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A898B8: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A898BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A898C0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A898C4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A898C8: 419A0024  beq cr6, 0x82a898ec
	if ctx.cr[6].eq {
	pc = 0x82A898EC; continue 'dispatch;
	}
	// 82A898CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A898D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A898D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A898D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A898DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A898E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A898E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A898E8: 4082FFE8  bne 0x82a898d0
	if !ctx.cr[0].eq {
	pc = 0x82A898D0; continue 'dispatch;
	}
	// 82A898EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A898F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A898F4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A898F8: 409A000C  bne cr6, 0x82a89904
	if !ctx.cr[6].eq {
	pc = 0x82A89904; continue 'dispatch;
	}
	// 82A898FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A89900: 419A000C  beq cr6, 0x82a8990c
	if ctx.cr[6].eq {
	pc = 0x82A8990C; continue 'dispatch;
	}
	// 82A89904: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82A89908: 48000008  b 0x82a89910
	pc = 0x82A89910; continue 'dispatch;
	// 82A8990C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A89910: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A89914: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A89918: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82A8991C: 4BA81D35  bl 0x8250b650
	ctx.lr = 0x82A89920;
	sub_8250B650(ctx, base);
	// 82A89920: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A89924: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A89928: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A8992C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A89930: 4BA83BD9  bl 0x8250d508
	ctx.lr = 0x82A89934;
	sub_8250D508(ctx, base);
	// 82A89934: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A89938: 48368359  bl 0x82df1c90
	ctx.lr = 0x82A8993C;
	sub_82DF1C90(ctx, base);
	// 82A8993C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89940: 48369AE9  bl 0x82df3428
	ctx.lr = 0x82A89944;
	sub_82DF3428(ctx, base);
	// 82A89944: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A89948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8994C: 808BA080  lwz r4, -0x5f80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24448 as u32) ) } as u64;
	// 82A89950: 4836A0B9  bl 0x82df3a08
	ctx.lr = 0x82A89954;
	sub_82DF3A08(ctx, base);
	// 82A89954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A89958: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8995C: 48106E9D  bl 0x82b907f8
	ctx.lr = 0x82A89960;
	sub_82B907F8(ctx, base);
	// 82A89960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89964: 48369AC5  bl 0x82df3428
	ctx.lr = 0x82A89968;
	sub_82DF3428(ctx, base);
	// 82A89968: 3D6082A9  lis r11, -0x7d57
	ctx.r[11].s64 = -2102853632;
	// 82A8996C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A89970: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A89974: 396B93C0  addi r11, r11, -0x6c40
	ctx.r[11].s64 = ctx.r[11].s64 + -27712;
	// 82A89978: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A8997C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A89980: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A89984: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A89988: 4BFFFC41  bl 0x82a895c8
	ctx.lr = 0x82A8998C;
	sub_82A895C8(ctx, base);
	// 82A8998C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A89990: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89994: 48105E75  bl 0x82b8f808
	ctx.lr = 0x82A89998;
	sub_82B8F808(ctx, base);
	// 82A89998: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A8999C: 4B83F31D  bl 0x822c8cb8
	ctx.lr = 0x82A899A0;
	sub_822C8CB8(ctx, base);
	// 82A899A0: 2F1C0016  cmpwi cr6, r28, 0x16
	ctx.cr[6].compare_i32(ctx.r[28].s32, 22, &mut ctx.xer);
	// 82A899A4: 419A0010  beq cr6, 0x82a899b4
	if ctx.cr[6].eq {
	pc = 0x82A899B4; continue 'dispatch;
	}
	// 82A899A8: 2F1C002D  cmpwi cr6, r28, 0x2d
	ctx.cr[6].compare_i32(ctx.r[28].s32, 45, &mut ctx.xer);
	// 82A899AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A899B0: 409A0008  bne cr6, 0x82a899b8
	if !ctx.cr[6].eq {
	pc = 0x82A899B8; continue 'dispatch;
	}
	// 82A899B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A899B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A899BC: 48104CD5  bl 0x82b8e690
	ctx.lr = 0x82A899C0;
	sub_82B8E690(ctx, base);
	// 82A899C0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A899C4: 48105C2D  bl 0x82b8f5f0
	ctx.lr = 0x82A899C8;
	sub_82B8F5F0(ctx, base);
	// 82A899C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A899CC: 939D0030  stw r28, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[28].u32 ) };
	// 82A899D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A899D4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A899D8: D01D002C  stfs f0, 0x2c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A899DC: 483682B5  bl 0x82df1c90
	ctx.lr = 0x82A899E0;
	sub_82DF1C90(ctx, base);
	// 82A899E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A899E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A899E8: 4871E7CC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A899F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A899F0 size=724
    let mut pc: u32 = 0x82A899F0;
    'dispatch: loop {
        match pc {
            0x82A899F0 => {
    //   block [0x82A899F0..0x82A89CC4)
	// 82A899F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A899F4: 4871E775  bl 0x831a8168
	ctx.lr = 0x82A899F8;
	sub_831A8130(ctx, base);
	// 82A899F8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A899FC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89A00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A89A04: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A89A08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A89A0C: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82A89A10: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A89A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89A18: 419A025C  beq cr6, 0x82a89c74
	if ctx.cr[6].eq {
	pc = 0x82A89C74; continue 'dispatch;
	}
	// 82A89A1C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A89A20: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A89A24: 419A021C  beq cr6, 0x82a89c40
	if ctx.cr[6].eq {
	pc = 0x82A89C40; continue 'dispatch;
	}
	// 82A89A28: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82A89A2C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82A89A30: 3BCA9B20  addi r30, r10, -0x64e0
	ctx.r[30].s64 = ctx.r[10].s64 + -25824;
	// 82A89A34: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 82A89A38: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A89A3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A89A40: 41820114  beq 0x82a89b54
	if ctx.cr[0].eq {
	pc = 0x82A89B54; continue 'dispatch;
	}
	// 82A89A44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89A48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89A4C: 388B2964  addi r4, r11, 0x2964
	ctx.r[4].s64 = ctx.r[11].s64 + 10596;
	// 82A89A50: 48369FB9  bl 0x82df3a08
	ctx.lr = 0x82A89A54;
	sub_82DF3A08(ctx, base);
	// 82A89A54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A89A58: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A89A5C: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A89A60: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A89A64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A89A68: 481057F1  bl 0x82b8f258
	ctx.lr = 0x82A89A6C;
	sub_82B8F258(ctx, base);
	// 82A89A6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89A70: 483699B9  bl 0x82df3428
	ctx.lr = 0x82A89A74;
	sub_82DF3428(ctx, base);
	// 82A89A74: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A89A78: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A89A7C: 419A00D0  beq cr6, 0x82a89b4c
	if ctx.cr[6].eq {
	pc = 0x82A89B4C; continue 'dispatch;
	}
	// 82A89A80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A89A84: 48101DBD  bl 0x82b8b840
	ctx.lr = 0x82A89A88;
	sub_82B8B840(ctx, base);
	// 82A89A88: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A89A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89A90: 419A00AC  beq cr6, 0x82a89b3c
	if ctx.cr[6].eq {
	pc = 0x82A89B3C; continue 'dispatch;
	}
	// 82A89A94: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A89A98: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A89A9C: 48101DA5  bl 0x82b8b840
	ctx.lr = 0x82A89AA0;
	sub_82B8B840(ctx, base);
	// 82A89AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A89AA4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A89AA8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A89AAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89AB0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A89AB4: 4B83A9AD  bl 0x822c4460
	ctx.lr = 0x82A89AB8;
	sub_822C4460(ctx, base);
	// 82A89AB8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A89ABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89AC0: 419A0008  beq cr6, 0x82a89ac8
	if ctx.cr[6].eq {
	pc = 0x82A89AC8; continue 'dispatch;
	}
	// 82A89AC4: 4B836DCD  bl 0x822c0890
	ctx.lr = 0x82A89AC8;
	sub_822C0890(ctx, base);
	// 82A89AC8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A89ACC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A89AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89AD4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A89AD8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A89ADC: 419A0024  beq cr6, 0x82a89b00
	if ctx.cr[6].eq {
	pc = 0x82A89B00; continue 'dispatch;
	}
	// 82A89AE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A89AE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A89AE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A89AEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A89AF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A89AF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A89AF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A89AFC: 4082FFE8  bne 0x82a89ae4
	if !ctx.cr[0].eq {
	pc = 0x82A89AE4; continue 'dispatch;
	}
	// 82A89B00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89B04: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A89B08: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A89B0C: 4BD62ABD  bl 0x827ec5c8
	ctx.lr = 0x82A89B10;
	sub_827EC5C8(ctx, base);
	// 82A89B10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A89B14: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89B18: 4838B459  bl 0x82e14f70
	ctx.lr = 0x82A89B1C;
	sub_82E14F70(ctx, base);
	// 82A89B1C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A89B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89B24: 419A0008  beq cr6, 0x82a89b2c
	if ctx.cr[6].eq {
	pc = 0x82A89B2C; continue 'dispatch;
	}
	// 82A89B28: 4B836D69  bl 0x822c0890
	ctx.lr = 0x82A89B2C;
	sub_822C0890(ctx, base);
	// 82A89B2C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A89B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89B34: 419A0008  beq cr6, 0x82a89b3c
	if ctx.cr[6].eq {
	pc = 0x82A89B3C; continue 'dispatch;
	}
	// 82A89B38: 4B836D59  bl 0x822c0890
	ctx.lr = 0x82A89B3C;
	sub_822C0890(ctx, base);
	// 82A89B3C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A89B40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89B44: 419A0008  beq cr6, 0x82a89b4c
	if ctx.cr[6].eq {
	pc = 0x82A89B4C; continue 'dispatch;
	}
	// 82A89B48: 4B836D49  bl 0x822c0890
	ctx.lr = 0x82A89B4C;
	sub_822C0890(ctx, base);
	// 82A89B4C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A89B50: 480000A4  b 0x82a89bf4
	pc = 0x82A89BF4; continue 'dispatch;
	// 82A89B54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89B58: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82A89B5C: 4BD62675  bl 0x827ec1d0
	ctx.lr = 0x82A89B60;
	sub_827EC1D0(ctx, base);
	// 82A89B60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A89B64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A89B68: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A89B6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89B70: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A89B74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A89B78: 4E800421  bctrl
	ctx.lr = 0x82A89B7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A89B7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89B80: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A89B84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89B8C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A89B90: 419A0024  beq cr6, 0x82a89bb4
	if ctx.cr[6].eq {
	pc = 0x82A89BB4; continue 'dispatch;
	}
	// 82A89B94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A89B98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A89B9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A89BA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A89BA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A89BA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A89BAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A89BB0: 4082FFE8  bne 0x82a89b98
	if !ctx.cr[0].eq {
	pc = 0x82A89B98; continue 'dispatch;
	}
	// 82A89BB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89BB8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A89BBC: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A89BC0: 4BD62A09  bl 0x827ec5c8
	ctx.lr = 0x82A89BC4;
	sub_827EC5C8(ctx, base);
	// 82A89BC4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A89BC8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89BCC: 4838B3A5  bl 0x82e14f70
	ctx.lr = 0x82A89BD0;
	sub_82E14F70(ctx, base);
	// 82A89BD0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A89BD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89BD8: 419A0008  beq cr6, 0x82a89be0
	if ctx.cr[6].eq {
	pc = 0x82A89BE0; continue 'dispatch;
	}
	// 82A89BDC: 4B836CB5  bl 0x822c0890
	ctx.lr = 0x82A89BE0;
	sub_822C0890(ctx, base);
	// 82A89BE0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A89BE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89BE8: 419A0008  beq cr6, 0x82a89bf0
	if ctx.cr[6].eq {
	pc = 0x82A89BF0; continue 'dispatch;
	}
	// 82A89BEC: 4B836CA5  bl 0x822c0890
	ctx.lr = 0x82A89BF0;
	sub_822C0890(ctx, base);
	// 82A89BF0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A89BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89BF8: 419A0008  beq cr6, 0x82a89c00
	if ctx.cr[6].eq {
	pc = 0x82A89C00; continue 'dispatch;
	}
	// 82A89BFC: 4B836C95  bl 0x822c0890
	ctx.lr = 0x82A89C00;
	sub_822C0890(ctx, base);
	// 82A89C00: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A89C04: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 82A89C08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89C0C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82A89C10: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A89C14: 48369DF5  bl 0x82df3a08
	ctx.lr = 0x82A89C18;
	sub_82DF3A08(ctx, base);
	// 82A89C18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89C1C: 4BF892A5  bl 0x82a12ec0
	ctx.lr = 0x82A89C20;
	sub_82A12EC0(ctx, base);
	// 82A89C20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89C24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A89C28: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A89C2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A89C30: 4E800421  bctrl
	ctx.lr = 0x82A89C34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A89C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89C38: 483697F1  bl 0x82df3428
	ctx.lr = 0x82A89C3C;
	sub_82DF3428(ctx, base);
	// 82A89C3C: 939F0030  stw r28, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[28].u32 ) };
	// 82A89C40: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A89C44: 481048FD  bl 0x82b8e540
	ctx.lr = 0x82A89C48;
	sub_82B8E540(ctx, base);
	// 82A89C48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A89C4C: 40820028  bne 0x82a89c74
	if !ctx.cr[0].eq {
	pc = 0x82A89C74; continue 'dispatch;
	}
	// 82A89C50: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A89C54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A89C58: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A89C5C: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82A89C60: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A89C64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89C68: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82A89C6C: 419A0008  beq cr6, 0x82a89c74
	if ctx.cr[6].eq {
	pc = 0x82A89C74; continue 'dispatch;
	}
	// 82A89C70: 4B836C21  bl 0x822c0890
	ctx.lr = 0x82A89C74;
	sub_822C0890(ctx, base);
	// 82A89C74: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A89C78: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A89C7C: 419A003C  beq cr6, 0x82a89cb8
	if ctx.cr[6].eq {
	pc = 0x82A89CB8; continue 'dispatch;
	}
	// 82A89C80: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A89C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89C88: 409A0024  bne cr6, 0x82a89cac
	if !ctx.cr[6].eq {
	pc = 0x82A89CAC; continue 'dispatch;
	}
	// 82A89C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89C90: 4BFFFB51  bl 0x82a897e0
	ctx.lr = 0x82A89C94;
	sub_82A897E0(ctx, base);
	// 82A89C94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A89C98: 40820020  bne 0x82a89cb8
	if !ctx.cr[0].eq {
	pc = 0x82A89CB8; continue 'dispatch;
	}
	// 82A89C9C: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 82A89CA0: 93BF0024  stw r29, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
	// 82A89CA4: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82A89CA8: 48000010  b 0x82a89cb8
	pc = 0x82A89CB8; continue 'dispatch;
	// 82A89CAC: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A89CB0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A89CB4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A89CB8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A89CBC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A89CC0: 4871E4F8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A89CC8 size=8
    let mut pc: u32 = 0x82A89CC8;
    'dispatch: loop {
        match pc {
            0x82A89CC8 => {
    //   block [0x82A89CC8..0x82A89CD0)
	// 82A89CC8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A89CCC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A89CD0 size=8
    let mut pc: u32 = 0x82A89CD0;
    'dispatch: loop {
        match pc {
            0x82A89CD0 => {
    //   block [0x82A89CD0..0x82A89CD8)
	// 82A89CD0: 2F040015  cmpwi cr6, r4, 0x15
	ctx.cr[6].compare_i32(ctx.r[4].s32, 21, &mut ctx.xer);
	// 82A89CD4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A89CD8 size=36
    let mut pc: u32 = 0x82A89CD8;
    'dispatch: loop {
        match pc {
            0x82A89CD8 => {
    //   block [0x82A89CD8..0x82A89CFC)
	// 82A89CD8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A89CDC: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 82A89CE0: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A89CE4: 396B9AC8  addi r11, r11, -0x6538
	ctx.r[11].s64 = ctx.r[11].s64 + -25912;
	// 82A89CE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A89CEC: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 82A89CF0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A89CF4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82A89CF8: 4BFFFAE8  b 0x82a897e0
	sub_82A897E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89CFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A89CFC size=4
    let mut pc: u32 = 0x82A89CFC;
    'dispatch: loop {
        match pc {
            0x82A89CFC => {
    //   block [0x82A89CFC..0x82A89D00)
	// 82A89CFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A89D00 size=76
    let mut pc: u32 = 0x82A89D00;
    'dispatch: loop {
        match pc {
            0x82A89D00 => {
    //   block [0x82A89D00..0x82A89D4C)
	// 82A89D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89D04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89D08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89D0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89D10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89D14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A89D18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A89D1C: 483CF985  bl 0x82e596a0
	ctx.lr = 0x82A89D20;
	sub_82E596A0(ctx, base);
	// 82A89D20: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89D24: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A89D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89D2C: 396B2C78  addi r11, r11, 0x2c78
	ctx.r[11].s64 = ctx.r[11].s64 + 11384;
	// 82A89D30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A89D34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A89D38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A89D3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A89D40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A89D44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A89D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A89D50 size=76
    let mut pc: u32 = 0x82A89D50;
    'dispatch: loop {
        match pc {
            0x82A89D50 => {
    //   block [0x82A89D50..0x82A89D9C)
	// 82A89D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89D58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89D5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89D60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89D64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A89D68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A89D6C: 483CF915  bl 0x82e59680
	ctx.lr = 0x82A89D70;
	sub_82E59680(ctx, base);
	// 82A89D70: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89D74: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A89D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89D7C: 396B2C80  addi r11, r11, 0x2c80
	ctx.r[11].s64 = ctx.r[11].s64 + 11392;
	// 82A89D80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A89D84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A89D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A89D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A89D90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A89D94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A89D98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A89DA0 size=76
    let mut pc: u32 = 0x82A89DA0;
    'dispatch: loop {
        match pc {
            0x82A89DA0 => {
    //   block [0x82A89DA0..0x82A89DEC)
	// 82A89DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89DB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89DB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A89DB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A89DBC: 483CF8E5  bl 0x82e596a0
	ctx.lr = 0x82A89DC0;
	sub_82E596A0(ctx, base);
	// 82A89DC0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89DC4: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A89DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89DCC: 396B2C88  addi r11, r11, 0x2c88
	ctx.r[11].s64 = ctx.r[11].s64 + 11400;
	// 82A89DD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A89DD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A89DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A89DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A89DE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A89DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A89DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A89DF0 size=100
    let mut pc: u32 = 0x82A89DF0;
    'dispatch: loop {
        match pc {
            0x82A89DF0 => {
    //   block [0x82A89DF0..0x82A89E54)
	// 82A89DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89DF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89DFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89E00: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A89E04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A89E0C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A89E10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A89E14: 483CF86D  bl 0x82e59680
	ctx.lr = 0x82A89E18;
	sub_82E59680(ctx, base);
	// 82A89E18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89E1C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A89E20: 396B2C90  addi r11, r11, 0x2c90
	ctx.r[11].s64 = ctx.r[11].s64 + 11408;
	// 82A89E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89E28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A89E2C: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A89E58 size=128
    let mut pc: u32 = 0x82A89E58;
    'dispatch: loop {
        match pc {
            0x82A89E58 => {
    //   block [0x82A89E58..0x82A89ED8)
	// 82A89E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89E60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89E64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89E68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A89E70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A89E74: 483CF80D  bl 0x82e59680
	ctx.lr = 0x82A89E78;
	sub_82E59680(ctx, base);
	// 82A89E78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89E7C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A89E80: 392B2C98  addi r9, r11, 0x2c98
	ctx.r[9].s64 = ctx.r[11].s64 + 11416;
	// 82A89E84: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A89E88: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A89E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89E90: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89E94: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82A89E98: 13FE50C7  vcmpequd (lvx128) v31, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A89ED8 size=12
    let mut pc: u32 = 0x82A89ED8;
    'dispatch: loop {
        match pc {
            0x82A89ED8 => {
    //   block [0x82A89ED8..0x82A89EE4)
	// 82A89ED8: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A89EDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A89EE0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89EE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A89EE4 size=8
    let mut pc: u32 = 0x82A89EE4;
    'dispatch: loop {
        match pc {
            0x82A89EE4 => {
    //   block [0x82A89EE4..0x82A89EEC)
	// 82A89EE4: 4BD67ED4  b 0x827f1db8
	sub_827F1DB8(ctx, base);
	return;
	// 82A89EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A89EF0 size=196
    let mut pc: u32 = 0x82A89EF0;
    'dispatch: loop {
        match pc {
            0x82A89EF0 => {
    //   block [0x82A89EF0..0x82A89FB4)
	// 82A89EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89F04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A89F08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A89F0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A89F10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A89F14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A89F18: 4B836A21  bl 0x822c0938
	ctx.lr = 0x82A89F1C;
	sub_822C0938(ctx, base);
	// 82A89F1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A89F20: 41820028  beq 0x82a89f48
	if ctx.cr[0].eq {
	pc = 0x82A89F48; continue 'dispatch;
	}
	// 82A89F24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A89F28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A89F2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A89F30: 392B3900  addi r9, r11, 0x3900
	ctx.r[9].s64 = ctx.r[11].s64 + 14592;
	// 82A89F34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A89F38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A89F3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A89F40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A89F44: 48000008  b 0x82a89f4c
	pc = 0x82A89F4C; continue 'dispatch;
	// 82A89F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A89F4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A89F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89F54: 409A0044  bne cr6, 0x82a89f98
	if !ctx.cr[6].eq {
	pc = 0x82A89F98; continue 'dispatch;
	}
	// 82A89F58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A89F5C: 419A001C  beq cr6, 0x82a89f78
	if ctx.cr[6].eq {
	pc = 0x82A89F78; continue 'dispatch;
	}
	// 82A89F60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89F64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A89F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A89F6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A89F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A89F74: 4E800421  bctrl
	ctx.lr = 0x82A89F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A89F78: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A89F7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A89F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A89F84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A89F88: 816BB290  lwz r11, -0x4d70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19824 as u32) ) } as u64;
	// 82A89F8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A89F90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A89F94: 4B83606D  bl 0x822c0000
	ctx.lr = 0x82A89F98;
	sub_822C0000(ctx, base);
	// 82A89F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A89F9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A89FA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A89FA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A89FA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A89FAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A89FB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A89FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A89FB8 size=220
    let mut pc: u32 = 0x82A89FB8;
    'dispatch: loop {
        match pc {
            0x82A89FB8 => {
    //   block [0x82A89FB8..0x82A8A094)
	// 82A89FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A89FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A89FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A89FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A89FC8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A89FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A89FD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A89FD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A89FD8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A89FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A89FE0: 419A0098  beq cr6, 0x82a8a078
	if ctx.cr[6].eq {
	pc = 0x82A8A078; continue 'dispatch;
	}
	// 82A89FE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A89FE8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A89FEC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A89FF0: C00ACEE4  lfs f0, -0x311c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A89FF4: C1AB0028  lfs f13, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A89FF8: C1890018  lfs f12, 0x18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A89FFC: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A8A000: EC00687A  fmadds f0, f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A8A004: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82A8A008: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8A00C: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82A8A010: 4BA0DE09  bl 0x82497e18
	ctx.lr = 0x82A8A014;
	sub_82497E18(ctx, base);
	// 82A8A014: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8A018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8A01C: C02B0028  lfs f1, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A8A020: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8A024: 483F2965  bl 0x82e7c988
	ctx.lr = 0x82A8A028;
	sub_82E7C988(ctx, base);
	// 82A8A028: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8A02C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A8A030: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A8A034: 4B83A8CD  bl 0x822c4900
	ctx.lr = 0x82A8A038;
	sub_822C4900(ctx, base);
	// 82A8A038: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A8A03C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A8A040: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A8A044: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82A8A048: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A8A04C: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82A8A050: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8A054: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A8A058: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8A05C: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8A060: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8A098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A8A098 size=84
    let mut pc: u32 = 0x82A8A098;
    'dispatch: loop {
        match pc {
            0x82A8A098 => {
    //   block [0x82A8A098..0x82A8A0EC)
	// 82A8A098: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8A09C: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A8A0A0: 394BB1B0  addi r10, r11, -0x4e50
	ctx.r[10].s64 = ctx.r[11].s64 + -20048;
	// 82A8A0A4: 1D24001C  mulli r9, r4, 0x1c
	ctx.r[9].s64 = ctx.r[4].s64 * 28;
	// 82A8A0A8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A8A0AC: 39083920  addi r8, r8, 0x3920
	ctx.r[8].s64 = ctx.r[8].s64 + 14624;
	// 82A8A0B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8A0B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8A0B8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A8A0BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A8A0C0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A8A0C4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A8A0C8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A8A0CC: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A8A0D0: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A8A0D4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A8A0D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A8A0DC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A8A0E0: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A8A0E4: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82A8A0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8A0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8A0F0 size=196
    let mut pc: u32 = 0x82A8A0F0;
    'dispatch: loop {
        match pc {
            0x82A8A0F0 => {
    //   block [0x82A8A0F0..0x82A8A1B4)
	// 82A8A0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8A0F4: 4871E079  bl 0x831a816c
	ctx.lr = 0x82A8A0F8;
	sub_831A8130(ctx, base);
	// 82A8A0F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8A0FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8A100: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8A104: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 82A8A108: 396B3920  addi r11, r11, 0x3920
	ctx.r[11].s64 = ctx.r[11].s64 + 14624;
	// 82A8A10C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8A110: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A8A114: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A8A118: 48388429  bl 0x82e12540
	ctx.lr = 0x82A8A11C;
	sub_82E12540(ctx, base);
	// 82A8A11C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A8A120: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A8A124: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A8A128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A12C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82A8A130: 419A0008  beq cr6, 0x82a8a138
	if ctx.cr[6].eq {
	pc = 0x82A8A138; continue 'dispatch;
	}
	// 82A8A134: 4B83675D  bl 0x822c0890
	ctx.lr = 0x82A8A138;
	sub_822C0890(ctx, base);
	// 82A8A138: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A8A13C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A8A140: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8A144: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A148: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A8A14C: 419A0008  beq cr6, 0x82a8a154
	if ctx.cr[6].eq {
	pc = 0x82A8A154; continue 'dispatch;
	}
	// 82A8A150: 4B836741  bl 0x822c0890
	ctx.lr = 0x82A8A154;
	sub_822C0890(ctx, base);
	// 82A8A154: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A8A158: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A8A15C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A160: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82A8A164: 419A0008  beq cr6, 0x82a8a16c
	if ctx.cr[6].eq {
	pc = 0x82A8A16C; continue 'dispatch;
	}
	// 82A8A168: 4B836729  bl 0x822c0890
	ctx.lr = 0x82A8A16C;
	sub_822C0890(ctx, base);
	// 82A8A16C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A8A170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A174: 419A0008  beq cr6, 0x82a8a17c
	if ctx.cr[6].eq {
	pc = 0x82A8A17C; continue 'dispatch;
	}
	// 82A8A178: 4B836719  bl 0x822c0890
	ctx.lr = 0x82A8A17C;
	sub_822C0890(ctx, base);
	// 82A8A17C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A8A180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A184: 419A0008  beq cr6, 0x82a8a18c
	if ctx.cr[6].eq {
	pc = 0x82A8A18C; continue 'dispatch;
	}
	// 82A8A188: 4B836709  bl 0x822c0890
	ctx.lr = 0x82A8A18C;
	sub_822C0890(ctx, base);
	// 82A8A18C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A8A190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A194: 419A0008  beq cr6, 0x82a8a19c
	if ctx.cr[6].eq {
	pc = 0x82A8A19C; continue 'dispatch;
	}
	// 82A8A198: 4B8366F9  bl 0x822c0890
	ctx.lr = 0x82A8A19C;
	sub_822C0890(ctx, base);
	// 82A8A19C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8A1A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A1A4: 419A0008  beq cr6, 0x82a8a1ac
	if ctx.cr[6].eq {
	pc = 0x82A8A1AC; continue 'dispatch;
	}
	// 82A8A1A8: 4B8366E9  bl 0x822c0890
	ctx.lr = 0x82A8A1AC;
	sub_822C0890(ctx, base);
	// 82A8A1AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8A1B0: 4871E00C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8A1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8A1B8 size=112
    let mut pc: u32 = 0x82A8A1B8;
    'dispatch: loop {
        match pc {
            0x82A8A1B8 => {
    //   block [0x82A8A1B8..0x82A8A228)
	// 82A8A1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8A1BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8A1C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8A1C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8A1C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8A1CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8A1D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8A1D4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A8A1D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8A1DC: 4BFFFD15  bl 0x82a89ef0
	ctx.lr = 0x82A8A1E0;
	sub_82A89EF0(ctx, base);
	// 82A8A1E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A8A1E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A8A1E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8A1EC: 4B835E15  bl 0x822c0000
	ctx.lr = 0x82A8A1F0;
	sub_822C0000(ctx, base);
	// 82A8A1F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8A1F4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A8A1F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8A1FC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8A200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A204: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8A208: 419A0008  beq cr6, 0x82a8a210
	if ctx.cr[6].eq {
	pc = 0x82A8A210; continue 'dispatch;
	}
	// 82A8A20C: 4B836685  bl 0x822c0890
	ctx.lr = 0x82A8A210;
	sub_822C0890(ctx, base);
	// 82A8A210: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8A214: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8A218: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8A21C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8A220: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8A224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8A228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A8A228 size=332
    let mut pc: u32 = 0x82A8A228;
    'dispatch: loop {
        match pc {
            0x82A8A228 => {
    //   block [0x82A8A228..0x82A8A374)
	// 82A8A228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8A22C: 4871DF39  bl 0x831a8164
	ctx.lr = 0x82A8A230;
	sub_831A8130(ctx, base);
	// 82A8A230: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82A8A234: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82A8A238: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A8A23C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8A240: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8A244: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A8A248: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8A24C: 388B394C  addi r4, r11, 0x394c
	ctx.r[4].s64 = ctx.r[11].s64 + 14668;
	// 82A8A250: 483697B9  bl 0x82df3a08
	ctx.lr = 0x82A8A254;
	sub_82DF3A08(ctx, base);
	// 82A8A254: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8A258: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8A25C: 388B393C  addi r4, r11, 0x393c
	ctx.r[4].s64 = ctx.r[11].s64 + 14652;
	// 82A8A260: 483697A9  bl 0x82df3a08
	ctx.lr = 0x82A8A264;
	sub_82DF3A08(ctx, base);
	// 82A8A264: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A8A268: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8A26C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A270: 4BB40291  bl 0x825ca500
	ctx.lr = 0x82A8A274;
	sub_825CA500(ctx, base);
	// 82A8A274: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A8A278: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8A27C: 483691AD  bl 0x82df3428
	ctx.lr = 0x82A8A280;
	sub_82DF3428(ctx, base);
	// 82A8A280: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8A284: 483691A5  bl 0x82df3428
	ctx.lr = 0x82A8A288;
	sub_82DF3428(ctx, base);
	// 82A8A288: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8A28C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A8A290: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82A8A294: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A8A298: 3BCBB1B0  addi r30, r11, -0x4e50
	ctx.r[30].s64 = ctx.r[11].s64 + -20048;
	// 82A8A29C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8A2A0: C3AA08A8  lfs f29, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A8A2A4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A8A2A8: C3C966D4  lfs f30, 0x66d4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26324 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A8A2AC: 3B6B3924  addi r27, r11, 0x3924
	ctx.r[27].s64 = ctx.r[11].s64 + 14628;
	// 82A8A2B0: C3E83938  lfs f31, 0x3938(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(14648 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A8A2B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8A2B8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A2BC: 4836974D  bl 0x82df3a08
	ctx.lr = 0x82A8A2C0;
	sub_82DF3A08(ctx, base);
	// 82A8A2C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A8A2C4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A8A2C8: 48369741  bl 0x82df3a08
	ctx.lr = 0x82A8A2CC;
	sub_82DF3A08(ctx, base);
	// 82A8A2CC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A8A2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8A2D4: 483695DD  bl 0x82df38b0
	ctx.lr = 0x82A8A2D8;
	sub_82DF38B0(ctx, base);
	// 82A8A2D8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A8A2DC: 4836914D  bl 0x82df3428
	ctx.lr = 0x82A8A2E0;
	sub_82DF3428(ctx, base);
	// 82A8A2E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8A2E4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A2E8: 48369721  bl 0x82df3a08
	ctx.lr = 0x82A8A2EC;
	sub_82DF3A08(ctx, base);
	// 82A8A2EC: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 82A8A2F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8A2F4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82A8A2F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A8A2FC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A8A300: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8A304: 4BB18FA5  bl 0x825a32a8
	ctx.lr = 0x82A8A308;
	sub_825A32A8(ctx, base);
	// 82A8A308: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8A30C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A8A310: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A8A314: 4BB1745D  bl 0x825a1770
	ctx.lr = 0x82A8A318;
	sub_825A1770(ctx, base);
	// 82A8A318: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A8A31C: 4836910D  bl 0x82df3428
	ctx.lr = 0x82A8A320;
	sub_82DF3428(ctx, base);
	// 82A8A320: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A8A324: 4B83E995  bl 0x822c8cb8
	ctx.lr = 0x82A8A328;
	sub_822C8CB8(ctx, base);
	// 82A8A328: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8A32C: 483690FD  bl 0x82df3428
	ctx.lr = 0x82A8A330;
	sub_82DF3428(ctx, base);
	// 82A8A330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8A334: 483690F5  bl 0x82df3428
	ctx.lr = 0x82A8A338;
	sub_82DF3428(ctx, base);
	// 82A8A338: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A8A33C: 397E00E0  addi r11, r30, 0xe0
	ctx.r[11].s64 = ctx.r[30].s64 + 224;
	// 82A8A340: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A8A344: 4198FF70  blt cr6, 0x82a8a2b4
	if ctx.cr[6].lt {
	pc = 0x82A8A2B4; continue 'dispatch;
	}
	// 82A8A348: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A34C: 4BB3F985  bl 0x825c9cd0
	ctx.lr = 0x82A8A350;
	sub_825C9CD0(ctx, base);
	// 82A8A350: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8A354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A358: 419A0008  beq cr6, 0x82a8a360
	if ctx.cr[6].eq {
	pc = 0x82A8A360; continue 'dispatch;
	}
	// 82A8A35C: 4B836535  bl 0x822c0890
	ctx.lr = 0x82A8A360;
	sub_822C0890(ctx, base);
	// 82A8A360: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A8A364: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A8A368: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A8A36C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A8A370: 4871DE44  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8A378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8A378 size=76
    let mut pc: u32 = 0x82A8A378;
    'dispatch: loop {
        match pc {
            0x82A8A378 => {
    //   block [0x82A8A378..0x82A8A3C4)
	// 82A8A378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8A37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8A380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8A384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8A388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8A38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8A390: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8A394: 4BFFFD5D  bl 0x82a8a0f0
	ctx.lr = 0x82A8A398;
	sub_82A8A0F0(ctx, base);
	// 82A8A398: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8A39C: 4182000C  beq 0x82a8a3a8
	if ctx.cr[0].eq {
	pc = 0x82A8A3A8; continue 'dispatch;
	}
	// 82A8A3A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8A3A4: 4B835EC5  bl 0x822c0268
	ctx.lr = 0x82A8A3A8;
	sub_822C0268(ctx, base);
	// 82A8A3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8A3AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8A3B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8A3B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8A3B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8A3BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8A3C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8A3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A8A3C8 size=1496
    let mut pc: u32 = 0x82A8A3C8;
    'dispatch: loop {
        match pc {
            0x82A8A3C8 => {
    //   block [0x82A8A3C8..0x82A8A9A0)
	// 82A8A3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8A3CC: 4871DD8D  bl 0x831a8158
	ctx.lr = 0x82A8A3D0;
	sub_831A8130(ctx, base);
	// 82A8A3D0: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8A3D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A8A3D8: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82A8A3DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A8A3E0: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82A8A3E4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A8A3E8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8A3EC: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82A8A3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8A3F4: 419A00B4  beq cr6, 0x82a8a4a8
	if ctx.cr[6].eq {
	pc = 0x82A8A4A8; continue 'dispatch;
	}
	// 82A8A3F8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A8A3FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8A400: 419A007C  beq cr6, 0x82a8a47c
	if ctx.cr[6].eq {
	pc = 0x82A8A47C; continue 'dispatch;
	}
	// 82A8A404: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8A408: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8A410: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A8A414: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82A8A418: 419A0024  beq cr6, 0x82a8a43c
	if ctx.cr[6].eq {
	pc = 0x82A8A43C; continue 'dispatch;
	}
	// 82A8A41C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A8A420: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A8A424: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8A428: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8A42C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A8A430: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A8A434: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8A438: 4082FFE8  bne 0x82a8a420
	if !ctx.cr[0].eq {
	pc = 0x82A8A420; continue 'dispatch;
	}
	// 82A8A43C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A8A440: 809B7058  lwz r4, 0x7058(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A8A444: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82A8A448: 38790010  addi r3, r25, 0x10
	ctx.r[3].s64 = ctx.r[25].s64 + 16;
	// 82A8A44C: 4BA85C75  bl 0x825100c0
	ctx.lr = 0x82A8A450;
	sub_825100C0(ctx, base);
	// 82A8A450: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A8A454: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A458: 419A0008  beq cr6, 0x82a8a460
	if ctx.cr[6].eq {
	pc = 0x82A8A460; continue 'dispatch;
	}
	// 82A8A45C: 4B836435  bl 0x822c0890
	ctx.lr = 0x82A8A460;
	sub_822C0890(ctx, base);
	// 82A8A460: 935E0010  stw r26, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 82A8A464: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A8A468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A46C: 935E0014  stw r26, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82A8A470: 419A0020  beq cr6, 0x82a8a490
	if ctx.cr[6].eq {
	pc = 0x82A8A490; continue 'dispatch;
	}
	// 82A8A474: 4B83641D  bl 0x822c0890
	ctx.lr = 0x82A8A478;
	sub_822C0890(ctx, base);
	// 82A8A478: 48000018  b 0x82a8a490
	pc = 0x82A8A490; continue 'dispatch;
	// 82A8A47C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A8A480: 809B7058  lwz r4, 0x7058(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A8A484: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A8A488: 38790010  addi r3, r25, 0x10
	ctx.r[3].s64 = ctx.r[25].s64 + 16;
	// 82A8A48C: 4BA85D65  bl 0x825101f0
	ctx.lr = 0x82A8A490;
	sub_825101F0(ctx, base);
	// 82A8A490: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A8A494: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8A498: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A8A49C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8A4A0: 419A0008  beq cr6, 0x82a8a4a8
	if ctx.cr[6].eq {
	pc = 0x82A8A4A8; continue 'dispatch;
	}
	// 82A8A4A4: 4B8363ED  bl 0x822c0890
	ctx.lr = 0x82A8A4A8;
	sub_822C0890(ctx, base);
	// 82A8A4A8: 3B990010  addi r28, r25, 0x10
	ctx.r[28].s64 = ctx.r[25].s64 + 16;
	// 82A8A4AC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A8A4B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A8A4B4: 4BA85015  bl 0x8250f4c8
	ctx.lr = 0x82A8A4B8;
	sub_8250F4C8(ctx, base);
	// 82A8A4B8: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A8A4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8A4C0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A8A4C4: 409A0008  bne cr6, 0x82a8a4cc
	if !ctx.cr[6].eq {
	pc = 0x82A8A4CC; continue 'dispatch;
	}
	// 82A8A4C8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A8A4CC: 4BA7E05D  bl 0x82508528
	ctx.lr = 0x82A8A4D0;
	sub_82508528(ctx, base);
	// 82A8A4D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8A4D4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A8A4D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A4DC: 483A060D  bl 0x82e2aae8
	ctx.lr = 0x82A8A4E0;
	sub_82E2AAE8(ctx, base);
	// 82A8A4E0: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 82A8A4E4: 419803C0  blt cr6, 0x82a8a8a4
	if ctx.cr[6].lt {
	pc = 0x82A8A8A4; continue 'dispatch;
	}
	// 82A8A4E8: 419A02D8  beq cr6, 0x82a8a7c0
	if ctx.cr[6].eq {
	pc = 0x82A8A7C0; continue 'dispatch;
	}
	// 82A8A4EC: 2B1D0003  cmplwi cr6, r29, 3
	ctx.cr[6].compare_u32(ctx.r[29].u32, 3 as u32, &mut ctx.xer);
	// 82A8A4F0: 40980498  bge cr6, 0x82a8a988
	if !ctx.cr[6].lt {
	pc = 0x82A8A988; continue 'dispatch;
	}
	// 82A8A4F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8A4F8: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8A4FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A8A500: 419A0488  beq cr6, 0x82a8a988
	if ctx.cr[6].eq {
	pc = 0x82A8A988; continue 'dispatch;
	}
	// 82A8A504: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8A508: 48369501  bl 0x82df3a08
	ctx.lr = 0x82A8A50C;
	sub_82DF3A08(ctx, base);
	// 82A8A50C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A8A510: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A8A514: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A8A518: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A8A51C: 483A4955  bl 0x82e2ee70
	ctx.lr = 0x82A8A520;
	sub_82E2EE70(ctx, base);
	// 82A8A520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8A524: 48368F05  bl 0x82df3428
	ctx.lr = 0x82A8A528;
	sub_82DF3428(ctx, base);
	// 82A8A528: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8A52C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A8A530: 3BAB3970  addi r29, r11, 0x3970
	ctx.r[29].s64 = ctx.r[11].s64 + 14704;
	// 82A8A534: 38A000D9  li r5, 0xd9
	ctx.r[5].s64 = 217;
	// 82A8A538: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A8A53C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A8A540: 48367EA9  bl 0x82df23e8
	ctx.lr = 0x82A8A544;
	sub_82DF23E8(ctx, base);
	// 82A8A544: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8A548: 41820014  beq 0x82a8a55c
	if ctx.cr[0].eq {
	pc = 0x82A8A55C; continue 'dispatch;
	}
	// 82A8A54C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82A8A550: 4838C341  bl 0x82e16890
	ctx.lr = 0x82A8A554;
	sub_82E16890(ctx, base);
	// 82A8A554: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A8A558: 48000008  b 0x82a8a560
	pc = 0x82A8A560; continue 'dispatch;
	// 82A8A55C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A8A560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8A564: 4B8D2E0D  bl 0x8235d370
	ctx.lr = 0x82A8A568;
	sub_8235D370(ctx, base);
	// 82A8A568: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A8A56C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A570: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8A574: 831F0000  lwz r24, 0(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A578: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A8A57C: 4E800421  bctrl
	ctx.lr = 0x82A8A580;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A8A580: 80F80084  lwz r7, 0x84(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A8A584: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A8A588: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82A8A58C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A8A590: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82A8A594: 39070010  addi r8, r7, 0x10
	ctx.r[8].s64 = ctx.r[7].s64 + 16;
	// 82A8A598: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8A59C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82A8A5A0: 13C93407  vcmpneb. (lvlx128) v30, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8A5A4: 13AA3407  vcmpneb. (lvlx128) v29, v10, v6
	tmp.u32 = ctx.r[10].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A8A5A8: 138B3407  vcmpneb. (lvlx128) v28, v11, v6
	tmp.u32 = ctx.r[11].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8A9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8A9A0 size=248
    let mut pc: u32 = 0x82A8A9A0;
    'dispatch: loop {
        match pc {
            0x82A8A9A0 => {
    //   block [0x82A8A9A0..0x82A8AA98)
	// 82A8A9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8A9A4: 4871D7C9  bl 0x831a816c
	ctx.lr = 0x82A8A9A8;
	sub_831A8130(ctx, base);
	// 82A8A9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8A9AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8A9B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8A9B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A8A9B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8A9BC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A9C0: 48369049  bl 0x82df3a08
	ctx.lr = 0x82A8A9C4;
	sub_82DF3A08(ctx, base);
	// 82A8A9C4: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 82A8A9C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8A9CC: 4BD61BFD  bl 0x827ec5c8
	ctx.lr = 0x82A8A9D0;
	sub_827EC5C8(ctx, base);
	// 82A8A9D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8A9D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A8A9D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8A9DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A9E0: 4838A651  bl 0x82e15030
	ctx.lr = 0x82A8A9E4;
	sub_82E15030(ctx, base);
	// 82A8A9E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8A9E8: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 82A8A9EC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A8A9F0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A8A9F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8A9F8: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A8A9FC: 4B839A65  bl 0x822c4460
	ctx.lr = 0x82A8AA00;
	sub_822C4460(ctx, base);
	// 82A8AA00: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A8AA04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8AA08: 419A0008  beq cr6, 0x82a8aa10
	if ctx.cr[6].eq {
	pc = 0x82A8AA10; continue 'dispatch;
	}
	// 82A8AA0C: 4B835E85  bl 0x822c0890
	ctx.lr = 0x82A8AA10;
	sub_822C0890(ctx, base);
	// 82A8AA10: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A8AA14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8AA18: 419A0008  beq cr6, 0x82a8aa20
	if ctx.cr[6].eq {
	pc = 0x82A8AA20; continue 'dispatch;
	}
	// 82A8AA1C: 4B835E75  bl 0x822c0890
	ctx.lr = 0x82A8AA20;
	sub_822C0890(ctx, base);
	// 82A8AA20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AA24: 48368A05  bl 0x82df3428
	ctx.lr = 0x82A8AA28;
	sub_82DF3428(ctx, base);
	// 82A8AA28: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AA2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A8AA30: 388B3970  addi r4, r11, 0x3970
	ctx.r[4].s64 = ctx.r[11].s64 + 14704;
	// 82A8AA34: 38A00099  li r5, 0x99
	ctx.r[5].s64 = 153;
	// 82A8AA38: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A8AA3C: 483679AD  bl 0x82df23e8
	ctx.lr = 0x82A8AA40;
	sub_82DF23E8(ctx, base);
	// 82A8AA40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8AA44: 41820024  beq 0x82a8aa68
	if ctx.cr[0].eq {
	pc = 0x82A8AA68; continue 'dispatch;
	}
	// 82A8AA48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AA4C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82A8AA50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A8AA54: 396B3914  addi r11, r11, 0x3914
	ctx.r[11].s64 = ctx.r[11].s64 + 14612;
	// 82A8AA58: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8AA5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A8AA60: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8AA64: 48000008  b 0x82a8aa6c
	pc = 0x82A8AA6C; continue 'dispatch;
	// 82A8AA68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A8AA6C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82A8AA70: 4BFFF749  bl 0x82a8a1b8
	ctx.lr = 0x82A8AA74;
	sub_82A8A1B8(ctx, base);
	// 82A8AA74: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A8AA78: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8AA7C: 48388045  bl 0x82e12ac0
	ctx.lr = 0x82A8AA80;
	sub_82E12AC0(ctx, base);
	// 82A8AA80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A8AA84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A8AA88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8AA8C: 4BFFF93D  bl 0x82a8a3c8
	ctx.lr = 0x82A8AA90;
	sub_82A8A3C8(ctx, base);
	// 82A8AA90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A8AA94: 4871D728  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8AA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A8AA98 size=196
    let mut pc: u32 = 0x82A8AA98;
    'dispatch: loop {
        match pc {
            0x82A8AA98 => {
    //   block [0x82A8AA98..0x82A8AB5C)
	// 82A8AA98: DBE1FFF8  stfd f31, -8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 82A8AA9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AAA0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82A8AAA4: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 82A8AAA8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A8AAAC: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82A8AAB0: C1AB39C0  lfs f13, 0x39c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14784 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A8AAB4: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82A8AAB8: C18ADD6C  lfs f12, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A8AABC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A8AAC0: C1697BC4  lfs f11, 0x7bc4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A8AAC4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A8AAC8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A8AACC: C148D5B8  lfs f10, -0x2a48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A8AAD0: C0076150  lfs f0, 0x6150(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A8AAD4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A8AAD8: C1269524  lfs f9, -0x6adc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A8AADC: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 82A8AAE0: C10B093C  lfs f8, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A8AAE4: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82A8AAE8: C0EAACFC  lfs f7, -0x5304(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A8AAEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A8AAF0: C0C9A9F0  lfs f6, -0x5610(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A8AAF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A8AAF8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A8AAFC: C0A8C664  lfs f5, -0x399c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82A8AB00: C0872D48  lfs f4, 0x2d48(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(11592 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82A8AB04: C06639BC  lfs f3, 0x39bc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(14780 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A8AB08: C04B08A8  lfs f2, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A8AB0C: C02ADF2C  lfs f1, -0x20d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8404 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A8AB10: C3E9C5F0  lfs f31, -0x3a10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A8AB14: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A8AB18: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A8AB1C: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A8AB20: D143000C  stfs f10, 0xc(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A8AB24: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A8AB28: D1230014  stfs f9, 0x14(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A8AB2C: D1030018  stfs f8, 0x18(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A8AB30: D0E3001C  stfs f7, 0x1c(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A8AB34: D0C30020  stfs f6, 0x20(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A8AB38: D0A30024  stfs f5, 0x24(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A8AB3C: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82A8AB40: D083002C  stfs f4, 0x2c(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A8AB44: D0630030  stfs f3, 0x30(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82A8AB48: D0430034  stfs f2, 0x34(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82A8AB4C: D0230038  stfs f1, 0x38(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82A8AB50: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82A8AB54: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82A8AB58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8AB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A8AB60 size=1924
    let mut pc: u32 = 0x82A8AB60;
    'dispatch: loop {
        match pc {
            0x82A8AB60 => {
    //   block [0x82A8AB60..0x82A8B2E4)
	// 82A8AB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8AB64: 4871D609  bl 0x831a816c
	ctx.lr = 0x82A8AB68;
	sub_831A8130(ctx, base);
	// 82A8AB68: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82A8AB6C: 4871DF0D  bl 0x831a8a78
	ctx.lr = 0x82A8AB70;
	sub_831A8A40(ctx, base);
	// 82A8AB70: 9421FB60  stwu r1, -0x4a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1184 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8AB74: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A8AB78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8AB7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8AB80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8AB84: 388B1F3C  addi r4, r11, 0x1f3c
	ctx.r[4].s64 = ctx.r[11].s64 + 7996;
	// 82A8AB88: 48368E81  bl 0x82df3a08
	ctx.lr = 0x82A8AB8C;
	sub_82DF3A08(ctx, base);
	// 82A8AB8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A8AB90: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A8AB94: 388B1F2C  addi r4, r11, 0x1f2c
	ctx.r[4].s64 = ctx.r[11].s64 + 7980;
	// 82A8AB98: 48368E71  bl 0x82df3a08
	ctx.lr = 0x82A8AB9C;
	sub_82DF3A08(ctx, base);
	// 82A8AB9C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A8ABA0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A8ABA4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8ABA8: 4BB3F959  bl 0x825ca500
	ctx.lr = 0x82A8ABAC;
	sub_825CA500(ctx, base);
	// 82A8ABAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A8ABB0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A8ABB4: 48368875  bl 0x82df3428
	ctx.lr = 0x82A8ABB8;
	sub_82DF3428(ctx, base);
	// 82A8ABB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A8ABBC: 4836886D  bl 0x82df3428
	ctx.lr = 0x82A8ABC0;
	sub_82DF3428(ctx, base);
	// 82A8ABC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A8ABC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8ABC8: 388B03DC  addi r4, r11, 0x3dc
	ctx.r[4].s64 = ctx.r[11].s64 + 988;
	// 82A8ABCC: 48368E3D  bl 0x82df3a08
	ctx.lr = 0x82A8ABD0;
	sub_82DF3A08(ctx, base);
	// 82A8ABD0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82A8ABD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8ABD8: 388B0F60  addi r4, r11, 0xf60
	ctx.r[4].s64 = ctx.r[11].s64 + 3936;
	// 82A8ABDC: 48368E2D  bl 0x82df3a08
	ctx.lr = 0x82A8ABE0;
	sub_82DF3A08(ctx, base);
	// 82A8ABE0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A8ABE4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A8ABE8: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82A8ABEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A8ABF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8ABF4: C3AB89AC  lfs f29, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A8ABF8: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 82A8ABFC: C389964C  lfs f28, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A8AC00: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82A8AC04: C04AC350  lfs f2, -0x3cb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A8AC08: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82A8AC0C: 4BB1869D  bl 0x825a32a8
	ctx.lr = 0x82A8AC10;
	sub_825A32A8(ctx, base);
	// 82A8AC10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AC14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AC18: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AC1C: 4BB16B55  bl 0x825a1770
	ctx.lr = 0x82A8AC20;
	sub_825A1770(ctx, base);
	// 82A8AC20: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 82A8AC24: 48368805  bl 0x82df3428
	ctx.lr = 0x82A8AC28;
	sub_82DF3428(ctx, base);
	// 82A8AC28: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 82A8AC2C: 4B83E08D  bl 0x822c8cb8
	ctx.lr = 0x82A8AC30;
	sub_822C8CB8(ctx, base);
	// 82A8AC30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AC34: 483687F5  bl 0x82df3428
	ctx.lr = 0x82A8AC38;
	sub_82DF3428(ctx, base);
	// 82A8AC38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AC3C: 483687ED  bl 0x82df3428
	ctx.lr = 0x82A8AC40;
	sub_82DF3428(ctx, base);
	// 82A8AC40: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AC44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AC48: 388B3CA8  addi r4, r11, 0x3ca8
	ctx.r[4].s64 = ctx.r[11].s64 + 15528;
	// 82A8AC4C: 48368DBD  bl 0x82df3a08
	ctx.lr = 0x82A8AC50;
	sub_82DF3A08(ctx, base);
	// 82A8AC50: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AC54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AC58: 388B3C94  addi r4, r11, 0x3c94
	ctx.r[4].s64 = ctx.r[11].s64 + 15508;
	// 82A8AC5C: 48368DAD  bl 0x82df3a08
	ctx.lr = 0x82A8AC60;
	sub_82DF3A08(ctx, base);
	// 82A8AC60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A8AC64: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82A8AC68: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82A8AC6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AC70: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A8AC74: C3CB08A8  lfs f30, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A8AC78: C04A9A8C  lfs f2, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A8AC7C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A8AC80: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A8AC84: 4BB18625  bl 0x825a32a8
	ctx.lr = 0x82A8AC88;
	sub_825A32A8(ctx, base);
	// 82A8AC88: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AC8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8AC90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AC94: 4BB16ADD  bl 0x825a1770
	ctx.lr = 0x82A8AC98;
	sub_825A1770(ctx, base);
	// 82A8AC98: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82A8AC9C: 4836878D  bl 0x82df3428
	ctx.lr = 0x82A8ACA0;
	sub_82DF3428(ctx, base);
	// 82A8ACA0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A8ACA4: 4B83E015  bl 0x822c8cb8
	ctx.lr = 0x82A8ACA8;
	sub_822C8CB8(ctx, base);
	// 82A8ACA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8ACAC: 4836877D  bl 0x82df3428
	ctx.lr = 0x82A8ACB0;
	sub_82DF3428(ctx, base);
	// 82A8ACB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8ACB4: 48368775  bl 0x82df3428
	ctx.lr = 0x82A8ACB8;
	sub_82DF3428(ctx, base);
	// 82A8ACB8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8ACBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8ACC0: 388B3C78  addi r4, r11, 0x3c78
	ctx.r[4].s64 = ctx.r[11].s64 + 15480;
	// 82A8ACC4: 48368D45  bl 0x82df3a08
	ctx.lr = 0x82A8ACC8;
	sub_82DF3A08(ctx, base);
	// 82A8ACC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8ACCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8ACD0: 388B3C5C  addi r4, r11, 0x3c5c
	ctx.r[4].s64 = ctx.r[11].s64 + 15452;
	// 82A8ACD4: 48368D35  bl 0x82df3a08
	ctx.lr = 0x82A8ACD8;
	sub_82DF3A08(ctx, base);
	// 82A8ACD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A8ACDC: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82A8ACE0: FC40E890  fmr f2, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8ACE4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8ACE8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A8ACEC: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 82A8ACF0: C3EB9528  lfs f31, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A8ACF4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8ACF8: 4BB185B1  bl 0x825a32a8
	ctx.lr = 0x82A8ACFC;
	sub_825A32A8(ctx, base);
	// 82A8ACFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AD00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AD04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8AD08: 4BB16A69  bl 0x825a1770
	ctx.lr = 0x82A8AD0C;
	sub_825A1770(ctx, base);
	// 82A8AD0C: 38610398  addi r3, r1, 0x398
	ctx.r[3].s64 = ctx.r[1].s64 + 920;
	// 82A8AD10: 48368719  bl 0x82df3428
	ctx.lr = 0x82A8AD14;
	sub_82DF3428(ctx, base);
	// 82A8AD14: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 82A8AD18: 4B83DFA1  bl 0x822c8cb8
	ctx.lr = 0x82A8AD1C;
	sub_822C8CB8(ctx, base);
	// 82A8AD1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AD20: 48368709  bl 0x82df3428
	ctx.lr = 0x82A8AD24;
	sub_82DF3428(ctx, base);
	// 82A8AD24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AD28: 48368701  bl 0x82df3428
	ctx.lr = 0x82A8AD2C;
	sub_82DF3428(ctx, base);
	// 82A8AD2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AD30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AD34: 388B3C38  addi r4, r11, 0x3c38
	ctx.r[4].s64 = ctx.r[11].s64 + 15416;
	// 82A8AD38: 48368CD1  bl 0x82df3a08
	ctx.lr = 0x82A8AD3C;
	sub_82DF3A08(ctx, base);
	// 82A8AD3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AD40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AD44: 388B3C20  addi r4, r11, 0x3c20
	ctx.r[4].s64 = ctx.r[11].s64 + 15392;
	// 82A8AD48: 48368CC1  bl 0x82df3a08
	ctx.lr = 0x82A8AD4C;
	sub_82DF3A08(ctx, base);
	// 82A8AD4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A8AD50: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82A8AD54: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8AD58: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AD5C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A8AD60: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82A8AD64: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A8AD68: 4BB18541  bl 0x825a32a8
	ctx.lr = 0x82A8AD6C;
	sub_825A32A8(ctx, base);
	// 82A8AD6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AD70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AD74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8AD78: 4BB169F9  bl 0x825a1770
	ctx.lr = 0x82A8AD7C;
	sub_825A1770(ctx, base);
	// 82A8AD7C: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 82A8AD80: 483686A9  bl 0x82df3428
	ctx.lr = 0x82A8AD84;
	sub_82DF3428(ctx, base);
	// 82A8AD84: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 82A8AD88: 4B83DF31  bl 0x822c8cb8
	ctx.lr = 0x82A8AD8C;
	sub_822C8CB8(ctx, base);
	// 82A8AD8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AD90: 48368699  bl 0x82df3428
	ctx.lr = 0x82A8AD94;
	sub_82DF3428(ctx, base);
	// 82A8AD94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AD98: 48368691  bl 0x82df3428
	ctx.lr = 0x82A8AD9C;
	sub_82DF3428(ctx, base);
	// 82A8AD9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8ADA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8ADA4: 388B3C00  addi r4, r11, 0x3c00
	ctx.r[4].s64 = ctx.r[11].s64 + 15360;
	// 82A8ADA8: 48368C61  bl 0x82df3a08
	ctx.lr = 0x82A8ADAC;
	sub_82DF3A08(ctx, base);
	// 82A8ADAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8ADB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8ADB4: 388B3BE8  addi r4, r11, 0x3be8
	ctx.r[4].s64 = ctx.r[11].s64 + 15336;
	// 82A8ADB8: 48368C51  bl 0x82df3a08
	ctx.lr = 0x82A8ADBC;
	sub_82DF3A08(ctx, base);
	// 82A8ADBC: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82A8ADC0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8ADC4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8ADC8: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 82A8ADCC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8ADD0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8ADD4: 4BB184D5  bl 0x825a32a8
	ctx.lr = 0x82A8ADD8;
	sub_825A32A8(ctx, base);
	// 82A8ADD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8ADDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8ADE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8ADE4: 4BB1698D  bl 0x825a1770
	ctx.lr = 0x82A8ADE8;
	sub_825A1770(ctx, base);
	// 82A8ADE8: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 82A8ADEC: 4836863D  bl 0x82df3428
	ctx.lr = 0x82A8ADF0;
	sub_82DF3428(ctx, base);
	// 82A8ADF0: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 82A8ADF4: 4B83DEC5  bl 0x822c8cb8
	ctx.lr = 0x82A8ADF8;
	sub_822C8CB8(ctx, base);
	// 82A8ADF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8ADFC: 4836862D  bl 0x82df3428
	ctx.lr = 0x82A8AE00;
	sub_82DF3428(ctx, base);
	// 82A8AE00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AE04: 48368625  bl 0x82df3428
	ctx.lr = 0x82A8AE08;
	sub_82DF3428(ctx, base);
	// 82A8AE08: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AE0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AE10: 388B3BCC  addi r4, r11, 0x3bcc
	ctx.r[4].s64 = ctx.r[11].s64 + 15308;
	// 82A8AE14: 48368BF5  bl 0x82df3a08
	ctx.lr = 0x82A8AE18;
	sub_82DF3A08(ctx, base);
	// 82A8AE18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AE1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AE20: 388B3BB0  addi r4, r11, 0x3bb0
	ctx.r[4].s64 = ctx.r[11].s64 + 15280;
	// 82A8AE24: 48368BE5  bl 0x82df3a08
	ctx.lr = 0x82A8AE28;
	sub_82DF3A08(ctx, base);
	// 82A8AE28: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 82A8AE2C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AE30: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8AE34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A8AE38: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8AE3C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8AE40: 4BB18469  bl 0x825a32a8
	ctx.lr = 0x82A8AE44;
	sub_825A32A8(ctx, base);
	// 82A8AE44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AE48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AE4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8AE50: 4BB16921  bl 0x825a1770
	ctx.lr = 0x82A8AE54;
	sub_825A1770(ctx, base);
	// 82A8AE54: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A8AE58: 483685D1  bl 0x82df3428
	ctx.lr = 0x82A8AE5C;
	sub_82DF3428(ctx, base);
	// 82A8AE5C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A8AE60: 4B83DE59  bl 0x822c8cb8
	ctx.lr = 0x82A8AE64;
	sub_822C8CB8(ctx, base);
	// 82A8AE64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AE68: 483685C1  bl 0x82df3428
	ctx.lr = 0x82A8AE6C;
	sub_82DF3428(ctx, base);
	// 82A8AE6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AE70: 483685B9  bl 0x82df3428
	ctx.lr = 0x82A8AE74;
	sub_82DF3428(ctx, base);
	// 82A8AE74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AE78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AE7C: 388B3B98  addi r4, r11, 0x3b98
	ctx.r[4].s64 = ctx.r[11].s64 + 15256;
	// 82A8AE80: 48368B89  bl 0x82df3a08
	ctx.lr = 0x82A8AE84;
	sub_82DF3A08(ctx, base);
	// 82A8AE84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AE88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AE8C: 388B3B88  addi r4, r11, 0x3b88
	ctx.r[4].s64 = ctx.r[11].s64 + 15240;
	// 82A8AE90: 48368B79  bl 0x82df3a08
	ctx.lr = 0x82A8AE94;
	sub_82DF3A08(ctx, base);
	// 82A8AE94: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A8AE98: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 82A8AE9C: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82A8AEA0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AEA4: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82A8AEA8: 386103E0  addi r3, r1, 0x3e0
	ctx.r[3].s64 = ctx.r[1].s64 + 992;
	// 82A8AEAC: C3AB6218  lfs f29, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A8AEB0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8AEB4: 4BB183F5  bl 0x825a32a8
	ctx.lr = 0x82A8AEB8;
	sub_825A32A8(ctx, base);
	// 82A8AEB8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AEBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AEC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8AEC4: 4BB168AD  bl 0x825a1770
	ctx.lr = 0x82A8AEC8;
	sub_825A1770(ctx, base);
	// 82A8AEC8: 38610418  addi r3, r1, 0x418
	ctx.r[3].s64 = ctx.r[1].s64 + 1048;
	// 82A8AECC: 4836855D  bl 0x82df3428
	ctx.lr = 0x82A8AED0;
	sub_82DF3428(ctx, base);
	// 82A8AED0: 386103F8  addi r3, r1, 0x3f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1016;
	// 82A8AED4: 4B83DDE5  bl 0x822c8cb8
	ctx.lr = 0x82A8AED8;
	sub_822C8CB8(ctx, base);
	// 82A8AED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AEDC: 4836854D  bl 0x82df3428
	ctx.lr = 0x82A8AEE0;
	sub_82DF3428(ctx, base);
	// 82A8AEE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AEE4: 48368545  bl 0x82df3428
	ctx.lr = 0x82A8AEE8;
	sub_82DF3428(ctx, base);
	// 82A8AEE8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AEEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AEF0: 388B3B68  addi r4, r11, 0x3b68
	ctx.r[4].s64 = ctx.r[11].s64 + 15208;
	// 82A8AEF4: 48368B15  bl 0x82df3a08
	ctx.lr = 0x82A8AEF8;
	sub_82DF3A08(ctx, base);
	// 82A8AEF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AEFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AF00: 388B3B54  addi r4, r11, 0x3b54
	ctx.r[4].s64 = ctx.r[11].s64 + 15188;
	// 82A8AF04: 48368B05  bl 0x82df3a08
	ctx.lr = 0x82A8AF08;
	sub_82DF3A08(ctx, base);
	// 82A8AF08: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 82A8AF0C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AF10: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8AF14: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 82A8AF18: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A8AF1C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8AF20: 4BB18389  bl 0x825a32a8
	ctx.lr = 0x82A8AF24;
	sub_825A32A8(ctx, base);
	// 82A8AF24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AF28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8AF2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AF30: 4BB16841  bl 0x825a1770
	ctx.lr = 0x82A8AF34;
	sub_825A1770(ctx, base);
	// 82A8AF34: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 82A8AF38: 483684F1  bl 0x82df3428
	ctx.lr = 0x82A8AF3C;
	sub_82DF3428(ctx, base);
	// 82A8AF3C: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 82A8AF40: 4B83DD79  bl 0x822c8cb8
	ctx.lr = 0x82A8AF44;
	sub_822C8CB8(ctx, base);
	// 82A8AF44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AF48: 483684E1  bl 0x82df3428
	ctx.lr = 0x82A8AF4C;
	sub_82DF3428(ctx, base);
	// 82A8AF4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AF50: 483684D9  bl 0x82df3428
	ctx.lr = 0x82A8AF54;
	sub_82DF3428(ctx, base);
	// 82A8AF54: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AF58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AF5C: 388B3B38  addi r4, r11, 0x3b38
	ctx.r[4].s64 = ctx.r[11].s64 + 15160;
	// 82A8AF60: 48368AA9  bl 0x82df3a08
	ctx.lr = 0x82A8AF64;
	sub_82DF3A08(ctx, base);
	// 82A8AF64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AF68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AF6C: 388B3B24  addi r4, r11, 0x3b24
	ctx.r[4].s64 = ctx.r[11].s64 + 15140;
	// 82A8AF70: 48368A99  bl 0x82df3a08
	ctx.lr = 0x82A8AF74;
	sub_82DF3A08(ctx, base);
	// 82A8AF74: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 82A8AF78: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AF7C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8AF80: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A8AF84: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A8AF88: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8AF8C: 4BB1831D  bl 0x825a32a8
	ctx.lr = 0x82A8AF90;
	sub_825A32A8(ctx, base);
	// 82A8AF90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8AF94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8AF98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8AF9C: 4BB167D5  bl 0x825a1770
	ctx.lr = 0x82A8AFA0;
	sub_825A1770(ctx, base);
	// 82A8AFA0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A8AFA4: 48368485  bl 0x82df3428
	ctx.lr = 0x82A8AFA8;
	sub_82DF3428(ctx, base);
	// 82A8AFA8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A8AFAC: 4B83DD0D  bl 0x822c8cb8
	ctx.lr = 0x82A8AFB0;
	sub_822C8CB8(ctx, base);
	// 82A8AFB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AFB4: 48368475  bl 0x82df3428
	ctx.lr = 0x82A8AFB8;
	sub_82DF3428(ctx, base);
	// 82A8AFB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AFBC: 4836846D  bl 0x82df3428
	ctx.lr = 0x82A8AFC0;
	sub_82DF3428(ctx, base);
	// 82A8AFC0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AFC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8AFC8: 388B3B08  addi r4, r11, 0x3b08
	ctx.r[4].s64 = ctx.r[11].s64 + 15112;
	// 82A8AFCC: 48368A3D  bl 0x82df3a08
	ctx.lr = 0x82A8AFD0;
	sub_82DF3A08(ctx, base);
	// 82A8AFD0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8AFD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8AFD8: 388B3AF4  addi r4, r11, 0x3af4
	ctx.r[4].s64 = ctx.r[11].s64 + 15092;
	// 82A8AFDC: 48368A2D  bl 0x82df3a08
	ctx.lr = 0x82A8AFE0;
	sub_82DF3A08(ctx, base);
	// 82A8AFE0: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 82A8AFE4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8AFE8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8AFEC: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82A8AFF0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A8AFF4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8AFF8: 4BB182B1  bl 0x825a32a8
	ctx.lr = 0x82A8AFFC;
	sub_825A32A8(ctx, base);
	// 82A8AFFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8B000: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8B004: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8B008: 4BB16769  bl 0x825a1770
	ctx.lr = 0x82A8B00C;
	sub_825A1770(ctx, base);
	// 82A8B00C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82A8B010: 48368419  bl 0x82df3428
	ctx.lr = 0x82A8B014;
	sub_82DF3428(ctx, base);
	// 82A8B014: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82A8B018: 4B83DCA1  bl 0x822c8cb8
	ctx.lr = 0x82A8B01C;
	sub_822C8CB8(ctx, base);
	// 82A8B01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B020: 48368409  bl 0x82df3428
	ctx.lr = 0x82A8B024;
	sub_82DF3428(ctx, base);
	// 82A8B024: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B028: 48368401  bl 0x82df3428
	ctx.lr = 0x82A8B02C;
	sub_82DF3428(ctx, base);
	// 82A8B02C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B030: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B034: 388B3AD8  addi r4, r11, 0x3ad8
	ctx.r[4].s64 = ctx.r[11].s64 + 15064;
	// 82A8B038: 483689D1  bl 0x82df3a08
	ctx.lr = 0x82A8B03C;
	sub_82DF3A08(ctx, base);
	// 82A8B03C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B044: 388B3AC4  addi r4, r11, 0x3ac4
	ctx.r[4].s64 = ctx.r[11].s64 + 15044;
	// 82A8B048: 483689C1  bl 0x82df3a08
	ctx.lr = 0x82A8B04C;
	sub_82DF3A08(ctx, base);
	// 82A8B04C: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 82A8B050: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8B054: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8B058: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82A8B05C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A8B060: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8B064: 4BB18245  bl 0x825a32a8
	ctx.lr = 0x82A8B068;
	sub_825A32A8(ctx, base);
	// 82A8B068: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8B06C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8B070: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8B074: 4BB166FD  bl 0x825a1770
	ctx.lr = 0x82A8B078;
	sub_825A1770(ctx, base);
	// 82A8B078: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 82A8B07C: 483683AD  bl 0x82df3428
	ctx.lr = 0x82A8B080;
	sub_82DF3428(ctx, base);
	// 82A8B080: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 82A8B084: 4B83DC35  bl 0x822c8cb8
	ctx.lr = 0x82A8B088;
	sub_822C8CB8(ctx, base);
	// 82A8B088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B08C: 4836839D  bl 0x82df3428
	ctx.lr = 0x82A8B090;
	sub_82DF3428(ctx, base);
	// 82A8B090: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B094: 48368395  bl 0x82df3428
	ctx.lr = 0x82A8B098;
	sub_82DF3428(ctx, base);
	// 82A8B098: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B09C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B0A0: 388B3AAC  addi r4, r11, 0x3aac
	ctx.r[4].s64 = ctx.r[11].s64 + 15020;
	// 82A8B0A4: 48368965  bl 0x82df3a08
	ctx.lr = 0x82A8B0A8;
	sub_82DF3A08(ctx, base);
	// 82A8B0A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B0AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B0B0: 388B3A94  addi r4, r11, 0x3a94
	ctx.r[4].s64 = ctx.r[11].s64 + 14996;
	// 82A8B0B4: 48368955  bl 0x82df3a08
	ctx.lr = 0x82A8B0B8;
	sub_82DF3A08(ctx, base);
	// 82A8B0B8: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 82A8B0BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8B0C0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8B0C4: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 82A8B0C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A8B0CC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A8B0D0: 4BB181D9  bl 0x825a32a8
	ctx.lr = 0x82A8B0D4;
	sub_825A32A8(ctx, base);
	// 82A8B0D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8B0D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8B0DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8B0E0: 4BB16691  bl 0x825a1770
	ctx.lr = 0x82A8B0E4;
	sub_825A1770(ctx, base);
	// 82A8B0E4: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 82A8B0E8: 48368341  bl 0x82df3428
	ctx.lr = 0x82A8B0EC;
	sub_82DF3428(ctx, base);
	// 82A8B0EC: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 82A8B0F0: 4B83DBC9  bl 0x822c8cb8
	ctx.lr = 0x82A8B0F4;
	sub_822C8CB8(ctx, base);
	// 82A8B0F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B0F8: 48368331  bl 0x82df3428
	ctx.lr = 0x82A8B0FC;
	sub_82DF3428(ctx, base);
	// 82A8B0FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B100: 48368329  bl 0x82df3428
	ctx.lr = 0x82A8B104;
	sub_82DF3428(ctx, base);
	// 82A8B104: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B108: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B10C: 388B3A78  addi r4, r11, 0x3a78
	ctx.r[4].s64 = ctx.r[11].s64 + 14968;
	// 82A8B110: 483688F9  bl 0x82df3a08
	ctx.lr = 0x82A8B114;
	sub_82DF3A08(ctx, base);
	// 82A8B114: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B11C: 388B3A60  addi r4, r11, 0x3a60
	ctx.r[4].s64 = ctx.r[11].s64 + 14944;
	// 82A8B120: 483688E9  bl 0x82df3a08
	ctx.lr = 0x82A8B124;
	sub_82DF3A08(ctx, base);
	// 82A8B124: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A8B128: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 82A8B12C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8B130: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8B134: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8B138: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 82A8B13C: C3CB0790  lfs f30, 0x790(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1936 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A8B140: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A8B144: 4BB18165  bl 0x825a32a8
	ctx.lr = 0x82A8B148;
	sub_825A32A8(ctx, base);
	// 82A8B148: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8B14C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8B150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8B154: 4BB1661D  bl 0x825a1770
	ctx.lr = 0x82A8B158;
	sub_825A1770(ctx, base);
	// 82A8B158: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 82A8B15C: 483682CD  bl 0x82df3428
	ctx.lr = 0x82A8B160;
	sub_82DF3428(ctx, base);
	// 82A8B160: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 82A8B164: 4B83DB55  bl 0x822c8cb8
	ctx.lr = 0x82A8B168;
	sub_822C8CB8(ctx, base);
	// 82A8B168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B16C: 483682BD  bl 0x82df3428
	ctx.lr = 0x82A8B170;
	sub_82DF3428(ctx, base);
	// 82A8B170: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B174: 483682B5  bl 0x82df3428
	ctx.lr = 0x82A8B178;
	sub_82DF3428(ctx, base);
	// 82A8B178: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B17C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B180: 388B3A44  addi r4, r11, 0x3a44
	ctx.r[4].s64 = ctx.r[11].s64 + 14916;
	// 82A8B184: 48368885  bl 0x82df3a08
	ctx.lr = 0x82A8B188;
	sub_82DF3A08(ctx, base);
	// 82A8B188: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B190: 388B3A2C  addi r4, r11, 0x3a2c
	ctx.r[4].s64 = ctx.r[11].s64 + 14892;
	// 82A8B194: 48368875  bl 0x82df3a08
	ctx.lr = 0x82A8B198;
	sub_82DF3A08(ctx, base);
	// 82A8B198: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 82A8B19C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8B1A0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8B1A4: 38610320  addi r3, r1, 0x320
	ctx.r[3].s64 = ctx.r[1].s64 + 800;
	// 82A8B1A8: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8B1AC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A8B1B0: 4BB180F9  bl 0x825a32a8
	ctx.lr = 0x82A8B1B4;
	sub_825A32A8(ctx, base);
	// 82A8B1B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8B1B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8B1BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8B1C0: 4BB165B1  bl 0x825a1770
	ctx.lr = 0x82A8B1C4;
	sub_825A1770(ctx, base);
	// 82A8B1C4: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 82A8B1C8: 48368261  bl 0x82df3428
	ctx.lr = 0x82A8B1CC;
	sub_82DF3428(ctx, base);
	// 82A8B1CC: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 82A8B1D0: 4B83DAE9  bl 0x822c8cb8
	ctx.lr = 0x82A8B1D4;
	sub_822C8CB8(ctx, base);
	// 82A8B1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B1D8: 48368251  bl 0x82df3428
	ctx.lr = 0x82A8B1DC;
	sub_82DF3428(ctx, base);
	// 82A8B1DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B1E0: 48368249  bl 0x82df3428
	ctx.lr = 0x82A8B1E4;
	sub_82DF3428(ctx, base);
	// 82A8B1E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B1E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B1EC: 388B3A0C  addi r4, r11, 0x3a0c
	ctx.r[4].s64 = ctx.r[11].s64 + 14860;
	// 82A8B1F0: 48368819  bl 0x82df3a08
	ctx.lr = 0x82A8B1F4;
	sub_82DF3A08(ctx, base);
	// 82A8B1F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B1F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B1FC: 388B39F8  addi r4, r11, 0x39f8
	ctx.r[4].s64 = ctx.r[11].s64 + 14840;
	// 82A8B200: 48368809  bl 0x82df3a08
	ctx.lr = 0x82A8B204;
	sub_82DF3A08(ctx, base);
	// 82A8B204: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 82A8B208: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8B20C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8B210: 386103A0  addi r3, r1, 0x3a0
	ctx.r[3].s64 = ctx.r[1].s64 + 928;
	// 82A8B214: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8B218: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A8B21C: 4BB1808D  bl 0x825a32a8
	ctx.lr = 0x82A8B220;
	sub_825A32A8(ctx, base);
	// 82A8B220: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8B224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8B228: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8B22C: 4BB16545  bl 0x825a1770
	ctx.lr = 0x82A8B230;
	sub_825A1770(ctx, base);
	// 82A8B230: 386103D8  addi r3, r1, 0x3d8
	ctx.r[3].s64 = ctx.r[1].s64 + 984;
	// 82A8B234: 483681F5  bl 0x82df3428
	ctx.lr = 0x82A8B238;
	sub_82DF3428(ctx, base);
	// 82A8B238: 386103B8  addi r3, r1, 0x3b8
	ctx.r[3].s64 = ctx.r[1].s64 + 952;
	// 82A8B23C: 4B83DA7D  bl 0x822c8cb8
	ctx.lr = 0x82A8B240;
	sub_822C8CB8(ctx, base);
	// 82A8B240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B244: 483681E5  bl 0x82df3428
	ctx.lr = 0x82A8B248;
	sub_82DF3428(ctx, base);
	// 82A8B248: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B24C: 483681DD  bl 0x82df3428
	ctx.lr = 0x82A8B250;
	sub_82DF3428(ctx, base);
	// 82A8B250: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B254: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B258: 388B39D8  addi r4, r11, 0x39d8
	ctx.r[4].s64 = ctx.r[11].s64 + 14808;
	// 82A8B25C: 483687AD  bl 0x82df3a08
	ctx.lr = 0x82A8B260;
	sub_82DF3A08(ctx, base);
	// 82A8B260: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B268: 388B39C4  addi r4, r11, 0x39c4
	ctx.r[4].s64 = ctx.r[11].s64 + 14788;
	// 82A8B26C: 4836879D  bl 0x82df3a08
	ctx.lr = 0x82A8B270;
	sub_82DF3A08(ctx, base);
	// 82A8B270: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 82A8B274: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A8B278: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A8B27C: 38610420  addi r3, r1, 0x420
	ctx.r[3].s64 = ctx.r[1].s64 + 1056;
	// 82A8B280: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A8B284: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A8B288: 4BB18021  bl 0x825a32a8
	ctx.lr = 0x82A8B28C;
	sub_825A32A8(ctx, base);
	// 82A8B28C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A8B290: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8B294: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A8B298: 4BB164D9  bl 0x825a1770
	ctx.lr = 0x82A8B29C;
	sub_825A1770(ctx, base);
	// 82A8B29C: 38610458  addi r3, r1, 0x458
	ctx.r[3].s64 = ctx.r[1].s64 + 1112;
	// 82A8B2A0: 48368189  bl 0x82df3428
	ctx.lr = 0x82A8B2A4;
	sub_82DF3428(ctx, base);
	// 82A8B2A4: 38610438  addi r3, r1, 0x438
	ctx.r[3].s64 = ctx.r[1].s64 + 1080;
	// 82A8B2A8: 4B83DA11  bl 0x822c8cb8
	ctx.lr = 0x82A8B2AC;
	sub_822C8CB8(ctx, base);
	// 82A8B2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B2B0: 48368179  bl 0x82df3428
	ctx.lr = 0x82A8B2B4;
	sub_82DF3428(ctx, base);
	// 82A8B2B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A8B2B8: 48368171  bl 0x82df3428
	ctx.lr = 0x82A8B2BC;
	sub_82DF3428(ctx, base);
	// 82A8B2BC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B2C0: 4BB3EA11  bl 0x825c9cd0
	ctx.lr = 0x82A8B2C4;
	sub_825C9CD0(ctx, base);
	// 82A8B2C4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B2C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8B2CC: 419A0008  beq cr6, 0x82a8b2d4
	if ctx.cr[6].eq {
	pc = 0x82A8B2D4; continue 'dispatch;
	}
	// 82A8B2D0: 4B8355C1  bl 0x822c0890
	ctx.lr = 0x82A8B2D4;
	sub_822C0890(ctx, base);
	// 82A8B2D4: 382104A0  addi r1, r1, 0x4a0
	ctx.r[1].s64 = ctx.r[1].s64 + 1184;
	// 82A8B2D8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82A8B2DC: 4871D7E9  bl 0x831a8ac4
	ctx.lr = 0x82A8B2E0;
	sub_831A8A8C(ctx, base);
	// 82A8B2E0: 4871CEDC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A8B2E8 size=8
    let mut pc: u32 = 0x82A8B2E8;
    'dispatch: loop {
        match pc {
            0x82A8B2E8 => {
    //   block [0x82A8B2E8..0x82A8B2F0)
	// 82A8B2E8: 80630050  lwz r3, 0x50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8B2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A8B2F0 size=8
    let mut pc: u32 = 0x82A8B2F0;
    'dispatch: loop {
        match pc {
            0x82A8B2F0 => {
    //   block [0x82A8B2F0..0x82A8B2F8)
	// 82A8B2F0: 90830050  stw r4, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82A8B2F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A8B2F8 size=8
    let mut pc: u32 = 0x82A8B2F8;
    'dispatch: loop {
        match pc {
            0x82A8B2F8 => {
    //   block [0x82A8B2F8..0x82A8B300)
	// 82A8B2F8: C023006C  lfs f1, 0x6c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A8B2FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B300 size=172
    let mut pc: u32 = 0x82A8B300;
    'dispatch: loop {
        match pc {
            0x82A8B300 => {
    //   block [0x82A8B300..0x82A8B3AC)
	// 82A8B300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8B30C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B314: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A8B318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B31C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A8B320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8B324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B328: 4B835611  bl 0x822c0938
	ctx.lr = 0x82A8B32C;
	sub_822C0938(ctx, base);
	// 82A8B32C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8B330: 41820028  beq 0x82a8b358
	if ctx.cr[0].eq {
	pc = 0x82A8B358; continue 'dispatch;
	}
	// 82A8B334: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B338: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8B33C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A8B340: 392B3CE4  addi r9, r11, 0x3ce4
	ctx.r[9].s64 = ctx.r[11].s64 + 15588;
	// 82A8B344: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8B348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8B34C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A8B350: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8B354: 48000008  b 0x82a8b35c
	pc = 0x82A8B35C; continue 'dispatch;
	// 82A8B358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B35C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8B364: 409A002C  bne cr6, 0x82a8b390
	if !ctx.cr[6].eq {
	pc = 0x82A8B390; continue 'dispatch;
	}
	// 82A8B368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B36C: 4B834EFD  bl 0x822c0268
	ctx.lr = 0x82A8B370;
	sub_822C0268(ctx, base);
	// 82A8B370: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8B374: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A8B378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B37C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A8B380: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A8B384: 816BB35C  lwz r11, -0x4ca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19620 as u32) ) } as u64;
	// 82A8B388: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8B38C: 4B834C75  bl 0x822c0000
	ctx.lr = 0x82A8B390;
	sub_822C0000(ctx, base);
	// 82A8B390: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8B394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8B398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8B39C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8B3A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8B3A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8B3A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B3B0 size=172
    let mut pc: u32 = 0x82A8B3B0;
    'dispatch: loop {
        match pc {
            0x82A8B3B0 => {
    //   block [0x82A8B3B0..0x82A8B45C)
	// 82A8B3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B3B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8B3BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B3C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B3C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A8B3C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B3CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A8B3D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8B3D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B3D8: 4B835561  bl 0x822c0938
	ctx.lr = 0x82A8B3DC;
	sub_822C0938(ctx, base);
	// 82A8B3DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8B3E0: 41820028  beq 0x82a8b408
	if ctx.cr[0].eq {
	pc = 0x82A8B408; continue 'dispatch;
	}
	// 82A8B3E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B3E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8B3EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A8B3F0: 392B3CF8  addi r9, r11, 0x3cf8
	ctx.r[9].s64 = ctx.r[11].s64 + 15608;
	// 82A8B3F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8B3F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8B3FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A8B400: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8B404: 48000008  b 0x82a8b40c
	pc = 0x82A8B40C; continue 'dispatch;
	// 82A8B408: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B40C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8B414: 409A002C  bne cr6, 0x82a8b440
	if !ctx.cr[6].eq {
	pc = 0x82A8B440; continue 'dispatch;
	}
	// 82A8B418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B41C: 4B834E4D  bl 0x822c0268
	ctx.lr = 0x82A8B420;
	sub_822C0268(ctx, base);
	// 82A8B420: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8B424: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A8B428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B42C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A8B430: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A8B434: 816BB35C  lwz r11, -0x4ca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19620 as u32) ) } as u64;
	// 82A8B438: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8B43C: 4B834BC5  bl 0x822c0000
	ctx.lr = 0x82A8B440;
	sub_822C0000(ctx, base);
	// 82A8B440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8B444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8B448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8B44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8B450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8B454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8B458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B460 size=172
    let mut pc: u32 = 0x82A8B460;
    'dispatch: loop {
        match pc {
            0x82A8B460 => {
    //   block [0x82A8B460..0x82A8B50C)
	// 82A8B460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8B46C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B474: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A8B478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B47C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A8B480: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8B484: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B488: 4B8354B1  bl 0x822c0938
	ctx.lr = 0x82A8B48C;
	sub_822C0938(ctx, base);
	// 82A8B48C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8B490: 41820028  beq 0x82a8b4b8
	if ctx.cr[0].eq {
	pc = 0x82A8B4B8; continue 'dispatch;
	}
	// 82A8B494: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B498: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8B49C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A8B4A0: 392B3D0C  addi r9, r11, 0x3d0c
	ctx.r[9].s64 = ctx.r[11].s64 + 15628;
	// 82A8B4A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8B4A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8B4AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A8B4B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8B4B4: 48000008  b 0x82a8b4bc
	pc = 0x82A8B4BC; continue 'dispatch;
	// 82A8B4B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B4BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B4C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8B4C4: 409A002C  bne cr6, 0x82a8b4f0
	if !ctx.cr[6].eq {
	pc = 0x82A8B4F0; continue 'dispatch;
	}
	// 82A8B4C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B4CC: 4B834D9D  bl 0x822c0268
	ctx.lr = 0x82A8B4D0;
	sub_822C0268(ctx, base);
	// 82A8B4D0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8B4D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A8B4D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B4DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A8B4E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A8B4E4: 816BB35C  lwz r11, -0x4ca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19620 as u32) ) } as u64;
	// 82A8B4E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8B4EC: 4B834B15  bl 0x822c0000
	ctx.lr = 0x82A8B4F0;
	sub_822C0000(ctx, base);
	// 82A8B4F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8B4F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8B4F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8B4FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8B500: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8B504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8B508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B510 size=172
    let mut pc: u32 = 0x82A8B510;
    'dispatch: loop {
        match pc {
            0x82A8B510 => {
    //   block [0x82A8B510..0x82A8B5BC)
	// 82A8B510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8B51C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B524: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A8B528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B52C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A8B530: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8B534: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B538: 4B835401  bl 0x822c0938
	ctx.lr = 0x82A8B53C;
	sub_822C0938(ctx, base);
	// 82A8B53C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8B540: 41820028  beq 0x82a8b568
	if ctx.cr[0].eq {
	pc = 0x82A8B568; continue 'dispatch;
	}
	// 82A8B544: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8B548: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8B54C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A8B550: 392B3D20  addi r9, r11, 0x3d20
	ctx.r[9].s64 = ctx.r[11].s64 + 15648;
	// 82A8B554: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8B558: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8B55C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A8B560: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8B564: 48000008  b 0x82a8b56c
	pc = 0x82A8B56C; continue 'dispatch;
	// 82A8B568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B56C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8B574: 409A002C  bne cr6, 0x82a8b5a0
	if !ctx.cr[6].eq {
	pc = 0x82A8B5A0; continue 'dispatch;
	}
	// 82A8B578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B57C: 4B834CED  bl 0x822c0268
	ctx.lr = 0x82A8B580;
	sub_822C0268(ctx, base);
	// 82A8B580: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8B584: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A8B588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8B58C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A8B590: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A8B594: 816BB35C  lwz r11, -0x4ca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19620 as u32) ) } as u64;
	// 82A8B598: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8B59C: 4B834A65  bl 0x822c0000
	ctx.lr = 0x82A8B5A0;
	sub_822C0000(ctx, base);
	// 82A8B5A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8B5A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8B5A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8B5AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8B5B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8B5B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8B5B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B5C0 size=88
    let mut pc: u32 = 0x82A8B5C0;
    'dispatch: loop {
        match pc {
            0x82A8B5C0 => {
    //   block [0x82A8B5C0..0x82A8B618)
	// 82A8B5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B5C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8B5CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B5D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8B5D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8B5DC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B5E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8B5E4: 419A0008  beq cr6, 0x82a8b5ec
	if ctx.cr[6].eq {
	pc = 0x82A8B5EC; continue 'dispatch;
	}
	// 82A8B5E8: 4B8352A9  bl 0x822c0890
	ctx.lr = 0x82A8B5EC;
	sub_822C0890(ctx, base);
	// 82A8B5EC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8B5F0: 4182000C  beq 0x82a8b5fc
	if ctx.cr[0].eq {
	pc = 0x82A8B5FC; continue 'dispatch;
	}
	// 82A8B5F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B5F8: 4B834C71  bl 0x822c0268
	ctx.lr = 0x82A8B5FC;
	sub_822C0268(ctx, base);
	// 82A8B5FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B600: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8B604: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8B608: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8B60C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8B610: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8B614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B618 size=252
    let mut pc: u32 = 0x82A8B618;
    'dispatch: loop {
        match pc {
            0x82A8B618 => {
    //   block [0x82A8B618..0x82A8B714)
	// 82A8B618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B61C: 4871CB4D  bl 0x831a8168
	ctx.lr = 0x82A8B620;
	sub_831A8130(ctx, base);
	// 82A8B620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B624: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A8B628: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8B62C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A8B630: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A8B634: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B638: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B63C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A8B640: 409A0018  bne cr6, 0x82a8b658
	if !ctx.cr[6].eq {
	pc = 0x82A8B658; continue 'dispatch;
	}
	// 82A8B644: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B648: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B64C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A8B650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A8B654: 419A0008  beq cr6, 0x82a8b65c
	if ctx.cr[6].eq {
	pc = 0x82A8B65C; continue 'dispatch;
	}
	// 82A8B658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B65C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8B660: 40820098  bne 0x82a8b6f8
	if !ctx.cr[0].eq {
	pc = 0x82A8B6F8; continue 'dispatch;
	}
	// 82A8B664: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B668: 81670008  lwz r11, 8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8B66C: 5549F87E  srwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A8B670: 554507FE  clrlwi r5, r10, 0x1f
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A8B674: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A8B678: 41990008  bgt cr6, 0x82a8b680
	if ctx.cr[6].gt {
	pc = 0x82A8B680; continue 'dispatch;
	}
	// 82A8B67C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A8B680: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B684: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B688: 550AF87E  srwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A8B68C: 550807FE  clrlwi r8, r8, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 82A8B690: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8B694: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A8B698: 41990008  bgt cr6, 0x82a8b6a0
	if ctx.cr[6].gt {
	pc = 0x82A8B6A0; continue 'dispatch;
	}
	// 82A8B69C: 7D465050  subf r10, r6, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 82A8B6A0: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B6A4: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A8B6A8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B6AC: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A8B6B0: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A8B6B4: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A8B6B8: 7D47302E  lwzx r10, r7, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82A8B6BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A8B6C0: 7D44182E  lwzx r10, r4, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82A8B6C4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A8B6C8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A8B6CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B6D0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A8B6D4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B6D8: 4B838D89  bl 0x822c4460
	ctx.lr = 0x82A8B6DC;
	sub_822C4460(ctx, base);
	// 82A8B6DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B6E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A8B6E4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A8B6E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B6EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A8B6F0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A8B6F4: 4BFFFF40  b 0x82a8b634
	pc = 0x82A8B634; continue 'dispatch;
	// 82A8B6F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B6FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A8B700: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B704: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B708: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8B70C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A8B710: 4871CAA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B718 size=244
    let mut pc: u32 = 0x82A8B718;
    'dispatch: loop {
        match pc {
            0x82A8B718 => {
    //   block [0x82A8B718..0x82A8B80C)
	// 82A8B718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B71C: 4871CA4D  bl 0x831a8168
	ctx.lr = 0x82A8B720;
	sub_831A8130(ctx, base);
	// 82A8B720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B724: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A8B728: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A8B72C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A8B730: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A8B734: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B738: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B73C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A8B740: 409A0018  bne cr6, 0x82a8b758
	if !ctx.cr[6].eq {
	pc = 0x82A8B758; continue 'dispatch;
	}
	// 82A8B744: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B748: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B74C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A8B750: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A8B754: 419A0008  beq cr6, 0x82a8b75c
	if ctx.cr[6].eq {
	pc = 0x82A8B75C; continue 'dispatch;
	}
	// 82A8B758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8B75C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8B760: 40820090  bne 0x82a8b7f0
	if !ctx.cr[0].eq {
	pc = 0x82A8B7F0; continue 'dispatch;
	}
	// 82A8B764: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B768: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82A8B76C: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A8B770: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8B774: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8B778: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A8B77C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A8B780: 41990008  bgt cr6, 0x82a8b788
	if ctx.cr[6].gt {
	pc = 0x82A8B788; continue 'dispatch;
	}
	// 82A8B784: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82A8B788: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A8B78C: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B790: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B794: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A8B798: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B79C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A8B7A0: 7D06402E  lwzx r8, r6, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82A8B7A4: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A8B7A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A8B7AC: 556607FE  clrlwi r6, r11, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82A8B7B0: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8B7B4: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82A8B7B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A8B7BC: 41990008  bgt cr6, 0x82a8b7c4
	if ctx.cr[6].gt {
	pc = 0x82A8B7C4; continue 'dispatch;
	}
	// 82A8B7C0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A8B7C4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B7C8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A8B7CC: 54CA1838  slwi r10, r6, 3
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A8B7D0: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B7D4: 38880004  addi r4, r8, 4
	ctx.r[4].s64 = ctx.r[8].s64 + 4;
	// 82A8B7D8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A8B7DC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A8B7E0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A8B7E4: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A8B7E8: 4B838C79  bl 0x822c4460
	ctx.lr = 0x82A8B7EC;
	sub_822C4460(ctx, base);
	// 82A8B7EC: 4BFFFF48  b 0x82a8b734
	pc = 0x82A8B734; continue 'dispatch;
	// 82A8B7F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B7F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A8B7F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B7FC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8B800: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8B804: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A8B808: 4871C9B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B810 size=120
    let mut pc: u32 = 0x82A8B810;
    'dispatch: loop {
        match pc {
            0x82A8B810 => {
    //   block [0x82A8B810..0x82A8B888)
	// 82A8B810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8B81C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8B828: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A8B82C: 483683D5  bl 0x82df3c00
	ctx.lr = 0x82A8B830;
	sub_82DF3C00(ctx, base);
	// 82A8B830: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A8B834: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B838: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A8B83C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8B844: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A8B848: 419A0024  beq cr6, 0x82a8b86c
	if ctx.cr[6].eq {
	pc = 0x82A8B86C; continue 'dispatch;
	}
	// 82A8B84C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A8B850: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A8B854: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8B858: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A8B85C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A8B860: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A8B864: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A8B868: 4082FFE8  bne 0x82a8b850
	if !ctx.cr[0].eq {
	pc = 0x82A8B850; continue 'dispatch;
	}
	// 82A8B86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8B874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8B878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8B87C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8B880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8B884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B888 size=116
    let mut pc: u32 = 0x82A8B888;
    'dispatch: loop {
        match pc {
            0x82A8B888 => {
    //   block [0x82A8B888..0x82A8B8FC)
	// 82A8B888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B88C: 4871C8DD  bl 0x831a8168
	ctx.lr = 0x82A8B890;
	sub_831A8130(ctx, base);
	// 82A8B890: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B894: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A8B898: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B89C: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B8A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A8B8A4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B8A8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A8B8AC: 83C50004  lwz r30, 4(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B8B0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A8B8B4: 83A40000  lwz r29, 0(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B8B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8B8BC: 83840004  lwz r28, 4(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B8C0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A8B8C4: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82A8B8C8: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A8B8CC: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 82A8B8D0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A8B8D4: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A8B8D8: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A8B8DC: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82A8B8E0: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8B8E4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8B8E8: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8B8EC: 4BFFFD2D  bl 0x82a8b618
	ctx.lr = 0x82A8B8F0;
	sub_82A8B618(ctx, base);
	// 82A8B8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B8F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A8B8F8: 4871C8C0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B900 size=116
    let mut pc: u32 = 0x82A8B900;
    'dispatch: loop {
        match pc {
            0x82A8B900 => {
    //   block [0x82A8B900..0x82A8B974)
	// 82A8B900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B904: 4871C865  bl 0x831a8168
	ctx.lr = 0x82A8B908;
	sub_831A8130(ctx, base);
	// 82A8B908: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B90C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A8B910: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B914: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B918: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A8B91C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B920: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A8B924: 83C50004  lwz r30, 4(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B928: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A8B92C: 83A40000  lwz r29, 0(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8B930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8B934: 83840004  lwz r28, 4(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8B938: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A8B93C: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82A8B940: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A8B944: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 82A8B948: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A8B94C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A8B950: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A8B954: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82A8B958: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8B95C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8B960: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A8B964: 4BFFFDB5  bl 0x82a8b718
	ctx.lr = 0x82A8B968;
	sub_82A8B718(ctx, base);
	// 82A8B968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B96C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A8B970: 4871C848  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B978 size=96
    let mut pc: u32 = 0x82A8B978;
    'dispatch: loop {
        match pc {
            0x82A8B978 => {
    //   block [0x82A8B978..0x82A8B9D8)
	// 82A8B978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8B984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8B990: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A8B994: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8B998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8B99C: 419A0008  beq cr6, 0x82a8b9a4
	if ctx.cr[6].eq {
	pc = 0x82A8B9A4; continue 'dispatch;
	}
	// 82A8B9A0: 4B834EF1  bl 0x822c0890
	ctx.lr = 0x82A8B9A4;
	sub_822C0890(ctx, base);
	// 82A8B9A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B9A8: 48367A81  bl 0x82df3428
	ctx.lr = 0x82A8B9AC;
	sub_82DF3428(ctx, base);
	// 82A8B9AC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8B9B0: 4182000C  beq 0x82a8b9bc
	if ctx.cr[0].eq {
	pc = 0x82A8B9BC; continue 'dispatch;
	}
	// 82A8B9B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B9B8: 4B8348B1  bl 0x822c0268
	ctx.lr = 0x82A8B9BC;
	sub_822C0268(ctx, base);
	// 82A8B9BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8B9C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8B9C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8B9C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8B9CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8B9D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8B9D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8B9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8B9D8 size=136
    let mut pc: u32 = 0x82A8B9D8;
    'dispatch: loop {
        match pc {
            0x82A8B9D8 => {
    //   block [0x82A8B9D8..0x82A8BA60)
	// 82A8B9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8B9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8B9E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8B9E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8B9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A8B9EC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A8B9F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A8B9F4: 419A0058  beq cr6, 0x82a8ba4c
	if ctx.cr[6].eq {
	pc = 0x82A8BA4C; continue 'dispatch;
	}
	// 82A8B9F8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8B9FC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A8BA00: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A8BA04: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82A8BA08: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A8BA0C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A8BA10: 41990008  bgt cr6, 0x82a8ba18
	if ctx.cr[6].gt {
	pc = 0x82A8BA18; continue 'dispatch;
	}
	// 82A8BA14: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A8BA18: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8BA1C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A8BA20: 554A1F38  rlwinm r10, r10, 3, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82A8BA24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A8BA28: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A8BA2C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A8BA30: 4BFFFB91  bl 0x82a8b5c0
	ctx.lr = 0x82A8BA34;
	sub_82A8B5C0(ctx, base);
	// 82A8BA34: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A8BA38: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A8BA3C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A8BA40: 4082000C  bne 0x82a8ba4c
	if !ctx.cr[0].eq {
	pc = 0x82A8BA4C; continue 'dispatch;
	}
	// 82A8BA44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8BA48: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A8BA4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A8BA50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8BA54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8BA58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8BA5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8BA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8BA60 size=244
    let mut pc: u32 = 0x82A8BA60;
    'dispatch: loop {
        match pc {
            0x82A8BA60 => {
    //   block [0x82A8BA60..0x82A8BB54)
	// 82A8BA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8BA64: 4871C705  bl 0x831a8168
	ctx.lr = 0x82A8BA68;
	sub_831A8130(ctx, base);
	// 82A8BA68: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8BA6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8BA70: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8BA74: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A8BA78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A8BA7C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82A8BA80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A8BA84: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8BA88: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A8BA8C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A8BA90: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A8BA94: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82A8BA98: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A8BA9C: 7FA85050  subf r29, r8, r10
	ctx.r[29].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82A8BAA0: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A8BAA4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A8BAA8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A8BAAC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8BAB0: 7FCA5850  subf r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A8BAB4: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A8BAB8: 40980044  bge cr6, 0x82a8bafc
	if !ctx.cr[6].lt {
	pc = 0x82A8BAFC; continue 'dispatch;
	}
	// 82A8BABC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8BAC0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A8BAC4: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8BAC8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A8BACC: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82A8BAD0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A8BAD4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A8BAD8: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82A8BADC: 4BFFFE25  bl 0x82a8b900
	ctx.lr = 0x82A8BAE0;
	sub_82A8B900(ctx, base);
	// 82A8BAE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A8BAE4: 419A0054  beq cr6, 0x82a8bb38
	if ctx.cr[6].eq {
	pc = 0x82A8BB38; continue 'dispatch;
	}
	// 82A8BAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8BAEC: 4BD6300D  bl 0x827eeaf8
	ctx.lr = 0x82A8BAF0;
	sub_827EEAF8(ctx, base);
	// 82A8BAF0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A8BAF4: 4082FFF4  bne 0x82a8bae8
	if !ctx.cr[0].eq {
	pc = 0x82A8BAE8; continue 'dispatch;
	}
	// 82A8BAF8: 48000040  b 0x82a8bb38
	pc = 0x82A8BB38; continue 'dispatch;
	// 82A8BAFC: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8BB00: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A8BB04: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A8BB08: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A8BB0C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82A8BB10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A8BB14: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82A8BB18: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82A8BB1C: 4BFFFD6D  bl 0x82a8b888
	ctx.lr = 0x82A8BB20;
	sub_82A8B888(ctx, base);
	// 82A8BB20: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A8BB24: 419A0014  beq cr6, 0x82a8bb38
	if ctx.cr[6].eq {
	pc = 0x82A8BB38; continue 'dispatch;
	}
	// 82A8BB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8BB2C: 4BFFFEAD  bl 0x82a8b9d8
	ctx.lr = 0x82A8BB30;
	sub_82A8B9D8(ctx, base);
	// 82A8BB30: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A8BB34: 4082FFF4  bne 0x82a8bb28
	if !ctx.cr[0].eq {
	pc = 0x82A8BB28; continue 'dispatch;
	}
	// 82A8BB38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8BB3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A8BB40: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A8BB44: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A8BB48: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A8BB4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A8BB50: 4871C668  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8BB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A8BB58 size=184
    let mut pc: u32 = 0x82A8BB58;
    'dispatch: loop {
        match pc {
            0x82A8BB58 => {
    //   block [0x82A8BB58..0x82A8BC10)
	// 82A8BB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A8BB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A8BB60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A8BB64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A8BB68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A8BB6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A8BB70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8BB74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A8BB78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A8BB7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8BB80: 4B834DB9  bl 0x822c0938
	ctx.lr = 0x82A8BB84;
	sub_822C0938(ctx, base);
	// 82A8BB84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A8BB88: 41820028  beq 0x82a8bbb0
	if ctx.cr[0].eq {
	pc = 0x82A8BBB0; continue 'dispatch;
	}
	// 82A8BB8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A8BB90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A8BB94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A8BB98: 392B3CD0  addi r9, r11, 0x3cd0
	ctx.r[9].s64 = ctx.r[11].s64 + 15568;
	// 82A8BB9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A8BBA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A8BBA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A8BBA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A8BBAC: 48000008  b 0x82a8bbb4
	pc = 0x82A8BBB4; continue 'dispatch;
	// 82A8BBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A8BBB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A8BBB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A8BBBC: 409A0038  bne cr6, 0x82a8bbf4
	if !ctx.cr[6].eq {
	pc = 0x82A8BBF4; continue 'dispatch;
	}
	// 82A8BBC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A8BBC4: 419A0010  beq cr6, 0x82a8bbd4
	if ctx.cr[6].eq {
	pc = 0x82A8BBD4; continue 'dispatch;
	}
	// 82A8BBC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A8BBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A8BBD0: 4BFFFDA9  bl 0x82a8b978
	ctx.lr = 0x82A8BBD4;
	sub_82A8B978(ctx, base);
	// 82A8BBD4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A8BBD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A8BBDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A8BBE0: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A8BBE4: 816BB35C  lwz r11, -0x4ca4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19620 as u32) ) } as u64;
	// 82A8BBE8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A8BBEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A8BBF0: 4B834411  bl 0x822c0000
	ctx.lr = 0x82A8BBF4;
	sub_822C0000(ctx, base);
	// 82A8BBF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A8BBF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A8BBFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A8BC00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A8BC04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A8BC08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A8BC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8BC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A8BC10 size=12
    let mut pc: u32 = 0x82A8BC10;
    'dispatch: loop {
        match pc {
            0x82A8BC10 => {
    //   block [0x82A8BC10..0x82A8BC1C)
	// 82A8BC10: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A8BC14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A8BC18: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8BC1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A8BC1C size=8
    let mut pc: u32 = 0x82A8BC1C;
    'dispatch: loop {
        match pc {
            0x82A8BC1C => {
    //   block [0x82A8BC1C..0x82A8BC24)
	// 82A8BC1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A8BC20: 4BFFFD58  b 0x82a8b978
	sub_82A8B978(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A8BC24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A8BC24 size=4
    let mut pc: u32 = 0x82A8BC24;
    'dispatch: loop {
        match pc {
            0x82A8BC24 => {
    //   block [0x82A8BC24..0x82A8BC28)
	// 82A8BC24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


