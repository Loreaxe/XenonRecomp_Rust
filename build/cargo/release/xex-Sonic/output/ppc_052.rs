pub fn sub_825D3318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D3318 size=132
    let mut pc: u32 = 0x825D3318;
    'dispatch: loop {
        match pc {
            0x825D3318 => {
    //   block [0x825D3318..0x825D339C)
	// 825D3318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D331C: 48BD4E4D  bl 0x831a8168
	ctx.lr = 0x825D3320;
	sub_831A8130(ctx, base);
	// 825D3320: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D3324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D3328: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825D332C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 825D3330: 4BFE1A89  bl 0x825b4db8
	ctx.lr = 0x825D3334;
	sub_825B4DB8(ctx, base);
	// 825D3334: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D3338: 93BF0120  stw r29, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[29].u32 ) };
	// 825D333C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D3340: 396BE0B4  addi r11, r11, -0x1f4c
	ctx.r[11].s64 = ctx.r[11].s64 + -8012;
	// 825D3344: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 825D3348: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D334C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D3350: 93DF0124  stw r30, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u32 ) };
	// 825D3354: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 825D3358: 9BDF012C  stb r30, 0x12c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u8 ) };
	// 825D335C: 4BF77C45  bl 0x8254afa0
	ctx.lr = 0x825D3360;
	sub_8254AFA0(ctx, base);
	// 825D3360: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D3364: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D3368: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 825D336C: 93DF0144  stw r30, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[30].u32 ) };
	// 825D3370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3374: 93DF014C  stw r30, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[30].u32 ) };
	// 825D3378: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 825D337C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D3380: 9BDF0158  stb r30, 0x158(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[30].u8 ) };
	// 825D3384: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D3388: 9BDF0159  stb r30, 0x159(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(345 as u32), ctx.r[30].u8 ) };
	// 825D338C: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825D3390: D1BF0154  stfs f13, 0x154(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 825D3394: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D3398: 48BD4E20  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D33A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D33A0 size=76
    let mut pc: u32 = 0x825D33A0;
    'dispatch: loop {
        match pc {
            0x825D33A0 => {
    //   block [0x825D33A0..0x825D33EC)
	// 825D33A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D33A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D33A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D33AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D33B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D33B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D33B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D33BC: 4BFFFE0D  bl 0x825d31c8
	ctx.lr = 0x825D33C0;
	sub_825D31C8(ctx, base);
	// 825D33C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D33C4: 4182000C  beq 0x825d33d0
	if ctx.cr[0].eq {
	pc = 0x825D33D0; continue 'dispatch;
	}
	// 825D33C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D33CC: 4BCECE9D  bl 0x822c0268
	ctx.lr = 0x825D33D0;
	sub_822C0268(ctx, base);
	// 825D33D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D33D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D33D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D33DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D33E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D33E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D33E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D33F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D33F0 size=364
    let mut pc: u32 = 0x825D33F0;
    'dispatch: loop {
        match pc {
            0x825D33F0 => {
    //   block [0x825D33F0..0x825D355C)
	// 825D33F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D33F4: 48BD4D71  bl 0x831a8164
	ctx.lr = 0x825D33F8;
	sub_831A8130(ctx, base);
	// 825D33F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D33FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D3400: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825D3404: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825D3408: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825D340C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D3410: C18B9690  lfs f12, -0x6970(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26992 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D3414: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825D3418: C16A95F4  lfs f11, -0x6a0c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825D341C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D3420: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D3424: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D3428: C1A8959C  lfs f13, -0x6a64(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D342C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825D3430: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825D3434: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D3438: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825D343C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3440: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825D3444: 3887E060  addi r4, r7, -0x1fa0
	ctx.r[4].s64 = ctx.r[7].s64 + -8096;
	// 825D3448: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825D344C: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 825D3450: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825D3454: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 825D3458: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825D345C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825D3460: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825D3464: 4BCECF75  bl 0x822c03d8
	ctx.lr = 0x825D3468;
	sub_822C03D8(ctx, base);
	// 825D3468: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D346C: 4182003C  beq 0x825d34a8
	if ctx.cr[0].eq {
	pc = 0x825D34A8; continue 'dispatch;
	}
	// 825D3470: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D3474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3478: 808BBCD4  lwz r4, -0x432c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17196 as u32) ) } as u64;
	// 825D347C: 4882058D  bl 0x82df3a08
	ctx.lr = 0x825D3480;
	sub_82DF3A08(ctx, base);
	// 825D3480: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 825D3484: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D3488: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825D348C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825D3490: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3498: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825D349C: 4BFFFE7D  bl 0x825d3318
	ctx.lr = 0x825D34A0;
	sub_825D3318(ctx, base);
	// 825D34A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D34A4: 48000008  b 0x825d34ac
	pc = 0x825D34AC; continue 'dispatch;
	// 825D34A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D34AC: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D34B0: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825D34B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D34B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D34BC: 4BFFF2D5  bl 0x825d2790
	ctx.lr = 0x825D34C0;
	sub_825D2790(ctx, base);
	// 825D34C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D34C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D34C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D34CC: 4BCECB35  bl 0x822c0000
	ctx.lr = 0x825D34D0;
	sub_822C0000(ctx, base);
	// 825D34D0: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D34D4: 4182000C  beq 0x825d34e0
	if ctx.cr[0].eq {
	pc = 0x825D34E0; continue 'dispatch;
	}
	// 825D34D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D34DC: 4881FF4D  bl 0x82df3428
	ctx.lr = 0x825D34E0;
	sub_82DF3428(ctx, base);
	// 825D34E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D34E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D34E8: 388BE11C  addi r4, r11, -0x1ee4
	ctx.r[4].s64 = ctx.r[11].s64 + -7908;
	// 825D34EC: 4882051D  bl 0x82df3a08
	ctx.lr = 0x825D34F0;
	sub_82DF3A08(ctx, base);
	// 825D34F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D34F4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D34F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D34FC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D3500: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D3504: 419A0024  beq cr6, 0x825d3528
	if ctx.cr[6].eq {
	pc = 0x825D3528; continue 'dispatch;
	}
	// 825D3508: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D350C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3510: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3514: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3518: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D351C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3520: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3524: 4082FFE8  bne 0x825d350c
	if !ctx.cr[0].eq {
	pc = 0x825D350C; continue 'dispatch;
	}
	// 825D3528: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D352C: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3530: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D3534: 4BFE2D65  bl 0x825b6298
	ctx.lr = 0x825D3538;
	sub_825B6298(ctx, base);
	// 825D3538: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D353C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D3540: 419A0008  beq cr6, 0x825d3548
	if ctx.cr[6].eq {
	pc = 0x825D3548; continue 'dispatch;
	}
	// 825D3544: 4BCED34D  bl 0x822c0890
	ctx.lr = 0x825D3548;
	sub_822C0890(ctx, base);
	// 825D3548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D354C: 4881FEDD  bl 0x82df3428
	ctx.lr = 0x825D3550;
	sub_82DF3428(ctx, base);
	// 825D3550: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D3554: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825D3558: 48BD4C5C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D3560 size=3356
    let mut pc: u32 = 0x825D3560;
    'dispatch: loop {
        match pc {
            0x825D3560 => {
    //   block [0x825D3560..0x825D427C)
	// 825D3560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D3564: 48BD4BE5  bl 0x831a8148
	ctx.lr = 0x825D3568;
	sub_831A8130(ctx, base);
	// 825D3568: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D356C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825D3570: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 825D3574: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 825D3578: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D357C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825D3580: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 825D3584: 4BFE2A2D  bl 0x825b5fb0
	ctx.lr = 0x825D3588;
	sub_825B5FB0(ctx, base);
	// 825D3588: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D358C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3590: 3ACBE060  addi r22, r11, -0x1fa0
	ctx.r[22].s64 = ctx.r[11].s64 + -8096;
	// 825D3594: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 825D3598: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D359C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825D35A0: 4BCECE39  bl 0x822c03d8
	ctx.lr = 0x825D35A4;
	sub_822C03D8(ctx, base);
	// 825D35A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D35A8: 41820010  beq 0x825d35b8
	if ctx.cr[0].eq {
	pc = 0x825D35B8; continue 'dispatch;
	}
	// 825D35AC: 4BFCED05  bl 0x825a22b0
	ctx.lr = 0x825D35B0;
	sub_825A22B0(ctx, base);
	// 825D35B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D35B4: 48000008  b 0x825d35bc
	pc = 0x825D35BC; continue 'dispatch;
	// 825D35B8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825D35BC: 3B3A0124  addi r25, r26, 0x124
	ctx.r[25].s64 = ctx.r[26].s64 + 292;
	// 825D35C0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825D35C4: 4BFE243D  bl 0x825b5a00
	ctx.lr = 0x825D35C8;
	sub_825B5A00(ctx, base);
	// 825D35C8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D35CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D35D0: 38A00049  li r5, 0x49
	ctx.r[5].s64 = 73;
	// 825D35D4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825D35D8: 4BCECE01  bl 0x822c03d8
	ctx.lr = 0x825D35DC;
	sub_822C03D8(ctx, base);
	// 825D35DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D35E0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D35E4: 3B6BE1D0  addi r27, r11, -0x1e30
	ctx.r[27].s64 = ctx.r[11].s64 + -7728;
	// 825D35E8: 41820054  beq 0x825d363c
	if ctx.cr[0].eq {
	pc = 0x825D363C; continue 'dispatch;
	}
	// 825D35EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D35F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D35F4: 48820415  bl 0x82df3a08
	ctx.lr = 0x825D35F8;
	sub_82DF3A08(ctx, base);
	// 825D35F8: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D35FC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D3600: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 825D3604: 396B2F90  addi r11, r11, 0x2f90
	ctx.r[11].s64 = ctx.r[11].s64 + 12176;
	// 825D3608: 92E10080  stw r23, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 825D360C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825D3610: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D3614: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825D3618: 4BFFFB31  bl 0x825d3148
	ctx.lr = 0x825D361C;
	sub_825D3148(ctx, base);
	// 825D361C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D3620: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825D3624: 38BA014C  addi r5, r26, 0x14c
	ctx.r[5].s64 = ctx.r[26].s64 + 332;
	// 825D3628: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D362C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3630: 4BFD8B61  bl 0x825ac190
	ctx.lr = 0x825D3634;
	sub_825AC190(ctx, base);
	// 825D3634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D3638: 48000008  b 0x825d3640
	pc = 0x825D3640; continue 'dispatch;
	// 825D363C: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3640: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D3644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3648: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D364C: 4BF1FD6D  bl 0x824f33b8
	ctx.lr = 0x825D3650;
	sub_824F33B8(ctx, base);
	// 825D3650: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3658: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D365C: 4BCEC9A5  bl 0x822c0000
	ctx.lr = 0x825D3660;
	sub_822C0000(ctx, base);
	// 825D3660: 570B07FF  clrlwi. r11, r24, 0x1f
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3664: 41820010  beq 0x825d3674
	if ctx.cr[0].eq {
	pc = 0x825D3674; continue 'dispatch;
	}
	// 825D3668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D366C: 5718003C  rlwinm r24, r24, 0, 0, 0x1e
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D3670: 4881FDB9  bl 0x82df3428
	ctx.lr = 0x825D3674;
	sub_82DF3428(ctx, base);
	// 825D3674: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D3678: 3BBA0130  addi r29, r26, 0x130
	ctx.r[29].s64 = ctx.r[26].s64 + 304;
	// 825D367C: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3680: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 825D3684: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D368C: 419A0038  beq cr6, 0x825d36c4
	if ctx.cr[6].eq {
	pc = 0x825D36C4; continue 'dispatch;
	}
	// 825D3690: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D3694: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D3698: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825D369C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D36A0: 40980024  bge cr6, 0x825d36c4
	if !ctx.cr[6].lt {
	pc = 0x825D36C4; continue 'dispatch;
	}
	// 825D36A4: 817A0134  lwz r11, 0x134(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D36A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D36AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D36B0: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825D36B4: 4BFD870D  bl 0x825abdc0
	ctx.lr = 0x825D36B8;
	sub_825ABDC0(ctx, base);
	// 825D36B8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825D36BC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825D36C0: 4BFFFFC4  b 0x825d3684
	pc = 0x825D3684; continue 'dispatch;
	// 825D36C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D36C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D36CC: 388BE1C4  addi r4, r11, -0x1e3c
	ctx.r[4].s64 = ctx.r[11].s64 + -7740;
	// 825D36D0: 48820339  bl 0x82df3a08
	ctx.lr = 0x825D36D4;
	sub_82DF3A08(ctx, base);
	// 825D36D4: 82810064  lwz r20, 0x64(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D36D8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 825D36DC: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 825D36E0: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 825D36E4: 419A0024  beq cr6, 0x825d3708
	if ctx.cr[6].eq {
	pc = 0x825D3708; continue 'dispatch;
	}
	// 825D36E8: 39740004  addi r11, r20, 4
	ctx.r[11].s64 = ctx.r[20].s64 + 4;
	// 825D36EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D36F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D36F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D36F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D36FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3700: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3704: 4082FFE8  bne 0x825d36ec
	if !ctx.cr[0].eq {
	pc = 0x825D36EC; continue 'dispatch;
	}
	// 825D3708: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D370C: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3714: 4BFCE9FD  bl 0x825a2110
	ctx.lr = 0x825D3718;
	sub_825A2110(ctx, base);
	// 825D3718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D371C: 4881FD0D  bl 0x82df3428
	ctx.lr = 0x825D3720;
	sub_82DF3428(ctx, base);
	// 825D3720: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D3724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3728: 388BE1B8  addi r4, r11, -0x1e48
	ctx.r[4].s64 = ctx.r[11].s64 + -7752;
	// 825D372C: 488202DD  bl 0x82df3a08
	ctx.lr = 0x825D3730;
	sub_82DF3A08(ctx, base);
	// 825D3730: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D3734: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D3738: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825D373C: 396B2F38  addi r11, r11, 0x2f38
	ctx.r[11].s64 = ctx.r[11].s64 + 12088;
	// 825D3740: 92E10080  stw r23, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 825D3744: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D3748: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D374C: 4BFFF87D  bl 0x825d2fc8
	ctx.lr = 0x825D3750;
	sub_825D2FC8(ctx, base);
	// 825D3750: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825D3754: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3758: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825D375C: 38C02710  li r6, 0x2710
	ctx.r[6].s64 = 10000;
	// 825D3760: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D3764: 389A0150  addi r4, r26, 0x150
	ctx.r[4].s64 = ctx.r[26].s64 + 336;
	// 825D3768: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825D376C: 4BFCFD1D  bl 0x825a3488
	ctx.lr = 0x825D3770;
	sub_825A3488(ctx, base);
	// 825D3770: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D3774: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D377C: 4BFCE75D  bl 0x825a1ed8
	ctx.lr = 0x825D3780;
	sub_825A1ED8(ctx, base);
	// 825D3780: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 825D3784: 4881FCA5  bl 0x82df3428
	ctx.lr = 0x825D3788;
	sub_82DF3428(ctx, base);
	// 825D3788: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 825D378C: 4BCF552D  bl 0x822c8cb8
	ctx.lr = 0x825D3790;
	sub_822C8CB8(ctx, base);
	// 825D3790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3794: 4881FC95  bl 0x82df3428
	ctx.lr = 0x825D3798;
	sub_82DF3428(ctx, base);
	// 825D3798: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D379C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D37A0: 388BE1AC  addi r4, r11, -0x1e54
	ctx.r[4].s64 = ctx.r[11].s64 + -7764;
	// 825D37A4: 48820265  bl 0x82df3a08
	ctx.lr = 0x825D37A8;
	sub_82DF3A08(ctx, base);
	// 825D37A8: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D37AC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D37B0: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825D37B4: 396B26D8  addi r11, r11, 0x26d8
	ctx.r[11].s64 = ctx.r[11].s64 + 9944;
	// 825D37B8: 92E10080  stw r23, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 825D37BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D37C0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D37C4: 4BFFF885  bl 0x825d3048
	ctx.lr = 0x825D37C8;
	sub_825D3048(ctx, base);
	// 825D37C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D37CC: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D37D0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 825D37D4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825D37D8: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825D37DC: 389A0154  addi r4, r26, 0x154
	ctx.r[4].s64 = ctx.r[26].s64 + 340;
	// 825D37E0: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 825D37E4: C06B9528  lfs f3, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825D37E8: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825D37EC: C0290790  lfs f1, 0x790(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D37F0: 4BFCF931  bl 0x825a3120
	ctx.lr = 0x825D37F4;
	sub_825A3120(ctx, base);
	// 825D37F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D37F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D37FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3800: 4BFCDF71  bl 0x825a1770
	ctx.lr = 0x825D3804;
	sub_825A1770(ctx, base);
	// 825D3804: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 825D3808: 4881FC21  bl 0x82df3428
	ctx.lr = 0x825D380C;
	sub_82DF3428(ctx, base);
	// 825D380C: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 825D3810: 4BCF54A9  bl 0x822c8cb8
	ctx.lr = 0x825D3814;
	sub_822C8CB8(ctx, base);
	// 825D3814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3818: 4881FC11  bl 0x82df3428
	ctx.lr = 0x825D381C;
	sub_82DF3428(ctx, base);
	// 825D381C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D3820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3824: 388BE1A0  addi r4, r11, -0x1e60
	ctx.r[4].s64 = ctx.r[11].s64 + -7776;
	// 825D3828: 488201E1  bl 0x82df3a08
	ctx.lr = 0x825D382C;
	sub_82DF3A08(ctx, base);
	// 825D382C: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D3830: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D3834: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825D3838: 396B26D8  addi r11, r11, 0x26d8
	ctx.r[11].s64 = ctx.r[11].s64 + 9944;
	// 825D383C: 92E10080  stw r23, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 825D3840: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D3844: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D3848: 4BFFF881  bl 0x825d30c8
	ctx.lr = 0x825D384C;
	sub_825D30C8(ctx, base);
	// 825D384C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D3850: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3854: 389A0158  addi r4, r26, 0x158
	ctx.r[4].s64 = ctx.r[26].s64 + 344;
	// 825D3858: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825D385C: 4BFCF77D  bl 0x825a2fd8
	ctx.lr = 0x825D3860;
	sub_825A2FD8(ctx, base);
	// 825D3860: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D3864: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D386C: 4BFCE91D  bl 0x825a2188
	ctx.lr = 0x825D3870;
	sub_825A2188(ctx, base);
	// 825D3870: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825D3874: 4881FBB5  bl 0x82df3428
	ctx.lr = 0x825D3878;
	sub_82DF3428(ctx, base);
	// 825D3878: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825D387C: 4BCF543D  bl 0x822c8cb8
	ctx.lr = 0x825D3880;
	sub_822C8CB8(ctx, base);
	// 825D3880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3884: 4881FBA5  bl 0x82df3428
	ctx.lr = 0x825D3888;
	sub_82DF3428(ctx, base);
	// 825D3888: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D388C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3890: 388BE190  addi r4, r11, -0x1e70
	ctx.r[4].s64 = ctx.r[11].s64 + -7792;
	// 825D3894: 48820175  bl 0x82df3a08
	ctx.lr = 0x825D3898;
	sub_82DF3A08(ctx, base);
	// 825D3898: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D389C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D38A0: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825D38A4: 396B2F68  addi r11, r11, 0x2f68
	ctx.r[11].s64 = ctx.r[11].s64 + 12136;
	// 825D38A8: 92E10080  stw r23, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 825D38AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D38B0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D38B4: 4BFFF815  bl 0x825d30c8
	ctx.lr = 0x825D38B8;
	sub_825D30C8(ctx, base);
	// 825D38B8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D38BC: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D38C0: 389A0159  addi r4, r26, 0x159
	ctx.r[4].s64 = ctx.r[26].s64 + 345;
	// 825D38C4: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 825D38C8: 4BFCF711  bl 0x825a2fd8
	ctx.lr = 0x825D38CC;
	sub_825A2FD8(ctx, base);
	// 825D38CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D38D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D38D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D38D8: 4BFCE8B1  bl 0x825a2188
	ctx.lr = 0x825D38DC;
	sub_825A2188(ctx, base);
	// 825D38DC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 825D38E0: 4881FB49  bl 0x82df3428
	ctx.lr = 0x825D38E4;
	sub_82DF3428(ctx, base);
	// 825D38E4: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825D38E8: 4BCF53D1  bl 0x822c8cb8
	ctx.lr = 0x825D38EC;
	sub_822C8CB8(ctx, base);
	// 825D38EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D38F0: 4881FB39  bl 0x82df3428
	ctx.lr = 0x825D38F4;
	sub_82DF3428(ctx, base);
	// 825D38F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D38F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D38FC: 388BE184  addi r4, r11, -0x1e7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7804;
	// 825D3900: 48820109  bl 0x82df3a08
	ctx.lr = 0x825D3904;
	sub_82DF3A08(ctx, base);
	// 825D3904: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D3908: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D390C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825D3910: 396B26D8  addi r11, r11, 0x26d8
	ctx.r[11].s64 = ctx.r[11].s64 + 9944;
	// 825D3914: 92E10080  stw r23, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[23].u32 ) };
	// 825D3918: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D391C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D3920: 4BFFF729  bl 0x825d3048
	ctx.lr = 0x825D3924;
	sub_825D3048(ctx, base);
	// 825D3924: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D3928: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D392C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825D3930: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825D3934: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825D3938: 389A0148  addi r4, r26, 0x148
	ctx.r[4].s64 = ctx.r[26].s64 + 328;
	// 825D393C: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 825D3940: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825D3944: C04A9F64  lfs f2, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825D3948: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D394C: 4BFCF7D5  bl 0x825a3120
	ctx.lr = 0x825D3950;
	sub_825A3120(ctx, base);
	// 825D3950: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D3954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D395C: 4BFCDE15  bl 0x825a1770
	ctx.lr = 0x825D3960;
	sub_825A1770(ctx, base);
	// 825D3960: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 825D3964: 4881FAC5  bl 0x82df3428
	ctx.lr = 0x825D3968;
	sub_82DF3428(ctx, base);
	// 825D3968: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 825D396C: 4BCF534D  bl 0x822c8cb8
	ctx.lr = 0x825D3970;
	sub_822C8CB8(ctx, base);
	// 825D3970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3974: 4881FAB5  bl 0x82df3428
	ctx.lr = 0x825D3978;
	sub_82DF3428(ctx, base);
	// 825D3978: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D397C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3980: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 825D3984: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D3988: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 825D398C: 4881EA5D  bl 0x82df23e8
	ctx.lr = 0x825D3990;
	sub_82DF23E8(ctx, base);
	// 825D3990: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D3994: 4182006C  beq 0x825d3a00
	if ctx.cr[0].eq {
	pc = 0x825D3A00; continue 'dispatch;
	}
	// 825D3998: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D399C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D39A0: 48820069  bl 0x82df3a08
	ctx.lr = 0x825D39A4;
	sub_82DF3A08(ctx, base);
	// 825D39A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D39A8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D39AC: 63180002  ori r24, r24, 2
	ctx.r[24].u64 = ctx.r[24].u64 | 2;
	// 825D39B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D39B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D39B8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D39BC: 419A0024  beq cr6, 0x825d39e0
	if ctx.cr[6].eq {
	pc = 0x825D39E0; continue 'dispatch;
	}
	// 825D39C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D39C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D39C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D39CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D39D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D39D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D39D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D39DC: 4082FFE8  bne 0x825d39c4
	if !ctx.cr[0].eq {
	pc = 0x825D39C4; continue 'dispatch;
	}
	// 825D39E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D39E4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D39E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D39EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D39F0: 4BFE4B89  bl 0x825b8578
	ctx.lr = 0x825D39F4;
	sub_825B8578(ctx, base);
	// 825D39F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D39F8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825D39FC: 48000008  b 0x825d3a04
	pc = 0x825D3A04; continue 'dispatch;
	// 825D3A00: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3A04: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D3A08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3A0C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3A10: 4BFE1F29  bl 0x825b5938
	ctx.lr = 0x825D3A14;
	sub_825B5938(ctx, base);
	// 825D3A14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3A18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3A1C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3A20: 4BCEC5E1  bl 0x822c0000
	ctx.lr = 0x825D3A24;
	sub_822C0000(ctx, base);
	// 825D3A24: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D3A28: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D3A2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3A30: 93E100C4  stw r31, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[31].u32 ) };
	// 825D3A34: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D3A38: 419A0024  beq cr6, 0x825d3a5c
	if ctx.cr[6].eq {
	pc = 0x825D3A5C; continue 'dispatch;
	}
	// 825D3A3C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825D3A40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3A44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3A48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3A4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3A50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3A54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3A58: 4082FFE8  bne 0x825d3a40
	if !ctx.cr[0].eq {
	pc = 0x825D3A40; continue 'dispatch;
	}
	// 825D3A5C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D3A60: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825D3A64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D3A68: 4BFE32A9  bl 0x825b6d10
	ctx.lr = 0x825D3A6C;
	sub_825B6D10(ctx, base);
	// 825D3A6C: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D3A70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D3A74: 419A0008  beq cr6, 0x825d3a7c
	if ctx.cr[6].eq {
	pc = 0x825D3A7C; continue 'dispatch;
	}
	// 825D3A78: 4BCECE19  bl 0x822c0890
	ctx.lr = 0x825D3A7C;
	sub_822C0890(ctx, base);
	// 825D3A7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3A80: 419A000C  beq cr6, 0x825d3a8c
	if ctx.cr[6].eq {
	pc = 0x825D3A8C; continue 'dispatch;
	}
	// 825D3A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3A88: 4BCECE09  bl 0x822c0890
	ctx.lr = 0x825D3A8C;
	sub_822C0890(ctx, base);
	// 825D3A8C: 570B07BD  rlwinm. r11, r24, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3A90: 41820010  beq 0x825d3aa0
	if ctx.cr[0].eq {
	pc = 0x825D3AA0; continue 'dispatch;
	}
	// 825D3A94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3A98: 571807FA  rlwinm r24, r24, 0, 0x1f, 0x1d
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D3A9C: 4881F98D  bl 0x82df3428
	ctx.lr = 0x825D3AA0;
	sub_82DF3428(ctx, base);
	// 825D3AA0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D3AA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3AA8: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 825D3AAC: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D3AB0: 4881E939  bl 0x82df23e8
	ctx.lr = 0x825D3AB4;
	sub_82DF23E8(ctx, base);
	// 825D3AB4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D3AB8: 41820070  beq 0x825d3b28
	if ctx.cr[0].eq {
	pc = 0x825D3B28; continue 'dispatch;
	}
	// 825D3ABC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D3AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3AC4: 388BE174  addi r4, r11, -0x1e8c
	ctx.r[4].s64 = ctx.r[11].s64 + -7820;
	// 825D3AC8: 4881FF41  bl 0x82df3a08
	ctx.lr = 0x825D3ACC;
	sub_82DF3A08(ctx, base);
	// 825D3ACC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3AD0: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3AD4: 63180004  ori r24, r24, 4
	ctx.r[24].u64 = ctx.r[24].u64 | 4;
	// 825D3AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D3ADC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D3AE0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D3AE4: 419A0024  beq cr6, 0x825d3b08
	if ctx.cr[6].eq {
	pc = 0x825D3B08; continue 'dispatch;
	}
	// 825D3AE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D3AEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3AF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3AF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3AF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3AFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3B00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3B04: 4082FFE8  bne 0x825d3aec
	if !ctx.cr[0].eq {
	pc = 0x825D3AEC; continue 'dispatch;
	}
	// 825D3B08: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825D3B0C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D3B10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3B14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3B18: 4BFE4A61  bl 0x825b8578
	ctx.lr = 0x825D3B1C;
	sub_825B8578(ctx, base);
	// 825D3B1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D3B20: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825D3B24: 48000008  b 0x825d3b2c
	pc = 0x825D3B2C; continue 'dispatch;
	// 825D3B28: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3B2C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D3B30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3B34: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3B38: 4BFE1E01  bl 0x825b5938
	ctx.lr = 0x825D3B3C;
	sub_825B5938(ctx, base);
	// 825D3B3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3B40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3B44: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3B48: 4BCEC4B9  bl 0x822c0000
	ctx.lr = 0x825D3B4C;
	sub_822C0000(ctx, base);
	// 825D3B4C: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D3B50: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D3B54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3B58: 93E100BC  stw r31, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u32 ) };
	// 825D3B5C: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 825D3B60: 419A0024  beq cr6, 0x825d3b84
	if ctx.cr[6].eq {
	pc = 0x825D3B84; continue 'dispatch;
	}
	// 825D3B64: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825D3B68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3B6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3B70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3B74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3B78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3B7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3B80: 4082FFE8  bne 0x825d3b68
	if !ctx.cr[0].eq {
	pc = 0x825D3B68; continue 'dispatch;
	}
	// 825D3B84: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D3B88: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 825D3B8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D3B90: 4BFE3181  bl 0x825b6d10
	ctx.lr = 0x825D3B94;
	sub_825B6D10(ctx, base);
	// 825D3B94: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825D3B98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D3B9C: 419A0008  beq cr6, 0x825d3ba4
	if ctx.cr[6].eq {
	pc = 0x825D3BA4; continue 'dispatch;
	}
	// 825D3BA0: 4BCECCF1  bl 0x822c0890
	ctx.lr = 0x825D3BA4;
	sub_822C0890(ctx, base);
	// 825D3BA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3BA8: 419A000C  beq cr6, 0x825d3bb4
	if ctx.cr[6].eq {
	pc = 0x825D3BB4; continue 'dispatch;
	}
	// 825D3BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3BB0: 4BCECCE1  bl 0x822c0890
	ctx.lr = 0x825D3BB4;
	sub_822C0890(ctx, base);
	// 825D3BB4: 570B077B  rlwinm. r11, r24, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3BB8: 41820010  beq 0x825d3bc8
	if ctx.cr[0].eq {
	pc = 0x825D3BC8; continue 'dispatch;
	}
	// 825D3BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3BC0: 571807B8  rlwinm r24, r24, 0, 0x1e, 0x1c
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D3BC4: 4881F865  bl 0x82df3428
	ctx.lr = 0x825D3BC8;
	sub_82DF3428(ctx, base);
	// 825D3BC8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D3BCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3BD0: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 825D3BD4: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 825D3BD8: 4881E811  bl 0x82df23e8
	ctx.lr = 0x825D3BDC;
	sub_82DF23E8(ctx, base);
	// 825D3BDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D3BE0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D3BE4: 3BCBC02C  addi r30, r11, -0x3fd4
	ctx.r[30].s64 = ctx.r[11].s64 + -16340;
	// 825D3BE8: 41820028  beq 0x825d3c10
	if ctx.cr[0].eq {
	pc = 0x825D3C10; continue 'dispatch;
	}
	// 825D3BEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D3BF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3BF4: 4881FE15  bl 0x82df3a08
	ctx.lr = 0x825D3BF8;
	sub_82DF3A08(ctx, base);
	// 825D3BF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3C00: 63180008  ori r24, r24, 8
	ctx.r[24].u64 = ctx.r[24].u64 | 8;
	// 825D3C04: 4BFE46B5  bl 0x825b82b8
	ctx.lr = 0x825D3C08;
	sub_825B82B8(ctx, base);
	// 825D3C08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D3C0C: 48000008  b 0x825d3c14
	pc = 0x825D3C14; continue 'dispatch;
	// 825D3C10: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3C14: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 825D3C18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3C1C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825D3C20: 4BFE07F9  bl 0x825b4418
	ctx.lr = 0x825D3C24;
	sub_825B4418(ctx, base);
	// 825D3C24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3C28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3C2C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825D3C30: 4BCEC3D1  bl 0x822c0000
	ctx.lr = 0x825D3C34;
	sub_822C0000(ctx, base);
	// 825D3C34: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825D3C38: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D3C3C: 4BFE3085  bl 0x825b6cc0
	ctx.lr = 0x825D3C40;
	sub_825B6CC0(ctx, base);
	// 825D3C40: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D3C44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D3C48: 419A0008  beq cr6, 0x825d3c50
	if ctx.cr[6].eq {
	pc = 0x825D3C50; continue 'dispatch;
	}
	// 825D3C4C: 4BCECC45  bl 0x822c0890
	ctx.lr = 0x825D3C50;
	sub_822C0890(ctx, base);
	// 825D3C50: 570B0739  rlwinm. r11, r24, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3C54: 41820010  beq 0x825d3c64
	if ctx.cr[0].eq {
	pc = 0x825D3C64; continue 'dispatch;
	}
	// 825D3C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3C5C: 57180776  rlwinm r24, r24, 0, 0x1d, 0x1b
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D3C60: 4881F7C9  bl 0x82df3428
	ctx.lr = 0x825D3C64;
	sub_82DF3428(ctx, base);
	// 825D3C64: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D3C68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3C6C: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 825D3C70: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D3C74: 4881E775  bl 0x82df23e8
	ctx.lr = 0x825D3C78;
	sub_82DF23E8(ctx, base);
	// 825D3C78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D3C7C: 41820070  beq 0x825d3cec
	if ctx.cr[0].eq {
	pc = 0x825D3CEC; continue 'dispatch;
	}
	// 825D3C80: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825D3C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3C88: 388B7C4C  addi r4, r11, 0x7c4c
	ctx.r[4].s64 = ctx.r[11].s64 + 31820;
	// 825D3C8C: 4881FD7D  bl 0x82df3a08
	ctx.lr = 0x825D3C90;
	sub_82DF3A08(ctx, base);
	// 825D3C90: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3C94: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3C98: 63180010  ori r24, r24, 0x10
	ctx.r[24].u64 = ctx.r[24].u64 | 16;
	// 825D3C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D3CA0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D3CA4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D3CA8: 419A0024  beq cr6, 0x825d3ccc
	if ctx.cr[6].eq {
	pc = 0x825D3CCC; continue 'dispatch;
	}
	// 825D3CAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D3CB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3CB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3CB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3CBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3CC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3CC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3CC8: 4082FFE8  bne 0x825d3cb0
	if !ctx.cr[0].eq {
	pc = 0x825D3CB0; continue 'dispatch;
	}
	// 825D3CCC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825D3CD0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D3CD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3CDC: 4BFE489D  bl 0x825b8578
	ctx.lr = 0x825D3CE0;
	sub_825B8578(ctx, base);
	// 825D3CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D3CE4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825D3CE8: 48000008  b 0x825d3cf0
	pc = 0x825D3CF0; continue 'dispatch;
	// 825D3CEC: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3CF0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D3CF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3CF8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3CFC: 4BFE1C3D  bl 0x825b5938
	ctx.lr = 0x825D3D00;
	sub_825B5938(ctx, base);
	// 825D3D00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3D04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3D08: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3D0C: 4BCEC2F5  bl 0x822c0000
	ctx.lr = 0x825D3D10;
	sub_822C0000(ctx, base);
	// 825D3D10: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D3D14: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D3D18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3D1C: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 825D3D20: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 825D3D24: 419A0024  beq cr6, 0x825d3d48
	if ctx.cr[6].eq {
	pc = 0x825D3D48; continue 'dispatch;
	}
	// 825D3D28: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825D3D2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3D30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3D34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3D38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3D3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3D40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3D44: 4082FFE8  bne 0x825d3d2c
	if !ctx.cr[0].eq {
	pc = 0x825D3D2C; continue 'dispatch;
	}
	// 825D3D48: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D3D4C: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 825D3D50: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D3D54: 4BFE2FBD  bl 0x825b6d10
	ctx.lr = 0x825D3D58;
	sub_825B6D10(ctx, base);
	// 825D3D58: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825D3D5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D3D60: 419A0008  beq cr6, 0x825d3d68
	if ctx.cr[6].eq {
	pc = 0x825D3D68; continue 'dispatch;
	}
	// 825D3D64: 4BCECB2D  bl 0x822c0890
	ctx.lr = 0x825D3D68;
	sub_822C0890(ctx, base);
	// 825D3D68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3D6C: 419A000C  beq cr6, 0x825d3d78
	if ctx.cr[6].eq {
	pc = 0x825D3D78; continue 'dispatch;
	}
	// 825D3D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3D74: 4BCECB1D  bl 0x822c0890
	ctx.lr = 0x825D3D78;
	sub_822C0890(ctx, base);
	// 825D3D78: 570B06F7  rlwinm. r11, r24, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3D7C: 41820010  beq 0x825d3d8c
	if ctx.cr[0].eq {
	pc = 0x825D3D8C; continue 'dispatch;
	}
	// 825D3D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3D84: 57180734  rlwinm r24, r24, 0, 0x1c, 0x1a
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D3D88: 4881F6A1  bl 0x82df3428
	ctx.lr = 0x825D3D8C;
	sub_82DF3428(ctx, base);
	// 825D3D8C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D3D90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3D94: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 825D3D98: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D3D9C: 4881E64D  bl 0x82df23e8
	ctx.lr = 0x825D3DA0;
	sub_82DF23E8(ctx, base);
	// 825D3DA0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D3DA4: 41820070  beq 0x825d3e14
	if ctx.cr[0].eq {
	pc = 0x825D3E14; continue 'dispatch;
	}
	// 825D3DA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D3DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3DB0: 388BE164  addi r4, r11, -0x1e9c
	ctx.r[4].s64 = ctx.r[11].s64 + -7836;
	// 825D3DB4: 4881FC55  bl 0x82df3a08
	ctx.lr = 0x825D3DB8;
	sub_82DF3A08(ctx, base);
	// 825D3DB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3DBC: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3DC0: 63180020  ori r24, r24, 0x20
	ctx.r[24].u64 = ctx.r[24].u64 | 32;
	// 825D3DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D3DC8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D3DCC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D3DD0: 419A0024  beq cr6, 0x825d3df4
	if ctx.cr[6].eq {
	pc = 0x825D3DF4; continue 'dispatch;
	}
	// 825D3DD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D3DD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3DDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3DE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3DE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3DE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3DEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3DF0: 4082FFE8  bne 0x825d3dd8
	if !ctx.cr[0].eq {
	pc = 0x825D3DD8; continue 'dispatch;
	}
	// 825D3DF4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825D3DF8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D3DFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3E04: 4BFE4775  bl 0x825b8578
	ctx.lr = 0x825D3E08;
	sub_825B8578(ctx, base);
	// 825D3E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D3E0C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825D3E10: 48000008  b 0x825d3e18
	pc = 0x825D3E18; continue 'dispatch;
	// 825D3E14: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3E18: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D3E1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3E20: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3E24: 4BFE1B15  bl 0x825b5938
	ctx.lr = 0x825D3E28;
	sub_825B5938(ctx, base);
	// 825D3E28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3E2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3E30: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3E34: 4BCEC1CD  bl 0x822c0000
	ctx.lr = 0x825D3E38;
	sub_822C0000(ctx, base);
	// 825D3E38: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D3E3C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D3E40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3E44: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 825D3E48: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 825D3E4C: 419A0024  beq cr6, 0x825d3e70
	if ctx.cr[6].eq {
	pc = 0x825D3E70; continue 'dispatch;
	}
	// 825D3E50: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825D3E54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3E58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3E5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3E60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3E64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3E68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3E6C: 4082FFE8  bne 0x825d3e54
	if !ctx.cr[0].eq {
	pc = 0x825D3E54; continue 'dispatch;
	}
	// 825D3E70: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D3E74: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825D3E78: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D3E7C: 4BFE2E95  bl 0x825b6d10
	ctx.lr = 0x825D3E80;
	sub_825B6D10(ctx, base);
	// 825D3E80: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825D3E84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D3E88: 419A0008  beq cr6, 0x825d3e90
	if ctx.cr[6].eq {
	pc = 0x825D3E90; continue 'dispatch;
	}
	// 825D3E8C: 4BCECA05  bl 0x822c0890
	ctx.lr = 0x825D3E90;
	sub_822C0890(ctx, base);
	// 825D3E90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3E94: 419A000C  beq cr6, 0x825d3ea0
	if ctx.cr[6].eq {
	pc = 0x825D3EA0; continue 'dispatch;
	}
	// 825D3E98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3E9C: 4BCEC9F5  bl 0x822c0890
	ctx.lr = 0x825D3EA0;
	sub_822C0890(ctx, base);
	// 825D3EA0: 570B06B5  rlwinm. r11, r24, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3EA4: 41820010  beq 0x825d3eb4
	if ctx.cr[0].eq {
	pc = 0x825D3EB4; continue 'dispatch;
	}
	// 825D3EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3EAC: 571806F2  rlwinm r24, r24, 0, 0x1b, 0x19
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D3EB0: 4881F579  bl 0x82df3428
	ctx.lr = 0x825D3EB4;
	sub_82DF3428(ctx, base);
	// 825D3EB4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D3EB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3EBC: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 825D3EC0: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D3EC4: 4881E525  bl 0x82df23e8
	ctx.lr = 0x825D3EC8;
	sub_82DF23E8(ctx, base);
	// 825D3EC8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D3ECC: 41820070  beq 0x825d3f3c
	if ctx.cr[0].eq {
	pc = 0x825D3F3C; continue 'dispatch;
	}
	// 825D3ED0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D3ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3ED8: 388BE148  addi r4, r11, -0x1eb8
	ctx.r[4].s64 = ctx.r[11].s64 + -7864;
	// 825D3EDC: 4881FB2D  bl 0x82df3a08
	ctx.lr = 0x825D3EE0;
	sub_82DF3A08(ctx, base);
	// 825D3EE0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3EE4: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3EE8: 63180040  ori r24, r24, 0x40
	ctx.r[24].u64 = ctx.r[24].u64 | 64;
	// 825D3EEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D3EF0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D3EF4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D3EF8: 419A0024  beq cr6, 0x825d3f1c
	if ctx.cr[6].eq {
	pc = 0x825D3F1C; continue 'dispatch;
	}
	// 825D3EFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D3F00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3F04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3F08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3F0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3F10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3F14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3F18: 4082FFE8  bne 0x825d3f00
	if !ctx.cr[0].eq {
	pc = 0x825D3F00; continue 'dispatch;
	}
	// 825D3F1C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825D3F20: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D3F24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3F2C: 4BFE464D  bl 0x825b8578
	ctx.lr = 0x825D3F30;
	sub_825B8578(ctx, base);
	// 825D3F30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D3F34: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825D3F38: 48000008  b 0x825d3f40
	pc = 0x825D3F40; continue 'dispatch;
	// 825D3F3C: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D3F40: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D3F44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3F48: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3F4C: 4BFE19ED  bl 0x825b5938
	ctx.lr = 0x825D3F50;
	sub_825B5938(ctx, base);
	// 825D3F50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D3F54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D3F58: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D3F5C: 4BCEC0A5  bl 0x822c0000
	ctx.lr = 0x825D3F60;
	sub_822C0000(ctx, base);
	// 825D3F60: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D3F64: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D3F68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3F6C: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 825D3F70: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 825D3F74: 419A0024  beq cr6, 0x825d3f98
	if ctx.cr[6].eq {
	pc = 0x825D3F98; continue 'dispatch;
	}
	// 825D3F78: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825D3F7C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3F80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3F84: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D3F88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3F8C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3F90: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3F94: 4082FFE8  bne 0x825d3f7c
	if !ctx.cr[0].eq {
	pc = 0x825D3F7C; continue 'dispatch;
	}
	// 825D3F98: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D3F9C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825D3FA0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D3FA4: 4BFE2D6D  bl 0x825b6d10
	ctx.lr = 0x825D3FA8;
	sub_825B6D10(ctx, base);
	// 825D3FA8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825D3FAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D3FB0: 419A0008  beq cr6, 0x825d3fb8
	if ctx.cr[6].eq {
	pc = 0x825D3FB8; continue 'dispatch;
	}
	// 825D3FB4: 4BCEC8DD  bl 0x822c0890
	ctx.lr = 0x825D3FB8;
	sub_822C0890(ctx, base);
	// 825D3FB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D3FBC: 419A000C  beq cr6, 0x825d3fc8
	if ctx.cr[6].eq {
	pc = 0x825D3FC8; continue 'dispatch;
	}
	// 825D3FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3FC4: 4BCEC8CD  bl 0x822c0890
	ctx.lr = 0x825D3FC8;
	sub_822C0890(ctx, base);
	// 825D3FC8: 570B0673  rlwinm. r11, r24, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3FCC: 41820010  beq 0x825d3fdc
	if ctx.cr[0].eq {
	pc = 0x825D3FDC; continue 'dispatch;
	}
	// 825D3FD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D3FD4: 571806B0  rlwinm r24, r24, 0, 0x1a, 0x18
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D3FD8: 4881F451  bl 0x82df3428
	ctx.lr = 0x825D3FDC;
	sub_82DF3428(ctx, base);
	// 825D3FDC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D3FE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D3FE4: 38A0005D  li r5, 0x5d
	ctx.r[5].s64 = 93;
	// 825D3FE8: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 825D3FEC: 4881E3FD  bl 0x82df23e8
	ctx.lr = 0x825D3FF0;
	sub_82DF23E8(ctx, base);
	// 825D3FF0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D3FF4: 41820028  beq 0x825d401c
	if ctx.cr[0].eq {
	pc = 0x825D401C; continue 'dispatch;
	}
	// 825D3FF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D3FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4000: 4881FA09  bl 0x82df3a08
	ctx.lr = 0x825D4004;
	sub_82DF3A08(ctx, base);
	// 825D4004: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D4008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D400C: 63180080  ori r24, r24, 0x80
	ctx.r[24].u64 = ctx.r[24].u64 | 128;
	// 825D4010: 4BFE42A9  bl 0x825b82b8
	ctx.lr = 0x825D4014;
	sub_825B82B8(ctx, base);
	// 825D4014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D4018: 48000008  b 0x825d4020
	pc = 0x825D4020; continue 'dispatch;
	// 825D401C: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D4020: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825D4024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4028: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825D402C: 4BFE03ED  bl 0x825b4418
	ctx.lr = 0x825D4030;
	sub_825B4418(ctx, base);
	// 825D4030: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D4034: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4038: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825D403C: 4BCEBFC5  bl 0x822c0000
	ctx.lr = 0x825D4040;
	sub_822C0000(ctx, base);
	// 825D4040: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825D4044: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D4048: 4BFE2C79  bl 0x825b6cc0
	ctx.lr = 0x825D404C;
	sub_825B6CC0(ctx, base);
	// 825D404C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D4050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4054: 419A0008  beq cr6, 0x825d405c
	if ctx.cr[6].eq {
	pc = 0x825D405C; continue 'dispatch;
	}
	// 825D4058: 4BCEC839  bl 0x822c0890
	ctx.lr = 0x825D405C;
	sub_822C0890(ctx, base);
	// 825D405C: 570B0631  rlwinm. r11, r24, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4060: 41820010  beq 0x825d4070
	if ctx.cr[0].eq {
	pc = 0x825D4070; continue 'dispatch;
	}
	// 825D4064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4068: 5718066E  rlwinm r24, r24, 0, 0x19, 0x17
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D406C: 4881F3BD  bl 0x82df3428
	ctx.lr = 0x825D4070;
	sub_82DF3428(ctx, base);
	// 825D4070: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D4074: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D4078: 38A0005E  li r5, 0x5e
	ctx.r[5].s64 = 94;
	// 825D407C: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D4080: 4881E369  bl 0x82df23e8
	ctx.lr = 0x825D4084;
	sub_82DF23E8(ctx, base);
	// 825D4084: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D4088: 4182006C  beq 0x825d40f4
	if ctx.cr[0].eq {
	pc = 0x825D40F4; continue 'dispatch;
	}
	// 825D408C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D4090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4094: 388BE138  addi r4, r11, -0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + -7880;
	// 825D4098: 4881F971  bl 0x82df3a08
	ctx.lr = 0x825D409C;
	sub_82DF3A08(ctx, base);
	// 825D409C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D40A0: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D40A4: 63180100  ori r24, r24, 0x100
	ctx.r[24].u64 = ctx.r[24].u64 | 256;
	// 825D40A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D40AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D40B0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D40B4: 419A0024  beq cr6, 0x825d40d8
	if ctx.cr[6].eq {
	pc = 0x825D40D8; continue 'dispatch;
	}
	// 825D40B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D40BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D40C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D40C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D40C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D40CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D40D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D40D4: 4082FFE8  bne 0x825d40bc
	if !ctx.cr[0].eq {
	pc = 0x825D40BC; continue 'dispatch;
	}
	// 825D40D8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825D40DC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D40E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D40E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D40E8: 4BFE4491  bl 0x825b8578
	ctx.lr = 0x825D40EC;
	sub_825B8578(ctx, base);
	// 825D40EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D40F0: 48000008  b 0x825d40f8
	pc = 0x825D40F8; continue 'dispatch;
	// 825D40F4: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D40F8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D40FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4100: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D4104: 4BFE1835  bl 0x825b5938
	ctx.lr = 0x825D4108;
	sub_825B5938(ctx, base);
	// 825D4108: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D410C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4110: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D4114: 4BCEBEED  bl 0x822c0000
	ctx.lr = 0x825D4118;
	sub_822C0000(ctx, base);
	// 825D4118: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D411C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D4120: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D4124: 93E100CC  stw r31, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[31].u32 ) };
	// 825D4128: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 825D412C: 419A0024  beq cr6, 0x825d4150
	if ctx.cr[6].eq {
	pc = 0x825D4150; continue 'dispatch;
	}
	// 825D4130: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825D4134: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D4138: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D413C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D4140: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D4144: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D4148: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D414C: 4082FFE8  bne 0x825d4134
	if !ctx.cr[0].eq {
	pc = 0x825D4134; continue 'dispatch;
	}
	// 825D4150: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825D4154: 388100C8  addi r4, r1, 0xc8
	ctx.r[4].s64 = ctx.r[1].s64 + 200;
	// 825D4158: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D415C: 4BFE2BB5  bl 0x825b6d10
	ctx.lr = 0x825D4160;
	sub_825B6D10(ctx, base);
	// 825D4160: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825D4164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4168: 419A0008  beq cr6, 0x825d4170
	if ctx.cr[6].eq {
	pc = 0x825D4170; continue 'dispatch;
	}
	// 825D416C: 4BCEC725  bl 0x822c0890
	ctx.lr = 0x825D4170;
	sub_822C0890(ctx, base);
	// 825D4170: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D4174: 419A000C  beq cr6, 0x825d4180
	if ctx.cr[6].eq {
	pc = 0x825D4180; continue 'dispatch;
	}
	// 825D4178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D417C: 4BCEC715  bl 0x822c0890
	ctx.lr = 0x825D4180;
	sub_822C0890(ctx, base);
	// 825D4180: 570B05EF  rlwinm. r11, r24, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4184: 41820010  beq 0x825d4194
	if ctx.cr[0].eq {
	pc = 0x825D4194; continue 'dispatch;
	}
	// 825D4188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D418C: 5718062C  rlwinm r24, r24, 0, 0x18, 0x16
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D4190: 4881F299  bl 0x82df3428
	ctx.lr = 0x825D4194;
	sub_82DF3428(ctx, base);
	// 825D4194: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825D4198: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D419C: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 825D41A0: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 825D41A4: 4881E245  bl 0x82df23e8
	ctx.lr = 0x825D41A8;
	sub_82DF23E8(ctx, base);
	// 825D41A8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D41AC: 41820054  beq 0x825d4200
	if ctx.cr[0].eq {
	pc = 0x825D4200; continue 'dispatch;
	}
	// 825D41B0: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D41B4: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825D41B8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825D41BC: 92E100D0  stw r23, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[23].u32 ) };
	// 825D41C0: 396B2A70  addi r11, r11, 0x2a70
	ctx.r[11].s64 = ctx.r[11].s64 + 10864;
	// 825D41C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D41C8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D41CC: 4BFFEF7D  bl 0x825d3148
	ctx.lr = 0x825D41D0;
	sub_825D3148(ctx, base);
	// 825D41D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D41D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D41D8: 388BE130  addi r4, r11, -0x1ed0
	ctx.r[4].s64 = ctx.r[11].s64 + -7888;
	// 825D41DC: 631E0200  ori r30, r24, 0x200
	ctx.r[30].u64 = ctx.r[24].u64 | 512;
	// 825D41E0: 4881F829  bl 0x82df3a08
	ctx.lr = 0x825D41E4;
	sub_82DF3A08(ctx, base);
	// 825D41E4: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 825D41E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D41EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D41F0: 63D80400  ori r24, r30, 0x400
	ctx.r[24].u64 = ctx.r[30].u64 | 1024;
	// 825D41F4: 4BFFE3D5  bl 0x825d25c8
	ctx.lr = 0x825D41F8;
	sub_825D25C8(ctx, base);
	// 825D41F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D41FC: 48000008  b 0x825d4204
	pc = 0x825D4204; continue 'dispatch;
	// 825D4200: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 825D4204: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 825D4208: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D420C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825D4210: 4BFE1CA1  bl 0x825b5eb0
	ctx.lr = 0x825D4214;
	sub_825B5EB0(ctx, base);
	// 825D4214: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D4218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D421C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825D4220: 4BCEBDE1  bl 0x822c0000
	ctx.lr = 0x825D4224;
	sub_822C0000(ctx, base);
	// 825D4224: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825D4228: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D422C: 4BFE27C5  bl 0x825b69f0
	ctx.lr = 0x825D4230;
	sub_825B69F0(ctx, base);
	// 825D4230: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D4234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4238: 419A0008  beq cr6, 0x825d4240
	if ctx.cr[6].eq {
	pc = 0x825D4240; continue 'dispatch;
	}
	// 825D423C: 4BCEC655  bl 0x822c0890
	ctx.lr = 0x825D4240;
	sub_822C0890(ctx, base);
	// 825D4240: 570B056B  rlwinm. r11, r24, 0, 0x15, 0x15
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4244: 41820010  beq 0x825d4254
	if ctx.cr[0].eq {
	pc = 0x825D4254; continue 'dispatch;
	}
	// 825D4248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D424C: 571805A8  rlwinm r24, r24, 0, 0x16, 0x14
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825D4250: 4881F1D9  bl 0x82df3428
	ctx.lr = 0x825D4254;
	sub_82DF3428(ctx, base);
	// 825D4254: 570B05AD  rlwinm. r11, r24, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4258: 4182000C  beq 0x825d4264
	if ctx.cr[0].eq {
	pc = 0x825D4264; continue 'dispatch;
	}
	// 825D425C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825D4260: 4BCF4A59  bl 0x822c8cb8
	ctx.lr = 0x825D4264;
	sub_822C8CB8(ctx, base);
	// 825D4264: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 825D4268: 419A000C  beq cr6, 0x825d4274
	if ctx.cr[6].eq {
	pc = 0x825D4274; continue 'dispatch;
	}
	// 825D426C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825D4270: 4BCEC621  bl 0x822c0890
	ctx.lr = 0x825D4274;
	sub_822C0890(ctx, base);
	// 825D4274: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 825D4278: 48BD3F20  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4280 size=196
    let mut pc: u32 = 0x825D4280;
    'dispatch: loop {
        match pc {
            0x825D4280 => {
    //   block [0x825D4280..0x825D4344)
	// 825D4280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D4288: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D428C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D4290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D4298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D429C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D42A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D42A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D42A8: 4BCEC691  bl 0x822c0938
	ctx.lr = 0x825D42AC;
	sub_822C0938(ctx, base);
	// 825D42AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D42B0: 41820028  beq 0x825d42d8
	if ctx.cr[0].eq {
	pc = 0x825D42D8; continue 'dispatch;
	}
	// 825D42B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D42B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D42BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D42C0: 392BE1E8  addi r9, r11, -0x1e18
	ctx.r[9].s64 = ctx.r[11].s64 + -7704;
	// 825D42C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D42C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D42CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D42D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D42D4: 48000008  b 0x825d42dc
	pc = 0x825D42DC; continue 'dispatch;
	// 825D42D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D42DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D42E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D42E4: 409A0044  bne cr6, 0x825d4328
	if !ctx.cr[6].eq {
	pc = 0x825D4328; continue 'dispatch;
	}
	// 825D42E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D42EC: 419A001C  beq cr6, 0x825d4308
	if ctx.cr[6].eq {
	pc = 0x825D4308; continue 'dispatch;
	}
	// 825D42F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D42F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D42F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D42FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D4304: 4E800421  bctrl
	ctx.lr = 0x825D4308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D4308: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D430C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D4310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4314: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D4318: 816BBE2C  lwz r11, -0x41d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16852 as u32) ) } as u64;
	// 825D431C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D4320: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D4324: 4BCEBCDD  bl 0x822c0000
	ctx.lr = 0x825D4328;
	sub_822C0000(ctx, base);
	// 825D4328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D432C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D4330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D4334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D4338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D433C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D4340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4348 size=100
    let mut pc: u32 = 0x825D4348;
    'dispatch: loop {
        match pc {
            0x825D4348 => {
    //   block [0x825D4348..0x825D43AC)
	// 825D4348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D434C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D4350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D4354: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D435C: 4BF3CD95  bl 0x825110f0
	ctx.lr = 0x825D4360;
	sub_825110F0(ctx, base);
	// 825D4360: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D4364: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D4368: 392BE210  addi r9, r11, -0x1df0
	ctx.r[9].s64 = ctx.r[11].s64 + -7664;
	// 825D436C: 394AE1FC  addi r10, r10, -0x1e04
	ctx.r[10].s64 = ctx.r[10].s64 + -7684;
	// 825D4370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D4374: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D4378: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D437C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4380: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D4384: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 825D4388: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 825D438C: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 825D4390: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D4394: 997F00D1  stb r11, 0xd1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(209 as u32), ctx.r[11].u8 ) };
	// 825D4398: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D439C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D43A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D43A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D43A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D43B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D43B0 size=124
    let mut pc: u32 = 0x825D43B0;
    'dispatch: loop {
        match pc {
            0x825D43B0 => {
    //   block [0x825D43B0..0x825D442C)
	// 825D43B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D43B4: 48BD3DB9  bl 0x831a816c
	ctx.lr = 0x825D43B8;
	sub_831A8130(ctx, base);
	// 825D43B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D43BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D43C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D43C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D43C8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825D43CC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825D43D0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825D43D4: 4881E015  bl 0x82df23e8
	ctx.lr = 0x825D43D8;
	sub_82DF23E8(ctx, base);
	// 825D43D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D43DC: 4182001C  beq 0x825d43f8
	if ctx.cr[0].eq {
	pc = 0x825D43F8; continue 'dispatch;
	}
	// 825D43E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D43E4: 4888529D  bl 0x82e59680
	ctx.lr = 0x825D43E8;
	sub_82E59680(ctx, base);
	// 825D43E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D43EC: 396BE1E0  addi r11, r11, -0x1e20
	ctx.r[11].s64 = ctx.r[11].s64 + -7712;
	// 825D43F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D43F4: 48000008  b 0x825d43fc
	pc = 0x825D43FC; continue 'dispatch;
	// 825D43F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D43FC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D4400: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D4404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D440C: 4BFFFE75  bl 0x825d4280
	ctx.lr = 0x825D4410;
	sub_825D4280(ctx, base);
	// 825D4410: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D4414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D441C: 4BCEBBE5  bl 0x822c0000
	ctx.lr = 0x825D4420;
	sub_822C0000(ctx, base);
	// 825D4420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D4424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D4428: 48BD3D94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D4430 size=440
    let mut pc: u32 = 0x825D4430;
    'dispatch: loop {
        match pc {
            0x825D4430 => {
    //   block [0x825D4430..0x825D45E8)
	// 825D4430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4434: 48BD3D35  bl 0x831a8168
	ctx.lr = 0x825D4438;
	sub_831A8130(ctx, base);
	// 825D4438: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D443C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D4440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D4444: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D4448: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D444C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D4450: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825D4454: 4881D7A5  bl 0x82df1bf8
	ctx.lr = 0x825D4458;
	sub_82DF1BF8(ctx, base);
	// 825D4458: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D445C: 48572DFD  bl 0x82b47258
	ctx.lr = 0x825D4460;
	sub_82B47258(ctx, base);
	// 825D4460: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D4464: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D4468: 4881D829  bl 0x82df1c90
	ctx.lr = 0x825D446C;
	sub_82DF1C90(ctx, base);
	// 825D446C: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D4470: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D4474: 4BFDD6F5  bl 0x825b1b68
	ctx.lr = 0x825D4478;
	sub_825B1B68(ctx, base);
	// 825D4478: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D447C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D4480: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D4484: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825D4488: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825D448C: 4BFDDC75  bl 0x825b2100
	ctx.lr = 0x825D4490;
	sub_825B2100(ctx, base);
	// 825D4490: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D4494: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825D4498: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825D449C: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825D44A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D44A4: 48BD406D  bl 0x831a8510
	ctx.lr = 0x825D44A8;
	sub_831A8510(ctx, base);
	// 825D44A8: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D44AC: 93C100C4  stw r30, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 825D44B0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 825D44B4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825D44B8: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 825D44BC: 4BCEFFA5  bl 0x822c4460
	ctx.lr = 0x825D44C0;
	sub_822C4460(ctx, base);
	// 825D44C0: 897F00D0  lbz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 825D44C4: 895F00D1  lbz r10, 0xd1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(209 as u32) ) } as u64;
	// 825D44C8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825D44CC: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D44D0: 996100CC  stb r11, 0xcc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 825D44D4: 994100CE  stb r10, 0xce(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(206 as u32), ctx.r[10].u8 ) };
	// 825D44D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D44DC: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D44E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D44E4: 4E800421  bctrl
	ctx.lr = 0x825D44E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D44E8: 896100CC  lbz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825D44EC: 894100CE  lbz r10, 0xce(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(206 as u32) ) } as u64;
	// 825D44F0: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D44F4: 995F00D1  stb r10, 0xd1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(209 as u32), ctx.r[10].u8 ) };
	// 825D44F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D44FC: 556B039D  rlwinm. r11, r11, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4500: 418200C8  beq 0x825d45c8
	if ctx.cr[0].eq {
	pc = 0x825D45C8; continue 'dispatch;
	}
	// 825D4504: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D4508: 4BFE1C61  bl 0x825b6168
	ctx.lr = 0x825D450C;
	sub_825B6168(ctx, base);
	// 825D450C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 825D4510: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D4514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4518: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 825D451C: 419A0008  beq cr6, 0x825d4524
	if ctx.cr[6].eq {
	pc = 0x825D4524; continue 'dispatch;
	}
	// 825D4520: 4BCEC371  bl 0x822c0890
	ctx.lr = 0x825D4524;
	sub_822C0890(ctx, base);
	// 825D4524: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D4528: 4BFFFE89  bl 0x825d43b0
	ctx.lr = 0x825D452C;
	sub_825D43B0(ctx, base);
	// 825D452C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4530: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D4534: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D453C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D4540: 419A0024  beq cr6, 0x825d4564
	if ctx.cr[6].eq {
	pc = 0x825D4564; continue 'dispatch;
	}
	// 825D4544: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D4548: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D454C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D4550: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D4554: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D4558: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D455C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D4560: 4082FFE8  bne 0x825d4548
	if !ctx.cr[0].eq {
	pc = 0x825D4548; continue 'dispatch;
	}
	// 825D4564: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4568: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D456C: 4BF3ADC5  bl 0x8250f330
	ctx.lr = 0x825D4570;
	sub_8250F330(ctx, base);
	// 825D4570: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4574: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825D4578: 4BF152E9  bl 0x824e9860
	ctx.lr = 0x825D457C;
	sub_824E9860(ctx, base);
	// 825D457C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D4580: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D4584: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D4588: 388AE238  addi r4, r10, -0x1dc8
	ctx.r[4].s64 = ctx.r[10].s64 + -7624;
	// 825D458C: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 825D4590: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825D4594: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D4598: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D459C: 488844A5  bl 0x82e58a40
	ctx.lr = 0x825D45A0;
	sub_82E58A40(ctx, base);
	// 825D45A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D45A4: 4881D6ED  bl 0x82df1c90
	ctx.lr = 0x825D45A8;
	sub_82DF1C90(ctx, base);
	// 825D45A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D45AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D45B0: 419A0008  beq cr6, 0x825d45b8
	if ctx.cr[6].eq {
	pc = 0x825D45B8; continue 'dispatch;
	}
	// 825D45B4: 4BCEC2DD  bl 0x822c0890
	ctx.lr = 0x825D45B8;
	sub_822C0890(ctx, base);
	// 825D45B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D45BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D45C0: 419A0008  beq cr6, 0x825d45c8
	if ctx.cr[6].eq {
	pc = 0x825D45C8; continue 'dispatch;
	}
	// 825D45C4: 4BCEC2CD  bl 0x822c0890
	ctx.lr = 0x825D45C8;
	sub_822C0890(ctx, base);
	// 825D45C8: 806100C8  lwz r3, 0xc8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D45CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D45D0: 419A0008  beq cr6, 0x825d45d8
	if ctx.cr[6].eq {
	pc = 0x825D45D8; continue 'dispatch;
	}
	// 825D45D4: 4BCEC2BD  bl 0x822c0890
	ctx.lr = 0x825D45D8;
	sub_822C0890(ctx, base);
	// 825D45D8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825D45DC: 4881EE4D  bl 0x82df3428
	ctx.lr = 0x825D45E0;
	sub_82DF3428(ctx, base);
	// 825D45E0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825D45E4: 48BD3BD4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D45E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D45E8 size=672
    let mut pc: u32 = 0x825D45E8;
    'dispatch: loop {
        match pc {
            0x825D45E8 => {
    //   block [0x825D45E8..0x825D4888)
	// 825D45E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D45EC: 48BD3B6D  bl 0x831a8158
	ctx.lr = 0x825D45F0;
	sub_831A8130(ctx, base);
	// 825D45F0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D45F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D45F8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D45FC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D4600: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D4604: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D4608: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 825D460C: 409A0008  bne cr6, 0x825d4614
	if !ctx.cr[6].eq {
	pc = 0x825D4614; continue 'dispatch;
	}
	// 825D4610: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D4618: 4BF34189  bl 0x825087a0
	ctx.lr = 0x825D461C;
	sub_825087A0(ctx, base);
	// 825D461C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825D4620: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4624: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825D4628: 4881F3E1  bl 0x82df3a08
	ctx.lr = 0x825D462C;
	sub_82DF3A08(ctx, base);
	// 825D462C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D4630: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D4634: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D4638: 4BF34149  bl 0x82508780
	ctx.lr = 0x825D463C;
	sub_82508780(ctx, base);
	// 825D463C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4640: 4881EDE9  bl 0x82df3428
	ctx.lr = 0x825D4644;
	sub_82DF3428(ctx, base);
	// 825D4644: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D4648: 4BCF46D1  bl 0x822c8d18
	ctx.lr = 0x825D464C;
	sub_822C8D18(ctx, base);
	// 825D464C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D4654: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D4658: 409A0008  bne cr6, 0x825d4660
	if !ctx.cr[6].eq {
	pc = 0x825D4660; continue 'dispatch;
	}
	// 825D465C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4660: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4664: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D4668: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D466C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D4670: 4E800421  bctrl
	ctx.lr = 0x825D4674;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D4674: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D4678: 4881D619  bl 0x82df1c90
	ctx.lr = 0x825D467C;
	sub_82DF1C90(ctx, base);
	// 825D467C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D4680: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D4684: 388BE238  addi r4, r11, -0x1dc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7624;
	// 825D4688: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 825D468C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825D4690: 4BCEBD49  bl 0x822c03d8
	ctx.lr = 0x825D4694;
	sub_822C03D8(ctx, base);
	// 825D4694: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D4698: 41820010  beq 0x825d46a8
	if ctx.cr[0].eq {
	pc = 0x825D46A8; continue 'dispatch;
	}
	// 825D469C: 4BFDD3DD  bl 0x825b1a78
	ctx.lr = 0x825D46A0;
	sub_825B1A78(ctx, base);
	// 825D46A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D46A4: 48000008  b 0x825d46ac
	pc = 0x825D46AC; continue 'dispatch;
	// 825D46A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D46AC: 3B5E00C8  addi r26, r30, 0xc8
	ctx.r[26].s64 = ctx.r[30].s64 + 200;
	// 825D46B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D46B4: 4BFDDCD5  bl 0x825b2388
	ctx.lr = 0x825D46B8;
	sub_825B2388(ctx, base);
	// 825D46B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D46BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D46C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D46C4: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825D46C8: 4881D531  bl 0x82df1bf8
	ctx.lr = 0x825D46CC;
	sub_82DF1BF8(ctx, base);
	// 825D46CC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825D46D0: 48572B89  bl 0x82b47258
	ctx.lr = 0x825D46D4;
	sub_82B47258(ctx, base);
	// 825D46D4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825D46D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D46DC: 4881D5B5  bl 0x82df1c90
	ctx.lr = 0x825D46E0;
	sub_82DF1C90(ctx, base);
	// 825D46E0: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 825D46E4: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 825D46E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D46EC: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 825D46F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D46F4: 388BE288  addi r4, r11, -0x1d78
	ctx.r[4].s64 = ctx.r[11].s64 + -7544;
	// 825D46F8: 4881F311  bl 0x82df3a08
	ctx.lr = 0x825D46FC;
	sub_82DF3A08(ctx, base);
	// 825D46FC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825D4700: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825D4704: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D4708: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825D470C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4710: 4882B129  bl 0x82dff838
	ctx.lr = 0x825D4714;
	sub_82DFF838(ctx, base);
	// 825D4714: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 825D4718: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825D471C: 3F208212  lis r25, -0x7dee
	ctx.r[25].s64 = -2112749568;
	// 825D4720: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D4724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D4728: 419A006C  beq cr6, 0x825d4794
	if ctx.cr[6].eq {
	pc = 0x825D4794; continue 'dispatch;
	}
	// 825D472C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D4730: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D4734: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825D4738: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D473C: 40980058  bge cr6, 0x825d4794
	if !ctx.cr[6].lt {
	pc = 0x825D4794; continue 'dispatch;
	}
	// 825D4740: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4744: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D4748: 4881F901  bl 0x82df4048
	ctx.lr = 0x825D474C;
	sub_82DF4048(ctx, base);
	// 825D474C: 8179B230  lwz r11, -0x4dd0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825D4750: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D4754: 419A0034  beq cr6, 0x825d4788
	if ctx.cr[6].eq {
	pc = 0x825D4788; continue 'dispatch;
	}
	// 825D4758: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D475C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4760: 7F9D5A14  add r28, r29, r11
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4764: 4881F32D  bl 0x82df3a90
	ctx.lr = 0x825D4768;
	sub_82DF3A90(ctx, base);
	// 825D4768: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D476C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D4770: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D4774: 4881FB95  bl 0x82df4308
	ctx.lr = 0x825D4778;
	sub_82DF4308(ctx, base);
	// 825D4778: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D477C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D4780: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4784: 4BD1A5A5  bl 0x822eed28
	ctx.lr = 0x825D4788;
	sub_822EED28(ctx, base);
	// 825D4788: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825D478C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825D4790: 4BFFFF90  b 0x825d4720
	pc = 0x825D4720; continue 'dispatch;
	// 825D4794: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D4798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D479C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D47A0: 4BFFEC51  bl 0x825d33f0
	ctx.lr = 0x825D47A4;
	sub_825D33F0(ctx, base);
	// 825D47A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D47A8: 3BBE00C0  addi r29, r30, 0xc0
	ctx.r[29].s64 = ctx.r[30].s64 + 192;
	// 825D47AC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D47B0: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825D47B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D47B8: 917E00C0  stw r11, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D47BC: 4BCEFCA5  bl 0x822c4460
	ctx.lr = 0x825D47C0;
	sub_822C4460(ctx, base);
	// 825D47C0: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825D47C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D47C8: 419A0008  beq cr6, 0x825d47d0
	if ctx.cr[6].eq {
	pc = 0x825D47D0; continue 'dispatch;
	}
	// 825D47CC: 4BCEC0C5  bl 0x822c0890
	ctx.lr = 0x825D47D0;
	sub_822C0890(ctx, base);
	// 825D47D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D47D4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825D47D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D47DC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825D47E0: 4BFDD921  bl 0x825b2100
	ctx.lr = 0x825D47E4;
	sub_825B2100(ctx, base);
	// 825D47E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D47E8: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825D47EC: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825D47F0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D47F4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D47F8: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 825D47FC: 48BD3D15  bl 0x831a8510
	ctx.lr = 0x825D4800;
	sub_831A8510(ctx, base);
	// 825D4800: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4804: 93E100E4  stw r31, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[31].u32 ) };
	// 825D4808: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 825D480C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825D4810: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 825D4814: 4BCEFC4D  bl 0x822c4460
	ctx.lr = 0x825D4818;
	sub_822C4460(ctx, base);
	// 825D4818: 897E00D0  lbz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 825D481C: 895E00D1  lbz r10, 0xd1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(209 as u32) ) } as u64;
	// 825D4820: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825D4824: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4828: 996100EC  stb r11, 0xec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 825D482C: 994100EE  stb r10, 0xee(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(238 as u32), ctx.r[10].u8 ) };
	// 825D4830: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4834: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825D4838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D483C: 4E800421  bctrl
	ctx.lr = 0x825D4840;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D4840: 896100EC  lbz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825D4844: 894100EE  lbz r10, 0xee(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(238 as u32) ) } as u64;
	// 825D4848: 806100E8  lwz r3, 0xe8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 825D484C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4850: 997E00D0  stb r11, 0xd0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D4854: 995E00D1  stb r10, 0xd1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(209 as u32), ctx.r[10].u8 ) };
	// 825D4858: 419A0008  beq cr6, 0x825d4860
	if ctx.cr[6].eq {
	pc = 0x825D4860; continue 'dispatch;
	}
	// 825D485C: 4BCEC035  bl 0x822c0890
	ctx.lr = 0x825D4860;
	sub_822C0890(ctx, base);
	// 825D4860: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825D4864: 4881EBC5  bl 0x82df3428
	ctx.lr = 0x825D4868;
	sub_82DF3428(ctx, base);
	// 825D4868: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D486C: 4BDFDB7D  bl 0x823d23e8
	ctx.lr = 0x825D4870;
	sub_823D23E8(ctx, base);
	// 825D4870: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4874: 4881EBB5  bl 0x82df3428
	ctx.lr = 0x825D4878;
	sub_82DF3428(ctx, base);
	// 825D4878: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D487C: 4BDFDB6D  bl 0x823d23e8
	ctx.lr = 0x825D4880;
	sub_823D23E8(ctx, base);
	// 825D4880: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825D4884: 48BD3924  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D4888 size=72
    let mut pc: u32 = 0x825D4888;
    'dispatch: loop {
        match pc {
            0x825D4888 => {
    //   block [0x825D4888..0x825D48D0)
	// 825D4888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D488C: 48BD38E1  bl 0x831a816c
	ctx.lr = 0x825D4890;
	sub_831A8130(ctx, base);
	// 825D4890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4894: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D4898: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D489C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D48A0: 817D00F4  lwz r11, 0xf4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 825D48A4: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825D48A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825D48AC: 419A0010  beq cr6, 0x825d48bc
	if ctx.cr[6].eq {
	pc = 0x825D48BC; continue 'dispatch;
	}
	// 825D48B0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825D48B4: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D48B8: 485E0C39  bl 0x82bb54f0
	ctx.lr = 0x825D48BC;
	sub_82BB54F0(ctx, base);
	// 825D48BC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825D48C0: 2F1F0010  cmpwi cr6, r31, 0x10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 16, &mut ctx.xer);
	// 825D48C4: 4198FFDC  blt cr6, 0x825d48a0
	if ctx.cr[6].lt {
	pc = 0x825D48A0; continue 'dispatch;
	}
	// 825D48C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D48CC: 48BD38F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D48D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D48D0 size=148
    let mut pc: u32 = 0x825D48D0;
    'dispatch: loop {
        match pc {
            0x825D48D0 => {
    //   block [0x825D48D0..0x825D4964)
	// 825D48D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D48D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D48D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D48DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D48E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D48E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D48E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D48EC: 4BCEB715  bl 0x822c0000
	ctx.lr = 0x825D48F0;
	sub_822C0000(ctx, base);
	// 825D48F0: 3BDE0100  addi r30, r30, 0x100
	ctx.r[30].s64 = ctx.r[30].s64 + 256;
	// 825D48F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D48F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D48FC: 419A0050  beq cr6, 0x825d494c
	if ctx.cr[6].eq {
	pc = 0x825D494C; continue 'dispatch;
	}
	// 825D4900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4904: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4908: 4BF36049  bl 0x8250a950
	ctx.lr = 0x825D490C;
	sub_8250A950(ctx, base);
	// 825D490C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D4910: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D4914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D4918: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 825D491C: 409A0008  bne cr6, 0x825d4924
	if !ctx.cr[6].eq {
	pc = 0x825D4924; continue 'dispatch;
	}
	// 825D4920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4924: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D4928: 481FF049  bl 0x827d3970
	ctx.lr = 0x825D492C;
	sub_827D3970(ctx, base);
	// 825D492C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D4930: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825D4934: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D4938: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825D493C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825D4940: 4BCEFB21  bl 0x822c4460
	ctx.lr = 0x825D4944;
	sub_822C4460(ctx, base);
	// 825D4944: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4948: 4881D349  bl 0x82df1c90
	ctx.lr = 0x825D494C;
	sub_82DF1C90(ctx, base);
	// 825D494C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D4950: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D4954: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D4958: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D495C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D4960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4968 size=88
    let mut pc: u32 = 0x825D4968;
    'dispatch: loop {
        match pc {
            0x825D4968 => {
    //   block [0x825D4968..0x825D49C0)
	// 825D4968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D496C: 48BD37FD  bl 0x831a8168
	ctx.lr = 0x825D4970;
	sub_831A8130(ctx, base);
	// 825D4970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4974: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D4978: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D497C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D4980: 7F1D2040  cmplw cr6, r29, r4
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825D4984: 419A0030  beq cr6, 0x825d49b4
	if ctx.cr[6].eq {
	pc = 0x825D49B4; continue 'dispatch;
	}
	// 825D4988: 7F9F2050  subf r28, r31, r4
	ctx.r[28].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 825D498C: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 825D4990: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 825D4994: 7D7CFA14  add r11, r28, r31
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 825D4998: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D499C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D49A0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D49A4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D49A8: 4BCEFAB9  bl 0x822c4460
	ctx.lr = 0x825D49AC;
	sub_822C4460(ctx, base);
	// 825D49AC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825D49B0: 409AFFDC  bne cr6, 0x825d498c
	if !ctx.cr[6].eq {
	pc = 0x825D498C; continue 'dispatch;
	}
	// 825D49B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D49B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D49BC: 48BD37FC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D49C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D49C0 size=140
    let mut pc: u32 = 0x825D49C0;
    'dispatch: loop {
        match pc {
            0x825D49C0 => {
    //   block [0x825D49C0..0x825D4A4C)
	// 825D49C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D49C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D49C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D49CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D49D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D49D4: 4BF3C71D  bl 0x825110f0
	ctx.lr = 0x825D49D8;
	sub_825110F0(ctx, base);
	// 825D49D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D49DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D49E0: 392BE2B4  addi r9, r11, -0x1d4c
	ctx.r[9].s64 = ctx.r[11].s64 + -7500;
	// 825D49E4: 394AE2A0  addi r10, r10, -0x1d60
	ctx.r[10].s64 = ctx.r[10].s64 + -7520;
	// 825D49E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D49EC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D49F0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D49F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D49F8: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 825D49FC: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 825D4A00: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 825D4A04: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 825D4A08: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 825D4A0C: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 825D4A10: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825D4A14: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825D4A18: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825D4A1C: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825D4A20: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 825D4A24: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 825D4A28: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 825D4A2C: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 825D4A30: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825D4A34: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 825D4A38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D4A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D4A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D4A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D4A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D4A50 size=8
    let mut pc: u32 = 0x825D4A50;
    'dispatch: loop {
        match pc {
            0x825D4A50 => {
    //   block [0x825D4A50..0x825D4A58)
	// 825D4A50: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825D4A54: 48000074  b 0x825d4ac8
	sub_825D4AC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4A58 size=112
    let mut pc: u32 = 0x825D4A58;
    'dispatch: loop {
        match pc {
            0x825D4A58 => {
    //   block [0x825D4A58..0x825D4AC8)
	// 825D4A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D4A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D4A64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D4A6C: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 825D4A70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4A74: 419A0008  beq cr6, 0x825d4a7c
	if ctx.cr[6].eq {
	pc = 0x825D4A7C; continue 'dispatch;
	}
	// 825D4A78: 4BCEBE19  bl 0x822c0890
	ctx.lr = 0x825D4A7C;
	sub_822C0890(ctx, base);
	// 825D4A7C: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 825D4A80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4A84: 419A0008  beq cr6, 0x825d4a8c
	if ctx.cr[6].eq {
	pc = 0x825D4A8C; continue 'dispatch;
	}
	// 825D4A88: 4BCEBE09  bl 0x822c0890
	ctx.lr = 0x825D4A8C;
	sub_822C0890(ctx, base);
	// 825D4A8C: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 825D4A90: 4BEDC811  bl 0x824b12a0
	ctx.lr = 0x825D4A94;
	sub_824B12A0(ctx, base);
	// 825D4A94: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 825D4A98: 4BEDC809  bl 0x824b12a0
	ctx.lr = 0x825D4A9C;
	sub_824B12A0(ctx, base);
	// 825D4A9C: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 825D4AA0: 4BEDC801  bl 0x824b12a0
	ctx.lr = 0x825D4AA4;
	sub_824B12A0(ctx, base);
	// 825D4AA4: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825D4AA8: 4BEDC7F9  bl 0x824b12a0
	ctx.lr = 0x825D4AAC;
	sub_824B12A0(ctx, base);
	// 825D4AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4AB0: 4BF3C6E9  bl 0x82511198
	ctx.lr = 0x825D4AB4;
	sub_82511198(ctx, base);
	// 825D4AB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D4AB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D4ABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D4AC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D4AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4AC8 size=76
    let mut pc: u32 = 0x825D4AC8;
    'dispatch: loop {
        match pc {
            0x825D4AC8 => {
    //   block [0x825D4AC8..0x825D4B14)
	// 825D4AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D4AD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D4AD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D4AD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4ADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D4AE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D4AE4: 4BFFFF75  bl 0x825d4a58
	ctx.lr = 0x825D4AE8;
	sub_825D4A58(ctx, base);
	// 825D4AE8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4AEC: 4182000C  beq 0x825d4af8
	if ctx.cr[0].eq {
	pc = 0x825D4AF8; continue 'dispatch;
	}
	// 825D4AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4AF4: 4881D8E5  bl 0x82df23d8
	ctx.lr = 0x825D4AF8;
	sub_82DF23D8(ctx, base);
	// 825D4AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4AFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D4B00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D4B04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D4B08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D4B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D4B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D4B18 size=1168
    let mut pc: u32 = 0x825D4B18;
    'dispatch: loop {
        match pc {
            0x825D4B18 => {
    //   block [0x825D4B18..0x825D4FA8)
	// 825D4B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4B1C: 48BD3615  bl 0x831a8130
	ctx.lr = 0x825D4B20;
	sub_831A8130(ctx, base);
	// 825D4B20: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 825D4B24: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 825D4B28: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825D4B2C: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4B30: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D4B34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D4B38: 7F8FE378  mr r15, r28
	ctx.r[15].u64 = ctx.r[28].u64;
	// 825D4B3C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D4B40: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825D4B44: 91E10050  stw r15, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[15].u32 ) };
	// 825D4B48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D4B4C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825D4B50: 409A0008  bne cr6, 0x825d4b58
	if !ctx.cr[6].eq {
	pc = 0x825D4B58; continue 'dispatch;
	}
	// 825D4B54: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D4B58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D4B5C: 4BF33C45  bl 0x825087a0
	ctx.lr = 0x825D4B60;
	sub_825087A0(ctx, base);
	// 825D4B60: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825D4B64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D4B68: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825D4B6C: 4881EE9D  bl 0x82df3a08
	ctx.lr = 0x825D4B70;
	sub_82DF3A08(ctx, base);
	// 825D4B70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D4B74: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D4B78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D4B7C: 4BF33C05  bl 0x82508780
	ctx.lr = 0x825D4B80;
	sub_82508780(ctx, base);
	// 825D4B80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D4B84: 4881E8A5  bl 0x82df3428
	ctx.lr = 0x825D4B88;
	sub_82DF3428(ctx, base);
	// 825D4B88: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 825D4B8C: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 825D4B90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D4B94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D4B98: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D4B9C: 809E271C  lwz r4, 0x271c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(10012 as u32) ) } as u64;
	// 825D4BA0: 4881D059  bl 0x82df1bf8
	ctx.lr = 0x825D4BA4;
	sub_82DF1BF8(ctx, base);
	// 825D4BA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D4BA8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D4BAC: 809E271C  lwz r4, 0x271c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(10012 as u32) ) } as u64;
	// 825D4BB0: 83C10090  lwz r30, 0x90(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825D4BB4: 4881D045  bl 0x82df1bf8
	ctx.lr = 0x825D4BB8;
	sub_82DF1BF8(ctx, base);
	// 825D4BB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D4BBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D4BC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D4BC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4BC8: 3BCBE334  addi r30, r11, -0x1ccc
	ctx.r[30].s64 = ctx.r[11].s64 + -7372;
	// 825D4BCC: 83610080  lwz r27, 0x80(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825D4BD0: 4887B211  bl 0x82e4fde0
	ctx.lr = 0x825D4BD4;
	sub_82E4FDE0(ctx, base);
	// 825D4BD4: 4881E5DD  bl 0x82df31b0
	ctx.lr = 0x825D4BD8;
	sub_82DF31B0(ctx, base);
	// 825D4BD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D4BDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D4BE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D4BE4: 4887B765  bl 0x82e50348
	ctx.lr = 0x825D4BE8;
	sub_82E50348(ctx, base);
	// 825D4BE8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D4BEC: 4881D0A5  bl 0x82df1c90
	ctx.lr = 0x825D4BF0;
	sub_82DF1C90(ctx, base);
	// 825D4BF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4BF4: 4881E835  bl 0x82df3428
	ctx.lr = 0x825D4BF8;
	sub_82DF3428(ctx, base);
	// 825D4BF8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D4BFC: 4881D095  bl 0x82df1c90
	ctx.lr = 0x825D4C00;
	sub_82DF1C90(ctx, base);
	// 825D4C00: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D4C04: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4C08: 48855EE1  bl 0x82e2aae8
	ctx.lr = 0x825D4C0C;
	sub_82E2AAE8(ctx, base);
	// 825D4C0C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825D4C10: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825D4C14: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 825D4C18: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D4C1C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D4C20: C3E89534  lfs f31, -0x6acc(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D4C24: 3D208329  lis r9, -0x7cd7
	ctx.r[9].s64 = -2094465024;
	// 825D4C28: C3A708A4  lfs f29, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825D4C2C: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 825D4C30: C3C608A8  lfs f30, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825D4C34: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825D4C38: 3CC08329  lis r6, -0x7cd7
	ctx.r[6].s64 = -2094465024;
	// 825D4C3C: 3A3F00C0  addi r17, r31, 0xc0
	ctx.r[17].s64 = ctx.r[31].s64 + 192;
	// 825D4C40: 3A1F00E0  addi r16, r31, 0xe0
	ctx.r[16].s64 = ctx.r[31].s64 + 224;
	// 825D4C44: 3A5F00D0  addi r18, r31, 0xd0
	ctx.r[18].s64 = ctx.r[31].s64 + 208;
	// 825D4C48: 3A9F00F0  addi r20, r31, 0xf0
	ctx.r[20].s64 = ctx.r[31].s64 + 240;
	// 825D4C4C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 825D4C50: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 825D4C54: 3EA08335  lis r21, -0x7ccb
	ctx.r[21].s64 = -2093678592;
	// 825D4C58: 3B0BBEE0  addi r24, r11, -0x4120
	ctx.r[24].s64 = ctx.r[11].s64 + -16672;
	// 825D4C5C: 3B2AE328  addi r25, r10, -0x1cd8
	ctx.r[25].s64 = ctx.r[10].s64 + -7384;
	// 825D4C60: 3AE9BED8  addi r23, r9, -0x4128
	ctx.r[23].s64 = ctx.r[9].s64 + -16680;
	// 825D4C64: 3A686880  addi r19, r8, 0x6880
	ctx.r[19].s64 = ctx.r[8].s64 + 26752;
	// 825D4C68: 3B47E2E0  addi r26, r7, -0x1d20
	ctx.r[26].s64 = ctx.r[7].s64 + -7456;
	// 825D4C6C: 3AC6BED0  addi r22, r6, -0x4130
	ctx.r[22].s64 = ctx.r[6].s64 + -16688;
	// 825D4C70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D4C74: 7C9BB02E  lwzx r4, r27, r22
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825D4C78: 4881ED91  bl 0x82df3a08
	ctx.lr = 0x825D4C7C;
	sub_82DF3A08(ctx, base);
	// 825D4C7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D4C80: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825D4C84: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 825D4C88: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D4C8C: 4885A1E5  bl 0x82e2ee70
	ctx.lr = 0x825D4C90;
	sub_82E2EE70(ctx, base);
	// 825D4C90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D4C94: 4881E795  bl 0x82df3428
	ctx.lr = 0x825D4C98;
	sub_82DF3428(ctx, base);
	// 825D4C98: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 825D4C9C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 825D4CA0: 485DE469  bl 0x82bb3108
	ctx.lr = 0x825D4CA4;
	sub_82BB3108(ctx, base);
	// 825D4CA4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D4CA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D4CAC: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 825D4CB0: 38A00047  li r5, 0x47
	ctx.r[5].s64 = 71;
	// 825D4CB4: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 825D4CB8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825D4CBC: 4881D72D  bl 0x82df23e8
	ctx.lr = 0x825D4CC0;
	sub_82DF23E8(ctx, base);
	// 825D4CC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D4CC4: 41820014  beq 0x825d4cd8
	if ctx.cr[0].eq {
	pc = 0x825D4CD8; continue 'dispatch;
	}
	// 825D4CC8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 825D4CCC: 4883E425  bl 0x82e130f0
	ctx.lr = 0x825D4CD0;
	sub_82E130F0(ctx, base);
	// 825D4CD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D4CD4: 48000008  b 0x825d4cdc
	pc = 0x825D4CDC; continue 'dispatch;
	// 825D4CD8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D4CDC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D4CE0: 4BD0D071  bl 0x822e1d50
	ctx.lr = 0x825D4CE4;
	sub_822E1D50(ctx, base);
	// 825D4CE4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825D4CE8: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 825D4CEC: 485DE41D  bl 0x82bb3108
	ctx.lr = 0x825D4CF0;
	sub_82BB3108(ctx, base);
	// 825D4CF0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D4CF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D4CF8: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 825D4CFC: 38A0004B  li r5, 0x4b
	ctx.r[5].s64 = 75;
	// 825D4D00: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 825D4D04: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825D4D08: 4881D6E1  bl 0x82df23e8
	ctx.lr = 0x825D4D0C;
	sub_82DF23E8(ctx, base);
	// 825D4D0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D4D10: 41820018  beq 0x825d4d28
	if ctx.cr[0].eq {
	pc = 0x825D4D28; continue 'dispatch;
	}
	// 825D4D14: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D4D18: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4D1C: 48841B75  bl 0x82e16890
	ctx.lr = 0x825D4D20;
	sub_82E16890(ctx, base);
	// 825D4D20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D4D24: 48000008  b 0x825d4d2c
	pc = 0x825D4D2C; continue 'dispatch;
	// 825D4D28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D4D2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D4D30: 4BD88641  bl 0x8235d370
	ctx.lr = 0x825D4D34;
	sub_8235D370(ctx, base);
	// 825D4D34: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825D4D38: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 825D4D3C: 485DE3CD  bl 0x82bb3108
	ctx.lr = 0x825D4D40;
	sub_82BB3108(ctx, base);
	// 825D4D40: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 825D4D44: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4D48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4D4C: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 825D4D50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D4D58: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 825D4D5C: 419A0024  beq cr6, 0x825d4d80
	if ctx.cr[6].eq {
	pc = 0x825D4D80; continue 'dispatch;
	}
	// 825D4D60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D4D64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D4D68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D4D6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D4D70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D4D74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D4D78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D4D7C: 4082FFE8  bne 0x825d4d64
	if !ctx.cr[0].eq {
	pc = 0x825D4D64; continue 'dispatch;
	}
	// 825D4D80: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 825D4D84: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825D4D88: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D4D8C: 48840325  bl 0x82e150b0
	ctx.lr = 0x825D4D90;
	sub_82E150B0(ctx, base);
	// 825D4D90: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D4D94: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825D4D98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D4D9C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825D4DA0: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 825D4DA4: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 825D4DA8: 4881D641  bl 0x82df23e8
	ctx.lr = 0x825D4DAC;
	sub_82DF23E8(ctx, base);
	// 825D4DAC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D4DB0: 41820040  beq 0x825d4df0
	if ctx.cr[0].eq {
	pc = 0x825D4DF0; continue 'dispatch;
	}
	// 825D4DB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4DB8: 7C9BB82E  lwzx r4, r27, r23
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 825D4DBC: 4881EC4D  bl 0x82df3a08
	ctx.lr = 0x825D4DC0;
	sub_82DF3A08(ctx, base);
	// 825D4DC0: 61EB0001  ori r11, r15, 1
	ctx.r[11].u64 = ctx.r[15].u64 | 1;
	// 825D4DC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D4DC8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825D4DCC: 616F0002  ori r15, r11, 2
	ctx.r[15].u64 = ctx.r[11].u64 | 2;
	// 825D4DD0: 39C10058  addi r14, r1, 0x58
	ctx.r[14].s64 = ctx.r[1].s64 + 88;
	// 825D4DD4: 4BF3A6F5  bl 0x8250f4c8
	ctx.lr = 0x825D4DD8;
	sub_8250F4C8(ctx, base);
	// 825D4DD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D4DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D4DE0: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 825D4DE4: 485DEE1D  bl 0x82bb3c00
	ctx.lr = 0x825D4DE8;
	sub_82BB3C00(ctx, base);
	// 825D4DE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D4DEC: 48000008  b 0x825d4df4
	pc = 0x825D4DF4; continue 'dispatch;
	// 825D4DF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D4DF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D4DF8: 4BD885E9  bl 0x8235d3e0
	ctx.lr = 0x825D4DFC;
	sub_8235D3E0(ctx, base);
	// 825D4DFC: 55EB07BD  rlwinm. r11, r15, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4E00: 41820010  beq 0x825d4e10
	if ctx.cr[0].eq {
	pc = 0x825D4E10; continue 'dispatch;
	}
	// 825D4E04: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825D4E08: 55EF07FA  rlwinm r15, r15, 0, 0x1f, 0x1d
	ctx.r[15].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 825D4E0C: 4881CE85  bl 0x82df1c90
	ctx.lr = 0x825D4E10;
	sub_82DF1C90(ctx, base);
	// 825D4E10: 55EB07FF  clrlwi. r11, r15, 0x1f
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D4E14: 41820010  beq 0x825d4e24
	if ctx.cr[0].eq {
	pc = 0x825D4E24; continue 'dispatch;
	}
	// 825D4E18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D4E1C: 55EF003C  rlwinm r15, r15, 0, 0, 0x1e
	ctx.r[15].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 825D4E20: 4881E609  bl 0x82df3428
	ctx.lr = 0x825D4E24;
	sub_82DF3428(ctx, base);
	// 825D4E24: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D4E28: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825D4E2C: 485DE2DD  bl 0x82bb3108
	ctx.lr = 0x825D4E30;
	sub_82BB3108(ctx, base);
	// 825D4E30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D4E34: D3C100C8  stfs f30, 0xc8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 825D4E38: 932100C0  stw r25, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u32 ) };
	// 825D4E3C: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 825D4E40: D3A100D0  stfs f29, 0xd0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 825D4E44: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 825D4E48: 9B8100DC  stb r28, 0xdc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[28].u8 ) };
	// 825D4E4C: D3E100D8  stfs f31, 0xd8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 825D4E50: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825D4E54: 7D7BC02E  lwzx r11, r27, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825D4E58: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 825D4E5C: 48829A6D  bl 0x82dfe8c8
	ctx.lr = 0x825D4E60;
	sub_82DFE8C8(ctx, base);
	// 825D4E60: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825D4E64: 48829A65  bl 0x82dfe8c8
	ctx.lr = 0x825D4E68;
	sub_82DFE8C8(ctx, base);
	// 825D4E68: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825D4E6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825D4E70: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825D4E74: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D4E78: 485E00E9  bl 0x82bb4f60
	ctx.lr = 0x825D4E7C;
	sub_82BB4F60(ctx, base);
	// 825D4E7C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825D4E80: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4E84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D4E88: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825D4E8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D4E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D4E94: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825D4E98: 419A0024  beq cr6, 0x825d4ebc
	if ctx.cr[6].eq {
	pc = 0x825D4EBC; continue 'dispatch;
	}
	// 825D4E9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D4EA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D4EA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D4EA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D4EAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D4EB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D4EB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D4EB8: 4082FFE8  bne 0x825d4ea0
	if !ctx.cr[0].eq {
	pc = 0x825D4EA0; continue 'dispatch;
	}
	// 825D4EBC: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 825D4EC0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825D4EC4: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D4EC8: 488400A9  bl 0x82e14f70
	ctx.lr = 0x825D4ECC;
	sub_82E14F70(ctx, base);
	// 825D4ECC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D4ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4ED4: 419A0008  beq cr6, 0x825d4edc
	if ctx.cr[6].eq {
	pc = 0x825D4EDC; continue 'dispatch;
	}
	// 825D4ED8: 4BCEB9B9  bl 0x822c0890
	ctx.lr = 0x825D4EDC;
	sub_822C0890(ctx, base);
	// 825D4EDC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825D4EE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4EE4: 4881EB25  bl 0x82df3a08
	ctx.lr = 0x825D4EE8;
	sub_82DF3A08(ctx, base);
	// 825D4EE8: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825D4EEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D4EF0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825D4EF4: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D4EF8: 485DE419  bl 0x82bb3310
	ctx.lr = 0x825D4EFC;
	sub_82BB3310(ctx, base);
	// 825D4EFC: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825D4F00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4F04: 419A0008  beq cr6, 0x825d4f0c
	if ctx.cr[6].eq {
	pc = 0x825D4F0C; continue 'dispatch;
	}
	// 825D4F08: 4BCEB989  bl 0x822c0890
	ctx.lr = 0x825D4F0C;
	sub_822C0890(ctx, base);
	// 825D4F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D4F10: 4881E519  bl 0x82df3428
	ctx.lr = 0x825D4F14;
	sub_82DF3428(ctx, base);
	// 825D4F14: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D4F18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4F1C: 419A0008  beq cr6, 0x825d4f24
	if ctx.cr[6].eq {
	pc = 0x825D4F24; continue 'dispatch;
	}
	// 825D4F20: 4BCEB971  bl 0x822c0890
	ctx.lr = 0x825D4F24;
	sub_822C0890(ctx, base);
	// 825D4F24: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D4F28: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D4F2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D4F30: 419A001C  beq cr6, 0x825d4f4c
	if ctx.cr[6].eq {
	pc = 0x825D4F4C; continue 'dispatch;
	}
	// 825D4F34: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 825D4F38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825D4F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D4F40: 80957058  lwz r4, 0x7058(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825D4F44: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D4F48: 4BF3BC11  bl 0x82510b58
	ctx.lr = 0x825D4F4C;
	sub_82510B58(ctx, base);
	// 825D4F4C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D4F50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4F54: 419A0008  beq cr6, 0x825d4f5c
	if ctx.cr[6].eq {
	pc = 0x825D4F5C; continue 'dispatch;
	}
	// 825D4F58: 4BCEB939  bl 0x822c0890
	ctx.lr = 0x825D4F5C;
	sub_822C0890(ctx, base);
	// 825D4F5C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D4F60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4F64: 419A0008  beq cr6, 0x825d4f6c
	if ctx.cr[6].eq {
	pc = 0x825D4F6C; continue 'dispatch;
	}
	// 825D4F68: 4BCEB929  bl 0x822c0890
	ctx.lr = 0x825D4F6C;
	sub_822C0890(ctx, base);
	// 825D4F6C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825D4F70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D4F74: 419A0008  beq cr6, 0x825d4f7c
	if ctx.cr[6].eq {
	pc = 0x825D4F7C; continue 'dispatch;
	}
	// 825D4F78: 4BCEB919  bl 0x822c0890
	ctx.lr = 0x825D4F7C;
	sub_822C0890(ctx, base);
	// 825D4F7C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 825D4F80: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825D4F84: 2F1B0008  cmpwi cr6, r27, 8
	ctx.cr[6].compare_i32(ctx.r[27].s32, 8, &mut ctx.xer);
	// 825D4F88: 4198FCE8  blt cr6, 0x825d4c70
	if ctx.cr[6].lt {
	pc = 0x825D4C70; continue 'dispatch;
	}
	// 825D4F8C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D4F90: 48855B71  bl 0x82e2ab00
	ctx.lr = 0x825D4F94;
	sub_82E2AB00(ctx, base);
	// 825D4F94: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 825D4F98: CBA1FF50  lfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 825D4F9C: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 825D4FA0: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 825D4FA4: 48BD31DC  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D4FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D4FA8 size=196
    let mut pc: u32 = 0x825D4FA8;
    'dispatch: loop {
        match pc {
            0x825D4FA8 => {
    //   block [0x825D4FA8..0x825D506C)
	// 825D4FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D4FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D4FB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D4FB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D4FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D4FBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D4FC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D4FC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D4FC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D4FCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D4FD0: 4BCEB969  bl 0x822c0938
	ctx.lr = 0x825D4FD4;
	sub_822C0938(ctx, base);
	// 825D4FD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D4FD8: 41820028  beq 0x825d5000
	if ctx.cr[0].eq {
	pc = 0x825D5000; continue 'dispatch;
	}
	// 825D4FDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D4FE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D4FE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D4FE8: 392BE394  addi r9, r11, -0x1c6c
	ctx.r[9].s64 = ctx.r[11].s64 + -7276;
	// 825D4FEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D4FF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D4FF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D4FF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D4FFC: 48000008  b 0x825d5004
	pc = 0x825D5004; continue 'dispatch;
	// 825D5000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D5004: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D500C: 409A0044  bne cr6, 0x825d5050
	if !ctx.cr[6].eq {
	pc = 0x825D5050; continue 'dispatch;
	}
	// 825D5010: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D5014: 419A001C  beq cr6, 0x825d5030
	if ctx.cr[6].eq {
	pc = 0x825D5030; continue 'dispatch;
	}
	// 825D5018: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D501C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D5020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D5024: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D502C: 4E800421  bctrl
	ctx.lr = 0x825D5030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D5030: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D5034: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D5038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D503C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D5040: 816BBEE8  lwz r11, -0x4118(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16664 as u32) ) } as u64;
	// 825D5044: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D5048: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D504C: 4BCEAFB5  bl 0x822c0000
	ctx.lr = 0x825D5050;
	sub_822C0000(ctx, base);
	// 825D5050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D5058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D505C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D5060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D5064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D5068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D5070 size=100
    let mut pc: u32 = 0x825D5070;
    'dispatch: loop {
        match pc {
            0x825D5070 => {
    //   block [0x825D5070..0x825D50D4)
	// 825D5070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D5078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D507C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D5084: 4BF3C06D  bl 0x825110f0
	ctx.lr = 0x825D5088;
	sub_825110F0(ctx, base);
	// 825D5088: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D508C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D5090: 392BE3BC  addi r9, r11, -0x1c44
	ctx.r[9].s64 = ctx.r[11].s64 + -7236;
	// 825D5094: 394AE3A8  addi r10, r10, -0x1c58
	ctx.r[10].s64 = ctx.r[10].s64 + -7256;
	// 825D5098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D509C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D50A0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D50A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D50A8: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D50AC: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 825D50B0: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 825D50B4: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 825D50B8: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D50BC: 997F00D1  stb r11, 0xd1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(209 as u32), ctx.r[11].u8 ) };
	// 825D50C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D50C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D50C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D50CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D50D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D50D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D50D8 size=104
    let mut pc: u32 = 0x825D50D8;
    'dispatch: loop {
        match pc {
            0x825D50D8 => {
    //   block [0x825D50D8..0x825D5140)
	// 825D50D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D50DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D50E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D50E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D50E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D50EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D50F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D50F4: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D50F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D50FC: 419A0020  beq cr6, 0x825d511c
	if ctx.cr[6].eq {
	pc = 0x825D511C; continue 'dispatch;
	}
	// 825D5100: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D5104: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D5108: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D510C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5110: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 825D5114: 419A0008  beq cr6, 0x825d511c
	if ctx.cr[6].eq {
	pc = 0x825D511C; continue 'dispatch;
	}
	// 825D5118: 4BCEB779  bl 0x822c0890
	ctx.lr = 0x825D511C;
	sub_822C0890(ctx, base);
	// 825D511C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D5120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D5124: 4BCEAEDD  bl 0x822c0000
	ctx.lr = 0x825D5128;
	sub_822C0000(ctx, base);
	// 825D5128: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D512C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D5130: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D5134: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D5138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D513C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D5140 size=124
    let mut pc: u32 = 0x825D5140;
    'dispatch: loop {
        match pc {
            0x825D5140 => {
    //   block [0x825D5140..0x825D51BC)
	// 825D5140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5144: 48BD3029  bl 0x831a816c
	ctx.lr = 0x825D5148;
	sub_831A8130(ctx, base);
	// 825D5148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D514C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D5150: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D5154: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D5158: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825D515C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825D5160: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825D5164: 4881D285  bl 0x82df23e8
	ctx.lr = 0x825D5168;
	sub_82DF23E8(ctx, base);
	// 825D5168: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D516C: 4182001C  beq 0x825d5188
	if ctx.cr[0].eq {
	pc = 0x825D5188; continue 'dispatch;
	}
	// 825D5170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D5174: 4888450D  bl 0x82e59680
	ctx.lr = 0x825D5178;
	sub_82E59680(ctx, base);
	// 825D5178: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D517C: 396BE38C  addi r11, r11, -0x1c74
	ctx.r[11].s64 = ctx.r[11].s64 + -7284;
	// 825D5180: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5184: 48000008  b 0x825d518c
	pc = 0x825D518C; continue 'dispatch;
	// 825D5188: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D518C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D5190: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D5194: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D5198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D519C: 4BFFFE0D  bl 0x825d4fa8
	ctx.lr = 0x825D51A0;
	sub_825D4FA8(ctx, base);
	// 825D51A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D51A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D51A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D51AC: 4BCEAE55  bl 0x822c0000
	ctx.lr = 0x825D51B0;
	sub_822C0000(ctx, base);
	// 825D51B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D51B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D51B8: 48BD3004  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D51C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D51C0 size=440
    let mut pc: u32 = 0x825D51C0;
    'dispatch: loop {
        match pc {
            0x825D51C0 => {
    //   block [0x825D51C0..0x825D5378)
	// 825D51C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D51C4: 48BD2FA5  bl 0x831a8168
	ctx.lr = 0x825D51C8;
	sub_831A8130(ctx, base);
	// 825D51C8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D51CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D51D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D51D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D51D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D51DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D51E0: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825D51E4: 4881CA15  bl 0x82df1bf8
	ctx.lr = 0x825D51E8;
	sub_82DF1BF8(ctx, base);
	// 825D51E8: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D51EC: 4857206D  bl 0x82b47258
	ctx.lr = 0x825D51F0;
	sub_82B47258(ctx, base);
	// 825D51F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D51F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D51F8: 4881CA99  bl 0x82df1c90
	ctx.lr = 0x825D51FC;
	sub_82DF1C90(ctx, base);
	// 825D51FC: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D5200: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D5204: 4BFDC965  bl 0x825b1b68
	ctx.lr = 0x825D5208;
	sub_825B1B68(ctx, base);
	// 825D5208: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D520C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D5210: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D5214: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825D5218: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825D521C: 4BFDCEE5  bl 0x825b2100
	ctx.lr = 0x825D5220;
	sub_825B2100(ctx, base);
	// 825D5220: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D5224: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825D5228: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825D522C: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825D5230: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D5234: 48BD32DD  bl 0x831a8510
	ctx.lr = 0x825D5238;
	sub_831A8510(ctx, base);
	// 825D5238: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D523C: 93C100C4  stw r30, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 825D5240: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 825D5244: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825D5248: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 825D524C: 4BCEF215  bl 0x822c4460
	ctx.lr = 0x825D5250;
	sub_822C4460(ctx, base);
	// 825D5250: 897F00D0  lbz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 825D5254: 895F00D1  lbz r10, 0xd1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(209 as u32) ) } as u64;
	// 825D5258: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825D525C: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D5260: 996100CC  stb r11, 0xcc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 825D5264: 994100CE  stb r10, 0xce(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(206 as u32), ctx.r[10].u8 ) };
	// 825D5268: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D526C: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D5270: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D5274: 4E800421  bctrl
	ctx.lr = 0x825D5278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D5278: 896100CC  lbz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825D527C: 894100CE  lbz r10, 0xce(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(206 as u32) ) } as u64;
	// 825D5280: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D5284: 995F00D1  stb r10, 0xd1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(209 as u32), ctx.r[10].u8 ) };
	// 825D5288: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D528C: 556B039D  rlwinm. r11, r11, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D5290: 418200C8  beq 0x825d5358
	if ctx.cr[0].eq {
	pc = 0x825D5358; continue 'dispatch;
	}
	// 825D5294: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D5298: 4BFE0ED1  bl 0x825b6168
	ctx.lr = 0x825D529C;
	sub_825B6168(ctx, base);
	// 825D529C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 825D52A0: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D52A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D52A8: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 825D52AC: 419A0008  beq cr6, 0x825d52b4
	if ctx.cr[6].eq {
	pc = 0x825D52B4; continue 'dispatch;
	}
	// 825D52B0: 4BCEB5E1  bl 0x822c0890
	ctx.lr = 0x825D52B4;
	sub_822C0890(ctx, base);
	// 825D52B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D52B8: 4BFFFE89  bl 0x825d5140
	ctx.lr = 0x825D52BC;
	sub_825D5140(ctx, base);
	// 825D52BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D52C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D52C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D52C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D52CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D52D0: 419A0024  beq cr6, 0x825d52f4
	if ctx.cr[6].eq {
	pc = 0x825D52F4; continue 'dispatch;
	}
	// 825D52D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D52D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D52DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D52E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D52E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D52E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D52EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D52F0: 4082FFE8  bne 0x825d52d8
	if !ctx.cr[0].eq {
	pc = 0x825D52D8; continue 'dispatch;
	}
	// 825D52F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D52F8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D52FC: 4BF3A035  bl 0x8250f330
	ctx.lr = 0x825D5300;
	sub_8250F330(ctx, base);
	// 825D5300: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5304: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825D5308: 4BF14559  bl 0x824e9860
	ctx.lr = 0x825D530C;
	sub_824E9860(ctx, base);
	// 825D530C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D5310: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D5314: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D5318: 388AE3E8  addi r4, r10, -0x1c18
	ctx.r[4].s64 = ctx.r[10].s64 + -7192;
	// 825D531C: 38A0006A  li r5, 0x6a
	ctx.r[5].s64 = 106;
	// 825D5320: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825D5324: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D5328: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D532C: 48883715  bl 0x82e58a40
	ctx.lr = 0x825D5330;
	sub_82E58A40(ctx, base);
	// 825D5330: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D5334: 4881C95D  bl 0x82df1c90
	ctx.lr = 0x825D5338;
	sub_82DF1C90(ctx, base);
	// 825D5338: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D533C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5340: 419A0008  beq cr6, 0x825d5348
	if ctx.cr[6].eq {
	pc = 0x825D5348; continue 'dispatch;
	}
	// 825D5344: 4BCEB54D  bl 0x822c0890
	ctx.lr = 0x825D5348;
	sub_822C0890(ctx, base);
	// 825D5348: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D534C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5350: 419A0008  beq cr6, 0x825d5358
	if ctx.cr[6].eq {
	pc = 0x825D5358; continue 'dispatch;
	}
	// 825D5354: 4BCEB53D  bl 0x822c0890
	ctx.lr = 0x825D5358;
	sub_822C0890(ctx, base);
	// 825D5358: 806100C8  lwz r3, 0xc8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D535C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5360: 419A0008  beq cr6, 0x825d5368
	if ctx.cr[6].eq {
	pc = 0x825D5368; continue 'dispatch;
	}
	// 825D5364: 4BCEB52D  bl 0x822c0890
	ctx.lr = 0x825D5368;
	sub_822C0890(ctx, base);
	// 825D5368: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825D536C: 4881E0BD  bl 0x82df3428
	ctx.lr = 0x825D5370;
	sub_82DF3428(ctx, base);
	// 825D5370: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825D5374: 48BD2E44  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D5378 size=696
    let mut pc: u32 = 0x825D5378;
    'dispatch: loop {
        match pc {
            0x825D5378 => {
    //   block [0x825D5378..0x825D5630)
	// 825D5378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D537C: 48BD2DDD  bl 0x831a8158
	ctx.lr = 0x825D5380;
	sub_831A8130(ctx, base);
	// 825D5380: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5384: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D5388: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D538C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D5390: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D5394: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D5398: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 825D539C: 409A0008  bne cr6, 0x825d53a4
	if !ctx.cr[6].eq {
	pc = 0x825D53A4; continue 'dispatch;
	}
	// 825D53A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D53A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D53A8: 4BF333F9  bl 0x825087a0
	ctx.lr = 0x825D53AC;
	sub_825087A0(ctx, base);
	// 825D53AC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825D53B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D53B4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825D53B8: 4881E651  bl 0x82df3a08
	ctx.lr = 0x825D53BC;
	sub_82DF3A08(ctx, base);
	// 825D53BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D53C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D53C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D53C8: 4BF333B9  bl 0x82508780
	ctx.lr = 0x825D53CC;
	sub_82508780(ctx, base);
	// 825D53CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D53D0: 4881E059  bl 0x82df3428
	ctx.lr = 0x825D53D4;
	sub_82DF3428(ctx, base);
	// 825D53D4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D53D8: 4BCF3941  bl 0x822c8d18
	ctx.lr = 0x825D53DC;
	sub_822C8D18(ctx, base);
	// 825D53DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D53E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D53E4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D53E8: 409A0008  bne cr6, 0x825d53f0
	if !ctx.cr[6].eq {
	pc = 0x825D53F0; continue 'dispatch;
	}
	// 825D53EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D53F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D53F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D53F8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D53FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D5400: 4E800421  bctrl
	ctx.lr = 0x825D5404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D5404: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D5408: 4881C889  bl 0x82df1c90
	ctx.lr = 0x825D540C;
	sub_82DF1C90(ctx, base);
	// 825D540C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D5410: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D5414: 388BE3E8  addi r4, r11, -0x1c18
	ctx.r[4].s64 = ctx.r[11].s64 + -7192;
	// 825D5418: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 825D541C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825D5420: 4BCEAFB9  bl 0x822c03d8
	ctx.lr = 0x825D5424;
	sub_822C03D8(ctx, base);
	// 825D5424: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D5428: 41820010  beq 0x825d5438
	if ctx.cr[0].eq {
	pc = 0x825D5438; continue 'dispatch;
	}
	// 825D542C: 4BFDC64D  bl 0x825b1a78
	ctx.lr = 0x825D5430;
	sub_825B1A78(ctx, base);
	// 825D5430: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D5434: 48000008  b 0x825d543c
	pc = 0x825D543C; continue 'dispatch;
	// 825D5438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D543C: 3B5E00C8  addi r26, r30, 0xc8
	ctx.r[26].s64 = ctx.r[30].s64 + 200;
	// 825D5440: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D5444: 4BFDCF45  bl 0x825b2388
	ctx.lr = 0x825D5448;
	sub_825B2388(ctx, base);
	// 825D5448: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D544C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D5450: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D5454: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825D5458: 4881C7A1  bl 0x82df1bf8
	ctx.lr = 0x825D545C;
	sub_82DF1BF8(ctx, base);
	// 825D545C: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825D5460: 48571DF9  bl 0x82b47258
	ctx.lr = 0x825D5464;
	sub_82B47258(ctx, base);
	// 825D5464: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825D5468: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D546C: 4881C825  bl 0x82df1c90
	ctx.lr = 0x825D5470;
	sub_82DF1C90(ctx, base);
	// 825D5470: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D5474: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D5478: 388BE288  addi r4, r11, -0x1d78
	ctx.r[4].s64 = ctx.r[11].s64 + -7544;
	// 825D547C: 4881E58D  bl 0x82df3a08
	ctx.lr = 0x825D5480;
	sub_82DF3A08(ctx, base);
	// 825D5480: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 825D5484: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 825D5488: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D548C: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 825D5490: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825D5494: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825D5498: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825D549C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D54A0: 4882A399  bl 0x82dff838
	ctx.lr = 0x825D54A4;
	sub_82DFF838(ctx, base);
	// 825D54A4: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 825D54A8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825D54AC: 3F208212  lis r25, -0x7dee
	ctx.r[25].s64 = -2112749568;
	// 825D54B0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D54B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D54B8: 419A0084  beq cr6, 0x825d553c
	if ctx.cr[6].eq {
	pc = 0x825D553C; continue 'dispatch;
	}
	// 825D54BC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D54C0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D54C4: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825D54C8: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D54CC: 40980070  bge cr6, 0x825d553c
	if !ctx.cr[6].lt {
	pc = 0x825D553C; continue 'dispatch;
	}
	// 825D54D0: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D54D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D54D8: 4881E729  bl 0x82df3c00
	ctx.lr = 0x825D54DC;
	sub_82DF3C00(ctx, base);
	// 825D54DC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D54E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D54E4: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D54E8: 4881EB61  bl 0x82df4048
	ctx.lr = 0x825D54EC;
	sub_82DF4048(ctx, base);
	// 825D54EC: 8179B230  lwz r11, -0x4dd0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825D54F0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D54F4: 419A0034  beq cr6, 0x825d5528
	if ctx.cr[6].eq {
	pc = 0x825D5528; continue 'dispatch;
	}
	// 825D54F8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D54FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D5500: 7F9D5A14  add r28, r29, r11
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D5504: 4881E58D  bl 0x82df3a90
	ctx.lr = 0x825D5508;
	sub_82DF3A90(ctx, base);
	// 825D5508: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D550C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D5510: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D5514: 4881EDF5  bl 0x82df4308
	ctx.lr = 0x825D5518;
	sub_82DF4308(ctx, base);
	// 825D5518: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D551C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D5520: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D5524: 4BD19805  bl 0x822eed28
	ctx.lr = 0x825D5528;
	sub_822EED28(ctx, base);
	// 825D5528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D552C: 4881DEFD  bl 0x82df3428
	ctx.lr = 0x825D5530;
	sub_82DF3428(ctx, base);
	// 825D5530: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825D5534: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825D5538: 4BFFFF78  b 0x825d54b0
	pc = 0x825D54B0; continue 'dispatch;
	// 825D553C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D5540: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D5544: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D5548: 48000E51  bl 0x825d6398
	ctx.lr = 0x825D554C;
	sub_825D6398(ctx, base);
	// 825D554C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D5550: 3BBE00C0  addi r29, r30, 0xc0
	ctx.r[29].s64 = ctx.r[30].s64 + 192;
	// 825D5554: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D5558: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825D555C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5560: 917E00C0  stw r11, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D5564: 4BCEEEFD  bl 0x822c4460
	ctx.lr = 0x825D5568;
	sub_822C4460(ctx, base);
	// 825D5568: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825D556C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5570: 419A0008  beq cr6, 0x825d5578
	if ctx.cr[6].eq {
	pc = 0x825D5578; continue 'dispatch;
	}
	// 825D5574: 4BCEB31D  bl 0x822c0890
	ctx.lr = 0x825D5578;
	sub_822C0890(ctx, base);
	// 825D5578: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D557C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825D5580: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D5584: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825D5588: 4BFDCB79  bl 0x825b2100
	ctx.lr = 0x825D558C;
	sub_825B2100(ctx, base);
	// 825D558C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D5590: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825D5594: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825D5598: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D559C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D55A0: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 825D55A4: 48BD2F6D  bl 0x831a8510
	ctx.lr = 0x825D55A8;
	sub_831A8510(ctx, base);
	// 825D55A8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D55AC: 93E100E4  stw r31, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[31].u32 ) };
	// 825D55B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D55B4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825D55B8: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 825D55BC: 4BCEEEA5  bl 0x822c4460
	ctx.lr = 0x825D55C0;
	sub_822C4460(ctx, base);
	// 825D55C0: 897E00D0  lbz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 825D55C4: 895E00D1  lbz r10, 0xd1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(209 as u32) ) } as u64;
	// 825D55C8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825D55CC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D55D0: 996100EC  stb r11, 0xec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 825D55D4: 994100EE  stb r10, 0xee(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(238 as u32), ctx.r[10].u8 ) };
	// 825D55D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D55DC: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825D55E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D55E4: 4E800421  bctrl
	ctx.lr = 0x825D55E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D55E8: 896100EC  lbz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825D55EC: 894100EE  lbz r10, 0xee(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(238 as u32) ) } as u64;
	// 825D55F0: 806100E8  lwz r3, 0xe8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 825D55F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D55F8: 997E00D0  stb r11, 0xd0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D55FC: 995E00D1  stb r10, 0xd1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(209 as u32), ctx.r[10].u8 ) };
	// 825D5600: 419A0008  beq cr6, 0x825d5608
	if ctx.cr[6].eq {
	pc = 0x825D5608; continue 'dispatch;
	}
	// 825D5604: 4BCEB28D  bl 0x822c0890
	ctx.lr = 0x825D5608;
	sub_822C0890(ctx, base);
	// 825D5608: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825D560C: 4881DE1D  bl 0x82df3428
	ctx.lr = 0x825D5610;
	sub_82DF3428(ctx, base);
	// 825D5610: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D5614: 4BDFCDD5  bl 0x823d23e8
	ctx.lr = 0x825D5618;
	sub_823D23E8(ctx, base);
	// 825D5618: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D561C: 4BDFCDCD  bl 0x823d23e8
	ctx.lr = 0x825D5620;
	sub_823D23E8(ctx, base);
	// 825D5620: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D5624: 4881DE05  bl 0x82df3428
	ctx.lr = 0x825D5628;
	sub_82DF3428(ctx, base);
	// 825D5628: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825D562C: 48BD2B7C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D5630 size=136
    let mut pc: u32 = 0x825D5630;
    'dispatch: loop {
        match pc {
            0x825D5630 => {
    //   block [0x825D5630..0x825D56B8)
	// 825D5630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D5638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D563C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D5640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5644: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D5648: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D564C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D5650: 409A0020  bne cr6, 0x825d5670
	if !ctx.cr[6].eq {
	pc = 0x825D5670; continue 'dispatch;
	}
	// 825D5654: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D5658: 419A0048  beq cr6, 0x825d56a0
	if ctx.cr[6].eq {
	pc = 0x825D56A0; continue 'dispatch;
	}
	// 825D565C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5660: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5664: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D5668: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D566C: 48000034  b 0x825d56a0
	pc = 0x825D56A0; continue 'dispatch;
	// 825D5670: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825D5674: 419A002C  beq cr6, 0x825d56a0
	if ctx.cr[6].eq {
	pc = 0x825D56A0; continue 'dispatch;
	}
	// 825D5678: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D567C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5680: 388BC010  addi r4, r11, -0x3ff0
	ctx.r[4].s64 = ctx.r[11].s64 + -16368;
	// 825D5684: 48BD2A75  bl 0x831a80f8
	ctx.lr = 0x825D5688;
	sub_831A80F8(ctx, base);
	// 825D5688: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D568C: 4182000C  beq 0x825d5698
	if ctx.cr[0].eq {
	pc = 0x825D5698; continue 'dispatch;
	}
	// 825D5690: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825D5694: 4800000C  b 0x825d56a0
	pc = 0x825D56A0; continue 'dispatch;
	// 825D5698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D569C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D56A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D56A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D56A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D56AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D56B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D56B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D56B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D56B8 size=120
    let mut pc: u32 = 0x825D56B8;
    'dispatch: loop {
        match pc {
            0x825D56B8 => {
    //   block [0x825D56B8..0x825D5730)
	// 825D56B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D56BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D56C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D56C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D56C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D56CC: 897F012C  lbz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825D56D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D56D4: 41820038  beq 0x825d570c
	if ctx.cr[0].eq {
	pc = 0x825D570C; continue 'dispatch;
	}
	// 825D56D8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D56DC: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D56E0: 41820034  beq 0x825d5714
	if ctx.cr[0].eq {
	pc = 0x825D5714; continue 'dispatch;
	}
	// 825D56E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D56E8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D56EC: 4BE9B8ED  bl 0x82470fd8
	ctx.lr = 0x825D56F0;
	sub_82470FD8(ctx, base);
	// 825D56F0: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D56F4: 484FD245  bl 0x82ad2938
	ctx.lr = 0x825D56F8;
	sub_82AD2938(ctx, base);
	// 825D56F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D56FC: D03F0150  stfs f1, 0x150(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 825D5700: 997F012C  stb r11, 0x12c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u8 ) };
	// 825D5704: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825D5708: 4800000C  b 0x825d5714
	pc = 0x825D5714; continue 'dispatch;
	// 825D570C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D5710: 4BFDF4E9  bl 0x825b4bf8
	ctx.lr = 0x825D5714;
	sub_825B4BF8(ctx, base);
	// 825D5714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D5718: 4BFE0EC9  bl 0x825b65e0
	ctx.lr = 0x825D571C;
	sub_825B65E0(ctx, base);
	// 825D571C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D5720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D5724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D5728: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D572C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D5730 size=184
    let mut pc: u32 = 0x825D5730;
    'dispatch: loop {
        match pc {
            0x825D5730 => {
    //   block [0x825D5730..0x825D57E8)
	// 825D5730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D5738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D573C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D5740: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825D5744: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D574C: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D5750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5754: 419A0078  beq cr6, 0x825d57cc
	if ctx.cr[6].eq {
	pc = 0x825D57CC; continue 'dispatch;
	}
	// 825D5758: 815F0138  lwz r10, 0x138(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D575C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D5760: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D5764: 41820068  beq 0x825d57cc
	if ctx.cr[0].eq {
	pc = 0x825D57CC; continue 'dispatch;
	}
	// 825D5768: 83DF0140  lwz r30, 0x140(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D576C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D5770: 419A005C  beq cr6, 0x825d57cc
	if ctx.cr[6].eq {
	pc = 0x825D57CC; continue 'dispatch;
	}
	// 825D5774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5778: 4BE9B851  bl 0x82470fc8
	ctx.lr = 0x825D577C;
	sub_82470FC8(ctx, base);
	// 825D577C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5780: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825D5784: 4BE9B83D  bl 0x82470fc0
	ctx.lr = 0x825D5788;
	sub_82470FC0(ctx, base);
	// 825D5788: C01F0150  lfs f0, 0x150(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D578C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 825D5790: 40980008  bge cr6, 0x825d5798
	if !ctx.cr[6].lt {
	pc = 0x825D5798; continue 'dispatch;
	}
	// 825D5794: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 825D5798: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825D579C: 40990008  ble cr6, 0x825d57a4
	if !ctx.cr[6].gt {
	pc = 0x825D57A4; continue 'dispatch;
	}
	// 825D57A0: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	// 825D57A4: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 825D57A8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D57AC: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 825D57B0: 4BE9C0D9  bl 0x82471888
	ctx.lr = 0x825D57B4;
	sub_82471888(ctx, base);
	// 825D57B4: C03F015C  lfs f1, 0x15c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D57B8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D57BC: 4812E7E5  bl 0x82703fa0
	ctx.lr = 0x825D57C0;
	sub_82703FA0(ctx, base);
	// 825D57C0: 889F0160  lbz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 825D57C4: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D57C8: 4BE9B809  bl 0x82470fd0
	ctx.lr = 0x825D57CC;
	sub_82470FD0(ctx, base);
	// 825D57CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D57D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D57D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D57D8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825D57DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D57E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D57E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D57E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D57E8 size=196
    let mut pc: u32 = 0x825D57E8;
    'dispatch: loop {
        match pc {
            0x825D57E8 => {
    //   block [0x825D57E8..0x825D58AC)
	// 825D57E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D57EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D57F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D57F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D57F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D57FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D5800: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D5804: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D5808: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D580C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5810: 4BCEB129  bl 0x822c0938
	ctx.lr = 0x825D5814;
	sub_822C0938(ctx, base);
	// 825D5814: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D5818: 41820028  beq 0x825d5840
	if ctx.cr[0].eq {
	pc = 0x825D5840; continue 'dispatch;
	}
	// 825D581C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D5820: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D5824: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D5828: 392BE44C  addi r9, r11, -0x1bb4
	ctx.r[9].s64 = ctx.r[11].s64 + -7092;
	// 825D582C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D5830: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D5834: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D5838: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D583C: 48000008  b 0x825d5844
	pc = 0x825D5844; continue 'dispatch;
	// 825D5840: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D5844: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D584C: 409A0044  bne cr6, 0x825d5890
	if !ctx.cr[6].eq {
	pc = 0x825D5890; continue 'dispatch;
	}
	// 825D5850: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D5854: 419A001C  beq cr6, 0x825d5870
	if ctx.cr[6].eq {
	pc = 0x825D5870; continue 'dispatch;
	}
	// 825D5858: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D585C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D5860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D5864: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D586C: 4E800421  bctrl
	ctx.lr = 0x825D5870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D5870: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D5874: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D5878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D587C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D5880: 816BBF70  lwz r11, -0x4090(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16528 as u32) ) } as u64;
	// 825D5884: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D5888: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D588C: 4BCEA775  bl 0x822c0000
	ctx.lr = 0x825D5890;
	sub_822C0000(ctx, base);
	// 825D5890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D5898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D589C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D58A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D58A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D58A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D58B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D58B0 size=196
    let mut pc: u32 = 0x825D58B0;
    'dispatch: loop {
        match pc {
            0x825D58B0 => {
    //   block [0x825D58B0..0x825D5974)
	// 825D58B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D58B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D58B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D58BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D58C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D58C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D58C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D58CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D58D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D58D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D58D8: 4BCEB061  bl 0x822c0938
	ctx.lr = 0x825D58DC;
	sub_822C0938(ctx, base);
	// 825D58DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D58E0: 41820028  beq 0x825d5908
	if ctx.cr[0].eq {
	pc = 0x825D5908; continue 'dispatch;
	}
	// 825D58E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D58E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D58EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D58F0: 392BE460  addi r9, r11, -0x1ba0
	ctx.r[9].s64 = ctx.r[11].s64 + -7072;
	// 825D58F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D58F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D58FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D5900: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D5904: 48000008  b 0x825d590c
	pc = 0x825D590C; continue 'dispatch;
	// 825D5908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D590C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5914: 409A0044  bne cr6, 0x825d5958
	if !ctx.cr[6].eq {
	pc = 0x825D5958; continue 'dispatch;
	}
	// 825D5918: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D591C: 419A001C  beq cr6, 0x825d5938
	if ctx.cr[6].eq {
	pc = 0x825D5938; continue 'dispatch;
	}
	// 825D5920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5924: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D5928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D592C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D5934: 4E800421  bctrl
	ctx.lr = 0x825D5938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D5938: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D593C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D5940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D5944: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D5948: 816BBF70  lwz r11, -0x4090(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16528 as u32) ) } as u64;
	// 825D594C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D5950: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D5954: 4BCEA6AD  bl 0x822c0000
	ctx.lr = 0x825D5958;
	sub_822C0000(ctx, base);
	// 825D5958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D595C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D5960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D5964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D5968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D596C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D5970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D5978 size=72
    let mut pc: u32 = 0x825D5978;
    'dispatch: loop {
        match pc {
            0x825D5978 => {
    //   block [0x825D5978..0x825D59C0)
	// 825D5978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D597C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D5980: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5984: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825D5988: 419A001C  beq cr6, 0x825d59a4
	if ctx.cr[6].eq {
	pc = 0x825D59A4; continue 'dispatch;
	}
	// 825D598C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D5990: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D5994: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825D5998: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D599C: 4BFFFC95  bl 0x825d5630
	ctx.lr = 0x825D59A0;
	sub_825D5630(ctx, base);
	// 825D59A0: 48000010  b 0x825d59b0
	pc = 0x825D59B0; continue 'dispatch;
	// 825D59A4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D59A8: 396BC010  addi r11, r11, -0x3ff0
	ctx.r[11].s64 = ctx.r[11].s64 + -16368;
	// 825D59AC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D59B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D59B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D59B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D59BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D59C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D59C0 size=112
    let mut pc: u32 = 0x825D59C0;
    'dispatch: loop {
        match pc {
            0x825D59C0 => {
    //   block [0x825D59C0..0x825D5A30)
	// 825D59C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D59C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D59C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D59CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D59D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D59D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D59D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D59DC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825D59E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D59E4: 4BFFFECD  bl 0x825d58b0
	ctx.lr = 0x825D59E8;
	sub_825D58B0(ctx, base);
	// 825D59E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D59EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D59F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D59F4: 4BCEA60D  bl 0x822c0000
	ctx.lr = 0x825D59F8;
	sub_822C0000(ctx, base);
	// 825D59F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D59FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D5A00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5A04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D5A08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5A0C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D5A10: 419A0008  beq cr6, 0x825d5a18
	if ctx.cr[6].eq {
	pc = 0x825D5A18; continue 'dispatch;
	}
	// 825D5A14: 4BCEAE7D  bl 0x822c0890
	ctx.lr = 0x825D5A18;
	sub_822C0890(ctx, base);
	// 825D5A18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D5A1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D5A20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D5A24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D5A28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D5A2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D5A30 size=260
    let mut pc: u32 = 0x825D5A30;
    'dispatch: loop {
        match pc {
            0x825D5A30 => {
    //   block [0x825D5A30..0x825D5B34)
	// 825D5A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5A34: 48BD2739  bl 0x831a816c
	ctx.lr = 0x825D5A38;
	sub_831A8130(ctx, base);
	// 825D5A38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5A3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D5A40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D5A44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D5A48: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5A4C: 4BF39A7D  bl 0x8250f4c8
	ctx.lr = 0x825D5A50;
	sub_8250F4C8(ctx, base);
	// 825D5A50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5A54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D5A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5A5C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D5A60: 409A0008  bne cr6, 0x825d5a68
	if !ctx.cr[6].eq {
	pc = 0x825D5A68; continue 'dispatch;
	}
	// 825D5A64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D5A68: 4BF32AC1  bl 0x82508528
	ctx.lr = 0x825D5A6C;
	sub_82508528(ctx, base);
	// 825D5A6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D5A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D5A74: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5A78: 4886A491  bl 0x82e3ff08
	ctx.lr = 0x825D5A7C;
	sub_82E3FF08(ctx, base);
	// 825D5A7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D5A80: 4881C211  bl 0x82df1c90
	ctx.lr = 0x825D5A84;
	sub_82DF1C90(ctx, base);
	// 825D5A84: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 825D5A88: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D5A8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D5A90: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D5A94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D5A98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D5A9C: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D5AA0: 4886B699  bl 0x82e41138
	ctx.lr = 0x825D5AA4;
	sub_82E41138(ctx, base);
	// 825D5AA4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D5AA8: 48A32681  bl 0x83008128
	ctx.lr = 0x825D5AAC;
	sub_83008128(ctx, base);
	// 825D5AAC: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825D5AB0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D5AB4: 4199000C  bgt cr6, 0x825d5ac0
	if ctx.cr[6].gt {
	pc = 0x825D5AC0; continue 'dispatch;
	}
	// 825D5AB8: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 825D5ABC: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 825D5AC0: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D5AC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D5AC8: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D5ACC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D5AD0: 388BE470  addi r4, r11, -0x1b90
	ctx.r[4].s64 = ctx.r[11].s64 + -7056;
	// 825D5AD4: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 825D5AD8: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 825D5ADC: 4881C90D  bl 0x82df23e8
	ctx.lr = 0x825D5AE0;
	sub_82DF23E8(ctx, base);
	// 825D5AE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D5AE4: 41820028  beq 0x825d5b0c
	if ctx.cr[0].eq {
	pc = 0x825D5B0C; continue 'dispatch;
	}
	// 825D5AE8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825D5AEC: 88FF0160  lbz r7, 0x160(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 825D5AF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D5AF4: C03F015C  lfs f1, 0x15c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D5AF8: 390B6910  addi r8, r11, 0x6910
	ctx.r[8].s64 = ctx.r[11].s64 + 26896;
	// 825D5AFC: 80BF0158  lwz r5, 0x158(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825D5B00: 4BE9B711  bl 0x82471210
	ctx.lr = 0x825D5B04;
	sub_82471210(ctx, base);
	// 825D5B04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D5B08: 48000008  b 0x825d5b10
	pc = 0x825D5B10; continue 'dispatch;
	// 825D5B0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D5B10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5B14: 4BDC345D  bl 0x82398f70
	ctx.lr = 0x825D5B18;
	sub_82398F70(ctx, base);
	// 825D5B18: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D5B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5B20: 419A0008  beq cr6, 0x825d5b28
	if ctx.cr[6].eq {
	pc = 0x825D5B28; continue 'dispatch;
	}
	// 825D5B24: 4BCEAD6D  bl 0x822c0890
	ctx.lr = 0x825D5B28;
	sub_822C0890(ctx, base);
	// 825D5B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5B2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D5B30: 48BD268C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D5B38 size=556
    let mut pc: u32 = 0x825D5B38;
    'dispatch: loop {
        match pc {
            0x825D5B38 => {
    //   block [0x825D5B38..0x825D5D64)
	// 825D5B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5B3C: 48BD2629  bl 0x831a8164
	ctx.lr = 0x825D5B40;
	sub_831A8130(ctx, base);
	// 825D5B40: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825D5B44: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5B48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D5B4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D5B50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D5B54: 3BABE470  addi r29, r11, -0x1b90
	ctx.r[29].s64 = ctx.r[11].s64 + -7056;
	// 825D5B58: 3BFE0140  addi r31, r30, 0x140
	ctx.r[31].s64 = ctx.r[30].s64 + 320;
	// 825D5B5C: 817E0140  lwz r11, 0x140(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D5B60: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D5B64: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D5B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5B6C: 419A00DC  beq cr6, 0x825d5c48
	if ctx.cr[6].eq {
	pc = 0x825D5C48; continue 'dispatch;
	}
	// 825D5B70: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825D5B74: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D5B78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D5B7C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D5B80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D5B84: 48270A8D  bl 0x82846610
	ctx.lr = 0x825D5B88;
	sub_82846610(ctx, base);
	// 825D5B88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5B8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D5B90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D5B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5B98: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D5B9C: 419A0024  beq cr6, 0x825d5bc0
	if ctx.cr[6].eq {
	pc = 0x825D5BC0; continue 'dispatch;
	}
	// 825D5BA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D5BA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D5BA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D5BAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D5BB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D5BB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D5BB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D5BBC: 4082FFE8  bne 0x825d5ba4
	if !ctx.cr[0].eq {
	pc = 0x825D5BA4; continue 'dispatch;
	}
	// 825D5BC0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D5BC4: 809E0120  lwz r4, 0x120(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5BC8: 4BF39951  bl 0x8250f518
	ctx.lr = 0x825D5BCC;
	sub_8250F518(ctx, base);
	// 825D5BCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5BD4: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D5BD8: 409A0008  bne cr6, 0x825d5be0
	if !ctx.cr[6].eq {
	pc = 0x825D5BE0; continue 'dispatch;
	}
	// 825D5BDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D5BE0: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825D5BE4: 4BF5246D  bl 0x82528050
	ctx.lr = 0x825D5BE8;
	sub_82528050(ctx, base);
	// 825D5BE8: 817E0120  lwz r11, 0x120(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5BEC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D5BF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D5BF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D5BF8: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 825D5BFC: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 825D5C00: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825D5C04: 48882E3D  bl 0x82e58a40
	ctx.lr = 0x825D5C08;
	sub_82E58A40(ctx, base);
	// 825D5C08: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D5C0C: 4881C085  bl 0x82df1c90
	ctx.lr = 0x825D5C10;
	sub_82DF1C90(ctx, base);
	// 825D5C10: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D5C14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5C18: 419A0008  beq cr6, 0x825d5c20
	if ctx.cr[6].eq {
	pc = 0x825D5C20; continue 'dispatch;
	}
	// 825D5C1C: 4BCEAC75  bl 0x822c0890
	ctx.lr = 0x825D5C20;
	sub_822C0890(ctx, base);
	// 825D5C20: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D5C24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5C28: 419A0008  beq cr6, 0x825d5c30
	if ctx.cr[6].eq {
	pc = 0x825D5C30; continue 'dispatch;
	}
	// 825D5C2C: 4BCEAC65  bl 0x822c0890
	ctx.lr = 0x825D5C30;
	sub_822C0890(ctx, base);
	// 825D5C30: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825D5C34: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D5C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5C3C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825D5C40: 419A0008  beq cr6, 0x825d5c48
	if ctx.cr[6].eq {
	pc = 0x825D5C48; continue 'dispatch;
	}
	// 825D5C44: 4BCEAC4D  bl 0x822c0890
	ctx.lr = 0x825D5C48;
	sub_822C0890(ctx, base);
	// 825D5C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D5C4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D5C50: 4BFFFDE1  bl 0x825d5a30
	ctx.lr = 0x825D5C54;
	sub_825D5A30(ctx, base);
	// 825D5C54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D5C58: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D5C5C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D5C60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5C64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D5C68: 4BCEE7F9  bl 0x822c4460
	ctx.lr = 0x825D5C6C;
	sub_822C4460(ctx, base);
	// 825D5C6C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D5C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5C74: 419A0008  beq cr6, 0x825d5c7c
	if ctx.cr[6].eq {
	pc = 0x825D5C7C; continue 'dispatch;
	}
	// 825D5C78: 4BCEAC19  bl 0x822c0890
	ctx.lr = 0x825D5C7C;
	sub_822C0890(ctx, base);
	// 825D5C7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D5C80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5C84: 4BE9B355  bl 0x82470fd8
	ctx.lr = 0x825D5C88;
	sub_82470FD8(ctx, base);
	// 825D5C88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5C8C: 4BFFFAA5  bl 0x825d5730
	ctx.lr = 0x825D5C90;
	sub_825D5730(ctx, base);
	// 825D5C90: 39600BBB  li r11, 0xbbb
	ctx.r[11].s64 = 3003;
	// 825D5C94: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825D5C98: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825D5C9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D5CA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D5CA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D5CA8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D5CAC: 485967CD  bl 0x82b6c478
	ctx.lr = 0x825D5CB0;
	sub_82B6C478(ctx, base);
	// 825D5CB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5CB4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D5CB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D5CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5CC0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D5CC4: 419A0024  beq cr6, 0x825d5ce8
	if ctx.cr[6].eq {
	pc = 0x825D5CE8; continue 'dispatch;
	}
	// 825D5CC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D5CCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D5CD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D5CD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D5CD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D5CDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D5CE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D5CE4: 4082FFE8  bne 0x825d5ccc
	if !ctx.cr[0].eq {
	pc = 0x825D5CCC; continue 'dispatch;
	}
	// 825D5CE8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D5CEC: 809E0120  lwz r4, 0x120(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5CF0: 4BF39829  bl 0x8250f518
	ctx.lr = 0x825D5CF4;
	sub_8250F518(ctx, base);
	// 825D5CF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5CFC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D5D00: 409A0008  bne cr6, 0x825d5d08
	if !ctx.cr[6].eq {
	pc = 0x825D5D08; continue 'dispatch;
	}
	// 825D5D04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D5D08: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 825D5D0C: 4BF52345  bl 0x82528050
	ctx.lr = 0x825D5D10;
	sub_82528050(ctx, base);
	// 825D5D10: 817E0120  lwz r11, 0x120(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5D14: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D5D18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D5D1C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D5D20: 38A000A9  li r5, 0xa9
	ctx.r[5].s64 = 169;
	// 825D5D24: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 825D5D28: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825D5D2C: 48882D15  bl 0x82e58a40
	ctx.lr = 0x825D5D30;
	sub_82E58A40(ctx, base);
	// 825D5D30: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D5D34: 4881BF5D  bl 0x82df1c90
	ctx.lr = 0x825D5D38;
	sub_82DF1C90(ctx, base);
	// 825D5D38: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D5D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5D40: 419A0008  beq cr6, 0x825d5d48
	if ctx.cr[6].eq {
	pc = 0x825D5D48; continue 'dispatch;
	}
	// 825D5D44: 4BCEAB4D  bl 0x822c0890
	ctx.lr = 0x825D5D48;
	sub_822C0890(ctx, base);
	// 825D5D48: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825D5D4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D5D50: 419A0008  beq cr6, 0x825d5d58
	if ctx.cr[6].eq {
	pc = 0x825D5D58; continue 'dispatch;
	}
	// 825D5D54: 4BCEAB3D  bl 0x822c0890
	ctx.lr = 0x825D5D58;
	sub_822C0890(ctx, base);
	// 825D5D58: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825D5D5C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825D5D60: 48BD2454  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D5D68 size=356
    let mut pc: u32 = 0x825D5D68;
    'dispatch: loop {
        match pc {
            0x825D5D68 => {
    //   block [0x825D5D68..0x825D5ECC)
	// 825D5D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5D6C: 48BD23FD  bl 0x831a8168
	ctx.lr = 0x825D5D70;
	sub_831A8130(ctx, base);
	// 825D5D70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D5D78: 897F012C  lbz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825D5D7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D5D80: 40820144  bne 0x825d5ec4
	if !ctx.cr[0].eq {
	pc = 0x825D5EC4; continue 'dispatch;
	}
	// 825D5D84: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D5D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5D8C: 419A0138  beq cr6, 0x825d5ec4
	if ctx.cr[6].eq {
	pc = 0x825D5EC4; continue 'dispatch;
	}
	// 825D5D90: 815F0138  lwz r10, 0x138(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D5D94: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D5D98: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D5D9C: 41820128  beq 0x825d5ec4
	if ctx.cr[0].eq {
	pc = 0x825D5EC4; continue 'dispatch;
	}
	// 825D5DA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D5DA4: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D5DA8: 4BE9B231  bl 0x82470fd8
	ctx.lr = 0x825D5DAC;
	sub_82470FD8(ctx, base);
	// 825D5DAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D5DB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D5DB4: 388BE470  addi r4, r11, -0x1b90
	ctx.r[4].s64 = ctx.r[11].s64 + -7056;
	// 825D5DB8: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 825D5DBC: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 825D5DC0: 4881C629  bl 0x82df23e8
	ctx.lr = 0x825D5DC4;
	sub_82DF23E8(ctx, base);
	// 825D5DC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D5DC8: 41820010  beq 0x825d5dd8
	if ctx.cr[0].eq {
	pc = 0x825D5DD8; continue 'dispatch;
	}
	// 825D5DCC: 4BFFEBF5  bl 0x825d49c0
	ctx.lr = 0x825D5DD0;
	sub_825D49C0(ctx, base);
	// 825D5DD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D5DD4: 48000008  b 0x825d5ddc
	pc = 0x825D5DDC; continue 'dispatch;
	// 825D5DD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D5DDC: 387F0148  addi r3, r31, 0x148
	ctx.r[3].s64 = ctx.r[31].s64 + 328;
	// 825D5DE0: 4BFFFBE1  bl 0x825d59c0
	ctx.lr = 0x825D5DE4;
	sub_825D59C0(ctx, base);
	// 825D5DE4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825D5DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D5DEC: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 825D5DF0: 4881DC19  bl 0x82df3a08
	ctx.lr = 0x825D5DF4;
	sub_82DF3A08(ctx, base);
	// 825D5DF4: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 825D5DF8: 815F0148  lwz r10, 0x148(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 825D5DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5E00: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D5E04: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D5E08: 419A0024  beq cr6, 0x825d5e2c
	if ctx.cr[6].eq {
	pc = 0x825D5E2C; continue 'dispatch;
	}
	// 825D5E0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D5E10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D5E14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D5E18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D5E1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D5E20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D5E24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D5E28: 4082FFE8  bne 0x825d5e10
	if !ctx.cr[0].eq {
	pc = 0x825D5E10; continue 'dispatch;
	}
	// 825D5E2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D5E30: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5E34: 4BF39695  bl 0x8250f4c8
	ctx.lr = 0x825D5E38;
	sub_8250F4C8(ctx, base);
	// 825D5E38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5E40: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 825D5E44: 409A0008  bne cr6, 0x825d5e4c
	if !ctx.cr[6].eq {
	pc = 0x825D5E4C; continue 'dispatch;
	}
	// 825D5E48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D5E4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D5E50: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5E54: 4BF39675  bl 0x8250f4c8
	ctx.lr = 0x825D5E58;
	sub_8250F4C8(ctx, base);
	// 825D5E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D5E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5E60: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 825D5E64: 409A0008  bne cr6, 0x825d5e6c
	if !ctx.cr[6].eq {
	pc = 0x825D5E6C; continue 'dispatch;
	}
	// 825D5E68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D5E6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D5E70: 839F0120  lwz r28, 0x120(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D5E74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D5E78: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D5E7C: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 825D5E80: 4BF357D1  bl 0x8250b650
	ctx.lr = 0x825D5E84;
	sub_8250B650(ctx, base);
	// 825D5E84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D5E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D5E8C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825D5E90: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825D5E94: 4BF37675  bl 0x8250d508
	ctx.lr = 0x825D5E98;
	sub_8250D508(ctx, base);
	// 825D5E98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D5E9C: 4881BDF5  bl 0x82df1c90
	ctx.lr = 0x825D5EA0;
	sub_82DF1C90(ctx, base);
	// 825D5EA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D5EA4: 4881BDED  bl 0x82df1c90
	ctx.lr = 0x825D5EA8;
	sub_82DF1C90(ctx, base);
	// 825D5EA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D5EAC: 4881BDE5  bl 0x82df1c90
	ctx.lr = 0x825D5EB0;
	sub_82DF1C90(ctx, base);
	// 825D5EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D5EB4: 4881D575  bl 0x82df3428
	ctx.lr = 0x825D5EB8;
	sub_82DF3428(ctx, base);
	// 825D5EB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D5EBC: 997F012C  stb r11, 0x12c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u8 ) };
	// 825D5EC0: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825D5EC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825D5EC8: 48BD22F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D5ED0 size=12
    let mut pc: u32 = 0x825D5ED0;
    'dispatch: loop {
        match pc {
            0x825D5ED0 => {
    //   block [0x825D5ED0..0x825D5EDC)
	// 825D5ED0: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D5ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5ED8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5EDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D5EDC size=16
    let mut pc: u32 = 0x825D5EDC;
    'dispatch: loop {
        match pc {
            0x825D5EDC => {
    //   block [0x825D5EDC..0x825D5EEC)
	// 825D5EDC: 81430138  lwz r10, 0x138(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D5EE0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D5EE4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D5EE8: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5EEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D5EEC size=16
    let mut pc: u32 = 0x825D5EEC;
    'dispatch: loop {
        match pc {
            0x825D5EEC => {
    //   block [0x825D5EEC..0x825D5EFC)
	// 825D5EEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D5EF0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D5EF4: D0030150  stfs f0, 0x150(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 825D5EF8: 4BFFFC40  b 0x825d5b38
	sub_825D5B38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5EFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D5EFC size=4
    let mut pc: u32 = 0x825D5EFC;
    'dispatch: loop {
        match pc {
            0x825D5EFC => {
    //   block [0x825D5EFC..0x825D5F00)
	// 825D5EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D5F00 size=20
    let mut pc: u32 = 0x825D5F00;
    'dispatch: loop {
        match pc {
            0x825D5F00 => {
    //   block [0x825D5F00..0x825D5F14)
	// 825D5F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D5F04: 91630158  stw r11, 0x158(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 825D5F08: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D5F0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D5F10: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5F14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D5F14 size=16
    let mut pc: u32 = 0x825D5F14;
    'dispatch: loop {
        match pc {
            0x825D5F14 => {
    //   block [0x825D5F14..0x825D5F24)
	// 825D5F14: 81430138  lwz r10, 0x138(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D5F18: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D5F1C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D5F20: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5F24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D5F24 size=16
    let mut pc: u32 = 0x825D5F24;
    'dispatch: loop {
        match pc {
            0x825D5F24 => {
    //   block [0x825D5F24..0x825D5F34)
	// 825D5F24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D5F28: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D5F2C: D0030150  stfs f0, 0x150(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 825D5F30: 4BFFFC08  b 0x825d5b38
	sub_825D5B38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5F34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D5F34 size=4
    let mut pc: u32 = 0x825D5F34;
    'dispatch: loop {
        match pc {
            0x825D5F34 => {
    //   block [0x825D5F34..0x825D5F38)
	// 825D5F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D5F38 size=128
    let mut pc: u32 = 0x825D5F38;
    'dispatch: loop {
        match pc {
            0x825D5F38 => {
    //   block [0x825D5F38..0x825D5FB8)
	// 825D5F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5F3C: 48BD2231  bl 0x831a816c
	ctx.lr = 0x825D5F40;
	sub_831A8130(ctx, base);
	// 825D5F40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5F44: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D5F48: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D5F4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D5F50: 3BEB7D9C  addi r31, r11, 0x7d9c
	ctx.r[31].s64 = ctx.r[11].s64 + 32156;
	// 825D5F54: 816A7DA4  lwz r11, 0x7da4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32164 as u32) ) } as u64;
	// 825D5F58: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D5F5C: 40820024  bne 0x825d5f80
	if !ctx.cr[0].eq {
	pc = 0x825D5F80; continue 'dispatch;
	}
	// 825D5F60: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D5F64: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D5F68: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D5F6C: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D5F70: 39085978  addi r8, r8, 0x5978
	ctx.r[8].s64 = ctx.r[8].s64 + 22904;
	// 825D5F74: 916A7DA4  stw r11, 0x7da4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32164 as u32), ctx.r[11].u32 ) };
	// 825D5F78: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D5F7C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D5F80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D5F84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D5F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D5F8C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D5F90: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D5F94: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D5F98: 4BFFC989  bl 0x825d2920
	ctx.lr = 0x825D5F9C;
	sub_825D2920(ctx, base);
	// 825D5F9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D5FA0: 4182000C  beq 0x825d5fac
	if ctx.cr[0].eq {
	pc = 0x825D5FAC; continue 'dispatch;
	}
	// 825D5FA4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D5FA8: 48000008  b 0x825d5fb0
	pc = 0x825D5FB0; continue 'dispatch;
	// 825D5FAC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D5FB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D5FB4: 48BD2208  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D5FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D5FB8 size=128
    let mut pc: u32 = 0x825D5FB8;
    'dispatch: loop {
        match pc {
            0x825D5FB8 => {
    //   block [0x825D5FB8..0x825D6038)
	// 825D5FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D5FBC: 48BD21B1  bl 0x831a816c
	ctx.lr = 0x825D5FC0;
	sub_831A8130(ctx, base);
	// 825D5FC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D5FC4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D5FC8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D5FCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D5FD0: 3BEB7DA8  addi r31, r11, 0x7da8
	ctx.r[31].s64 = ctx.r[11].s64 + 32168;
	// 825D5FD4: 816A7DB0  lwz r11, 0x7db0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32176 as u32) ) } as u64;
	// 825D5FD8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D5FDC: 40820024  bne 0x825d6000
	if !ctx.cr[0].eq {
	pc = 0x825D6000; continue 'dispatch;
	}
	// 825D5FE0: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D5FE4: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D5FE8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D5FEC: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D5FF0: 39085978  addi r8, r8, 0x5978
	ctx.r[8].s64 = ctx.r[8].s64 + 22904;
	// 825D5FF4: 916A7DB0  stw r11, 0x7db0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32176 as u32), ctx.r[11].u32 ) };
	// 825D5FF8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D5FFC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D6000: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D6004: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D6008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D600C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D6010: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D6014: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6018: 4BFFC909  bl 0x825d2920
	ctx.lr = 0x825D601C;
	sub_825D2920(ctx, base);
	// 825D601C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6020: 4182000C  beq 0x825d602c
	if ctx.cr[0].eq {
	pc = 0x825D602C; continue 'dispatch;
	}
	// 825D6024: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D6028: 48000008  b 0x825d6030
	pc = 0x825D6030; continue 'dispatch;
	// 825D602C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D6030: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D6034: 48BD2188  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6038 size=128
    let mut pc: u32 = 0x825D6038;
    'dispatch: loop {
        match pc {
            0x825D6038 => {
    //   block [0x825D6038..0x825D60B8)
	// 825D6038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D603C: 48BD2131  bl 0x831a816c
	ctx.lr = 0x825D6040;
	sub_831A8130(ctx, base);
	// 825D6040: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6044: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D6048: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D604C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D6050: 3BEB7DB4  addi r31, r11, 0x7db4
	ctx.r[31].s64 = ctx.r[11].s64 + 32180;
	// 825D6054: 816A7DBC  lwz r11, 0x7dbc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32188 as u32) ) } as u64;
	// 825D6058: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D605C: 40820024  bne 0x825d6080
	if !ctx.cr[0].eq {
	pc = 0x825D6080; continue 'dispatch;
	}
	// 825D6060: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D6064: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D6068: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D606C: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D6070: 39085978  addi r8, r8, 0x5978
	ctx.r[8].s64 = ctx.r[8].s64 + 22904;
	// 825D6074: 916A7DBC  stw r11, 0x7dbc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32188 as u32), ctx.r[11].u32 ) };
	// 825D6078: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D607C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D6080: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D6084: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D6088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D608C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D6090: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D6094: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6098: 4BFFC889  bl 0x825d2920
	ctx.lr = 0x825D609C;
	sub_825D2920(ctx, base);
	// 825D609C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D60A0: 4182000C  beq 0x825d60ac
	if ctx.cr[0].eq {
	pc = 0x825D60AC; continue 'dispatch;
	}
	// 825D60A4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D60A8: 48000008  b 0x825d60b0
	pc = 0x825D60B0; continue 'dispatch;
	// 825D60AC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D60B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D60B4: 48BD2108  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D60B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D60B8 size=128
    let mut pc: u32 = 0x825D60B8;
    'dispatch: loop {
        match pc {
            0x825D60B8 => {
    //   block [0x825D60B8..0x825D6138)
	// 825D60B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D60BC: 48BD20B1  bl 0x831a816c
	ctx.lr = 0x825D60C0;
	sub_831A8130(ctx, base);
	// 825D60C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D60C4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D60C8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D60CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D60D0: 3BEB7DC0  addi r31, r11, 0x7dc0
	ctx.r[31].s64 = ctx.r[11].s64 + 32192;
	// 825D60D4: 816A7DC8  lwz r11, 0x7dc8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32200 as u32) ) } as u64;
	// 825D60D8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D60DC: 40820024  bne 0x825d6100
	if !ctx.cr[0].eq {
	pc = 0x825D6100; continue 'dispatch;
	}
	// 825D60E0: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D60E4: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D60E8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D60EC: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D60F0: 39085978  addi r8, r8, 0x5978
	ctx.r[8].s64 = ctx.r[8].s64 + 22904;
	// 825D60F4: 916A7DC8  stw r11, 0x7dc8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32200 as u32), ctx.r[11].u32 ) };
	// 825D60F8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D60FC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D6100: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D6104: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D6108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D610C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D6110: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D6114: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6118: 4BFFC809  bl 0x825d2920
	ctx.lr = 0x825D611C;
	sub_825D2920(ctx, base);
	// 825D611C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6120: 4182000C  beq 0x825d612c
	if ctx.cr[0].eq {
	pc = 0x825D612C; continue 'dispatch;
	}
	// 825D6124: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D6128: 48000008  b 0x825d6130
	pc = 0x825D6130; continue 'dispatch;
	// 825D612C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D6130: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D6134: 48BD2088  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D6138 size=388
    let mut pc: u32 = 0x825D6138;
    'dispatch: loop {
        match pc {
            0x825D6138 => {
    //   block [0x825D6138..0x825D62BC)
	// 825D6138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D613C: 48BD2031  bl 0x831a816c
	ctx.lr = 0x825D6140;
	sub_831A8130(ctx, base);
	// 825D6140: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825D6144: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D614C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D6150: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D6154: 394AE4C4  addi r10, r10, -0x1b3c
	ctx.r[10].s64 = ctx.r[10].s64 + -6972;
	// 825D6158: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D615C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D6160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6164: 419A00E8  beq cr6, 0x825d624c
	if ctx.cr[6].eq {
	pc = 0x825D624C; continue 'dispatch;
	}
	// 825D6168: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D616C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D6170: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825D6174: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D6178: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D617C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D6180: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825D6184: 4827048D  bl 0x82846610
	ctx.lr = 0x825D6188;
	sub_82846610(ctx, base);
	// 825D6188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D618C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D6190: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6198: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D619C: 419A0024  beq cr6, 0x825d61c0
	if ctx.cr[6].eq {
	pc = 0x825D61C0; continue 'dispatch;
	}
	// 825D61A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D61A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D61A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D61AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D61B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D61B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D61B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D61BC: 4082FFE8  bne 0x825d61a4
	if !ctx.cr[0].eq {
	pc = 0x825D61A4; continue 'dispatch;
	}
	// 825D61C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D61C4: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D61C8: 4BF39351  bl 0x8250f518
	ctx.lr = 0x825D61CC;
	sub_8250F518(ctx, base);
	// 825D61CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D61D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D61D4: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D61D8: 409A0008  bne cr6, 0x825d61e0
	if !ctx.cr[6].eq {
	pc = 0x825D61E0; continue 'dispatch;
	}
	// 825D61DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D61E0: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 825D61E4: 4BF51E6D  bl 0x82528050
	ctx.lr = 0x825D61E8;
	sub_82528050(ctx, base);
	// 825D61E8: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D61EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D61F0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D61F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D61F8: 388AE470  addi r4, r10, -0x1b90
	ctx.r[4].s64 = ctx.r[10].s64 + -7056;
	// 825D61FC: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 825D6200: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 825D6204: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825D6208: 48882839  bl 0x82e58a40
	ctx.lr = 0x825D620C;
	sub_82E58A40(ctx, base);
	// 825D620C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D6210: 4881BA81  bl 0x82df1c90
	ctx.lr = 0x825D6214;
	sub_82DF1C90(ctx, base);
	// 825D6214: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D6218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D621C: 419A0008  beq cr6, 0x825d6224
	if ctx.cr[6].eq {
	pc = 0x825D6224; continue 'dispatch;
	}
	// 825D6220: 4BCEA671  bl 0x822c0890
	ctx.lr = 0x825D6224;
	sub_822C0890(ctx, base);
	// 825D6224: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D6228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D622C: 419A0008  beq cr6, 0x825d6234
	if ctx.cr[6].eq {
	pc = 0x825D6234; continue 'dispatch;
	}
	// 825D6230: 4BCEA661  bl 0x822c0890
	ctx.lr = 0x825D6234;
	sub_822C0890(ctx, base);
	// 825D6234: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 825D6238: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 825D623C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6240: 93DF0144  stw r30, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[30].u32 ) };
	// 825D6244: 419A0008  beq cr6, 0x825d624c
	if ctx.cr[6].eq {
	pc = 0x825D624C; continue 'dispatch;
	}
	// 825D6248: 4BCEA649  bl 0x822c0890
	ctx.lr = 0x825D624C;
	sub_822C0890(ctx, base);
	// 825D624C: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 825D6250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6254: 419A001C  beq cr6, 0x825d6270
	if ctx.cr[6].eq {
	pc = 0x825D6270; continue 'dispatch;
	}
	// 825D6258: 93DF0148  stw r30, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 825D625C: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 825D6260: 93DF014C  stw r30, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[30].u32 ) };
	// 825D6264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6268: 419A0008  beq cr6, 0x825d6270
	if ctx.cr[6].eq {
	pc = 0x825D6270; continue 'dispatch;
	}
	// 825D626C: 4BCEA625  bl 0x822c0890
	ctx.lr = 0x825D6270;
	sub_822C0890(ctx, base);
	// 825D6270: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 825D6274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6278: 419A0008  beq cr6, 0x825d6280
	if ctx.cr[6].eq {
	pc = 0x825D6280; continue 'dispatch;
	}
	// 825D627C: 4BCEA615  bl 0x822c0890
	ctx.lr = 0x825D6280;
	sub_822C0890(ctx, base);
	// 825D6280: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 825D6284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6288: 419A0008  beq cr6, 0x825d6290
	if ctx.cr[6].eq {
	pc = 0x825D6290; continue 'dispatch;
	}
	// 825D628C: 4BCEA605  bl 0x822c0890
	ctx.lr = 0x825D6290;
	sub_822C0890(ctx, base);
	// 825D6290: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 825D6294: 4BDFC155  bl 0x823d23e8
	ctx.lr = 0x825D6298;
	sub_823D23E8(ctx, base);
	// 825D6298: 807F0128  lwz r3, 0x128(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 825D629C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D62A0: 419A0008  beq cr6, 0x825d62a8
	if ctx.cr[6].eq {
	pc = 0x825D62A8; continue 'dispatch;
	}
	// 825D62A4: 4BCEA5ED  bl 0x822c0890
	ctx.lr = 0x825D62A8;
	sub_822C0890(ctx, base);
	// 825D62A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D62AC: 4BFDE0F5  bl 0x825b43a0
	ctx.lr = 0x825D62B0;
	sub_825B43A0(ctx, base);
	// 825D62B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825D62B4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825D62B8: 48BD1F04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D62C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D62C0 size=136
    let mut pc: u32 = 0x825D62C0;
    'dispatch: loop {
        match pc {
            0x825D62C0 => {
    //   block [0x825D62C0..0x825D6348)
	// 825D62C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D62C4: 48BD1EA5  bl 0x831a8168
	ctx.lr = 0x825D62C8;
	sub_831A8130(ctx, base);
	// 825D62C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D62CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D62D0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825D62D4: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 825D62D8: 4BFDEAE1  bl 0x825b4db8
	ctx.lr = 0x825D62DC;
	sub_825B4DB8(ctx, base);
	// 825D62DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D62E0: 93BF0120  stw r29, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[29].u32 ) };
	// 825D62E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D62E8: 396BE4C4  addi r11, r11, -0x1b3c
	ctx.r[11].s64 = ctx.r[11].s64 + -6972;
	// 825D62EC: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 825D62F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D62F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D62F8: 93DF0124  stw r30, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u32 ) };
	// 825D62FC: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 825D6300: 9BDF012C  stb r30, 0x12c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u8 ) };
	// 825D6304: 4BF74C9D  bl 0x8254afa0
	ctx.lr = 0x825D6308;
	sub_8254AFA0(ctx, base);
	// 825D6308: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D630C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D6310: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 825D6314: 93DF0144  stw r30, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[30].u32 ) };
	// 825D6318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D631C: 93DF0148  stw r30, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 825D6320: 93DF014C  stw r30, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[30].u32 ) };
	// 825D6324: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D6328: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 825D632C: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D6330: 93DF0158  stw r30, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[30].u32 ) };
	// 825D6334: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 825D6338: 9BDF0160  stb r30, 0x160(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[30].u8 ) };
	// 825D633C: D1BF015C  stfs f13, 0x15c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 825D6340: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D6344: 48BD1E74  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6348 size=76
    let mut pc: u32 = 0x825D6348;
    'dispatch: loop {
        match pc {
            0x825D6348 => {
    //   block [0x825D6348..0x825D6394)
	// 825D6348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D634C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D6350: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D6354: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D6358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D635C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D6360: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D6364: 4BFFFDD5  bl 0x825d6138
	ctx.lr = 0x825D6368;
	sub_825D6138(ctx, base);
	// 825D6368: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D636C: 4182000C  beq 0x825d6378
	if ctx.cr[0].eq {
	pc = 0x825D6378; continue 'dispatch;
	}
	// 825D6370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6374: 4BCE9EF5  bl 0x822c0268
	ctx.lr = 0x825D6378;
	sub_822C0268(ctx, base);
	// 825D6378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D637C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D6380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D6384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D6388: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D638C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D6390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D6398 size=364
    let mut pc: u32 = 0x825D6398;
    'dispatch: loop {
        match pc {
            0x825D6398 => {
    //   block [0x825D6398..0x825D6504)
	// 825D6398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D639C: 48BD1DC9  bl 0x831a8164
	ctx.lr = 0x825D63A0;
	sub_831A8130(ctx, base);
	// 825D63A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D63A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D63A8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825D63AC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825D63B0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825D63B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D63B8: C18B9690  lfs f12, -0x6970(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26992 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D63BC: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825D63C0: C16A95F4  lfs f11, -0x6a0c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825D63C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D63C8: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D63CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D63D0: C1A8959C  lfs f13, -0x6a64(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D63D4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825D63D8: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825D63DC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D63E0: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825D63E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D63E8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825D63EC: 3887E470  addi r4, r7, -0x1b90
	ctx.r[4].s64 = ctx.r[7].s64 + -7056;
	// 825D63F0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825D63F4: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 825D63F8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825D63FC: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825D6400: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825D6404: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825D6408: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825D640C: 4BCE9FCD  bl 0x822c03d8
	ctx.lr = 0x825D6410;
	sub_822C03D8(ctx, base);
	// 825D6410: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D6414: 4182003C  beq 0x825d6450
	if ctx.cr[0].eq {
	pc = 0x825D6450; continue 'dispatch;
	}
	// 825D6418: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D641C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6420: 808BBF6C  lwz r4, -0x4094(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16532 as u32) ) } as u64;
	// 825D6424: 4881D5E5  bl 0x82df3a08
	ctx.lr = 0x825D6428;
	sub_82DF3A08(ctx, base);
	// 825D6428: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 825D642C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D6430: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825D6434: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825D6438: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D643C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6440: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825D6444: 4BFFFE7D  bl 0x825d62c0
	ctx.lr = 0x825D6448;
	sub_825D62C0(ctx, base);
	// 825D6448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D644C: 48000008  b 0x825d6454
	pc = 0x825D6454; continue 'dispatch;
	// 825D6450: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D6454: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D6458: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825D645C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D6460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6464: 4BFFF385  bl 0x825d57e8
	ctx.lr = 0x825D6468;
	sub_825D57E8(ctx, base);
	// 825D6468: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D646C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D6470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6474: 4BCE9B8D  bl 0x822c0000
	ctx.lr = 0x825D6478;
	sub_822C0000(ctx, base);
	// 825D6478: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D647C: 4182000C  beq 0x825d6488
	if ctx.cr[0].eq {
	pc = 0x825D6488; continue 'dispatch;
	}
	// 825D6480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6484: 4881CFA5  bl 0x82df3428
	ctx.lr = 0x825D6488;
	sub_82DF3428(ctx, base);
	// 825D6488: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D648C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6490: 388BE52C  addi r4, r11, -0x1ad4
	ctx.r[4].s64 = ctx.r[11].s64 + -6868;
	// 825D6494: 4881D575  bl 0x82df3a08
	ctx.lr = 0x825D6498;
	sub_82DF3A08(ctx, base);
	// 825D6498: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D649C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D64A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D64A4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D64A8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D64AC: 419A0024  beq cr6, 0x825d64d0
	if ctx.cr[6].eq {
	pc = 0x825D64D0; continue 'dispatch;
	}
	// 825D64B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D64B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D64B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D64BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D64C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D64C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D64C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D64CC: 4082FFE8  bne 0x825d64b4
	if !ctx.cr[0].eq {
	pc = 0x825D64B4; continue 'dispatch;
	}
	// 825D64D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D64D4: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D64D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D64DC: 4BFDFDBD  bl 0x825b6298
	ctx.lr = 0x825D64E0;
	sub_825B6298(ctx, base);
	// 825D64E0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D64E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D64E8: 419A0008  beq cr6, 0x825d64f0
	if ctx.cr[6].eq {
	pc = 0x825D64F0; continue 'dispatch;
	}
	// 825D64EC: 4BCEA3A5  bl 0x822c0890
	ctx.lr = 0x825D64F0;
	sub_822C0890(ctx, base);
	// 825D64F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D64F4: 4881CF35  bl 0x82df3428
	ctx.lr = 0x825D64F8;
	sub_82DF3428(ctx, base);
	// 825D64F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D64FC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825D6500: 48BD1CB4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D6508 size=1760
    let mut pc: u32 = 0x825D6508;
    'dispatch: loop {
        match pc {
            0x825D6508 => {
    //   block [0x825D6508..0x825D6BE8)
	// 825D6508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D650C: 48BD1C45  bl 0x831a8150
	ctx.lr = 0x825D6510;
	sub_831A8130(ctx, base);
	// 825D6510: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6514: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825D6518: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 825D651C: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 825D6520: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D6524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D6528: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 825D652C: 4BFDFA85  bl 0x825b5fb0
	ctx.lr = 0x825D6530;
	sub_825B5FB0(ctx, base);
	// 825D6530: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6534: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D6538: 3AEBE470  addi r23, r11, -0x1b90
	ctx.r[23].s64 = ctx.r[11].s64 + -7056;
	// 825D653C: 38A00051  li r5, 0x51
	ctx.r[5].s64 = 81;
	// 825D6540: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825D6544: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825D6548: 4BCE9E91  bl 0x822c03d8
	ctx.lr = 0x825D654C;
	sub_822C03D8(ctx, base);
	// 825D654C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D6550: 41820010  beq 0x825d6560
	if ctx.cr[0].eq {
	pc = 0x825D6560; continue 'dispatch;
	}
	// 825D6554: 4BFCBD5D  bl 0x825a22b0
	ctx.lr = 0x825D6558;
	sub_825A22B0(ctx, base);
	// 825D6558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D655C: 48000008  b 0x825d6564
	pc = 0x825D6564; continue 'dispatch;
	// 825D6560: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D6564: 3B9F0124  addi r28, r31, 0x124
	ctx.r[28].s64 = ctx.r[31].s64 + 292;
	// 825D6568: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D656C: 4BFDF495  bl 0x825b5a00
	ctx.lr = 0x825D6570;
	sub_825B5A00(ctx, base);
	// 825D6570: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825D6574: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D6578: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 825D657C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825D6580: 4BCE9E59  bl 0x822c03d8
	ctx.lr = 0x825D6584;
	sub_822C03D8(ctx, base);
	// 825D6584: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D6588: 41820058  beq 0x825d65e0
	if ctx.cr[0].eq {
	pc = 0x825D65E0; continue 'dispatch;
	}
	// 825D658C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6594: 388BE1D0  addi r4, r11, -0x1e30
	ctx.r[4].s64 = ctx.r[11].s64 + -7728;
	// 825D6598: 4881D471  bl 0x82df3a08
	ctx.lr = 0x825D659C;
	sub_82DF3A08(ctx, base);
	// 825D659C: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D65A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D65A4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825D65A8: 396B5F00  addi r11, r11, 0x5f00
	ctx.r[11].s64 = ctx.r[11].s64 + 24320;
	// 825D65AC: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 825D65B0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825D65B4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D65B8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825D65BC: 4BFFFAFD  bl 0x825d60b8
	ctx.lr = 0x825D65C0;
	sub_825D60B8(ctx, base);
	// 825D65C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D65C4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825D65C8: 38BF0154  addi r5, r31, 0x154
	ctx.r[5].s64 = ctx.r[31].s64 + 340;
	// 825D65CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D65D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D65D4: 4BFD5BBD  bl 0x825ac190
	ctx.lr = 0x825D65D8;
	sub_825AC190(ctx, base);
	// 825D65D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D65DC: 48000008  b 0x825d65e4
	pc = 0x825D65E4; continue 'dispatch;
	// 825D65E0: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 825D65E4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825D65E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D65EC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D65F0: 4BF1CDC9  bl 0x824f33b8
	ctx.lr = 0x825D65F4;
	sub_824F33B8(ctx, base);
	// 825D65F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D65F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D65FC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D6600: 4BCE9A01  bl 0x822c0000
	ctx.lr = 0x825D6604;
	sub_822C0000(ctx, base);
	// 825D6604: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6608: 41820010  beq 0x825d6618
	if ctx.cr[0].eq {
	pc = 0x825D6618; continue 'dispatch;
	}
	// 825D660C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6610: 5739003C  rlwinm r25, r25, 0, 0, 0x1e
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 825D6614: 4881CE15  bl 0x82df3428
	ctx.lr = 0x825D6618;
	sub_82DF3428(ctx, base);
	// 825D6618: 83410060  lwz r26, 0x60(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D661C: 3B7F0130  addi r27, r31, 0x130
	ctx.r[27].s64 = ctx.r[31].s64 + 304;
	// 825D6620: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 825D6624: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 825D6628: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D662C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6630: 419A0038  beq cr6, 0x825d6668
	if ctx.cr[6].eq {
	pc = 0x825D6668; continue 'dispatch;
	}
	// 825D6634: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D6638: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D663C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825D6640: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D6644: 40980024  bge cr6, 0x825d6668
	if !ctx.cr[6].lt {
	pc = 0x825D6668; continue 'dispatch;
	}
	// 825D6648: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D664C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D6650: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D6654: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825D6658: 4BFD5769  bl 0x825abdc0
	ctx.lr = 0x825D665C;
	sub_825ABDC0(ctx, base);
	// 825D665C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825D6660: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825D6664: 4BFFFFC4  b 0x825d6628
	pc = 0x825D6628; continue 'dispatch;
	// 825D6668: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D666C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6670: 388BE1C4  addi r4, r11, -0x1e3c
	ctx.r[4].s64 = ctx.r[11].s64 + -7740;
	// 825D6674: 4881D395  bl 0x82df3a08
	ctx.lr = 0x825D6678;
	sub_82DF3A08(ctx, base);
	// 825D6678: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D667C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 825D6680: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825D6684: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 825D6688: 419A0024  beq cr6, 0x825d66ac
	if ctx.cr[6].eq {
	pc = 0x825D66AC; continue 'dispatch;
	}
	// 825D668C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 825D6690: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D6694: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6698: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D669C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D66A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D66A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D66A8: 4082FFE8  bne 0x825d6690
	if !ctx.cr[0].eq {
	pc = 0x825D6690; continue 'dispatch;
	}
	// 825D66AC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D66B0: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D66B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D66B8: 4BFCBA59  bl 0x825a2110
	ctx.lr = 0x825D66BC;
	sub_825A2110(ctx, base);
	// 825D66BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D66C0: 4881CD69  bl 0x82df3428
	ctx.lr = 0x825D66C4;
	sub_82DF3428(ctx, base);
	// 825D66C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D66C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D66CC: 388BE1B8  addi r4, r11, -0x1e48
	ctx.r[4].s64 = ctx.r[11].s64 + -7752;
	// 825D66D0: 4881D339  bl 0x82df3a08
	ctx.lr = 0x825D66D4;
	sub_82DF3A08(ctx, base);
	// 825D66D4: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D66D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D66DC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825D66E0: 396B5ED0  addi r11, r11, 0x5ed0
	ctx.r[11].s64 = ctx.r[11].s64 + 24272;
	// 825D66E4: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 825D66E8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D66EC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D66F0: 4BFFF849  bl 0x825d5f38
	ctx.lr = 0x825D66F4;
	sub_825D5F38(ctx, base);
	// 825D66F4: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825D66F8: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D66FC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825D6700: 38C02710  li r6, 0x2710
	ctx.r[6].s64 = 10000;
	// 825D6704: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D6708: 389F0158  addi r4, r31, 0x158
	ctx.r[4].s64 = ctx.r[31].s64 + 344;
	// 825D670C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825D6710: 4BFCCD79  bl 0x825a3488
	ctx.lr = 0x825D6714;
	sub_825A3488(ctx, base);
	// 825D6714: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D6718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D671C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6720: 4BFCB7B9  bl 0x825a1ed8
	ctx.lr = 0x825D6724;
	sub_825A1ED8(ctx, base);
	// 825D6724: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825D6728: 4881CD01  bl 0x82df3428
	ctx.lr = 0x825D672C;
	sub_82DF3428(ctx, base);
	// 825D672C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825D6730: 4BCF2589  bl 0x822c8cb8
	ctx.lr = 0x825D6734;
	sub_822C8CB8(ctx, base);
	// 825D6734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6738: 4881CCF1  bl 0x82df3428
	ctx.lr = 0x825D673C;
	sub_82DF3428(ctx, base);
	// 825D673C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6744: 388BE1AC  addi r4, r11, -0x1e54
	ctx.r[4].s64 = ctx.r[11].s64 + -7764;
	// 825D6748: 4881D2C1  bl 0x82df3a08
	ctx.lr = 0x825D674C;
	sub_82DF3A08(ctx, base);
	// 825D674C: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D6750: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D6754: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825D6758: 396B5730  addi r11, r11, 0x5730
	ctx.r[11].s64 = ctx.r[11].s64 + 22320;
	// 825D675C: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 825D6760: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D6764: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D6768: 4BFFF851  bl 0x825d5fb8
	ctx.lr = 0x825D676C;
	sub_825D5FB8(ctx, base);
	// 825D676C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D6770: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6774: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 825D6778: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825D677C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825D6780: 389F015C  addi r4, r31, 0x15c
	ctx.r[4].s64 = ctx.r[31].s64 + 348;
	// 825D6784: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 825D6788: C06B9528  lfs f3, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825D678C: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825D6790: C0290790  lfs f1, 0x790(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D6794: 4BFCC98D  bl 0x825a3120
	ctx.lr = 0x825D6798;
	sub_825A3120(ctx, base);
	// 825D6798: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D679C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D67A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D67A4: 4BFCAFCD  bl 0x825a1770
	ctx.lr = 0x825D67A8;
	sub_825A1770(ctx, base);
	// 825D67A8: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 825D67AC: 4881CC7D  bl 0x82df3428
	ctx.lr = 0x825D67B0;
	sub_82DF3428(ctx, base);
	// 825D67B0: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 825D67B4: 4BCF2505  bl 0x822c8cb8
	ctx.lr = 0x825D67B8;
	sub_822C8CB8(ctx, base);
	// 825D67B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D67BC: 4881CC6D  bl 0x82df3428
	ctx.lr = 0x825D67C0;
	sub_82DF3428(ctx, base);
	// 825D67C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D67C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D67C8: 388BE1A0  addi r4, r11, -0x1e60
	ctx.r[4].s64 = ctx.r[11].s64 + -7776;
	// 825D67CC: 4881D23D  bl 0x82df3a08
	ctx.lr = 0x825D67D0;
	sub_82DF3A08(ctx, base);
	// 825D67D0: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D67D4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D67D8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825D67DC: 396B5730  addi r11, r11, 0x5730
	ctx.r[11].s64 = ctx.r[11].s64 + 22320;
	// 825D67E0: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 825D67E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D67E8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D67EC: 4BFFF84D  bl 0x825d6038
	ctx.lr = 0x825D67F0;
	sub_825D6038(ctx, base);
	// 825D67F0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D67F4: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D67F8: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 825D67FC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825D6800: 4BFCC7D9  bl 0x825a2fd8
	ctx.lr = 0x825D6804;
	sub_825A2FD8(ctx, base);
	// 825D6804: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D6808: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D680C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6810: 4BFCB979  bl 0x825a2188
	ctx.lr = 0x825D6814;
	sub_825A2188(ctx, base);
	// 825D6814: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825D6818: 4881CC11  bl 0x82df3428
	ctx.lr = 0x825D681C;
	sub_82DF3428(ctx, base);
	// 825D681C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825D6820: 4BCF2499  bl 0x822c8cb8
	ctx.lr = 0x825D6824;
	sub_822C8CB8(ctx, base);
	// 825D6824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6828: 4881CC01  bl 0x82df3428
	ctx.lr = 0x825D682C;
	sub_82DF3428(ctx, base);
	// 825D682C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6834: 388BE184  addi r4, r11, -0x1e7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7804;
	// 825D6838: 4881D1D1  bl 0x82df3a08
	ctx.lr = 0x825D683C;
	sub_82DF3A08(ctx, base);
	// 825D683C: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D6840: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D6844: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825D6848: 396B5730  addi r11, r11, 0x5730
	ctx.r[11].s64 = ctx.r[11].s64 + 22320;
	// 825D684C: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 825D6850: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D6854: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D6858: 4BFFF761  bl 0x825d5fb8
	ctx.lr = 0x825D685C;
	sub_825D5FB8(ctx, base);
	// 825D685C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D6860: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6864: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825D6868: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825D686C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825D6870: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 825D6874: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 825D6878: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825D687C: C04A9F64  lfs f2, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825D6880: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D6884: 4BFCC89D  bl 0x825a3120
	ctx.lr = 0x825D6888;
	sub_825A3120(ctx, base);
	// 825D6888: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D688C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D6890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6894: 4BFCAEDD  bl 0x825a1770
	ctx.lr = 0x825D6898;
	sub_825A1770(ctx, base);
	// 825D6898: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 825D689C: 4881CB8D  bl 0x82df3428
	ctx.lr = 0x825D68A0;
	sub_82DF3428(ctx, base);
	// 825D68A0: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 825D68A4: 4BCF2415  bl 0x822c8cb8
	ctx.lr = 0x825D68A8;
	sub_822C8CB8(ctx, base);
	// 825D68A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D68AC: 4881CB7D  bl 0x82df3428
	ctx.lr = 0x825D68B0;
	sub_82DF3428(ctx, base);
	// 825D68B0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825D68B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D68B8: 38A00062  li r5, 0x62
	ctx.r[5].s64 = 98;
	// 825D68BC: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D68C0: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 825D68C4: 4881BB25  bl 0x82df23e8
	ctx.lr = 0x825D68C8;
	sub_82DF23E8(ctx, base);
	// 825D68C8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D68CC: 41820070  beq 0x825d693c
	if ctx.cr[0].eq {
	pc = 0x825D693C; continue 'dispatch;
	}
	// 825D68D0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825D68D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D68D8: 388B7C4C  addi r4, r11, 0x7c4c
	ctx.r[4].s64 = ctx.r[11].s64 + 31820;
	// 825D68DC: 4881D12D  bl 0x82df3a08
	ctx.lr = 0x825D68E0;
	sub_82DF3A08(ctx, base);
	// 825D68E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D68E4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D68E8: 63390002  ori r25, r25, 2
	ctx.r[25].u64 = ctx.r[25].u64 | 2;
	// 825D68EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D68F0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D68F4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D68F8: 419A0024  beq cr6, 0x825d691c
	if ctx.cr[6].eq {
	pc = 0x825D691C; continue 'dispatch;
	}
	// 825D68FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D6900: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D6904: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6908: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D690C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D6910: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D6914: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6918: 4082FFE8  bne 0x825d6900
	if !ctx.cr[0].eq {
	pc = 0x825D6900; continue 'dispatch;
	}
	// 825D691C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D6920: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D6924: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D6928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D692C: 4BFE1C4D  bl 0x825b8578
	ctx.lr = 0x825D6930;
	sub_825B8578(ctx, base);
	// 825D6930: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D6934: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825D6938: 48000008  b 0x825d6940
	pc = 0x825D6940; continue 'dispatch;
	// 825D693C: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 825D6940: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825D6944: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D6948: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D694C: 4BFDEFED  bl 0x825b5938
	ctx.lr = 0x825D6950;
	sub_825B5938(ctx, base);
	// 825D6950: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D6954: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D6958: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D695C: 4BCE96A5  bl 0x822c0000
	ctx.lr = 0x825D6960;
	sub_822C0000(ctx, base);
	// 825D6960: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D6964: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D6968: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D696C: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 825D6970: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825D6974: 419A0024  beq cr6, 0x825d6998
	if ctx.cr[6].eq {
	pc = 0x825D6998; continue 'dispatch;
	}
	// 825D6978: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825D697C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D6980: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6984: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D6988: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D698C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D6990: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6994: 4082FFE8  bne 0x825d697c
	if !ctx.cr[0].eq {
	pc = 0x825D697C; continue 'dispatch;
	}
	// 825D6998: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825D699C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825D69A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D69A4: 4BFE036D  bl 0x825b6d10
	ctx.lr = 0x825D69A8;
	sub_825B6D10(ctx, base);
	// 825D69A8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D69AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D69B0: 419A0008  beq cr6, 0x825d69b8
	if ctx.cr[6].eq {
	pc = 0x825D69B8; continue 'dispatch;
	}
	// 825D69B4: 4BCE9EDD  bl 0x822c0890
	ctx.lr = 0x825D69B8;
	sub_822C0890(ctx, base);
	// 825D69B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D69BC: 419A000C  beq cr6, 0x825d69c8
	if ctx.cr[6].eq {
	pc = 0x825D69C8; continue 'dispatch;
	}
	// 825D69C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D69C4: 4BCE9ECD  bl 0x822c0890
	ctx.lr = 0x825D69C8;
	sub_822C0890(ctx, base);
	// 825D69C8: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D69CC: 41820010  beq 0x825d69dc
	if ctx.cr[0].eq {
	pc = 0x825D69DC; continue 'dispatch;
	}
	// 825D69D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D69D4: 573907FA  rlwinm r25, r25, 0, 0x1f, 0x1d
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 825D69D8: 4881CA51  bl 0x82df3428
	ctx.lr = 0x825D69DC;
	sub_82DF3428(ctx, base);
	// 825D69DC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825D69E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D69E4: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 825D69E8: 386000E4  li r3, 0xe4
	ctx.r[3].s64 = 228;
	// 825D69EC: 4881B9FD  bl 0x82df23e8
	ctx.lr = 0x825D69F0;
	sub_82DF23E8(ctx, base);
	// 825D69F0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D69F4: 4182006C  beq 0x825d6a60
	if ctx.cr[0].eq {
	pc = 0x825D6A60; continue 'dispatch;
	}
	// 825D69F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D69FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6A00: 388BE164  addi r4, r11, -0x1e9c
	ctx.r[4].s64 = ctx.r[11].s64 + -7836;
	// 825D6A04: 4881D005  bl 0x82df3a08
	ctx.lr = 0x825D6A08;
	sub_82DF3A08(ctx, base);
	// 825D6A08: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6A0C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6A10: 63390004  ori r25, r25, 4
	ctx.r[25].u64 = ctx.r[25].u64 | 4;
	// 825D6A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6A18: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D6A1C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D6A20: 419A0024  beq cr6, 0x825d6a44
	if ctx.cr[6].eq {
	pc = 0x825D6A44; continue 'dispatch;
	}
	// 825D6A24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D6A28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D6A2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6A30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D6A34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D6A38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D6A3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6A40: 4082FFE8  bne 0x825d6a28
	if !ctx.cr[0].eq {
	pc = 0x825D6A28; continue 'dispatch;
	}
	// 825D6A44: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825D6A48: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D6A4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D6A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6A54: 4BFE1B25  bl 0x825b8578
	ctx.lr = 0x825D6A58;
	sub_825B8578(ctx, base);
	// 825D6A58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D6A5C: 48000008  b 0x825d6a64
	pc = 0x825D6A64; continue 'dispatch;
	// 825D6A60: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 825D6A64: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825D6A68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D6A6C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D6A70: 4BFDEEC9  bl 0x825b5938
	ctx.lr = 0x825D6A74;
	sub_825B5938(ctx, base);
	// 825D6A74: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D6A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D6A7C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D6A80: 4BCE9581  bl 0x822c0000
	ctx.lr = 0x825D6A84;
	sub_822C0000(ctx, base);
	// 825D6A84: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D6A88: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D6A8C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D6A90: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 825D6A94: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825D6A98: 419A0024  beq cr6, 0x825d6abc
	if ctx.cr[6].eq {
	pc = 0x825D6ABC; continue 'dispatch;
	}
	// 825D6A9C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825D6AA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D6AA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6AA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D6AAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D6AB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D6AB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6AB8: 4082FFE8  bne 0x825d6aa0
	if !ctx.cr[0].eq {
	pc = 0x825D6AA0; continue 'dispatch;
	}
	// 825D6ABC: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825D6AC0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825D6AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6AC8: 4BFE0249  bl 0x825b6d10
	ctx.lr = 0x825D6ACC;
	sub_825B6D10(ctx, base);
	// 825D6ACC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D6AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6AD4: 419A0008  beq cr6, 0x825d6adc
	if ctx.cr[6].eq {
	pc = 0x825D6ADC; continue 'dispatch;
	}
	// 825D6AD8: 4BCE9DB9  bl 0x822c0890
	ctx.lr = 0x825D6ADC;
	sub_822C0890(ctx, base);
	// 825D6ADC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D6AE0: 419A000C  beq cr6, 0x825d6aec
	if ctx.cr[6].eq {
	pc = 0x825D6AEC; continue 'dispatch;
	}
	// 825D6AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6AE8: 4BCE9DA9  bl 0x822c0890
	ctx.lr = 0x825D6AEC;
	sub_822C0890(ctx, base);
	// 825D6AEC: 572B077B  rlwinm. r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6AF0: 41820010  beq 0x825d6b00
	if ctx.cr[0].eq {
	pc = 0x825D6B00; continue 'dispatch;
	}
	// 825D6AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6AF8: 573907B8  rlwinm r25, r25, 0, 0x1e, 0x1c
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 825D6AFC: 4881C92D  bl 0x82df3428
	ctx.lr = 0x825D6B00;
	sub_82DF3428(ctx, base);
	// 825D6B00: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825D6B04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D6B08: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825D6B0C: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 825D6B10: 4881B8D9  bl 0x82df23e8
	ctx.lr = 0x825D6B14;
	sub_82DF23E8(ctx, base);
	// 825D6B14: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D6B18: 41820054  beq 0x825d6b6c
	if ctx.cr[0].eq {
	pc = 0x825D6B6C; continue 'dispatch;
	}
	// 825D6B1C: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D6B20: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825D6B24: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D6B28: 930100A0  stw r24, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[24].u32 ) };
	// 825D6B2C: 396B5D68  addi r11, r11, 0x5d68
	ctx.r[11].s64 = ctx.r[11].s64 + 23912;
	// 825D6B30: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D6B34: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D6B38: 4BFFF581  bl 0x825d60b8
	ctx.lr = 0x825D6B3C;
	sub_825D60B8(ctx, base);
	// 825D6B3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6B44: 388BE130  addi r4, r11, -0x1ed0
	ctx.r[4].s64 = ctx.r[11].s64 + -7888;
	// 825D6B48: 633D0008  ori r29, r25, 8
	ctx.r[29].u64 = ctx.r[25].u64 | 8;
	// 825D6B4C: 4881CEBD  bl 0x82df3a08
	ctx.lr = 0x825D6B50;
	sub_82DF3A08(ctx, base);
	// 825D6B50: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825D6B54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D6B58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6B5C: 63B90010  ori r25, r29, 0x10
	ctx.r[25].u64 = ctx.r[29].u64 | 16;
	// 825D6B60: 4BFFBA69  bl 0x825d25c8
	ctx.lr = 0x825D6B64;
	sub_825D25C8(ctx, base);
	// 825D6B64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D6B68: 48000008  b 0x825d6b70
	pc = 0x825D6B70; continue 'dispatch;
	// 825D6B6C: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 825D6B70: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 825D6B74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D6B78: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825D6B7C: 4BFDF335  bl 0x825b5eb0
	ctx.lr = 0x825D6B80;
	sub_825B5EB0(ctx, base);
	// 825D6B80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D6B84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D6B88: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825D6B8C: 4BCE9475  bl 0x822c0000
	ctx.lr = 0x825D6B90;
	sub_822C0000(ctx, base);
	// 825D6B90: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825D6B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6B98: 4BFDFE59  bl 0x825b69f0
	ctx.lr = 0x825D6B9C;
	sub_825B69F0(ctx, base);
	// 825D6B9C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D6BA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6BA4: 419A0008  beq cr6, 0x825d6bac
	if ctx.cr[6].eq {
	pc = 0x825D6BAC; continue 'dispatch;
	}
	// 825D6BA8: 4BCE9CE9  bl 0x822c0890
	ctx.lr = 0x825D6BAC;
	sub_822C0890(ctx, base);
	// 825D6BAC: 572B06F7  rlwinm. r11, r25, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6BB0: 41820010  beq 0x825d6bc0
	if ctx.cr[0].eq {
	pc = 0x825D6BC0; continue 'dispatch;
	}
	// 825D6BB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6BB8: 57390734  rlwinm r25, r25, 0, 0x1c, 0x1a
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 825D6BBC: 4881C86D  bl 0x82df3428
	ctx.lr = 0x825D6BC0;
	sub_82DF3428(ctx, base);
	// 825D6BC0: 572B0739  rlwinm. r11, r25, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6BC4: 4182000C  beq 0x825d6bd0
	if ctx.cr[0].eq {
	pc = 0x825D6BD0; continue 'dispatch;
	}
	// 825D6BC8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D6BCC: 4BCF20ED  bl 0x822c8cb8
	ctx.lr = 0x825D6BD0;
	sub_822C8CB8(ctx, base);
	// 825D6BD0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825D6BD4: 419A000C  beq cr6, 0x825d6be0
	if ctx.cr[6].eq {
	pc = 0x825D6BE0; continue 'dispatch;
	}
	// 825D6BD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D6BDC: 4BCE9CB5  bl 0x822c0890
	ctx.lr = 0x825D6BE0;
	sub_822C0890(ctx, base);
	// 825D6BE0: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 825D6BE4: 48BD15BC  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6BE8 size=196
    let mut pc: u32 = 0x825D6BE8;
    'dispatch: loop {
        match pc {
            0x825D6BE8 => {
    //   block [0x825D6BE8..0x825D6CAC)
	// 825D6BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D6BF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D6BF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D6BF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6BFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D6C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D6C04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D6C08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D6C0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D6C10: 4BCE9D29  bl 0x822c0938
	ctx.lr = 0x825D6C14;
	sub_822C0938(ctx, base);
	// 825D6C14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D6C18: 41820028  beq 0x825d6c40
	if ctx.cr[0].eq {
	pc = 0x825D6C40; continue 'dispatch;
	}
	// 825D6C1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6C20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D6C24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D6C28: 392BE54C  addi r9, r11, -0x1ab4
	ctx.r[9].s64 = ctx.r[11].s64 + -6836;
	// 825D6C2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D6C30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D6C34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D6C38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D6C3C: 48000008  b 0x825d6c44
	pc = 0x825D6C44; continue 'dispatch;
	// 825D6C40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D6C44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D6C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6C4C: 409A0044  bne cr6, 0x825d6c90
	if !ctx.cr[6].eq {
	pc = 0x825D6C90; continue 'dispatch;
	}
	// 825D6C50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D6C54: 419A001C  beq cr6, 0x825d6c70
	if ctx.cr[6].eq {
	pc = 0x825D6C70; continue 'dispatch;
	}
	// 825D6C58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6C5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D6C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6C64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6C68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D6C6C: 4E800421  bctrl
	ctx.lr = 0x825D6C70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D6C70: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D6C74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D6C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D6C7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D6C80: 816BC0D0  lwz r11, -0x3f30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16176 as u32) ) } as u64;
	// 825D6C84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D6C88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D6C8C: 4BCE9375  bl 0x822c0000
	ctx.lr = 0x825D6C90;
	sub_822C0000(ctx, base);
	// 825D6C90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6C94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D6C98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D6C9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D6CA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D6CA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D6CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6CB0 size=100
    let mut pc: u32 = 0x825D6CB0;
    'dispatch: loop {
        match pc {
            0x825D6CB0 => {
    //   block [0x825D6CB0..0x825D6D14)
	// 825D6CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6CB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D6CB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D6CBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6CC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D6CC4: 4BF3A42D  bl 0x825110f0
	ctx.lr = 0x825D6CC8;
	sub_825110F0(ctx, base);
	// 825D6CC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6CCC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D6CD0: 392BE574  addi r9, r11, -0x1a8c
	ctx.r[9].s64 = ctx.r[11].s64 + -6796;
	// 825D6CD4: 394AE560  addi r10, r10, -0x1aa0
	ctx.r[10].s64 = ctx.r[10].s64 + -6816;
	// 825D6CD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D6CDC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D6CE0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D6CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6CE8: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D6CEC: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 825D6CF0: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 825D6CF4: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 825D6CF8: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D6CFC: 997F00D1  stb r11, 0xd1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(209 as u32), ctx.r[11].u8 ) };
	// 825D6D00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D6D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D6D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D6D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D6D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D6D18 size=8
    let mut pc: u32 = 0x825D6D18;
    'dispatch: loop {
        match pc {
            0x825D6D18 => {
    //   block [0x825D6D18..0x825D6D20)
	// 825D6D18: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825D6D1C: 48000054  b 0x825d6d70
	sub_825D6D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6D20 size=80
    let mut pc: u32 = 0x825D6D20;
    'dispatch: loop {
        match pc {
            0x825D6D20 => {
    //   block [0x825D6D20..0x825D6D70)
	// 825D6D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D6D28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D6D2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D6D34: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 825D6D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6D3C: 419A0008  beq cr6, 0x825d6d44
	if ctx.cr[6].eq {
	pc = 0x825D6D44; continue 'dispatch;
	}
	// 825D6D40: 4BCE9B51  bl 0x822c0890
	ctx.lr = 0x825D6D44;
	sub_822C0890(ctx, base);
	// 825D6D44: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D6D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6D4C: 419A0008  beq cr6, 0x825d6d54
	if ctx.cr[6].eq {
	pc = 0x825D6D54; continue 'dispatch;
	}
	// 825D6D50: 4BCE9B41  bl 0x822c0890
	ctx.lr = 0x825D6D54;
	sub_822C0890(ctx, base);
	// 825D6D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6D58: 4BF3A441  bl 0x82511198
	ctx.lr = 0x825D6D5C;
	sub_82511198(ctx, base);
	// 825D6D5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D6D60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D6D64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D6D68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D6D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6D70 size=76
    let mut pc: u32 = 0x825D6D70;
    'dispatch: loop {
        match pc {
            0x825D6D70 => {
    //   block [0x825D6D70..0x825D6DBC)
	// 825D6D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D6D78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D6D7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D6D80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D6D88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D6D8C: 4BFFFF95  bl 0x825d6d20
	ctx.lr = 0x825D6D90;
	sub_825D6D20(ctx, base);
	// 825D6D90: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6D94: 4182000C  beq 0x825d6da0
	if ctx.cr[0].eq {
	pc = 0x825D6DA0; continue 'dispatch;
	}
	// 825D6D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6D9C: 4881B63D  bl 0x82df23d8
	ctx.lr = 0x825D6DA0;
	sub_82DF23D8(ctx, base);
	// 825D6DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6DA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D6DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D6DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D6DB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D6DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D6DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D6DC0 size=124
    let mut pc: u32 = 0x825D6DC0;
    'dispatch: loop {
        match pc {
            0x825D6DC0 => {
    //   block [0x825D6DC0..0x825D6E3C)
	// 825D6DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6DC4: 48BD13A9  bl 0x831a816c
	ctx.lr = 0x825D6DC8;
	sub_831A8130(ctx, base);
	// 825D6DC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6DCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D6DD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D6DD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D6DD8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825D6DDC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825D6DE0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825D6DE4: 4881B605  bl 0x82df23e8
	ctx.lr = 0x825D6DE8;
	sub_82DF23E8(ctx, base);
	// 825D6DE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D6DEC: 4182001C  beq 0x825d6e08
	if ctx.cr[0].eq {
	pc = 0x825D6E08; continue 'dispatch;
	}
	// 825D6DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D6DF4: 4888288D  bl 0x82e59680
	ctx.lr = 0x825D6DF8;
	sub_82E59680(ctx, base);
	// 825D6DF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D6DFC: 396BE544  addi r11, r11, -0x1abc
	ctx.r[11].s64 = ctx.r[11].s64 + -6844;
	// 825D6E00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D6E04: 48000008  b 0x825d6e0c
	pc = 0x825D6E0C; continue 'dispatch;
	// 825D6E08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D6E0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D6E10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D6E14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D6E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6E1C: 4BFFFDCD  bl 0x825d6be8
	ctx.lr = 0x825D6E20;
	sub_825D6BE8(ctx, base);
	// 825D6E20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D6E24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D6E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D6E2C: 4BCE91D5  bl 0x822c0000
	ctx.lr = 0x825D6E30;
	sub_822C0000(ctx, base);
	// 825D6E30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D6E34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D6E38: 48BD1384  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D6E40 size=440
    let mut pc: u32 = 0x825D6E40;
    'dispatch: loop {
        match pc {
            0x825D6E40 => {
    //   block [0x825D6E40..0x825D6FF8)
	// 825D6E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6E44: 48BD1325  bl 0x831a8168
	ctx.lr = 0x825D6E48;
	sub_831A8130(ctx, base);
	// 825D6E48: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D6E4C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D6E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D6E54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D6E58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D6E5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D6E60: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825D6E64: 4881AD95  bl 0x82df1bf8
	ctx.lr = 0x825D6E68;
	sub_82DF1BF8(ctx, base);
	// 825D6E68: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D6E6C: 485703ED  bl 0x82b47258
	ctx.lr = 0x825D6E70;
	sub_82B47258(ctx, base);
	// 825D6E70: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D6E74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D6E78: 4881AE19  bl 0x82df1c90
	ctx.lr = 0x825D6E7C;
	sub_82DF1C90(ctx, base);
	// 825D6E7C: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D6E80: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D6E84: 4BFDACE5  bl 0x825b1b68
	ctx.lr = 0x825D6E88;
	sub_825B1B68(ctx, base);
	// 825D6E88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D6E8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D6E90: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D6E94: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825D6E98: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825D6E9C: 4BFDB265  bl 0x825b2100
	ctx.lr = 0x825D6EA0;
	sub_825B2100(ctx, base);
	// 825D6EA0: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D6EA4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825D6EA8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825D6EAC: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825D6EB0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D6EB4: 48BD165D  bl 0x831a8510
	ctx.lr = 0x825D6EB8;
	sub_831A8510(ctx, base);
	// 825D6EB8: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D6EBC: 93C100C4  stw r30, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 825D6EC0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 825D6EC4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825D6EC8: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 825D6ECC: 4BCED595  bl 0x822c4460
	ctx.lr = 0x825D6ED0;
	sub_822C4460(ctx, base);
	// 825D6ED0: 897F00D0  lbz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 825D6ED4: 895F00D1  lbz r10, 0xd1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(209 as u32) ) } as u64;
	// 825D6ED8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825D6EDC: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D6EE0: 996100CC  stb r11, 0xcc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 825D6EE4: 994100CE  stb r10, 0xce(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(206 as u32), ctx.r[10].u8 ) };
	// 825D6EE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6EEC: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D6EF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D6EF4: 4E800421  bctrl
	ctx.lr = 0x825D6EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D6EF8: 896100CC  lbz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825D6EFC: 894100CE  lbz r10, 0xce(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(206 as u32) ) } as u64;
	// 825D6F00: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D6F04: 995F00D1  stb r10, 0xd1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(209 as u32), ctx.r[10].u8 ) };
	// 825D6F08: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6F0C: 556B039D  rlwinm. r11, r11, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D6F10: 418200C8  beq 0x825d6fd8
	if ctx.cr[0].eq {
	pc = 0x825D6FD8; continue 'dispatch;
	}
	// 825D6F14: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D6F18: 4BFDF251  bl 0x825b6168
	ctx.lr = 0x825D6F1C;
	sub_825B6168(ctx, base);
	// 825D6F1C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 825D6F20: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825D6F24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6F28: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 825D6F2C: 419A0008  beq cr6, 0x825d6f34
	if ctx.cr[6].eq {
	pc = 0x825D6F34; continue 'dispatch;
	}
	// 825D6F30: 4BCE9961  bl 0x822c0890
	ctx.lr = 0x825D6F34;
	sub_822C0890(ctx, base);
	// 825D6F34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D6F38: 4BFFFE89  bl 0x825d6dc0
	ctx.lr = 0x825D6F3C;
	sub_825D6DC0(ctx, base);
	// 825D6F3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6F40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D6F44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D6F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D6F4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D6F50: 419A0024  beq cr6, 0x825d6f74
	if ctx.cr[6].eq {
	pc = 0x825D6F74; continue 'dispatch;
	}
	// 825D6F54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D6F58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D6F5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6F60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D6F64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D6F68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D6F6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D6F70: 4082FFE8  bne 0x825d6f58
	if !ctx.cr[0].eq {
	pc = 0x825D6F58; continue 'dispatch;
	}
	// 825D6F74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D6F78: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D6F7C: 4BF383B5  bl 0x8250f330
	ctx.lr = 0x825D6F80;
	sub_8250F330(ctx, base);
	// 825D6F80: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D6F84: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825D6F88: 4BF128D9  bl 0x824e9860
	ctx.lr = 0x825D6F8C;
	sub_824E9860(ctx, base);
	// 825D6F8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D6F90: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D6F94: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D6F98: 388AE5A0  addi r4, r10, -0x1a60
	ctx.r[4].s64 = ctx.r[10].s64 + -6752;
	// 825D6F9C: 38A00068  li r5, 0x68
	ctx.r[5].s64 = 104;
	// 825D6FA0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825D6FA4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D6FA8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D6FAC: 48881A95  bl 0x82e58a40
	ctx.lr = 0x825D6FB0;
	sub_82E58A40(ctx, base);
	// 825D6FB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D6FB4: 4881ACDD  bl 0x82df1c90
	ctx.lr = 0x825D6FB8;
	sub_82DF1C90(ctx, base);
	// 825D6FB8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D6FBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6FC0: 419A0008  beq cr6, 0x825d6fc8
	if ctx.cr[6].eq {
	pc = 0x825D6FC8; continue 'dispatch;
	}
	// 825D6FC4: 4BCE98CD  bl 0x822c0890
	ctx.lr = 0x825D6FC8;
	sub_822C0890(ctx, base);
	// 825D6FC8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D6FCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6FD0: 419A0008  beq cr6, 0x825d6fd8
	if ctx.cr[6].eq {
	pc = 0x825D6FD8; continue 'dispatch;
	}
	// 825D6FD4: 4BCE98BD  bl 0x822c0890
	ctx.lr = 0x825D6FD8;
	sub_822C0890(ctx, base);
	// 825D6FD8: 806100C8  lwz r3, 0xc8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D6FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D6FE0: 419A0008  beq cr6, 0x825d6fe8
	if ctx.cr[6].eq {
	pc = 0x825D6FE8; continue 'dispatch;
	}
	// 825D6FE4: 4BCE98AD  bl 0x822c0890
	ctx.lr = 0x825D6FE8;
	sub_822C0890(ctx, base);
	// 825D6FE8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825D6FEC: 4881C43D  bl 0x82df3428
	ctx.lr = 0x825D6FF0;
	sub_82DF3428(ctx, base);
	// 825D6FF0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825D6FF4: 48BD11C4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D6FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D6FF8 size=696
    let mut pc: u32 = 0x825D6FF8;
    'dispatch: loop {
        match pc {
            0x825D6FF8 => {
    //   block [0x825D6FF8..0x825D72B0)
	// 825D6FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D6FFC: 48BD115D  bl 0x831a8158
	ctx.lr = 0x825D7000;
	sub_831A8130(ctx, base);
	// 825D7000: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D7008: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D700C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D7010: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D7014: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D7018: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 825D701C: 409A0008  bne cr6, 0x825d7024
	if !ctx.cr[6].eq {
	pc = 0x825D7024; continue 'dispatch;
	}
	// 825D7020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D7024: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D7028: 4BF31779  bl 0x825087a0
	ctx.lr = 0x825D702C;
	sub_825087A0(ctx, base);
	// 825D702C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825D7030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7034: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825D7038: 4881C9D1  bl 0x82df3a08
	ctx.lr = 0x825D703C;
	sub_82DF3A08(ctx, base);
	// 825D703C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D7040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D7044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D7048: 4BF31739  bl 0x82508780
	ctx.lr = 0x825D704C;
	sub_82508780(ctx, base);
	// 825D704C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7050: 4881C3D9  bl 0x82df3428
	ctx.lr = 0x825D7054;
	sub_82DF3428(ctx, base);
	// 825D7054: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D7058: 4BCF1CC1  bl 0x822c8d18
	ctx.lr = 0x825D705C;
	sub_822C8D18(ctx, base);
	// 825D705C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7064: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D7068: 409A0008  bne cr6, 0x825d7070
	if !ctx.cr[6].eq {
	pc = 0x825D7070; continue 'dispatch;
	}
	// 825D706C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7074: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D7078: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825D707C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D7080: 4E800421  bctrl
	ctx.lr = 0x825D7084;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7084: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D7088: 4881AC09  bl 0x82df1c90
	ctx.lr = 0x825D708C;
	sub_82DF1C90(ctx, base);
	// 825D708C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D7090: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D7094: 388BE5A0  addi r4, r11, -0x1a60
	ctx.r[4].s64 = ctx.r[11].s64 + -6752;
	// 825D7098: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 825D709C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825D70A0: 4BCE9339  bl 0x822c03d8
	ctx.lr = 0x825D70A4;
	sub_822C03D8(ctx, base);
	// 825D70A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D70A8: 41820010  beq 0x825d70b8
	if ctx.cr[0].eq {
	pc = 0x825D70B8; continue 'dispatch;
	}
	// 825D70AC: 4BFDA9CD  bl 0x825b1a78
	ctx.lr = 0x825D70B0;
	sub_825B1A78(ctx, base);
	// 825D70B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D70B4: 48000008  b 0x825d70bc
	pc = 0x825D70BC; continue 'dispatch;
	// 825D70B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D70BC: 3B5E00C8  addi r26, r30, 0xc8
	ctx.r[26].s64 = ctx.r[30].s64 + 200;
	// 825D70C0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D70C4: 4BFDB2C5  bl 0x825b2388
	ctx.lr = 0x825D70C8;
	sub_825B2388(ctx, base);
	// 825D70C8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D70CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D70D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D70D4: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825D70D8: 4881AB21  bl 0x82df1bf8
	ctx.lr = 0x825D70DC;
	sub_82DF1BF8(ctx, base);
	// 825D70DC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825D70E0: 48570179  bl 0x82b47258
	ctx.lr = 0x825D70E4;
	sub_82B47258(ctx, base);
	// 825D70E4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825D70E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D70EC: 4881ABA5  bl 0x82df1c90
	ctx.lr = 0x825D70F0;
	sub_82DF1C90(ctx, base);
	// 825D70F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D70F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D70F8: 388BE288  addi r4, r11, -0x1d78
	ctx.r[4].s64 = ctx.r[11].s64 + -7544;
	// 825D70FC: 4881C90D  bl 0x82df3a08
	ctx.lr = 0x825D7100;
	sub_82DF3A08(ctx, base);
	// 825D7100: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 825D7104: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 825D7108: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D710C: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 825D7110: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825D7114: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825D7118: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825D711C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7120: 48828719  bl 0x82dff838
	ctx.lr = 0x825D7124;
	sub_82DFF838(ctx, base);
	// 825D7124: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 825D7128: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825D712C: 3F208212  lis r25, -0x7dee
	ctx.r[25].s64 = -2112749568;
	// 825D7130: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D7134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7138: 419A0084  beq cr6, 0x825d71bc
	if ctx.cr[6].eq {
	pc = 0x825D71BC; continue 'dispatch;
	}
	// 825D713C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D7140: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D7144: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825D7148: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D714C: 40980070  bge cr6, 0x825d71bc
	if !ctx.cr[6].lt {
	pc = 0x825D71BC; continue 'dispatch;
	}
	// 825D7150: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D7154: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7158: 4881CAA9  bl 0x82df3c00
	ctx.lr = 0x825D715C;
	sub_82DF3C00(ctx, base);
	// 825D715C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D7160: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D7164: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D7168: 4881CEE1  bl 0x82df4048
	ctx.lr = 0x825D716C;
	sub_82DF4048(ctx, base);
	// 825D716C: 8179B230  lwz r11, -0x4dd0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825D7170: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D7174: 419A0034  beq cr6, 0x825d71a8
	if ctx.cr[6].eq {
	pc = 0x825D71A8; continue 'dispatch;
	}
	// 825D7178: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D717C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D7180: 7F9D5A14  add r28, r29, r11
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D7184: 4881C90D  bl 0x82df3a90
	ctx.lr = 0x825D7188;
	sub_82DF3A90(ctx, base);
	// 825D7188: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D718C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D7190: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D7194: 4881D175  bl 0x82df4308
	ctx.lr = 0x825D7198;
	sub_82DF4308(ctx, base);
	// 825D7198: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D719C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D71A0: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D71A4: 4BD17B85  bl 0x822eed28
	ctx.lr = 0x825D71A8;
	sub_822EED28(ctx, base);
	// 825D71A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D71AC: 4881C27D  bl 0x82df3428
	ctx.lr = 0x825D71B0;
	sub_82DF3428(ctx, base);
	// 825D71B0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825D71B4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825D71B8: 4BFFFF78  b 0x825d7130
	pc = 0x825D7130; continue 'dispatch;
	// 825D71BC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D71C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D71C4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D71C8: 48000959  bl 0x825d7b20
	ctx.lr = 0x825D71CC;
	sub_825D7B20(ctx, base);
	// 825D71CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D71D0: 3BBE00C0  addi r29, r30, 0xc0
	ctx.r[29].s64 = ctx.r[30].s64 + 192;
	// 825D71D4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D71D8: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825D71DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D71E0: 917E00C0  stw r11, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D71E4: 4BCED27D  bl 0x822c4460
	ctx.lr = 0x825D71E8;
	sub_822C4460(ctx, base);
	// 825D71E8: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825D71EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D71F0: 419A0008  beq cr6, 0x825d71f8
	if ctx.cr[6].eq {
	pc = 0x825D71F8; continue 'dispatch;
	}
	// 825D71F4: 4BCE969D  bl 0x822c0890
	ctx.lr = 0x825D71F8;
	sub_822C0890(ctx, base);
	// 825D71F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D71FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825D7200: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D7204: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825D7208: 4BFDAEF9  bl 0x825b2100
	ctx.lr = 0x825D720C;
	sub_825B2100(ctx, base);
	// 825D720C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D7210: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825D7214: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825D7218: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D721C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D7220: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 825D7224: 48BD12ED  bl 0x831a8510
	ctx.lr = 0x825D7228;
	sub_831A8510(ctx, base);
	// 825D7228: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D722C: 93E100E4  stw r31, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[31].u32 ) };
	// 825D7230: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D7234: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825D7238: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 825D723C: 4BCED225  bl 0x822c4460
	ctx.lr = 0x825D7240;
	sub_822C4460(ctx, base);
	// 825D7240: 897E00D0  lbz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 825D7244: 895E00D1  lbz r10, 0xd1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(209 as u32) ) } as u64;
	// 825D7248: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825D724C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7250: 996100EC  stb r11, 0xec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 825D7254: 994100EE  stb r10, 0xee(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(238 as u32), ctx.r[10].u8 ) };
	// 825D7258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D725C: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825D7260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D7264: 4E800421  bctrl
	ctx.lr = 0x825D7268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7268: 896100EC  lbz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825D726C: 894100EE  lbz r10, 0xee(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(238 as u32) ) } as u64;
	// 825D7270: 806100E8  lwz r3, 0xe8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 825D7274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D7278: 997E00D0  stb r11, 0xd0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 825D727C: 995E00D1  stb r10, 0xd1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(209 as u32), ctx.r[10].u8 ) };
	// 825D7280: 419A0008  beq cr6, 0x825d7288
	if ctx.cr[6].eq {
	pc = 0x825D7288; continue 'dispatch;
	}
	// 825D7284: 4BCE960D  bl 0x822c0890
	ctx.lr = 0x825D7288;
	sub_822C0890(ctx, base);
	// 825D7288: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825D728C: 4881C19D  bl 0x82df3428
	ctx.lr = 0x825D7290;
	sub_82DF3428(ctx, base);
	// 825D7290: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D7294: 4BDFB155  bl 0x823d23e8
	ctx.lr = 0x825D7298;
	sub_823D23E8(ctx, base);
	// 825D7298: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D729C: 4BDFB14D  bl 0x823d23e8
	ctx.lr = 0x825D72A0;
	sub_823D23E8(ctx, base);
	// 825D72A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D72A4: 4881C185  bl 0x82df3428
	ctx.lr = 0x825D72A8;
	sub_82DF3428(ctx, base);
	// 825D72A8: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825D72AC: 48BD0EFC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D72B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D72B0 size=144
    let mut pc: u32 = 0x825D72B0;
    'dispatch: loop {
        match pc {
            0x825D72B0 => {
    //   block [0x825D72B0..0x825D7340)
	// 825D72B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D72B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D72B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D72BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D72C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D72C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D72C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D72CC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D72D0: 409A0028  bne cr6, 0x825d72f8
	if !ctx.cr[6].eq {
	pc = 0x825D72F8; continue 'dispatch;
	}
	// 825D72D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D72D8: 419A0050  beq cr6, 0x825d7328
	if ctx.cr[6].eq {
	pc = 0x825D7328; continue 'dispatch;
	}
	// 825D72DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D72E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D72E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D72E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D72EC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D72F0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825D72F4: 48000034  b 0x825d7328
	pc = 0x825D7328; continue 'dispatch;
	// 825D72F8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825D72FC: 419A002C  beq cr6, 0x825d7328
	if ctx.cr[6].eq {
	pc = 0x825D7328; continue 'dispatch;
	}
	// 825D7300: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D7304: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7308: 388BC1B8  addi r4, r11, -0x3e48
	ctx.r[4].s64 = ctx.r[11].s64 + -15944;
	// 825D730C: 48BD0DED  bl 0x831a80f8
	ctx.lr = 0x825D7310;
	sub_831A80F8(ctx, base);
	// 825D7310: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D7314: 4182000C  beq 0x825d7320
	if ctx.cr[0].eq {
	pc = 0x825D7320; continue 'dispatch;
	}
	// 825D7318: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825D731C: 4800000C  b 0x825d7328
	pc = 0x825D7328; continue 'dispatch;
	// 825D7320: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7324: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7328: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D732C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D7330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D7334: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D7338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D733C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7340 size=196
    let mut pc: u32 = 0x825D7340;
    'dispatch: loop {
        match pc {
            0x825D7340 => {
    //   block [0x825D7340..0x825D7404)
	// 825D7340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D734C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D7350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D7358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D735C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D7360: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D7364: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7368: 4BCE95D1  bl 0x822c0938
	ctx.lr = 0x825D736C;
	sub_822C0938(ctx, base);
	// 825D736C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D7370: 41820028  beq 0x825d7398
	if ctx.cr[0].eq {
	pc = 0x825D7398; continue 'dispatch;
	}
	// 825D7374: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D7378: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D737C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D7380: 392BE60C  addi r9, r11, -0x19f4
	ctx.r[9].s64 = ctx.r[11].s64 + -6644;
	// 825D7384: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D7388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D738C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D7390: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D7394: 48000008  b 0x825d739c
	pc = 0x825D739C; continue 'dispatch;
	// 825D7398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D739C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D73A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D73A4: 409A0044  bne cr6, 0x825d73e8
	if !ctx.cr[6].eq {
	pc = 0x825D73E8; continue 'dispatch;
	}
	// 825D73A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D73AC: 419A001C  beq cr6, 0x825d73c8
	if ctx.cr[6].eq {
	pc = 0x825D73C8; continue 'dispatch;
	}
	// 825D73B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D73B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D73B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D73BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D73C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D73C4: 4E800421  bctrl
	ctx.lr = 0x825D73C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D73C8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D73CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D73D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D73D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D73D8: 816BC160  lwz r11, -0x3ea0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16032 as u32) ) } as u64;
	// 825D73DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D73E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D73E4: 4BCE8C1D  bl 0x822c0000
	ctx.lr = 0x825D73E8;
	sub_822C0000(ctx, base);
	// 825D73E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D73EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D73F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D73F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D73F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D73FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D7400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7408 size=72
    let mut pc: u32 = 0x825D7408;
    'dispatch: loop {
        match pc {
            0x825D7408 => {
    //   block [0x825D7408..0x825D7450)
	// 825D7408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D740C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7410: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7414: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825D7418: 419A001C  beq cr6, 0x825d7434
	if ctx.cr[6].eq {
	pc = 0x825D7434; continue 'dispatch;
	}
	// 825D741C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D7420: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D7424: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825D7428: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D742C: 4BFFFE85  bl 0x825d72b0
	ctx.lr = 0x825D7430;
	sub_825D72B0(ctx, base);
	// 825D7430: 48000010  b 0x825d7440
	pc = 0x825D7440; continue 'dispatch;
	// 825D7434: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D7438: 396BC1B8  addi r11, r11, -0x3e48
	ctx.r[11].s64 = ctx.r[11].s64 + -15944;
	// 825D743C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7440: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D7444: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D7448: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D744C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7450 size=72
    let mut pc: u32 = 0x825D7450;
    'dispatch: loop {
        match pc {
            0x825D7450 => {
    //   block [0x825D7450..0x825D7498)
	// 825D7450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7458: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D745C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D7464: 4BFDD795  bl 0x825b4bf8
	ctx.lr = 0x825D7468;
	sub_825B4BF8(ctx, base);
	// 825D7468: 389F012C  addi r4, r31, 0x12c
	ctx.r[4].s64 = ctx.r[31].s64 + 300;
	// 825D746C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7470: 483F12E9  bl 0x829c8758
	ctx.lr = 0x825D7474;
	sub_829C8758(ctx, base);
	// 825D7474: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D7478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D747C: 419A0008  beq cr6, 0x825d7484
	if ctx.cr[6].eq {
	pc = 0x825D7484; continue 'dispatch;
	}
	// 825D7480: 4BCE9411  bl 0x822c0890
	ctx.lr = 0x825D7484;
	sub_822C0890(ctx, base);
	// 825D7484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D7488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D748C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D7490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D7494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7498 size=140
    let mut pc: u32 = 0x825D7498;
    'dispatch: loop {
        match pc {
            0x825D7498 => {
    //   block [0x825D7498..0x825D7524)
	// 825D7498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D749C: 48BD0CD1  bl 0x831a816c
	ctx.lr = 0x825D74A0;
	sub_831A8130(ctx, base);
	// 825D74A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D74A4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D74A8: F8A100A8  std r5, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[5].u64 ) };
	// 825D74AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D74B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D74B4: 3BEB7DCC  addi r31, r11, 0x7dcc
	ctx.r[31].s64 = ctx.r[11].s64 + 32204;
	// 825D74B8: 816A7DD4  lwz r11, 0x7dd4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32212 as u32) ) } as u64;
	// 825D74BC: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D74C0: 40820024  bne 0x825d74e4
	if !ctx.cr[0].eq {
	pc = 0x825D74E4; continue 'dispatch;
	}
	// 825D74C4: 3D20825C  lis r9, -0x7da4
	ctx.r[9].s64 = -2107899904;
	// 825D74C8: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D74CC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D74D0: 39293EE0  addi r9, r9, 0x3ee0
	ctx.r[9].s64 = ctx.r[9].s64 + 16096;
	// 825D74D4: 39087408  addi r8, r8, 0x7408
	ctx.r[8].s64 = ctx.r[8].s64 + 29704;
	// 825D74D8: 916A7DD4  stw r11, 0x7dd4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32212 as u32), ctx.r[11].u32 ) };
	// 825D74DC: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D74E0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D74E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D74E8: 814100A8  lwz r10, 0xa8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825D74EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D74F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D74F4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825D74F8: 794507E6  rldicr r5, r10, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 825D74FC: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D7500: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D7504: 4BD301BD  bl 0x823076c0
	ctx.lr = 0x825D7508;
	sub_823076C0(ctx, base);
	// 825D7508: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D750C: 4182000C  beq 0x825d7518
	if ctx.cr[0].eq {
	pc = 0x825D7518; continue 'dispatch;
	}
	// 825D7510: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D7514: 48000008  b 0x825d751c
	pc = 0x825D751C; continue 'dispatch;
	// 825D7518: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D751C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D7520: 48BD0C9C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7528 size=1204
    let mut pc: u32 = 0x825D7528;
    'dispatch: loop {
        match pc {
            0x825D7528 => {
    //   block [0x825D7528..0x825D79DC)
	// 825D7528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D752C: 48BD0C1D  bl 0x831a8148
	ctx.lr = 0x825D7530;
	sub_831A8130(ctx, base);
	// 825D7530: 9421FC80  stwu r1, -0x380(r1)
	ea = ctx.r[1].u32.wrapping_add(-896 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7534: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 825D7538: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825D753C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D7540: 4881BBB1  bl 0x82df30f0
	ctx.lr = 0x825D7544;
	sub_82DF30F0(ctx, base);
	// 825D7544: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D7548: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 825D754C: 93E100B8  stw r31, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u32 ) };
	// 825D7550: 93E100BC  stw r31, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u32 ) };
	// 825D7554: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 825D7558: 4BFA33D9  bl 0x8257a930
	ctx.lr = 0x825D755C;
	sub_8257A930(ctx, base);
	// 825D755C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 825D7560: 485BD231  bl 0x82b94790
	ctx.lr = 0x825D7564;
	sub_82B94790(ctx, base);
	// 825D7564: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D7568: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D756C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825D7570: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D7574: 485BD2A5  bl 0x82b94818
	ctx.lr = 0x825D7578;
	sub_82B94818(ctx, base);
	// 825D7578: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 825D757C: 4BDFAE6D  bl 0x823d23e8
	ctx.lr = 0x825D7580;
	sub_823D23E8(ctx, base);
	// 825D7580: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D7584: 4882ADFD  bl 0x82e02380
	ctx.lr = 0x825D7588;
	sub_82E02380(ctx, base);
	// 825D7588: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D758C: 80950120  lwz r4, 0x120(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D7590: 4BF37F39  bl 0x8250f4c8
	ctx.lr = 0x825D7594;
	sub_8250F4C8(ctx, base);
	// 825D7594: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D759C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D75A0: 409A0008  bne cr6, 0x825d75a8
	if !ctx.cr[6].eq {
	pc = 0x825D75A8; continue 'dispatch;
	}
	// 825D75A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D75A8: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D75AC: 4BF30F7D  bl 0x82508528
	ctx.lr = 0x825D75B0;
	sub_82508528(ctx, base);
	// 825D75B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D75B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D75B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D75BC: 4882AC0D  bl 0x82e021c8
	ctx.lr = 0x825D75C0;
	sub_82E021C8(ctx, base);
	// 825D75C0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D75C4: 4881A6CD  bl 0x82df1c90
	ctx.lr = 0x825D75C8;
	sub_82DF1C90(ctx, base);
	// 825D75C8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D75CC: 80950120  lwz r4, 0x120(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D75D0: 4BF37EF9  bl 0x8250f4c8
	ctx.lr = 0x825D75D4;
	sub_8250F4C8(ctx, base);
	// 825D75D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D75D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D75DC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D75E0: 409A0008  bne cr6, 0x825d75e8
	if !ctx.cr[6].eq {
	pc = 0x825D75E8; continue 'dispatch;
	}
	// 825D75E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D75E8: 4BF31329  bl 0x82508910
	ctx.lr = 0x825D75EC;
	sub_82508910(ctx, base);
	// 825D75EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D75F0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D75F4: 4881A69D  bl 0x82df1c90
	ctx.lr = 0x825D75F8;
	sub_82DF1C90(ctx, base);
	// 825D75F8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825D75FC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D7600: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 825D7604: 7FF6FB78  mr r22, r31
	ctx.r[22].u64 = ctx.r[31].u64;
	// 825D7608: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825D760C: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 825D7610: 3B40000A  li r26, 0xa
	ctx.r[26].s64 = 10;
	// 825D7614: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 825D7618: 3B0B0878  addi r24, r11, 0x878
	ctx.r[24].s64 = ctx.r[11].s64 + 2168;
	// 825D761C: 3B8A8408  addi r28, r10, -0x7bf8
	ctx.r[28].s64 = ctx.r[10].s64 + -31736;
	// 825D7620: 3AE90880  addi r23, r9, 0x880
	ctx.r[23].s64 = ctx.r[9].s64 + 2176;
	// 825D7624: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 825D7628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D762C: 419A0124  beq cr6, 0x825d7750
	if ctx.cr[6].eq {
	pc = 0x825D7750; continue 'dispatch;
	}
	// 825D7630: 814100BC  lwz r10, 0xbc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825D7634: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D7638: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825D763C: 7F165040  cmplw cr6, r22, r10
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D7640: 40980110  bge cr6, 0x825d7750
	if !ctx.cr[6].lt {
	pc = 0x825D7750; continue 'dispatch;
	}
	// 825D7644: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D7648: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D764C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D7650: 4881C651  bl 0x82df3ca0
	ctx.lr = 0x825D7654;
	sub_82DF3CA0(ctx, base);
	// 825D7654: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D7658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D765C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825D7660: 4881C699  bl 0x82df3cf8
	ctx.lr = 0x825D7664;
	sub_82DF3CF8(ctx, base);
	// 825D7664: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D7668: 4881BDC1  bl 0x82df3428
	ctx.lr = 0x825D766C;
	sub_82DF3428(ctx, base);
	// 825D766C: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 825D7670: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D7674: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D7678: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D767C: 4881C625  bl 0x82df3ca0
	ctx.lr = 0x825D7680;
	sub_82DF3CA0(ctx, base);
	// 825D7680: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D7684: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825D7688: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825D768C: 4881C66D  bl 0x82df3cf8
	ctx.lr = 0x825D7690;
	sub_82DF3CF8(ctx, base);
	// 825D7690: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D7694: 4881BD95  bl 0x82df3428
	ctx.lr = 0x825D7698;
	sub_82DF3428(ctx, base);
	// 825D7698: 932101E0  stw r25, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[25].u32 ) };
	// 825D769C: 934101E4  stw r26, 0x1e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), ctx.r[26].u32 ) };
	// 825D76A0: 38E101E0  addi r7, r1, 0x1e0
	ctx.r[7].s64 = ctx.r[1].s64 + 480;
	// 825D76A4: 93E101E8  stw r31, 0x1e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), ctx.r[31].u32 ) };
	// 825D76A8: 38C1006C  addi r6, r1, 0x6c
	ctx.r[6].s64 = ctx.r[1].s64 + 108;
	// 825D76AC: 93E101EC  stw r31, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[31].u32 ) };
	// 825D76B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D76B4: 93E101F0  stw r31, 0x1f0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(496 as u32), ctx.r[31].u32 ) };
	// 825D76B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D76BC: 93E10210  stw r31, 0x210(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(528 as u32), ctx.r[31].u32 ) };
	// 825D76C0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D76C4: 93E10230  stw r31, 0x230(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(560 as u32), ctx.r[31].u32 ) };
	// 825D76C8: 93E10250  stw r31, 0x250(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(592 as u32), ctx.r[31].u32 ) };
	// 825D76CC: 93C10270  stw r30, 0x270(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(624 as u32), ctx.r[30].u32 ) };
	// 825D76D0: 4882EDD1  bl 0x82e064a0
	ctx.lr = 0x825D76D4;
	sub_82E064A0(ctx, base);
	// 825D76D4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825D76D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D76DC: 419A0008  beq cr6, 0x825d76e4
	if ctx.cr[6].eq {
	pc = 0x825D76E4; continue 'dispatch;
	}
	// 825D76E0: 4BCE91B1  bl 0x822c0890
	ctx.lr = 0x825D76E4;
	sub_822C0890(ctx, base);
	// 825D76E4: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 825D76E8: 4BEF9FE1  bl 0x824d16c8
	ctx.lr = 0x825D76EC;
	sub_824D16C8(ctx, base);
	// 825D76EC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D76F0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D76F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D76F8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D76FC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825D7700: 419A0024  beq cr6, 0x825d7724
	if ctx.cr[6].eq {
	pc = 0x825D7724; continue 'dispatch;
	}
	// 825D7704: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D7708: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D770C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7710: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D7714: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D7718: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D771C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7720: 4082FFE8  bne 0x825d7708
	if !ctx.cr[0].eq {
	pc = 0x825D7708; continue 'dispatch;
	}
	// 825D7724: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 825D7728: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D772C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D7730: 4882D4C1  bl 0x82e04bf0
	ctx.lr = 0x825D7734;
	sub_82E04BF0(ctx, base);
	// 825D7734: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825D7738: 4881BCF1  bl 0x82df3428
	ctx.lr = 0x825D773C;
	sub_82DF3428(ctx, base);
	// 825D773C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7740: 4881BCE9  bl 0x82df3428
	ctx.lr = 0x825D7744;
	sub_82DF3428(ctx, base);
	// 825D7744: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825D7748: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825D774C: 4BFFFED8  b 0x825d7624
	pc = 0x825D7624; continue 'dispatch;
	// 825D7750: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D7754: 4882ADD5  bl 0x82e02528
	ctx.lr = 0x825D7758;
	sub_82E02528(ctx, base);
	// 825D7758: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D775C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D7760: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7764: 4882A36D  bl 0x82e01ad0
	ctx.lr = 0x825D7768;
	sub_82E01AD0(ctx, base);
	// 825D7768: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D776C: 7FF6FB78  mr r22, r31
	ctx.r[22].u64 = ctx.r[31].u64;
	// 825D7770: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825D7774: 3B0BE61C  addi r24, r11, -0x19e4
	ctx.r[24].s64 = ctx.r[11].s64 + -6628;
	// 825D7778: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 825D777C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7780: 419A0134  beq cr6, 0x825d78b4
	if ctx.cr[6].eq {
	pc = 0x825D78B4; continue 'dispatch;
	}
	// 825D7784: 814100BC  lwz r10, 0xbc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825D7788: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D778C: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825D7790: 7F165040  cmplw cr6, r22, r10
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825D7794: 40980120  bge cr6, 0x825d78b4
	if !ctx.cr[6].lt {
	pc = 0x825D78B4; continue 'dispatch;
	}
	// 825D7798: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D779C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D77A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D77A4: 4881C4FD  bl 0x82df3ca0
	ctx.lr = 0x825D77A8;
	sub_82DF3CA0(ctx, base);
	// 825D77A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D77AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D77B0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825D77B4: 4881C545  bl 0x82df3cf8
	ctx.lr = 0x825D77B8;
	sub_82DF3CF8(ctx, base);
	// 825D77B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D77BC: 4881BC6D  bl 0x82df3428
	ctx.lr = 0x825D77C0;
	sub_82DF3428(ctx, base);
	// 825D77C0: 93210140  stw r25, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[25].u32 ) };
	// 825D77C4: 93410144  stw r26, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[26].u32 ) };
	// 825D77C8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825D77CC: 93E10148  stw r31, 0x148(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[31].u32 ) };
	// 825D77D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D77D4: 93E1014C  stw r31, 0x14c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[31].u32 ) };
	// 825D77D8: 3A810140  addi r20, r1, 0x140
	ctx.r[20].s64 = ctx.r[1].s64 + 320;
	// 825D77DC: 93E10150  stw r31, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[31].u32 ) };
	// 825D77E0: 93E10170  stw r31, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[31].u32 ) };
	// 825D77E4: 93E10190  stw r31, 0x190(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[31].u32 ) };
	// 825D77E8: 93E101B0  stw r31, 0x1b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[31].u32 ) };
	// 825D77EC: 93C101D0  stw r30, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[30].u32 ) };
	// 825D77F0: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 825D77F4: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825D77F8: 4881C4A9  bl 0x82df3ca0
	ctx.lr = 0x825D77FC;
	sub_82DF3CA0(ctx, base);
	// 825D77FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D7800: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D7804: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D7808: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 825D780C: 4882DE95  bl 0x82e056a0
	ctx.lr = 0x825D7810;
	sub_82E056A0(ctx, base);
	// 825D7810: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D7814: 4881BC15  bl 0x82df3428
	ctx.lr = 0x825D7818;
	sub_82DF3428(ctx, base);
	// 825D7818: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 825D781C: 4BEF9EAD  bl 0x824d16c8
	ctx.lr = 0x825D7820;
	sub_824D16C8(ctx, base);
	// 825D7820: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D7824: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D7828: 93210280  stw r25, 0x280(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(640 as u32), ctx.r[25].u32 ) };
	// 825D782C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7830: 93410284  stw r26, 0x284(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), ctx.r[26].u32 ) };
	// 825D7834: 93E10288  stw r31, 0x288(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(648 as u32), ctx.r[31].u32 ) };
	// 825D7838: 93E1028C  stw r31, 0x28c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(652 as u32), ctx.r[31].u32 ) };
	// 825D783C: 93E10290  stw r31, 0x290(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(656 as u32), ctx.r[31].u32 ) };
	// 825D7840: 93E102B0  stw r31, 0x2b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(688 as u32), ctx.r[31].u32 ) };
	// 825D7844: 93E102D0  stw r31, 0x2d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), ctx.r[31].u32 ) };
	// 825D7848: 93E102F0  stw r31, 0x2f0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(752 as u32), ctx.r[31].u32 ) };
	// 825D784C: 93C10310  stw r30, 0x310(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(784 as u32), ctx.r[30].u32 ) };
	// 825D7850: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D7854: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825D7858: 419A0024  beq cr6, 0x825d787c
	if ctx.cr[6].eq {
	pc = 0x825D787C; continue 'dispatch;
	}
	// 825D785C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D7860: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D7864: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7868: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D786C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D7870: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D7874: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7878: 4082FFE8  bne 0x825d7860
	if !ctx.cr[0].eq {
	pc = 0x825D7860; continue 'dispatch;
	}
	// 825D787C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825D7880: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D7884: 38C10280  addi r6, r1, 0x280
	ctx.r[6].s64 = ctx.r[1].s64 + 640;
	// 825D7888: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D788C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D7890: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D7894: 4882CEED  bl 0x82e04780
	ctx.lr = 0x825D7898;
	sub_82E04780(ctx, base);
	// 825D7898: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 825D789C: 4BEF9E2D  bl 0x824d16c8
	ctx.lr = 0x825D78A0;
	sub_824D16C8(ctx, base);
	// 825D78A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D78A4: 4881BB85  bl 0x82df3428
	ctx.lr = 0x825D78A8;
	sub_82DF3428(ctx, base);
	// 825D78A8: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825D78AC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825D78B0: 4BFFFEC8  b 0x825d7778
	pc = 0x825D7778; continue 'dispatch;
	// 825D78B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D78B8: 4882C539  bl 0x82e03df0
	ctx.lr = 0x825D78BC;
	sub_82E03DF0(ctx, base);
	// 825D78BC: 38C100C4  addi r6, r1, 0xc4
	ctx.r[6].s64 = ctx.r[1].s64 + 196;
	// 825D78C0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 825D78C4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D78C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D78CC: 485BD0F5  bl 0x82b949c0
	ctx.lr = 0x825D78D0;
	sub_82B949C0(ctx, base);
	// 825D78D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D78D4: 80950120  lwz r4, 0x120(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D78D8: 4BF37BF1  bl 0x8250f4c8
	ctx.lr = 0x825D78DC;
	sub_8250F4C8(ctx, base);
	// 825D78DC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825D78E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D78E4: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 825D78E8: 4881C121  bl 0x82df3a08
	ctx.lr = 0x825D78EC;
	sub_82DF3A08(ctx, base);
	// 825D78EC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D78F0: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825D78F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D78F8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D78FC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825D7900: 419A0024  beq cr6, 0x825d7924
	if ctx.cr[6].eq {
	pc = 0x825D7924; continue 'dispatch;
	}
	// 825D7904: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D7908: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D790C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7910: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D7914: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D7918: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D791C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7920: 4082FFE8  bne 0x825d7908
	if !ctx.cr[0].eq {
	pc = 0x825D7908; continue 'dispatch;
	}
	// 825D7924: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825D7928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D792C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825D7930: 409A000C  bne cr6, 0x825d793c
	if !ctx.cr[6].eq {
	pc = 0x825D793C; continue 'dispatch;
	}
	// 825D7934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D7938: 419A0008  beq cr6, 0x825d7940
	if ctx.cr[6].eq {
	pc = 0x825D7940; continue 'dispatch;
	}
	// 825D793C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 825D7940: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D7944: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D7948: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825D794C: 4BF33D05  bl 0x8250b650
	ctx.lr = 0x825D7950;
	sub_8250B650(ctx, base);
	// 825D7950: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D7954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7958: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D795C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D7960: 4BF35BA9  bl 0x8250d508
	ctx.lr = 0x825D7964;
	sub_8250D508(ctx, base);
	// 825D7964: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D7968: 4881A329  bl 0x82df1c90
	ctx.lr = 0x825D796C;
	sub_82DF1C90(ctx, base);
	// 825D796C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7970: 4881BAB9  bl 0x82df3428
	ctx.lr = 0x825D7974;
	sub_82DF3428(ctx, base);
	// 825D7974: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D7978: 4881A319  bl 0x82df1c90
	ctx.lr = 0x825D797C;
	sub_82DF1C90(ctx, base);
	// 825D797C: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825D7980: 485B7C71  bl 0x82b8f5f0
	ctx.lr = 0x825D7984;
	sub_82B8F5F0(ctx, base);
	// 825D7984: 3975012C  addi r11, r21, 0x12c
	ctx.r[11].s64 = ctx.r[21].s64 + 300;
	// 825D7988: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 825D798C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825D7990: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825D7994: 9175012C  stw r11, 0x12c(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825D7998: 4BF1E919  bl 0x824f62b0
	ctx.lr = 0x825D799C;
	sub_824F62B0(ctx, base);
	// 825D799C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D79A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D79A4: 419A0008  beq cr6, 0x825d79ac
	if ctx.cr[6].eq {
	pc = 0x825D79AC; continue 'dispatch;
	}
	// 825D79A8: 4BCE8EE9  bl 0x822c0890
	ctx.lr = 0x825D79AC;
	sub_822C0890(ctx, base);
	// 825D79AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D79B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D79B4: 419A0008  beq cr6, 0x825d79bc
	if ctx.cr[6].eq {
	pc = 0x825D79BC; continue 'dispatch;
	}
	// 825D79B8: 4BCE8ED9  bl 0x822c0890
	ctx.lr = 0x825D79BC;
	sub_822C0890(ctx, base);
	// 825D79BC: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 825D79C0: 4BFA2FF1  bl 0x8257a9b0
	ctx.lr = 0x825D79C4;
	sub_8257A9B0(ctx, base);
	// 825D79C4: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 825D79C8: 4BDFAA21  bl 0x823d23e8
	ctx.lr = 0x825D79CC;
	sub_823D23E8(ctx, base);
	// 825D79CC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825D79D0: 4881BA59  bl 0x82df3428
	ctx.lr = 0x825D79D4;
	sub_82DF3428(ctx, base);
	// 825D79D4: 38210380  addi r1, r1, 0x380
	ctx.r[1].s64 = ctx.r[1].s64 + 896;
	// 825D79D8: 48BD07C0  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D79E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D79E0 size=144
    let mut pc: u32 = 0x825D79E0;
    'dispatch: loop {
        match pc {
            0x825D79E0 => {
    //   block [0x825D79E0..0x825D7A70)
	// 825D79E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D79E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D79E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D79EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D79F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D79F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D79F8: 396BE634  addi r11, r11, -0x19cc
	ctx.r[11].s64 = ctx.r[11].s64 + -6604;
	// 825D79FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7A00: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825D7A04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D7A08: 419A003C  beq cr6, 0x825d7a44
	if ctx.cr[6].eq {
	pc = 0x825D7A44; continue 'dispatch;
	}
	// 825D7A0C: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 825D7A10: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825D7A14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7A18: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825D7A1C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825D7A20: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D7A24: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7A28: 4082FFE8  bne 0x825d7a10
	if !ctx.cr[0].eq {
	pc = 0x825D7A10; continue 'dispatch;
	}
	// 825D7A2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D7A30: 409A0014  bne cr6, 0x825d7a44
	if !ctx.cr[6].eq {
	pc = 0x825D7A44; continue 'dispatch;
	}
	// 825D7A34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7A38: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D7A3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D7A40: 4E800421  bctrl
	ctx.lr = 0x825D7A44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7A44: 807F0128  lwz r3, 0x128(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 825D7A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D7A4C: 419A0008  beq cr6, 0x825d7a54
	if ctx.cr[6].eq {
	pc = 0x825D7A54; continue 'dispatch;
	}
	// 825D7A50: 4BCE8E41  bl 0x822c0890
	ctx.lr = 0x825D7A54;
	sub_822C0890(ctx, base);
	// 825D7A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7A58: 4BFDC949  bl 0x825b43a0
	ctx.lr = 0x825D7A5C;
	sub_825B43A0(ctx, base);
	// 825D7A5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D7A60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D7A64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D7A68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D7A6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7A70 size=96
    let mut pc: u32 = 0x825D7A70;
    'dispatch: loop {
        match pc {
            0x825D7A70 => {
    //   block [0x825D7A70..0x825D7AD0)
	// 825D7A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7A78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D7A7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D7A80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D7A88: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 825D7A8C: 4BFDD32D  bl 0x825b4db8
	ctx.lr = 0x825D7A90;
	sub_825B4DB8(ctx, base);
	// 825D7A90: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D7A94: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 825D7A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7A9C: 394AE634  addi r10, r10, -0x19cc
	ctx.r[10].s64 = ctx.r[10].s64 + -6604;
	// 825D7AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7AA4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D7AA8: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825D7AAC: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 825D7AB0: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825D7AB4: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825D7AB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D7ABC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D7AC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D7AC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D7AC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D7ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7AD0 size=76
    let mut pc: u32 = 0x825D7AD0;
    'dispatch: loop {
        match pc {
            0x825D7AD0 => {
    //   block [0x825D7AD0..0x825D7B1C)
	// 825D7AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7AD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D7ADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D7AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D7AE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D7AEC: 4BFFFEF5  bl 0x825d79e0
	ctx.lr = 0x825D7AF0;
	sub_825D79E0(ctx, base);
	// 825D7AF0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D7AF4: 4182000C  beq 0x825d7b00
	if ctx.cr[0].eq {
	pc = 0x825D7B00; continue 'dispatch;
	}
	// 825D7AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7AFC: 4BCE876D  bl 0x822c0268
	ctx.lr = 0x825D7B00;
	sub_822C0268(ctx, base);
	// 825D7B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7B04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D7B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D7B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D7B10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D7B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D7B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D7B20 size=364
    let mut pc: u32 = 0x825D7B20;
    'dispatch: loop {
        match pc {
            0x825D7B20 => {
    //   block [0x825D7B20..0x825D7C8C)
	// 825D7B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7B24: 48BD0641  bl 0x831a8164
	ctx.lr = 0x825D7B28;
	sub_831A8130(ctx, base);
	// 825D7B28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7B2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D7B30: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D7B34: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825D7B38: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825D7B3C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D7B40: C18B9690  lfs f12, -0x6970(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26992 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825D7B44: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825D7B48: C16AE70C  lfs f11, -0x18f4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825D7B4C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D7B50: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D7B54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D7B58: C1A8959C  lfs f13, -0x6a64(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D7B5C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825D7B60: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825D7B64: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D7B68: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825D7B6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D7B70: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825D7B74: 3887E6B8  addi r4, r7, -0x1948
	ctx.r[4].s64 = ctx.r[7].s64 + -6472;
	// 825D7B78: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825D7B7C: 38A00025  li r5, 0x25
	ctx.r[5].s64 = 37;
	// 825D7B80: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825D7B84: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 825D7B88: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825D7B8C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825D7B90: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825D7B94: 4BCE8845  bl 0x822c03d8
	ctx.lr = 0x825D7B98;
	sub_822C03D8(ctx, base);
	// 825D7B98: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D7B9C: 4182003C  beq 0x825d7bd8
	if ctx.cr[0].eq {
	pc = 0x825D7BD8; continue 'dispatch;
	}
	// 825D7BA0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D7BA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7BA8: 808BC15C  lwz r4, -0x3ea4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16036 as u32) ) } as u64;
	// 825D7BAC: 4881BE5D  bl 0x82df3a08
	ctx.lr = 0x825D7BB0;
	sub_82DF3A08(ctx, base);
	// 825D7BB0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 825D7BB4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D7BB8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825D7BBC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825D7BC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D7BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7BC8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825D7BCC: 4BFFFEA5  bl 0x825d7a70
	ctx.lr = 0x825D7BD0;
	sub_825D7A70(ctx, base);
	// 825D7BD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D7BD4: 48000008  b 0x825d7bdc
	pc = 0x825D7BDC; continue 'dispatch;
	// 825D7BD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D7BDC: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D7BE0: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825D7BE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D7BE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D7BEC: 4BFFF755  bl 0x825d7340
	ctx.lr = 0x825D7BF0;
	sub_825D7340(ctx, base);
	// 825D7BF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D7BF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D7BF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D7BFC: 4BCE8405  bl 0x822c0000
	ctx.lr = 0x825D7C00;
	sub_822C0000(ctx, base);
	// 825D7C00: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D7C04: 4182000C  beq 0x825d7c10
	if ctx.cr[0].eq {
	pc = 0x825D7C10; continue 'dispatch;
	}
	// 825D7C08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7C0C: 4881B81D  bl 0x82df3428
	ctx.lr = 0x825D7C10;
	sub_82DF3428(ctx, base);
	// 825D7C10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D7C14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7C18: 388BE69C  addi r4, r11, -0x1964
	ctx.r[4].s64 = ctx.r[11].s64 + -6500;
	// 825D7C1C: 4881BDED  bl 0x82df3a08
	ctx.lr = 0x825D7C20;
	sub_82DF3A08(ctx, base);
	// 825D7C20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7C24: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7C2C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D7C30: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D7C34: 419A0024  beq cr6, 0x825d7c58
	if ctx.cr[6].eq {
	pc = 0x825D7C58; continue 'dispatch;
	}
	// 825D7C38: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D7C3C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D7C40: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7C44: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D7C48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D7C4C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D7C50: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D7C54: 4082FFE8  bne 0x825d7c3c
	if !ctx.cr[0].eq {
	pc = 0x825D7C3C; continue 'dispatch;
	}
	// 825D7C58: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D7C5C: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7C60: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D7C64: 4BFDE635  bl 0x825b6298
	ctx.lr = 0x825D7C68;
	sub_825B6298(ctx, base);
	// 825D7C68: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D7C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D7C70: 419A0008  beq cr6, 0x825d7c78
	if ctx.cr[6].eq {
	pc = 0x825D7C78; continue 'dispatch;
	}
	// 825D7C74: 4BCE8C1D  bl 0x822c0890
	ctx.lr = 0x825D7C78;
	sub_822C0890(ctx, base);
	// 825D7C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7C7C: 4881B7AD  bl 0x82df3428
	ctx.lr = 0x825D7C80;
	sub_82DF3428(ctx, base);
	// 825D7C80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D7C84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825D7C88: 48BD052C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7C90 size=360
    let mut pc: u32 = 0x825D7C90;
    'dispatch: loop {
        match pc {
            0x825D7C90 => {
    //   block [0x825D7C90..0x825D7DF8)
	// 825D7C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7C94: 48BD04CD  bl 0x831a8160
	ctx.lr = 0x825D7C98;
	sub_831A8130(ctx, base);
	// 825D7C98: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7C9C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825D7CA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D7CA4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825D7CA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D7CAC: 3B4BE6B8  addi r26, r11, -0x1948
	ctx.r[26].s64 = ctx.r[11].s64 + -6472;
	// 825D7CB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D7CB4: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 825D7CB8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D7CBC: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825D7CC0: 4BCE8719  bl 0x822c03d8
	ctx.lr = 0x825D7CC4;
	sub_822C03D8(ctx, base);
	// 825D7CC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D7CC8: 41820010  beq 0x825d7cd8
	if ctx.cr[0].eq {
	pc = 0x825D7CD8; continue 'dispatch;
	}
	// 825D7CCC: 4BFCA5E5  bl 0x825a22b0
	ctx.lr = 0x825D7CD0;
	sub_825A22B0(ctx, base);
	// 825D7CD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D7CD4: 48000008  b 0x825d7cdc
	pc = 0x825D7CDC; continue 'dispatch;
	// 825D7CD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D7CDC: 387D0124  addi r3, r29, 0x124
	ctx.r[3].s64 = ctx.r[29].s64 + 292;
	// 825D7CE0: 4BFDDD21  bl 0x825b5a00
	ctx.lr = 0x825D7CE4;
	sub_825B5A00(ctx, base);
	// 825D7CE4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D7CE8: 485BCAA9  bl 0x82b94790
	ctx.lr = 0x825D7CEC;
	sub_82B94790(ctx, base);
	// 825D7CEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D7CF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D7CF4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D7CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7CFC: 419A00EC  beq cr6, 0x825d7de8
	if ctx.cr[6].eq {
	pc = 0x825D7DE8; continue 'dispatch;
	}
	// 825D7D00: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825D7D04: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D7D08: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825D7D0C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D7D10: 409800D8  bge cr6, 0x825d7de8
	if !ctx.cr[6].lt {
	pc = 0x825D7DE8; continue 'dispatch;
	}
	// 825D7D14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D7D18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D7D1C: 38A0003B  li r5, 0x3b
	ctx.r[5].s64 = 59;
	// 825D7D20: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 825D7D24: 4881A6C5  bl 0x82df23e8
	ctx.lr = 0x825D7D28;
	sub_82DF23E8(ctx, base);
	// 825D7D28: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D7D2C: 4182005C  beq 0x825d7d88
	if ctx.cr[0].eq {
	pc = 0x825D7D88; continue 'dispatch;
	}
	// 825D7D30: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825D7D34: 3D60825D  lis r11, -0x7da3
	ctx.r[11].s64 = -2107834368;
	// 825D7D38: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825D7D3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D7D40: E9210058  ld r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825D7D44: 396B7528  addi r11, r11, 0x7528
	ctx.r[11].s64 = ctx.r[11].s64 + 29992;
	// 825D7D48: F9210064  std r9, 0x64(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u64 ) };
	// 825D7D4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D7D50: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D7D54: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D7D58: 792507E6  rldicr r5, r9, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 825D7D5C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825D7D60: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825D7D64: 4BFFF735  bl 0x825d7498
	ctx.lr = 0x825D7D68;
	sub_825D7498(ctx, base);
	// 825D7D68: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D7D6C: 7C9C5A14  add r4, r28, r11
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825D7D70: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D7D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7D78: 637B0001  ori r27, r27, 1
	ctx.r[27].u64 = ctx.r[27].u64 | 1;
	// 825D7D7C: 4BFFA84D  bl 0x825d25c8
	ctx.lr = 0x825D7D80;
	sub_825D25C8(ctx, base);
	// 825D7D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D7D84: 48000008  b 0x825d7d8c
	pc = 0x825D7D8C; continue 'dispatch;
	// 825D7D88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D7D8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825D7D90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D7D94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D7D98: 4BFDE119  bl 0x825b5eb0
	ctx.lr = 0x825D7D9C;
	sub_825B5EB0(ctx, base);
	// 825D7D9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D7DA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D7DA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D7DA8: 4BCE8259  bl 0x822c0000
	ctx.lr = 0x825D7DAC;
	sub_822C0000(ctx, base);
	// 825D7DAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D7DB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D7DB4: 4BFDEC3D  bl 0x825b69f0
	ctx.lr = 0x825D7DB8;
	sub_825B69F0(ctx, base);
	// 825D7DB8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D7DBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D7DC0: 419A0008  beq cr6, 0x825d7dc8
	if ctx.cr[6].eq {
	pc = 0x825D7DC8; continue 'dispatch;
	}
	// 825D7DC4: 4BCE8ACD  bl 0x822c0890
	ctx.lr = 0x825D7DC8;
	sub_822C0890(ctx, base);
	// 825D7DC8: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D7DCC: 41820010  beq 0x825d7ddc
	if ctx.cr[0].eq {
	pc = 0x825D7DDC; continue 'dispatch;
	}
	// 825D7DD0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D7DD4: 577B003C  rlwinm r27, r27, 0, 0, 0x1e
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 825D7DD8: 4BCF0EE1  bl 0x822c8cb8
	ctx.lr = 0x825D7DDC;
	sub_822C8CB8(ctx, base);
	// 825D7DDC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825D7DE0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 825D7DE4: 4BFFFF10  b 0x825d7cf4
	pc = 0x825D7CF4; continue 'dispatch;
	// 825D7DE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D7DEC: 4BDFA5FD  bl 0x823d23e8
	ctx.lr = 0x825D7DF0;
	sub_823D23E8(ctx, base);
	// 825D7DF0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825D7DF4: 48BD03BC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7DF8 size=196
    let mut pc: u32 = 0x825D7DF8;
    'dispatch: loop {
        match pc {
            0x825D7DF8 => {
    //   block [0x825D7DF8..0x825D7EBC)
	// 825D7DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7E00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D7E04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D7E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7E0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D7E10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7E14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D7E18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D7E1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7E20: 4BCE8B19  bl 0x822c0938
	ctx.lr = 0x825D7E24;
	sub_822C0938(ctx, base);
	// 825D7E24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D7E28: 41820028  beq 0x825d7e50
	if ctx.cr[0].eq {
	pc = 0x825D7E50; continue 'dispatch;
	}
	// 825D7E2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D7E30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D7E34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D7E38: 392BE71C  addi r9, r11, -0x18e4
	ctx.r[9].s64 = ctx.r[11].s64 + -6372;
	// 825D7E3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D7E40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D7E44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D7E48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D7E4C: 48000008  b 0x825d7e54
	pc = 0x825D7E54; continue 'dispatch;
	// 825D7E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7E54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7E58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7E5C: 409A0044  bne cr6, 0x825d7ea0
	if !ctx.cr[6].eq {
	pc = 0x825D7EA0; continue 'dispatch;
	}
	// 825D7E60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D7E64: 419A001C  beq cr6, 0x825d7e80
	if ctx.cr[6].eq {
	pc = 0x825D7E80; continue 'dispatch;
	}
	// 825D7E68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7E6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D7E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7E74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7E78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D7E7C: 4E800421  bctrl
	ctx.lr = 0x825D7E80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7E80: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D7E84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D7E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7E8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D7E90: 816BC290  lwz r11, -0x3d70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15728 as u32) ) } as u64;
	// 825D7E94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D7E98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D7E9C: 4BCE8165  bl 0x822c0000
	ctx.lr = 0x825D7EA0;
	sub_822C0000(ctx, base);
	// 825D7EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D7EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D7EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D7EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D7EB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D7EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D7EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7EC0 size=196
    let mut pc: u32 = 0x825D7EC0;
    'dispatch: loop {
        match pc {
            0x825D7EC0 => {
    //   block [0x825D7EC0..0x825D7F84)
	// 825D7EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D7ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D7ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7ED4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D7ED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7EDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D7EE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D7EE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7EE8: 4BCE8A51  bl 0x822c0938
	ctx.lr = 0x825D7EEC;
	sub_822C0938(ctx, base);
	// 825D7EEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D7EF0: 41820028  beq 0x825d7f18
	if ctx.cr[0].eq {
	pc = 0x825D7F18; continue 'dispatch;
	}
	// 825D7EF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D7EF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D7EFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D7F00: 392BE730  addi r9, r11, -0x18d0
	ctx.r[9].s64 = ctx.r[11].s64 + -6352;
	// 825D7F04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D7F08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D7F0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D7F10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D7F14: 48000008  b 0x825d7f1c
	pc = 0x825D7F1C; continue 'dispatch;
	// 825D7F18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7F1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7F20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7F24: 409A0044  bne cr6, 0x825d7f68
	if !ctx.cr[6].eq {
	pc = 0x825D7F68; continue 'dispatch;
	}
	// 825D7F28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D7F2C: 419A001C  beq cr6, 0x825d7f48
	if ctx.cr[6].eq {
	pc = 0x825D7F48; continue 'dispatch;
	}
	// 825D7F30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7F34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D7F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D7F3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D7F44: 4E800421  bctrl
	ctx.lr = 0x825D7F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D7F48: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D7F4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D7F50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D7F54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D7F58: 816BC290  lwz r11, -0x3d70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15728 as u32) ) } as u64;
	// 825D7F5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D7F60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D7F64: 4BCE809D  bl 0x822c0000
	ctx.lr = 0x825D7F68;
	sub_822C0000(ctx, base);
	// 825D7F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D7F6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D7F70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D7F74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D7F78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D7F7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D7F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D7F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D7F88 size=196
    let mut pc: u32 = 0x825D7F88;
    'dispatch: loop {
        match pc {
            0x825D7F88 => {
    //   block [0x825D7F88..0x825D804C)
	// 825D7F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D7F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D7F90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D7F94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D7F98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D7F9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D7FA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7FA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D7FA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D7FAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7FB0: 4BCE8989  bl 0x822c0938
	ctx.lr = 0x825D7FB4;
	sub_822C0938(ctx, base);
	// 825D7FB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D7FB8: 41820028  beq 0x825d7fe0
	if ctx.cr[0].eq {
	pc = 0x825D7FE0; continue 'dispatch;
	}
	// 825D7FBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D7FC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D7FC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D7FC8: 392BE744  addi r9, r11, -0x18bc
	ctx.r[9].s64 = ctx.r[11].s64 + -6332;
	// 825D7FCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D7FD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D7FD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D7FD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D7FDC: 48000008  b 0x825d7fe4
	pc = 0x825D7FE4; continue 'dispatch;
	// 825D7FE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D7FE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D7FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D7FEC: 409A0044  bne cr6, 0x825d8030
	if !ctx.cr[6].eq {
	pc = 0x825D8030; continue 'dispatch;
	}
	// 825D7FF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D7FF4: 419A001C  beq cr6, 0x825d8010
	if ctx.cr[6].eq {
	pc = 0x825D8010; continue 'dispatch;
	}
	// 825D7FF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D7FFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D8000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8004: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D800C: 4E800421  bctrl
	ctx.lr = 0x825D8010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D8010: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D8014: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D8018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D801C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D8020: 816BC290  lwz r11, -0x3d70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15728 as u32) ) } as u64;
	// 825D8024: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D8028: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D802C: 4BCE7FD5  bl 0x822c0000
	ctx.lr = 0x825D8030;
	sub_822C0000(ctx, base);
	// 825D8030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D803C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8040: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8044: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8050 size=124
    let mut pc: u32 = 0x825D8050;
    'dispatch: loop {
        match pc {
            0x825D8050 => {
    //   block [0x825D8050..0x825D80CC)
	// 825D8050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8054: 48BD0119  bl 0x831a816c
	ctx.lr = 0x825D8058;
	sub_831A8130(ctx, base);
	// 825D8058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D805C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D8060: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D8064: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D8068: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825D806C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825D8070: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825D8074: 4881A375  bl 0x82df23e8
	ctx.lr = 0x825D8078;
	sub_82DF23E8(ctx, base);
	// 825D8078: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D807C: 4182001C  beq 0x825d8098
	if ctx.cr[0].eq {
	pc = 0x825D8098; continue 'dispatch;
	}
	// 825D8080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8084: 488815FD  bl 0x82e59680
	ctx.lr = 0x825D8088;
	sub_82E59680(ctx, base);
	// 825D8088: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D808C: 396BE714  addi r11, r11, -0x18ec
	ctx.r[11].s64 = ctx.r[11].s64 + -6380;
	// 825D8090: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D8094: 48000008  b 0x825d809c
	pc = 0x825D809C; continue 'dispatch;
	// 825D8098: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D809C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D80A0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D80A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D80A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D80AC: 4BFFFE15  bl 0x825d7ec0
	ctx.lr = 0x825D80B0;
	sub_825D7EC0(ctx, base);
	// 825D80B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D80B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D80B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D80BC: 4BCE7F45  bl 0x822c0000
	ctx.lr = 0x825D80C0;
	sub_822C0000(ctx, base);
	// 825D80C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D80C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D80C8: 48BD00F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D80D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D80D0 size=120
    let mut pc: u32 = 0x825D80D0;
    'dispatch: loop {
        match pc {
            0x825D80D0 => {
    //   block [0x825D80D0..0x825D8148)
	// 825D80D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D80D4: 48BD0099  bl 0x831a816c
	ctx.lr = 0x825D80D8;
	sub_831A8130(ctx, base);
	// 825D80D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D80DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D80E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D80E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D80E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D80EC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825D80F0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825D80F4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825D80F8: 4881A2F1  bl 0x82df23e8
	ctx.lr = 0x825D80FC;
	sub_82DF23E8(ctx, base);
	// 825D80FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D8100: 41820014  beq 0x825d8114
	if ctx.cr[0].eq {
	pc = 0x825D8114; continue 'dispatch;
	}
	// 825D8104: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D8108: 4857F199  bl 0x82b572a0
	ctx.lr = 0x825D810C;
	sub_82B572A0(ctx, base);
	// 825D810C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8110: 48000008  b 0x825d8118
	pc = 0x825D8118; continue 'dispatch;
	// 825D8114: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D8118: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D811C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D8120: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D8124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8128: 4BFFFE61  bl 0x825d7f88
	ctx.lr = 0x825D812C;
	sub_825D7F88(ctx, base);
	// 825D812C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D8130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D8134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8138: 4BCE7EC9  bl 0x822c0000
	ctx.lr = 0x825D813C;
	sub_822C0000(ctx, base);
	// 825D813C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D8140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8144: 48BD0078  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8148 size=72
    let mut pc: u32 = 0x825D8148;
    'dispatch: loop {
        match pc {
            0x825D8148 => {
    //   block [0x825D8148..0x825D8190)
	// 825D8148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D814C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8154: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D815C: 4882663D  bl 0x82dfe798
	ctx.lr = 0x825D8160;
	sub_82DFE798(ctx, base);
	// 825D8160: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D8164: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8168: 394AE990  addi r10, r10, -0x1670
	ctx.r[10].s64 = ctx.r[10].s64 + -5744;
	// 825D816C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825D8170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8174: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D8178: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825D817C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D8180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D818C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8190 size=96
    let mut pc: u32 = 0x825D8190;
    'dispatch: loop {
        match pc {
            0x825D8190 => {
    //   block [0x825D8190..0x825D81F0)
	// 825D8190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8198: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D819C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D81A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D81A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D81A8: 396BE990  addi r11, r11, -0x1670
	ctx.r[11].s64 = ctx.r[11].s64 + -5744;
	// 825D81AC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D81B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D81B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825D81B8: 419A0010  beq cr6, 0x825d81c8
	if ctx.cr[6].eq {
	pc = 0x825D81C8; continue 'dispatch;
	}
	// 825D81BC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D81C0: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825D81C4: 48819FC5  bl 0x82df2188
	ctx.lr = 0x825D81C8;
	sub_82DF2188(ctx, base);
	// 825D81C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D81CC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825D81D0: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 825D81D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D81D8: 4881B251  bl 0x82df3428
	ctx.lr = 0x825D81DC;
	sub_82DF3428(ctx, base);
	// 825D81DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D81E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D81E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D81E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D81EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D81F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D81F0 size=76
    let mut pc: u32 = 0x825D81F0;
    'dispatch: loop {
        match pc {
            0x825D81F0 => {
    //   block [0x825D81F0..0x825D823C)
	// 825D81F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D81F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D81F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D81FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8200: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8208: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D820C: 4BFFFF85  bl 0x825d8190
	ctx.lr = 0x825D8210;
	sub_825D8190(ctx, base);
	// 825D8210: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8214: 4182000C  beq 0x825d8220
	if ctx.cr[0].eq {
	pc = 0x825D8220; continue 'dispatch;
	}
	// 825D8218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D821C: 4881A1BD  bl 0x82df23d8
	ctx.lr = 0x825D8220;
	sub_82DF23D8(ctx, base);
	// 825D8220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8224: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8228: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D822C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8230: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8240 size=144
    let mut pc: u32 = 0x825D8240;
    'dispatch: loop {
        match pc {
            0x825D8240 => {
    //   block [0x825D8240..0x825D82D0)
	// 825D8240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8244: 48BCFF25  bl 0x831a8168
	ctx.lr = 0x825D8248;
	sub_831A8130(ctx, base);
	// 825D8248: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D824C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825D8250: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8254: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D8258: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825D825C: 419A006C  beq cr6, 0x825d82c8
	if ctx.cr[6].eq {
	pc = 0x825D82C8; continue 'dispatch;
	}
	// 825D8260: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D8264: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 825D8268: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825D826C: 419A000C  beq cr6, 0x825d8278
	if ctx.cr[6].eq {
	pc = 0x825D8278; continue 'dispatch;
	}
	// 825D8270: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825D8274: 48819F15  bl 0x82df2188
	ctx.lr = 0x825D8278;
	sub_82DF2188(ctx, base);
	// 825D8278: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D827C: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825D8280: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 825D8284: 388BE998  addi r4, r11, -0x1668
	ctx.r[4].s64 = ctx.r[11].s64 + -5736;
	// 825D8288: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825D828C: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 825D8290: 48819F71  bl 0x82df2200
	ctx.lr = 0x825D8294;
	sub_82DF2200(ctx, base);
	// 825D8294: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 825D8298: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D829C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D82A0: 48BD0271  bl 0x831a8510
	ctx.lr = 0x825D82A4;
	sub_831A8510(ctx, base);
	// 825D82A4: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D82A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D82AC: 488361FD  bl 0x82e0e4a8
	ctx.lr = 0x825D82B0;
	sub_82E0E4A8(ctx, base);
	// 825D82B0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D82B4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825D82B8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825D82BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D82C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D82C4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825D82C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D82CC: 48BCFEEC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D82D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D82D0 size=20
    let mut pc: u32 = 0x825D82D0;
    'dispatch: loop {
        match pc {
            0x825D82D0 => {
    //   block [0x825D82D0..0x825D82E4)
	// 825D82D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D82D4: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825D82D8: 396BE9D4  addi r11, r11, -0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + -5676;
	// 825D82DC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D82E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D82E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D82E8 size=16
    let mut pc: u32 = 0x825D82E8;
    'dispatch: loop {
        match pc {
            0x825D82E8 => {
    //   block [0x825D82E8..0x825D82F8)
	// 825D82E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D82EC: 396BE9D4  addi r11, r11, -0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + -5676;
	// 825D82F0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D82F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D82F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D82F8 size=68
    let mut pc: u32 = 0x825D82F8;
    'dispatch: loop {
        match pc {
            0x825D82F8 => {
    //   block [0x825D82F8..0x825D833C)
	// 825D82F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D82FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8300: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8304: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D830C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D8310: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D8314: 396BE9D4  addi r11, r11, -0x162c
	ctx.r[11].s64 = ctx.r[11].s64 + -5676;
	// 825D8318: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D831C: 41820008  beq 0x825d8324
	if ctx.cr[0].eq {
	pc = 0x825D8324; continue 'dispatch;
	}
	// 825D8320: 4BCE7F49  bl 0x822c0268
	ctx.lr = 0x825D8324;
	sub_822C0268(ctx, base);
	// 825D8324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8328: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D832C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8340 size=112
    let mut pc: u32 = 0x825D8340;
    'dispatch: loop {
        match pc {
            0x825D8340 => {
    //   block [0x825D8340..0x825D83B0)
	// 825D8340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D834C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8354: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D8358: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D835C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D8360: 388B9B98  addi r4, r11, -0x6468
	ctx.r[4].s64 = ctx.r[11].s64 + -25704;
	// 825D8364: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 825D8368: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 825D836C: 4881A07D  bl 0x82df23e8
	ctx.lr = 0x825D8370;
	sub_82DF23E8(ctx, base);
	// 825D8370: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D8374: 41820010  beq 0x825d8384
	if ctx.cr[0].eq {
	pc = 0x825D8384; continue 'dispatch;
	}
	// 825D8378: 4BFFFDD1  bl 0x825d8148
	ctx.lr = 0x825D837C;
	sub_825D8148(ctx, base);
	// 825D837C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8380: 48000008  b 0x825d8388
	pc = 0x825D8388; continue 'dispatch;
	// 825D8384: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D8388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D838C: 889E0068  lbz r4, 0x68(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D8390: 488264E9  bl 0x82dfe878
	ctx.lr = 0x825D8394;
	sub_82DFE878(ctx, base);
	// 825D8394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D839C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D83A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D83A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D83A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D83AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D83B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D83B0 size=164
    let mut pc: u32 = 0x825D83B0;
    'dispatch: loop {
        match pc {
            0x825D83B0 => {
    //   block [0x825D83B0..0x825D8454)
	// 825D83B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D83B4: 48BCFDB9  bl 0x831a816c
	ctx.lr = 0x825D83B8;
	sub_831A8130(ctx, base);
	// 825D83B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D83BC: 3D60825E  lis r11, -0x7da2
	ctx.r[11].s64 = -2107768832;
	// 825D83C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D83C4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D83C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D83CC: 396B8340  addi r11, r11, -0x7cc0
	ctx.r[11].s64 = ctx.r[11].s64 + -31936;
	// 825D83D0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825D83D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D83D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D83DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D83E0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825D83E4: 48826515  bl 0x82dfe8f8
	ctx.lr = 0x825D83E8;
	sub_82DFE8F8(ctx, base);
	// 825D83E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D83EC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D83F0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825D83F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D83F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D83FC: 4882949D  bl 0x82e01898
	ctx.lr = 0x825D8400;
	sub_82E01898(ctx, base);
	// 825D8400: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8404: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D8408: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D840C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8410: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D8414: 419A0024  beq cr6, 0x825d8438
	if ctx.cr[6].eq {
	pc = 0x825D8438; continue 'dispatch;
	}
	// 825D8418: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D841C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8420: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8424: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8428: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D842C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8430: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8434: 4082FFE8  bne 0x825d841c
	if !ctx.cr[0].eq {
	pc = 0x825D841C; continue 'dispatch;
	}
	// 825D8438: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D843C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8440: 419A0008  beq cr6, 0x825d8448
	if ctx.cr[6].eq {
	pc = 0x825D8448; continue 'dispatch;
	}
	// 825D8444: 4BCE844D  bl 0x822c0890
	ctx.lr = 0x825D8448;
	sub_822C0890(ctx, base);
	// 825D8448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D844C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D8450: 48BCFD6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8458 size=108
    let mut pc: u32 = 0x825D8458;
    'dispatch: loop {
        match pc {
            0x825D8458 => {
    //   block [0x825D8458..0x825D84C4)
	// 825D8458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D845C: 48BCFD0D  bl 0x831a8168
	ctx.lr = 0x825D8460;
	sub_831A8130(ctx, base);
	// 825D8460: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8464: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D8468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D846C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D8470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8474: 388BC3DC  addi r4, r11, -0x3c24
	ctx.r[4].s64 = ctx.r[11].s64 + -15396;
	// 825D8478: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D847C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825D8480: 4881B589  bl 0x82df3a08
	ctx.lr = 0x825D8484;
	sub_82DF3A08(ctx, base);
	// 825D8484: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825D8488: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D848C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D8490: 480001D9  bl 0x825d8668
	ctx.lr = 0x825D8494;
	sub_825D8668(ctx, base);
	// 825D8494: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D8498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D849C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D84A0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825D84A4: 4BFFFF0D  bl 0x825d83b0
	ctx.lr = 0x825D84A8;
	sub_825D83B0(ctx, base);
	// 825D84A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D84AC: 4881AF7D  bl 0x82df3428
	ctx.lr = 0x825D84B0;
	sub_82DF3428(ctx, base);
	// 825D84B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D84B4: 4881AF75  bl 0x82df3428
	ctx.lr = 0x825D84B8;
	sub_82DF3428(ctx, base);
	// 825D84B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D84BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D84C0: 48BCFCF8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D84C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D84C8 size=112
    let mut pc: u32 = 0x825D84C8;
    'dispatch: loop {
        match pc {
            0x825D84C8 => {
    //   block [0x825D84C8..0x825D8538)
	// 825D84C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D84CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D84D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D84D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D84D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D84DC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D84E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D84E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D84E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D84EC: 388BC3DC  addi r4, r11, -0x3c24
	ctx.r[4].s64 = ctx.r[11].s64 + -15396;
	// 825D84F0: 4881B519  bl 0x82df3a08
	ctx.lr = 0x825D84F4;
	sub_82DF3A08(ctx, base);
	// 825D84F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D84F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D84FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D8500: 48000169  bl 0x825d8668
	ctx.lr = 0x825D8504;
	sub_825D8668(ctx, base);
	// 825D8504: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D8508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D850C: 48829F2D  bl 0x82e02438
	ctx.lr = 0x825D8510;
	sub_82E02438(ctx, base);
	// 825D8510: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D8514: 4881AF15  bl 0x82df3428
	ctx.lr = 0x825D8518;
	sub_82DF3428(ctx, base);
	// 825D8518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D851C: 4881AF0D  bl 0x82df3428
	ctx.lr = 0x825D8520;
	sub_82DF3428(ctx, base);
	// 825D8520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D852C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8538 size=156
    let mut pc: u32 = 0x825D8538;
    'dispatch: loop {
        match pc {
            0x825D8538 => {
    //   block [0x825D8538..0x825D85D4)
	// 825D8538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D853C: 48BCFC2D  bl 0x831a8168
	ctx.lr = 0x825D8540;
	sub_831A8130(ctx, base);
	// 825D8540: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8544: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825D8548: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D854C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D8550: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D8554: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D8558: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D855C: 4BFFFD75  bl 0x825d82d0
	ctx.lr = 0x825D8560;
	sub_825D82D0(ctx, base);
	// 825D8560: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D8564: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825D8568: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D856C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8570: 4BFFFEE9  bl 0x825d8458
	ctx.lr = 0x825D8574;
	sub_825D8458(ctx, base);
	// 825D8574: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D8578: 488262F1  bl 0x82dfe868
	ctx.lr = 0x825D857C;
	sub_82DFE868(ctx, base);
	// 825D857C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8580: 40820024  bne 0x825d85a4
	if !ctx.cr[0].eq {
	pc = 0x825D85A4; continue 'dispatch;
	}
	// 825D8584: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D8588: 419A001C  beq cr6, 0x825d85a4
	if ctx.cr[6].eq {
	pc = 0x825D85A4; continue 'dispatch;
	}
	// 825D858C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825D8590: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D8594: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D8598: 4BFFFCA9  bl 0x825d8240
	ctx.lr = 0x825D859C;
	sub_825D8240(ctx, base);
	// 825D859C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D85A0: 488262B9  bl 0x82dfe858
	ctx.lr = 0x825D85A4;
	sub_82DFE858(ctx, base);
	// 825D85A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D85A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D85AC: 419A0008  beq cr6, 0x825d85b4
	if ctx.cr[6].eq {
	pc = 0x825D85B4; continue 'dispatch;
	}
	// 825D85B0: 4BCE82E1  bl 0x822c0890
	ctx.lr = 0x825D85B4;
	sub_822C0890(ctx, base);
	// 825D85B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D85B8: 4BFFFD31  bl 0x825d82e8
	ctx.lr = 0x825D85BC;
	sub_825D82E8(ctx, base);
	// 825D85BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D85C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D85C4: 419A0008  beq cr6, 0x825d85cc
	if ctx.cr[6].eq {
	pc = 0x825D85CC; continue 'dispatch;
	}
	// 825D85C8: 4BCE82C9  bl 0x822c0890
	ctx.lr = 0x825D85CC;
	sub_822C0890(ctx, base);
	// 825D85CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D85D0: 48BCFBE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D85D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D85D8 size=140
    let mut pc: u32 = 0x825D85D8;
    'dispatch: loop {
        match pc {
            0x825D85D8 => {
    //   block [0x825D85D8..0x825D8664)
	// 825D85D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D85DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D85E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D85E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D85E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D85EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D85F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D85F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D85F8: 388BE9D8  addi r4, r11, -0x1628
	ctx.r[4].s64 = ctx.r[11].s64 + -5672;
	// 825D85FC: 4881B40D  bl 0x82df3a08
	ctx.lr = 0x825D8600;
	sub_82DF3A08(ctx, base);
	// 825D8600: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D8604: 3D60825E  lis r11, -0x7da2
	ctx.r[11].s64 = -2107768832;
	// 825D8608: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825D860C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D8610: 388B84C8  addi r4, r11, -0x7b38
	ctx.r[4].s64 = ctx.r[11].s64 + -31544;
	// 825D8614: 4BCF9B0D  bl 0x822d2120
	ctx.lr = 0x825D8618;
	sub_822D2120(ctx, base);
	// 825D8618: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 825D861C: 3D60825E  lis r11, -0x7da2
	ctx.r[11].s64 = -2107768832;
	// 825D8620: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D8624: 388B8538  addi r4, r11, -0x7ac8
	ctx.r[4].s64 = ctx.r[11].s64 + -31432;
	// 825D8628: 4BFC1DE1  bl 0x8259a408
	ctx.lr = 0x825D862C;
	sub_8259A408(ctx, base);
	// 825D862C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D8630: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825D8634: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825D8638: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D863C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8640: 4882ABC9  bl 0x82e03208
	ctx.lr = 0x825D8644;
	sub_82E03208(ctx, base);
	// 825D8644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8648: 4881ADE1  bl 0x82df3428
	ctx.lr = 0x825D864C;
	sub_82DF3428(ctx, base);
	// 825D864C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825D8650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8658: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D865C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8668 size=132
    let mut pc: u32 = 0x825D8668;
    'dispatch: loop {
        match pc {
            0x825D8668 => {
    //   block [0x825D8668..0x825D86EC)
	// 825D8668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D866C: 48BCFAFD  bl 0x831a8168
	ctx.lr = 0x825D8670;
	sub_831A8130(ctx, base);
	// 825D8670: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8678: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D867C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D8680: 4881AA71  bl 0x82df30f0
	ctx.lr = 0x825D8684;
	sub_82DF30F0(ctx, base);
	// 825D8684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8688: 4881ADA9  bl 0x82df3430
	ctx.lr = 0x825D868C;
	sub_82DF3430(ctx, base);
	// 825D868C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D8690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D8694: 4881AD9D  bl 0x82df3430
	ctx.lr = 0x825D8698;
	sub_82DF3430(ctx, base);
	// 825D8698: 7D7C1A14  add r11, r28, r3
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 825D869C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D86A0: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825D86A4: 48AEF43D  bl 0x830c7ae0
	ctx.lr = 0x825D86A8;
	sub_830C7AE0(ctx, base);
	// 825D86A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D86AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D86B0: 388BE9E0  addi r4, r11, -0x1620
	ctx.r[4].s64 = ctx.r[11].s64 + -5664;
	// 825D86B4: 4881AEC5  bl 0x82df3578
	ctx.lr = 0x825D86B8;
	sub_82DF3578(ctx, base);
	// 825D86B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D86BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D86C0: 4881B019  bl 0x82df36d8
	ctx.lr = 0x825D86C4;
	sub_82DF36D8(ctx, base);
	// 825D86C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D86C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D86CC: 388B9FD8  addi r4, r11, -0x6028
	ctx.r[4].s64 = ctx.r[11].s64 + -24616;
	// 825D86D0: 4881AEA9  bl 0x82df3578
	ctx.lr = 0x825D86D4;
	sub_82DF3578(ctx, base);
	// 825D86D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D86D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D86DC: 4881AFFD  bl 0x82df36d8
	ctx.lr = 0x825D86E0;
	sub_82DF36D8(ctx, base);
	// 825D86E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D86E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D86E8: 48BCFAD0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D86F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D86F0 size=24
    let mut pc: u32 = 0x825D86F0;
    'dispatch: loop {
        match pc {
            0x825D86F0 => {
    //   block [0x825D86F0..0x825D8708)
	// 825D86F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D86F4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825D86F8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D86FC: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825D8700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D8704: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8708 size=188
    let mut pc: u32 = 0x825D8708;
    'dispatch: loop {
        match pc {
            0x825D8708 => {
    //   block [0x825D8708..0x825D87C4)
	// 825D8708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D870C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D8714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D871C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D8720: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8724: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D8728: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D872C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D8730: 4BCE8209  bl 0x822c0938
	ctx.lr = 0x825D8734;
	sub_822C0938(ctx, base);
	// 825D8734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D8738: 41820028  beq 0x825d8760
	if ctx.cr[0].eq {
	pc = 0x825D8760; continue 'dispatch;
	}
	// 825D873C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D8740: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D8744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D8748: 392BE9EC  addi r9, r11, -0x1614
	ctx.r[9].s64 = ctx.r[11].s64 + -5652;
	// 825D874C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D8750: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D8754: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D8758: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D875C: 48000008  b 0x825d8764
	pc = 0x825D8764; continue 'dispatch;
	// 825D8760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8764: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D8768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D876C: 409A003C  bne cr6, 0x825d87a8
	if !ctx.cr[6].eq {
	pc = 0x825D87A8; continue 'dispatch;
	}
	// 825D8770: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D8774: 419A0014  beq cr6, 0x825d8788
	if ctx.cr[6].eq {
	pc = 0x825D8788; continue 'dispatch;
	}
	// 825D8778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D877C: 48000F75  bl 0x825d96f0
	ctx.lr = 0x825D8780;
	sub_825D96F0(ctx, base);
	// 825D8780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8784: 4BCE7AE5  bl 0x822c0268
	ctx.lr = 0x825D8788;
	sub_822C0268(ctx, base);
	// 825D8788: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D878C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D8790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8794: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D8798: 816BC3E8  lwz r11, -0x3c18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15384 as u32) ) } as u64;
	// 825D879C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D87A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D87A4: 4BCE785D  bl 0x822c0000
	ctx.lr = 0x825D87A8;
	sub_822C0000(ctx, base);
	// 825D87A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D87AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D87B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D87B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D87B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D87BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D87C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D87C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D87C8 size=64
    let mut pc: u32 = 0x825D87C8;
    'dispatch: loop {
        match pc {
            0x825D87C8 => {
    //   block [0x825D87C8..0x825D8808)
	// 825D87C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D87CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D87D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D87D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D87D8: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D87DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D87E0: 419A0014  beq cr6, 0x825d87f4
	if ctx.cr[6].eq {
	pc = 0x825D87F4; continue 'dispatch;
	}
	// 825D87E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D87E8: 48000F09  bl 0x825d96f0
	ctx.lr = 0x825D87EC;
	sub_825D96F0(ctx, base);
	// 825D87EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D87F0: 4BCE7A79  bl 0x822c0268
	ctx.lr = 0x825D87F4;
	sub_822C0268(ctx, base);
	// 825D87F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D87F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D87FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8808 size=144
    let mut pc: u32 = 0x825D8808;
    'dispatch: loop {
        match pc {
            0x825D8808 => {
    //   block [0x825D8808..0x825D8898)
	// 825D8808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D880C: 48BCF961  bl 0x831a816c
	ctx.lr = 0x825D8810;
	sub_831A8130(ctx, base);
	// 825D8810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D8818: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D881C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D8820: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D8824: 388BE9FC  addi r4, r11, -0x1604
	ctx.r[4].s64 = ctx.r[11].s64 + -5636;
	// 825D8828: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 825D882C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D8830: 4BCE7BA9  bl 0x822c03d8
	ctx.lr = 0x825D8834;
	sub_822C03D8(ctx, base);
	// 825D8834: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D8838: 4182002C  beq 0x825d8864
	if ctx.cr[0].eq {
	pc = 0x825D8864; continue 'dispatch;
	}
	// 825D883C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8840: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8844: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825D8848: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D884C: 4E800421  bctrl
	ctx.lr = 0x825D8850;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D8850: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D8854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8858: 48000E29  bl 0x825d9680
	ctx.lr = 0x825D885C;
	sub_825D9680(ctx, base);
	// 825D885C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8860: 48000008  b 0x825d8868
	pc = 0x825D8868; continue 'dispatch;
	// 825D8864: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D8868: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D886C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D8870: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D8874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8878: 4BFFFE91  bl 0x825d8708
	ctx.lr = 0x825D887C;
	sub_825D8708(ctx, base);
	// 825D887C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D8880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D8884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8888: 4BCE7779  bl 0x822c0000
	ctx.lr = 0x825D888C;
	sub_822C0000(ctx, base);
	// 825D888C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D8890: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8894: 48BCF928  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D8898 size=8
    let mut pc: u32 = 0x825D8898;
    'dispatch: loop {
        match pc {
            0x825D8898 => {
    //   block [0x825D8898..0x825D88A0)
	// 825D8898: 831A93F0  lwz r24, -0x6c10(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-27664 as u32) ) } as u64;
	// 825D889C: 8203EA84  lwz r16, -0x157c(r3)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-5500 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D88A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D88A0 size=324
    let mut pc: u32 = 0x825D88A0;
    'dispatch: loop {
        match pc {
            0x825D88A0 => {
    //   block [0x825D88A0..0x825D89E4)
	// 825D88A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D88A4: 38000000  li r0, 0
	ctx.r[0].s64 = 0;
	// 825D88A8: 90010004  stw r0, 4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(4 as u32), ctx.r[0].u32 ) };
	// 825D88AC: 48BCF8B9  bl 0x831a8164
	ctx.lr = 0x825D88B0;
	sub_831A8130(ctx, base);
	// 825D88B0: 3BE1FF50  addi r31, r1, -0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + -176;
	// 825D88B4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D88B8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825D88BC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825D88C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D88C4: 3FA08339  lis r29, -0x7cc7
	ctx.r[29].s64 = -2093416448;
	// 825D88C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D88CC: 809DB7E8  lwz r4, -0x4818(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18456 as u32) ) } as u64;
	// 825D88D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D88D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D88D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D88DC: 4E800421  bctrl
	ctx.lr = 0x825D88E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D88E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D88E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D88E8: 386BEA48  addi r3, r11, -0x15b8
	ctx.r[3].s64 = ctx.r[11].s64 + -5560;
	// 825D88EC: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825D88F0: 489F8B01  bl 0x82fd13f0
	ctx.lr = 0x825D88F4;
	sub_82FD13F0(ctx, base);
	// 825D88F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D88F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D88FC: 909F0054  stw r4, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 825D8900: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8904: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D8908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D890C: 4E800421  bctrl
	ctx.lr = 0x825D8910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D8910: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D8914: 489F8ADD  bl 0x82fd13f0
	ctx.lr = 0x825D8918;
	sub_82FD13F0(ctx, base);
	// 825D8918: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825D891C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8920: 3D408214  lis r10, -0x7dec
	ctx.r[10].s64 = -2112618496;
	// 825D8924: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825D8928: 388A930C  addi r4, r10, -0x6cf4
	ctx.r[4].s64 = ctx.r[10].s64 + -27892;
	// 825D892C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8930: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8934: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D8938: 4E800421  bctrl
	ctx.lr = 0x825D893C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D893C: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 825D8940: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 825D8944: 80BDB7E8  lwz r5, -0x4818(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18456 as u32) ) } as u64;
	// 825D8948: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D894C: 489FFAB5  bl 0x82fd8400
	ctx.lr = 0x825D8950;
	sub_82FD8400(ctx, base);
	// 825D8950: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8958: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 825D895C: 409A0008  bne cr6, 0x825d8964
	if !ctx.cr[6].eq {
	pc = 0x825D8964; continue 'dispatch;
	}
	// 825D8960: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D8964: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8968: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 825D896C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8970: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825D8974: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D8978: 4E800421  bctrl
	ctx.lr = 0x825D897C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D897C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 825D8980: 489FFC89  bl 0x82fd8608
	ctx.lr = 0x825D8984;
	sub_82FD8608(ctx, base);
	// 825D8984: 7D084378  mr r8, r8
	ctx.r[8].u64 = ctx.r[8].u64;
	// 825D8988: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 825D898C: 489F9D65  bl 0x82fd26f0
	ctx.lr = 0x825D8990;
	sub_82FD26F0(ctx, base);
	// 825D8990: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825D8994: 489F9D5D  bl 0x82fd26f0
	ctx.lr = 0x825D8998;
	sub_82FD26F0(ctx, base);
	// 825D8998: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D899C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D89A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D89A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D89A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D89AC: 4E800421  bctrl
	ctx.lr = 0x825D89B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D89B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825D89B4: 48000028  b 0x825d89dc
	pc = 0x825D89DC; continue 'dispatch;
	// 825D89B8: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D89BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D89C0: 419A0018  beq cr6, 0x825d89d8
	if ctx.cr[6].eq {
	pc = 0x825D89D8; continue 'dispatch;
	}
	// 825D89C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D89C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D89CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D89D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D89D4: 4E800421  bctrl
	ctx.lr = 0x825D89D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D89D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D89DC: 383F00B0  addi r1, r31, 0xb0
	ctx.r[1].s64 = ctx.r[31].s64 + 176;
	// 825D89E0: 48BCF7D4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D89E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D89E4 size=8
    let mut pc: u32 = 0x825D89E4;
    'dispatch: loop {
        match pc {
            0x825D89E4 => {
    //   block [0x825D89E4..0x825D89EC)
	// 825D89E4: 831A93F0  lwz r24, -0x6c10(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-27664 as u32) ) } as u64;
	// 825D89E8: 8203EA84  lwz r16, -0x157c(r3)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-5500 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D89EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D89EC size=56
    let mut pc: u32 = 0x825D89EC;
    'dispatch: loop {
        match pc {
            0x825D89EC => {
    //   block [0x825D89EC..0x825D8A24)
	// 825D89EC: 3BECFF50  addi r31, r12, -0xb0
	ctx.r[31].s64 = ctx.r[12].s64 + -176;
	// 825D89F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D89F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D89F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D89FC: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 825D8A00: 489F9CF1  bl 0x82fd26f0
	ctx.lr = 0x825D8A04;
	sub_82FD26F0(ctx, base);
	// 825D8A04: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825D8A08: 489F9CE9  bl 0x82fd26f0
	ctx.lr = 0x825D8A0C;
	sub_82FD26F0(ctx, base);
	// 825D8A0C: 3C60825E  lis r3, -0x7da2
	ctx.r[3].s64 = -2107768832;
	// 825D8A10: 386389B8  addi r3, r3, -0x7648
	ctx.r[3].s64 = ctx.r[3].s64 + -30280;
	// 825D8A14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D8A18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8A1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8A20: 48BCF794  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8A28 size=188
    let mut pc: u32 = 0x825D8A28;
    'dispatch: loop {
        match pc {
            0x825D8A28 => {
    //   block [0x825D8A28..0x825D8AE4)
	// 825D8A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8A30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D8A34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8A38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8A3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D8A40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8A44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D8A48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D8A4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D8A50: 4BCE7EE9  bl 0x822c0938
	ctx.lr = 0x825D8A54;
	sub_822C0938(ctx, base);
	// 825D8A54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D8A58: 41820028  beq 0x825d8a80
	if ctx.cr[0].eq {
	pc = 0x825D8A80; continue 'dispatch;
	}
	// 825D8A5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D8A60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D8A64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D8A68: 392BEA38  addi r9, r11, -0x15c8
	ctx.r[9].s64 = ctx.r[11].s64 + -5576;
	// 825D8A6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D8A70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D8A74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D8A78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D8A7C: 48000008  b 0x825d8a84
	pc = 0x825D8A84; continue 'dispatch;
	// 825D8A80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8A84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D8A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8A8C: 409A003C  bne cr6, 0x825d8ac8
	if !ctx.cr[6].eq {
	pc = 0x825D8AC8; continue 'dispatch;
	}
	// 825D8A90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D8A94: 419A0014  beq cr6, 0x825d8aa8
	if ctx.cr[6].eq {
	pc = 0x825D8AA8; continue 'dispatch;
	}
	// 825D8A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8A9C: 4BFFFC55  bl 0x825d86f0
	ctx.lr = 0x825D8AA0;
	sub_825D86F0(ctx, base);
	// 825D8AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8AA4: 4BCE77C5  bl 0x822c0268
	ctx.lr = 0x825D8AA8;
	sub_822C0268(ctx, base);
	// 825D8AA8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D8AAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D8AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8AB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D8AB8: 816BC42C  lwz r11, -0x3bd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15316 as u32) ) } as u64;
	// 825D8ABC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D8AC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D8AC4: 4BCE753D  bl 0x822c0000
	ctx.lr = 0x825D8AC8;
	sub_822C0000(ctx, base);
	// 825D8AC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8ACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8AD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8AD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8AD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8ADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8AE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8AE8 size=64
    let mut pc: u32 = 0x825D8AE8;
    'dispatch: loop {
        match pc {
            0x825D8AE8 => {
    //   block [0x825D8AE8..0x825D8B28)
	// 825D8AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8AEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8AF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8AF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8AF8: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D8AFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D8B00: 419A0014  beq cr6, 0x825d8b14
	if ctx.cr[6].eq {
	pc = 0x825D8B14; continue 'dispatch;
	}
	// 825D8B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8B08: 4BFFFBE9  bl 0x825d86f0
	ctx.lr = 0x825D8B0C;
	sub_825D86F0(ctx, base);
	// 825D8B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8B10: 4BCE7759  bl 0x822c0268
	ctx.lr = 0x825D8B14;
	sub_822C0268(ctx, base);
	// 825D8B14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D8B18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8B1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8B20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8B24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8B28 size=596
    let mut pc: u32 = 0x825D8B28;
    'dispatch: loop {
        match pc {
            0x825D8B28 => {
    //   block [0x825D8B28..0x825D8D7C)
	// 825D8B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8B2C: 48BCF639  bl 0x831a8164
	ctx.lr = 0x825D8B30;
	sub_831A8130(ctx, base);
	// 825D8B30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8B34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D8B38: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D8B3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D8B40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D8B44: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8B48: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8B4C: 48000A1D  bl 0x825d9568
	ctx.lr = 0x825D8B50;
	sub_825D9568(ctx, base);
	// 825D8B50: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825D8B54: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D8B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8B5C: 48000A0D  bl 0x825d9568
	ctx.lr = 0x825D8B60;
	sub_825D9568(ctx, base);
	// 825D8B60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D8B64: 4881A7A5  bl 0x82df3308
	ctx.lr = 0x825D8B68;
	sub_82DF3308(ctx, base);
	// 825D8B68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D8B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8B70: 4881A8B9  bl 0x82df3428
	ctx.lr = 0x825D8B74;
	sub_82DF3428(ctx, base);
	// 825D8B74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D8B78: 4881A8B1  bl 0x82df3428
	ctx.lr = 0x825D8B7C;
	sub_82DF3428(ctx, base);
	// 825D8B7C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8B80: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8B84: 418200D4  beq 0x825d8c58
	if ctx.cr[0].eq {
	pc = 0x825D8C58; continue 'dispatch;
	}
	// 825D8B88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D8B8C: 48000E15  bl 0x825d99a0
	ctx.lr = 0x825D8B90;
	sub_825D99A0(ctx, base);
	// 825D8B90: 480000B4  b 0x825d8c44
	pc = 0x825D8C44; continue 'dispatch;
	// 825D8B94: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D8B98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D8B9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825D8BA0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825D8BA4: 419A0024  beq cr6, 0x825d8bc8
	if ctx.cr[6].eq {
	pc = 0x825D8BC8; continue 'dispatch;
	}
	// 825D8BA8: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 825D8BAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8BB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8BB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8BB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D8BBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8BC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8BC4: 4082FFE8  bne 0x825d8bac
	if !ctx.cr[0].eq {
	pc = 0x825D8BAC; continue 'dispatch;
	}
	// 825D8BC8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8BCC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8BD4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D8BD8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D8BDC: 419A0024  beq cr6, 0x825d8c00
	if ctx.cr[6].eq {
	pc = 0x825D8C00; continue 'dispatch;
	}
	// 825D8BE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D8BE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8BE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8BEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8BF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D8BF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8BF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8BFC: 4082FFE8  bne 0x825d8be4
	if !ctx.cr[0].eq {
	pc = 0x825D8BE4; continue 'dispatch;
	}
	// 825D8C00: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D8C04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D8C08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D8C0C: 4BFFFF1D  bl 0x825d8b28
	ctx.lr = 0x825D8C10;
	sub_825D8B28(ctx, base);
	// 825D8C10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D8C14: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D8C18: 48000EA1  bl 0x825d9ab8
	ctx.lr = 0x825D8C1C;
	sub_825D9AB8(ctx, base);
	// 825D8C1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D8C20: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825D8C24: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D8C28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8C2C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D8C30: 4BCEB831  bl 0x822c4460
	ctx.lr = 0x825D8C34;
	sub_822C4460(ctx, base);
	// 825D8C34: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D8C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8C3C: 419A0008  beq cr6, 0x825d8c44
	if ctx.cr[6].eq {
	pc = 0x825D8C44; continue 'dispatch;
	}
	// 825D8C40: 4BCE7C51  bl 0x822c0890
	ctx.lr = 0x825D8C44;
	sub_822C0890(ctx, base);
	// 825D8C44: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825D8C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8C4C: 409AFF48  bne cr6, 0x825d8b94
	if !ctx.cr[6].eq {
	pc = 0x825D8B94; continue 'dispatch;
	}
	// 825D8C50: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D8C54: 480000F4  b 0x825d8d48
	pc = 0x825D8D48; continue 'dispatch;
	// 825D8C58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D8C5C: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8C60: 48000909  bl 0x825d9568
	ctx.lr = 0x825D8C64;
	sub_825D9568(ctx, base);
	// 825D8C64: 4881A54D  bl 0x82df31b0
	ctx.lr = 0x825D8C68;
	sub_82DF31B0(ctx, base);
	// 825D8C68: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D8C6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D8C70: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D8C74: 48000F5D  bl 0x825d9bd0
	ctx.lr = 0x825D8C78;
	sub_825D9BD0(ctx, base);
	// 825D8C78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D8C7C: 4881A7AD  bl 0x82df3428
	ctx.lr = 0x825D8C80;
	sub_82DF3428(ctx, base);
	// 825D8C80: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D8C84: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8C8C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825D8C90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8C94: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D8C98: 419A0078  beq cr6, 0x825d8d10
	if ctx.cr[6].eq {
	pc = 0x825D8D10; continue 'dispatch;
	}
	// 825D8C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8CA0: 419A0024  beq cr6, 0x825d8cc4
	if ctx.cr[6].eq {
	pc = 0x825D8CC4; continue 'dispatch;
	}
	// 825D8CA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D8CA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8CAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8CB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8CB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D8CB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8CBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8CC0: 4082FFE8  bne 0x825d8ca8
	if !ctx.cr[0].eq {
	pc = 0x825D8CA8; continue 'dispatch;
	}
	// 825D8CC4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D8CC8: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D8CCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8CD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D8CD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D8CD8: 419A0024  beq cr6, 0x825d8cfc
	if ctx.cr[6].eq {
	pc = 0x825D8CFC; continue 'dispatch;
	}
	// 825D8CDC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D8CE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8CE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8CE8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8CEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D8CF0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8CF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8CF8: 4082FFE8  bne 0x825d8ce0
	if !ctx.cr[0].eq {
	pc = 0x825D8CE0; continue 'dispatch;
	}
	// 825D8CFC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D8D00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D8D04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D8D08: 4BFFFE21  bl 0x825d8b28
	ctx.lr = 0x825D8D0C;
	sub_825D8B28(ctx, base);
	// 825D8D0C: 48000038  b 0x825d8d44
	pc = 0x825D8D44; continue 'dispatch;
	// 825D8D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8D14: 419A0024  beq cr6, 0x825d8d38
	if ctx.cr[6].eq {
	pc = 0x825D8D38; continue 'dispatch;
	}
	// 825D8D18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D8D1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8D20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8D24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8D28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D8D2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8D30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8D34: 4082FFE8  bne 0x825d8d1c
	if !ctx.cr[0].eq {
	pc = 0x825D8D1C; continue 'dispatch;
	}
	// 825D8D38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D8D3C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8D40: 48000669  bl 0x825d93a8
	ctx.lr = 0x825D8D44;
	sub_825D93A8(ctx, base);
	// 825D8D44: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D8D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8D4C: 419A0008  beq cr6, 0x825d8d54
	if ctx.cr[6].eq {
	pc = 0x825D8D54; continue 'dispatch;
	}
	// 825D8D50: 4BCE7B41  bl 0x822c0890
	ctx.lr = 0x825D8D54;
	sub_822C0890(ctx, base);
	// 825D8D54: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8D58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8D5C: 419A0008  beq cr6, 0x825d8d64
	if ctx.cr[6].eq {
	pc = 0x825D8D64; continue 'dispatch;
	}
	// 825D8D60: 4BCE7B31  bl 0x822c0890
	ctx.lr = 0x825D8D64;
	sub_822C0890(ctx, base);
	// 825D8D64: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D8D68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8D6C: 419A0008  beq cr6, 0x825d8d74
	if ctx.cr[6].eq {
	pc = 0x825D8D74; continue 'dispatch;
	}
	// 825D8D70: 4BCE7B21  bl 0x822c0890
	ctx.lr = 0x825D8D74;
	sub_822C0890(ctx, base);
	// 825D8D74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825D8D78: 48BCF43C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8D80 size=292
    let mut pc: u32 = 0x825D8D80;
    'dispatch: loop {
        match pc {
            0x825D8D80 => {
    //   block [0x825D8D80..0x825D8EA4)
	// 825D8D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D8D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8D90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8D94: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825D8D98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D8D9C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D8DA0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8DA4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825D8DA8: 409A0024  bne cr6, 0x825d8dcc
	if !ctx.cr[6].eq {
	pc = 0x825D8DCC; continue 'dispatch;
	}
	// 825D8DAC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8DB0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D8DB4: 419A00D8  beq cr6, 0x825d8e8c
	if ctx.cr[6].eq {
	pc = 0x825D8E8C; continue 'dispatch;
	}
	// 825D8DB8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D8DBC: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 825D8DC0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825D8DC4: 4BCEB69D  bl 0x822c4460
	ctx.lr = 0x825D8DC8;
	sub_822C4460(ctx, base);
	// 825D8DC8: 480000C4  b 0x825d8e8c
	pc = 0x825D8E8C; continue 'dispatch;
	// 825D8DCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8DD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D8DD4: 419A00B8  beq cr6, 0x825d8e8c
	if ctx.cr[6].eq {
	pc = 0x825D8E8C; continue 'dispatch;
	}
	// 825D8DD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D8DDC: 4BFFFA2D  bl 0x825d8808
	ctx.lr = 0x825D8DE0;
	sub_825D8808(ctx, base);
	// 825D8DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D8DE4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8DE8: 4BFFFA21  bl 0x825d8808
	ctx.lr = 0x825D8DEC;
	sub_825D8808(ctx, base);
	// 825D8DEC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D8DF0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D8DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8DF8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D8DFC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825D8E00: 419A0024  beq cr6, 0x825d8e24
	if ctx.cr[6].eq {
	pc = 0x825D8E24; continue 'dispatch;
	}
	// 825D8E04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D8E08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8E0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8E10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8E14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D8E18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8E1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8E20: 4082FFE8  bne 0x825d8e08
	if !ctx.cr[0].eq {
	pc = 0x825D8E08; continue 'dispatch;
	}
	// 825D8E24: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D8E28: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D8E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D8E30: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825D8E34: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825D8E38: 419A0024  beq cr6, 0x825d8e5c
	if ctx.cr[6].eq {
	pc = 0x825D8E5C; continue 'dispatch;
	}
	// 825D8E3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D8E40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D8E44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8E48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D8E4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D8E50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D8E54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D8E58: 4082FFE8  bne 0x825d8e40
	if !ctx.cr[0].eq {
	pc = 0x825D8E40; continue 'dispatch;
	}
	// 825D8E5C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825D8E60: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825D8E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D8E68: 4BFFFCC1  bl 0x825d8b28
	ctx.lr = 0x825D8E6C;
	sub_825D8B28(ctx, base);
	// 825D8E6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D8E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8E74: 419A0008  beq cr6, 0x825d8e7c
	if ctx.cr[6].eq {
	pc = 0x825D8E7C; continue 'dispatch;
	}
	// 825D8E78: 4BCE7A19  bl 0x822c0890
	ctx.lr = 0x825D8E7C;
	sub_822C0890(ctx, base);
	// 825D8E7C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D8E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8E84: 419A0008  beq cr6, 0x825d8e8c
	if ctx.cr[6].eq {
	pc = 0x825D8E8C; continue 'dispatch;
	}
	// 825D8E88: 4BCE7A09  bl 0x822c0890
	ctx.lr = 0x825D8E8C;
	sub_822C0890(ctx, base);
	// 825D8E8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D8E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8E98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8E9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8EA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8EA8 size=76
    let mut pc: u32 = 0x825D8EA8;
    'dispatch: loop {
        match pc {
            0x825D8EA8 => {
    //   block [0x825D8EA8..0x825D8EF4)
	// 825D8EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8EB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D8EB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8EC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D8EC4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D8EC8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825D8ECC: 4852CDC5  bl 0x82b05c90
	ctx.lr = 0x825D8ED0;
	sub_82B05C90(ctx, base);
	// 825D8ED0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825D8ED4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 825D8ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8EDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8EE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8EEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8EF8 size=76
    let mut pc: u32 = 0x825D8EF8;
    'dispatch: loop {
        match pc {
            0x825D8EF8 => {
    //   block [0x825D8EF8..0x825D8F44)
	// 825D8EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8F00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8F04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8F08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8F0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D8F10: 4BCE7A29  bl 0x822c0938
	ctx.lr = 0x825D8F14;
	sub_822C0938(ctx, base);
	// 825D8F14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D8F18: 4182000C  beq 0x825d8f24
	if ctx.cr[0].eq {
	pc = 0x825D8F24; continue 'dispatch;
	}
	// 825D8F1C: 4BFFFF8D  bl 0x825d8ea8
	ctx.lr = 0x825D8F20;
	sub_825D8EA8(ctx, base);
	// 825D8F20: 48000008  b 0x825d8f28
	pc = 0x825D8F28; continue 'dispatch;
	// 825D8F24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D8F28: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825D8F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8F30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D8F34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8F38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8F48 size=104
    let mut pc: u32 = 0x825D8F48;
    'dispatch: loop {
        match pc {
            0x825D8F48 => {
    //   block [0x825D8F48..0x825D8FB0)
	// 825D8F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D8F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8F58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8F5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8F60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D8F64: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D8F68: 4822D551  bl 0x828064b8
	ctx.lr = 0x825D8F6C;
	sub_828064B8(ctx, base);
	// 825D8F6C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D8F70: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D8F74: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825D8F78: 48819211  bl 0x82df2188
	ctx.lr = 0x825D8F7C;
	sub_82DF2188(ctx, base);
	// 825D8F7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D8F80: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D8F84: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825D8F88: 4182000C  beq 0x825d8f94
	if ctx.cr[0].eq {
	pc = 0x825D8F94; continue 'dispatch;
	}
	// 825D8F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8F90: 4BCE72D9  bl 0x822c0268
	ctx.lr = 0x825D8F94;
	sub_822C0268(ctx, base);
	// 825D8F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D8F98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D8F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8FA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D8FA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8FB0 size=72
    let mut pc: u32 = 0x825D8FB0;
    'dispatch: loop {
        match pc {
            0x825D8FB0 => {
    //   block [0x825D8FB0..0x825D8FF8)
	// 825D8FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D8FB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D8FBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D8FC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D8FC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8FC8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825D8FCC: 4822D4ED  bl 0x828064b8
	ctx.lr = 0x825D8FD0;
	sub_828064B8(ctx, base);
	// 825D8FD0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D8FD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D8FD8: 419A000C  beq cr6, 0x825d8fe4
	if ctx.cr[6].eq {
	pc = 0x825D8FE4; continue 'dispatch;
	}
	// 825D8FDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D8FE0: 4BFFFF69  bl 0x825d8f48
	ctx.lr = 0x825D8FE4;
	sub_825D8F48(ctx, base);
	// 825D8FE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D8FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D8FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D8FF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D8FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D8FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D8FF8 size=304
    let mut pc: u32 = 0x825D8FF8;
    'dispatch: loop {
        match pc {
            0x825D8FF8 => {
    //   block [0x825D8FF8..0x825D9128)
	// 825D8FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D8FFC: 48BCF16D  bl 0x831a8168
	ctx.lr = 0x825D9000;
	sub_831A8130(ctx, base);
	// 825D9000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9004: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825D9008: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D900C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D9010: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9014: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D901C: 409A0028  bne cr6, 0x825d9044
	if !ctx.cr[6].eq {
	pc = 0x825D9044; continue 'dispatch;
	}
	// 825D9020: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D9024: 386BEB10  addi r3, r11, -0x14f0
	ctx.r[3].s64 = ctx.r[11].s64 + -5360;
	// 825D9028: 489F83C9  bl 0x82fd13f0
	ctx.lr = 0x825D902C;
	sub_82FD13F0(ctx, base);
	// 825D902C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 825D9030: 489FF999  bl 0x82fd89c8
	ctx.lr = 0x825D9034;
	sub_82FD89C8(ctx, base);
	// 825D9034: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9038: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825D903C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D9040: 489F96B1  bl 0x82fd26f0
	ctx.lr = 0x825D9044;
	sub_82FD26F0(ctx, base);
	// 825D9044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9048: 489F83A9  bl 0x82fd13f0
	ctx.lr = 0x825D904C;
	sub_82FD13F0(ctx, base);
	// 825D904C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825D9050: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D9054: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D9058: 388BEAD8  addi r4, r11, -0x1528
	ctx.r[4].s64 = ctx.r[11].s64 + -5416;
	// 825D905C: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 825D9060: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D9064: 4BCE7375  bl 0x822c03d8
	ctx.lr = 0x825D9068;
	sub_822C03D8(ctx, base);
	// 825D9068: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D906C: 41820044  beq 0x825d90b0
	if ctx.cr[0].eq {
	pc = 0x825D90B0; continue 'dispatch;
	}
	// 825D9070: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9074: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 825D9078: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D907C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D9080: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D9084: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9088: 80EAB7E8  lwz r7, -0x4818(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18456 as u32) ) } as u64;
	// 825D908C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9090: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825D9094: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9098: 4E800421  bctrl
	ctx.lr = 0x825D909C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D909C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D90A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D90A4: 4833BDCD  bl 0x82914e70
	ctx.lr = 0x825D90A8;
	sub_82914E70(ctx, base);
	// 825D90A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D90AC: 48000008  b 0x825d90b4
	pc = 0x825D90B4; continue 'dispatch;
	// 825D90B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D90B4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D90B8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D90BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D90C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D90C4: 4BFFF965  bl 0x825d8a28
	ctx.lr = 0x825D90C8;
	sub_825D8A28(ctx, base);
	// 825D90C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D90CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D90D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D90D4: 4BCE6F2D  bl 0x822c0000
	ctx.lr = 0x825D90D8;
	sub_822C0000(ctx, base);
	// 825D90D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D90DC: 489F9615  bl 0x82fd26f0
	ctx.lr = 0x825D90E0;
	sub_82FD26F0(ctx, base);
	// 825D90E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D90E4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825D90E8: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825D90EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D90F0: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D90F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D90F8: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D90FC: 480F07D5  bl 0x826c98d0
	ctx.lr = 0x825D9100;
	sub_826C98D0(ctx, base);
	// 825D9100: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D9104: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D9108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D910C: 4852F215  bl 0x82b08320
	ctx.lr = 0x825D9110;
	sub_82B08320(ctx, base);
	// 825D9110: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825D9114: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9118: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D911C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825D9120: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D9124: 48BCF094  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9128 size=388
    let mut pc: u32 = 0x825D9128;
    'dispatch: loop {
        match pc {
            0x825D9128 => {
    //   block [0x825D9128..0x825D92AC)
	// 825D9128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D912C: 48BCF03D  bl 0x831a8168
	ctx.lr = 0x825D9130;
	sub_831A8130(ctx, base);
	// 825D9130: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9134: 3FE08339  lis r31, -0x7cc7
	ctx.r[31].s64 = -2093416448;
	// 825D9138: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D913C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D9140: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825D9144: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D9148: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825D914C: 811FB7E8  lwz r8, -0x4818(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-18456 as u32) ) } as u64;
	// 825D9150: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825D9154: 38CBA18C  addi r6, r11, -0x5e74
	ctx.r[6].s64 = ctx.r[11].s64 + -24180;
	// 825D9158: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D915C: 489FA8ED  bl 0x82fd3a48
	ctx.lr = 0x825D9160;
	sub_82FD3A48(ctx, base);
	// 825D9160: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D9164: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D9168: 80BFB7E8  lwz r5, -0x4818(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-18456 as u32) ) } as u64;
	// 825D916C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D9170: 489FE859  bl 0x82fd79c8
	ctx.lr = 0x825D9174;
	sub_82FD79C8(ctx, base);
	// 825D9174: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D9178: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D917C: 489FB50D  bl 0x82fd4688
	ctx.lr = 0x825D9180;
	sub_82FD4688(ctx, base);
	// 825D9180: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D9184: 489FB2A5  bl 0x82fd4428
	ctx.lr = 0x825D9188;
	sub_82FD4428(ctx, base);
	// 825D9188: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D918C: 489FB1F5  bl 0x82fd4380
	ctx.lr = 0x825D9190;
	sub_82FD4380(ctx, base);
	// 825D9190: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D9194: 40820030  bne 0x825d91c4
	if !ctx.cr[0].eq {
	pc = 0x825D91C4; continue 'dispatch;
	}
	// 825D9198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D919C: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 825D91A0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D91A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D91A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D91AC: 4BFFF87D  bl 0x825d8a28
	ctx.lr = 0x825D91B0;
	sub_825D8A28(ctx, base);
	// 825D91B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D91B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D91B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D91BC: 4BCE6E45  bl 0x822c0000
	ctx.lr = 0x825D91C0;
	sub_822C0000(ctx, base);
	// 825D91C0: 480000D0  b 0x825d9290
	pc = 0x825D9290; continue 'dispatch;
	// 825D91C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D91C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D91CC: 388BEAD8  addi r4, r11, -0x1528
	ctx.r[4].s64 = ctx.r[11].s64 + -5416;
	// 825D91D0: 38A000DF  li r5, 0xdf
	ctx.r[5].s64 = 223;
	// 825D91D4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D91D8: 4BCE7201  bl 0x822c03d8
	ctx.lr = 0x825D91DC;
	sub_822C03D8(ctx, base);
	// 825D91DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D91E0: 41820014  beq 0x825d91f4
	if ctx.cr[0].eq {
	pc = 0x825D91F4; continue 'dispatch;
	}
	// 825D91E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D91E8: 4833BC89  bl 0x82914e70
	ctx.lr = 0x825D91EC;
	sub_82914E70(ctx, base);
	// 825D91EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D91F0: 48000008  b 0x825d91f8
	pc = 0x825D91F8; continue 'dispatch;
	// 825D91F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D91F8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825D91FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9200: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D9204: 4BFFF825  bl 0x825d8a28
	ctx.lr = 0x825D9208;
	sub_825D8A28(ctx, base);
	// 825D9208: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D920C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9210: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D9214: 4BCE6DED  bl 0x822c0000
	ctx.lr = 0x825D9218;
	sub_822C0000(ctx, base);
	// 825D9218: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D921C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825D9220: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825D9224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9228: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D922C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D9230: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9234: 480F069D  bl 0x826c98d0
	ctx.lr = 0x825D9238;
	sub_826C98D0(ctx, base);
	// 825D9238: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D923C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D9240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9244: 4852F0DD  bl 0x82b08320
	ctx.lr = 0x825D9248;
	sub_82B08320(ctx, base);
	// 825D9248: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D924C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D9250: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825D9254: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D925C: 938A0000  stw r28, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825D9260: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D9264: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825D9268: 419A0028  beq cr6, 0x825d9290
	if ctx.cr[6].eq {
	pc = 0x825D9290; continue 'dispatch;
	}
	// 825D926C: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 825D9270: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D9274: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D9278: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D927C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9280: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D9284: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D9288: 4082FFE8  bne 0x825d9270
	if !ctx.cr[0].eq {
	pc = 0x825D9270; continue 'dispatch;
	}
	// 825D928C: 4BCE7605  bl 0x822c0890
	ctx.lr = 0x825D9290;
	sub_822C0890(ctx, base);
	// 825D9290: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D9294: 489FE7B5  bl 0x82fd7a48
	ctx.lr = 0x825D9298;
	sub_82FD7A48(ctx, base);
	// 825D9298: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D929C: 489FA80D  bl 0x82fd3aa8
	ctx.lr = 0x825D92A0;
	sub_82FD3AA8(ctx, base);
	// 825D92A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D92A4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 825D92A8: 48BCEF10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D92B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D92B0 size=16
    let mut pc: u32 = 0x825D92B0;
    'dispatch: loop {
        match pc {
            0x825D92B0 => {
    //   block [0x825D92B0..0x825D92C0)
	// 825D92B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D92B4: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825D92B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D92BC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D92C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D92C0 size=52
    let mut pc: u32 = 0x825D92C0;
    'dispatch: loop {
        match pc {
            0x825D92C0 => {
    //   block [0x825D92C0..0x825D92F4)
	// 825D92C0: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D92C4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D92C8: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D92CC: 550807FE  clrlwi r8, r8, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 825D92D0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D92D4: 41990008  bgt cr6, 0x825d92dc
	if ctx.cr[6].gt {
	pc = 0x825D92DC; continue 'dispatch;
	}
	// 825D92D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825D92DC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D92E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D92E4: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D92E8: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D92EC: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 825D92F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D92F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D92F8 size=40
    let mut pc: u32 = 0x825D92F8;
    'dispatch: loop {
        match pc {
            0x825D92F8 => {
    //   block [0x825D92F8..0x825D9320)
	// 825D92F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D92FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9300: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9304: 4BFFFFAD  bl 0x825d92b0
	ctx.lr = 0x825D9308;
	sub_825D92B0(ctx, base);
	// 825D9308: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D930C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9310: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D9314: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9318: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D931C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9320 size=132
    let mut pc: u32 = 0x825D9320;
    'dispatch: loop {
        match pc {
            0x825D9320 => {
    //   block [0x825D9320..0x825D93A4)
	// 825D9320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D932C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9338: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D933C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D9340: 489F80B1  bl 0x82fd13f0
	ctx.lr = 0x825D9344;
	sub_82FD13F0(ctx, base);
	// 825D9344: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825D9348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D934C: 489F80A5  bl 0x82fd13f0
	ctx.lr = 0x825D9350;
	sub_82FD13F0(ctx, base);
	// 825D9350: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D9354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9358: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 825D935C: 4BFFFF55  bl 0x825d92b0
	ctx.lr = 0x825D9360;
	sub_825D92B0(ctx, base);
	// 825D9360: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9364: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9368: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D936C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9370: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 825D9374: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9378: 4E800421  bctrl
	ctx.lr = 0x825D937C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D937C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9380: 489F9371  bl 0x82fd26f0
	ctx.lr = 0x825D9384;
	sub_82FD26F0(ctx, base);
	// 825D9384: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D9388: 489F9369  bl 0x82fd26f0
	ctx.lr = 0x825D938C;
	sub_82FD26F0(ctx, base);
	// 825D938C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D9390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9398: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D939C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D93A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D93A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D93A8 size=164
    let mut pc: u32 = 0x825D93A8;
    'dispatch: loop {
        match pc {
            0x825D93A8 => {
    //   block [0x825D93A8..0x825D944C)
	// 825D93A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D93AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D93B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D93B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D93B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D93BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D93C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D93C4: 4BFFFEED  bl 0x825d92b0
	ctx.lr = 0x825D93C8;
	sub_825D92B0(ctx, base);
	// 825D93C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D93CC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D93D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D93D4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D93D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D93DC: 4E800421  bctrl
	ctx.lr = 0x825D93E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D93E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D93E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D93E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825D93EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D93F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D93F4: 816A0038  lwz r11, 0x38(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 825D93F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D93FC: 4E800421  bctrl
	ctx.lr = 0x825D9400;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9400: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9408: 4BFFFEA9  bl 0x825d92b0
	ctx.lr = 0x825D940C;
	sub_825D92B0(ctx, base);
	// 825D940C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9410: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9418: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825D941C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9420: 4E800421  bctrl
	ctx.lr = 0x825D9424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9424: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D942C: 419A0008  beq cr6, 0x825d9434
	if ctx.cr[6].eq {
	pc = 0x825D9434; continue 'dispatch;
	}
	// 825D9430: 4BCE7461  bl 0x822c0890
	ctx.lr = 0x825D9434;
	sub_822C0890(ctx, base);
	// 825D9434: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D9438: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D943C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9440: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D9444: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9448: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9450 size=176
    let mut pc: u32 = 0x825D9450;
    'dispatch: loop {
        match pc {
            0x825D9450 => {
    //   block [0x825D9450..0x825D9500)
	// 825D9450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D945C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9468: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 825D946C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D9470: 489F7F81  bl 0x82fd13f0
	ctx.lr = 0x825D9474;
	sub_82FD13F0(ctx, base);
	// 825D9474: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D947C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 825D9480: 4BFFFE31  bl 0x825d92b0
	ctx.lr = 0x825D9484;
	sub_825D92B0(ctx, base);
	// 825D9484: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9488: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D948C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9490: 816B00A0  lwz r11, 0xa0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 825D9494: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9498: 4E800421  bctrl
	ctx.lr = 0x825D949C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D949C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D94A0: 4BFFFE11  bl 0x825d92b0
	ctx.lr = 0x825D94A4;
	sub_825D92B0(ctx, base);
	// 825D94A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D94A8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D94AC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D94B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D94B4: 816B00A0  lwz r11, 0xa0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 825D94B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D94BC: 4E800421  bctrl
	ctx.lr = 0x825D94C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D94C0: 489F7EE9  bl 0x82fd13a8
	ctx.lr = 0x825D94C4;
	sub_82FD13A8(ctx, base);
	// 825D94C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D94C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D94CC: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 825D94D0: 4881A539  bl 0x82df3a08
	ctx.lr = 0x825D94D4;
	sub_82DF3A08(ctx, base);
	// 825D94D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D94D8: 489F9219  bl 0x82fd26f0
	ctx.lr = 0x825D94DC;
	sub_82FD26F0(ctx, base);
	// 825D94DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D94E0: 489F9211  bl 0x82fd26f0
	ctx.lr = 0x825D94E4;
	sub_82FD26F0(ctx, base);
	// 825D94E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D94E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D94EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D94F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D94F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D94F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D94FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9500 size=104
    let mut pc: u32 = 0x825D9500;
    'dispatch: loop {
        match pc {
            0x825D9500 => {
    //   block [0x825D9500..0x825D9568)
	// 825D9500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9508: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D950C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9514: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D9518: 489F7ED9  bl 0x82fd13f0
	ctx.lr = 0x825D951C;
	sub_82FD13F0(ctx, base);
	// 825D951C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9524: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 825D9528: 4BFFFD89  bl 0x825d92b0
	ctx.lr = 0x825D952C;
	sub_825D92B0(ctx, base);
	// 825D952C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9530: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9538: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 825D953C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9540: 4E800421  bctrl
	ctx.lr = 0x825D9544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D954C: 489F91A5  bl 0x82fd26f0
	ctx.lr = 0x825D9550;
	sub_82FD26F0(ctx, base);
	// 825D9550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D9558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D955C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9568 size=104
    let mut pc: u32 = 0x825D9568;
    'dispatch: loop {
        match pc {
            0x825D9568 => {
    //   block [0x825D9568..0x825D95D0)
	// 825D9568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D956C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9574: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D957C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D9580: 4BFFFD31  bl 0x825d92b0
	ctx.lr = 0x825D9584;
	sub_825D92B0(ctx, base);
	// 825D9584: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9588: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D958C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9590: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9594: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9598: 4E800421  bctrl
	ctx.lr = 0x825D959C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D959C: 489F7E0D  bl 0x82fd13a8
	ctx.lr = 0x825D95A0;
	sub_82FD13A8(ctx, base);
	// 825D95A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D95A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D95A8: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 825D95AC: 4881A45D  bl 0x82df3a08
	ctx.lr = 0x825D95B0;
	sub_82DF3A08(ctx, base);
	// 825D95B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D95B4: 489F913D  bl 0x82fd26f0
	ctx.lr = 0x825D95B8;
	sub_82FD26F0(ctx, base);
	// 825D95B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D95BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D95C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D95C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D95C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D95CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D95D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D95D0 size=172
    let mut pc: u32 = 0x825D95D0;
    'dispatch: loop {
        match pc {
            0x825D95D0 => {
    //   block [0x825D95D0..0x825D967C)
	// 825D95D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D95D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D95D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D95DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D95E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D95E4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D95E8: 4BFFFCC9  bl 0x825d92b0
	ctx.lr = 0x825D95EC;
	sub_825D92B0(ctx, base);
	// 825D95EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D95F0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D95F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D95F8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D95FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9600: 4E800421  bctrl
	ctx.lr = 0x825D9604;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D9608: 4182004C  beq 0x825d9654
	if ctx.cr[0].eq {
	pc = 0x825D9654; continue 'dispatch;
	}
	// 825D960C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9610: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9614: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9618: 4E800421  bctrl
	ctx.lr = 0x825D961C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D961C: 489F7D8D  bl 0x82fd13a8
	ctx.lr = 0x825D9620;
	sub_82FD13A8(ctx, base);
	// 825D9620: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825D9624: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 825D9628: 4182002C  beq 0x825d9654
	if ctx.cr[0].eq {
	pc = 0x825D9654; continue 'dispatch;
	}
	// 825D962C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9630: 4881A3D9  bl 0x82df3a08
	ctx.lr = 0x825D9634;
	sub_82DF3A08(ctx, base);
	// 825D9634: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D9638: 489F90B9  bl 0x82fd26f0
	ctx.lr = 0x825D963C;
	sub_82FD26F0(ctx, base);
	// 825D963C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D9640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9644: 4881A5BD  bl 0x82df3c00
	ctx.lr = 0x825D9648;
	sub_82DF3C00(ctx, base);
	// 825D9648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D964C: 48819DDD  bl 0x82df3428
	ctx.lr = 0x825D9650;
	sub_82DF3428(ctx, base);
	// 825D9650: 48000014  b 0x825d9664
	pc = 0x825D9664; continue 'dispatch;
	// 825D9654: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D9658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D965C: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 825D9660: 4881A3A9  bl 0x82df3a08
	ctx.lr = 0x825D9664;
	sub_82DF3A08(ctx, base);
	// 825D9664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9668: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D966C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9674: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9680 size=108
    let mut pc: u32 = 0x825D9680;
    'dispatch: loop {
        match pc {
            0x825D9680 => {
    //   block [0x825D9680..0x825D96EC)
	// 825D9680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9684: 48BCEAE9  bl 0x831a816c
	ctx.lr = 0x825D9688;
	sub_831A8130(ctx, base);
	// 825D9688: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D968C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D9690: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D9694: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D9698: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D969C: 388BEB14  addi r4, r11, -0x14ec
	ctx.r[4].s64 = ctx.r[11].s64 + -5356;
	// 825D96A0: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 825D96A4: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 825D96A8: 48818D41  bl 0x82df23e8
	ctx.lr = 0x825D96AC;
	sub_82DF23E8(ctx, base);
	// 825D96AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D96B0: 41820024  beq 0x825d96d4
	if ctx.cr[0].eq {
	pc = 0x825D96D4; continue 'dispatch;
	}
	// 825D96B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D96B8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825D96BC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825D96C0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825D96C4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825D96C8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825D96CC: 481C252D  bl 0x8279bbf8
	ctx.lr = 0x825D96D0;
	sub_8279BBF8(ctx, base);
	// 825D96D0: 48000008  b 0x825d96d8
	pc = 0x825D96D8; continue 'dispatch;
	// 825D96D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D96D8: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D96DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D96E0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D96E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D96E8: 48BCEAD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D96F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D96F0 size=72
    let mut pc: u32 = 0x825D96F0;
    'dispatch: loop {
        match pc {
            0x825D96F0 => {
    //   block [0x825D96F0..0x825D9738)
	// 825D96F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D96F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D96F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D96FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9700: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9704: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D9708: 419A001C  beq cr6, 0x825d9724
	if ctx.cr[6].eq {
	pc = 0x825D9724; continue 'dispatch;
	}
	// 825D970C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825D9710: 4BFD6A01  bl 0x825b0110
	ctx.lr = 0x825D9714;
	sub_825B0110(ctx, base);
	// 825D9714: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D9718: 4BFE6989  bl 0x825c00a0
	ctx.lr = 0x825D971C;
	sub_825C00A0(ctx, base);
	// 825D971C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9720: 48818CB9  bl 0x82df23d8
	ctx.lr = 0x825D9724;
	sub_82DF23D8(ctx, base);
	// 825D9724: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D9728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D972C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9738 size=112
    let mut pc: u32 = 0x825D9738;
    'dispatch: loop {
        match pc {
            0x825D9738 => {
    //   block [0x825D9738..0x825D97A8)
	// 825D9738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D973C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D9744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D974C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D9750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9754: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825D9758: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D975C: 4BFFEFAD  bl 0x825d8708
	ctx.lr = 0x825D9760;
	sub_825D8708(ctx, base);
	// 825D9760: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D9764: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9768: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D976C: 4BCE6895  bl 0x822c0000
	ctx.lr = 0x825D9770;
	sub_822C0000(ctx, base);
	// 825D9770: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9774: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D9778: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D977C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D9784: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D9788: 419A0008  beq cr6, 0x825d9790
	if ctx.cr[6].eq {
	pc = 0x825D9790; continue 'dispatch;
	}
	// 825D978C: 4BCE7105  bl 0x822c0890
	ctx.lr = 0x825D9790;
	sub_822C0890(ctx, base);
	// 825D9790: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D9794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D979C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D97A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D97A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D97A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D97A8 size=348
    let mut pc: u32 = 0x825D97A8;
    'dispatch: loop {
        match pc {
            0x825D97A8 => {
    //   block [0x825D97A8..0x825D9904)
	// 825D97A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D97AC: 48BCE9BD  bl 0x831a8168
	ctx.lr = 0x825D97B0;
	sub_831A8130(ctx, base);
	// 825D97B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D97B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D97B8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D97BC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825D97C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D97C4: 4881A245  bl 0x82df3a08
	ctx.lr = 0x825D97C8;
	sub_82DF3A08(ctx, base);
	// 825D97C8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825D97CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D97D0: 4881A901  bl 0x82df40d0
	ctx.lr = 0x825D97D4;
	sub_82DF40D0(ctx, base);
	// 825D97D4: 3FE08212  lis r31, -0x7dee
	ctx.r[31].s64 = -2112749568;
	// 825D97D8: 817FB230  lwz r11, -0x4dd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825D97DC: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D97E0: 419A0044  beq cr6, 0x825d9824
	if ctx.cr[6].eq {
	pc = 0x825D9824; continue 'dispatch;
	}
	// 825D97E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D97E8: 3BCBEB48  addi r30, r11, -0x14b8
	ctx.r[30].s64 = ctx.r[11].s64 + -5304;
	// 825D97EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D97F0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825D97F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825D97F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D97FC: 4881A9C5  bl 0x82df41c0
	ctx.lr = 0x825D9800;
	sub_82DF41C0(ctx, base);
	// 825D9800: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9808: 4881A3C9  bl 0x82df3bd0
	ctx.lr = 0x825D980C;
	sub_82DF3BD0(ctx, base);
	// 825D980C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825D9810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9814: 4881A8BD  bl 0x82df40d0
	ctx.lr = 0x825D9818;
	sub_82DF40D0(ctx, base);
	// 825D9818: 817FB230  lwz r11, -0x4dd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825D981C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825D9820: 409AFFCC  bne cr6, 0x825d97ec
	if !ctx.cr[6].eq {
	pc = 0x825D97EC; continue 'dispatch;
	}
	// 825D9824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9828: 48819989  bl 0x82df31b0
	ctx.lr = 0x825D982C;
	sub_82DF31B0(ctx, base);
	// 825D982C: 489F7BC5  bl 0x82fd13f0
	ctx.lr = 0x825D9830;
	sub_82FD13F0(ctx, base);
	// 825D9830: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 825D9834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9838: 4BFFFA79  bl 0x825d92b0
	ctx.lr = 0x825D983C;
	sub_825D92B0(ctx, base);
	// 825D983C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9840: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9844: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9848: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D984C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9850: 4E800421  bctrl
	ctx.lr = 0x825D9854;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9854: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9858: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D985C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9864: 4E800421  bctrl
	ctx.lr = 0x825D9868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9868: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D986C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9870: 4BFFFA41  bl 0x825d92b0
	ctx.lr = 0x825D9874;
	sub_825D92B0(ctx, base);
	// 825D9874: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9878: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D987C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9884: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825D9888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D988C: 4E800421  bctrl
	ctx.lr = 0x825D9890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9890: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D9894: 489F8E5D  bl 0x82fd26f0
	ctx.lr = 0x825D9898;
	sub_82FD26F0(ctx, base);
	// 825D9898: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D989C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D98A0: 388BEB14  addi r4, r11, -0x14ec
	ctx.r[4].s64 = ctx.r[11].s64 + -5356;
	// 825D98A4: 38A000A6  li r5, 0xa6
	ctx.r[5].s64 = 166;
	// 825D98A8: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D98AC: 4BCE6B2D  bl 0x822c03d8
	ctx.lr = 0x825D98B0;
	sub_822C03D8(ctx, base);
	// 825D98B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D98B4: 41820014  beq 0x825d98c8
	if ctx.cr[0].eq {
	pc = 0x825D98C8; continue 'dispatch;
	}
	// 825D98B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D98BC: 4BFFFDC5  bl 0x825d9680
	ctx.lr = 0x825D98C0;
	sub_825D9680(ctx, base);
	// 825D98C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D98C4: 48000008  b 0x825d98cc
	pc = 0x825D98CC; continue 'dispatch;
	// 825D98C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D98CC: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D98D0: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825D98D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D98D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D98DC: 4BFFEE2D  bl 0x825d8708
	ctx.lr = 0x825D98E0;
	sub_825D8708(ctx, base);
	// 825D98E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D98E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D98E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D98EC: 4BCE6715  bl 0x822c0000
	ctx.lr = 0x825D98F0;
	sub_822C0000(ctx, base);
	// 825D98F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D98F4: 48819B35  bl 0x82df3428
	ctx.lr = 0x825D98F8;
	sub_82DF3428(ctx, base);
	// 825D98F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D98FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D9900: 48BCE8B8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9908 size=148
    let mut pc: u32 = 0x825D9908;
    'dispatch: loop {
        match pc {
            0x825D9908 => {
    //   block [0x825D9908..0x825D999C)
	// 825D9908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D990C: 48BCE861  bl 0x831a816c
	ctx.lr = 0x825D9910;
	sub_831A8130(ctx, base);
	// 825D9910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9914: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D9918: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D991C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825D9920: 4BFFFE89  bl 0x825d97a8
	ctx.lr = 0x825D9924;
	sub_825D97A8(ctx, base);
	// 825D9924: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9928: 489F7AC9  bl 0x82fd13f0
	ctx.lr = 0x825D992C;
	sub_82FD13F0(ctx, base);
	// 825D992C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825D9930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9934: 4BFFF97D  bl 0x825d92b0
	ctx.lr = 0x825D9938;
	sub_825D92B0(ctx, base);
	// 825D9938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D993C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9940: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9944: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825D9948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D994C: 4E800421  bctrl
	ctx.lr = 0x825D9950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9950: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9954: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9958: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D995C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9960: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9964: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D9968: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D996C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9970: 4E800421  bctrl
	ctx.lr = 0x825D9974;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9978: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825D997C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9984: 4E800421  bctrl
	ctx.lr = 0x825D9988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D998C: 489F8D65  bl 0x82fd26f0
	ctx.lr = 0x825D9990;
	sub_82FD26F0(ctx, base);
	// 825D9990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D9994: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D9998: 48BCE824  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D99A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D99A0 size=280
    let mut pc: u32 = 0x825D99A0;
    'dispatch: loop {
        match pc {
            0x825D99A0 => {
    //   block [0x825D99A0..0x825D9AB8)
	// 825D99A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D99A4: 48BCE7C9  bl 0x831a816c
	ctx.lr = 0x825D99A8;
	sub_831A8130(ctx, base);
	// 825D99A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D99AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D99B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D99B4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D99B8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825D99BC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825D99C0: 4BFFF8F1  bl 0x825d92b0
	ctx.lr = 0x825D99C4;
	sub_825D92B0(ctx, base);
	// 825D99C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D99C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D99CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D99D0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D99D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D99D8: 4E800421  bctrl
	ctx.lr = 0x825D99DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D99DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D99E0: 41820048  beq 0x825d9a28
	if ctx.cr[0].eq {
	pc = 0x825D9A28; continue 'dispatch;
	}
	// 825D99E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D99E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D99EC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D99F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D99F4: 4E800421  bctrl
	ctx.lr = 0x825D99F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D99F8: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 825D99FC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825D9A00: 419A0020  beq cr6, 0x825d9a20
	if ctx.cr[6].eq {
	pc = 0x825D9A20; continue 'dispatch;
	}
	// 825D9A04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9A0C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9A10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9A14: 4E800421  bctrl
	ctx.lr = 0x825D9A18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9A18: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D9A1C: 4082FFC8  bne 0x825d99e4
	if !ctx.cr[0].eq {
	pc = 0x825D99E4; continue 'dispatch;
	}
	// 825D9A20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D9A24: 409A0010  bne cr6, 0x825d9a34
	if !ctx.cr[6].eq {
	pc = 0x825D9A34; continue 'dispatch;
	}
	// 825D9A28: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D9A2C: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D9A30: 4800007C  b 0x825d9aac
	pc = 0x825D9AAC; continue 'dispatch;
	// 825D9A34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D9A38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D9A3C: 388BEB14  addi r4, r11, -0x14ec
	ctx.r[4].s64 = ctx.r[11].s64 + -5356;
	// 825D9A40: 38A0015F  li r5, 0x15f
	ctx.r[5].s64 = 351;
	// 825D9A44: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D9A48: 4BCE6991  bl 0x822c03d8
	ctx.lr = 0x825D9A4C;
	sub_822C03D8(ctx, base);
	// 825D9A4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D9A50: 41820014  beq 0x825d9a64
	if ctx.cr[0].eq {
	pc = 0x825D9A64; continue 'dispatch;
	}
	// 825D9A54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9A58: 4BFFFC29  bl 0x825d9680
	ctx.lr = 0x825D9A5C;
	sub_825D9680(ctx, base);
	// 825D9A5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9A60: 48000008  b 0x825d9a68
	pc = 0x825D9A68; continue 'dispatch;
	// 825D9A64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D9A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9A6C: 4BFFFCCD  bl 0x825d9738
	ctx.lr = 0x825D9A70;
	sub_825D9738(ctx, base);
	// 825D9A70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9A74: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D9A78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D9A7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D9A80: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825D9A84: 419A0028  beq cr6, 0x825d9aac
	if ctx.cr[6].eq {
	pc = 0x825D9AAC; continue 'dispatch;
	}
	// 825D9A88: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 825D9A8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D9A90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D9A94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D9A98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9A9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D9AA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D9AA4: 4082FFE8  bne 0x825d9a8c
	if !ctx.cr[0].eq {
	pc = 0x825D9A8C; continue 'dispatch;
	}
	// 825D9AA8: 4BCE6DE9  bl 0x822c0890
	ctx.lr = 0x825D9AAC;
	sub_822C0890(ctx, base);
	// 825D9AAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D9AB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D9AB4: 48BCE708  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9AB8 size=280
    let mut pc: u32 = 0x825D9AB8;
    'dispatch: loop {
        match pc {
            0x825D9AB8 => {
    //   block [0x825D9AB8..0x825D9BD0)
	// 825D9AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9ABC: 48BCE6B1  bl 0x831a816c
	ctx.lr = 0x825D9AC0;
	sub_831A8130(ctx, base);
	// 825D9AC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9AC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D9AC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D9ACC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825D9AD0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825D9AD4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825D9AD8: 4BFFF7D9  bl 0x825d92b0
	ctx.lr = 0x825D9ADC;
	sub_825D92B0(ctx, base);
	// 825D9ADC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9AE0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9AE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9AE8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9AEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9AF0: 4E800421  bctrl
	ctx.lr = 0x825D9AF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9AF4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D9AF8: 41820048  beq 0x825d9b40
	if ctx.cr[0].eq {
	pc = 0x825D9B40; continue 'dispatch;
	}
	// 825D9AFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9B04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D9B08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9B0C: 4E800421  bctrl
	ctx.lr = 0x825D9B10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9B10: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 825D9B14: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825D9B18: 419A0020  beq cr6, 0x825d9b38
	if ctx.cr[6].eq {
	pc = 0x825D9B38; continue 'dispatch;
	}
	// 825D9B1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9B24: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9B28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9B2C: 4E800421  bctrl
	ctx.lr = 0x825D9B30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9B30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D9B34: 4082FFC8  bne 0x825d9afc
	if !ctx.cr[0].eq {
	pc = 0x825D9AFC; continue 'dispatch;
	}
	// 825D9B38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D9B3C: 409A0010  bne cr6, 0x825d9b4c
	if !ctx.cr[6].eq {
	pc = 0x825D9B4C; continue 'dispatch;
	}
	// 825D9B40: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D9B44: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D9B48: 4800007C  b 0x825d9bc4
	pc = 0x825D9BC4; continue 'dispatch;
	// 825D9B4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D9B50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D9B54: 388BEB14  addi r4, r11, -0x14ec
	ctx.r[4].s64 = ctx.r[11].s64 + -5356;
	// 825D9B58: 38A0017A  li r5, 0x17a
	ctx.r[5].s64 = 378;
	// 825D9B5C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D9B60: 4BCE6879  bl 0x822c03d8
	ctx.lr = 0x825D9B64;
	sub_822C03D8(ctx, base);
	// 825D9B64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D9B68: 41820014  beq 0x825d9b7c
	if ctx.cr[0].eq {
	pc = 0x825D9B7C; continue 'dispatch;
	}
	// 825D9B6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9B70: 4BFFFB11  bl 0x825d9680
	ctx.lr = 0x825D9B74;
	sub_825D9680(ctx, base);
	// 825D9B74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9B78: 48000008  b 0x825d9b80
	pc = 0x825D9B80; continue 'dispatch;
	// 825D9B7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D9B80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9B84: 4BFFFBB5  bl 0x825d9738
	ctx.lr = 0x825D9B88;
	sub_825D9738(ctx, base);
	// 825D9B88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9B8C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D9B90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D9B94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D9B98: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825D9B9C: 419A0028  beq cr6, 0x825d9bc4
	if ctx.cr[6].eq {
	pc = 0x825D9BC4; continue 'dispatch;
	}
	// 825D9BA0: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 825D9BA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D9BA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D9BAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D9BB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D9BB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D9BB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D9BBC: 4082FFE8  bne 0x825d9ba4
	if !ctx.cr[0].eq {
	pc = 0x825D9BA4; continue 'dispatch;
	}
	// 825D9BC0: 4BCE6CD1  bl 0x822c0890
	ctx.lr = 0x825D9BC4;
	sub_822C0890(ctx, base);
	// 825D9BC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D9BC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D9BCC: 48BCE5F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9BD0 size=224
    let mut pc: u32 = 0x825D9BD0;
    'dispatch: loop {
        match pc {
            0x825D9BD0 => {
    //   block [0x825D9BD0..0x825D9CB0)
	// 825D9BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9BD4: 48BCE599  bl 0x831a816c
	ctx.lr = 0x825D9BD8;
	sub_831A8130(ctx, base);
	// 825D9BD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9BDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D9BE0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 825D9BE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D9BE8: 489F7809  bl 0x82fd13f0
	ctx.lr = 0x825D9BEC;
	sub_82FD13F0(ctx, base);
	// 825D9BEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D9BF0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825D9BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9BF8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D9BFC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825D9C00: 4BFFF6B1  bl 0x825d92b0
	ctx.lr = 0x825D9C04;
	sub_825D92B0(ctx, base);
	// 825D9C04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9C08: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9C0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9C10: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825D9C14: 48000038  b 0x825d9c4c
	pc = 0x825D9C4C; continue 'dispatch;
	// 825D9C18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9C20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9C24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9C28: 4E800421  bctrl
	ctx.lr = 0x825D9C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9C30: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9C34: 489F7D95  bl 0x82fd19c8
	ctx.lr = 0x825D9C38;
	sub_82FD19C8(ctx, base);
	// 825D9C38: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825D9C3C: 41820024  beq 0x825d9c60
	if ctx.cr[0].eq {
	pc = 0x825D9C60; continue 'dispatch;
	}
	// 825D9C40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9C48: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825D9C4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D9C50: 4E800421  bctrl
	ctx.lr = 0x825D9C54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D9C54: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D9C58: 4082FFC0  bne 0x825d9c18
	if !ctx.cr[0].eq {
	pc = 0x825D9C18; continue 'dispatch;
	}
	// 825D9C5C: 48000040  b 0x825d9c9c
	pc = 0x825D9C9C; continue 'dispatch;
	// 825D9C60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D9C64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D9C68: 388BEB14  addi r4, r11, -0x14ec
	ctx.r[4].s64 = ctx.r[11].s64 + -5356;
	// 825D9C6C: 38A001F2  li r5, 0x1f2
	ctx.r[5].s64 = 498;
	// 825D9C70: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D9C74: 4BCE6765  bl 0x822c03d8
	ctx.lr = 0x825D9C78;
	sub_822C03D8(ctx, base);
	// 825D9C78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D9C7C: 41820014  beq 0x825d9c90
	if ctx.cr[0].eq {
	pc = 0x825D9C90; continue 'dispatch;
	}
	// 825D9C80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9C84: 4BFFF9FD  bl 0x825d9680
	ctx.lr = 0x825D9C88;
	sub_825D9680(ctx, base);
	// 825D9C88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9C8C: 48000008  b 0x825d9c94
	pc = 0x825D9C94; continue 'dispatch;
	// 825D9C90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D9C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D9C98: 4BFFFAA1  bl 0x825d9738
	ctx.lr = 0x825D9C9C;
	sub_825D9738(ctx, base);
	// 825D9C9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9CA0: 489F8A51  bl 0x82fd26f0
	ctx.lr = 0x825D9CA4;
	sub_82FD26F0(ctx, base);
	// 825D9CA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D9CA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D9CAC: 48BCE510  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9CB0 size=220
    let mut pc: u32 = 0x825D9CB0;
    'dispatch: loop {
        match pc {
            0x825D9CB0 => {
    //   block [0x825D9CB0..0x825D9D8C)
	// 825D9CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9CB4: 48BCE4B5  bl 0x831a8168
	ctx.lr = 0x825D9CB8;
	sub_831A8130(ctx, base);
	// 825D9CB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9CC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D9CC4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D9CC8: 4BFFF659  bl 0x825d9320
	ctx.lr = 0x825D9CCC;
	sub_825D9320(ctx, base);
	// 825D9CCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9CD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9CD4: 4BFFFCCD  bl 0x825d99a0
	ctx.lr = 0x825D9CD8;
	sub_825D99A0(ctx, base);
	// 825D9CD8: 48000090  b 0x825d9d68
	pc = 0x825D9D68; continue 'dispatch;
	// 825D9CDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825D9CE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9CE8: 4BFFF639  bl 0x825d9320
	ctx.lr = 0x825D9CEC;
	sub_825D9320(ctx, base);
	// 825D9CEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9CF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D9CF4: 4BFFFCAD  bl 0x825d99a0
	ctx.lr = 0x825D9CF8;
	sub_825D99A0(ctx, base);
	// 825D9CF8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9CFC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D9D00: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825D9D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D9D08: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825D9D0C: 695C0001  xori r28, r10, 1
	ctx.r[28].u64 = ctx.r[10].u64 ^ 1;
	// 825D9D10: 419A000C  beq cr6, 0x825d9d1c
	if ctx.cr[6].eq {
	pc = 0x825D9D1C; continue 'dispatch;
	}
	// 825D9D14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825D9D18: 4BCE6B79  bl 0x822c0890
	ctx.lr = 0x825D9D1C;
	sub_822C0890(ctx, base);
	// 825D9D1C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D9D20: 41820014  beq 0x825d9d34
	if ctx.cr[0].eq {
	pc = 0x825D9D34; continue 'dispatch;
	}
	// 825D9D24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825D9D28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9D30: 4BFFFF81  bl 0x825d9cb0
	ctx.lr = 0x825D9D34;
	sub_825D9CB0(ctx, base);
	// 825D9D34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D9D38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D9D3C: 4BFFFD7D  bl 0x825d9ab8
	ctx.lr = 0x825D9D40;
	sub_825D9AB8(ctx, base);
	// 825D9D40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D9D44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D9D48: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D9D4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D9D50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D9D54: 4BCEA70D  bl 0x822c4460
	ctx.lr = 0x825D9D58;
	sub_822C4460(ctx, base);
	// 825D9D58: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D9D5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D9D60: 419A0008  beq cr6, 0x825d9d68
	if ctx.cr[6].eq {
	pc = 0x825D9D68; continue 'dispatch;
	}
	// 825D9D64: 4BCE6B2D  bl 0x822c0890
	ctx.lr = 0x825D9D68;
	sub_822C0890(ctx, base);
	// 825D9D68: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D9D6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D9D70: 409AFF6C  bne cr6, 0x825d9cdc
	if !ctx.cr[6].eq {
	pc = 0x825D9CDC; continue 'dispatch;
	}
	// 825D9D74: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D9D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D9D7C: 419A0008  beq cr6, 0x825d9d84
	if ctx.cr[6].eq {
	pc = 0x825D9D84; continue 'dispatch;
	}
	// 825D9D80: 4BCE6B11  bl 0x822c0890
	ctx.lr = 0x825D9D84;
	sub_822C0890(ctx, base);
	// 825D9D84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D9D88: 48BCE430  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9D90 size=56
    let mut pc: u32 = 0x825D9D90;
    'dispatch: loop {
        match pc {
            0x825D9D90 => {
    //   block [0x825D9D90..0x825D9DC8)
	// 825D9D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9D98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9D9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9DA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9DA4: 48002A1D  bl 0x825dc7c0
	ctx.lr = 0x825D9DA8;
	sub_825DC7C0(ctx, base);
	// 825D9DA8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D9DAC: 480008A5  bl 0x825da650
	ctx.lr = 0x825D9DB0;
	sub_825DA650(ctx, base);
	// 825D9DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9DB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D9DB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9DBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9DC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9DC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9DC8 size=56
    let mut pc: u32 = 0x825D9DC8;
    'dispatch: loop {
        match pc {
            0x825D9DC8 => {
    //   block [0x825D9DC8..0x825D9E00)
	// 825D9DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9DD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9DD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9DD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9DDC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D9DE0: 480008E9  bl 0x825da6c8
	ctx.lr = 0x825D9DE4;
	sub_825DA6C8(ctx, base);
	// 825D9DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9DE8: 48002A51  bl 0x825dc838
	ctx.lr = 0x825D9DEC;
	sub_825DC838(ctx, base);
	// 825D9DEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D9DF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9DF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E00 size=4
    let mut pc: u32 = 0x825D9E00;
    'dispatch: loop {
        match pc {
            0x825D9E00 => {
    //   block [0x825D9E00..0x825D9E04)
	// 825D9E00: 48001188  b 0x825daf88
	sub_825DAF88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E08 size=4
    let mut pc: u32 = 0x825D9E08;
    'dispatch: loop {
        match pc {
            0x825D9E08 => {
    //   block [0x825D9E08..0x825D9E0C)
	// 825D9E08: 480019F0  b 0x825db7f8
	sub_825DB7F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E10 size=4
    let mut pc: u32 = 0x825D9E10;
    'dispatch: loop {
        match pc {
            0x825D9E10 => {
    //   block [0x825D9E10..0x825D9E14)
	// 825D9E10: 48001EA8  b 0x825dbcb8
	sub_825DBCB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E18 size=4
    let mut pc: u32 = 0x825D9E18;
    'dispatch: loop {
        match pc {
            0x825D9E18 => {
    //   block [0x825D9E18..0x825D9E1C)
	// 825D9E18: 48001F40  b 0x825dbd58
	sub_825DBD58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E20 size=4
    let mut pc: u32 = 0x825D9E20;
    'dispatch: loop {
        match pc {
            0x825D9E20 => {
    //   block [0x825D9E20..0x825D9E24)
	// 825D9E20: 48001FD8  b 0x825dbdf8
	sub_825DBDF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E28 size=4
    let mut pc: u32 = 0x825D9E28;
    'dispatch: loop {
        match pc {
            0x825D9E28 => {
    //   block [0x825D9E28..0x825D9E2C)
	// 825D9E28: 48002070  b 0x825dbe98
	sub_825DBE98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E30 size=4
    let mut pc: u32 = 0x825D9E30;
    'dispatch: loop {
        match pc {
            0x825D9E30 => {
    //   block [0x825D9E30..0x825D9E34)
	// 825D9E30: 48002108  b 0x825dbf38
	sub_825DBF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E38 size=4
    let mut pc: u32 = 0x825D9E38;
    'dispatch: loop {
        match pc {
            0x825D9E38 => {
    //   block [0x825D9E38..0x825D9E3C)
	// 825D9E38: 48002240  b 0x825dc078
	sub_825DC078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E40 size=4
    let mut pc: u32 = 0x825D9E40;
    'dispatch: loop {
        match pc {
            0x825D9E40 => {
    //   block [0x825D9E40..0x825D9E44)
	// 825D9E40: 480022D8  b 0x825dc118
	sub_825DC118(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E48 size=4
    let mut pc: u32 = 0x825D9E48;
    'dispatch: loop {
        match pc {
            0x825D9E48 => {
    //   block [0x825D9E48..0x825D9E4C)
	// 825D9E48: 48002410  b 0x825dc258
	sub_825DC258(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E50 size=4
    let mut pc: u32 = 0x825D9E50;
    'dispatch: loop {
        match pc {
            0x825D9E50 => {
    //   block [0x825D9E50..0x825D9E54)
	// 825D9E50: 48002548  b 0x825dc398
	sub_825DC398(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E58 size=4
    let mut pc: u32 = 0x825D9E58;
    'dispatch: loop {
        match pc {
            0x825D9E58 => {
    //   block [0x825D9E58..0x825D9E5C)
	// 825D9E58: 480025E0  b 0x825dc438
	sub_825DC438(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E60 size=4
    let mut pc: u32 = 0x825D9E60;
    'dispatch: loop {
        match pc {
            0x825D9E60 => {
    //   block [0x825D9E60..0x825D9E64)
	// 825D9E60: 48002498  b 0x825dc2f8
	sub_825DC2F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E68 size=4
    let mut pc: u32 = 0x825D9E68;
    'dispatch: loop {
        match pc {
            0x825D9E68 => {
    //   block [0x825D9E68..0x825D9E6C)
	// 825D9E68: 48002710  b 0x825dc578
	sub_825DC578(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E70 size=4
    let mut pc: u32 = 0x825D9E70;
    'dispatch: loop {
        match pc {
            0x825D9E70 => {
    //   block [0x825D9E70..0x825D9E74)
	// 825D9E70: 48002168  b 0x825dbfd8
	sub_825DBFD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E78 size=4
    let mut pc: u32 = 0x825D9E78;
    'dispatch: loop {
        match pc {
            0x825D9E78 => {
    //   block [0x825D9E78..0x825D9E7C)
	// 825D9E78: 48002340  b 0x825dc1b8
	sub_825DC1B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E80 size=4
    let mut pc: u32 = 0x825D9E80;
    'dispatch: loop {
        match pc {
            0x825D9E80 => {
    //   block [0x825D9E80..0x825D9E84)
	// 825D9E80: 48002798  b 0x825dc618
	sub_825DC618(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E88 size=8
    let mut pc: u32 = 0x825D9E88;
    'dispatch: loop {
        match pc {
            0x825D9E88 => {
    //   block [0x825D9E88..0x825D9E90)
	// 825D9E88: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 825D9E8C: 48000374  b 0x825da200
	sub_825DA200(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E90 size=8
    let mut pc: u32 = 0x825D9E90;
    'dispatch: loop {
        match pc {
            0x825D9E90 => {
    //   block [0x825D9E90..0x825D9E98)
	// 825D9E90: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 825D9E94: 4800052C  b 0x825da3c0
	sub_825DA3C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9E98 size=8
    let mut pc: u32 = 0x825D9E98;
    'dispatch: loop {
        match pc {
            0x825D9E98 => {
    //   block [0x825D9E98..0x825D9EA0)
	// 825D9E98: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 825D9E9C: 480005C4  b 0x825da460
	sub_825DA460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D9EA0 size=8
    let mut pc: u32 = 0x825D9EA0;
    'dispatch: loop {
        match pc {
            0x825D9EA0 => {
    //   block [0x825D9EA0..0x825D9EA8)
	// 825D9EA0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 825D9EA4: 4800065C  b 0x825da500
	sub_825DA500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9EA8 size=52
    let mut pc: u32 = 0x825D9EA8;
    'dispatch: loop {
        match pc {
            0x825D9EA8 => {
    //   block [0x825D9EA8..0x825D9EDC)
	// 825D9EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9EB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9EB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9EB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9EBC: 48001B25  bl 0x825db9e0
	ctx.lr = 0x825D9EC0;
	sub_825DB9E0(ctx, base);
	// 825D9EC0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D9EC4: 48000415  bl 0x825da2d8
	ctx.lr = 0x825D9EC8;
	sub_825DA2D8(ctx, base);
	// 825D9EC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D9ECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9ED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9ED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9EE0 size=68
    let mut pc: u32 = 0x825D9EE0;
    'dispatch: loop {
        match pc {
            0x825D9EE0 => {
    //   block [0x825D9EE0..0x825D9F24)
	// 825D9EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9EE4: 48BCE289  bl 0x831a816c
	ctx.lr = 0x825D9EE8;
	sub_831A8130(ctx, base);
	// 825D9EE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9EEC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D9EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9EF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D9EF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D9EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9F00: 4BFB2011  bl 0x8258bf10
	ctx.lr = 0x825D9F04;
	sub_8258BF10(ctx, base);
	// 825D9F04: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D9F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9F10: 480027A9  bl 0x825dc6b8
	ctx.lr = 0x825D9F14;
	sub_825DC6B8(ctx, base);
	// 825D9F14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9F18: 4BCEEDA1  bl 0x822c8cb8
	ctx.lr = 0x825D9F1C;
	sub_822C8CB8(ctx, base);
	// 825D9F1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D9F20: 48BCE29C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9F28 size=80
    let mut pc: u32 = 0x825D9F28;
    'dispatch: loop {
        match pc {
            0x825D9F28 => {
    //   block [0x825D9F28..0x825D9F78)
	// 825D9F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D9F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9F38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D9F48: 4BFB1FC9  bl 0x8258bf10
	ctx.lr = 0x825D9F4C;
	sub_8258BF10(ctx, base);
	// 825D9F4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D9F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D9F54: 48000F85  bl 0x825daed8
	ctx.lr = 0x825D9F58;
	sub_825DAED8(ctx, base);
	// 825D9F58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D9F5C: 4BCEED5D  bl 0x822c8cb8
	ctx.lr = 0x825D9F60;
	sub_822C8CB8(ctx, base);
	// 825D9F60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D9F64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9F68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D9F6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D9F70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D9F74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9F78 size=68
    let mut pc: u32 = 0x825D9F78;
    'dispatch: loop {
        match pc {
            0x825D9F78 => {
    //   block [0x825D9F78..0x825D9FBC)
	// 825D9F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9F7C: 48BCE1F1  bl 0x831a816c
	ctx.lr = 0x825D9F80;
	sub_831A8130(ctx, base);
	// 825D9F80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9F84: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825D9F88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9F8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D9F90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D9F94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9F98: 4BFB1F79  bl 0x8258bf10
	ctx.lr = 0x825D9F9C;
	sub_8258BF10(ctx, base);
	// 825D9F9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D9FA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D9FA4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D9FA8: 480005F9  bl 0x825da5a0
	ctx.lr = 0x825D9FAC;
	sub_825DA5A0(ctx, base);
	// 825D9FAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D9FB0: 4BCEED09  bl 0x822c8cb8
	ctx.lr = 0x825D9FB4;
	sub_822C8CB8(ctx, base);
	// 825D9FB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D9FB8: 48BCE204  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D9FC0 size=72
    let mut pc: u32 = 0x825D9FC0;
    'dispatch: loop {
        match pc {
            0x825D9FC0 => {
    //   block [0x825D9FC0..0x825DA008)
	// 825D9FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D9FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D9FC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D9FCC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D9FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D9FD4: 80840008  lwz r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D9FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9FDC: 48819A2D  bl 0x82df3a08
	ctx.lr = 0x825D9FE0;
	sub_82DF3A08(ctx, base);
	// 825D9FE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D9FE4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D9FE8: 48819BE9  bl 0x82df3bd0
	ctx.lr = 0x825D9FEC;
	sub_82DF3BD0(ctx, base);
	// 825D9FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D9FF0: 48819439  bl 0x82df3428
	ctx.lr = 0x825D9FF4;
	sub_82DF3428(ctx, base);
	// 825D9FF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D9FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D9FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA000: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DA008 size=20
    let mut pc: u32 = 0x825DA008;
    'dispatch: loop {
        match pc {
            0x825DA008 => {
    //   block [0x825DA008..0x825DA01C)
	// 825DA008: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DA00C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA010: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DA014: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DA018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DA020 size=20
    let mut pc: u32 = 0x825DA020;
    'dispatch: loop {
        match pc {
            0x825DA020 => {
    //   block [0x825DA020..0x825DA034)
	// 825DA020: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DA024: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA028: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA02C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA038 size=68
    let mut pc: u32 = 0x825DA038;
    'dispatch: loop {
        match pc {
            0x825DA038 => {
    //   block [0x825DA038..0x825DA07C)
	// 825DA038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA040: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA044: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA048: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA04C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA050: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DA054: 396BEB50  addi r11, r11, -0x14b0
	ctx.r[11].s64 = ctx.r[11].s64 + -5296;
	// 825DA058: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA05C: 41820008  beq 0x825da064
	if ctx.cr[0].eq {
	pc = 0x825DA064; continue 'dispatch;
	}
	// 825DA060: 4BCE6209  bl 0x822c0268
	ctx.lr = 0x825DA064;
	sub_822C0268(ctx, base);
	// 825DA064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA068: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DA06C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA070: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA080 size=196
    let mut pc: u32 = 0x825DA080;
    'dispatch: loop {
        match pc {
            0x825DA080 => {
    //   block [0x825DA080..0x825DA144)
	// 825DA080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA08C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DA09C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825DA0A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DA0A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA0A8: 4BCE6891  bl 0x822c0938
	ctx.lr = 0x825DA0AC;
	sub_822C0938(ctx, base);
	// 825DA0AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DA0B0: 41820028  beq 0x825da0d8
	if ctx.cr[0].eq {
	pc = 0x825DA0D8; continue 'dispatch;
	}
	// 825DA0B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA0B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825DA0BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DA0C0: 392BEB60  addi r9, r11, -0x14a0
	ctx.r[9].s64 = ctx.r[11].s64 + -5280;
	// 825DA0C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DA0C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DA0CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DA0D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DA0D4: 48000008  b 0x825da0dc
	pc = 0x825DA0DC; continue 'dispatch;
	// 825DA0D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DA0DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA0E4: 409A0044  bne cr6, 0x825da128
	if !ctx.cr[6].eq {
	pc = 0x825DA128; continue 'dispatch;
	}
	// 825DA0E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DA0EC: 419A001C  beq cr6, 0x825da108
	if ctx.cr[6].eq {
	pc = 0x825DA108; continue 'dispatch;
	}
	// 825DA0F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA0F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DA0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA0FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA100: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DA104: 4E800421  bctrl
	ctx.lr = 0x825DA108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DA108: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DA10C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825DA110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA114: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825DA118: 816BC4A4  lwz r11, -0x3b5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15196 as u32) ) } as u64;
	// 825DA11C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DA120: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DA124: 4BCE5EDD  bl 0x822c0000
	ctx.lr = 0x825DA128;
	sub_822C0000(ctx, base);
	// 825DA128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DA12C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA138: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA13C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA148 size=84
    let mut pc: u32 = 0x825DA148;
    'dispatch: loop {
        match pc {
            0x825DA148 => {
    //   block [0x825DA148..0x825DA19C)
	// 825DA148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA14C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA15C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA160: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA164: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DA168: 396BEBA4  addi r11, r11, -0x145c
	ctx.r[11].s64 = ctx.r[11].s64 + -5212;
	// 825DA16C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DA170: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA174: 4BFB1D9D  bl 0x8258bf10
	ctx.lr = 0x825DA178;
	sub_8258BF10(ctx, base);
	// 825DA178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DA17C: 4BCEEB3D  bl 0x822c8cb8
	ctx.lr = 0x825DA180;
	sub_822C8CB8(ctx, base);
	// 825DA180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA1A0 size=92
    let mut pc: u32 = 0x825DA1A0;
    'dispatch: loop {
        match pc {
            0x825DA1A0 => {
    //   block [0x825DA1A0..0x825DA1FC)
	// 825DA1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA1A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA1A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA1AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA1B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA1B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA1B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DA1BC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DA1C0: 4BCEEAF9  bl 0x822c8cb8
	ctx.lr = 0x825DA1C4;
	sub_822C8CB8(ctx, base);
	// 825DA1C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA1C8: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DA1CC: 396BEB50  addi r11, r11, -0x14b0
	ctx.r[11].s64 = ctx.r[11].s64 + -5296;
	// 825DA1D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA1D4: 4182000C  beq 0x825da1e0
	if ctx.cr[0].eq {
	pc = 0x825DA1E0; continue 'dispatch;
	}
	// 825DA1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA1DC: 4BCE608D  bl 0x822c0268
	ctx.lr = 0x825DA1E0;
	sub_822C0268(ctx, base);
	// 825DA1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA1F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA200 size=208
    let mut pc: u32 = 0x825DA200;
    'dispatch: loop {
        match pc {
            0x825DA200 => {
    //   block [0x825DA200..0x825DA2D0)
	// 825DA200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA204: 48BCDF61  bl 0x831a8164
	ctx.lr = 0x825DA208;
	sub_831A8130(ctx, base);
	// 825DA208: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA20C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DA210: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825DA214: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA21C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA220: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825DA224: 4800009C  b 0x825da2c0
	pc = 0x825DA2C0; continue 'dispatch;
	// 825DA228: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DA22C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825DA230: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825DA234: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DA238: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DA23C: 419A0070  beq cr6, 0x825da2ac
	if ctx.cr[6].eq {
	pc = 0x825DA2AC; continue 'dispatch;
	}
	// 825DA240: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA248: 419A0064  beq cr6, 0x825da2ac
	if ctx.cr[6].eq {
	pc = 0x825DA2AC; continue 'dispatch;
	}
	// 825DA24C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 825DA250: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825DA254: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA258: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 825DA25C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DA260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA264: 419A0024  beq cr6, 0x825da288
	if ctx.cr[6].eq {
	pc = 0x825DA288; continue 'dispatch;
	}
	// 825DA268: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825DA26C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825DA270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA274: 419A0014  beq cr6, 0x825da288
	if ctx.cr[6].eq {
	pc = 0x825DA288; continue 'dispatch;
	}
	// 825DA278: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA27C: 4BFD764D  bl 0x825b18c8
	ctx.lr = 0x825DA280;
	sub_825B18C8(ctx, base);
	// 825DA280: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DA284: 4182001C  beq 0x825da2a0
	if ctx.cr[0].eq {
	pc = 0x825DA2A0; continue 'dispatch;
	}
	// 825DA288: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DA28C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA290: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA294: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DA298: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DA29C: 4E800421  bctrl
	ctx.lr = 0x825DA2A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DA2A0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825DA2A4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825DA2A8: 4082FFAC  bne 0x825da254
	if !ctx.cr[0].eq {
	pc = 0x825DA254; continue 'dispatch;
	}
	// 825DA2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA2B0: 4BDC73D9  bl 0x823a1688
	ctx.lr = 0x825DA2B4;
	sub_823A1688(ctx, base);
	// 825DA2B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA2B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA2BC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DA2C0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DA2C4: 409AFF64  bne cr6, 0x825da228
	if !ctx.cr[6].eq {
	pc = 0x825DA228; continue 'dispatch;
	}
	// 825DA2C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DA2CC: 48BCDEE8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DA2D0 size=8
    let mut pc: u32 = 0x825DA2D0;
    'dispatch: loop {
        match pc {
            0x825DA2D0 => {
    //   block [0x825DA2D0..0x825DA2D8)
	// 825DA2D0: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 825DA2D4: 4BFD75F4  b 0x825b18c8
	sub_825B18C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DA2D8 size=8
    let mut pc: u32 = 0x825DA2D8;
    'dispatch: loop {
        match pc {
            0x825DA2D8 => {
    //   block [0x825DA2D8..0x825DA2E0)
	// 825DA2D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA2DC: 4BFD849C  b 0x825b2778
	sub_825B2778(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA2E0 size=220
    let mut pc: u32 = 0x825DA2E0;
    'dispatch: loop {
        match pc {
            0x825DA2E0 => {
    //   block [0x825DA2E0..0x825DA3BC)
	// 825DA2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA2E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA2E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA2EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA2F0: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA2F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA2F8: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA300: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DA304: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DA308: 419A0024  beq cr6, 0x825da32c
	if ctx.cr[6].eq {
	pc = 0x825DA32C; continue 'dispatch;
	}
	// 825DA30C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DA310: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DA314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DA318: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DA31C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DA320: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DA324: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DA328: 4082FFE8  bne 0x825da310
	if !ctx.cr[0].eq {
	pc = 0x825DA310; continue 'dispatch;
	}
	// 825DA32C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DA330: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825DA334: 4BEB28DD  bl 0x8248cc10
	ctx.lr = 0x825DA338;
	sub_8248CC10(ctx, base);
	// 825DA338: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DA33C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA340: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA348: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825DA34C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825DA350: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 825DA354: 419A0024  beq cr6, 0x825da378
	if ctx.cr[6].eq {
	pc = 0x825DA378; continue 'dispatch;
	}
	// 825DA358: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DA35C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DA360: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DA364: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DA368: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DA36C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DA370: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DA374: 4082FFE8  bne 0x825da35c
	if !ctx.cr[0].eq {
	pc = 0x825DA35C; continue 'dispatch;
	}
	// 825DA378: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825DA37C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA384: 48365A15  bl 0x8293fd98
	ctx.lr = 0x825DA388;
	sub_8293FD98(ctx, base);
	// 825DA388: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825DA38C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DA390: 419A0008  beq cr6, 0x825da398
	if ctx.cr[6].eq {
	pc = 0x825DA398; continue 'dispatch;
	}
	// 825DA394: 4BCE64FD  bl 0x822c0890
	ctx.lr = 0x825DA398;
	sub_822C0890(ctx, base);
	// 825DA398: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825DA39C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DA3A0: 419A0008  beq cr6, 0x825da3a8
	if ctx.cr[6].eq {
	pc = 0x825DA3A8; continue 'dispatch;
	}
	// 825DA3A4: 4BCE64ED  bl 0x822c0890
	ctx.lr = 0x825DA3A8;
	sub_822C0890(ctx, base);
	// 825DA3A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DA3AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA3B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA3B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA3B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA3C0 size=156
    let mut pc: u32 = 0x825DA3C0;
    'dispatch: loop {
        match pc {
            0x825DA3C0 => {
    //   block [0x825DA3C0..0x825DA45C)
	// 825DA3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA3C4: 48BCDDA9  bl 0x831a816c
	ctx.lr = 0x825DA3C8;
	sub_831A8130(ctx, base);
	// 825DA3C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA3CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA3D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA3D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DA3D8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DA3DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DA3E0: 388BEBB0  addi r4, r11, -0x1450
	ctx.r[4].s64 = ctx.r[11].s64 + -5200;
	// 825DA3E4: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 825DA3E8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DA3EC: 4BCE5FED  bl 0x822c03d8
	ctx.lr = 0x825DA3F0;
	sub_822C03D8(ctx, base);
	// 825DA3F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DA3F4: 4182001C  beq 0x825da410
	if ctx.cr[0].eq {
	pc = 0x825DA410; continue 'dispatch;
	}
	// 825DA3F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA3FC: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DA400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA404: 396BEB74  addi r11, r11, -0x148c
	ctx.r[11].s64 = ctx.r[11].s64 + -5260;
	// 825DA408: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA40C: 48000008  b 0x825da414
	pc = 0x825DA414; continue 'dispatch;
	// 825DA410: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DA414: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DA418: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA41C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA420: 4BFFFC61  bl 0x825da080
	ctx.lr = 0x825DA424;
	sub_825DA080(ctx, base);
	// 825DA424: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DA428: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA42C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA430: 4BCE5BD1  bl 0x822c0000
	ctx.lr = 0x825DA434;
	sub_822C0000(ctx, base);
	// 825DA434: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DA438: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DA43C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA440: 4BFFFEA1  bl 0x825da2e0
	ctx.lr = 0x825DA444;
	sub_825DA2E0(ctx, base);
	// 825DA444: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DA448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DA44C: 419A0008  beq cr6, 0x825da454
	if ctx.cr[6].eq {
	pc = 0x825DA454; continue 'dispatch;
	}
	// 825DA450: 4BCE6441  bl 0x822c0890
	ctx.lr = 0x825DA454;
	sub_822C0890(ctx, base);
	// 825DA454: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DA458: 48BCDD64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA460 size=156
    let mut pc: u32 = 0x825DA460;
    'dispatch: loop {
        match pc {
            0x825DA460 => {
    //   block [0x825DA460..0x825DA4FC)
	// 825DA460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA464: 48BCDD09  bl 0x831a816c
	ctx.lr = 0x825DA468;
	sub_831A8130(ctx, base);
	// 825DA468: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA46C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA470: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA474: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DA478: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DA47C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DA480: 388BEBB0  addi r4, r11, -0x1450
	ctx.r[4].s64 = ctx.r[11].s64 + -5200;
	// 825DA484: 38A00168  li r5, 0x168
	ctx.r[5].s64 = 360;
	// 825DA488: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DA48C: 4BCE5F4D  bl 0x822c03d8
	ctx.lr = 0x825DA490;
	sub_822C03D8(ctx, base);
	// 825DA490: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DA494: 4182001C  beq 0x825da4b0
	if ctx.cr[0].eq {
	pc = 0x825DA4B0; continue 'dispatch;
	}
	// 825DA498: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA49C: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DA4A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA4A4: 396BEB84  addi r11, r11, -0x147c
	ctx.r[11].s64 = ctx.r[11].s64 + -5244;
	// 825DA4A8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA4AC: 48000008  b 0x825da4b4
	pc = 0x825DA4B4; continue 'dispatch;
	// 825DA4B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DA4B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DA4B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA4BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA4C0: 4BFFFBC1  bl 0x825da080
	ctx.lr = 0x825DA4C4;
	sub_825DA080(ctx, base);
	// 825DA4C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DA4C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA4CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA4D0: 4BCE5B31  bl 0x822c0000
	ctx.lr = 0x825DA4D4;
	sub_822C0000(ctx, base);
	// 825DA4D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DA4D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DA4DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA4E0: 4BFFFE01  bl 0x825da2e0
	ctx.lr = 0x825DA4E4;
	sub_825DA2E0(ctx, base);
	// 825DA4E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DA4E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DA4EC: 419A0008  beq cr6, 0x825da4f4
	if ctx.cr[6].eq {
	pc = 0x825DA4F4; continue 'dispatch;
	}
	// 825DA4F0: 4BCE63A1  bl 0x822c0890
	ctx.lr = 0x825DA4F4;
	sub_822C0890(ctx, base);
	// 825DA4F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DA4F8: 48BCDCC4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA500 size=156
    let mut pc: u32 = 0x825DA500;
    'dispatch: loop {
        match pc {
            0x825DA500 => {
    //   block [0x825DA500..0x825DA59C)
	// 825DA500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA504: 48BCDC69  bl 0x831a816c
	ctx.lr = 0x825DA508;
	sub_831A8130(ctx, base);
	// 825DA508: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA50C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA510: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA514: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DA518: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DA51C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DA520: 388BEBB0  addi r4, r11, -0x1450
	ctx.r[4].s64 = ctx.r[11].s64 + -5200;
	// 825DA524: 38A0022D  li r5, 0x22d
	ctx.r[5].s64 = 557;
	// 825DA528: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DA52C: 4BCE5EAD  bl 0x822c03d8
	ctx.lr = 0x825DA530;
	sub_822C03D8(ctx, base);
	// 825DA530: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DA534: 4182001C  beq 0x825da550
	if ctx.cr[0].eq {
	pc = 0x825DA550; continue 'dispatch;
	}
	// 825DA538: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA53C: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DA540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA544: 396BEB94  addi r11, r11, -0x146c
	ctx.r[11].s64 = ctx.r[11].s64 + -5228;
	// 825DA548: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA54C: 48000008  b 0x825da554
	pc = 0x825DA554; continue 'dispatch;
	// 825DA550: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DA554: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DA558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA55C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA560: 4BFFFB21  bl 0x825da080
	ctx.lr = 0x825DA564;
	sub_825DA080(ctx, base);
	// 825DA564: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DA568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA56C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA570: 4BCE5A91  bl 0x822c0000
	ctx.lr = 0x825DA574;
	sub_822C0000(ctx, base);
	// 825DA574: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DA578: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DA57C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA580: 4BFFFD61  bl 0x825da2e0
	ctx.lr = 0x825DA584;
	sub_825DA2E0(ctx, base);
	// 825DA584: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DA588: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DA58C: 419A0008  beq cr6, 0x825da594
	if ctx.cr[6].eq {
	pc = 0x825DA594; continue 'dispatch;
	}
	// 825DA590: 4BCE6301  bl 0x822c0890
	ctx.lr = 0x825DA594;
	sub_822C0890(ctx, base);
	// 825DA594: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DA598: 48BCDC24  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA5A0 size=172
    let mut pc: u32 = 0x825DA5A0;
    'dispatch: loop {
        match pc {
            0x825DA5A0 => {
    //   block [0x825DA5A0..0x825DA64C)
	// 825DA5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA5A4: 48BCDBC5  bl 0x831a8168
	ctx.lr = 0x825DA5A8;
	sub_831A8130(ctx, base);
	// 825DA5A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA5AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA5B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA5B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DA5B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825DA5BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DA5C0: 388BEBB0  addi r4, r11, -0x1450
	ctx.r[4].s64 = ctx.r[11].s64 + -5200;
	// 825DA5C4: 38A0029F  li r5, 0x29f
	ctx.r[5].s64 = 671;
	// 825DA5C8: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 825DA5CC: 4BCE5E0D  bl 0x822c03d8
	ctx.lr = 0x825DA5D0;
	sub_822C03D8(ctx, base);
	// 825DA5D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825DA5D4: 41820024  beq 0x825da5f8
	if ctx.cr[0].eq {
	pc = 0x825DA5F8; continue 'dispatch;
	}
	// 825DA5D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DA5DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DA5E0: 4BFB1931  bl 0x8258bf10
	ctx.lr = 0x825DA5E4;
	sub_8258BF10(ctx, base);
	// 825DA5E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DA5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA5EC: 4BFFFB5D  bl 0x825da148
	ctx.lr = 0x825DA5F0;
	sub_825DA148(ctx, base);
	// 825DA5F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA5F4: 48000008  b 0x825da5fc
	pc = 0x825DA5FC; continue 'dispatch;
	// 825DA5F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DA5FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DA600: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA604: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA608: 4BFFFA79  bl 0x825da080
	ctx.lr = 0x825DA60C;
	sub_825DA080(ctx, base);
	// 825DA60C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DA610: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DA614: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA618: 4BCE59E9  bl 0x822c0000
	ctx.lr = 0x825DA61C;
	sub_822C0000(ctx, base);
	// 825DA61C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DA620: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DA624: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA628: 4BFFFCB9  bl 0x825da2e0
	ctx.lr = 0x825DA62C;
	sub_825DA2E0(ctx, base);
	// 825DA62C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DA630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DA634: 419A0008  beq cr6, 0x825da63c
	if ctx.cr[6].eq {
	pc = 0x825DA63C; continue 'dispatch;
	}
	// 825DA638: 4BCE6259  bl 0x822c0890
	ctx.lr = 0x825DA63C;
	sub_822C0890(ctx, base);
	// 825DA63C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DA640: 4BCEE679  bl 0x822c8cb8
	ctx.lr = 0x825DA644;
	sub_822C8CB8(ctx, base);
	// 825DA644: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825DA648: 48BCDB70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA650 size=116
    let mut pc: u32 = 0x825DA650;
    'dispatch: loop {
        match pc {
            0x825DA650 => {
    //   block [0x825DA650..0x825DA6C4)
	// 825DA650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA65C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA664: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DA668: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA66C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DA670: 388BEBB0  addi r4, r11, -0x1450
	ctx.r[4].s64 = ctx.r[11].s64 + -5200;
	// 825DA674: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 825DA678: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 825DA67C: 48817D6D  bl 0x82df23e8
	ctx.lr = 0x825DA680;
	sub_82DF23E8(ctx, base);
	// 825DA680: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825DA684: 4182001C  beq 0x825da6a0
	if ctx.cr[0].eq {
	pc = 0x825DA6A0; continue 'dispatch;
	}
	// 825DA688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA68C: 481C156D  bl 0x8279bbf8
	ctx.lr = 0x825DA690;
	sub_8279BBF8(ctx, base);
	// 825DA690: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DA694: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825DA698: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825DA69C: 48000008  b 0x825da6a4
	pc = 0x825DA6A4; continue 'dispatch;
	// 825DA6A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DA6A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DA6A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DA6AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA6B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA6B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA6B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA6BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA6C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA6C8 size=72
    let mut pc: u32 = 0x825DA6C8;
    'dispatch: loop {
        match pc {
            0x825DA6C8 => {
    //   block [0x825DA6C8..0x825DA710)
	// 825DA6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA6D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA6D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA6D8: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA6DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DA6E0: 419A001C  beq cr6, 0x825da6fc
	if ctx.cr[6].eq {
	pc = 0x825DA6FC; continue 'dispatch;
	}
	// 825DA6E4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825DA6E8: 4BCEE5D1  bl 0x822c8cb8
	ctx.lr = 0x825DA6EC;
	sub_822C8CB8(ctx, base);
	// 825DA6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA6F0: 48512C09  bl 0x82aed2f8
	ctx.lr = 0x825DA6F4;
	sub_82AED2F8(ctx, base);
	// 825DA6F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DA6F8: 48817CE1  bl 0x82df23d8
	ctx.lr = 0x825DA6FC;
	sub_82DF23D8(ctx, base);
	// 825DA6FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DA700: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA704: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA708: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA710 size=88
    let mut pc: u32 = 0x825DA710;
    'dispatch: loop {
        match pc {
            0x825DA710 => {
    //   block [0x825DA710..0x825DA768)
	// 825DA710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA718: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA71C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA720: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA724: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DA728: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DA72C: 41820014  beq 0x825da740
	if ctx.cr[0].eq {
	pc = 0x825DA740; continue 'dispatch;
	}
	// 825DA730: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DA734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA738: 419A0008  beq cr6, 0x825da740
	if ctx.cr[6].eq {
	pc = 0x825DA740; continue 'dispatch;
	}
	// 825DA73C: 489F7FB5  bl 0x82fd26f0
	ctx.lr = 0x825DA740;
	sub_82FD26F0(ctx, base);
	// 825DA740: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA744: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825DA748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DA74C: 419A0008  beq cr6, 0x825da754
	if ctx.cr[6].eq {
	pc = 0x825DA754; continue 'dispatch;
	}
	// 825DA750: 489F7FA1  bl 0x82fd26f0
	ctx.lr = 0x825DA754;
	sub_82FD26F0(ctx, base);
	// 825DA754: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DA758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA75C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA768 size=68
    let mut pc: u32 = 0x825DA768;
    'dispatch: loop {
        match pc {
            0x825DA768 => {
    //   block [0x825DA768..0x825DA7AC)
	// 825DA768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA774: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA780: 4BFFEE51  bl 0x825d95d0
	ctx.lr = 0x825DA784;
	sub_825D95D0(ctx, base);
	// 825DA784: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DA788: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA78C: 48819445  bl 0x82df3bd0
	ctx.lr = 0x825DA790;
	sub_82DF3BD0(ctx, base);
	// 825DA790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA794: 48818C95  bl 0x82df3428
	ctx.lr = 0x825DA798;
	sub_82DF3428(ctx, base);
	// 825DA798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA79C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA7A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA7B0 size=80
    let mut pc: u32 = 0x825DA7B0;
    'dispatch: loop {
        match pc {
            0x825DA7B0 => {
    //   block [0x825DA7B0..0x825DA800)
	// 825DA7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA7B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA7BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA7C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA7C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA7C8: 4BFFEE09  bl 0x825d95d0
	ctx.lr = 0x825DA7CC;
	sub_825D95D0(ctx, base);
	// 825DA7CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DA7D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA7D4: 4881ED2D  bl 0x82df9500
	ctx.lr = 0x825DA7D8;
	sub_82DF9500(ctx, base);
	// 825DA7D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA7DC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DA7E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA7E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DA7E8: 48818C41  bl 0x82df3428
	ctx.lr = 0x825DA7EC;
	sub_82DF3428(ctx, base);
	// 825DA7EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA7F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA7F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA7F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA7FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA800 size=136
    let mut pc: u32 = 0x825DA800;
    'dispatch: loop {
        match pc {
            0x825DA800 => {
    //   block [0x825DA800..0x825DA888)
	// 825DA800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA80C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA814: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DA818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA81C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DA820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA824: 388B9FFC  addi r4, r11, -0x6004
	ctx.r[4].s64 = ctx.r[11].s64 + -24580;
	// 825DA828: 488191E1  bl 0x82df3a08
	ctx.lr = 0x825DA82C;
	sub_82DF3A08(ctx, base);
	// 825DA82C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DA830: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA834: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825DA838: 4BFFED99  bl 0x825d95d0
	ctx.lr = 0x825DA83C;
	sub_825D95D0(ctx, base);
	// 825DA83C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DA840: 48818AC9  bl 0x82df3308
	ctx.lr = 0x825DA844;
	sub_82DF3308(ctx, base);
	// 825DA844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA848: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DA84C: 48818BDD  bl 0x82df3428
	ctx.lr = 0x825DA850;
	sub_82DF3428(ctx, base);
	// 825DA850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA854: 48818BD5  bl 0x82df3428
	ctx.lr = 0x825DA858;
	sub_82DF3428(ctx, base);
	// 825DA858: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DA85C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DA860: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA864: 40820008  bne 0x825da86c
	if !ctx.cr[0].eq {
	pc = 0x825DA86C; continue 'dispatch;
	}
	// 825DA868: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DA86C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825DA870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA87C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DA888 size=84
    let mut pc: u32 = 0x825DA888;
    'dispatch: loop {
        match pc {
            0x825DA888 => {
    //   block [0x825DA888..0x825DA8DC)
	// 825DA888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA894: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825DA898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA89C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA8A4: 4BFFED2D  bl 0x825d95d0
	ctx.lr = 0x825DA8A8;
	sub_825D95D0(ctx, base);
	// 825DA8A8: 48818909  bl 0x82df31b0
	ctx.lr = 0x825DA8AC;
	sub_82DF31B0(ctx, base);
	// 825DA8AC: 48BD1D9D  bl 0x831ac648
	ctx.lr = 0x825DA8B0;
	sub_831AC648(ctx, base);
	// 825DA8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA8B4: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825DA8B8: 48818B71  bl 0x82df3428
	ctx.lr = 0x825DA8BC;
	sub_82DF3428(ctx, base);
	// 825DA8BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA8C0: D3EB0000  stfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DA8C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA8C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA8CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA8D0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA8D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA8D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA8E0 size=84
    let mut pc: u32 = 0x825DA8E0;
    'dispatch: loop {
        match pc {
            0x825DA8E0 => {
    //   block [0x825DA8E0..0x825DA934)
	// 825DA8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA8E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA8EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA8F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA8F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA8F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA8FC: 4BFFECD5  bl 0x825d95d0
	ctx.lr = 0x825DA900;
	sub_825D95D0(ctx, base);
	// 825DA900: 488188B1  bl 0x82df31b0
	ctx.lr = 0x825DA904;
	sub_82DF31B0(ctx, base);
	// 825DA904: 48BD1D4D  bl 0x831ac650
	ctx.lr = 0x825DA908;
	sub_831AC650(ctx, base);
	// 825DA908: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA90C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA910: 48818B19  bl 0x82df3428
	ctx.lr = 0x825DA914;
	sub_82DF3428(ctx, base);
	// 825DA914: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA918: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825DA91C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA938 size=84
    let mut pc: u32 = 0x825DA938;
    'dispatch: loop {
        match pc {
            0x825DA938 => {
    //   block [0x825DA938..0x825DA98C)
	// 825DA938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA94C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA954: 4BFFEC7D  bl 0x825d95d0
	ctx.lr = 0x825DA958;
	sub_825D95D0(ctx, base);
	// 825DA958: 48818859  bl 0x82df31b0
	ctx.lr = 0x825DA95C;
	sub_82DF31B0(ctx, base);
	// 825DA95C: 48BD1CF5  bl 0x831ac650
	ctx.lr = 0x825DA960;
	sub_831AC650(ctx, base);
	// 825DA960: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA968: 48818AC1  bl 0x82df3428
	ctx.lr = 0x825DA96C;
	sub_82DF3428(ctx, base);
	// 825DA96C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA970: B3CA0000  sth r30, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u16 ) };
	// 825DA974: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA97C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA980: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA990 size=84
    let mut pc: u32 = 0x825DA990;
    'dispatch: loop {
        match pc {
            0x825DA990 => {
    //   block [0x825DA990..0x825DA9E4)
	// 825DA990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DA998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DA99C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DA9A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DA9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA9AC: 4BFFEC25  bl 0x825d95d0
	ctx.lr = 0x825DA9B0;
	sub_825D95D0(ctx, base);
	// 825DA9B0: 48818801  bl 0x82df31b0
	ctx.lr = 0x825DA9B4;
	sub_82DF31B0(ctx, base);
	// 825DA9B4: 48BD1C9D  bl 0x831ac650
	ctx.lr = 0x825DA9B8;
	sub_831AC650(ctx, base);
	// 825DA9B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DA9BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DA9C0: 48818A69  bl 0x82df3428
	ctx.lr = 0x825DA9C4;
	sub_82DF3428(ctx, base);
	// 825DA9C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA9C8: 9BCA0000  stb r30, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 825DA9CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DA9D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DA9D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DA9D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DA9DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DA9E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DA9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DA9E8 size=88
    let mut pc: u32 = 0x825DA9E8;
    'dispatch: loop {
        match pc {
            0x825DA9E8 => {
    //   block [0x825DA9E8..0x825DAA40)
	// 825DA9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DA9EC: 48BCD781  bl 0x831a816c
	ctx.lr = 0x825DA9F0;
	sub_831A8130(ctx, base);
	// 825DA9F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DA9F4: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DA9F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DA9FC: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAA00: 48000028  b 0x825daa28
	pc = 0x825DAA28; continue 'dispatch;
	// 825DAA04: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAA08: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAA0C: 489F6FBD  bl 0x82fd19c8
	ctx.lr = 0x825DAA10;
	sub_82FD19C8(ctx, base);
	// 825DAA10: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825DAA14: 4080000C  bge 0x825daa20
	if !ctx.cr[0].lt {
	pc = 0x825DAA20; continue 'dispatch;
	}
	// 825DAA18: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAA1C: 4800000C  b 0x825daa28
	pc = 0x825DAA28; continue 'dispatch;
	// 825DAA20: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825DAA24: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAA28: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DAA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DAA30: 419AFFD4  beq cr6, 0x825daa04
	if ctx.cr[6].eq {
	pc = 0x825DAA04; continue 'dispatch;
	}
	// 825DAA34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DAA38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DAA3C: 48BCD780  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAA40 size=196
    let mut pc: u32 = 0x825DAA40;
    'dispatch: loop {
        match pc {
            0x825DAA40 => {
    //   block [0x825DAA40..0x825DAB04)
	// 825DAA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAA48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DAA4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DAA50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAA54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DAA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DAA5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825DAA60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DAA64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DAA68: 4BCE5ED1  bl 0x822c0938
	ctx.lr = 0x825DAA6C;
	sub_822C0938(ctx, base);
	// 825DAA6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DAA70: 41820028  beq 0x825daa98
	if ctx.cr[0].eq {
	pc = 0x825DAA98; continue 'dispatch;
	}
	// 825DAA74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DAA78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825DAA7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DAA80: 392BEBFC  addi r9, r11, -0x1404
	ctx.r[9].s64 = ctx.r[11].s64 + -5124;
	// 825DAA84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DAA88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DAA8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DAA90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DAA94: 48000008  b 0x825daa9c
	pc = 0x825DAA9C; continue 'dispatch;
	// 825DAA98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DAA9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DAAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DAAA4: 409A0044  bne cr6, 0x825daae8
	if !ctx.cr[6].eq {
	pc = 0x825DAAE8; continue 'dispatch;
	}
	// 825DAAA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DAAAC: 419A001C  beq cr6, 0x825daac8
	if ctx.cr[6].eq {
	pc = 0x825DAAC8; continue 'dispatch;
	}
	// 825DAAB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAAB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DAAB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DAABC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAAC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DAAC4: 4E800421  bctrl
	ctx.lr = 0x825DAAC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DAAC8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DAACC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825DAAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DAAD4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825DAAD8: 816BC768  lwz r11, -0x3898(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14488 as u32) ) } as u64;
	// 825DAADC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825DAAE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DAAE4: 4BCE551D  bl 0x822c0000
	ctx.lr = 0x825DAAE8;
	sub_822C0000(ctx, base);
	// 825DAAE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DAAEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DAAF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DAAF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DAAF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DAAFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DAB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAB08 size=112
    let mut pc: u32 = 0x825DAB08;
    'dispatch: loop {
        match pc {
            0x825DAB08 => {
    //   block [0x825DAB08..0x825DAB78)
	// 825DAB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAB10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DAB14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DAB18: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAB1C: D8210020  stfd f1, 0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 825DAB20: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DAB24: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 825DAB28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DAB2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DAB30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DAB34: 388BEC3C  addi r4, r11, -0x13c4
	ctx.r[4].s64 = ctx.r[11].s64 + -5060;
	// 825DAB38: 48BCDFA1  bl 0x831a8ad8
	ctx.lr = 0x825DAB3C;
	sub_831A8AD8(ctx, base);
	// 825DAB3C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825DAB40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DAB44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DAB48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DAB4C: 4BFFEDBD  bl 0x825d9908
	ctx.lr = 0x825DAB50;
	sub_825D9908(ctx, base);
	// 825DAB50: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DAB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DAB58: 419A0008  beq cr6, 0x825dab60
	if ctx.cr[6].eq {
	pc = 0x825DAB60; continue 'dispatch;
	}
	// 825DAB5C: 4BCE5D35  bl 0x822c0890
	ctx.lr = 0x825DAB60;
	sub_822C0890(ctx, base);
	// 825DAB60: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 825DAB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DAB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DAB6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DAB70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DAB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAB78 size=108
    let mut pc: u32 = 0x825DAB78;
    'dispatch: loop {
        match pc {
            0x825DAB78 => {
    //   block [0x825DAB78..0x825DABE4)
	// 825DAB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAB80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DAB84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DAB88: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAB8C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825DAB90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DAB94: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DAB98: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825DAB9C: 388B7690  addi r4, r11, 0x7690
	ctx.r[4].s64 = ctx.r[11].s64 + 30352;
	// 825DABA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DABA4: 48BCDF35  bl 0x831a8ad8
	ctx.lr = 0x825DABA8;
	sub_831A8AD8(ctx, base);
	// 825DABA8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825DABAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DABB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DABB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DABB8: 4BFFED51  bl 0x825d9908
	ctx.lr = 0x825DABBC;
	sub_825D9908(ctx, base);
	// 825DABBC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DABC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DABC4: 419A0008  beq cr6, 0x825dabcc
	if ctx.cr[6].eq {
	pc = 0x825DABCC; continue 'dispatch;
	}
	// 825DABC8: 4BCE5CC9  bl 0x822c0890
	ctx.lr = 0x825DABCC;
	sub_822C0890(ctx, base);
	// 825DABCC: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 825DABD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DABD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DABD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DABDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DABE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DABE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DABE8 size=96
    let mut pc: u32 = 0x825DABE8;
    'dispatch: loop {
        match pc {
            0x825DABE8 => {
    //   block [0x825DABE8..0x825DAC48)
	// 825DABE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DABEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DABF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DABF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DABF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DABFC: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAC00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DAC04: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DAC08: 488185A9  bl 0x82df31b0
	ctx.lr = 0x825DAC0C;
	sub_82DF31B0(ctx, base);
	// 825DAC0C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825DAC10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DAC14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DAC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DAC1C: 4BFFECED  bl 0x825d9908
	ctx.lr = 0x825DAC20;
	sub_825D9908(ctx, base);
	// 825DAC20: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DAC24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DAC28: 419A0008  beq cr6, 0x825dac30
	if ctx.cr[6].eq {
	pc = 0x825DAC30; continue 'dispatch;
	}
	// 825DAC2C: 4BCE5C65  bl 0x822c0890
	ctx.lr = 0x825DAC30;
	sub_822C0890(ctx, base);
	// 825DAC30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DAC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DAC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DAC3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DAC40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DAC44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAC48 size=68
    let mut pc: u32 = 0x825DAC48;
    'dispatch: loop {
        match pc {
            0x825DAC48 => {
    //   block [0x825DAC48..0x825DAC8C)
	// 825DAC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAC50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DAC54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAC58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DAC5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DAC60: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DAC64: 396BEBEC  addi r11, r11, -0x1414
	ctx.r[11].s64 = ctx.r[11].s64 + -5140;
	// 825DAC68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DAC6C: 41820008  beq 0x825dac74
	if ctx.cr[0].eq {
	pc = 0x825DAC74; continue 'dispatch;
	}
	// 825DAC70: 4BCE55F9  bl 0x822c0268
	ctx.lr = 0x825DAC74;
	sub_822C0268(ctx, base);
	// 825DAC74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DAC78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DAC7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DAC80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DAC84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DAC88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAC90 size=112
    let mut pc: u32 = 0x825DAC90;
    'dispatch: loop {
        match pc {
            0x825DAC90 => {
    //   block [0x825DAC90..0x825DAD00)
	// 825DAC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAC98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DAC9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DACA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DACA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DACA8: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DACAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DACB0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DACB4: 4881E79D  bl 0x82df9450
	ctx.lr = 0x825DACB8;
	sub_82DF9450(ctx, base);
	// 825DACB8: 488184F9  bl 0x82df31b0
	ctx.lr = 0x825DACBC;
	sub_82DF31B0(ctx, base);
	// 825DACBC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825DACC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DACC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DACC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DACCC: 4BFFEC3D  bl 0x825d9908
	ctx.lr = 0x825DACD0;
	sub_825D9908(ctx, base);
	// 825DACD0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DACD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DACD8: 419A0008  beq cr6, 0x825dace0
	if ctx.cr[6].eq {
	pc = 0x825DACE0; continue 'dispatch;
	}
	// 825DACDC: 4BCE5BB5  bl 0x822c0890
	ctx.lr = 0x825DACE0;
	sub_822C0890(ctx, base);
	// 825DACE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DACE4: 48818745  bl 0x82df3428
	ctx.lr = 0x825DACE8;
	sub_82DF3428(ctx, base);
	// 825DACE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DACEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DACF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DACF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DACF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DACFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAD00 size=112
    let mut pc: u32 = 0x825DAD00;
    'dispatch: loop {
        match pc {
            0x825DAD00 => {
    //   block [0x825DAD00..0x825DAD70)
	// 825DAD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAD08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAD0C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAD10: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825DAD14: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825DAD18: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 825DAD1C: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAD20: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DAD24: 4182001C  beq 0x825dad40
	if ctx.cr[0].eq {
	pc = 0x825DAD40; continue 'dispatch;
	}
	// 825DAD28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825DAD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DAD30: 38CA9FFC  addi r6, r10, -0x6004
	ctx.r[6].s64 = ctx.r[10].s64 + -24580;
	// 825DAD34: 4BFFEBD5  bl 0x825d9908
	ctx.lr = 0x825DAD38;
	sub_825D9908(ctx, base);
	// 825DAD38: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DAD3C: 48000018  b 0x825dad54
	pc = 0x825DAD54; continue 'dispatch;
	// 825DAD40: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825DAD44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DAD48: 38CA9FF4  addi r6, r10, -0x600c
	ctx.r[6].s64 = ctx.r[10].s64 + -24588;
	// 825DAD4C: 4BFFEBBD  bl 0x825d9908
	ctx.lr = 0x825DAD50;
	sub_825D9908(ctx, base);
	// 825DAD50: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DAD54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DAD58: 419A0008  beq cr6, 0x825dad60
	if ctx.cr[6].eq {
	pc = 0x825DAD60; continue 'dispatch;
	}
	// 825DAD5C: 4BCE5B35  bl 0x822c0890
	ctx.lr = 0x825DAD60;
	sub_822C0890(ctx, base);
	// 825DAD60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DAD64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DAD68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DAD6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825DAD70 size=12
    let mut pc: u32 = 0x825DAD70;
    'dispatch: loop {
        match pc {
            0x825DAD70 => {
    //   block [0x825DAD70..0x825DAD7C)
	// 825DAD70: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAD74: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825DAD78: 4BFFFD90  b 0x825dab08
	sub_825DAB08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DAD80 size=12
    let mut pc: u32 = 0x825DAD80;
    'dispatch: loop {
        match pc {
            0x825DAD80 => {
    //   block [0x825DAD80..0x825DAD8C)
	// 825DAD80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAD84: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAD88: 4BFFFDF0  b 0x825dab78
	sub_825DAB78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DAD90 size=12
    let mut pc: u32 = 0x825DAD90;
    'dispatch: loop {
        match pc {
            0x825DAD90 => {
    //   block [0x825DAD90..0x825DAD9C)
	// 825DAD90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAD94: A8CB0000  lha r6, 0(r11)
	ctx.r[6].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 825DAD98: 4BFFFDE0  b 0x825dab78
	sub_825DAB78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DADA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DADA0 size=12
    let mut pc: u32 = 0x825DADA0;
    'dispatch: loop {
        match pc {
            0x825DADA0 => {
    //   block [0x825DADA0..0x825DADAC)
	// 825DADA0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DADA4: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DADA8: 4BFFFDD0  b 0x825dab78
	sub_825DAB78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DADB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DADB0 size=64
    let mut pc: u32 = 0x825DADB0;
    'dispatch: loop {
        match pc {
            0x825DADB0 => {
    //   block [0x825DADB0..0x825DADF0)
	// 825DADB0: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DADB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DADB8: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 825DADBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DADC0: 89640008  lbz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DADC4: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DADC8: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 825DADCC: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DADD0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DADD4: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DADD8: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DADDC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DADE0: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DADE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DADE8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825DADEC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DADF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DADF0 size=36
    let mut pc: u32 = 0x825DADF0;
    'dispatch: loop {
        match pc {
            0x825DADF0 => {
    //   block [0x825DADF0..0x825DAE14)
	// 825DADF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DADF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DADF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DADFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DAE00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DAE04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DAE08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DAE0C: 4082FFE8  bne 0x825dadf4
	if !ctx.cr[0].eq {
	pc = 0x825DADF4; continue 'dispatch;
	}
	// 825DAE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DAE18 size=64
    let mut pc: u32 = 0x825DAE18;
    'dispatch: loop {
        match pc {
            0x825DAE18 => {
    //   block [0x825DAE18..0x825DAE58)
	// 825DAE18: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAE1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DAE20: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 825DAE24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825DAE28: 89640008  lbz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DAE2C: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DAE30: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 825DAE34: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAE38: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DAE3C: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DAE40: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAE44: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825DAE48: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAE4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DAE50: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825DAE54: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DAE58 size=36
    let mut pc: u32 = 0x825DAE58;
    'dispatch: loop {
        match pc {
            0x825DAE58 => {
    //   block [0x825DAE58..0x825DAE7C)
	// 825DAE58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DAE5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DAE60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DAE64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DAE68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DAE6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DAE70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DAE74: 4082FFE8  bne 0x825dae5c
	if !ctx.cr[0].eq {
	pc = 0x825DAE5C; continue 'dispatch;
	}
	// 825DAE78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAE80 size=84
    let mut pc: u32 = 0x825DAE80;
    'dispatch: loop {
        match pc {
            0x825DAE80 => {
    //   block [0x825DAE80..0x825DAED4)
	// 825DAE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAE88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DAE8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DAE90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DAE98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DAE9C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DAEA0: 396BED14  addi r11, r11, -0x12ec
	ctx.r[11].s64 = ctx.r[11].s64 + -4844;
	// 825DAEA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DAEA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DAEAC: 4BFB1065  bl 0x8258bf10
	ctx.lr = 0x825DAEB0;
	sub_8258BF10(ctx, base);
	// 825DAEB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DAEB4: 4BCEDE05  bl 0x822c8cb8
	ctx.lr = 0x825DAEB8;
	sub_822C8CB8(ctx, base);
	// 825DAEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DAEBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DAEC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DAEC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DAEC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DAECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DAED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAED8 size=60
    let mut pc: u32 = 0x825DAED8;
    'dispatch: loop {
        match pc {
            0x825DAED8 => {
    //   block [0x825DAED8..0x825DAF14)
	// 825DAED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAEDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DAEE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DAEE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAEE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAEEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DAEF0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 825DAEF4: 4BE961D5  bl 0x824710c8
	ctx.lr = 0x825DAEF8;
	sub_824710C8(ctx, base);
	// 825DAEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DAEFC: 4BCEDDBD  bl 0x822c8cb8
	ctx.lr = 0x825DAF00;
	sub_822C8CB8(ctx, base);
	// 825DAF00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DAF04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DAF08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DAF0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DAF10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAF18 size=112
    let mut pc: u32 = 0x825DAF18;
    'dispatch: loop {
        match pc {
            0x825DAF18 => {
    //   block [0x825DAF18..0x825DAF88)
	// 825DAF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAF1C: 48BCD251  bl 0x831a816c
	ctx.lr = 0x825DAF20;
	sub_831A8130(ctx, base);
	// 825DAF20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAF24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DAF28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825DAF2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DAF30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DAF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DAF38: 4BFFFAB1  bl 0x825da9e8
	ctx.lr = 0x825DAF3C;
	sub_825DA9E8(ctx, base);
	// 825DAF3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAF40: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825DAF44: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DAF48: 419A0020  beq cr6, 0x825daf68
	if ctx.cr[6].eq {
	pc = 0x825DAF68; continue 'dispatch;
	}
	// 825DAF4C: 8083000C  lwz r4, 0xc(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DAF50: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAF54: 489F6A75  bl 0x82fd19c8
	ctx.lr = 0x825DAF58;
	sub_82FD19C8(ctx, base);
	// 825DAF58: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825DAF5C: 4180000C  blt 0x825daf68
	if ctx.cr[0].lt {
	pc = 0x825DAF68; continue 'dispatch;
	}
	// 825DAF60: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DAF64: 48000010  b 0x825daf74
	pc = 0x825DAF74; continue 'dispatch;
	// 825DAF68: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAF6C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 825DAF70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825DAF74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAF78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DAF7C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DAF80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DAF84: 48BCD238  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DAF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DAF88 size=136
    let mut pc: u32 = 0x825DAF88;
    'dispatch: loop {
        match pc {
            0x825DAF88 => {
    //   block [0x825DAF88..0x825DB010)
	// 825DAF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DAF8C: 48BCD1DD  bl 0x831a8168
	ctx.lr = 0x825DAF90;
	sub_831A8130(ctx, base);
	// 825DAF90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DAF94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DAF98: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825DAF9C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAFA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAFA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAFA8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DAFAC: 48000054  b 0x825db000
	pc = 0x825DB000; continue 'dispatch;
	// 825DAFB0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DAFB4: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 825DAFB8: 83CB0018  lwz r30, 0x18(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DAFBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DAFC0: 409A0010  bne cr6, 0x825dafd0
	if !ctx.cr[6].eq {
	pc = 0x825DAFD0; continue 'dispatch;
	}
	// 825DAFC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAFC8: 489F63E1  bl 0x82fd13a8
	ctx.lr = 0x825DAFCC;
	sub_82FD13A8(ctx, base);
	// 825DAFCC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825DAFD0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAFD4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825DAFD8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAFDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DAFE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DAFE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DAFE8: 4E800421  bctrl
	ctx.lr = 0x825DAFEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DAFEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DAFF0: 481EE041  bl 0x827c9030
	ctx.lr = 0x825DAFF4;
	sub_827C9030(ctx, base);
	// 825DAFF4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DAFF8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DAFFC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB000: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DB004: 409AFFAC  bne cr6, 0x825dafb0
	if !ctx.cr[6].eq {
	pc = 0x825DAFB0; continue 'dispatch;
	}
	// 825DB008: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DB00C: 48BCD1AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB010 size=92
    let mut pc: u32 = 0x825DB010;
    'dispatch: loop {
        match pc {
            0x825DB010 => {
    //   block [0x825DB010..0x825DB06C)
	// 825DB010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DB018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DB01C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DB020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DB028: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DB02C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DB030: 4BCEDC89  bl 0x822c8cb8
	ctx.lr = 0x825DB034;
	sub_822C8CB8(ctx, base);
	// 825DB034: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DB038: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825DB03C: 396BEBEC  addi r11, r11, -0x1414
	ctx.r[11].s64 = ctx.r[11].s64 + -5140;
	// 825DB040: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DB044: 4182000C  beq 0x825db050
	if ctx.cr[0].eq {
	pc = 0x825DB050; continue 'dispatch;
	}
	// 825DB048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DB04C: 4BCE521D  bl 0x822c0268
	ctx.lr = 0x825DB050;
	sub_822C0268(ctx, base);
	// 825DB050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DB054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DB058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DB05C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DB060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DB064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DB068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB070 size=116
    let mut pc: u32 = 0x825DB070;
    'dispatch: loop {
        match pc {
            0x825DB070 => {
    //   block [0x825DB070..0x825DB0E4)
	// 825DB070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB074: 48BCD0ED  bl 0x831a8160
	ctx.lr = 0x825DB078;
	sub_831A8130(ctx, base);
	// 825DB078: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB07C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DB080: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825DB084: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DB088: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DB08C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825DB090: 38C00024  li r6, 0x24
	ctx.r[6].s64 = 36;
	// 825DB094: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825DB098: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 825DB09C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 825DB0A0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825DB0A4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 825DB0A8: 48817021  bl 0x82df20c8
	ctx.lr = 0x825DB0AC;
	sub_82DF20C8(ctx, base);
	// 825DB0AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825DB0B0: 41820028  beq 0x825db0d8
	if ctx.cr[0].eq {
	pc = 0x825DB0D8; continue 'dispatch;
	}
	// 825DB0B4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825DB0B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825DB0BC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825DB0C0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825DB0C4: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825DB0C8: 4BFFFCE9  bl 0x825dadb0
	ctx.lr = 0x825DB0CC;
	sub_825DADB0(ctx, base);
	// 825DB0CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DB0D0: 9B5F0020  stb r26, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u8 ) };
	// 825DB0D4: 997F0021  stb r11, 0x21(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(33 as u32), ctx.r[11].u8 ) };
	// 825DB0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DB0DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DB0E0: 48BCD0D0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB0E8 size=120
    let mut pc: u32 = 0x825DB0E8;
    'dispatch: loop {
        match pc {
            0x825DB0E8 => {
    //   block [0x825DB0E8..0x825DB160)
	// 825DB0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB0EC: 48BCD079  bl 0x831a8164
	ctx.lr = 0x825DB0F0;
	sub_831A8130(ctx, base);
	// 825DB0F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB0F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DB0F8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DB0FC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 825DB100: 897E0021  lbz r11, 0x21(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB108: 409A0050  bne cr6, 0x825db158
	if !ctx.cr[6].eq {
	pc = 0x825DB158; continue 'dispatch;
	}
	// 825DB10C: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 825DB110: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DB114: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB118: 4BFFFFD1  bl 0x825db0e8
	ctx.lr = 0x825DB11C;
	sub_825DB0E8(ctx, base);
	// 825DB11C: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825DB120: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 825DB124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DB128: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB12C: 419A0008  beq cr6, 0x825db134
	if ctx.cr[6].eq {
	pc = 0x825DB134; continue 'dispatch;
	}
	// 825DB130: 4BCE5761  bl 0x822c0890
	ctx.lr = 0x825DB134;
	sub_822C0890(ctx, base);
	// 825DB134: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DB138: 4BFFF5D9  bl 0x825da710
	ctx.lr = 0x825DB13C;
	sub_825DA710(ctx, base);
	// 825DB13C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DB140: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825DB144: 48817045  bl 0x82df2188
	ctx.lr = 0x825DB148;
	sub_82DF2188(ctx, base);
	// 825DB148: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB14C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825DB150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB154: 419AFFBC  beq cr6, 0x825db110
	if ctx.cr[6].eq {
	pc = 0x825DB110; continue 'dispatch;
	}
	// 825DB158: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DB15C: 48BCD058  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB160 size=84
    let mut pc: u32 = 0x825DB160;
    'dispatch: loop {
        match pc {
            0x825DB160 => {
    //   block [0x825DB160..0x825DB1B4)
	// 825DB160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DB168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DB16C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DB174: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB178: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB17C: 4BFFFF6D  bl 0x825db0e8
	ctx.lr = 0x825DB180;
	sub_825DB0E8(ctx, base);
	// 825DB180: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DB188: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825DB18C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825DB190: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB194: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB198: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB19C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825DB1A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DB1A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DB1A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DB1AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DB1B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB1B8 size=548
    let mut pc: u32 = 0x825DB1B8;
    'dispatch: loop {
        match pc {
            0x825DB1B8 => {
    //   block [0x825DB1B8..0x825DB3DC)
	// 825DB1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB1BC: 48BCCFA5  bl 0x831a8160
	ctx.lr = 0x825DB1C0;
	sub_831A8130(ctx, base);
	// 825DB1C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB1C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DB1C8: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 825DB1CC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825DB1D0: 616BCCCB  ori r11, r11, 0xcccb
	ctx.r[11].u64 = ctx.r[11].u64 | 52427;
	// 825DB1D4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825DB1D8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB1DC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825DB1E0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825DB1E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB1E8: 41980048  blt cr6, 0x825db230
	if ctx.cr[6].lt {
	pc = 0x825DB230; continue 'dispatch;
	}
	// 825DB1EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DB1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DB1F4: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 825DB1F8: 4BCEA6D1  bl 0x822c58c8
	ctx.lr = 0x825DB1FC;
	sub_822C58C8(ctx, base);
	// 825DB1FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DB200: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DB204: 4BCEA615  bl 0x822c5818
	ctx.lr = 0x825DB208;
	sub_822C5818(ctx, base);
	// 825DB208: 4BCE90A9  bl 0x822c42b0
	ctx.lr = 0x825DB20C;
	sub_822C42B0(ctx, base);
	// 825DB20C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DB210: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DB214: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 825DB218: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825DB21C: 4BCEA255  bl 0x822c5470
	ctx.lr = 0x825DB220;
	sub_822C5470(ctx, base);
	// 825DB220: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DB224: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DB228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DB22C: 4BCE9AB5  bl 0x822c4ce0
	ctx.lr = 0x825DB230;
	sub_822C4CE0(ctx, base);
	// 825DB230: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB234: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825DB238: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825DB23C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825DB240: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DB244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB248: 4BFFFE29  bl 0x825db070
	ctx.lr = 0x825DB24C;
	sub_825DB070(ctx, base);
	// 825DB24C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB250: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB254: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DB258: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DB25C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB260: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DB264: 409A0018  bne cr6, 0x825db27c
	if !ctx.cr[6].eq {
	pc = 0x825DB27C; continue 'dispatch;
	}
	// 825DB268: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825DB26C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB270: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825DB274: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB278: 4800003C  b 0x825db2b4
	pc = 0x825DB2B4; continue 'dispatch;
	// 825DB27C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DB280: 41820020  beq 0x825db2a0
	if ctx.cr[0].eq {
	pc = 0x825DB2A0; continue 'dispatch;
	}
	// 825DB284: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825DB288: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB28C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB290: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DB294: 409A0024  bne cr6, 0x825db2b8
	if !ctx.cr[6].eq {
	pc = 0x825DB2B8; continue 'dispatch;
	}
	// 825DB298: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825DB29C: 4800001C  b 0x825db2b8
	pc = 0x825DB2B8; continue 'dispatch;
	// 825DB2A0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825DB2A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB2A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB2AC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DB2B0: 409A0008  bne cr6, 0x825db2b8
	if !ctx.cr[6].eq {
	pc = 0x825DB2B8; continue 'dispatch;
	}
	// 825DB2B4: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825DB2B8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB2BC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825DB2C0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825DB2C4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825DB2C8: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB2CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB2D0: 409A00F0  bne cr6, 0x825db3c0
	if !ctx.cr[6].eq {
	pc = 0x825DB3C0; continue 'dispatch;
	}
	// 825DB2D4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825DB2D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB2DC: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB2E0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB2E4: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825DB2E8: 409A0054  bne cr6, 0x825db33c
	if !ctx.cr[6].eq {
	pc = 0x825DB33C; continue 'dispatch;
	}
	// 825DB2EC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB2F0: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB2F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825DB2F8: 419A0054  beq cr6, 0x825db34c
	if ctx.cr[6].eq {
	pc = 0x825DB34C; continue 'dispatch;
	}
	// 825DB2FC: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB300: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB304: 409A0010  bne cr6, 0x825db314
	if !ctx.cr[6].eq {
	pc = 0x825DB314; continue 'dispatch;
	}
	// 825DB308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB30C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DB310: 4BE78E09  bl 0x82454118
	ctx.lr = 0x825DB314;
	sub_82454118(ctx, base);
	// 825DB314: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB31C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB320: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB328: 9B6B0020  stb r27, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 825DB32C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB330: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB334: 481EDD75  bl 0x827c90a8
	ctx.lr = 0x825DB338;
	sub_827C90A8(ctx, base);
	// 825DB338: 48000074  b 0x825db3ac
	pc = 0x825DB3AC; continue 'dispatch;
	// 825DB33C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB340: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB344: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825DB348: 409A0028  bne cr6, 0x825db370
	if !ctx.cr[6].eq {
	pc = 0x825DB370; continue 'dispatch;
	}
	// 825DB34C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB350: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB354: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB358: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB35C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB360: 9B6A0020  stb r27, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 825DB364: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB368: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB36C: 48000040  b 0x825db3ac
	pc = 0x825DB3AC; continue 'dispatch;
	// 825DB370: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB374: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB378: 409A0010  bne cr6, 0x825db388
	if !ctx.cr[6].eq {
	pc = 0x825DB388; continue 'dispatch;
	}
	// 825DB37C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB380: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DB384: 481EDD25  bl 0x827c90a8
	ctx.lr = 0x825DB388;
	sub_827C90A8(ctx, base);
	// 825DB388: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB38C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB390: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB394: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB398: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB39C: 9B6B0020  stb r27, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 825DB3A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB3A4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB3A8: 4BE78D71  bl 0x82454118
	ctx.lr = 0x825DB3AC;
	sub_82454118(ctx, base);
	// 825DB3AC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB3B0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DB3B4: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB3B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB3BC: 419AFF1C  beq cr6, 0x825db2d8
	if ctx.cr[6].eq {
	pc = 0x825DB2D8; continue 'dispatch;
	}
	// 825DB3C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB3C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DB3C8: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825DB3CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB3D0: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB3D4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825DB3D8: 48BCCDD8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB3E0 size=1044
    let mut pc: u32 = 0x825DB3E0;
    'dispatch: loop {
        match pc {
            0x825DB3E0 => {
    //   block [0x825DB3E0..0x825DB7F4)
	// 825DB3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB3E4: 48BCCD75  bl 0x831a8158
	ctx.lr = 0x825DB3E8;
	sub_831A8130(ctx, base);
	// 825DB3E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB3EC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DB3F0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825DB3F4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825DB3F8: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 825DB3FC: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB404: 419A0048  beq cr6, 0x825db44c
	if ctx.cr[6].eq {
	pc = 0x825DB44C; continue 'dispatch;
	}
	// 825DB408: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DB40C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DB410: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 825DB414: 4BCEA4B5  bl 0x822c58c8
	ctx.lr = 0x825DB418;
	sub_822C58C8(ctx, base);
	// 825DB418: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DB41C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DB420: 4BCEEA91  bl 0x822c9eb0
	ctx.lr = 0x825DB424;
	sub_822C9EB0(ctx, base);
	// 825DB424: 4BCE8E8D  bl 0x822c42b0
	ctx.lr = 0x825DB428;
	sub_822C42B0(ctx, base);
	// 825DB428: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DB42C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DB430: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 825DB434: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825DB438: 4BCEA039  bl 0x822c5470
	ctx.lr = 0x825DB43C;
	sub_822C5470(ctx, base);
	// 825DB43C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825DB440: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825DB444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DB448: 4BCE9899  bl 0x822c4ce0
	ctx.lr = 0x825DB44C;
	sub_822C4CE0(ctx, base);
	// 825DB44C: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 825DB450: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 825DB454: 481EDBDD  bl 0x827c9030
	ctx.lr = 0x825DB458;
	sub_827C9030(ctx, base);
	// 825DB458: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB45C: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB464: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825DB468: 419A000C  beq cr6, 0x825db474
	if ctx.cr[6].eq {
	pc = 0x825DB474; continue 'dispatch;
	}
	// 825DB46C: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB470: 48000028  b 0x825db498
	pc = 0x825DB498; continue 'dispatch;
	// 825DB474: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB478: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB47C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB480: 419A000C  beq cr6, 0x825db48c
	if ctx.cr[6].eq {
	pc = 0x825DB48C; continue 'dispatch;
	}
	// 825DB484: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 825DB488: 48000010  b 0x825db498
	pc = 0x825DB498; continue 'dispatch;
	// 825DB48C: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB490: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825DB494: 409A00DC  bne cr6, 0x825db570
	if !ctx.cr[6].eq {
	pc = 0x825DB570; continue 'dispatch;
	}
	// 825DB498: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB49C: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB4A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB4A4: 409A0008  bne cr6, 0x825db4ac
	if !ctx.cr[6].eq {
	pc = 0x825DB4AC; continue 'dispatch;
	}
	// 825DB4A8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DB4AC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB4B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB4B4: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825DB4B8: 409A000C  bne cr6, 0x825db4c4
	if !ctx.cr[6].eq {
	pc = 0x825DB4C4; continue 'dispatch;
	}
	// 825DB4BC: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825DB4C0: 4800001C  b 0x825db4dc
	pc = 0x825DB4DC; continue 'dispatch;
	// 825DB4C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB4C8: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825DB4CC: 409A000C  bne cr6, 0x825db4d8
	if !ctx.cr[6].eq {
	pc = 0x825DB4D8; continue 'dispatch;
	}
	// 825DB4D0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825DB4D4: 48000008  b 0x825db4dc
	pc = 0x825DB4DC; continue 'dispatch;
	// 825DB4D8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825DB4DC: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB4E0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB4E4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825DB4E8: 409A003C  bne cr6, 0x825db524
	if !ctx.cr[6].eq {
	pc = 0x825DB524; continue 'dispatch;
	}
	// 825DB4EC: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB4F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB4F4: 419A000C  beq cr6, 0x825db500
	if ctx.cr[6].eq {
	pc = 0x825DB500; continue 'dispatch;
	}
	// 825DB4F8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 825DB4FC: 48000024  b 0x825db520
	pc = 0x825DB520; continue 'dispatch;
	// 825DB500: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB504: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825DB508: 4800000C  b 0x825db514
	pc = 0x825DB514; continue 'dispatch;
	// 825DB50C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825DB510: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB514: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB518: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825DB51C: 419AFFF0  beq cr6, 0x825db50c
	if ctx.cr[6].eq {
	pc = 0x825DB50C; continue 'dispatch;
	}
	// 825DB520: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DB524: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB528: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB52C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825DB530: 409A00D4  bne cr6, 0x825db604
	if !ctx.cr[6].eq {
	pc = 0x825DB604; continue 'dispatch;
	}
	// 825DB534: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB53C: 419A000C  beq cr6, 0x825db548
	if ctx.cr[6].eq {
	pc = 0x825DB548; continue 'dispatch;
	}
	// 825DB540: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 825DB544: 48000024  b 0x825db568
	pc = 0x825DB568; continue 'dispatch;
	// 825DB548: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB54C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825DB550: 4800000C  b 0x825db55c
	pc = 0x825DB55C; continue 'dispatch;
	// 825DB554: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825DB558: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB55C: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB560: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825DB564: 419AFFF0  beq cr6, 0x825db554
	if ctx.cr[6].eq {
	pc = 0x825DB554; continue 'dispatch;
	}
	// 825DB568: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825DB56C: 48000098  b 0x825db604
	pc = 0x825DB604; continue 'dispatch;
	// 825DB570: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825DB574: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB578: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DB57C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB580: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB584: 409A000C  bne cr6, 0x825db590
	if !ctx.cr[6].eq {
	pc = 0x825DB590; continue 'dispatch;
	}
	// 825DB588: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 825DB58C: 4800002C  b 0x825db5b8
	pc = 0x825DB5B8; continue 'dispatch;
	// 825DB590: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB594: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB59C: 409A0008  bne cr6, 0x825db5a4
	if !ctx.cr[6].eq {
	pc = 0x825DB5A4; continue 'dispatch;
	}
	// 825DB5A0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DB5A4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825DB5A8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB5AC: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825DB5B0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB5B4: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825DB5B8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB5BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB5C0: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825DB5C4: 409A000C  bne cr6, 0x825db5d0
	if !ctx.cr[6].eq {
	pc = 0x825DB5D0; continue 'dispatch;
	}
	// 825DB5C8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825DB5CC: 48000020  b 0x825db5ec
	pc = 0x825DB5EC; continue 'dispatch;
	// 825DB5D0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB5D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB5D8: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825DB5DC: 409A000C  bne cr6, 0x825db5e8
	if !ctx.cr[6].eq {
	pc = 0x825DB5E8; continue 'dispatch;
	}
	// 825DB5E0: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825DB5E4: 48000008  b 0x825db5ec
	pc = 0x825DB5EC; continue 'dispatch;
	// 825DB5E8: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825DB5EC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB5F0: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DB5F4: 897B0020  lbz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB5F8: 89590020  lbz r10, 0x20(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB5FC: 99790020  stb r11, 0x20(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 825DB600: 995B0020  stb r10, 0x20(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 825DB604: 897B0020  lbz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB608: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825DB60C: 409A0198  bne cr6, 0x825db7a4
	if !ctx.cr[6].eq {
	pc = 0x825DB7A4; continue 'dispatch;
	}
	// 825DB610: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB614: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825DB618: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB61C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB620: 419A0180  beq cr6, 0x825db7a0
	if ctx.cr[6].eq {
	pc = 0x825DB7A0; continue 'dispatch;
	}
	// 825DB624: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DB628: 897C0020  lbz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB62C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825DB630: 409A0170  bne cr6, 0x825db7a0
	if !ctx.cr[6].eq {
	pc = 0x825DB7A0; continue 'dispatch;
	}
	// 825DB634: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB638: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB63C: 409A00A8  bne cr6, 0x825db6e4
	if !ctx.cr[6].eq {
	pc = 0x825DB6E4; continue 'dispatch;
	}
	// 825DB640: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB644: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB648: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB64C: 409A001C  bne cr6, 0x825db668
	if !ctx.cr[6].eq {
	pc = 0x825DB668; continue 'dispatch;
	}
	// 825DB650: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB658: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB65C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DB660: 4BE78AB9  bl 0x82454118
	ctx.lr = 0x825DB664;
	sub_82454118(ctx, base);
	// 825DB664: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB668: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB66C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB670: 409A00C8  bne cr6, 0x825db738
	if !ctx.cr[6].eq {
	pc = 0x825DB738; continue 'dispatch;
	}
	// 825DB674: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB678: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB67C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825DB680: 409A0014  bne cr6, 0x825db694
	if !ctx.cr[6].eq {
	pc = 0x825DB694; continue 'dispatch;
	}
	// 825DB684: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB688: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB68C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825DB690: 419A00A4  beq cr6, 0x825db734
	if ctx.cr[6].eq {
	pc = 0x825DB734; continue 'dispatch;
	}
	// 825DB694: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB698: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB69C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825DB6A0: 409A0020  bne cr6, 0x825db6c0
	if !ctx.cr[6].eq {
	pc = 0x825DB6C0; continue 'dispatch;
	}
	// 825DB6A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB6A8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825DB6AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DB6B0: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB6B4: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB6B8: 481ED9F1  bl 0x827c90a8
	ctx.lr = 0x825DB6BC;
	sub_827C90A8(ctx, base);
	// 825DB6BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB6C0: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB6C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB6C8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DB6CC: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 825DB6D0: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB6D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB6D8: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB6DC: 4BE78A3D  bl 0x82454118
	ctx.lr = 0x825DB6E0;
	sub_82454118(ctx, base);
	// 825DB6E0: 480000C0  b 0x825db7a0
	pc = 0x825DB7A0; continue 'dispatch;
	// 825DB6E4: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB6E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB6EC: 409A001C  bne cr6, 0x825db708
	if !ctx.cr[6].eq {
	pc = 0x825DB708; continue 'dispatch;
	}
	// 825DB6F0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB6F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB6F8: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB6FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DB700: 481ED9A9  bl 0x827c90a8
	ctx.lr = 0x825DB704;
	sub_827C90A8(ctx, base);
	// 825DB704: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB708: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DB70C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825DB710: 409A0028  bne cr6, 0x825db738
	if !ctx.cr[6].eq {
	pc = 0x825DB738; continue 'dispatch;
	}
	// 825DB714: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB718: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB71C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825DB720: 409A0034  bne cr6, 0x825db754
	if !ctx.cr[6].eq {
	pc = 0x825DB754; continue 'dispatch;
	}
	// 825DB724: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB728: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB72C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825DB730: 409A0024  bne cr6, 0x825db754
	if !ctx.cr[6].eq {
	pc = 0x825DB754; continue 'dispatch;
	}
	// 825DB734: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB738: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB73C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825DB740: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB744: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB748: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB74C: 409AFEDC  bne cr6, 0x825db628
	if !ctx.cr[6].eq {
	pc = 0x825DB628; continue 'dispatch;
	}
	// 825DB750: 48000050  b 0x825db7a0
	pc = 0x825DB7A0; continue 'dispatch;
	// 825DB754: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB758: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB75C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825DB760: 409A0020  bne cr6, 0x825db780
	if !ctx.cr[6].eq {
	pc = 0x825DB780; continue 'dispatch;
	}
	// 825DB764: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB768: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825DB76C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DB770: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB774: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 825DB778: 4BE789A1  bl 0x82454118
	ctx.lr = 0x825DB77C;
	sub_82454118(ctx, base);
	// 825DB77C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB780: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825DB784: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB788: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825DB78C: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 825DB790: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB794: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB798: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB79C: 481ED90D  bl 0x827c90a8
	ctx.lr = 0x825DB7A0;
	sub_827C90A8(ctx, base);
	// 825DB7A0: 9BDC0020  stb r30, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825DB7A4: 807B001C  lwz r3, 0x1c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 825DB7A8: 3BFB000C  addi r31, r27, 0xc
	ctx.r[31].s64 = ctx.r[27].s64 + 12;
	// 825DB7AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DB7B0: 419A0008  beq cr6, 0x825db7b8
	if ctx.cr[6].eq {
	pc = 0x825DB7B8; continue 'dispatch;
	}
	// 825DB7B4: 4BCE50DD  bl 0x822c0890
	ctx.lr = 0x825DB7B8;
	sub_822C0890(ctx, base);
	// 825DB7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DB7BC: 4BFFEF55  bl 0x825da710
	ctx.lr = 0x825DB7C0;
	sub_825DA710(ctx, base);
	// 825DB7C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DB7C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825DB7C8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825DB7CC: 488169BD  bl 0x82df2188
	ctx.lr = 0x825DB7D0;
	sub_82DF2188(ctx, base);
	// 825DB7D0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB7D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB7D8: 419A000C  beq cr6, 0x825db7e4
	if ctx.cr[6].eq {
	pc = 0x825DB7E4; continue 'dispatch;
	}
	// 825DB7DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825DB7E0: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825DB7E4: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825DB7E8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825DB7EC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825DB7F0: 48BCC9B8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB7F8 size=396
    let mut pc: u32 = 0x825DB7F8;
    'dispatch: loop {
        match pc {
            0x825DB7F8 => {
    //   block [0x825DB7F8..0x825DB984)
	// 825DB7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB7FC: 48BCC965  bl 0x831a8160
	ctx.lr = 0x825DB800;
	sub_831A8130(ctx, base);
	// 825DB800: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB804: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DB808: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825DB80C: 4BFFDAED  bl 0x825d92f8
	ctx.lr = 0x825DB810;
	sub_825D92F8(ctx, base);
	// 825DB810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB814: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DB818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DB81C: 4E800421  bctrl
	ctx.lr = 0x825DB820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DB820: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825DB824: 41820158  beq 0x825db97c
	if ctx.cr[0].eq {
	pc = 0x825DB97C; continue 'dispatch;
	}
	// 825DB828: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DB82C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825DB830: 3B4BED20  addi r26, r11, -0x12e0
	ctx.r[26].s64 = ctx.r[11].s64 + -4832;
	// 825DB834: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825DB838: 419A0128  beq cr6, 0x825db960
	if ctx.cr[6].eq {
	pc = 0x825DB960; continue 'dispatch;
	}
	// 825DB83C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB844: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DB848: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DB84C: 4E800421  bctrl
	ctx.lr = 0x825DB850;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DB850: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 825DB854: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825DB858: 409A0108  bne cr6, 0x825db960
	if !ctx.cr[6].eq {
	pc = 0x825DB960; continue 'dispatch;
	}
	// 825DB85C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB864: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DB86C: 4E800421  bctrl
	ctx.lr = 0x825DB870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DB870: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 825DB874: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825DB878: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DB87C: 9B610068  stb r27, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u8 ) };
	// 825DB880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DB884: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB888: 4BFFF691  bl 0x825daf18
	ctx.lr = 0x825DB88C;
	sub_825DAF18(ctx, base);
	// 825DB88C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB890: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DB894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DB898: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DB89C: 419A00BC  beq cr6, 0x825db958
	if ctx.cr[6].eq {
	pc = 0x825DB958; continue 'dispatch;
	}
	// 825DB8A0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825DB8A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DB8A8: 38A000F3  li r5, 0xf3
	ctx.r[5].s64 = 243;
	// 825DB8AC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825DB8B0: 4BCE4B29  bl 0x822c03d8
	ctx.lr = 0x825DB8B4;
	sub_822C03D8(ctx, base);
	// 825DB8B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DB8B8: 41820014  beq 0x825db8cc
	if ctx.cr[0].eq {
	pc = 0x825DB8CC; continue 'dispatch;
	}
	// 825DB8BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DB8C0: 4BFFDDC1  bl 0x825d9680
	ctx.lr = 0x825DB8C4;
	sub_825D9680(ctx, base);
	// 825DB8C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DB8C8: 48000008  b 0x825db8d0
	pc = 0x825DB8D0; continue 'dispatch;
	// 825DB8CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825DB8D0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825DB8D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB8D8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825DB8DC: 4BFFCE2D  bl 0x825d8708
	ctx.lr = 0x825DB8E0;
	sub_825D8708(ctx, base);
	// 825DB8E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DB8E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB8E8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825DB8EC: 4BCE4715  bl 0x822c0000
	ctx.lr = 0x825DB8F0;
	sub_822C0000(ctx, base);
	// 825DB8F0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB8F4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 825DB8F8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825DB8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB900: 419A0030  beq cr6, 0x825db930
	if ctx.cr[6].eq {
	pc = 0x825DB930; continue 'dispatch;
	}
	// 825DB904: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825DB908: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825DB90C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DB910: 419A0020  beq cr6, 0x825db930
	if ctx.cr[6].eq {
	pc = 0x825DB930; continue 'dispatch;
	}
	// 825DB914: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DB918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB91C: 4BFD5FAD  bl 0x825b18c8
	ctx.lr = 0x825DB920;
	sub_825B18C8(ctx, base);
	// 825DB920: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DB924: 41820024  beq 0x825db948
	if ctx.cr[0].eq {
	pc = 0x825DB948; continue 'dispatch;
	}
	// 825DB928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DB92C: 48000008  b 0x825db934
	pc = 0x825DB934; continue 'dispatch;
	// 825DB930: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DB934: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 825DB938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB93C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DB940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DB944: 4E800421  bctrl
	ctx.lr = 0x825DB948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DB948: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DB94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DB950: 419A0008  beq cr6, 0x825db958
	if ctx.cr[6].eq {
	pc = 0x825DB958; continue 'dispatch;
	}
	// 825DB954: 4BCE4F3D  bl 0x822c0890
	ctx.lr = 0x825DB958;
	sub_822C0890(ctx, base);
	// 825DB958: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DB95C: 4BFFEDB5  bl 0x825da710
	ctx.lr = 0x825DB960;
	sub_825DA710(ctx, base);
	// 825DB960: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB964: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DB968: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825DB96C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825DB970: 4E800421  bctrl
	ctx.lr = 0x825DB974;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825DB974: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825DB978: 4082FEBC  bne 0x825db834
	if !ctx.cr[0].eq {
	pc = 0x825DB834; continue 'dispatch;
	}
	// 825DB97C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825DB980: 48BCC830  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB988 size=88
    let mut pc: u32 = 0x825DB988;
    'dispatch: loop {
        match pc {
            0x825DB988 => {
    //   block [0x825DB988..0x825DB9E0)
	// 825DB988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DB990: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DB994: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB998: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825DB99C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DB9A0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825DB9A4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825DB9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DB9AC: 4BFFDDFD  bl 0x825d97a8
	ctx.lr = 0x825DB9B0;
	sub_825D97A8(ctx, base);
	// 825DB9B0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825DB9B4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DB9B8: 4BFD5F11  bl 0x825b18c8
	ctx.lr = 0x825DB9BC;
	sub_825B18C8(ctx, base);
	// 825DB9BC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DB9C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DB9C4: 419A0008  beq cr6, 0x825db9cc
	if ctx.cr[6].eq {
	pc = 0x825DB9CC; continue 'dispatch;
	}
	// 825DB9C8: 4BCE4EC9  bl 0x822c0890
	ctx.lr = 0x825DB9CC;
	sub_822C0890(ctx, base);
	// 825DB9CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DB9D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DB9D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DB9D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DB9DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DB9E0 size=8
    let mut pc: u32 = 0x825DB9E0;
    'dispatch: loop {
        match pc {
            0x825DB9E0 => {
    //   block [0x825DB9E0..0x825DB9E8)
	// 825DB9E0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DB9E4: 4BFFF77C  b 0x825db160
	sub_825DB160(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DB9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DB9E8 size=240
    let mut pc: u32 = 0x825DB9E8;
    'dispatch: loop {
        match pc {
            0x825DB9E8 => {
    //   block [0x825DB9E8..0x825DBAD8)
	// 825DB9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DB9EC: 48BCC771  bl 0x831a815c
	ctx.lr = 0x825DB9F0;
	sub_831A8130(ctx, base);
	// 825DB9F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DB9F4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825DB9F8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825DB9FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DBA00: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825DBA04: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 825DBA08: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBA0C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBA10: 48000030  b 0x825dba40
	pc = 0x825DBA40; continue 'dispatch;
	// 825DBA14: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBA18: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 825DBA1C: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBA20: 489F5FA9  bl 0x82fd19c8
	ctx.lr = 0x825DBA24;
	sub_82FD19C8(ctx, base);
	// 825DBA24: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 825DBA28: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825DBA2C: 557CDFFF  rlwinm. r28, r11, 0x1b, 0x1f, 0x1f
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825DBA30: 4182000C  beq 0x825dba3c
	if ctx.cr[0].eq {
	pc = 0x825DBA3C; continue 'dispatch;
	}
	// 825DBA34: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBA38: 48000008  b 0x825dba40
	pc = 0x825DBA40; continue 'dispatch;
	// 825DBA3C: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825DBA40: 897D0021  lbz r11, 0x21(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(33 as u32) ) } as u64;
	// 825DBA44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DBA48: 419AFFCC  beq cr6, 0x825dba14
	if ctx.cr[6].eq {
	pc = 0x825DBA14; continue 'dispatch;
	}
	// 825DBA4C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 825DBA50: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DBA54: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825DBA58: 41820048  beq 0x825dbaa0
	if ctx.cr[0].eq {
	pc = 0x825DBAA0; continue 'dispatch;
	}
	// 825DBA5C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBA64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBA68: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DBA6C: 409A002C  bne cr6, 0x825dba98
	if !ctx.cr[6].eq {
	pc = 0x825DBA98; continue 'dispatch;
	}
	// 825DBA70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DBA74: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825DBA78: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825DBA7C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825DBA80: 4BFFF739  bl 0x825db1b8
	ctx.lr = 0x825DBA84;
	sub_825DB1B8(ctx, base);
	// 825DBA84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825DBA88: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 825DBA8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBA90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DBA94: 48000038  b 0x825dbacc
	pc = 0x825DBACC; continue 'dispatch;
	// 825DBA98: 485B28C1  bl 0x82b8e358
	ctx.lr = 0x825DBA9C;
	sub_82B8E358(ctx, base);
	// 825DBA9C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DBAA0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBAA4: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825DBAA8: 489F5F21  bl 0x82fd19c8
	ctx.lr = 0x825DBAAC;
	sub_82FD19C8(ctx, base);
	// 825DBAAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 825DBAB0: 40800010  bge 0x825dbac0
	if !ctx.cr[0].lt {
	pc = 0x825DBAC0; continue 'dispatch;
	}
	// 825DBAB4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825DBAB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBABC: 4BFFFFB8  b 0x825dba74
	pc = 0x825DBA74; continue 'dispatch;
	// 825DBAC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DBAC4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825DBAC8: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825DBACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DBAD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825DBAD4: 48BCC6D8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBAD8 size=132
    let mut pc: u32 = 0x825DBAD8;
    'dispatch: loop {
        match pc {
            0x825DBAD8 => {
    //   block [0x825DBAD8..0x825DBB5C)
	// 825DBAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBADC: 48BCC68D  bl 0x831a8168
	ctx.lr = 0x825DBAE0;
	sub_831A8130(ctx, base);
	// 825DBAE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBAE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DBAE8: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 825DBAEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825DBAF0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825DBAF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBAF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBAFC: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825DBB00: 409A0044  bne cr6, 0x825dbb44
	if !ctx.cr[6].eq {
	pc = 0x825DBB44; continue 'dispatch;
	}
	// 825DBB04: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825DBB08: 409A003C  bne cr6, 0x825dbb44
	if !ctx.cr[6].eq {
	pc = 0x825DBB44; continue 'dispatch;
	}
	// 825DBB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DBB10: 4BFFF651  bl 0x825db160
	ctx.lr = 0x825DBB14;
	sub_825DB160(ctx, base);
	// 825DBB14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBB18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBB1C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DBB20: 48000030  b 0x825dbb50
	pc = 0x825DBB50; continue 'dispatch;
	// 825DBB24: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825DBB28: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825DBB2C: 481ED505  bl 0x827c9030
	ctx.lr = 0x825DBB30;
	sub_827C9030(ctx, base);
	// 825DBB30: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825DBB34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBB38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBB3C: 4BFFF8A5  bl 0x825db3e0
	ctx.lr = 0x825DBB40;
	sub_825DB3E0(ctx, base);
	// 825DBB40: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825DBB44: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825DBB48: 409AFFDC  bne cr6, 0x825dbb24
	if !ctx.cr[6].eq {
	pc = 0x825DBB24; continue 'dispatch;
	}
	// 825DBB4C: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825DBB50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825DBB54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DBB58: 48BCC660  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBB60 size=340
    let mut pc: u32 = 0x825DBB60;
    'dispatch: loop {
        match pc {
            0x825DBB60 => {
    //   block [0x825DBB60..0x825DBCB4)
	// 825DBB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBB64: 48BCC605  bl 0x831a8168
	ctx.lr = 0x825DBB68;
	sub_831A8130(ctx, base);
	// 825DBB68: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBB6C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825DBB70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBB74: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DBB78: 48817E91  bl 0x82df3a08
	ctx.lr = 0x825DBB7C;
	sub_82DF3A08(ctx, base);
	// 825DBB7C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825DBB80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBB84: 4881854D  bl 0x82df40d0
	ctx.lr = 0x825DBB88;
	sub_82DF40D0(ctx, base);
	// 825DBB88: 3FE08212  lis r31, -0x7dee
	ctx.r[31].s64 = -2112749568;
	// 825DBB8C: 817FB230  lwz r11, -0x4dd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825DBB90: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DBB94: 419A0044  beq cr6, 0x825dbbd8
	if ctx.cr[6].eq {
	pc = 0x825DBBD8; continue 'dispatch;
	}
	// 825DBB98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBB9C: 3BCBEB48  addi r30, r11, -0x14b8
	ctx.r[30].s64 = ctx.r[11].s64 + -5304;
	// 825DBBA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DBBA4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825DBBA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825DBBAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBBB0: 48818611  bl 0x82df41c0
	ctx.lr = 0x825DBBB4;
	sub_82DF41C0(ctx, base);
	// 825DBBB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DBBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBBBC: 48818015  bl 0x82df3bd0
	ctx.lr = 0x825DBBC0;
	sub_82DF3BD0(ctx, base);
	// 825DBBC0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825DBBC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBBC8: 48818509  bl 0x82df40d0
	ctx.lr = 0x825DBBCC;
	sub_82DF40D0(ctx, base);
	// 825DBBCC: 817FB230  lwz r11, -0x4dd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 825DBBD0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825DBBD4: 409AFFCC  bne cr6, 0x825dbba0
	if !ctx.cr[6].eq {
	pc = 0x825DBBA0; continue 'dispatch;
	}
	// 825DBBD8: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DBBDC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBBE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DBBE4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825DBBE8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825DBBEC: 419A0024  beq cr6, 0x825dbc10
	if ctx.cr[6].eq {
	pc = 0x825DBC10; continue 'dispatch;
	}
	// 825DBBF0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825DBBF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DBBF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DBBFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DBC00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DBC04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DBC08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DBC0C: 4082FFE8  bne 0x825dbbf4
	if !ctx.cr[0].eq {
	pc = 0x825DBBF4; continue 'dispatch;
	}
	// 825DBC10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBC14: 4881759D  bl 0x82df31b0
	ctx.lr = 0x825DBC18;
	sub_82DF31B0(ctx, base);
	// 825DBC18: 489F57D9  bl 0x82fd13f0
	ctx.lr = 0x825DBC1C;
	sub_82FD13F0(ctx, base);
	// 825DBC1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DBC20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825DBC24: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 825DBC28: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825DBC2C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825DBC30: 99410068  stb r10, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 825DBC34: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825DBC38: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825DBC3C: 4BFFF1DD  bl 0x825dae18
	ctx.lr = 0x825DBC40;
	sub_825DAE18(ctx, base);
	// 825DBC40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DBC44: 4BFFEACD  bl 0x825da710
	ctx.lr = 0x825DBC48;
	sub_825DA710(ctx, base);
	// 825DBC48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DBC4C: 419A000C  beq cr6, 0x825dbc58
	if ctx.cr[6].eq {
	pc = 0x825DBC58; continue 'dispatch;
	}
	// 825DBC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DBC54: 4BCE4C3D  bl 0x822c0890
	ctx.lr = 0x825DBC58;
	sub_822C0890(ctx, base);
	// 825DBC58: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825DBC5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DBC60: 4BFFF151  bl 0x825dadb0
	ctx.lr = 0x825DBC64;
	sub_825DADB0(ctx, base);
	// 825DBC64: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825DBC68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DBC6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DBC70: 4BFFFD79  bl 0x825db9e8
	ctx.lr = 0x825DBC74;
	sub_825DB9E8(ctx, base);
	// 825DBC74: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825DBC78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DBC7C: 419A0008  beq cr6, 0x825dbc84
	if ctx.cr[6].eq {
	pc = 0x825DBC84; continue 'dispatch;
	}
	// 825DBC80: 4BCE4C11  bl 0x822c0890
	ctx.lr = 0x825DBC84;
	sub_822C0890(ctx, base);
	// 825DBC84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825DBC88: 4BFFEA89  bl 0x825da710
	ctx.lr = 0x825DBC8C;
	sub_825DA710(ctx, base);
	// 825DBC8C: 806100A0  lwz r3, 0xa0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825DBC90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DBC94: 419A0008  beq cr6, 0x825dbc9c
	if ctx.cr[6].eq {
	pc = 0x825DBC9C; continue 'dispatch;
	}
	// 825DBC98: 4BCE4BF9  bl 0x822c0890
	ctx.lr = 0x825DBC9C;
	sub_822C0890(ctx, base);
	// 825DBC9C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825DBCA0: 4BFFEA71  bl 0x825da710
	ctx.lr = 0x825DBCA4;
	sub_825DA710(ctx, base);
	// 825DBCA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DBCA8: 48817781  bl 0x82df3428
	ctx.lr = 0x825DBCAC;
	sub_82DF3428(ctx, base);
	// 825DBCAC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825DBCB0: 48BCC508  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBCB8 size=156
    let mut pc: u32 = 0x825DBCB8;
    'dispatch: loop {
        match pc {
            0x825DBCB8 => {
    //   block [0x825DBCB8..0x825DBD54)
	// 825DBCB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBCBC: 48BCC4B1  bl 0x831a816c
	ctx.lr = 0x825DBCC0;
	sub_831A8130(ctx, base);
	// 825DBCC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBCC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBCC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DBCCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DBCD0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DBCD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DBCD8: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DBCDC: 38A00154  li r5, 0x154
	ctx.r[5].s64 = 340;
	// 825DBCE0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DBCE4: 4BCE46F5  bl 0x822c03d8
	ctx.lr = 0x825DBCE8;
	sub_822C03D8(ctx, base);
	// 825DBCE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DBCEC: 4182001C  beq 0x825dbd08
	if ctx.cr[0].eq {
	pc = 0x825DBD08; continue 'dispatch;
	}
	// 825DBCF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBCF4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DBCF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DBCFC: 396BEC44  addi r11, r11, -0x13bc
	ctx.r[11].s64 = ctx.r[11].s64 + -5052;
	// 825DBD00: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DBD04: 48000008  b 0x825dbd0c
	pc = 0x825DBD0C; continue 'dispatch;
	// 825DBD08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DBD0C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DBD10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBD14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBD18: 4BFFED29  bl 0x825daa40
	ctx.lr = 0x825DBD1C;
	sub_825DAA40(ctx, base);
	// 825DBD1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DBD20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBD24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBD28: 4BCE42D9  bl 0x822c0000
	ctx.lr = 0x825DBD2C;
	sub_822C0000(ctx, base);
	// 825DBD2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DBD30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DBD34: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBD38: 4BFFFE29  bl 0x825dbb60
	ctx.lr = 0x825DBD3C;
	sub_825DBB60(ctx, base);
	// 825DBD3C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DBD40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DBD44: 419A0008  beq cr6, 0x825dbd4c
	if ctx.cr[6].eq {
	pc = 0x825DBD4C; continue 'dispatch;
	}
	// 825DBD48: 4BCE4B49  bl 0x822c0890
	ctx.lr = 0x825DBD4C;
	sub_822C0890(ctx, base);
	// 825DBD4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DBD50: 48BCC46C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBD58 size=156
    let mut pc: u32 = 0x825DBD58;
    'dispatch: loop {
        match pc {
            0x825DBD58 => {
    //   block [0x825DBD58..0x825DBDF4)
	// 825DBD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBD5C: 48BCC411  bl 0x831a816c
	ctx.lr = 0x825DBD60;
	sub_831A8130(ctx, base);
	// 825DBD60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBD64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBD68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DBD6C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DBD70: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DBD74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DBD78: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DBD7C: 38A00167  li r5, 0x167
	ctx.r[5].s64 = 359;
	// 825DBD80: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DBD84: 4BCE4655  bl 0x822c03d8
	ctx.lr = 0x825DBD88;
	sub_822C03D8(ctx, base);
	// 825DBD88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DBD8C: 4182001C  beq 0x825dbda8
	if ctx.cr[0].eq {
	pc = 0x825DBDA8; continue 'dispatch;
	}
	// 825DBD90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBD94: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DBD98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DBD9C: 396BEC54  addi r11, r11, -0x13ac
	ctx.r[11].s64 = ctx.r[11].s64 + -5036;
	// 825DBDA0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DBDA4: 48000008  b 0x825dbdac
	pc = 0x825DBDAC; continue 'dispatch;
	// 825DBDA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DBDAC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DBDB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBDB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBDB8: 4BFFEC89  bl 0x825daa40
	ctx.lr = 0x825DBDBC;
	sub_825DAA40(ctx, base);
	// 825DBDBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DBDC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBDC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBDC8: 4BCE4239  bl 0x822c0000
	ctx.lr = 0x825DBDCC;
	sub_822C0000(ctx, base);
	// 825DBDCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DBDD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DBDD4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBDD8: 4BFFFD89  bl 0x825dbb60
	ctx.lr = 0x825DBDDC;
	sub_825DBB60(ctx, base);
	// 825DBDDC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DBDE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DBDE4: 419A0008  beq cr6, 0x825dbdec
	if ctx.cr[6].eq {
	pc = 0x825DBDEC; continue 'dispatch;
	}
	// 825DBDE8: 4BCE4AA9  bl 0x822c0890
	ctx.lr = 0x825DBDEC;
	sub_822C0890(ctx, base);
	// 825DBDEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DBDF0: 48BCC3CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBDF8 size=156
    let mut pc: u32 = 0x825DBDF8;
    'dispatch: loop {
        match pc {
            0x825DBDF8 => {
    //   block [0x825DBDF8..0x825DBE94)
	// 825DBDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBDFC: 48BCC371  bl 0x831a816c
	ctx.lr = 0x825DBE00;
	sub_831A8130(ctx, base);
	// 825DBE00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBE04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBE08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DBE0C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DBE10: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DBE14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DBE18: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DBE1C: 38A00183  li r5, 0x183
	ctx.r[5].s64 = 387;
	// 825DBE20: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DBE24: 4BCE45B5  bl 0x822c03d8
	ctx.lr = 0x825DBE28;
	sub_822C03D8(ctx, base);
	// 825DBE28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DBE2C: 4182001C  beq 0x825dbe48
	if ctx.cr[0].eq {
	pc = 0x825DBE48; continue 'dispatch;
	}
	// 825DBE30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBE34: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DBE38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DBE3C: 396BEC64  addi r11, r11, -0x139c
	ctx.r[11].s64 = ctx.r[11].s64 + -5020;
	// 825DBE40: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DBE44: 48000008  b 0x825dbe4c
	pc = 0x825DBE4C; continue 'dispatch;
	// 825DBE48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DBE4C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DBE50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBE54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBE58: 4BFFEBE9  bl 0x825daa40
	ctx.lr = 0x825DBE5C;
	sub_825DAA40(ctx, base);
	// 825DBE5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DBE60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBE64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBE68: 4BCE4199  bl 0x822c0000
	ctx.lr = 0x825DBE6C;
	sub_822C0000(ctx, base);
	// 825DBE6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DBE70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DBE74: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBE78: 4BFFFCE9  bl 0x825dbb60
	ctx.lr = 0x825DBE7C;
	sub_825DBB60(ctx, base);
	// 825DBE7C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DBE80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DBE84: 419A0008  beq cr6, 0x825dbe8c
	if ctx.cr[6].eq {
	pc = 0x825DBE8C; continue 'dispatch;
	}
	// 825DBE88: 4BCE4A09  bl 0x822c0890
	ctx.lr = 0x825DBE8C;
	sub_822C0890(ctx, base);
	// 825DBE8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DBE90: 48BCC32C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBE98 size=156
    let mut pc: u32 = 0x825DBE98;
    'dispatch: loop {
        match pc {
            0x825DBE98 => {
    //   block [0x825DBE98..0x825DBF34)
	// 825DBE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBE9C: 48BCC2D1  bl 0x831a816c
	ctx.lr = 0x825DBEA0;
	sub_831A8130(ctx, base);
	// 825DBEA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBEA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBEA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DBEAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DBEB0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DBEB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DBEB8: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DBEBC: 38A00196  li r5, 0x196
	ctx.r[5].s64 = 406;
	// 825DBEC0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DBEC4: 4BCE4515  bl 0x822c03d8
	ctx.lr = 0x825DBEC8;
	sub_822C03D8(ctx, base);
	// 825DBEC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DBECC: 4182001C  beq 0x825dbee8
	if ctx.cr[0].eq {
	pc = 0x825DBEE8; continue 'dispatch;
	}
	// 825DBED0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBED4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DBED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DBEDC: 396BEC74  addi r11, r11, -0x138c
	ctx.r[11].s64 = ctx.r[11].s64 + -5004;
	// 825DBEE0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DBEE4: 48000008  b 0x825dbeec
	pc = 0x825DBEEC; continue 'dispatch;
	// 825DBEE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DBEEC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DBEF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBEF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBEF8: 4BFFEB49  bl 0x825daa40
	ctx.lr = 0x825DBEFC;
	sub_825DAA40(ctx, base);
	// 825DBEFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DBF00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBF04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBF08: 4BCE40F9  bl 0x822c0000
	ctx.lr = 0x825DBF0C;
	sub_822C0000(ctx, base);
	// 825DBF0C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DBF10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DBF14: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBF18: 4BFFFC49  bl 0x825dbb60
	ctx.lr = 0x825DBF1C;
	sub_825DBB60(ctx, base);
	// 825DBF1C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DBF20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DBF24: 419A0008  beq cr6, 0x825dbf2c
	if ctx.cr[6].eq {
	pc = 0x825DBF2C; continue 'dispatch;
	}
	// 825DBF28: 4BCE4969  bl 0x822c0890
	ctx.lr = 0x825DBF2C;
	sub_822C0890(ctx, base);
	// 825DBF2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DBF30: 48BCC28C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBF38 size=156
    let mut pc: u32 = 0x825DBF38;
    'dispatch: loop {
        match pc {
            0x825DBF38 => {
    //   block [0x825DBF38..0x825DBFD4)
	// 825DBF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBF3C: 48BCC231  bl 0x831a816c
	ctx.lr = 0x825DBF40;
	sub_831A8130(ctx, base);
	// 825DBF40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBF44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBF48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DBF4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DBF50: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DBF54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DBF58: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DBF5C: 38A001BB  li r5, 0x1bb
	ctx.r[5].s64 = 443;
	// 825DBF60: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DBF64: 4BCE4475  bl 0x822c03d8
	ctx.lr = 0x825DBF68;
	sub_822C03D8(ctx, base);
	// 825DBF68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DBF6C: 4182001C  beq 0x825dbf88
	if ctx.cr[0].eq {
	pc = 0x825DBF88; continue 'dispatch;
	}
	// 825DBF70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBF74: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DBF78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DBF7C: 396BEC84  addi r11, r11, -0x137c
	ctx.r[11].s64 = ctx.r[11].s64 + -4988;
	// 825DBF80: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DBF84: 48000008  b 0x825dbf8c
	pc = 0x825DBF8C; continue 'dispatch;
	// 825DBF88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DBF8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DBF90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBF94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBF98: 4BFFEAA9  bl 0x825daa40
	ctx.lr = 0x825DBF9C;
	sub_825DAA40(ctx, base);
	// 825DBF9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DBFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DBFA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DBFA8: 4BCE4059  bl 0x822c0000
	ctx.lr = 0x825DBFAC;
	sub_822C0000(ctx, base);
	// 825DBFAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DBFB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DBFB4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DBFB8: 4BFFFBA9  bl 0x825dbb60
	ctx.lr = 0x825DBFBC;
	sub_825DBB60(ctx, base);
	// 825DBFBC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DBFC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DBFC4: 419A0008  beq cr6, 0x825dbfcc
	if ctx.cr[6].eq {
	pc = 0x825DBFCC; continue 'dispatch;
	}
	// 825DBFC8: 4BCE48C9  bl 0x822c0890
	ctx.lr = 0x825DBFCC;
	sub_822C0890(ctx, base);
	// 825DBFCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DBFD0: 48BCC1EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DBFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DBFD8 size=156
    let mut pc: u32 = 0x825DBFD8;
    'dispatch: loop {
        match pc {
            0x825DBFD8 => {
    //   block [0x825DBFD8..0x825DC074)
	// 825DBFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DBFDC: 48BCC191  bl 0x831a816c
	ctx.lr = 0x825DBFE0;
	sub_831A8130(ctx, base);
	// 825DBFE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DBFE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DBFE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DBFEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DBFF0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DBFF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DBFF8: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DBFFC: 38A001E2  li r5, 0x1e2
	ctx.r[5].s64 = 482;
	// 825DC000: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC004: 4BCE43D5  bl 0x822c03d8
	ctx.lr = 0x825DC008;
	sub_822C03D8(ctx, base);
	// 825DC008: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC00C: 4182001C  beq 0x825dc028
	if ctx.cr[0].eq {
	pc = 0x825DC028; continue 'dispatch;
	}
	// 825DC010: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC014: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC01C: 396BEC10  addi r11, r11, -0x13f0
	ctx.r[11].s64 = ctx.r[11].s64 + -5104;
	// 825DC020: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC024: 48000008  b 0x825dc02c
	pc = 0x825DC02C; continue 'dispatch;
	// 825DC028: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC02C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC030: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC034: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC038: 4BFFEA09  bl 0x825daa40
	ctx.lr = 0x825DC03C;
	sub_825DAA40(ctx, base);
	// 825DC03C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC040: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC044: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC048: 4BCE3FB9  bl 0x822c0000
	ctx.lr = 0x825DC04C;
	sub_822C0000(ctx, base);
	// 825DC04C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC050: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC054: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC058: 4BFFFB09  bl 0x825dbb60
	ctx.lr = 0x825DC05C;
	sub_825DBB60(ctx, base);
	// 825DC05C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC064: 419A0008  beq cr6, 0x825dc06c
	if ctx.cr[6].eq {
	pc = 0x825DC06C; continue 'dispatch;
	}
	// 825DC068: 4BCE4829  bl 0x822c0890
	ctx.lr = 0x825DC06C;
	sub_822C0890(ctx, base);
	// 825DC06C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC070: 48BCC14C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC078 size=156
    let mut pc: u32 = 0x825DC078;
    'dispatch: loop {
        match pc {
            0x825DC078 => {
    //   block [0x825DC078..0x825DC114)
	// 825DC078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC07C: 48BCC0F1  bl 0x831a816c
	ctx.lr = 0x825DC080;
	sub_831A8130(ctx, base);
	// 825DC080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC084: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC088: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC08C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC090: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC094: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC098: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC09C: 38A00204  li r5, 0x204
	ctx.r[5].s64 = 516;
	// 825DC0A0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC0A4: 4BCE4335  bl 0x822c03d8
	ctx.lr = 0x825DC0A8;
	sub_822C03D8(ctx, base);
	// 825DC0A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC0AC: 4182001C  beq 0x825dc0c8
	if ctx.cr[0].eq {
	pc = 0x825DC0C8; continue 'dispatch;
	}
	// 825DC0B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC0B4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC0B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC0BC: 396BEC94  addi r11, r11, -0x136c
	ctx.r[11].s64 = ctx.r[11].s64 + -4972;
	// 825DC0C0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC0C4: 48000008  b 0x825dc0cc
	pc = 0x825DC0CC; continue 'dispatch;
	// 825DC0C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC0CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC0D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC0D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC0D8: 4BFFE969  bl 0x825daa40
	ctx.lr = 0x825DC0DC;
	sub_825DAA40(ctx, base);
	// 825DC0DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC0E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC0E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC0E8: 4BCE3F19  bl 0x822c0000
	ctx.lr = 0x825DC0EC;
	sub_822C0000(ctx, base);
	// 825DC0EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC0F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC0F4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC0F8: 4BFFFA69  bl 0x825dbb60
	ctx.lr = 0x825DC0FC;
	sub_825DBB60(ctx, base);
	// 825DC0FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC100: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC104: 419A0008  beq cr6, 0x825dc10c
	if ctx.cr[6].eq {
	pc = 0x825DC10C; continue 'dispatch;
	}
	// 825DC108: 4BCE4789  bl 0x822c0890
	ctx.lr = 0x825DC10C;
	sub_822C0890(ctx, base);
	// 825DC10C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC110: 48BCC0AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC118 size=156
    let mut pc: u32 = 0x825DC118;
    'dispatch: loop {
        match pc {
            0x825DC118 => {
    //   block [0x825DC118..0x825DC1B4)
	// 825DC118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC11C: 48BCC051  bl 0x831a816c
	ctx.lr = 0x825DC120;
	sub_831A8130(ctx, base);
	// 825DC120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC124: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC128: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC12C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC130: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC134: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC138: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC13C: 38A0022A  li r5, 0x22a
	ctx.r[5].s64 = 554;
	// 825DC140: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC144: 4BCE4295  bl 0x822c03d8
	ctx.lr = 0x825DC148;
	sub_822C03D8(ctx, base);
	// 825DC148: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC14C: 4182001C  beq 0x825dc168
	if ctx.cr[0].eq {
	pc = 0x825DC168; continue 'dispatch;
	}
	// 825DC150: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC154: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC15C: 396BECA4  addi r11, r11, -0x135c
	ctx.r[11].s64 = ctx.r[11].s64 + -4956;
	// 825DC160: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC164: 48000008  b 0x825dc16c
	pc = 0x825DC16C; continue 'dispatch;
	// 825DC168: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC16C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC174: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC178: 4BFFE8C9  bl 0x825daa40
	ctx.lr = 0x825DC17C;
	sub_825DAA40(ctx, base);
	// 825DC17C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC184: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC188: 4BCE3E79  bl 0x822c0000
	ctx.lr = 0x825DC18C;
	sub_822C0000(ctx, base);
	// 825DC18C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC190: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC194: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC198: 4BFFF9C9  bl 0x825dbb60
	ctx.lr = 0x825DC19C;
	sub_825DBB60(ctx, base);
	// 825DC19C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC1A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC1A4: 419A0008  beq cr6, 0x825dc1ac
	if ctx.cr[6].eq {
	pc = 0x825DC1AC; continue 'dispatch;
	}
	// 825DC1A8: 4BCE46E9  bl 0x822c0890
	ctx.lr = 0x825DC1AC;
	sub_822C0890(ctx, base);
	// 825DC1AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC1B0: 48BCC00C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC1B8 size=156
    let mut pc: u32 = 0x825DC1B8;
    'dispatch: loop {
        match pc {
            0x825DC1B8 => {
    //   block [0x825DC1B8..0x825DC254)
	// 825DC1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC1BC: 48BCBFB1  bl 0x831a816c
	ctx.lr = 0x825DC1C0;
	sub_831A8130(ctx, base);
	// 825DC1C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC1C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC1C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC1CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC1D0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC1D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC1D8: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC1DC: 38A00250  li r5, 0x250
	ctx.r[5].s64 = 592;
	// 825DC1E0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC1E4: 4BCE41F5  bl 0x822c03d8
	ctx.lr = 0x825DC1E8;
	sub_822C03D8(ctx, base);
	// 825DC1E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC1EC: 4182001C  beq 0x825dc208
	if ctx.cr[0].eq {
	pc = 0x825DC208; continue 'dispatch;
	}
	// 825DC1F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC1F4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC1F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC1FC: 396BEC20  addi r11, r11, -0x13e0
	ctx.r[11].s64 = ctx.r[11].s64 + -5088;
	// 825DC200: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC204: 48000008  b 0x825dc20c
	pc = 0x825DC20C; continue 'dispatch;
	// 825DC208: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC20C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC214: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC218: 4BFFE829  bl 0x825daa40
	ctx.lr = 0x825DC21C;
	sub_825DAA40(ctx, base);
	// 825DC21C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC224: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC228: 4BCE3DD9  bl 0x822c0000
	ctx.lr = 0x825DC22C;
	sub_822C0000(ctx, base);
	// 825DC22C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC230: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC234: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC238: 4BFFF929  bl 0x825dbb60
	ctx.lr = 0x825DC23C;
	sub_825DBB60(ctx, base);
	// 825DC23C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC240: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC244: 419A0008  beq cr6, 0x825dc24c
	if ctx.cr[6].eq {
	pc = 0x825DC24C; continue 'dispatch;
	}
	// 825DC248: 4BCE4649  bl 0x822c0890
	ctx.lr = 0x825DC24C;
	sub_822C0890(ctx, base);
	// 825DC24C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC250: 48BCBF6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC258 size=156
    let mut pc: u32 = 0x825DC258;
    'dispatch: loop {
        match pc {
            0x825DC258 => {
    //   block [0x825DC258..0x825DC2F4)
	// 825DC258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC25C: 48BCBF11  bl 0x831a816c
	ctx.lr = 0x825DC260;
	sub_831A8130(ctx, base);
	// 825DC260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC264: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC268: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC26C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC270: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC274: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC278: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC27C: 38A0029F  li r5, 0x29f
	ctx.r[5].s64 = 671;
	// 825DC280: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC284: 4BCE4155  bl 0x822c03d8
	ctx.lr = 0x825DC288;
	sub_822C03D8(ctx, base);
	// 825DC288: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC28C: 4182001C  beq 0x825dc2a8
	if ctx.cr[0].eq {
	pc = 0x825DC2A8; continue 'dispatch;
	}
	// 825DC290: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC294: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC29C: 396BECB4  addi r11, r11, -0x134c
	ctx.r[11].s64 = ctx.r[11].s64 + -4940;
	// 825DC2A0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC2A4: 48000008  b 0x825dc2ac
	pc = 0x825DC2AC; continue 'dispatch;
	// 825DC2A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC2AC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC2B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC2B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC2B8: 4BFFE789  bl 0x825daa40
	ctx.lr = 0x825DC2BC;
	sub_825DAA40(ctx, base);
	// 825DC2BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC2C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC2C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC2C8: 4BCE3D39  bl 0x822c0000
	ctx.lr = 0x825DC2CC;
	sub_822C0000(ctx, base);
	// 825DC2CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC2D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC2D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC2D8: 4BFFF889  bl 0x825dbb60
	ctx.lr = 0x825DC2DC;
	sub_825DBB60(ctx, base);
	// 825DC2DC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC2E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC2E4: 419A0008  beq cr6, 0x825dc2ec
	if ctx.cr[6].eq {
	pc = 0x825DC2EC; continue 'dispatch;
	}
	// 825DC2E8: 4BCE45A9  bl 0x822c0890
	ctx.lr = 0x825DC2EC;
	sub_822C0890(ctx, base);
	// 825DC2EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC2F0: 48BCBECC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC2F8 size=156
    let mut pc: u32 = 0x825DC2F8;
    'dispatch: loop {
        match pc {
            0x825DC2F8 => {
    //   block [0x825DC2F8..0x825DC394)
	// 825DC2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC2FC: 48BCBE71  bl 0x831a816c
	ctx.lr = 0x825DC300;
	sub_831A8130(ctx, base);
	// 825DC300: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC304: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC308: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC30C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC310: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC314: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC318: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC31C: 38A002AB  li r5, 0x2ab
	ctx.r[5].s64 = 683;
	// 825DC320: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC324: 4BCE40B5  bl 0x822c03d8
	ctx.lr = 0x825DC328;
	sub_822C03D8(ctx, base);
	// 825DC328: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC32C: 4182001C  beq 0x825dc348
	if ctx.cr[0].eq {
	pc = 0x825DC348; continue 'dispatch;
	}
	// 825DC330: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC334: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC338: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC33C: 396BECC4  addi r11, r11, -0x133c
	ctx.r[11].s64 = ctx.r[11].s64 + -4924;
	// 825DC340: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC344: 48000008  b 0x825dc34c
	pc = 0x825DC34C; continue 'dispatch;
	// 825DC348: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC34C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC354: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC358: 4BFFE6E9  bl 0x825daa40
	ctx.lr = 0x825DC35C;
	sub_825DAA40(ctx, base);
	// 825DC35C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC364: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC368: 4BCE3C99  bl 0x822c0000
	ctx.lr = 0x825DC36C;
	sub_822C0000(ctx, base);
	// 825DC36C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC370: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC374: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC378: 4BFFF7E9  bl 0x825dbb60
	ctx.lr = 0x825DC37C;
	sub_825DBB60(ctx, base);
	// 825DC37C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC384: 419A0008  beq cr6, 0x825dc38c
	if ctx.cr[6].eq {
	pc = 0x825DC38C; continue 'dispatch;
	}
	// 825DC388: 4BCE4509  bl 0x822c0890
	ctx.lr = 0x825DC38C;
	sub_822C0890(ctx, base);
	// 825DC38C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC390: 48BCBE2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC398 size=156
    let mut pc: u32 = 0x825DC398;
    'dispatch: loop {
        match pc {
            0x825DC398 => {
    //   block [0x825DC398..0x825DC434)
	// 825DC398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC39C: 48BCBDD1  bl 0x831a816c
	ctx.lr = 0x825DC3A0;
	sub_831A8130(ctx, base);
	// 825DC3A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC3A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC3A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC3AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC3B0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC3B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC3B8: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC3BC: 38A002B7  li r5, 0x2b7
	ctx.r[5].s64 = 695;
	// 825DC3C0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC3C4: 4BCE4015  bl 0x822c03d8
	ctx.lr = 0x825DC3C8;
	sub_822C03D8(ctx, base);
	// 825DC3C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC3CC: 4182001C  beq 0x825dc3e8
	if ctx.cr[0].eq {
	pc = 0x825DC3E8; continue 'dispatch;
	}
	// 825DC3D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC3D4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC3D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC3DC: 396BECD4  addi r11, r11, -0x132c
	ctx.r[11].s64 = ctx.r[11].s64 + -4908;
	// 825DC3E0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC3E4: 48000008  b 0x825dc3ec
	pc = 0x825DC3EC; continue 'dispatch;
	// 825DC3E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC3EC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC3F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC3F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC3F8: 4BFFE649  bl 0x825daa40
	ctx.lr = 0x825DC3FC;
	sub_825DAA40(ctx, base);
	// 825DC3FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC404: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC408: 4BCE3BF9  bl 0x822c0000
	ctx.lr = 0x825DC40C;
	sub_822C0000(ctx, base);
	// 825DC40C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC410: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC414: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC418: 4BFFF749  bl 0x825dbb60
	ctx.lr = 0x825DC41C;
	sub_825DBB60(ctx, base);
	// 825DC41C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC420: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC424: 419A0008  beq cr6, 0x825dc42c
	if ctx.cr[6].eq {
	pc = 0x825DC42C; continue 'dispatch;
	}
	// 825DC428: 4BCE4469  bl 0x822c0890
	ctx.lr = 0x825DC42C;
	sub_822C0890(ctx, base);
	// 825DC42C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC430: 48BCBD8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC438 size=156
    let mut pc: u32 = 0x825DC438;
    'dispatch: loop {
        match pc {
            0x825DC438 => {
    //   block [0x825DC438..0x825DC4D4)
	// 825DC438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC43C: 48BCBD31  bl 0x831a816c
	ctx.lr = 0x825DC440;
	sub_831A8130(ctx, base);
	// 825DC440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC444: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC448: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC44C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC450: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC454: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC458: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC45C: 38A002CF  li r5, 0x2cf
	ctx.r[5].s64 = 719;
	// 825DC460: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC464: 4BCE3F75  bl 0x822c03d8
	ctx.lr = 0x825DC468;
	sub_822C03D8(ctx, base);
	// 825DC468: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC46C: 4182001C  beq 0x825dc488
	if ctx.cr[0].eq {
	pc = 0x825DC488; continue 'dispatch;
	}
	// 825DC470: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC474: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC47C: 396BECE4  addi r11, r11, -0x131c
	ctx.r[11].s64 = ctx.r[11].s64 + -4892;
	// 825DC480: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC484: 48000008  b 0x825dc48c
	pc = 0x825DC48C; continue 'dispatch;
	// 825DC488: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC48C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC494: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC498: 4BFFE5A9  bl 0x825daa40
	ctx.lr = 0x825DC49C;
	sub_825DAA40(ctx, base);
	// 825DC49C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC4A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC4A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC4A8: 4BCE3B59  bl 0x822c0000
	ctx.lr = 0x825DC4AC;
	sub_822C0000(ctx, base);
	// 825DC4AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC4B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC4B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC4B8: 4BFFF6A9  bl 0x825dbb60
	ctx.lr = 0x825DC4BC;
	sub_825DBB60(ctx, base);
	// 825DC4BC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC4C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC4C4: 419A0008  beq cr6, 0x825dc4cc
	if ctx.cr[6].eq {
	pc = 0x825DC4CC; continue 'dispatch;
	}
	// 825DC4C8: 4BCE43C9  bl 0x822c0890
	ctx.lr = 0x825DC4CC;
	sub_822C0890(ctx, base);
	// 825DC4CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC4D0: 48BCBCEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC4D8 size=156
    let mut pc: u32 = 0x825DC4D8;
    'dispatch: loop {
        match pc {
            0x825DC4D8 => {
    //   block [0x825DC4D8..0x825DC574)
	// 825DC4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC4DC: 48BCBC91  bl 0x831a816c
	ctx.lr = 0x825DC4E0;
	sub_831A8130(ctx, base);
	// 825DC4E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC4E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC4E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC4EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC4F0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC4F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC4F8: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC4FC: 38A002DB  li r5, 0x2db
	ctx.r[5].s64 = 731;
	// 825DC500: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC504: 4BCE3ED5  bl 0x822c03d8
	ctx.lr = 0x825DC508;
	sub_822C03D8(ctx, base);
	// 825DC508: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC50C: 4182001C  beq 0x825dc528
	if ctx.cr[0].eq {
	pc = 0x825DC528; continue 'dispatch;
	}
	// 825DC510: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC514: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC51C: 396BECF4  addi r11, r11, -0x130c
	ctx.r[11].s64 = ctx.r[11].s64 + -4876;
	// 825DC520: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC524: 48000008  b 0x825dc52c
	pc = 0x825DC52C; continue 'dispatch;
	// 825DC528: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC52C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC534: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC538: 4BFFE509  bl 0x825daa40
	ctx.lr = 0x825DC53C;
	sub_825DAA40(ctx, base);
	// 825DC53C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC544: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC548: 4BCE3AB9  bl 0x822c0000
	ctx.lr = 0x825DC54C;
	sub_822C0000(ctx, base);
	// 825DC54C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC550: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC554: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC558: 4BFFF609  bl 0x825dbb60
	ctx.lr = 0x825DC55C;
	sub_825DBB60(ctx, base);
	// 825DC55C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC564: 419A0008  beq cr6, 0x825dc56c
	if ctx.cr[6].eq {
	pc = 0x825DC56C; continue 'dispatch;
	}
	// 825DC568: 4BCE4329  bl 0x822c0890
	ctx.lr = 0x825DC56C;
	sub_822C0890(ctx, base);
	// 825DC56C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC570: 48BCBC4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC578 size=156
    let mut pc: u32 = 0x825DC578;
    'dispatch: loop {
        match pc {
            0x825DC578 => {
    //   block [0x825DC578..0x825DC614)
	// 825DC578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC57C: 48BCBBF1  bl 0x831a816c
	ctx.lr = 0x825DC580;
	sub_831A8130(ctx, base);
	// 825DC580: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC584: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC588: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC58C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC590: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC594: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC598: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC59C: 38A0030C  li r5, 0x30c
	ctx.r[5].s64 = 780;
	// 825DC5A0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC5A4: 4BCE3E35  bl 0x822c03d8
	ctx.lr = 0x825DC5A8;
	sub_822C03D8(ctx, base);
	// 825DC5A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC5AC: 4182001C  beq 0x825dc5c8
	if ctx.cr[0].eq {
	pc = 0x825DC5C8; continue 'dispatch;
	}
	// 825DC5B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC5B4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC5B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC5BC: 396BED04  addi r11, r11, -0x12fc
	ctx.r[11].s64 = ctx.r[11].s64 + -4860;
	// 825DC5C0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC5C4: 48000008  b 0x825dc5cc
	pc = 0x825DC5CC; continue 'dispatch;
	// 825DC5C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC5CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC5D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC5D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC5D8: 4BFFE469  bl 0x825daa40
	ctx.lr = 0x825DC5DC;
	sub_825DAA40(ctx, base);
	// 825DC5DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC5E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC5E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC5E8: 4BCE3A19  bl 0x822c0000
	ctx.lr = 0x825DC5EC;
	sub_822C0000(ctx, base);
	// 825DC5EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC5F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC5F4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC5F8: 4BFFF569  bl 0x825dbb60
	ctx.lr = 0x825DC5FC;
	sub_825DBB60(ctx, base);
	// 825DC5FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC604: 419A0008  beq cr6, 0x825dc60c
	if ctx.cr[6].eq {
	pc = 0x825DC60C; continue 'dispatch;
	}
	// 825DC608: 4BCE4289  bl 0x822c0890
	ctx.lr = 0x825DC60C;
	sub_822C0890(ctx, base);
	// 825DC60C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC610: 48BCBBAC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC618 size=156
    let mut pc: u32 = 0x825DC618;
    'dispatch: loop {
        match pc {
            0x825DC618 => {
    //   block [0x825DC618..0x825DC6B4)
	// 825DC618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC61C: 48BCBB51  bl 0x831a816c
	ctx.lr = 0x825DC620;
	sub_831A8130(ctx, base);
	// 825DC620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC624: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC628: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC62C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC630: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825DC634: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC638: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC63C: 38A00332  li r5, 0x332
	ctx.r[5].s64 = 818;
	// 825DC640: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825DC644: 4BCE3D95  bl 0x822c03d8
	ctx.lr = 0x825DC648;
	sub_822C03D8(ctx, base);
	// 825DC648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DC64C: 4182001C  beq 0x825dc668
	if ctx.cr[0].eq {
	pc = 0x825DC668; continue 'dispatch;
	}
	// 825DC650: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC654: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825DC658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC65C: 396BEC30  addi r11, r11, -0x13d0
	ctx.r[11].s64 = ctx.r[11].s64 + -5072;
	// 825DC660: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC664: 48000008  b 0x825dc66c
	pc = 0x825DC66C; continue 'dispatch;
	// 825DC668: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC66C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC674: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC678: 4BFFE3C9  bl 0x825daa40
	ctx.lr = 0x825DC67C;
	sub_825DAA40(ctx, base);
	// 825DC67C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC684: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC688: 4BCE3979  bl 0x822c0000
	ctx.lr = 0x825DC68C;
	sub_822C0000(ctx, base);
	// 825DC68C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC690: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC694: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC698: 4BFFF4C9  bl 0x825dbb60
	ctx.lr = 0x825DC69C;
	sub_825DBB60(ctx, base);
	// 825DC69C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC6A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC6A4: 419A0008  beq cr6, 0x825dc6ac
	if ctx.cr[6].eq {
	pc = 0x825DC6AC; continue 'dispatch;
	}
	// 825DC6A8: 4BCE41E9  bl 0x822c0890
	ctx.lr = 0x825DC6AC;
	sub_822C0890(ctx, base);
	// 825DC6AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DC6B0: 48BCBB0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC6B8 size=172
    let mut pc: u32 = 0x825DC6B8;
    'dispatch: loop {
        match pc {
            0x825DC6B8 => {
    //   block [0x825DC6B8..0x825DC764)
	// 825DC6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC6BC: 48BCBAAD  bl 0x831a8168
	ctx.lr = 0x825DC6C0;
	sub_831A8130(ctx, base);
	// 825DC6C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC6C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC6C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC6CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DC6D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825DC6D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC6D8: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC6DC: 38A00351  li r5, 0x351
	ctx.r[5].s64 = 849;
	// 825DC6E0: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 825DC6E4: 4BCE3CF5  bl 0x822c03d8
	ctx.lr = 0x825DC6E8;
	sub_822C03D8(ctx, base);
	// 825DC6E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825DC6EC: 41820024  beq 0x825dc710
	if ctx.cr[0].eq {
	pc = 0x825DC710; continue 'dispatch;
	}
	// 825DC6F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825DC6F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DC6F8: 4BFAF819  bl 0x8258bf10
	ctx.lr = 0x825DC6FC;
	sub_8258BF10(ctx, base);
	// 825DC6FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825DC700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DC704: 4BFFE77D  bl 0x825dae80
	ctx.lr = 0x825DC708;
	sub_825DAE80(ctx, base);
	// 825DC708: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC70C: 48000008  b 0x825dc714
	pc = 0x825DC714; continue 'dispatch;
	// 825DC710: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DC714: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825DC718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC71C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC720: 4BFFE321  bl 0x825daa40
	ctx.lr = 0x825DC724;
	sub_825DAA40(ctx, base);
	// 825DC724: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825DC728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC72C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DC730: 4BCE38D1  bl 0x822c0000
	ctx.lr = 0x825DC734;
	sub_822C0000(ctx, base);
	// 825DC734: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825DC738: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DC73C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC740: 4BFFF421  bl 0x825dbb60
	ctx.lr = 0x825DC744;
	sub_825DBB60(ctx, base);
	// 825DC744: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DC748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DC74C: 419A0008  beq cr6, 0x825dc754
	if ctx.cr[6].eq {
	pc = 0x825DC754; continue 'dispatch;
	}
	// 825DC750: 4BCE4141  bl 0x822c0890
	ctx.lr = 0x825DC754;
	sub_822C0890(ctx, base);
	// 825DC754: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825DC758: 4BCEC561  bl 0x822c8cb8
	ctx.lr = 0x825DC75C;
	sub_822C8CB8(ctx, base);
	// 825DC75C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825DC760: 48BCBA58  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC768 size=88
    let mut pc: u32 = 0x825DC768;
    'dispatch: loop {
        match pc {
            0x825DC768 => {
    //   block [0x825DC768..0x825DC7C0)
	// 825DC768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DC770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DC774: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DC780: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825DC784: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DC788: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC78C: 4BFFF34D  bl 0x825dbad8
	ctx.lr = 0x825DC790;
	sub_825DBAD8(ctx, base);
	// 825DC790: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DC794: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DC798: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825DC79C: 488159ED  bl 0x82df2188
	ctx.lr = 0x825DC7A0;
	sub_82DF2188(ctx, base);
	// 825DC7A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DC7A4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DC7A8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825DC7AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DC7B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DC7B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DC7B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DC7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC7C0 size=116
    let mut pc: u32 = 0x825DC7C0;
    'dispatch: loop {
        match pc {
            0x825DC7C0 => {
    //   block [0x825DC7C0..0x825DC834)
	// 825DC7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DC7C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DC7CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DC7D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC7D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DC7D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DC7DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DC7E0: 388BED20  addi r4, r11, -0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + -4832;
	// 825DC7E4: 38A000B4  li r5, 0xb4
	ctx.r[5].s64 = 180;
	// 825DC7E8: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 825DC7EC: 48815BFD  bl 0x82df23e8
	ctx.lr = 0x825DC7F0;
	sub_82DF23E8(ctx, base);
	// 825DC7F0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825DC7F4: 4182001C  beq 0x825dc810
	if ctx.cr[0].eq {
	pc = 0x825DC810; continue 'dispatch;
	}
	// 825DC7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DC7FC: 485B2D9D  bl 0x82b8f598
	ctx.lr = 0x825DC800;
	sub_82B8F598(ctx, base);
	// 825DC800: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DC804: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825DC808: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825DC80C: 48000008  b 0x825dc814
	pc = 0x825DC814; continue 'dispatch;
	// 825DC810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DC814: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DC818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DC81C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DC820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DC824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DC828: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DC82C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DC830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DC838 size=72
    let mut pc: u32 = 0x825DC838;
    'dispatch: loop {
        match pc {
            0x825DC838 => {
    //   block [0x825DC838..0x825DC880)
	// 825DC838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC83C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DC840: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DC844: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC848: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DC84C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825DC850: 419A001C  beq cr6, 0x825dc86c
	if ctx.cr[6].eq {
	pc = 0x825DC86C; continue 'dispatch;
	}
	// 825DC854: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825DC858: 4BCEC461  bl 0x822c8cb8
	ctx.lr = 0x825DC85C;
	sub_822C8CB8(ctx, base);
	// 825DC85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DC860: 4BFFFF09  bl 0x825dc768
	ctx.lr = 0x825DC864;
	sub_825DC768(ctx, base);
	// 825DC864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DC868: 48815B71  bl 0x82df23d8
	ctx.lr = 0x825DC86C;
	sub_82DF23D8(ctx, base);
	// 825DC86C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DC870: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DC874: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DC878: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DC87C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DC880 size=188
    let mut pc: u32 = 0x825DC880;
    'dispatch: loop {
        match pc {
            0x825DC880 => {
    //   block [0x825DC880..0x825DC93C)
	// 825DC880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC884: 48BCB8E9  bl 0x831a816c
	ctx.lr = 0x825DC888;
	sub_831A8130(ctx, base);
	// 825DC888: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DC894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DC898: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DC89C: 4BFFFF25  bl 0x825dc7c0
	ctx.lr = 0x825DC8A0;
	sub_825DC7C0(ctx, base);
	// 825DC8A0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DC8A4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DC8A8: 388AED64  addi r4, r10, -0x129c
	ctx.r[4].s64 = ctx.r[10].s64 + -4764;
	// 825DC8AC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DC8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DC8B4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DC8B8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DC940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DC940 size=196
    let mut pc: u32 = 0x825DC940;
    'dispatch: loop {
        match pc {
            0x825DC940 => {
    //   block [0x825DC940..0x825DCA04)
	// 825DC940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DC944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DC948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DC94C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DC950: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DC954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DC958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DC95C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DC960: 4BFFFE61  bl 0x825dc7c0
	ctx.lr = 0x825DC964;
	sub_825DC7C0(ctx, base);
	// 825DC964: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825DC968: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825DC96C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825DC970: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825DC974: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DC978: 3889ED64  addi r4, r9, -0x129c
	ctx.r[4].s64 = ctx.r[9].s64 + -4764;
	// 825DC97C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DC980: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCA08 size=188
    let mut pc: u32 = 0x825DCA08;
    'dispatch: loop {
        match pc {
            0x825DCA08 => {
    //   block [0x825DCA08..0x825DCAC4)
	// 825DCA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCA0C: 48BCB761  bl 0x831a816c
	ctx.lr = 0x825DCA10;
	sub_831A8130(ctx, base);
	// 825DCA10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCA14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCA1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCA20: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DCA24: 4BFFFD9D  bl 0x825dc7c0
	ctx.lr = 0x825DCA28;
	sub_825DC7C0(ctx, base);
	// 825DCA28: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825DCA2C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825DCA30: 388AC028  addi r4, r10, -0x3fd8
	ctx.r[4].s64 = ctx.r[10].s64 + -16344;
	// 825DCA34: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DCA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCA3C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCA40: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCAC8 size=196
    let mut pc: u32 = 0x825DCAC8;
    'dispatch: loop {
        match pc {
            0x825DCAC8 => {
    //   block [0x825DCAC8..0x825DCB8C)
	// 825DCAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DCAD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DCAD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DCAD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCAE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCAE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCAE8: 4BFFFCD9  bl 0x825dc7c0
	ctx.lr = 0x825DCAEC;
	sub_825DC7C0(ctx, base);
	// 825DCAEC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825DCAF0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825DCAF4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825DCAF8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825DCAFC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DCB00: 3889C028  addi r4, r9, -0x3fd8
	ctx.r[4].s64 = ctx.r[9].s64 + -16344;
	// 825DCB04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCB08: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCB90 size=228
    let mut pc: u32 = 0x825DCB90;
    'dispatch: loop {
        match pc {
            0x825DCB90 => {
    //   block [0x825DCB90..0x825DCC74)
	// 825DCB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCB94: 48BCB5D9  bl 0x831a816c
	ctx.lr = 0x825DCB98;
	sub_831A8130(ctx, base);
	// 825DCB98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCB9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCBA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCBA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCBA8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DCBAC: 4BFFFC15  bl 0x825dc7c0
	ctx.lr = 0x825DCBB0;
	sub_825DC7C0(ctx, base);
	// 825DCBB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825DCBB4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825DCBB8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 825DCBBC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825DCBC0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825DCBC4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCBC8: 3888ED64  addi r4, r8, -0x129c
	ctx.r[4].s64 = ctx.r[8].s64 + -4764;
	// 825DCBCC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825DCBD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCBD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCBD8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCBDC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825DCBE0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825DCBE4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825DCBE8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825DCBEC: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825DCBF0: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCC78 size=232
    let mut pc: u32 = 0x825DCC78;
    'dispatch: loop {
        match pc {
            0x825DCC78 => {
    //   block [0x825DCC78..0x825DCD60)
	// 825DCC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DCC80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DCC84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DCC88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCC8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCC90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCC94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCC98: 4BFFFB29  bl 0x825dc7c0
	ctx.lr = 0x825DCC9C;
	sub_825DC7C0(ctx, base);
	// 825DCC9C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825DCCA0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825DCCA4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825DCCA8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825DCCAC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825DCCB0: 3889ED64  addi r4, r9, -0x129c
	ctx.r[4].s64 = ctx.r[9].s64 + -4764;
	// 825DCCB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCCB8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCD60 size=208
    let mut pc: u32 = 0x825DCD60;
    'dispatch: loop {
        match pc {
            0x825DCD60 => {
    //   block [0x825DCD60..0x825DCE30)
	// 825DCD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCD64: 48BCB409  bl 0x831a816c
	ctx.lr = 0x825DCD68;
	sub_831A8130(ctx, base);
	// 825DCD68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCD70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCD74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCD78: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DCD7C: 4BFFFA45  bl 0x825dc7c0
	ctx.lr = 0x825DCD80;
	sub_825DC7C0(ctx, base);
	// 825DCD80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCD84: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DCD88: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 825DCD8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCD90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCD94: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCD98: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825DCD9C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCDA0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825DCDA4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCDA8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825DCDAC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCDB0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825DCDB4: 4BFFF0E5  bl 0x825dbe98
	ctx.lr = 0x825DCDB8;
	sub_825DBE98(ctx, base);
	// 825DCDB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCDBC: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 825DCDC0: 388BED60  addi r4, r11, -0x12a0
	ctx.r[4].s64 = ctx.r[11].s64 + -4768;
	// 825DCDC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCDC8: 4BFFF0D1  bl 0x825dbe98
	ctx.lr = 0x825DCDCC;
	sub_825DBE98(ctx, base);
	// 825DCDCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCDD0: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 825DCDD4: 388BED5C  addi r4, r11, -0x12a4
	ctx.r[4].s64 = ctx.r[11].s64 + -4772;
	// 825DCDD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCDDC: 4BFFF0BD  bl 0x825dbe98
	ctx.lr = 0x825DCDE0;
	sub_825DBE98(ctx, base);
	// 825DCDE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCDE4: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 825DCDE8: 388BED58  addi r4, r11, -0x12a8
	ctx.r[4].s64 = ctx.r[11].s64 + -4776;
	// 825DCDEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCDF0: 4BFFF0A9  bl 0x825dbe98
	ctx.lr = 0x825DCDF4;
	sub_825DBE98(ctx, base);
	// 825DCDF4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DCDF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DCDFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCE00: 4BFFC9A9  bl 0x825d97a8
	ctx.lr = 0x825DCE04;
	sub_825D97A8(ctx, base);
	// 825DCE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCE08: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DCE0C: 4BFFE17D  bl 0x825daf88
	ctx.lr = 0x825DCE10;
	sub_825DAF88(ctx, base);
	// 825DCE10: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DCE14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DCE18: 419A0008  beq cr6, 0x825dce20
	if ctx.cr[6].eq {
	pc = 0x825DCE20; continue 'dispatch;
	}
	// 825DCE1C: 4BCE3A75  bl 0x822c0890
	ctx.lr = 0x825DCE20;
	sub_822C0890(ctx, base);
	// 825DCE20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCE24: 4BFFFA15  bl 0x825dc838
	ctx.lr = 0x825DCE28;
	sub_825DC838(ctx, base);
	// 825DCE28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DCE2C: 48BCB390  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCE30 size=196
    let mut pc: u32 = 0x825DCE30;
    'dispatch: loop {
        match pc {
            0x825DCE30 => {
    //   block [0x825DCE30..0x825DCEF4)
	// 825DCE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DCE38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DCE3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DCE40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCE44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCE48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCE4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCE50: 4BFFF971  bl 0x825dc7c0
	ctx.lr = 0x825DCE54;
	sub_825DC7C0(ctx, base);
	// 825DCE54: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCE58: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DCE5C: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 825DCE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCE64: 4BFFF035  bl 0x825dbe98
	ctx.lr = 0x825DCE68;
	sub_825DBE98(ctx, base);
	// 825DCE68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCE6C: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 825DCE70: 388BED60  addi r4, r11, -0x12a0
	ctx.r[4].s64 = ctx.r[11].s64 + -4768;
	// 825DCE74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCE78: 4BFFF021  bl 0x825dbe98
	ctx.lr = 0x825DCE7C;
	sub_825DBE98(ctx, base);
	// 825DCE7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCE80: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 825DCE84: 388BED5C  addi r4, r11, -0x12a4
	ctx.r[4].s64 = ctx.r[11].s64 + -4772;
	// 825DCE88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCE8C: 4BFFF00D  bl 0x825dbe98
	ctx.lr = 0x825DCE90;
	sub_825DBE98(ctx, base);
	// 825DCE90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCE94: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 825DCE98: 388BED58  addi r4, r11, -0x12a8
	ctx.r[4].s64 = ctx.r[11].s64 + -4776;
	// 825DCE9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCEA0: 4BFFEFF9  bl 0x825dbe98
	ctx.lr = 0x825DCEA4;
	sub_825DBE98(ctx, base);
	// 825DCEA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DCEA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCEAC: 4BFFE94D  bl 0x825db7f8
	ctx.lr = 0x825DCEB0;
	sub_825DB7F8(ctx, base);
	// 825DCEB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCEB4: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCEB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCEBC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DCEC0: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCEC4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DCEC8: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCECC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825DCED0: C001006C  lfs f0, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCED4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825DCED8: 4BFFF961  bl 0x825dc838
	ctx.lr = 0x825DCEDC;
	sub_825DC838(ctx, base);
	// 825DCEDC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DCEE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DCEE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DCEE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DCEEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DCEF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCEF8 size=208
    let mut pc: u32 = 0x825DCEF8;
    'dispatch: loop {
        match pc {
            0x825DCEF8 => {
    //   block [0x825DCEF8..0x825DCFC8)
	// 825DCEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCEFC: 48BCB271  bl 0x831a816c
	ctx.lr = 0x825DCF00;
	sub_831A8130(ctx, base);
	// 825DCF00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCF04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCF08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCF0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCF10: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DCF14: 4BFFF8AD  bl 0x825dc7c0
	ctx.lr = 0x825DCF18;
	sub_825DC7C0(ctx, base);
	// 825DCF18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCF1C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DCF20: 388BC028  addi r4, r11, -0x3fd8
	ctx.r[4].s64 = ctx.r[11].s64 + -16344;
	// 825DCF24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCF28: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DCF2C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCF30: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825DCF34: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCF38: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825DCF3C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCF40: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825DCF44: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DCF48: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825DCF4C: 4BFFEF4D  bl 0x825dbe98
	ctx.lr = 0x825DCF50;
	sub_825DBE98(ctx, base);
	// 825DCF50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCF54: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 825DCF58: 388BC024  addi r4, r11, -0x3fdc
	ctx.r[4].s64 = ctx.r[11].s64 + -16348;
	// 825DCF5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCF60: 4BFFEF39  bl 0x825dbe98
	ctx.lr = 0x825DCF64;
	sub_825DBE98(ctx, base);
	// 825DCF64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCF68: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 825DCF6C: 388BC020  addi r4, r11, -0x3fe0
	ctx.r[4].s64 = ctx.r[11].s64 + -16352;
	// 825DCF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCF74: 4BFFEF25  bl 0x825dbe98
	ctx.lr = 0x825DCF78;
	sub_825DBE98(ctx, base);
	// 825DCF78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCF7C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 825DCF80: 388BED68  addi r4, r11, -0x1298
	ctx.r[4].s64 = ctx.r[11].s64 + -4760;
	// 825DCF84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCF88: 4BFFEF11  bl 0x825dbe98
	ctx.lr = 0x825DCF8C;
	sub_825DBE98(ctx, base);
	// 825DCF8C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DCF90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DCF94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DCF98: 4BFFC811  bl 0x825d97a8
	ctx.lr = 0x825DCF9C;
	sub_825D97A8(ctx, base);
	// 825DCF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCFA0: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DCFA4: 4BFFDFE5  bl 0x825daf88
	ctx.lr = 0x825DCFA8;
	sub_825DAF88(ctx, base);
	// 825DCFA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DCFAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DCFB0: 419A0008  beq cr6, 0x825dcfb8
	if ctx.cr[6].eq {
	pc = 0x825DCFB8; continue 'dispatch;
	}
	// 825DCFB4: 4BCE38DD  bl 0x822c0890
	ctx.lr = 0x825DCFB8;
	sub_822C0890(ctx, base);
	// 825DCFB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCFBC: 4BFFF87D  bl 0x825dc838
	ctx.lr = 0x825DCFC0;
	sub_825DC838(ctx, base);
	// 825DCFC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DCFC4: 48BCB1F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DCFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825DCFC8 size=196
    let mut pc: u32 = 0x825DCFC8;
    'dispatch: loop {
        match pc {
            0x825DCFC8 => {
    //   block [0x825DCFC8..0x825DD08C)
	// 825DCFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DCFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DCFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DCFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DCFD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DCFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DCFE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCFE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DCFE8: 4BFFF7D9  bl 0x825dc7c0
	ctx.lr = 0x825DCFEC;
	sub_825DC7C0(ctx, base);
	// 825DCFEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DCFF0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825DCFF4: 388BC028  addi r4, r11, -0x3fd8
	ctx.r[4].s64 = ctx.r[11].s64 + -16344;
	// 825DCFF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DCFFC: 4BFFEE9D  bl 0x825dbe98
	ctx.lr = 0x825DD000;
	sub_825DBE98(ctx, base);
	// 825DD000: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD004: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 825DD008: 388BC024  addi r4, r11, -0x3fdc
	ctx.r[4].s64 = ctx.r[11].s64 + -16348;
	// 825DD00C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD010: 4BFFEE89  bl 0x825dbe98
	ctx.lr = 0x825DD014;
	sub_825DBE98(ctx, base);
	// 825DD014: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD018: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 825DD01C: 388BC020  addi r4, r11, -0x3fe0
	ctx.r[4].s64 = ctx.r[11].s64 + -16352;
	// 825DD020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD024: 4BFFEE75  bl 0x825dbe98
	ctx.lr = 0x825DD028;
	sub_825DBE98(ctx, base);
	// 825DD028: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD02C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 825DD030: 388BED68  addi r4, r11, -0x1298
	ctx.r[4].s64 = ctx.r[11].s64 + -4760;
	// 825DD034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD038: 4BFFEE61  bl 0x825dbe98
	ctx.lr = 0x825DD03C;
	sub_825DBE98(ctx, base);
	// 825DD03C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DD040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD044: 4BFFE7B5  bl 0x825db7f8
	ctx.lr = 0x825DD048;
	sub_825DB7F8(ctx, base);
	// 825DD048: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD04C: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DD050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD054: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825DD058: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DD05C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825DD060: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DD064: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825DD068: C001006C  lfs f0, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825DD06C: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825DD070: 4BFFF7C9  bl 0x825dc838
	ctx.lr = 0x825DD074;
	sub_825DC838(ctx, base);
	// 825DD074: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DD078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD07C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD080: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DD084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD090 size=184
    let mut pc: u32 = 0x825DD090;
    'dispatch: loop {
        match pc {
            0x825DD090 => {
    //   block [0x825DD090..0x825DD148)
	// 825DD090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD094: 48BCB0D9  bl 0x831a816c
	ctx.lr = 0x825DD098;
	sub_831A8130(ctx, base);
	// 825DD098: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD09C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD0A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD0A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DD0A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DD0AC: 4BFFF715  bl 0x825dc7c0
	ctx.lr = 0x825DD0B0;
	sub_825DC7C0(ctx, base);
	// 825DD0B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD0B4: 38A10055  addi r5, r1, 0x55
	ctx.r[5].s64 = ctx.r[1].s64 + 85;
	// 825DD0B8: 388BED70  addi r4, r11, -0x1290
	ctx.r[4].s64 = ctx.r[11].s64 + -4752;
	// 825DD0BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD0C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD0C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD0C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DD0CC: 4BFFF40D  bl 0x825dc4d8
	ctx.lr = 0x825DD0D0;
	sub_825DC4D8(ctx, base);
	// 825DD0D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD0D4: 38A10056  addi r5, r1, 0x56
	ctx.r[5].s64 = ctx.r[1].s64 + 86;
	// 825DD0D8: 388BED6C  addi r4, r11, -0x1294
	ctx.r[4].s64 = ctx.r[11].s64 + -4756;
	// 825DD0DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD0E0: 4BFFF3F9  bl 0x825dc4d8
	ctx.lr = 0x825DD0E4;
	sub_825DC4D8(ctx, base);
	// 825DD0E4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825DD0E8: 38A10057  addi r5, r1, 0x57
	ctx.r[5].s64 = ctx.r[1].s64 + 87;
	// 825DD0EC: 388B2CCC  addi r4, r11, 0x2ccc
	ctx.r[4].s64 = ctx.r[11].s64 + 11468;
	// 825DD0F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD0F4: 4BFFF3E5  bl 0x825dc4d8
	ctx.lr = 0x825DD0F8;
	sub_825DC4D8(ctx, base);
	// 825DD0F8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825DD0FC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825DD100: 388B2CD0  addi r4, r11, 0x2cd0
	ctx.r[4].s64 = ctx.r[11].s64 + 11472;
	// 825DD104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD108: 4BFFF3D1  bl 0x825dc4d8
	ctx.lr = 0x825DD10C;
	sub_825DC4D8(ctx, base);
	// 825DD10C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DD110: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DD114: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DD118: 4BFFC691  bl 0x825d97a8
	ctx.lr = 0x825DD11C;
	sub_825D97A8(ctx, base);
	// 825DD11C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD120: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DD124: 4BFFDE65  bl 0x825daf88
	ctx.lr = 0x825DD128;
	sub_825DAF88(ctx, base);
	// 825DD128: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DD12C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DD130: 419A0008  beq cr6, 0x825dd138
	if ctx.cr[6].eq {
	pc = 0x825DD138; continue 'dispatch;
	}
	// 825DD134: 4BCE375D  bl 0x822c0890
	ctx.lr = 0x825DD138;
	sub_822C0890(ctx, base);
	// 825DD138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD13C: 4BFFF6FD  bl 0x825dc838
	ctx.lr = 0x825DD140;
	sub_825DC838(ctx, base);
	// 825DD140: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DD144: 48BCB078  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD148 size=172
    let mut pc: u32 = 0x825DD148;
    'dispatch: loop {
        match pc {
            0x825DD148 => {
    //   block [0x825DD148..0x825DD1F4)
	// 825DD148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD14C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DD154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD15C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD164: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DD168: 4BFFF659  bl 0x825dc7c0
	ctx.lr = 0x825DD16C;
	sub_825DC7C0(ctx, base);
	// 825DD16C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD170: 38A10055  addi r5, r1, 0x55
	ctx.r[5].s64 = ctx.r[1].s64 + 85;
	// 825DD174: 388BED70  addi r4, r11, -0x1290
	ctx.r[4].s64 = ctx.r[11].s64 + -4752;
	// 825DD178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD17C: 4BFFF35D  bl 0x825dc4d8
	ctx.lr = 0x825DD180;
	sub_825DC4D8(ctx, base);
	// 825DD180: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD184: 38A10056  addi r5, r1, 0x56
	ctx.r[5].s64 = ctx.r[1].s64 + 86;
	// 825DD188: 388BED6C  addi r4, r11, -0x1294
	ctx.r[4].s64 = ctx.r[11].s64 + -4756;
	// 825DD18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD190: 4BFFF349  bl 0x825dc4d8
	ctx.lr = 0x825DD194;
	sub_825DC4D8(ctx, base);
	// 825DD194: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825DD198: 38A10057  addi r5, r1, 0x57
	ctx.r[5].s64 = ctx.r[1].s64 + 87;
	// 825DD19C: 388B2CCC  addi r4, r11, 0x2ccc
	ctx.r[4].s64 = ctx.r[11].s64 + 11468;
	// 825DD1A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD1A4: 4BFFF335  bl 0x825dc4d8
	ctx.lr = 0x825DD1A8;
	sub_825DC4D8(ctx, base);
	// 825DD1A8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825DD1AC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825DD1B0: 388B2CD0  addi r4, r11, 0x2cd0
	ctx.r[4].s64 = ctx.r[11].s64 + 11472;
	// 825DD1B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD1B8: 4BFFF321  bl 0x825dc4d8
	ctx.lr = 0x825DD1BC;
	sub_825DC4D8(ctx, base);
	// 825DD1BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DD1C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD1C4: 4BFFE635  bl 0x825db7f8
	ctx.lr = 0x825DD1C8;
	sub_825DB7F8(ctx, base);
	// 825DD1C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD1CC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DD1D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD1D4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DD1D8: 4BFFF661  bl 0x825dc838
	ctx.lr = 0x825DD1DC;
	sub_825DC838(ctx, base);
	// 825DD1DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DD1E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD1E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD1E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DD1EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD1F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD1F8 size=184
    let mut pc: u32 = 0x825DD1F8;
    'dispatch: loop {
        match pc {
            0x825DD1F8 => {
    //   block [0x825DD1F8..0x825DD2B0)
	// 825DD1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD1FC: 48BCAF71  bl 0x831a816c
	ctx.lr = 0x825DD200;
	sub_831A8130(ctx, base);
	// 825DD200: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD20C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DD210: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DD214: 4BFFF5AD  bl 0x825dc7c0
	ctx.lr = 0x825DD218;
	sub_825DC7C0(ctx, base);
	// 825DD218: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DD21C: 38A10055  addi r5, r1, 0x55
	ctx.r[5].s64 = ctx.r[1].s64 + 85;
	// 825DD220: 388B192C  addi r4, r11, 0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + 6444;
	// 825DD224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD228: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD22C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD230: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825DD234: 4BFFF2A5  bl 0x825dc4d8
	ctx.lr = 0x825DD238;
	sub_825DC4D8(ctx, base);
	// 825DD238: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825DD23C: 38A10056  addi r5, r1, 0x56
	ctx.r[5].s64 = ctx.r[1].s64 + 86;
	// 825DD240: 388BCAC0  addi r4, r11, -0x3540
	ctx.r[4].s64 = ctx.r[11].s64 + -13632;
	// 825DD244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD248: 4BFFF291  bl 0x825dc4d8
	ctx.lr = 0x825DD24C;
	sub_825DC4D8(ctx, base);
	// 825DD24C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825DD250: 38A10057  addi r5, r1, 0x57
	ctx.r[5].s64 = ctx.r[1].s64 + 87;
	// 825DD254: 388BCABC  addi r4, r11, -0x3544
	ctx.r[4].s64 = ctx.r[11].s64 + -13636;
	// 825DD258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD25C: 4BFFF27D  bl 0x825dc4d8
	ctx.lr = 0x825DD260;
	sub_825DC4D8(ctx, base);
	// 825DD260: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD264: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825DD268: 388BED74  addi r4, r11, -0x128c
	ctx.r[4].s64 = ctx.r[11].s64 + -4748;
	// 825DD26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD270: 4BFFF269  bl 0x825dc4d8
	ctx.lr = 0x825DD274;
	sub_825DC4D8(ctx, base);
	// 825DD274: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825DD278: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DD27C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DD280: 4BFFC529  bl 0x825d97a8
	ctx.lr = 0x825DD284;
	sub_825D97A8(ctx, base);
	// 825DD284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD288: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825DD28C: 4BFFDCFD  bl 0x825daf88
	ctx.lr = 0x825DD290;
	sub_825DAF88(ctx, base);
	// 825DD290: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DD294: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DD298: 419A0008  beq cr6, 0x825dd2a0
	if ctx.cr[6].eq {
	pc = 0x825DD2A0; continue 'dispatch;
	}
	// 825DD29C: 4BCE35F5  bl 0x822c0890
	ctx.lr = 0x825DD2A0;
	sub_822C0890(ctx, base);
	// 825DD2A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD2A4: 4BFFF595  bl 0x825dc838
	ctx.lr = 0x825DD2A8;
	sub_825DC838(ctx, base);
	// 825DD2A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DD2AC: 48BCAF10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD2B0 size=172
    let mut pc: u32 = 0x825DD2B0;
    'dispatch: loop {
        match pc {
            0x825DD2B0 => {
    //   block [0x825DD2B0..0x825DD35C)
	// 825DD2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD2B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DD2BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD2C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD2C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD2C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD2CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DD2D0: 4BFFF4F1  bl 0x825dc7c0
	ctx.lr = 0x825DD2D4;
	sub_825DC7C0(ctx, base);
	// 825DD2D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DD2D8: 38A10055  addi r5, r1, 0x55
	ctx.r[5].s64 = ctx.r[1].s64 + 85;
	// 825DD2DC: 388B192C  addi r4, r11, 0x192c
	ctx.r[4].s64 = ctx.r[11].s64 + 6444;
	// 825DD2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD2E4: 4BFFF1F5  bl 0x825dc4d8
	ctx.lr = 0x825DD2E8;
	sub_825DC4D8(ctx, base);
	// 825DD2E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825DD2EC: 38A10056  addi r5, r1, 0x56
	ctx.r[5].s64 = ctx.r[1].s64 + 86;
	// 825DD2F0: 388BCAC0  addi r4, r11, -0x3540
	ctx.r[4].s64 = ctx.r[11].s64 + -13632;
	// 825DD2F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD2F8: 4BFFF1E1  bl 0x825dc4d8
	ctx.lr = 0x825DD2FC;
	sub_825DC4D8(ctx, base);
	// 825DD2FC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825DD300: 38A10057  addi r5, r1, 0x57
	ctx.r[5].s64 = ctx.r[1].s64 + 87;
	// 825DD304: 388BCABC  addi r4, r11, -0x3544
	ctx.r[4].s64 = ctx.r[11].s64 + -13636;
	// 825DD308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD30C: 4BFFF1CD  bl 0x825dc4d8
	ctx.lr = 0x825DD310;
	sub_825DC4D8(ctx, base);
	// 825DD310: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD314: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825DD318: 388BED74  addi r4, r11, -0x128c
	ctx.r[4].s64 = ctx.r[11].s64 + -4748;
	// 825DD31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD320: 4BFFF1B9  bl 0x825dc4d8
	ctx.lr = 0x825DD324;
	sub_825DC4D8(ctx, base);
	// 825DD324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825DD328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD32C: 4BFFE4CD  bl 0x825db7f8
	ctx.lr = 0x825DD330;
	sub_825DB7F8(ctx, base);
	// 825DD330: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD334: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825DD338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD33C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825DD340: 4BFFF4F9  bl 0x825dc838
	ctx.lr = 0x825DD344;
	sub_825DC838(ctx, base);
	// 825DD344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DD348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD34C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD350: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DD354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD360 size=112
    let mut pc: u32 = 0x825DD360;
    'dispatch: loop {
        match pc {
            0x825DD360 => {
    //   block [0x825DD360..0x825DD3D0)
	// 825DD360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DD36C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD374: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825DD378: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DD37C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825DD380: 388B9B98  addi r4, r11, -0x6468
	ctx.r[4].s64 = ctx.r[11].s64 + -25704;
	// 825DD384: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 825DD388: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825DD38C: 4881505D  bl 0x82df23e8
	ctx.lr = 0x825DD390;
	sub_82DF23E8(ctx, base);
	// 825DD390: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825DD394: 41820010  beq 0x825dd3a4
	if ctx.cr[0].eq {
	pc = 0x825DD3A4; continue 'dispatch;
	}
	// 825DD398: 480012E1  bl 0x825de678
	ctx.lr = 0x825DD39C;
	sub_825DE678(ctx, base);
	// 825DD39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD3A0: 48000008  b 0x825dd3a8
	pc = 0x825DD3A8; continue 'dispatch;
	// 825DD3A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DD3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD3AC: 889E0068  lbz r4, 0x68(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 825DD3B0: 488214C9  bl 0x82dfe878
	ctx.lr = 0x825DD3B4;
	sub_82DFE878(ctx, base);
	// 825DD3B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD3B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DD3BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD3C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD3C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DD3C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD3D0 size=164
    let mut pc: u32 = 0x825DD3D0;
    'dispatch: loop {
        match pc {
            0x825DD3D0 => {
    //   block [0x825DD3D0..0x825DD474)
	// 825DD3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD3D4: 48BCAD99  bl 0x831a816c
	ctx.lr = 0x825DD3D8;
	sub_831A8130(ctx, base);
	// 825DD3D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD3DC: 3D60825E  lis r11, -0x7da2
	ctx.r[11].s64 = -2107768832;
	// 825DD3E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD3E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825DD3E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DD3EC: 396BD360  addi r11, r11, -0x2ca0
	ctx.r[11].s64 = ctx.r[11].s64 + -11424;
	// 825DD3F0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825DD3F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825DD3F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DD3FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825DD400: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825DD404: 488214F5  bl 0x82dfe8f8
	ctx.lr = 0x825DD408;
	sub_82DFE8F8(ctx, base);
	// 825DD408: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825DD40C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825DD410: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825DD414: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825DD418: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825DD41C: 4882447D  bl 0x82e01898
	ctx.lr = 0x825DD420;
	sub_82E01898(ctx, base);
	// 825DD420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD424: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DD428: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825DD42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825DD430: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825DD434: 419A0024  beq cr6, 0x825dd458
	if ctx.cr[6].eq {
	pc = 0x825DD458; continue 'dispatch;
	}
	// 825DD438: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825DD43C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825DD440: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DD444: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825DD448: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825DD44C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825DD450: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825DD454: 4082FFE8  bne 0x825dd43c
	if !ctx.cr[0].eq {
	pc = 0x825DD43C; continue 'dispatch;
	}
	// 825DD458: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825DD45C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825DD460: 419A0008  beq cr6, 0x825dd468
	if ctx.cr[6].eq {
	pc = 0x825DD468; continue 'dispatch;
	}
	// 825DD464: 4BCE342D  bl 0x822c0890
	ctx.lr = 0x825DD468;
	sub_822C0890(ctx, base);
	// 825DD468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD46C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825DD470: 48BCAD4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD478 size=108
    let mut pc: u32 = 0x825DD478;
    'dispatch: loop {
        match pc {
            0x825DD478 => {
    //   block [0x825DD478..0x825DD4E4)
	// 825DD478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD47C: 48BCACED  bl 0x831a8168
	ctx.lr = 0x825DD480;
	sub_831A8130(ctx, base);
	// 825DD480: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD484: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DD488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825DD48C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825DD490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD494: 388BD468  addi r4, r11, -0x2b98
	ctx.r[4].s64 = ctx.r[11].s64 + -11160;
	// 825DD498: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825DD49C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825DD4A0: 48816569  bl 0x82df3a08
	ctx.lr = 0x825DD4A4;
	sub_82DF3A08(ctx, base);
	// 825DD4A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825DD4A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DD4AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DD4B0: 48002351  bl 0x825df800
	ctx.lr = 0x825DD4B4;
	sub_825DF800(ctx, base);
	// 825DD4B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825DD4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD4BC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD4C0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825DD4C4: 4BFFFF0D  bl 0x825dd3d0
	ctx.lr = 0x825DD4C8;
	sub_825DD3D0(ctx, base);
	// 825DD4C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825DD4CC: 48815F5D  bl 0x82df3428
	ctx.lr = 0x825DD4D0;
	sub_82DF3428(ctx, base);
	// 825DD4D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD4D4: 48815F55  bl 0x82df3428
	ctx.lr = 0x825DD4D8;
	sub_82DF3428(ctx, base);
	// 825DD4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD4DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DD4E0: 48BCACD8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825DD4E8 size=32
    let mut pc: u32 = 0x825DD4E8;
    'dispatch: loop {
        match pc {
            0x825DD4E8 => {
    //   block [0x825DD4E8..0x825DD508)
	// 825DD4E8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825DD4EC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD4F0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825DD4F4: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825DD4F8: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 825DD4FC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825DD500: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825DD504: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD508 size=116
    let mut pc: u32 = 0x825DD508;
    'dispatch: loop {
        match pc {
            0x825DD508 => {
    //   block [0x825DD508..0x825DD57C)
	// 825DD508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DD514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD51C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DD520: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825DD524: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825DD528: 409A000C  bne cr6, 0x825dd534
	if !ctx.cr[6].eq {
	pc = 0x825DD534; continue 'dispatch;
	}
	// 825DD52C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD530: 48000030  b 0x825dd560
	pc = 0x825DD560; continue 'dispatch;
	// 825DD534: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825DD538: 419A0024  beq cr6, 0x825dd55c
	if ctx.cr[6].eq {
	pc = 0x825DD55C; continue 'dispatch;
	}
	// 825DD53C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DD540: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825DD544: 388BD0F8  addi r4, r11, -0x2f08
	ctx.r[4].s64 = ctx.r[11].s64 + -12040;
	// 825DD548: 48BCABB1  bl 0x831a80f8
	ctx.lr = 0x825DD54C;
	sub_831A80F8(ctx, base);
	// 825DD54C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DD550: 4182000C  beq 0x825dd55c
	if ctx.cr[0].eq {
	pc = 0x825DD55C; continue 'dispatch;
	}
	// 825DD554: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825DD558: 4800000C  b 0x825dd564
	pc = 0x825DD564; continue 'dispatch;
	// 825DD55C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825DD560: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DD564: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825DD568: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD56C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD570: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DD574: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD578: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD580 size=72
    let mut pc: u32 = 0x825DD580;
    'dispatch: loop {
        match pc {
            0x825DD580 => {
    //   block [0x825DD580..0x825DD5C8)
	// 825DD580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD588: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD58C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825DD590: 419A001C  beq cr6, 0x825dd5ac
	if ctx.cr[6].eq {
	pc = 0x825DD5AC; continue 'dispatch;
	}
	// 825DD594: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DD598: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825DD59C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825DD5A0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DD5A4: 4BFFFF65  bl 0x825dd508
	ctx.lr = 0x825DD5A8;
	sub_825DD508(ctx, base);
	// 825DD5A8: 48000010  b 0x825dd5b8
	pc = 0x825DD5B8; continue 'dispatch;
	// 825DD5AC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825DD5B0: 396BD0F8  addi r11, r11, -0x2f08
	ctx.r[11].s64 = ctx.r[11].s64 + -12040;
	// 825DD5B4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825DD5B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825DD5BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD5C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD5C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD5C8 size=128
    let mut pc: u32 = 0x825DD5C8;
    'dispatch: loop {
        match pc {
            0x825DD5C8 => {
    //   block [0x825DD5C8..0x825DD648)
	// 825DD5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD5CC: 48BCABA1  bl 0x831a816c
	ctx.lr = 0x825DD5D0;
	sub_831A8130(ctx, base);
	// 825DD5D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD5D4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825DD5D8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825DD5DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DD5E0: 3BEB7DD8  addi r31, r11, 0x7dd8
	ctx.r[31].s64 = ctx.r[11].s64 + 32216;
	// 825DD5E4: 816A7DE0  lwz r11, 0x7de0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32224 as u32) ) } as u64;
	// 825DD5E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825DD5EC: 40820024  bne 0x825dd610
	if !ctx.cr[0].eq {
	pc = 0x825DD610; continue 'dispatch;
	}
	// 825DD5F0: 3D20825E  lis r9, -0x7da2
	ctx.r[9].s64 = -2107768832;
	// 825DD5F4: 3D00825E  lis r8, -0x7da2
	ctx.r[8].s64 = -2107768832;
	// 825DD5F8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825DD5FC: 3929D4E8  addi r9, r9, -0x2b18
	ctx.r[9].s64 = ctx.r[9].s64 + -11032;
	// 825DD600: 3908D580  addi r8, r8, -0x2a80
	ctx.r[8].s64 = ctx.r[8].s64 + -10880;
	// 825DD604: 916A7DE0  stw r11, 0x7de0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32224 as u32), ctx.r[11].u32 ) };
	// 825DD608: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825DD60C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825DD610: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825DD614: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825DD618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825DD61C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825DD620: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825DD624: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825DD628: 482EA2B1  bl 0x828c78d8
	ctx.lr = 0x825DD62C;
	sub_828C78D8(ctx, base);
	// 825DD62C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825DD630: 4182000C  beq 0x825dd63c
	if ctx.cr[0].eq {
	pc = 0x825DD63C; continue 'dispatch;
	}
	// 825DD634: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825DD638: 48000008  b 0x825dd640
	pc = 0x825DD640; continue 'dispatch;
	// 825DD63C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825DD640: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825DD644: 48BCAB78  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825DD648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825DD648 size=140
    let mut pc: u32 = 0x825DD648;
    'dispatch: loop {
        match pc {
            0x825DD648 => {
    //   block [0x825DD648..0x825DD6D4)
	// 825DD648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825DD64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825DD650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825DD654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825DD658: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825DD65C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825DD660: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825DD664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD668: 388BED78  addi r4, r11, -0x1288
	ctx.r[4].s64 = ctx.r[11].s64 + -4744;
	// 825DD66C: 4881639D  bl 0x82df3a08
	ctx.lr = 0x825DD670;
	sub_82DF3A08(ctx, base);
	// 825DD670: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825DD674: 3D60825E  lis r11, -0x7da2
	ctx.r[11].s64 = -2107768832;
	// 825DD678: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825DD67C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825DD680: 388BE3E0  addi r4, r11, -0x1c20
	ctx.r[4].s64 = ctx.r[11].s64 + -7200;
	// 825DD684: 4BCF4A9D  bl 0x822d2120
	ctx.lr = 0x825DD688;
	sub_822D2120(ctx, base);
	// 825DD688: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 825DD68C: 3D60825E  lis r11, -0x7da2
	ctx.r[11].s64 = -2107768832;
	// 825DD690: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825DD694: 388BE998  addi r4, r11, -0x1668
	ctx.r[4].s64 = ctx.r[11].s64 + -5736;
	// 825DD698: 4BFFFF31  bl 0x825dd5c8
	ctx.lr = 0x825DD69C;
	sub_825DD5C8(ctx, base);
	// 825DD69C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825DD6A0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825DD6A4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825DD6A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825DD6AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825DD6B0: 48825B59  bl 0x82e03208
	ctx.lr = 0x825DD6B4;
	sub_82E03208(ctx, base);
	// 825DD6B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825DD6B8: 48815D71  bl 0x82df3428
	ctx.lr = 0x825DD6BC;
	sub_82DF3428(ctx, base);
	// 825DD6BC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825DD6C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825DD6C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825DD6C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825DD6CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825DD6D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


