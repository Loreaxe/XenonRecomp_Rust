pub fn sub_8233D2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233D2E0 size=196
    let mut pc: u32 = 0x8233D2E0;
    'dispatch: loop {
        match pc {
            0x8233D2E0 => {
    //   block [0x8233D2E0..0x8233D3A4)
	// 8233D2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233D2E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233D2E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233D2EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233D2F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233D2F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233D2F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233D2FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8233D300: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233D304: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233D308: 4BF83631  bl 0x822c0938
	ctx.lr = 0x8233D30C;
	sub_822C0938(ctx, base);
	// 8233D30C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233D310: 41820028  beq 0x8233d338
	if ctx.cr[0].eq {
	pc = 0x8233D338; continue 'dispatch;
	}
	// 8233D314: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D318: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8233D31C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8233D320: 392B1BDC  addi r9, r11, 0x1bdc
	ctx.r[9].s64 = ctx.r[11].s64 + 7132;
	// 8233D324: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8233D328: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233D32C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8233D330: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8233D334: 48000008  b 0x8233d33c
	pc = 0x8233D33C; continue 'dispatch;
	// 8233D338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233D33C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233D340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233D344: 409A0044  bne cr6, 0x8233d388
	if !ctx.cr[6].eq {
	pc = 0x8233D388; continue 'dispatch;
	}
	// 8233D348: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233D34C: 419A001C  beq cr6, 0x8233d368
	if ctx.cr[6].eq {
	pc = 0x8233D368; continue 'dispatch;
	}
	// 8233D350: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233D354: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8233D358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D35C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233D360: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233D364: 4E800421  bctrl
	ctx.lr = 0x8233D368;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233D368: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233D36C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233D370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233D374: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8233D378: 816B95DC  lwz r11, -0x6a24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27172 as u32) ) } as u64;
	// 8233D37C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8233D380: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8233D384: 4BF82C7D  bl 0x822c0000
	ctx.lr = 0x8233D388;
	sub_822C0000(ctx, base);
	// 8233D388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D38C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233D390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233D394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233D398: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233D39C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233D3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233D3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233D3A8 size=196
    let mut pc: u32 = 0x8233D3A8;
    'dispatch: loop {
        match pc {
            0x8233D3A8 => {
    //   block [0x8233D3A8..0x8233D46C)
	// 8233D3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233D3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233D3B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233D3B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233D3B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233D3BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233D3C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233D3C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8233D3C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233D3CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233D3D0: 4BF83569  bl 0x822c0938
	ctx.lr = 0x8233D3D4;
	sub_822C0938(ctx, base);
	// 8233D3D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233D3D8: 41820028  beq 0x8233d400
	if ctx.cr[0].eq {
	pc = 0x8233D400; continue 'dispatch;
	}
	// 8233D3DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D3E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8233D3E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8233D3E8: 392B1BF0  addi r9, r11, 0x1bf0
	ctx.r[9].s64 = ctx.r[11].s64 + 7152;
	// 8233D3EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8233D3F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233D3F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8233D3F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8233D3FC: 48000008  b 0x8233d404
	pc = 0x8233D404; continue 'dispatch;
	// 8233D400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233D404: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233D408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233D40C: 409A0044  bne cr6, 0x8233d450
	if !ctx.cr[6].eq {
	pc = 0x8233D450; continue 'dispatch;
	}
	// 8233D410: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233D414: 419A001C  beq cr6, 0x8233d430
	if ctx.cr[6].eq {
	pc = 0x8233D430; continue 'dispatch;
	}
	// 8233D418: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233D41C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8233D420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D424: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233D428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233D42C: 4E800421  bctrl
	ctx.lr = 0x8233D430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233D430: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233D434: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233D438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233D43C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8233D440: 816B95DC  lwz r11, -0x6a24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27172 as u32) ) } as u64;
	// 8233D444: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8233D448: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8233D44C: 4BF82BB5  bl 0x822c0000
	ctx.lr = 0x8233D450;
	sub_822C0000(ctx, base);
	// 8233D450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233D458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233D45C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233D460: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233D464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233D468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233D470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233D470 size=72
    let mut pc: u32 = 0x8233D470;
    'dispatch: loop {
        match pc {
            0x8233D470 => {
    //   block [0x8233D470..0x8233D4B8)
	// 8233D470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233D474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233D478: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233D47C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233D480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233D484: 48E1717D  bl 0x83154600
	ctx.lr = 0x8233D488;
	sub_83154600(ctx, base);
	// 8233D488: 486D33E9  bl 0x82a10870
	ctx.lr = 0x8233D48C;
	sub_82A10870(ctx, base);
	// 8233D48C: 4BFD6D25  bl 0x823141b0
	ctx.lr = 0x8233D490;
	sub_823141B0(ctx, base);
	// 8233D490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233D494: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8233D498: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8233D49C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D4A0: 4BFFFB71  bl 0x8233d010
	ctx.lr = 0x8233D4A4;
	sub_8233D010(ctx, base);
	// 8233D4A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233D4A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233D4AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233D4B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233D4B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233D4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233D4B8 size=292
    let mut pc: u32 = 0x8233D4B8;
    'dispatch: loop {
        match pc {
            0x8233D4B8 => {
    //   block [0x8233D4B8..0x8233D5DC)
	// 8233D4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233D4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233D4C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233D4C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233D4C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233D4CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233D4D0: 48B1C291  bl 0x82e59760
	ctx.lr = 0x8233D4D4;
	sub_82E59760(ctx, base);
	// 8233D4D4: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233D4D8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8233D4DC: 409900E8  ble cr6, 0x8233d5c4
	if !ctx.cr[6].gt {
	pc = 0x8233D5C4; continue 'dispatch;
	}
	// 8233D4E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D4E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233D4E8: 388B1CA0  addi r4, r11, 0x1ca0
	ctx.r[4].s64 = ctx.r[11].s64 + 7328;
	// 8233D4EC: 38A000A6  li r5, 0xa6
	ctx.r[5].s64 = 166;
	// 8233D4F0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8233D4F4: 48AB4EF5  bl 0x82df23e8
	ctx.lr = 0x8233D4F8;
	sub_82DF23E8(ctx, base);
	// 8233D4F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8233D4FC: 4182001C  beq 0x8233d518
	if ctx.cr[0].eq {
	pc = 0x8233D518; continue 'dispatch;
	}
	// 8233D500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D504: 48B1F425  bl 0x82e5c928
	ctx.lr = 0x8233D508;
	sub_82E5C928(ctx, base);
	// 8233D508: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D50C: 396B1C2C  addi r11, r11, 0x1c2c
	ctx.r[11].s64 = ctx.r[11].s64 + 7212;
	// 8233D510: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233D514: 48000008  b 0x8233d51c
	pc = 0x8233D51C; continue 'dispatch;
	// 8233D518: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8233D51C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8233D520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233D524: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233D528: 4BFFFCF1  bl 0x8233d218
	ctx.lr = 0x8233D52C;
	sub_8233D218(ctx, base);
	// 8233D52C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8233D530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233D534: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233D538: 4BF82AC9  bl 0x822c0000
	ctx.lr = 0x8233D53C;
	sub_822C0000(ctx, base);
	// 8233D53C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233D540: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8233D544: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233D548: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8233D54C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8233D550: 419A0024  beq cr6, 0x8233d574
	if ctx.cr[6].eq {
	pc = 0x8233D574; continue 'dispatch;
	}
	// 8233D554: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8233D558: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8233D55C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233D560: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8233D564: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8233D568: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8233D56C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233D570: 4082FFE8  bne 0x8233d558
	if !ctx.cr[0].eq {
	pc = 0x8233D558; continue 'dispatch;
	}
	// 8233D574: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233D578: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233D57C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233D580: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8233D584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233D588: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233D58C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233D590: 48B21331  bl 0x82e5e8c0
	ctx.lr = 0x8233D594;
	sub_82E5E8C0(ctx, base);
	// 8233D594: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233D598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233D59C: 419A0008  beq cr6, 0x8233d5a4
	if ctx.cr[6].eq {
	pc = 0x8233D5A4; continue 'dispatch;
	}
	// 8233D5A0: 4BF832F1  bl 0x822c0890
	ctx.lr = 0x8233D5A4;
	sub_822C0890(ctx, base);
	// 8233D5A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233D5A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233D5AC: 419A0008  beq cr6, 0x8233d5b4
	if ctx.cr[6].eq {
	pc = 0x8233D5B4; continue 'dispatch;
	}
	// 8233D5B0: 4BF832E1  bl 0x822c0890
	ctx.lr = 0x8233D5B4;
	sub_822C0890(ctx, base);
	// 8233D5B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233D5B8: 419A000C  beq cr6, 0x8233d5c4
	if ctx.cr[6].eq {
	pc = 0x8233D5C4; continue 'dispatch;
	}
	// 8233D5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D5C0: 4BF832D1  bl 0x822c0890
	ctx.lr = 0x8233D5C4;
	sub_822C0890(ctx, base);
	// 8233D5C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8233D5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233D5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233D5D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233D5D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233D5D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233D5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233D5E0 size=388
    let mut pc: u32 = 0x8233D5E0;
    'dispatch: loop {
        match pc {
            0x8233D5E0 => {
    //   block [0x8233D5E0..0x8233D764)
	// 8233D5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233D5E4: 48E6AB89  bl 0x831a816c
	ctx.lr = 0x8233D5E8;
	sub_831A8130(ctx, base);
	// 8233D5E8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8233D5EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233D5F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233D5F4: 48E1700D  bl 0x83154600
	ctx.lr = 0x8233D5F8;
	sub_83154600(ctx, base);
	// 8233D5F8: 486D3279  bl 0x82a10870
	ctx.lr = 0x8233D5FC;
	sub_82A10870(ctx, base);
	// 8233D5FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233D600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D604: 48B1C15D  bl 0x82e59760
	ctx.lr = 0x8233D608;
	sub_82E59760(ctx, base);
	// 8233D608: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D60C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8233D610: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8233D614: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8233D618: 3BEB1B94  addi r31, r11, 0x1b94
	ctx.r[31].s64 = ctx.r[11].s64 + 7060;
	// 8233D61C: C00B1B94  lfs f0, 0x1b94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233D620: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 8233D624: C1AAE830  lfs f13, -0x17d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233D628: C18908A8  lfs f12, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8233D62C: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8233D630: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8233D634: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8233D638: 4099000C  ble cr6, 0x8233d644
	if !ctx.cr[6].gt {
	pc = 0x8233D644; continue 'dispatch;
	}
	// 8233D63C: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 8233D640: 48000010  b 0x8233d650
	pc = 0x8233D650; continue 'dispatch;
	// 8233D644: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8233D648: 40980008  bge cr6, 0x8233d650
	if !ctx.cr[6].lt {
	pc = 0x8233D650; continue 'dispatch;
	}
	// 8233D64C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8233D650: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8233D654: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233D658: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233D65C: EC2C037A  fmadds f1, f12, f13, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 8233D660: 4BFE0881  bl 0x8231dee0
	ctx.lr = 0x8233D664;
	sub_8231DEE0(ctx, base);
	// 8233D664: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D668: 48B1C0F9  bl 0x82e59760
	ctx.lr = 0x8233D66C;
	sub_82E59760(ctx, base);
	// 8233D66C: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233D670: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8233D674: 409900E4  ble cr6, 0x8233d758
	if !ctx.cr[6].gt {
	pc = 0x8233D758; continue 'dispatch;
	}
	// 8233D678: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D67C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233D680: 388B1CA0  addi r4, r11, 0x1ca0
	ctx.r[4].s64 = ctx.r[11].s64 + 7328;
	// 8233D684: 38A000C0  li r5, 0xc0
	ctx.r[5].s64 = 192;
	// 8233D688: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8233D68C: 48AB4D5D  bl 0x82df23e8
	ctx.lr = 0x8233D690;
	sub_82DF23E8(ctx, base);
	// 8233D690: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8233D694: 4182001C  beq 0x8233d6b0
	if ctx.cr[0].eq {
	pc = 0x8233D6B0; continue 'dispatch;
	}
	// 8233D698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D69C: 48B1F28D  bl 0x82e5c928
	ctx.lr = 0x8233D6A0;
	sub_82E5C928(ctx, base);
	// 8233D6A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D6A4: 396B1C54  addi r11, r11, 0x1c54
	ctx.r[11].s64 = ctx.r[11].s64 + 7252;
	// 8233D6A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233D6AC: 48000008  b 0x8233d6b4
	pc = 0x8233D6B4; continue 'dispatch;
	// 8233D6B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8233D6B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8233D6B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233D6BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233D6C0: 4BFFFC21  bl 0x8233d2e0
	ctx.lr = 0x8233D6C4;
	sub_8233D2E0(ctx, base);
	// 8233D6C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8233D6C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233D6CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233D6D0: 4BF82931  bl 0x822c0000
	ctx.lr = 0x8233D6D4;
	sub_822C0000(ctx, base);
	// 8233D6D4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233D6D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8233D6DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233D6E0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8233D6E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8233D6E8: 419A0024  beq cr6, 0x8233d70c
	if ctx.cr[6].eq {
	pc = 0x8233D70C; continue 'dispatch;
	}
	// 8233D6EC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8233D6F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8233D6F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233D6F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8233D6FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8233D700: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8233D704: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233D708: 4082FFE8  bne 0x8233d6f0
	if !ctx.cr[0].eq {
	pc = 0x8233D6F0; continue 'dispatch;
	}
	// 8233D70C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233D710: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8233D714: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233D718: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8233D71C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233D720: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233D724: 48B2119D  bl 0x82e5e8c0
	ctx.lr = 0x8233D728;
	sub_82E5E8C0(ctx, base);
	// 8233D728: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233D72C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233D730: 419A0008  beq cr6, 0x8233d738
	if ctx.cr[6].eq {
	pc = 0x8233D738; continue 'dispatch;
	}
	// 8233D734: 4BF8315D  bl 0x822c0890
	ctx.lr = 0x8233D738;
	sub_822C0890(ctx, base);
	// 8233D738: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233D73C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233D740: 419A0008  beq cr6, 0x8233d748
	if ctx.cr[6].eq {
	pc = 0x8233D748; continue 'dispatch;
	}
	// 8233D744: 4BF8314D  bl 0x822c0890
	ctx.lr = 0x8233D748;
	sub_822C0890(ctx, base);
	// 8233D748: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233D74C: 419A000C  beq cr6, 0x8233d758
	if ctx.cr[6].eq {
	pc = 0x8233D758; continue 'dispatch;
	}
	// 8233D750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D754: 4BF8313D  bl 0x822c0890
	ctx.lr = 0x8233D758;
	sub_822C0890(ctx, base);
	// 8233D758: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8233D75C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8233D760: 48E6AA5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233D768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233D768 size=1152
    let mut pc: u32 = 0x8233D768;
    'dispatch: loop {
        match pc {
            0x8233D768 => {
    //   block [0x8233D768..0x8233DBE8)
	// 8233D768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233D76C: 48E6A9F9  bl 0x831a8164
	ctx.lr = 0x8233D770;
	sub_831A8130(ctx, base);
	// 8233D770: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8233D774: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8233D778: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233D77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233D780: 48E16E81  bl 0x83154600
	ctx.lr = 0x8233D784;
	sub_83154600(ctx, base);
	// 8233D784: 486D30ED  bl 0x82a10870
	ctx.lr = 0x8233D788;
	sub_82A10870(ctx, base);
	// 8233D788: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8233D78C: 4BFD6A25  bl 0x823141b0
	ctx.lr = 0x8233D790;
	sub_823141B0(ctx, base);
	// 8233D790: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233D794: 4BFF2C75  bl 0x82330408
	ctx.lr = 0x8233D798;
	sub_82330408(ctx, base);
	// 8233D798: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233D79C: 4182043C  beq 0x8233dbd8
	if ctx.cr[0].eq {
	pc = 0x8233DBD8; continue 'dispatch;
	}
	// 8233D7A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D7A4: 48E16E5D  bl 0x83154600
	ctx.lr = 0x8233D7A8;
	sub_83154600(ctx, base);
	// 8233D7A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233D7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D7B0: 83AB00B4  lwz r29, 0xb4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 8233D7B4: 4BFF256D  bl 0x8232fd20
	ctx.lr = 0x8233D7B8;
	sub_8232FD20(ctx, base);
	// 8233D7B8: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8233D7BC: 40980008  bge cr6, 0x8233d7c4
	if !ctx.cr[6].lt {
	pc = 0x8233D7C4; continue 'dispatch;
	}
	// 8233D7C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233D7C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D7C8: 48E16E39  bl 0x83154600
	ctx.lr = 0x8233D7CC;
	sub_83154600(ctx, base);
	// 8233D7CC: 93A300B4  stw r29, 0xb4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 8233D7D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D7D4: 4BFF249D  bl 0x8232fc70
	ctx.lr = 0x8233D7D8;
	sub_8232FC70(ctx, base);
	// 8233D7D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233D7DC: 418202A0  beq 0x8233da7c
	if ctx.cr[0].eq {
	pc = 0x8233DA7C; continue 'dispatch;
	}
	// 8233D7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D7E4: 48E16E1D  bl 0x83154600
	ctx.lr = 0x8233D7E8;
	sub_83154600(ctx, base);
	// 8233D7E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233D7EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D7F0: 48E16E11  bl 0x83154600
	ctx.lr = 0x8233D7F4;
	sub_83154600(ctx, base);
	// 8233D7F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8233D7F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D7FC: C3FD00BC  lfs f31, 0xbc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8233D800: 4BFF25C1  bl 0x8232fdc0
	ctx.lr = 0x8233D804;
	sub_8232FDC0(ctx, base);
	// 8233D804: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8233D808: 83DB00B8  lwz r30, 0xb8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(184 as u32) ) } as u64;
	// 8233D80C: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8233D810: 4BFC8EA1  bl 0x823066b0
	ctx.lr = 0x8233D814;
	sub_823066B0(ctx, base);
	// 8233D814: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233D818: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8233D81C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8233D820: 4811E991  bl 0x8245c1b0
	ctx.lr = 0x8233D824;
	sub_8245C1B0(ctx, base);
	// 8233D824: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8233D828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D82C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8233D830: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8233D834: 48E16DCD  bl 0x83154600
	ctx.lr = 0x8233D838;
	sub_83154600(ctx, base);
	// 8233D838: 39630068  addi r11, r3, 0x68
	ctx.r[11].s64 = ctx.r[3].s64 + 104;
	// 8233D83C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233D840: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8233D844: 409A000C  bne cr6, 0x8233d850
	if !ctx.cr[6].eq {
	pc = 0x8233D850; continue 'dispatch;
	}
	// 8233D848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233D84C: 48000014  b 0x8233d860
	pc = 0x8233D860; continue 'dispatch;
	// 8233D850: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233D854: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 8233D858: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8233D85C: 7D6B4BD6  divw r11, r11, r9
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 8233D860: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8233D864: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8233D868: 4098008C  bge cr6, 0x8233d8f4
	if !ctx.cr[6].lt {
	pc = 0x8233D8F4; continue 'dispatch;
	}
	// 8233D86C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8233D870: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 8233D874: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8233D878: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8233D87C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8233D880: 809E271C  lwz r4, 0x271c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(10012 as u32) ) } as u64;
	// 8233D884: 48AB4375  bl 0x82df1bf8
	ctx.lr = 0x8233D888;
	sub_82DF1BF8(ctx, base);
	// 8233D888: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8233D88C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8233D890: 809E271C  lwz r4, 0x271c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(10012 as u32) ) } as u64;
	// 8233D894: 83C10078  lwz r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8233D898: 48AB4361  bl 0x82df1bf8
	ctx.lr = 0x8233D89C;
	sub_82DF1BF8(ctx, base);
	// 8233D89C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D8A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233D8A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233D8A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233D8AC: 3BCB0C40  addi r30, r11, 0xc40
	ctx.r[30].s64 = ctx.r[11].s64 + 3136;
	// 8233D8B0: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8233D8B4: 48B1252D  bl 0x82e4fde0
	ctx.lr = 0x8233D8B8;
	sub_82E4FDE0(ctx, base);
	// 8233D8B8: 48AB58F9  bl 0x82df31b0
	ctx.lr = 0x8233D8BC;
	sub_82DF31B0(ctx, base);
	// 8233D8BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8233D8C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233D8C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8233D8C8: 48B12A81  bl 0x82e50348
	ctx.lr = 0x8233D8CC;
	sub_82E50348(ctx, base);
	// 8233D8CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8233D8D0: 48AB43C1  bl 0x82df1c90
	ctx.lr = 0x8233D8D4;
	sub_82DF1C90(ctx, base);
	// 8233D8D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233D8D8: 48AB5B51  bl 0x82df3428
	ctx.lr = 0x8233D8DC;
	sub_82DF3428(ctx, base);
	// 8233D8DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8233D8E0: 48AB43B1  bl 0x82df1c90
	ctx.lr = 0x8233D8E4;
	sub_82DF1C90(ctx, base);
	// 8233D8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D8E8: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8233D8EC: 4BFFF725  bl 0x8233d010
	ctx.lr = 0x8233D8F0;
	sub_8233D010(ctx, base);
	// 8233D8F0: 48000160  b 0x8233da50
	pc = 0x8233DA50; continue 'dispatch;
	// 8233D8F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D8FC: 3BCB1CA0  addi r30, r11, 0x1ca0
	ctx.r[30].s64 = ctx.r[11].s64 + 7328;
	// 8233D900: 48E16D01  bl 0x83154600
	ctx.lr = 0x8233D904;
	sub_83154600(ctx, base);
	// 8233D904: 388300A0  addi r4, r3, 0xa0
	ctx.r[4].s64 = ctx.r[3].s64 + 160;
	// 8233D908: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8233D90C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8233D910: 38C000F7  li r6, 0xf7
	ctx.r[6].s64 = 247;
	// 8233D914: 4BFD6225  bl 0x82313b38
	ctx.lr = 0x8233D918;
	sub_82313B38(ctx, base);
	// 8233D918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D91C: 48E16CE5  bl 0x83154600
	ctx.lr = 0x8233D920;
	sub_83154600(ctx, base);
	// 8233D920: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D924: 38830090  addi r4, r3, 0x90
	ctx.r[4].s64 = ctx.r[3].s64 + 144;
	// 8233D928: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8233D92C: C02B1B94  lfs f1, 0x1b94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233D930: 4BFDA939  bl 0x82318268
	ctx.lr = 0x8233D934;
	sub_82318268(ctx, base);
	// 8233D934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233D938: 48E16CC9  bl 0x83154600
	ctx.lr = 0x8233D93C;
	sub_83154600(ctx, base);
	// 8233D93C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233D940: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8233D944: C02B00B0  lfs f1, 0xb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233D948: 4BFF1221  bl 0x8232eb68
	ctx.lr = 0x8233D94C;
	sub_8232EB68(ctx, base);
	// 8233D94C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233D950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233D954: 808BB3F8  lwz r4, -0x4c08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19464 as u32) ) } as u64;
	// 8233D958: 48AB60B1  bl 0x82df3a08
	ctx.lr = 0x8233D95C;
	sub_82DF3A08(ctx, base);
	// 8233D95C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8233D960: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8233D964: 4BFC7C2D  bl 0x82305590
	ctx.lr = 0x8233D968;
	sub_82305590(ctx, base);
	// 8233D968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233D96C: 48AB5ABD  bl 0x82df3428
	ctx.lr = 0x8233D970;
	sub_82DF3428(ctx, base);
	// 8233D970: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233D974: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233D978: 38A000FB  li r5, 0xfb
	ctx.r[5].s64 = 251;
	// 8233D97C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8233D980: 48AB4A69  bl 0x82df23e8
	ctx.lr = 0x8233D984;
	sub_82DF23E8(ctx, base);
	// 8233D984: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8233D988: 4182001C  beq 0x8233d9a4
	if ctx.cr[0].eq {
	pc = 0x8233D9A4; continue 'dispatch;
	}
	// 8233D98C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233D990: 48B1EF99  bl 0x82e5c928
	ctx.lr = 0x8233D994;
	sub_82E5C928(ctx, base);
	// 8233D994: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233D998: 396B1C7C  addi r11, r11, 0x1c7c
	ctx.r[11].s64 = ctx.r[11].s64 + 7292;
	// 8233D99C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233D9A0: 48000008  b 0x8233d9a8
	pc = 0x8233D9A8; continue 'dispatch;
	// 8233D9A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8233D9A8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8233D9AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233D9B0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8233D9B4: 4BFFF9F5  bl 0x8233d3a8
	ctx.lr = 0x8233D9B8;
	sub_8233D3A8(ctx, base);
	// 8233D9B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8233D9BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233D9C0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8233D9C4: 4BF8263D  bl 0x822c0000
	ctx.lr = 0x8233D9C8;
	sub_822C0000(ctx, base);
	// 8233D9C8: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233D9CC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8233D9D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8233D9D4: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8233D9D8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8233D9DC: 419A0024  beq cr6, 0x8233da00
	if ctx.cr[6].eq {
	pc = 0x8233DA00; continue 'dispatch;
	}
	// 8233D9E0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8233D9E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8233D9E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233D9EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8233D9F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8233D9F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8233D9F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233D9FC: 4082FFE8  bne 0x8233d9e4
	if !ctx.cr[0].eq {
	pc = 0x8233D9E4; continue 'dispatch;
	}
	// 8233DA00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233DA04: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233DA08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233DA0C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8233DA10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233DA14: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8233DA18: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233DA1C: 48B20EA5  bl 0x82e5e8c0
	ctx.lr = 0x8233DA20;
	sub_82E5E8C0(ctx, base);
	// 8233DA20: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8233DA24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233DA28: 419A0008  beq cr6, 0x8233da30
	if ctx.cr[6].eq {
	pc = 0x8233DA30; continue 'dispatch;
	}
	// 8233DA2C: 4BF82E65  bl 0x822c0890
	ctx.lr = 0x8233DA30;
	sub_822C0890(ctx, base);
	// 8233DA30: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233DA34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233DA38: 419A0008  beq cr6, 0x8233da40
	if ctx.cr[6].eq {
	pc = 0x8233DA40; continue 'dispatch;
	}
	// 8233DA3C: 4BF82E55  bl 0x822c0890
	ctx.lr = 0x8233DA40;
	sub_822C0890(ctx, base);
	// 8233DA40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8233DA44: 419A000C  beq cr6, 0x8233da50
	if ctx.cr[6].eq {
	pc = 0x8233DA50; continue 'dispatch;
	}
	// 8233DA48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DA4C: 4BF82E45  bl 0x822c0890
	ctx.lr = 0x8233DA50;
	sub_822C0890(ctx, base);
	// 8233DA50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DA54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233DA58: 388B1D00  addi r4, r11, 0x1d00
	ctx.r[4].s64 = ctx.r[11].s64 + 7424;
	// 8233DA5C: 48AB5FAD  bl 0x82df3a08
	ctx.lr = 0x8233DA60;
	sub_82DF3A08(ctx, base);
	// 8233DA60: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8233DA64: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 8233DA68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8233DA6C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8233DA70: 4BFCA4C1  bl 0x82307f30
	ctx.lr = 0x8233DA74;
	sub_82307F30(ctx, base);
	// 8233DA74: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8233DA78: 4800014C  b 0x8233dbc4
	pc = 0x8233DBC4; continue 'dispatch;
	// 8233DA7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DA80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233DA84: 388B1CA0  addi r4, r11, 0x1ca0
	ctx.r[4].s64 = ctx.r[11].s64 + 7328;
	// 8233DA88: 38A00107  li r5, 0x107
	ctx.r[5].s64 = 263;
	// 8233DA8C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8233DA90: 48AB4959  bl 0x82df23e8
	ctx.lr = 0x8233DA94;
	sub_82DF23E8(ctx, base);
	// 8233DA94: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8233DA98: 4182001C  beq 0x8233dab4
	if ctx.cr[0].eq {
	pc = 0x8233DAB4; continue 'dispatch;
	}
	// 8233DA9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DAA0: 48B1EE89  bl 0x82e5c928
	ctx.lr = 0x8233DAA4;
	sub_82E5C928(ctx, base);
	// 8233DAA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DAA8: 396B1C7C  addi r11, r11, 0x1c7c
	ctx.r[11].s64 = ctx.r[11].s64 + 7292;
	// 8233DAAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233DAB0: 48000008  b 0x8233dab8
	pc = 0x8233DAB8; continue 'dispatch;
	// 8233DAB4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8233DAB8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8233DABC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233DAC0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8233DAC4: 4BFFF8E5  bl 0x8233d3a8
	ctx.lr = 0x8233DAC8;
	sub_8233D3A8(ctx, base);
	// 8233DAC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8233DACC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233DAD0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8233DAD4: 4BF8252D  bl 0x822c0000
	ctx.lr = 0x8233DAD8;
	sub_822C0000(ctx, base);
	// 8233DAD8: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233DADC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8233DAE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8233DAE4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 8233DAE8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8233DAEC: 419A0024  beq cr6, 0x8233db10
	if ctx.cr[6].eq {
	pc = 0x8233DB10; continue 'dispatch;
	}
	// 8233DAF0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8233DAF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8233DAF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233DAFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8233DB00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8233DB04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8233DB08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233DB0C: 4082FFE8  bne 0x8233daf4
	if !ctx.cr[0].eq {
	pc = 0x8233DAF4; continue 'dispatch;
	}
	// 8233DB10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233DB14: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233DB18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233DB1C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 8233DB20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233DB24: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8233DB28: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233DB2C: 48B20D95  bl 0x82e5e8c0
	ctx.lr = 0x8233DB30;
	sub_82E5E8C0(ctx, base);
	// 8233DB30: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8233DB34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233DB38: 419A0008  beq cr6, 0x8233db40
	if ctx.cr[6].eq {
	pc = 0x8233DB40; continue 'dispatch;
	}
	// 8233DB3C: 4BF82D55  bl 0x822c0890
	ctx.lr = 0x8233DB40;
	sub_822C0890(ctx, base);
	// 8233DB40: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8233DB44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233DB48: 419A0008  beq cr6, 0x8233db50
	if ctx.cr[6].eq {
	pc = 0x8233DB50; continue 'dispatch;
	}
	// 8233DB4C: 4BF82D45  bl 0x822c0890
	ctx.lr = 0x8233DB50;
	sub_822C0890(ctx, base);
	// 8233DB50: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8233DB54: 419A000C  beq cr6, 0x8233db60
	if ctx.cr[6].eq {
	pc = 0x8233DB60; continue 'dispatch;
	}
	// 8233DB58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DB5C: 4BF82D35  bl 0x822c0890
	ctx.lr = 0x8233DB60;
	sub_822C0890(ctx, base);
	// 8233DB60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DB64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233DB68: 388B0B7C  addi r4, r11, 0xb7c
	ctx.r[4].s64 = ctx.r[11].s64 + 2940;
	// 8233DB6C: 48AB5E9D  bl 0x82df3a08
	ctx.lr = 0x8233DB70;
	sub_82DF3A08(ctx, base);
	// 8233DB70: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8233DB74: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 8233DB78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8233DB7C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8233DB80: 4BFCA3B1  bl 0x82307f30
	ctx.lr = 0x8233DB84;
	sub_82307F30(ctx, base);
	// 8233DB84: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8233DB88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233DB8C: 419A0008  beq cr6, 0x8233db94
	if ctx.cr[6].eq {
	pc = 0x8233DB94; continue 'dispatch;
	}
	// 8233DB90: 4BF82D01  bl 0x822c0890
	ctx.lr = 0x8233DB94;
	sub_822C0890(ctx, base);
	// 8233DB94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233DB98: 48AB5891  bl 0x82df3428
	ctx.lr = 0x8233DB9C;
	sub_82DF3428(ctx, base);
	// 8233DB9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DBA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233DBA4: 388B0B70  addi r4, r11, 0xb70
	ctx.r[4].s64 = ctx.r[11].s64 + 2928;
	// 8233DBA8: 48AB5E61  bl 0x82df3a08
	ctx.lr = 0x8233DBAC;
	sub_82DF3A08(ctx, base);
	// 8233DBAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233DBB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233DBB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8233DBB8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8233DBBC: 4BFCB4DD  bl 0x82309098
	ctx.lr = 0x8233DBC0;
	sub_82309098(ctx, base);
	// 8233DBC0: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8233DBC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233DBC8: 419A0008  beq cr6, 0x8233dbd0
	if ctx.cr[6].eq {
	pc = 0x8233DBD0; continue 'dispatch;
	}
	// 8233DBCC: 4BF82CC5  bl 0x822c0890
	ctx.lr = 0x8233DBD0;
	sub_822C0890(ctx, base);
	// 8233DBD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233DBD4: 48AB5855  bl 0x82df3428
	ctx.lr = 0x8233DBD8;
	sub_82DF3428(ctx, base);
	// 8233DBD8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8233DBDC: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8233DBE0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8233DBE4: 48E6A5D0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233DBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233DBE8 size=132
    let mut pc: u32 = 0x8233DBE8;
    'dispatch: loop {
        match pc {
            0x8233DBE8 => {
    //   block [0x8233DBE8..0x8233DC6C)
	// 8233DBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233DBEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233DBF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233DBF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233DBF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233DBFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233DC00: 4BFF41D9  bl 0x82331dd8
	ctx.lr = 0x8233DC04;
	sub_82331DD8(ctx, base);
	// 8233DC04: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8233DC08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233DC0C: 394A1D18  addi r10, r10, 0x1d18
	ctx.r[10].s64 = ctx.r[10].s64 + 7448;
	// 8233DC10: 3BDF00C0  addi r30, r31, 0xc0
	ctx.r[30].s64 = ctx.r[31].s64 + 192;
	// 8233DC14: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8233DC18: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8233DC1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DC20: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8233DC24: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8233DC28: 48B1FCA9  bl 0x82e5d8d0
	ctx.lr = 0x8233DC2C;
	sub_82E5D8D0(ctx, base);
	// 8233DC2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DC30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233DC34: 396B1BA4  addi r11, r11, 0x1ba4
	ctx.r[11].s64 = ctx.r[11].s64 + 7076;
	// 8233DC38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DC3C: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 8233DC40: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8233DC44: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DC48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233DC4C: 4E800421  bctrl
	ctx.lr = 0x8233DC50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233DC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233DC54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233DC58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233DC5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233DC60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233DC64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233DC68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233DC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233DC70 size=96
    let mut pc: u32 = 0x8233DC70;
    'dispatch: loop {
        match pc {
            0x8233DC70 => {
    //   block [0x8233DC70..0x8233DCD0)
	// 8233DC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233DC74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233DC78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233DC7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233DC80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233DC84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233DC88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8233DC8C: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 8233DC90: 48B1FBB9  bl 0x82e5d848
	ctx.lr = 0x8233DC94;
	sub_82E5D848(ctx, base);
	// 8233DC94: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 8233DC98: 482CE3D1  bl 0x8260c068
	ctx.lr = 0x8233DC9C;
	sub_8260C068(ctx, base);
	// 8233DC9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233DCA0: 4BFF41C9  bl 0x82331e68
	ctx.lr = 0x8233DCA4;
	sub_82331E68(ctx, base);
	// 8233DCA4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233DCA8: 4182000C  beq 0x8233dcb4
	if ctx.cr[0].eq {
	pc = 0x8233DCB4; continue 'dispatch;
	}
	// 8233DCAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233DCB0: 48AB4729  bl 0x82df23d8
	ctx.lr = 0x8233DCB4;
	sub_82DF23D8(ctx, base);
	// 8233DCB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233DCB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233DCBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233DCC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233DCC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233DCC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233DCCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233DCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233DCD0 size=592
    let mut pc: u32 = 0x8233DCD0;
    'dispatch: loop {
        match pc {
            0x8233DCD0 => {
    //   block [0x8233DCD0..0x8233DF20)
	// 8233DCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233DCD4: 48E6A48D  bl 0x831a8160
	ctx.lr = 0x8233DCD8;
	sub_831A8130(ctx, base);
	// 8233DCD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233DCDC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8233DCE0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8233DCE4: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8233DCE8: 419A022C  beq cr6, 0x8233df14
	if ctx.cr[6].eq {
	pc = 0x8233DF14; continue 'dispatch;
	}
	// 8233DCEC: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DCF0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8233DCF4: 419A0018  beq cr6, 0x8233dd0c
	if ctx.cr[6].eq {
	pc = 0x8233DD0C; continue 'dispatch;
	}
	// 8233DCF8: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DCFC: 3B40001C  li r26, 0x1c
	ctx.r[26].s64 = 28;
	// 8233DD00: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 8233DD04: 7D2BD3D7  divw. r9, r11, r26
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8233DD08: 4082001C  bne 0x8233dd24
	if !ctx.cr[0].eq {
	pc = 0x8233DD24; continue 'dispatch;
	}
	// 8233DD0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8233DD10: 80DB0008  lwz r6, 8(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DD14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233DD18: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DD1C: 4BFD3C75  bl 0x82311990
	ctx.lr = 0x8233DD20;
	sub_82311990(ctx, base);
	// 8233DD20: 480001F4  b 0x8233df14
	pc = 0x8233DF14; continue 'dispatch;
	// 8233DD24: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DD28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8233DD2C: 409A000C  bne cr6, 0x8233dd38
	if !ctx.cr[6].eq {
	pc = 0x8233DD38; continue 'dispatch;
	}
	// 8233DD30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233DD34: 48000010  b 0x8233dd44
	pc = 0x8233DD44; continue 'dispatch;
	// 8233DD38: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DD3C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8233DD40: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 8233DD44: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8233DD48: 41990070  bgt cr6, 0x8233ddb8
	if ctx.cr[6].gt {
	pc = 0x8233DDB8; continue 'dispatch;
	}
	// 8233DD4C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 8233DD50: 48000018  b 0x8233dd68
	pc = 0x8233DD68; continue 'dispatch;
	// 8233DD54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233DD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233DD5C: 4BFD3AB5  bl 0x82311810
	ctx.lr = 0x8233DD60;
	sub_82311810(ctx, base);
	// 8233DD60: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 8233DD64: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 8233DD68: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8233DD6C: 409AFFE8  bne cr6, 0x8233dd54
	if !ctx.cr[6].eq {
	pc = 0x8233DD54; continue 'dispatch;
	}
	// 8233DD70: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DD74: 48000010  b 0x8233dd84
	pc = 0x8233DD84; continue 'dispatch;
	// 8233DD78: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8233DD7C: 4812C285  bl 0x8246a000
	ctx.lr = 0x8233DD80;
	sub_8246A000(ctx, base);
	// 8233DD80: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 8233DD84: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8233DD88: 409AFFF0  bne cr6, 0x8233dd78
	if !ctx.cr[6].eq {
	pc = 0x8233DD78; continue 'dispatch;
	}
	// 8233DD8C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DD90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233DD94: 419A0010  beq cr6, 0x8233dda4
	if ctx.cr[6].eq {
	pc = 0x8233DDA4; continue 'dispatch;
	}
	// 8233DD98: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DD9C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8233DDA0: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 8233DDA4: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DDA8: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 8233DDAC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8233DDB0: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8233DDB4: 48000160  b 0x8233df14
	pc = 0x8233DF14; continue 'dispatch;
	// 8233DDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8233DDBC: 409A000C  bne cr6, 0x8233ddc8
	if !ctx.cr[6].eq {
	pc = 0x8233DDC8; continue 'dispatch;
	}
	// 8233DDC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233DDC4: 48000010  b 0x8233ddd4
	pc = 0x8233DDD4; continue 'dispatch;
	// 8233DDC8: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 8233DDCC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8233DDD0: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 8233DDD4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8233DDD8: 41990098  bgt cr6, 0x8233de70
	if ctx.cr[6].gt {
	pc = 0x8233DE70; continue 'dispatch;
	}
	// 8233DDDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8233DDE0: 409A000C  bne cr6, 0x8233ddec
	if !ctx.cr[6].eq {
	pc = 0x8233DDEC; continue 'dispatch;
	}
	// 8233DDE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8233DDE8: 48000010  b 0x8233ddf8
	pc = 0x8233DDF8; continue 'dispatch;
	// 8233DDEC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DDF0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8233DDF4: 7D2BD3D6  divw r9, r11, r26
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 8233DDF8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DDFC: 1D29001C  mulli r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 * 28;
	// 8233DE00: 7FE95A14  add r31, r9, r11
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8233DE04: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 8233DE08: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8233DE0C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8233DE10: 419A0020  beq cr6, 0x8233de30
	if ctx.cr[6].eq {
	pc = 0x8233DE30; continue 'dispatch;
	}
	// 8233DE14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233DE18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233DE1C: 4BFD39F5  bl 0x82311810
	ctx.lr = 0x8233DE20;
	sub_82311810(ctx, base);
	// 8233DE20: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 8233DE24: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 8233DE28: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8233DE2C: 409AFFE8  bne cr6, 0x8233de14
	if !ctx.cr[6].eq {
	pc = 0x8233DE14; continue 'dispatch;
	}
	// 8233DE30: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DE34: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 8233DE38: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8233DE3C: 83FB0008  lwz r31, 8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DE40: 419A0028  beq cr6, 0x8233de68
	if ctx.cr[6].eq {
	pc = 0x8233DE68; continue 'dispatch;
	}
	// 8233DE44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233DE48: 419A0010  beq cr6, 0x8233de58
	if ctx.cr[6].eq {
	pc = 0x8233DE58; continue 'dispatch;
	}
	// 8233DE4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233DE50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233DE54: 482CDC35  bl 0x8260ba88
	ctx.lr = 0x8233DE58;
	sub_8260BA88(ctx, base);
	// 8233DE58: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 8233DE5C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 8233DE60: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8233DE64: 409AFFE0  bne cr6, 0x8233de44
	if !ctx.cr[6].eq {
	pc = 0x8233DE44; continue 'dispatch;
	}
	// 8233DE68: 93FB0008  stw r31, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8233DE6C: 480000A8  b 0x8233df14
	pc = 0x8233DF14; continue 'dispatch;
	// 8233DE70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8233DE74: 419A0038  beq cr6, 0x8233deac
	if ctx.cr[6].eq {
	pc = 0x8233DEAC; continue 'dispatch;
	}
	// 8233DE78: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DE7C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 8233DE80: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8233DE84: 419A0018  beq cr6, 0x8233de9c
	if ctx.cr[6].eq {
	pc = 0x8233DE9C; continue 'dispatch;
	}
	// 8233DE88: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8233DE8C: 4812C175  bl 0x8246a000
	ctx.lr = 0x8233DE90;
	sub_8246A000(ctx, base);
	// 8233DE90: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 8233DE94: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8233DE98: 409AFFF0  bne cr6, 0x8233de88
	if !ctx.cr[6].eq {
	pc = 0x8233DE88; continue 'dispatch;
	}
	// 8233DE9C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8233DEA0: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DEA4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8233DEA8: 48AB42E1  bl 0x82df2188
	ctx.lr = 0x8233DEAC;
	sub_82DF2188(ctx, base);
	// 8233DEAC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DEB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233DEB4: 409A000C  bne cr6, 0x8233dec0
	if !ctx.cr[6].eq {
	pc = 0x8233DEC0; continue 'dispatch;
	}
	// 8233DEB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8233DEBC: 48000010  b 0x8233decc
	pc = 0x8233DECC; continue 'dispatch;
	// 8233DEC0: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DEC4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8233DEC8: 7C8BD3D6  divw r4, r11, r26
	ctx.r[4].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 8233DECC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8233DED0: 482CDAB9  bl 0x8260b988
	ctx.lr = 0x8233DED4;
	sub_8260B988(ctx, base);
	// 8233DED4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233DED8: 4182003C  beq 0x8233df14
	if ctx.cr[0].eq {
	pc = 0x8233DF14; continue 'dispatch;
	}
	// 8233DEDC: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8233DEE0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DEE4: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233DEE8: 48000020  b 0x8233df08
	pc = 0x8233DF08; continue 'dispatch;
	// 8233DEEC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8233DEF0: 419A0010  beq cr6, 0x8233df00
	if ctx.cr[6].eq {
	pc = 0x8233DF00; continue 'dispatch;
	}
	// 8233DEF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233DEF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DEFC: 482CDB8D  bl 0x8260ba88
	ctx.lr = 0x8233DF00;
	sub_8260BA88(ctx, base);
	// 8233DF00: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 8233DF04: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 8233DF08: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8233DF0C: 409AFFE0  bne cr6, 0x8233deec
	if !ctx.cr[6].eq {
	pc = 0x8233DEEC; continue 'dispatch;
	}
	// 8233DF10: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8233DF14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8233DF18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8233DF1C: 48E6A294  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233DF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233DF20 size=700
    let mut pc: u32 = 0x8233DF20;
    'dispatch: loop {
        match pc {
            0x8233DF20 => {
    //   block [0x8233DF20..0x8233E1DC)
	// 8233DF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233DF24: 48E6A231  bl 0x831a8154
	ctx.lr = 0x8233DF28;
	sub_831A8130(ctx, base);
	// 8233DF28: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 8233DF2C: 48E6AB49  bl 0x831a8a74
	ctx.lr = 0x8233DF30;
	sub_831A8A40(ctx, base);
	// 8233DF30: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233DF34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233DF38: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233DF3C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 8233DF40: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 8233DF44: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8233DF48: FF601890  fmr f27, f3
	ctx.f[27].f64 = ctx.f[3].f64;
	// 8233DF4C: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 8233DF50: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 8233DF54: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 8233DF58: 486D2919  bl 0x82a10870
	ctx.lr = 0x8233DF5C;
	sub_82A10870(ctx, base);
	// 8233DF5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233DF60: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8233DF64: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 8233DF68: 4BFFFD69  bl 0x8233dcd0
	ctx.lr = 0x8233DF6C;
	sub_8233DCD0(ctx, base);
	// 8233DF6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DF70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DF74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8233DF78: 3B6B1B94  addi r27, r11, 0x1b94
	ctx.r[27].s64 = ctx.r[11].s64 + 7060;
	// 8233DF7C: C02B1B94  lfs f1, 0x1b94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233DF80: 4BFDA2E9  bl 0x82318268
	ctx.lr = 0x8233DF84;
	sub_82318268(ctx, base);
	// 8233DF84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233DF88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DF8C: 3B8B1CA0  addi r28, r11, 0x1ca0
	ctx.r[28].s64 = ctx.r[11].s64 + 7328;
	// 8233DF90: 38C00066  li r6, 0x66
	ctx.r[6].s64 = 102;
	// 8233DF94: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8233DF98: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8233DF9C: 4BFD5B9D  bl 0x82313b38
	ctx.lr = 0x8233DFA0;
	sub_82313B38(ctx, base);
	// 8233DFA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DFA4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8233DFA8: 4BFF0BC1  bl 0x8232eb68
	ctx.lr = 0x8233DFAC;
	sub_8232EB68(ctx, base);
	// 8233DFAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8233DFB0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8233DFB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233DFB8: 4BFD92F1  bl 0x823172a8
	ctx.lr = 0x8233DFBC;
	sub_823172A8(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233E1E0 size=348
    let mut pc: u32 = 0x8233E1E0;
    'dispatch: loop {
        match pc {
            0x8233E1E0 => {
    //   block [0x8233E1E0..0x8233E33C)
	// 8233E1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E1E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E1E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E1EC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E1F0: 486D2681  bl 0x82a10870
	ctx.lr = 0x8233E1F4;
	sub_82A10870(ctx, base);
	// 8233E1F4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E1F8: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8233E1FC: 3D208326  lis r9, -0x7cda
	ctx.r[9].s64 = -2094661632;
	// 8233E200: 3D008326  lis r8, -0x7cda
	ctx.r[8].s64 = -2094661632;
	// 8233E204: 3CE08326  lis r7, -0x7cda
	ctx.r[7].s64 = -2094661632;
	// 8233E208: 3CC08326  lis r6, -0x7cda
	ctx.r[6].s64 = -2094661632;
	// 8233E20C: 816BB0EC  lwz r11, -0x4f14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20244 as u32) ) } as u64;
	// 8233E210: 814AB0F0  lwz r10, -0x4f10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20240 as u32) ) } as u64;
	// 8233E214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E218: 8129B0F4  lwz r9, -0x4f0c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-20236 as u32) ) } as u64;
	// 8233E21C: 8108B0F8  lwz r8, -0x4f08(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-20232 as u32) ) } as u64;
	// 8233E220: 80E7B0FC  lwz r7, -0x4f04(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-20228 as u32) ) } as u64;
	// 8233E224: 80C6B100  lwz r6, -0x4f00(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-20224 as u32) ) } as u64;
	// 8233E228: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8233E22C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8233E230: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 8233E234: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 8233E238: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 8233E23C: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 8233E240: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8233E244: 4BFC749D  bl 0x823056e0
	ctx.lr = 0x8233E248;
	sub_823056E0(ctx, base);
	// 8233E248: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8233E24C: C00B2784  lfs f0, 0x2784(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233E250: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8233E254: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8233E258: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 8233E25C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8233E260: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 8233E264: 40990008  ble cr6, 0x8233e26c
	if !ctx.cr[6].gt {
	pc = 0x8233E26C; continue 'dispatch;
	}
	// 8233E268: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 8233E26C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8233E270: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8233E274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E278: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8233E27C: 48AB578D  bl 0x82df3a08
	ctx.lr = 0x8233E280;
	sub_82DF3A08(ctx, base);
	// 8233E280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8233E284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E288: 4BFC9651  bl 0x823078d8
	ctx.lr = 0x8233E28C;
	sub_823078D8(ctx, base);
	// 8233E28C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E290: 48AB5199  bl 0x82df3428
	ctx.lr = 0x8233E294;
	sub_82DF3428(ctx, base);
	// 8233E294: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 8233E298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E29C: 4BFD5A4D  bl 0x82313ce8
	ctx.lr = 0x8233E2A0;
	sub_82313CE8(ctx, base);
	// 8233E2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E2A4: 4BFD5455  bl 0x823136f8
	ctx.lr = 0x8233E2A8;
	sub_823136F8(ctx, base);
	// 8233E2A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E2AC: 40820040  bne 0x8233e2ec
	if !ctx.cr[0].eq {
	pc = 0x8233E2EC; continue 'dispatch;
	}
	// 8233E2B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E2B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E2B8: 388B12BC  addi r4, r11, 0x12bc
	ctx.r[4].s64 = ctx.r[11].s64 + 4796;
	// 8233E2BC: 48AB574D  bl 0x82df3a08
	ctx.lr = 0x8233E2C0;
	sub_82DF3A08(ctx, base);
	// 8233E2C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233E2C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233E2C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233E2CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233E2D0: 4BFCADC9  bl 0x82309098
	ctx.lr = 0x8233E2D4;
	sub_82309098(ctx, base);
	// 8233E2D4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233E2D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233E2DC: 419A0008  beq cr6, 0x8233e2e4
	if ctx.cr[6].eq {
	pc = 0x8233E2E4; continue 'dispatch;
	}
	// 8233E2E0: 4BF825B1  bl 0x822c0890
	ctx.lr = 0x8233E2E4;
	sub_822C0890(ctx, base);
	// 8233E2E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E2E8: 48AB5141  bl 0x82df3428
	ctx.lr = 0x8233E2EC;
	sub_82DF3428(ctx, base);
	// 8233E2EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E2F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E2F4: 388B1D00  addi r4, r11, 0x1d00
	ctx.r[4].s64 = ctx.r[11].s64 + 7424;
	// 8233E2F8: 48AB5711  bl 0x82df3a08
	ctx.lr = 0x8233E2FC;
	sub_82DF3A08(ctx, base);
	// 8233E2FC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8233E300: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 8233E304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233E308: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233E30C: 4BFC9C25  bl 0x82307f30
	ctx.lr = 0x8233E310;
	sub_82307F30(ctx, base);
	// 8233E310: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233E314: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233E318: 419A0008  beq cr6, 0x8233e320
	if ctx.cr[6].eq {
	pc = 0x8233E320; continue 'dispatch;
	}
	// 8233E31C: 4BF82575  bl 0x822c0890
	ctx.lr = 0x8233E320;
	sub_822C0890(ctx, base);
	// 8233E320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E324: 48AB5105  bl 0x82df3428
	ctx.lr = 0x8233E328;
	sub_82DF3428(ctx, base);
	// 8233E328: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8233E32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233E330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233E334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233E338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233E340 size=204
    let mut pc: u32 = 0x8233E340;
    'dispatch: loop {
        match pc {
            0x8233E340 => {
    //   block [0x8233E340..0x8233E40C)
	// 8233E340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233E34C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E358: 486D2519  bl 0x82a10870
	ctx.lr = 0x8233E35C;
	sub_82A10870(ctx, base);
	// 8233E35C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233E360: 4BFC70C9  bl 0x82305428
	ctx.lr = 0x8233E364;
	sub_82305428(ctx, base);
	// 8233E364: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E368: 4182003C  beq 0x8233e3a4
	if ctx.cr[0].eq {
	pc = 0x8233E3A4; continue 'dispatch;
	}
	// 8233E36C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E374: 808BB3AC  lwz r4, -0x4c54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19540 as u32) ) } as u64;
	// 8233E378: 48AB5691  bl 0x82df3a08
	ctx.lr = 0x8233E37C;
	sub_82DF3A08(ctx, base);
	// 8233E37C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233E380: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233E384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233E388: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233E38C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233E390: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233E394: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233E398: 48B206F9  bl 0x82e5ea90
	ctx.lr = 0x8233E39C;
	sub_82E5EA90(ctx, base);
	// 8233E39C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233E3A0: 48000048  b 0x8233e3e8
	pc = 0x8233E3E8; continue 'dispatch;
	// 8233E3A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233E3A8: 4BFD4861  bl 0x82312c08
	ctx.lr = 0x8233E3AC;
	sub_82312C08(ctx, base);
	// 8233E3AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E3B0: 41820044  beq 0x8233e3f4
	if ctx.cr[0].eq {
	pc = 0x8233E3F4; continue 'dispatch;
	}
	// 8233E3B4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E3B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E3BC: 808BB3B4  lwz r4, -0x4c4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19532 as u32) ) } as u64;
	// 8233E3C0: 48AB5649  bl 0x82df3a08
	ctx.lr = 0x8233E3C4;
	sub_82DF3A08(ctx, base);
	// 8233E3C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233E3C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233E3CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233E3D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233E3D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233E3D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233E3DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233E3E0: 48B206B1  bl 0x82e5ea90
	ctx.lr = 0x8233E3E4;
	sub_82E5EA90(ctx, base);
	// 8233E3E4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233E3E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233E3EC: 419A0008  beq cr6, 0x8233e3f4
	if ctx.cr[6].eq {
	pc = 0x8233E3F4; continue 'dispatch;
	}
	// 8233E3F0: 4BF824A1  bl 0x822c0890
	ctx.lr = 0x8233E3F4;
	sub_822C0890(ctx, base);
	// 8233E3F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8233E3F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233E3FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233E400: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233E404: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233E408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233E410 size=60
    let mut pc: u32 = 0x8233E410;
    'dispatch: loop {
        match pc {
            0x8233E410 => {
    //   block [0x8233E410..0x8233E44C)
	// 8233E410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E418: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E41C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E424: 4BFF39B5  bl 0x82331dd8
	ctx.lr = 0x8233E428;
	sub_82331DD8(ctx, base);
	// 8233E428: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E430: 396B1D44  addi r11, r11, 0x1d44
	ctx.r[11].s64 = ctx.r[11].s64 + 7492;
	// 8233E434: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233E438: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233E43C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233E440: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233E444: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233E448: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233E450 size=124
    let mut pc: u32 = 0x8233E450;
    'dispatch: loop {
        match pc {
            0x8233E450 => {
    //   block [0x8233E450..0x8233E4CC)
	// 8233E450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E458: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E45C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E464: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233E468: 419A004C  beq cr6, 0x8233e4b4
	if ctx.cr[6].eq {
	pc = 0x8233E4B4; continue 'dispatch;
	}
	// 8233E46C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233E470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233E474: 419A0018  beq cr6, 0x8233e48c
	if ctx.cr[6].eq {
	pc = 0x8233E48C; continue 'dispatch;
	}
	// 8233E478: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233E47C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233E480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233E484: 4E800421  bctrl
	ctx.lr = 0x8233E488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233E488: 4800000C  b 0x8233e494
	pc = 0x8233E494; continue 'dispatch;
	// 8233E48C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E490: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 8233E494: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E498: 388B99D0  addi r4, r11, -0x6630
	ctx.r[4].s64 = ctx.r[11].s64 + -26160;
	// 8233E49C: 48E69C5D  bl 0x831a80f8
	ctx.lr = 0x8233E4A0;
	sub_831A80F8(ctx, base);
	// 8233E4A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E4A4: 41820010  beq 0x8233e4b4
	if ctx.cr[0].eq {
	pc = 0x8233E4B4; continue 'dispatch;
	}
	// 8233E4A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233E4AC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8233E4B0: 48000008  b 0x8233e4b8
	pc = 0x8233E4B8; continue 'dispatch;
	// 8233E4B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8233E4B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233E4BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233E4C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233E4C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233E4C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233E4D0 size=352
    let mut pc: u32 = 0x8233E4D0;
    'dispatch: loop {
        match pc {
            0x8233E4D0 => {
    //   block [0x8233E4D0..0x8233E630)
	// 8233E4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E4D4: 48E69C99  bl 0x831a816c
	ctx.lr = 0x8233E4D8;
	sub_831A8130(ctx, base);
	// 8233E4D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E4DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233E4E0: 486D2391  bl 0x82a10870
	ctx.lr = 0x8233E4E4;
	sub_82A10870(ctx, base);
	// 8233E4E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E4E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E4EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233E4F0: 816B0090  lwz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8233E4F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233E4F8: 4E800421  bctrl
	ctx.lr = 0x8233E4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233E4FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E500: 40820128  bne 0x8233e628
	if !ctx.cr[0].eq {
	pc = 0x8233E628; continue 'dispatch;
	}
	// 8233E504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E508: 4BFD8AD9  bl 0x82316fe0
	ctx.lr = 0x8233E50C;
	sub_82316FE0(ctx, base);
	// 8233E50C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E510: 3BAB99C0  addi r29, r11, -0x6640
	ctx.r[29].s64 = ctx.r[11].s64 + -26176;
	// 8233E514: C00B99C0  lfs f0, -0x6640(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233E518: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8233E51C: 40980048  bge cr6, 0x8233e564
	if !ctx.cr[6].lt {
	pc = 0x8233E564; continue 'dispatch;
	}
	// 8233E520: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E528: 808BB38C  lwz r4, -0x4c74(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19572 as u32) ) } as u64;
	// 8233E52C: 48AB54DD  bl 0x82df3a08
	ctx.lr = 0x8233E530;
	sub_82DF3A08(ctx, base);
	// 8233E530: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233E534: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233E538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E53C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233E540: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233E544: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233E548: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233E54C: 48B20545  bl 0x82e5ea90
	ctx.lr = 0x8233E550;
	sub_82E5EA90(ctx, base);
	// 8233E550: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233E554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233E558: 419A00D0  beq cr6, 0x8233e628
	if ctx.cr[6].eq {
	pc = 0x8233E628; continue 'dispatch;
	}
	// 8233E55C: 4BF82335  bl 0x822c0890
	ctx.lr = 0x8233E560;
	sub_822C0890(ctx, base);
	// 8233E560: 480000C8  b 0x8233e628
	pc = 0x8233E628; continue 'dispatch;
	// 8233E564: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E56C: 4BFD68AD  bl 0x82314e18
	ctx.lr = 0x8233E570;
	sub_82314E18(ctx, base);
	// 8233E570: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E574: 408200B4  bne 0x8233e628
	if !ctx.cr[0].eq {
	pc = 0x8233E628; continue 'dispatch;
	}
	// 8233E578: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233E57C: 48B1B1FD  bl 0x82e59778
	ctx.lr = 0x8233E580;
	sub_82E59778(ctx, base);
	// 8233E580: 389E0068  addi r4, r30, 0x68
	ctx.r[4].s64 = ctx.r[30].s64 + 104;
	// 8233E584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E588: 4BFDE501  bl 0x8231ca88
	ctx.lr = 0x8233E58C;
	sub_8231CA88(ctx, base);
	// 8233E58C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8233E590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E594: 4BFC760D  bl 0x82305ba0
	ctx.lr = 0x8233E598;
	sub_82305BA0(ctx, base);
	// 8233E598: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8233E59C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8233E5A0: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233E5A4: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 8233E5A8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233E630 size=172
    let mut pc: u32 = 0x8233E630;
    'dispatch: loop {
        match pc {
            0x8233E630 => {
    //   block [0x8233E630..0x8233E6DC)
	// 8233E630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233E63C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E648: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8233E64C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 8233E650: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 8233E654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233E658: 48153CB1  bl 0x82492308
	ctx.lr = 0x8233E65C;
	sub_82492308(ctx, base);
	// 8233E65C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8233E660: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 8233E664: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8233E668: 419A0058  beq cr6, 0x8233e6c0
	if ctx.cr[6].eq {
	pc = 0x8233E6C0; continue 'dispatch;
	}
	// 8233E66C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8233E670: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 8233E674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233E678: 419A0018  beq cr6, 0x8233e690
	if ctx.cr[6].eq {
	pc = 0x8233E690; continue 'dispatch;
	}
	// 8233E67C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233E680: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233E684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233E688: 4E800421  bctrl
	ctx.lr = 0x8233E68C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233E68C: 4800000C  b 0x8233e698
	pc = 0x8233E698; continue 'dispatch;
	// 8233E690: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E694: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 8233E698: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E69C: 388B99D0  addi r4, r11, -0x6630
	ctx.r[4].s64 = ctx.r[11].s64 + -26160;
	// 8233E6A0: 48E69A59  bl 0x831a80f8
	ctx.lr = 0x8233E6A4;
	sub_831A80F8(ctx, base);
	// 8233E6A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E6A8: 41820018  beq 0x8233e6c0
	if ctx.cr[0].eq {
	pc = 0x8233E6C0; continue 'dispatch;
	}
	// 8233E6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E6B0: 4811C179  bl 0x8245a828
	ctx.lr = 0x8233E6B4;
	sub_8245A828(ctx, base);
	// 8233E6B4: D03E0000  stfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8233E6B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8233E6BC: 48000008  b 0x8233e6c4
	pc = 0x8233E6C4; continue 'dispatch;
	// 8233E6C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8233E6C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233E6C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233E6CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233E6D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233E6D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233E6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233E6E0 size=564
    let mut pc: u32 = 0x8233E6E0;
    'dispatch: loop {
        match pc {
            0x8233E6E0 => {
    //   block [0x8233E6E0..0x8233E914)
	// 8233E6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E6E4: 48E69A89  bl 0x831a816c
	ctx.lr = 0x8233E6E8;
	sub_831A8130(ctx, base);
	// 8233E6E8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8233E6EC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8233E6F0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E6F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233E6F8: 486D2179  bl 0x82a10870
	ctx.lr = 0x8233E6FC;
	sub_82A10870(ctx, base);
	// 8233E6FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E704: 4BFDE4D5  bl 0x8231cbd8
	ctx.lr = 0x8233E708;
	sub_8231CBD8(ctx, base);
	// 8233E708: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E70C: 408201F8  bne 0x8233e904
	if !ctx.cr[0].eq {
	pc = 0x8233E904; continue 'dispatch;
	}
	// 8233E710: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E718: 4BFD4909  bl 0x82313020
	ctx.lr = 0x8233E71C;
	sub_82313020(ctx, base);
	// 8233E71C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E720: 408201E4  bne 0x8233e904
	if !ctx.cr[0].eq {
	pc = 0x8233E904; continue 'dispatch;
	}
	// 8233E724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E728: 4BFDCDE1  bl 0x8231b508
	ctx.lr = 0x8233E72C;
	sub_8231B508(ctx, base);
	// 8233E72C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E734: 4BFD8AF5  bl 0x82317228
	ctx.lr = 0x8233E738;
	sub_82317228(ctx, base);
	// 8233E738: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E73C: 408201C8  bne 0x8233e904
	if !ctx.cr[0].eq {
	pc = 0x8233E904; continue 'dispatch;
	}
	// 8233E740: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8233E748: 388B12FC  addi r4, r11, 0x12fc
	ctx.r[4].s64 = ctx.r[11].s64 + 4860;
	// 8233E74C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E750: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 8233E754: 48AB52B5  bl 0x82df3a08
	ctx.lr = 0x8233E758;
	sub_82DF3A08(ctx, base);
	// 8233E758: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 8233E75C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8233E760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233E764: 4BFF5A75  bl 0x823341d8
	ctx.lr = 0x8233E768;
	sub_823341D8(ctx, base);
	// 8233E768: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E76C: 48AB4CBD  bl 0x82df3428
	ctx.lr = 0x8233E770;
	sub_82DF3428(ctx, base);
	// 8233E770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E774: 4BFD886D  bl 0x82316fe0
	ctx.lr = 0x8233E778;
	sub_82316FE0(ctx, base);
	// 8233E778: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E77C: C00B99C0  lfs f0, -0x6640(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233E780: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8233E784: 40980048  bge cr6, 0x8233e7cc
	if !ctx.cr[6].lt {
	pc = 0x8233E7CC; continue 'dispatch;
	}
	// 8233E788: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E78C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233E790: 808BB38C  lwz r4, -0x4c74(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19572 as u32) ) } as u64;
	// 8233E794: 48AB5275  bl 0x82df3a08
	ctx.lr = 0x8233E798;
	sub_82DF3A08(ctx, base);
	// 8233E798: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233E79C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233E7A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E7A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233E7A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233E7AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233E7B0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233E7B4: 48B202DD  bl 0x82e5ea90
	ctx.lr = 0x8233E7B8;
	sub_82E5EA90(ctx, base);
	// 8233E7B8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233E7BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233E7C0: 419A0144  beq cr6, 0x8233e904
	if ctx.cr[6].eq {
	pc = 0x8233E904; continue 'dispatch;
	}
	// 8233E7C4: 4BF820CD  bl 0x822c0890
	ctx.lr = 0x8233E7C8;
	sub_822C0890(ctx, base);
	// 8233E7C8: 4800013C  b 0x8233e904
	pc = 0x8233E904; continue 'dispatch;
	// 8233E7CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E7D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8233E7D4: 388B1378  addi r4, r11, 0x1378
	ctx.r[4].s64 = ctx.r[11].s64 + 4984;
	// 8233E7D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E7DC: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 8233E7E0: 48AB5229  bl 0x82df3a08
	ctx.lr = 0x8233E7E4;
	sub_82DF3A08(ctx, base);
	// 8233E7E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233E7E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8233E7EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233E7F0: 4BFF59E9  bl 0x823341d8
	ctx.lr = 0x8233E7F4;
	sub_823341D8(ctx, base);
	// 8233E7F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E7F8: 48AB4C31  bl 0x82df3428
	ctx.lr = 0x8233E7FC;
	sub_82DF3428(ctx, base);
	// 8233E7FC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8233E800: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233E804: 40820020  bne 0x8233e824
	if !ctx.cr[0].eq {
	pc = 0x8233E824; continue 'dispatch;
	}
	// 8233E808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E80C: 4BFDF885  bl 0x8231e090
	ctx.lr = 0x8233E810;
	sub_8231E090(ctx, base);
	// 8233E810: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233E814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E818: 4BFD5611  bl 0x82313e28
	ctx.lr = 0x8233E81C;
	sub_82313E28(ctx, base);
	// 8233E81C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E820: 408200E4  bne 0x8233e904
	if !ctx.cr[0].eq {
	pc = 0x8233E904; continue 'dispatch;
	}
	// 8233E824: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233E828: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8233E82C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8233E830: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233E834: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8233E838: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8233E83C: 41820078  beq 0x8233e8b4
	if ctx.cr[0].eq {
	pc = 0x8233E8B4; continue 'dispatch;
	}
	// 8233E840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E844: 4BFDA9A5  bl 0x823191e8
	ctx.lr = 0x8233E848;
	sub_823191E8(ctx, base);
	// 8233E848: EDA1F828  fsubs f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 8233E84C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E850: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E854: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233E858: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233E85C: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 8233E860: 808BB01C  lwz r4, -0x4fe4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20452 as u32) ) } as u64;
	// 8233E864: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8233E868: 40990034  ble cr6, 0x8233e89c
	if !ctx.cr[6].gt {
	pc = 0x8233E89C; continue 'dispatch;
	}
	// 8233E86C: 48AB519D  bl 0x82df3a08
	ctx.lr = 0x8233E870;
	sub_82DF3A08(ctx, base);
	// 8233E870: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8233E874: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8233E878: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8233E87C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8233E880: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8233E884: 4BFBA46D  bl 0x822f8cf0
	ctx.lr = 0x8233E888;
	sub_822F8CF0(ctx, base);
	// 8233E888: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233E88C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8233E890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E894: 4BFC90A5  bl 0x82307938
	ctx.lr = 0x8233E898;
	sub_82307938(ctx, base);
	// 8233E898: 48000014  b 0x8233e8ac
	pc = 0x8233E8AC; continue 'dispatch;
	// 8233E89C: 48AB516D  bl 0x82df3a08
	ctx.lr = 0x8233E8A0;
	sub_82DF3A08(ctx, base);
	// 8233E8A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8233E8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E8A8: 4BFC9031  bl 0x823078d8
	ctx.lr = 0x8233E8AC;
	sub_823078D8(ctx, base);
	// 8233E8AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E8B0: 48AB4B79  bl 0x82df3428
	ctx.lr = 0x8233E8B4;
	sub_82DF3428(ctx, base);
	// 8233E8B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E8B8: D3C10058  stfs f30, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8233E8BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E8C0: 388B1D6C  addi r4, r11, 0x1d6c
	ctx.r[4].s64 = ctx.r[11].s64 + 7532;
	// 8233E8C4: 48AB5145  bl 0x82df3a08
	ctx.lr = 0x8233E8C8;
	sub_82DF3A08(ctx, base);
	// 8233E8C8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8233E8CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8233E8D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233E8D4: 4BFFFD5D  bl 0x8233e630
	ctx.lr = 0x8233E8D8;
	sub_8233E630(ctx, base);
	// 8233E8D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233E8DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233E8E0: 48AB4B49  bl 0x82df3428
	ctx.lr = 0x8233E8E4;
	sub_82DF3428(ctx, base);
	// 8233E8E4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233E8E8: 41820010  beq 0x8233e8f8
	if ctx.cr[0].eq {
	pc = 0x8233E8F8; continue 'dispatch;
	}
	// 8233E8EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E8F0: C0210058  lfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233E8F4: 4BFC6DF5  bl 0x823056e8
	ctx.lr = 0x8233E8F8;
	sub_823056E8(ctx, base);
	// 8233E8F8: D3FE0068  stfs f31, 0x68(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8233E8FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233E900: 48D891E1  bl 0x830c7ae0
	ctx.lr = 0x8233E904;
	sub_830C7AE0(ctx, base);
	// 8233E904: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8233E908: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8233E90C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8233E910: 48E698AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233E918 size=72
    let mut pc: u32 = 0x8233E918;
    'dispatch: loop {
        match pc {
            0x8233E918 => {
    //   block [0x8233E918..0x8233E960)
	// 8233E918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E924: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E92C: 4BFF34AD  bl 0x82331dd8
	ctx.lr = 0x8233E930;
	sub_82331DD8(ctx, base);
	// 8233E930: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233E934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E938: 396B1D80  addi r11, r11, 0x1d80
	ctx.r[11].s64 = ctx.r[11].s64 + 7552;
	// 8233E93C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8233E940: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233E944: 4BFF3265  bl 0x82331ba8
	ctx.lr = 0x8233E948;
	sub_82331BA8(ctx, base);
	// 8233E948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E94C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233E950: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233E954: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233E958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233E95C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233E960 size=60
    let mut pc: u32 = 0x8233E960;
    'dispatch: loop {
        match pc {
            0x8233E960 => {
    //   block [0x8233E960..0x8233E99C)
	// 8233E960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E968: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E96C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E974: 48D8916D  bl 0x830c7ae0
	ctx.lr = 0x8233E978;
	sub_830C7AE0(ctx, base);
	// 8233E978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E97C: 486D1EF5  bl 0x82a10870
	ctx.lr = 0x8233E980;
	sub_82A10870(ctx, base);
	// 8233E980: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 8233E984: 4BFD536D  bl 0x82313cf0
	ctx.lr = 0x8233E988;
	sub_82313CF0(ctx, base);
	// 8233E988: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233E98C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233E990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233E994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233E998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233E9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233E9A0 size=348
    let mut pc: u32 = 0x8233E9A0;
    'dispatch: loop {
        match pc {
            0x8233E9A0 => {
    //   block [0x8233E9A0..0x8233EAFC)
	// 8233E9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233E9A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233E9A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233E9AC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233E9B0: 486D1EC1  bl 0x82a10870
	ctx.lr = 0x8233E9B4;
	sub_82A10870(ctx, base);
	// 8233E9B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233E9B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8233E9BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233E9C0: 4BFC70B1  bl 0x82305a70
	ctx.lr = 0x8233E9C4;
	sub_82305A70(ctx, base);
	// 8233E9C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233E9C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233E9CC: 4BFD8695  bl 0x82317060
	ctx.lr = 0x8233E9D0;
	sub_82317060(ctx, base);
	// 8233E9D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8233E9D4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 8233E9D8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8233E9DC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8233E9E0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8233E9E4: C00B89AC  lfs f0, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233E9E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233E9EC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8233E9F0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233EB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233EB00 size=272
    let mut pc: u32 = 0x8233EB00;
    'dispatch: loop {
        match pc {
            0x8233EB00 => {
    //   block [0x8233EB00..0x8233EC10)
	// 8233EB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233EB04: 48E69669  bl 0x831a816c
	ctx.lr = 0x8233EB08;
	sub_831A8130(ctx, base);
	// 8233EB08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233EB0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233EB10: 48D88FD1  bl 0x830c7ae0
	ctx.lr = 0x8233EB14;
	sub_830C7AE0(ctx, base);
	// 8233EB14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233EB18: 486D1D59  bl 0x82a10870
	ctx.lr = 0x8233EB1C;
	sub_82A10870(ctx, base);
	// 8233EB1C: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 8233EB20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233EB24: 897E2724  lbz r11, 0x2724(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10020 as u32) ) } as u64;
	// 8233EB28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233EB2C: 40820014  bne 0x8233eb40
	if !ctx.cr[0].eq {
	pc = 0x8233EB40; continue 'dispatch;
	}
	// 8233EB30: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8233EB34: 4BFCB21D  bl 0x82309d50
	ctx.lr = 0x8233EB38;
	sub_82309D50(ctx, base);
	// 8233EB38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8233EB3C: 997E2724  stb r11, 0x2724(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(10020 as u32), ctx.r[11].u8 ) };
	// 8233EB40: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233EB44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EB48: 808BB0A8  lwz r4, -0x4f58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20312 as u32) ) } as u64;
	// 8233EB4C: 48AB4EBD  bl 0x82df3a08
	ctx.lr = 0x8233EB50;
	sub_82DF3A08(ctx, base);
	// 8233EB50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8233EB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EB58: 4BFC8D81  bl 0x823078d8
	ctx.lr = 0x8233EB5C;
	sub_823078D8(ctx, base);
	// 8233EB5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EB60: 48AB48C9  bl 0x82df3428
	ctx.lr = 0x8233EB64;
	sub_82DF3428(ctx, base);
	// 8233EB64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EB68: 4BFD5099  bl 0x82313c00
	ctx.lr = 0x8233EB6C;
	sub_82313C00(ctx, base);
	// 8233EB6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233EB70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233EB74: 4BFD84ED  bl 0x82317060
	ctx.lr = 0x8233EB78;
	sub_82317060(ctx, base);
	// 8233EB78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8233EB7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EB80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8233EB84: 4BFD8725  bl 0x823172a8
	ctx.lr = 0x8233EB88;
	sub_823172A8(ctx, base);
	// 8233EB88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233EB8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EB90: 388B1DA8  addi r4, r11, 0x1da8
	ctx.r[4].s64 = ctx.r[11].s64 + 7592;
	// 8233EB94: 48AB4E75  bl 0x82df3a08
	ctx.lr = 0x8233EB98;
	sub_82DF3A08(ctx, base);
	// 8233EB98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8233EB9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EBA0: 4BFC7141  bl 0x82305ce0
	ctx.lr = 0x8233EBA4;
	sub_82305CE0(ctx, base);
	// 8233EBA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EBA8: 48AB4881  bl 0x82df3428
	ctx.lr = 0x8233EBAC;
	sub_82DF3428(ctx, base);
	// 8233EBAC: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 8233EBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EBB4: 4BFD5135  bl 0x82313ce8
	ctx.lr = 0x8233EBB8;
	sub_82313CE8(ctx, base);
	// 8233EBB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233EBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EBC0: C02BD5B8  lfs f1, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233EBC4: 4BFEFF25  bl 0x8232eae8
	ctx.lr = 0x8233EBC8;
	sub_8232EAE8(ctx, base);
	// 8233EBC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233EBCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EBD0: 388BD9BC  addi r4, r11, -0x2644
	ctx.r[4].s64 = ctx.r[11].s64 + -9796;
	// 8233EBD4: 48AB4E35  bl 0x82df3a08
	ctx.lr = 0x8233EBD8;
	sub_82DF3A08(ctx, base);
	// 8233EBD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233EBDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233EBE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233EBE4: 4BFCA155  bl 0x82308d38
	ctx.lr = 0x8233EBE8;
	sub_82308D38(ctx, base);
	// 8233EBE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233EBEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233EBF0: 419A0008  beq cr6, 0x8233ebf8
	if ctx.cr[6].eq {
	pc = 0x8233EBF8; continue 'dispatch;
	}
	// 8233EBF4: 4BF81C9D  bl 0x822c0890
	ctx.lr = 0x8233EBF8;
	sub_822C0890(ctx, base);
	// 8233EBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EBFC: 48AB482D  bl 0x82df3428
	ctx.lr = 0x8233EC00;
	sub_82DF3428(ctx, base);
	// 8233EC00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233EC04: 917D0068  stw r11, 0x68(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8233EC08: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8233EC0C: 48E695B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233EC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233EC10 size=440
    let mut pc: u32 = 0x8233EC10;
    'dispatch: loop {
        match pc {
            0x8233EC10 => {
    //   block [0x8233EC10..0x8233EDC8)
	// 8233EC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233EC14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233EC18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233EC1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233EC20: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8233EC24: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233EC28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233EC2C: 48D88EB5  bl 0x830c7ae0
	ctx.lr = 0x8233EC30;
	sub_830C7AE0(ctx, base);
	// 8233EC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EC34: 486D1C3D  bl 0x82a10870
	ctx.lr = 0x8233EC38;
	sub_82A10870(ctx, base);
	// 8233EC38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233EC3C: 4BFD3FCD  bl 0x82312c08
	ctx.lr = 0x8233EC40;
	sub_82312C08(ctx, base);
	// 8233EC40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233EC44: 41820048  beq 0x8233ec8c
	if ctx.cr[0].eq {
	pc = 0x8233EC8C; continue 'dispatch;
	}
	// 8233EC48: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233EC4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233EC50: 808BB3B4  lwz r4, -0x4c4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19532 as u32) ) } as u64;
	// 8233EC54: 48AB4DB5  bl 0x82df3a08
	ctx.lr = 0x8233EC58;
	sub_82DF3A08(ctx, base);
	// 8233EC58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233EC5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233EC60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233EC64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233EC68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233EC6C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233EC70: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233EC74: 48B1FE1D  bl 0x82e5ea90
	ctx.lr = 0x8233EC78;
	sub_82E5EA90(ctx, base);
	// 8233EC78: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233EC7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233EC80: 419A012C  beq cr6, 0x8233edac
	if ctx.cr[6].eq {
	pc = 0x8233EDAC; continue 'dispatch;
	}
	// 8233EC84: 4BF81C0D  bl 0x822c0890
	ctx.lr = 0x8233EC88;
	sub_822C0890(ctx, base);
	// 8233EC88: 48000124  b 0x8233edac
	pc = 0x8233EDAC; continue 'dispatch;
	// 8233EC8C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8233EC90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8233EC94: 41980060  blt cr6, 0x8233ecf4
	if ctx.cr[6].lt {
	pc = 0x8233ECF4; continue 'dispatch;
	}
	// 8233EC98: 409A0114  bne cr6, 0x8233edac
	if !ctx.cr[6].eq {
	pc = 0x8233EDAC; continue 'dispatch;
	}
	// 8233EC9C: 38800052  li r4, 0x52
	ctx.r[4].s64 = 82;
	// 8233ECA0: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233ECA4: 4811C145  bl 0x8245ade8
	ctx.lr = 0x8233ECA8;
	sub_8245ADE8(ctx, base);
	// 8233ECA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233ECAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8233ECB0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233ECB4: 4BFDAE35  bl 0x82319ae8
	ctx.lr = 0x8233ECB8;
	sub_82319AE8(ctx, base);
	// 8233ECB8: FC00F850  fneg f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 8233ECBC: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233ECC0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8233ECC4: 409800E8  bge cr6, 0x8233edac
	if !ctx.cr[6].lt {
	pc = 0x8233EDAC; continue 'dispatch;
	}
	// 8233ECC8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8233ECCC: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8233ECD0: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8233ECD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233ECD8: 808AB0B0  lwz r4, -0x4f50(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20304 as u32) ) } as u64;
	// 8233ECDC: 48AB4D2D  bl 0x82df3a08
	ctx.lr = 0x8233ECE0;
	sub_82DF3A08(ctx, base);
	// 8233ECE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8233ECE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233ECE8: 4BFC8BF1  bl 0x823078d8
	ctx.lr = 0x8233ECEC;
	sub_823078D8(ctx, base);
	// 8233ECEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233ECF0: 480000B8  b 0x8233eda8
	pc = 0x8233EDA8; continue 'dispatch;
	// 8233ECF4: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 8233ECF8: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233ECFC: 4811C0ED  bl 0x8245ade8
	ctx.lr = 0x8233ED00;
	sub_8245ADE8(ctx, base);
	// 8233ED00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233ED04: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233ED08: 48B1AA59  bl 0x82e59760
	ctx.lr = 0x8233ED0C;
	sub_82E59760(ctx, base);
	// 8233ED0C: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8233ED10: 40990030  ble cr6, 0x8233ed40
	if !ctx.cr[6].gt {
	pc = 0x8233ED40; continue 'dispatch;
	}
	// 8233ED14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8233ED18: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8233ED1C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8233ED20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233ED24: 808AB0AC  lwz r4, -0x4f54(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20308 as u32) ) } as u64;
	// 8233ED28: 48AB4CE1  bl 0x82df3a08
	ctx.lr = 0x8233ED2C;
	sub_82DF3A08(ctx, base);
	// 8233ED2C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8233ED30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233ED34: 4BFC8BA5  bl 0x823078d8
	ctx.lr = 0x8233ED38;
	sub_823078D8(ctx, base);
	// 8233ED38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8233ED3C: 4800006C  b 0x8233eda8
	pc = 0x8233EDA8; continue 'dispatch;
	// 8233ED40: 3880004F  li r4, 0x4f
	ctx.r[4].s64 = 79;
	// 8233ED44: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233ED48: 4811C0A1  bl 0x8245ade8
	ctx.lr = 0x8233ED4C;
	sub_8245ADE8(ctx, base);
	// 8233ED4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233ED50: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233ED54: 48B1AA0D  bl 0x82e59760
	ctx.lr = 0x8233ED58;
	sub_82E59760(ctx, base);
	// 8233ED58: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8233ED5C: 40990050  ble cr6, 0x8233edac
	if !ctx.cr[6].gt {
	pc = 0x8233EDAC; continue 'dispatch;
	}
	// 8233ED60: 38800051  li r4, 0x51
	ctx.r[4].s64 = 81;
	// 8233ED64: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233ED68: 4811C081  bl 0x8245ade8
	ctx.lr = 0x8233ED6C;
	sub_8245ADE8(ctx, base);
	// 8233ED6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233ED70: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233ED74: 4BFFFC2D  bl 0x8233e9a0
	ctx.lr = 0x8233ED78;
	sub_8233E9A0(ctx, base);
	// 8233ED78: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8233ED7C: 40980030  bge cr6, 0x8233edac
	if !ctx.cr[6].lt {
	pc = 0x8233EDAC; continue 'dispatch;
	}
	// 8233ED80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8233ED84: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8233ED88: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8233ED8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233ED90: 808AB0AC  lwz r4, -0x4f54(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20308 as u32) ) } as u64;
	// 8233ED94: 48AB4C75  bl 0x82df3a08
	ctx.lr = 0x8233ED98;
	sub_82DF3A08(ctx, base);
	// 8233ED98: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8233ED9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233EDA0: 4BFC8B39  bl 0x823078d8
	ctx.lr = 0x8233EDA4;
	sub_823078D8(ctx, base);
	// 8233EDA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233EDA8: 48AB4681  bl 0x82df3428
	ctx.lr = 0x8233EDAC;
	sub_82DF3428(ctx, base);
	// 8233EDAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8233EDB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233EDB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233EDB8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8233EDBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233EDC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233EDC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233EDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233EDC8 size=448
    let mut pc: u32 = 0x8233EDC8;
    'dispatch: loop {
        match pc {
            0x8233EDC8 => {
    //   block [0x8233EDC8..0x8233EF88)
	// 8233EDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233EDCC: 48E6939D  bl 0x831a8168
	ctx.lr = 0x8233EDD0;
	sub_831A8130(ctx, base);
	// 8233EDD0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233EDD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8233EDD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233EDDC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8233EDE0: 486D1A91  bl 0x82a10870
	ctx.lr = 0x8233EDE4;
	sub_82A10870(ctx, base);
	// 8233EDE4: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 8233EDE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233EDEC: 4BFDBC6D  bl 0x8231aa58
	ctx.lr = 0x8233EDF0;
	sub_8231AA58(ctx, base);
	// 8233EDF0: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 8233EDF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233EDF8: 4BFD5299  bl 0x82314090
	ctx.lr = 0x8233EDFC;
	sub_82314090(ctx, base);
	// 8233EDFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233EE00: 48D88CE1  bl 0x830c7ae0
	ctx.lr = 0x8233EE04;
	sub_830C7AE0(ctx, base);
	// 8233EE04: 897F0091  lbz r11, 0x91(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(145 as u32) ) } as u64;
	// 8233EE08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233EE0C: 41820050  beq 0x8233ee5c
	if ctx.cr[0].eq {
	pc = 0x8233EE5C; continue 'dispatch;
	}
	// 8233EE10: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233EE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EE18: 808BB3E0  lwz r4, -0x4c20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19488 as u32) ) } as u64;
	// 8233EE1C: 48AB4BED  bl 0x82df3a08
	ctx.lr = 0x8233EE20;
	sub_82DF3A08(ctx, base);
	// 8233EE20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233EE24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233EE28: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 8233EE2C: 48B1ABA5  bl 0x82e599d0
	ctx.lr = 0x8233EE30;
	sub_82E599D0(ctx, base);
	// 8233EE30: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233EE34: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 8233EE38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233EE3C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8233EE40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233EE44: 4E800421  bctrl
	ctx.lr = 0x8233EE48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233EE48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8233EE4C: 48AB4455  bl 0x82df32a0
	ctx.lr = 0x8233EE50;
	sub_82DF32A0(ctx, base);
	// 8233EE50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233EE54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8233EE58: 40820008  bne 0x8233ee60
	if !ctx.cr[0].eq {
	pc = 0x8233EE60; continue 'dispatch;
	}
	// 8233EE5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233EE60: 57CA07BD  rlwinm. r10, r30, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8233EE64: 557C063E  clrlwi r28, r11, 0x18
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8233EE68: 41820018  beq 0x8233ee80
	if ctx.cr[0].eq {
	pc = 0x8233EE80; continue 'dispatch;
	}
	// 8233EE6C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233EE70: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8233EE74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233EE78: 419A0008  beq cr6, 0x8233ee80
	if ctx.cr[6].eq {
	pc = 0x8233EE80; continue 'dispatch;
	}
	// 8233EE7C: 4BF81A15  bl 0x822c0890
	ctx.lr = 0x8233EE80;
	sub_822C0890(ctx, base);
	// 8233EE80: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233EE84: 4182000C  beq 0x8233ee90
	if ctx.cr[0].eq {
	pc = 0x8233EE90; continue 'dispatch;
	}
	// 8233EE88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233EE8C: 48AB459D  bl 0x82df3428
	ctx.lr = 0x8233EE90;
	sub_82DF3428(ctx, base);
	// 8233EE90: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233EE94: 418200C0  beq 0x8233ef54
	if ctx.cr[0].eq {
	pc = 0x8233EF54; continue 'dispatch;
	}
	// 8233EE98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233EE9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233EEA0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8233EEA4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8233EEA8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8233EEAC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233EEB0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233EEB4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8233EEB8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8233EEBC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8233EEC0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8233EEC4: C029CF44  lfs f1, -0x30bc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12476 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233EEC8: 48B3DD79  bl 0x82e7cc40
	ctx.lr = 0x8233EECC;
	sub_82E7CC40(ctx, base);
	// 8233EECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233EED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233EED4: 4BFD3E0D  bl 0x82312ce0
	ctx.lr = 0x8233EED8;
	sub_82312CE0(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233EF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233EF88 size=600
    let mut pc: u32 = 0x8233EF88;
    'dispatch: loop {
        match pc {
            0x8233EF88 => {
    //   block [0x8233EF88..0x8233F1E0)
	// 8233EF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233EF8C: 48E691E1  bl 0x831a816c
	ctx.lr = 0x8233EF90;
	sub_831A8130(ctx, base);
	// 8233EF90: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8233EF94: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233EF98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233EF9C: 486D18D5  bl 0x82a10870
	ctx.lr = 0x8233EFA0;
	sub_82A10870(ctx, base);
	// 8233EFA0: 3BFF0070  addi r31, r31, 0x70
	ctx.r[31].s64 = ctx.r[31].s64 + 112;
	// 8233EFA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8233EFA8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233EFAC: 3FA08326  lis r29, -0x7cda
	ctx.r[29].s64 = -2094661632;
	// 8233EFB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233EFB4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233EFB8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8233EFBC: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8233EFC0: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233EFC4: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233EFC8: FD406850  fneg f10, f13
	ctx.f[10].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8233EFCC: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8233EFD0: FD200050  fneg f9, f0
	ctx.f[9].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8233EFD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233EFD8: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8233EFDC: C1BD9A20  lfs f13, -0x65e0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-26080 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233EFE0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8233EFE4: C00B6150  lfs f0, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233EFE8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8233EFEC: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8233EFF0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8233EFF4: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8233EFF8: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8233EFFC: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8233F000: D1410084  stfs f10, 0x84(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8233F004: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8233F008: D121008C  stfs f9, 0x8c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8233F00C: 4BFC6A65  bl 0x82305a70
	ctx.lr = 0x8233F010;
	sub_82305A70(ctx, base);
	// 8233F010: 39610064  addi r11, r1, 0x64
	ctx.r[11].s64 = ctx.r[1].s64 + 100;
	// 8233F014: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8233F018: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8233F01C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8233F020: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8233F024: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8233F028: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8233F02C: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233F1E0 size=644
    let mut pc: u32 = 0x8233F1E0;
    'dispatch: loop {
        match pc {
            0x8233F1E0 => {
    //   block [0x8233F1E0..0x8233F464)
	// 8233F1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F1E4: 48E68F89  bl 0x831a816c
	ctx.lr = 0x8233F1E8;
	sub_831A8130(ctx, base);
	// 8233F1E8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8233F1EC: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F1F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233F1F4: 486D167D  bl 0x82a10870
	ctx.lr = 0x8233F1F8;
	sub_82A10870(ctx, base);
	// 8233F1F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233F1FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F200: 48D888E1  bl 0x830c7ae0
	ctx.lr = 0x8233F204;
	sub_830C7AE0(ctx, base);
	// 8233F204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233F208: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8233F20C: 4BFD8845  bl 0x82317a50
	ctx.lr = 0x8233F210;
	sub_82317A50(ctx, base);
	// 8233F210: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 8233F214: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8233F218: 38800049  li r4, 0x49
	ctx.r[4].s64 = 73;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233F468 size=500
    let mut pc: u32 = 0x8233F468;
    'dispatch: loop {
        match pc {
            0x8233F468 => {
    //   block [0x8233F468..0x8233F65C)
	// 8233F468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F46C: 48E68D01  bl 0x831a816c
	ctx.lr = 0x8233F470;
	sub_831A8130(ctx, base);
	// 8233F470: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8233F474: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233F47C: 486D13F5  bl 0x82a10870
	ctx.lr = 0x8233F480;
	sub_82A10870(ctx, base);
	// 8233F480: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233F484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F488: 48D88659  bl 0x830c7ae0
	ctx.lr = 0x8233F48C;
	sub_830C7AE0(ctx, base);
	// 8233F48C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8233F490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F494: 4BFC667D  bl 0x82305b10
	ctx.lr = 0x8233F498;
	sub_82305B10(ctx, base);
	// 8233F498: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233F49C: 4182000C  beq 0x8233f4a8
	if ctx.cr[0].eq {
	pc = 0x8233F4A8; continue 'dispatch;
	}
	// 8233F4A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8233F4A4: 997F0090  stb r11, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 8233F4A8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8233F4AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233F4B0: 41820030  beq 0x8233f4e0
	if ctx.cr[0].eq {
	pc = 0x8233F4E0; continue 'dispatch;
	}
	// 8233F4B4: 3880004B  li r4, 0x4b
	ctx.r[4].s64 = 75;
	// 8233F4B8: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233F4BC: 4811B92D  bl 0x8245ade8
	ctx.lr = 0x8233F4C0;
	sub_8245ADE8(ctx, base);
	// 8233F4C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F4C4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233F4C8: 48B1A299  bl 0x82e59760
	ctx.lr = 0x8233F4CC;
	sub_82E59760(ctx, base);
	// 8233F4CC: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8233F4D0: 40990010  ble cr6, 0x8233f4e0
	if !ctx.cr[6].gt {
	pc = 0x8233F4E0; continue 'dispatch;
	}
	// 8233F4D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F4D8: 4BFDBCE9  bl 0x8231b1c0
	ctx.lr = 0x8233F4DC;
	sub_8231B1C0(ctx, base);
	// 8233F4DC: 48000174  b 0x8233f650
	pc = 0x8233F650; continue 'dispatch;
	// 8233F4E0: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 8233F4E4: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233F4E8: 4811B901  bl 0x8245ade8
	ctx.lr = 0x8233F4EC;
	sub_8245ADE8(ctx, base);
	// 8233F4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F4F0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233F4F4: 48B1A26D  bl 0x82e59760
	ctx.lr = 0x8233F4F8;
	sub_82E59760(ctx, base);
	// 8233F4F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233F4FC: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8233F500: 3BAB1DB0  addi r29, r11, 0x1db0
	ctx.r[29].s64 = ctx.r[11].s64 + 7600;
	// 8233F504: 4098001C  bge cr6, 0x8233f520
	if !ctx.cr[6].lt {
	pc = 0x8233F520; continue 'dispatch;
	}
	// 8233F508: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8233F50C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8233F510: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 8233F514: 38C00062  li r6, 0x62
	ctx.r[6].s64 = 98;
	// 8233F518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F51C: 4BFD461D  bl 0x82313b38
	ctx.lr = 0x8233F520;
	sub_82313B38(ctx, base);
	// 8233F520: 3880004C  li r4, 0x4c
	ctx.r[4].s64 = 76;
	// 8233F524: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233F528: 4811B8C1  bl 0x8245ade8
	ctx.lr = 0x8233F52C;
	sub_8245ADE8(ctx, base);
	// 8233F52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F530: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8233F534: 48B1A22D  bl 0x82e59760
	ctx.lr = 0x8233F538;
	sub_82E59760(ctx, base);
	// 8233F538: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8233F53C: 4099003C  ble cr6, 0x8233f578
	if !ctx.cr[6].gt {
	pc = 0x8233F578; continue 'dispatch;
	}
	// 8233F540: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233F544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F548: 808BB3AC  lwz r4, -0x4c54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19540 as u32) ) } as u64;
	// 8233F54C: 48AB44BD  bl 0x82df3a08
	ctx.lr = 0x8233F550;
	sub_82DF3A08(ctx, base);
	// 8233F550: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233F554: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233F558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233F55C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233F560: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233F564: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233F568: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233F56C: 48B1F525  bl 0x82e5ea90
	ctx.lr = 0x8233F570;
	sub_82E5EA90(ctx, base);
	// 8233F570: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233F574: 480000D0  b 0x8233f644
	pc = 0x8233F644; continue 'dispatch;
	// 8233F578: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233F57C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8233F580: 4BFDA569  bl 0x82319ae8
	ctx.lr = 0x8233F584;
	sub_82319AE8(ctx, base);
	// 8233F584: 3880004A  li r4, 0x4a
	ctx.r[4].s64 = 74;
	// 8233F588: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8233F58C: 4811B85D  bl 0x8245ade8
	ctx.lr = 0x8233F590;
	sub_8245ADE8(ctx, base);
	// 8233F590: FC000850  fneg f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 8233F594: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233F598: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8233F59C: 41990008  bgt cr6, 0x8233f5a4
	if ctx.cr[6].gt {
	pc = 0x8233F5A4; continue 'dispatch;
	}
	// 8233F5A0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8233F5A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8233F5A8: 38C0006F  li r6, 0x6f
	ctx.r[6].s64 = 111;
	// 8233F5AC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8233F5B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F5B4: 4BFD4585  bl 0x82313b38
	ctx.lr = 0x8233F5B8;
	sub_82313B38(ctx, base);
	// 8233F5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F5BC: 4BFFF9CD  bl 0x8233ef88
	ctx.lr = 0x8233F5C0;
	sub_8233EF88(ctx, base);
	// 8233F5C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233F5C4: 4182003C  beq 0x8233f600
	if ctx.cr[0].eq {
	pc = 0x8233F600; continue 'dispatch;
	}
	// 8233F5C8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233F5CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F5D0: 808BB3AC  lwz r4, -0x4c54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19540 as u32) ) } as u64;
	// 8233F5D4: 48AB4435  bl 0x82df3a08
	ctx.lr = 0x8233F5D8;
	sub_82DF3A08(ctx, base);
	// 8233F5D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233F5DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233F5E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233F5E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233F5E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233F5EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233F5F0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233F5F4: 48B1F49D  bl 0x82e5ea90
	ctx.lr = 0x8233F5F8;
	sub_82E5EA90(ctx, base);
	// 8233F5F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233F5FC: 48000048  b 0x8233f644
	pc = 0x8233F644; continue 'dispatch;
	// 8233F600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F604: 4BFD3605  bl 0x82312c08
	ctx.lr = 0x8233F608;
	sub_82312C08(ctx, base);
	// 8233F608: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8233F60C: 41820044  beq 0x8233f650
	if ctx.cr[0].eq {
	pc = 0x8233F650; continue 'dispatch;
	}
	// 8233F610: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233F614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F618: 808BB3B4  lwz r4, -0x4c4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19532 as u32) ) } as u64;
	// 8233F61C: 48AB43ED  bl 0x82df3a08
	ctx.lr = 0x8233F620;
	sub_82DF3A08(ctx, base);
	// 8233F620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233F624: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233F628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233F62C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8233F630: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233F634: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8233F638: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233F63C: 48B1F455  bl 0x82e5ea90
	ctx.lr = 0x8233F640;
	sub_82E5EA90(ctx, base);
	// 8233F640: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8233F644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233F648: 419A0008  beq cr6, 0x8233f650
	if ctx.cr[6].eq {
	pc = 0x8233F650; continue 'dispatch;
	}
	// 8233F64C: 4BF81245  bl 0x822c0890
	ctx.lr = 0x8233F650;
	sub_822C0890(ctx, base);
	// 8233F650: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8233F654: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8233F658: 48E68B64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233F660 size=176
    let mut pc: u32 = 0x8233F660;
    'dispatch: loop {
        match pc {
            0x8233F660 => {
    //   block [0x8233F660..0x8233F710)
	// 8233F660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233F668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233F66C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233F670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233F678: 48E14F89  bl 0x83154600
	ctx.lr = 0x8233F67C;
	sub_83154600(ctx, base);
	// 8233F67C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233F680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F684: 48B1A0DD  bl 0x82e59760
	ctx.lr = 0x8233F688;
	sub_82E59760(ctx, base);
	// 8233F688: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233F68C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8233F690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F694: 4099000C  ble cr6, 0x8233f6a0
	if !ctx.cr[6].gt {
	pc = 0x8233F6A0; continue 'dispatch;
	}
	// 8233F698: 48B1A099  bl 0x82e59730
	ctx.lr = 0x8233F69C;
	sub_82E59730(ctx, base);
	// 8233F69C: 4800005C  b 0x8233f6f8
	pc = 0x8233F6F8; continue 'dispatch;
	// 8233F6A0: 48B1A0D9  bl 0x82e59778
	ctx.lr = 0x8233F6A4;
	sub_82E59778(ctx, base);
	// 8233F6A4: C01F006C  lfs f0, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233F6A8: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8233F6AC: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8233F6B0: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8233F6B4: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8233F6B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233F6BC: 4182000C  beq 0x8233f6c8
	if ctx.cr[0].eq {
	pc = 0x8233F6C8; continue 'dispatch;
	}
	// 8233F6C0: C00A9A24  lfs f0, -0x65dc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26076 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233F6C4: 4800000C  b 0x8233f6d0
	pc = 0x8233F6D0; continue 'dispatch;
	// 8233F6C8: 394A9A24  addi r10, r10, -0x65dc
	ctx.r[10].s64 = ctx.r[10].s64 + -26076;
	// 8233F6CC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233F6D0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8233F6D4: 41980024  blt cr6, 0x8233f6f8
	if ctx.cr[6].lt {
	pc = 0x8233F6F8; continue 'dispatch;
	}
	// 8233F6D8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8233F6DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F6E0: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8233F6E4: 989F0068  stb r4, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[4].u8 ) };
	// 8233F6E8: 4BFC6071  bl 0x82305758
	ctx.lr = 0x8233F6EC;
	sub_82305758(ctx, base);
	// 8233F6EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233F6F0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233F6F4: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8233F6F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233F6FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233F700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233F704: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233F708: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233F70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233F710 size=76
    let mut pc: u32 = 0x8233F710;
    'dispatch: loop {
        match pc {
            0x8233F710 => {
    //   block [0x8233F710..0x8233F75C)
	// 8233F710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233F718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233F71C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233F720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233F728: 48E14ED9  bl 0x83154600
	ctx.lr = 0x8233F72C;
	sub_83154600(ctx, base);
	// 8233F72C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8233F730: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233F734: 4BFC6025  bl 0x82305758
	ctx.lr = 0x8233F738;
	sub_82305758(ctx, base);
	// 8233F738: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F73C: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8233F740: 4BFE1569  bl 0x82320ca8
	ctx.lr = 0x8233F744;
	sub_82320CA8(ctx, base);
	// 8233F744: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233F748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233F74C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233F750: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233F754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233F758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233F760 size=60
    let mut pc: u32 = 0x8233F760;
    'dispatch: loop {
        match pc {
            0x8233F760 => {
    //   block [0x8233F760..0x8233F79C)
	// 8233F760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233F768: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233F76C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233F774: 48B1D1B5  bl 0x82e5c928
	ctx.lr = 0x8233F778;
	sub_82E5C928(ctx, base);
	// 8233F778: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233F77C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F780: 396B1E28  addi r11, r11, 0x1e28
	ctx.r[11].s64 = ctx.r[11].s64 + 7720;
	// 8233F784: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233F788: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233F78C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233F790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233F794: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233F798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233F7A0 size=384
    let mut pc: u32 = 0x8233F7A0;
    'dispatch: loop {
        match pc {
            0x8233F7A0 => {
    //   block [0x8233F7A0..0x8233F920)
	// 8233F7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233F7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233F7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233F7B0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 8233F7B4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8233F7B8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8233F7BC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F7C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233F7C4: 48E14E3D  bl 0x83154600
	ctx.lr = 0x8233F7C8;
	sub_83154600(ctx, base);
	// 8233F7C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233F7CC: 4BFE21F5  bl 0x823219c0
	ctx.lr = 0x8233F7D0;
	sub_823219C0(ctx, base);
	// 8233F7D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233F7D4: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 8233F7D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F7DC: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 8233F7E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8233F7E4: 4BFC5F75  bl 0x82305758
	ctx.lr = 0x8233F7E8;
	sub_82305758(ctx, base);
	// 8233F7E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233F7EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8233F7F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F7F4: 388A1E68  addi r4, r10, 0x1e68
	ctx.r[4].s64 = ctx.r[10].s64 + 7784;
	// 8233F7F8: C3AB08A4  lfs f29, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8233F7FC: D3BF006C  stfs f29, 0x6c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8233F800: 48AB4209  bl 0x82df3a08
	ctx.lr = 0x8233F804;
	sub_82DF3A08(ctx, base);
	// 8233F804: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233F808: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233F80C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233F810: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233F814: 4BFC86BD  bl 0x82307ed0
	ctx.lr = 0x8233F818;
	sub_82307ED0(ctx, base);
	// 8233F818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F81C: 48AB3C0D  bl 0x82df3428
	ctx.lr = 0x8233F820;
	sub_82DF3428(ctx, base);
	// 8233F820: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8233F824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233F828: 419A00C4  beq cr6, 0x8233f8ec
	if ctx.cr[6].eq {
	pc = 0x8233F8EC; continue 'dispatch;
	}
	// 8233F82C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233F830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F834: 388B1E58  addi r4, r11, 0x1e58
	ctx.r[4].s64 = ctx.r[11].s64 + 7768;
	// 8233F838: 48AB41D1  bl 0x82df3a08
	ctx.lr = 0x8233F83C;
	sub_82DF3A08(ctx, base);
	// 8233F83C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233F840: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8233F844: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8233F848: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 8233F84C: 3BEB9A24  addi r31, r11, -0x65dc
	ctx.r[31].s64 = ctx.r[11].s64 + -26076;
	// 8233F850: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233F854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233F858: C3EA9528  lfs f31, -0x6ad8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8233F85C: C3C9DD6C  lfs f30, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8233F860: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8233F864: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8233F868: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8233F86C: 48263945  bl 0x825a31b0
	ctx.lr = 0x8233F870;
	sub_825A31B0(ctx, base);
	// 8233F870: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233F874: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8233F878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233F87C: 482633FD  bl 0x825a2c78
	ctx.lr = 0x8233F880;
	sub_825A2C78(ctx, base);
	// 8233F880: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8233F884: 48AB3BA5  bl 0x82df3428
	ctx.lr = 0x8233F888;
	sub_82DF3428(ctx, base);
	// 8233F888: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8233F88C: 4BF8942D  bl 0x822c8cb8
	ctx.lr = 0x8233F890;
	sub_822C8CB8(ctx, base);
	// 8233F890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F894: 48AB3B95  bl 0x82df3428
	ctx.lr = 0x8233F898;
	sub_82DF3428(ctx, base);
	// 8233F898: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233F89C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F8A0: 388B1E4C  addi r4, r11, 0x1e4c
	ctx.r[4].s64 = ctx.r[11].s64 + 7756;
	// 8233F8A4: 48AB4165  bl 0x82df3a08
	ctx.lr = 0x8233F8A8;
	sub_82DF3A08(ctx, base);
	// 8233F8A8: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 8233F8AC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8233F8B0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8233F8B4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8233F8B8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8233F8BC: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8233F8C0: 482638F1  bl 0x825a31b0
	ctx.lr = 0x8233F8C4;
	sub_825A31B0(ctx, base);
	// 8233F8C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8233F8C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8233F8CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F8D0: 482633A9  bl 0x825a2c78
	ctx.lr = 0x8233F8D4;
	sub_825A2C78(ctx, base);
	// 8233F8D4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8233F8D8: 48AB3B51  bl 0x82df3428
	ctx.lr = 0x8233F8DC;
	sub_82DF3428(ctx, base);
	// 8233F8DC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8233F8E0: 4BF893D9  bl 0x822c8cb8
	ctx.lr = 0x8233F8E4;
	sub_822C8CB8(ctx, base);
	// 8233F8E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233F8E8: 48AB3B41  bl 0x82df3428
	ctx.lr = 0x8233F8EC;
	sub_82DF3428(ctx, base);
	// 8233F8EC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8233F8F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233F8F4: 419A0008  beq cr6, 0x8233f8fc
	if ctx.cr[6].eq {
	pc = 0x8233F8FC; continue 'dispatch;
	}
	// 8233F8F8: 4BF80F99  bl 0x822c0890
	ctx.lr = 0x8233F8FC;
	sub_822C0890(ctx, base);
	// 8233F8FC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8233F900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233F904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233F908: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8233F90C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8233F910: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8233F914: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233F918: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233F91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8233F920 size=12
    let mut pc: u32 = 0x8233F920;
    'dispatch: loop {
        match pc {
            0x8233F920 => {
    //   block [0x8233F920..0x8233F92C)
	// 8233F920: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233F924: 99630064  stb r11, 0x64(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 8233F928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233F930 size=68
    let mut pc: u32 = 0x8233F930;
    'dispatch: loop {
        match pc {
            0x8233F930 => {
    //   block [0x8233F930..0x8233F974)
	// 8233F930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233F938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233F93C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233F944: 48E14CBD  bl 0x83154600
	ctx.lr = 0x8233F948;
	sub_83154600(ctx, base);
	// 8233F948: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233F94C: 41820014  beq 0x8233f960
	if ctx.cr[0].eq {
	pc = 0x8233F960; continue 'dispatch;
	}
	// 8233F950: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8233F954: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 8233F958: 419A0008  beq cr6, 0x8233f960
	if ctx.cr[6].eq {
	pc = 0x8233F960; continue 'dispatch;
	}
	// 8233F95C: 4BFE12D5  bl 0x82320c30
	ctx.lr = 0x8233F960;
	sub_82320C30(ctx, base);
	// 8233F960: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233F964: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233F968: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233F96C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233F970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233F978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233F978 size=196
    let mut pc: u32 = 0x8233F978;
    'dispatch: loop {
        match pc {
            0x8233F978 => {
    //   block [0x8233F978..0x8233FA3C)
	// 8233F978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233F97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233F980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233F984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233F988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233F98C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233F990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233F994: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8233F998: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233F99C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233F9A0: 4BF80F99  bl 0x822c0938
	ctx.lr = 0x8233F9A4;
	sub_822C0938(ctx, base);
	// 8233F9A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233F9A8: 41820028  beq 0x8233f9d0
	if ctx.cr[0].eq {
	pc = 0x8233F9D0; continue 'dispatch;
	}
	// 8233F9AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233F9B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8233F9B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8233F9B8: 392B1E7C  addi r9, r11, 0x1e7c
	ctx.r[9].s64 = ctx.r[11].s64 + 7804;
	// 8233F9BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8233F9C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233F9C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8233F9C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8233F9CC: 48000008  b 0x8233f9d4
	pc = 0x8233F9D4; continue 'dispatch;
	// 8233F9D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233F9D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233F9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233F9DC: 409A0044  bne cr6, 0x8233fa20
	if !ctx.cr[6].eq {
	pc = 0x8233FA20; continue 'dispatch;
	}
	// 8233F9E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233F9E4: 419A001C  beq cr6, 0x8233fa00
	if ctx.cr[6].eq {
	pc = 0x8233FA00; continue 'dispatch;
	}
	// 8233F9E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233F9EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8233F9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233F9F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233F9F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233F9FC: 4E800421  bctrl
	ctx.lr = 0x8233FA00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233FA00: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233FA04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233FA08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233FA0C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8233FA10: 816B9AF4  lwz r11, -0x650c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25868 as u32) ) } as u64;
	// 8233FA14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8233FA18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8233FA1C: 4BF805E5  bl 0x822c0000
	ctx.lr = 0x8233FA20;
	sub_822C0000(ctx, base);
	// 8233FA20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FA24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233FA28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233FA2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233FA30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233FA34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233FA38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233FA40 size=196
    let mut pc: u32 = 0x8233FA40;
    'dispatch: loop {
        match pc {
            0x8233FA40 => {
    //   block [0x8233FA40..0x8233FB04)
	// 8233FA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233FA48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233FA4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233FA50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FA54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233FA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233FA5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8233FA60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233FA64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233FA68: 4BF80ED1  bl 0x822c0938
	ctx.lr = 0x8233FA6C;
	sub_822C0938(ctx, base);
	// 8233FA6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233FA70: 41820028  beq 0x8233fa98
	if ctx.cr[0].eq {
	pc = 0x8233FA98; continue 'dispatch;
	}
	// 8233FA74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233FA78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8233FA7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8233FA80: 392B1E90  addi r9, r11, 0x1e90
	ctx.r[9].s64 = ctx.r[11].s64 + 7824;
	// 8233FA84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8233FA88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233FA8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8233FA90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8233FA94: 48000008  b 0x8233fa9c
	pc = 0x8233FA9C; continue 'dispatch;
	// 8233FA98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233FA9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233FAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233FAA4: 409A0044  bne cr6, 0x8233fae8
	if !ctx.cr[6].eq {
	pc = 0x8233FAE8; continue 'dispatch;
	}
	// 8233FAA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233FAAC: 419A001C  beq cr6, 0x8233fac8
	if ctx.cr[6].eq {
	pc = 0x8233FAC8; continue 'dispatch;
	}
	// 8233FAB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233FAB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8233FAB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FABC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233FAC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233FAC4: 4E800421  bctrl
	ctx.lr = 0x8233FAC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233FAC8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233FACC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233FAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233FAD4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8233FAD8: 816B9AF4  lwz r11, -0x650c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25868 as u32) ) } as u64;
	// 8233FADC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8233FAE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8233FAE4: 4BF8051D  bl 0x822c0000
	ctx.lr = 0x8233FAE8;
	sub_822C0000(ctx, base);
	// 8233FAE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FAEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233FAF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233FAF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233FAF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233FAFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233FB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233FB08 size=196
    let mut pc: u32 = 0x8233FB08;
    'dispatch: loop {
        match pc {
            0x8233FB08 => {
    //   block [0x8233FB08..0x8233FBCC)
	// 8233FB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233FB10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233FB14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233FB18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FB1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233FB20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233FB24: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8233FB28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233FB2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233FB30: 4BF80E09  bl 0x822c0938
	ctx.lr = 0x8233FB34;
	sub_822C0938(ctx, base);
	// 8233FB34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233FB38: 41820028  beq 0x8233fb60
	if ctx.cr[0].eq {
	pc = 0x8233FB60; continue 'dispatch;
	}
	// 8233FB3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233FB40: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8233FB44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8233FB48: 392B1EA4  addi r9, r11, 0x1ea4
	ctx.r[9].s64 = ctx.r[11].s64 + 7844;
	// 8233FB4C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8233FB50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8233FB54: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8233FB58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8233FB5C: 48000008  b 0x8233fb64
	pc = 0x8233FB64; continue 'dispatch;
	// 8233FB60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233FB64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233FB68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233FB6C: 409A0044  bne cr6, 0x8233fbb0
	if !ctx.cr[6].eq {
	pc = 0x8233FBB0; continue 'dispatch;
	}
	// 8233FB70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8233FB74: 419A001C  beq cr6, 0x8233fb90
	if ctx.cr[6].eq {
	pc = 0x8233FB90; continue 'dispatch;
	}
	// 8233FB78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233FB7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8233FB80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FB84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233FB88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8233FB8C: 4E800421  bctrl
	ctx.lr = 0x8233FB90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8233FB90: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8233FB94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8233FB98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233FB9C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8233FBA0: 816B9AF4  lwz r11, -0x650c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25868 as u32) ) } as u64;
	// 8233FBA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8233FBA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8233FBAC: 4BF80455  bl 0x822c0000
	ctx.lr = 0x8233FBB0;
	sub_822C0000(ctx, base);
	// 8233FBB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FBB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233FBB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233FBBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233FBC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233FBC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233FBC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233FBD0 size=132
    let mut pc: u32 = 0x8233FBD0;
    'dispatch: loop {
        match pc {
            0x8233FBD0 => {
    //   block [0x8233FBD0..0x8233FC54)
	// 8233FBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233FBD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233FBDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233FBE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FBE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233FBE8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8233FBEC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8233FBF0: 48E14A11  bl 0x83154600
	ctx.lr = 0x8233FBF4;
	sub_83154600(ctx, base);
	// 8233FBF4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8233FBF8: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8233FBFC: 7D7E5B96  divwu r11, r30, r11
	ctx.r[11].u32 = ctx.r[30].u32 / ctx.r[11].u32;
	// 8233FC00: 394A9C44  addi r10, r10, -0x63bc
	ctx.r[10].s64 = ctx.r[10].s64 + -25532;
	// 8233FC04: 1D6B0005  mulli r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 * 5;
	// 8233FC08: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 8233FC0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233FC10: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8233FC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233FC18: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8233FC1C: 48AB3DED  bl 0x82df3a08
	ctx.lr = 0x8233FC20;
	sub_82DF3A08(ctx, base);
	// 8233FC20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FC24: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233FC28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8233FC2C: 4BFC85E5  bl 0x82308210
	ctx.lr = 0x8233FC30;
	sub_82308210(ctx, base);
	// 8233FC30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8233FC34: 48AB37F5  bl 0x82df3428
	ctx.lr = 0x8233FC38;
	sub_82DF3428(ctx, base);
	// 8233FC38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FC3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233FC40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233FC44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233FC48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8233FC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233FC50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233FC58 size=100
    let mut pc: u32 = 0x8233FC58;
    'dispatch: loop {
        match pc {
            0x8233FC58 => {
    //   block [0x8233FC58..0x8233FCBC)
	// 8233FC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233FC60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233FC64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FC68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233FC6C: 48B1CCBD  bl 0x82e5c928
	ctx.lr = 0x8233FC70;
	sub_82E5C928(ctx, base);
	// 8233FC70: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8233FC74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8233FC78: 394A1EE8  addi r10, r10, 0x1ee8
	ctx.r[10].s64 = ctx.r[10].s64 + 7912;
	// 8233FC7C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8233FC80: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8233FC84: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8233FC88: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8233FC8C: 993F0064  stb r9, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u8 ) };
	// 8233FC90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FC94: 911F0068  stw r8, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 8233FC98: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8233FC9C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8233FCA0: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8233FCA4: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8233FCA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233FCAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233FCB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233FCB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233FCB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233FCC0 size=80
    let mut pc: u32 = 0x8233FCC0;
    'dispatch: loop {
        match pc {
            0x8233FCC0 => {
    //   block [0x8233FCC0..0x8233FD10)
	// 8233FCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FCC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233FCC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233FCCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FCD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233FCD4: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8233FCD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233FCDC: 419A0008  beq cr6, 0x8233fce4
	if ctx.cr[6].eq {
	pc = 0x8233FCE4; continue 'dispatch;
	}
	// 8233FCE0: 4BF80BB1  bl 0x822c0890
	ctx.lr = 0x8233FCE4;
	sub_822C0890(ctx, base);
	// 8233FCE4: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8233FCE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8233FCEC: 419A0008  beq cr6, 0x8233fcf4
	if ctx.cr[6].eq {
	pc = 0x8233FCF4; continue 'dispatch;
	}
	// 8233FCF0: 4BF80BA1  bl 0x822c0890
	ctx.lr = 0x8233FCF4;
	sub_822C0890(ctx, base);
	// 8233FCF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FCF8: 48B1C891  bl 0x82e5c588
	ctx.lr = 0x8233FCFC;
	sub_82E5C588(ctx, base);
	// 8233FCFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8233FD00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8233FD04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8233FD08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8233FD0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233FD10 size=296
    let mut pc: u32 = 0x8233FD10;
    'dispatch: loop {
        match pc {
            0x8233FD10 => {
    //   block [0x8233FD10..0x8233FE38)
	// 8233FD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FD14: 48E6844D  bl 0x831a8160
	ctx.lr = 0x8233FD18;
	sub_831A8130(ctx, base);
	// 8233FD18: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FD1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8233FD20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233FD24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233FD28: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8233FD2C: 48E148D5  bl 0x83154600
	ctx.lr = 0x8233FD30;
	sub_83154600(ctx, base);
	// 8233FD30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233FD34: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8233FD38: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 8233FD3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8233FD40: 3889BA80  addi r4, r9, -0x4580
	ctx.r[4].s64 = ctx.r[9].s64 + -17792;
	// 8233FD44: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8233FD48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8233FD4C: C1AA964C  lfs f13, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8233FD50: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8233FD54: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8233FD58: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8233FD5C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8233FD60: 4BFC7A19  bl 0x82307778
	ctx.lr = 0x8233FD64;
	sub_82307778(ctx, base);
	// 8233FD64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233FD68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233FD6C: 3B6B1F10  addi r27, r11, 0x1f10
	ctx.r[27].s64 = ctx.r[11].s64 + 7952;
	// 8233FD70: 38A000E5  li r5, 0xe5
	ctx.r[5].s64 = 229;
	// 8233FD74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8233FD78: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8233FD7C: 48AB266D  bl 0x82df23e8
	ctx.lr = 0x8233FD80;
	sub_82DF23E8(ctx, base);
	// 8233FD80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233FD84: 41820014  beq 0x8233fd98
	if ctx.cr[0].eq {
	pc = 0x8233FD98; continue 'dispatch;
	}
	// 8233FD88: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8233FD8C: 48AD3365  bl 0x82e130f0
	ctx.lr = 0x8233FD90;
	sub_82E130F0(ctx, base);
	// 8233FD90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233FD94: 48000008  b 0x8233fd9c
	pc = 0x8233FD9C; continue 'dispatch;
	// 8233FD98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8233FD9C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8233FDA0: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	// 8233FDA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FDA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8233FDAC: 4BFA126D  bl 0x822e1018
	ctx.lr = 0x8233FDB0;
	sub_822E1018(ctx, base);
	// 8233FDB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8233FDB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FDB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8233FDBC: 4BF80245  bl 0x822c0000
	ctx.lr = 0x8233FDC0;
	sub_822C0000(ctx, base);
	// 8233FDC0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8233FDC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233FDC8: 38A000E7  li r5, 0xe7
	ctx.r[5].s64 = 231;
	// 8233FDCC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8233FDD0: 48AB2619  bl 0x82df23e8
	ctx.lr = 0x8233FDD4;
	sub_82DF23E8(ctx, base);
	// 8233FDD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8233FDD8: 41820030  beq 0x8233fe08
	if ctx.cr[0].eq {
	pc = 0x8233FE08; continue 'dispatch;
	}
	// 8233FDDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8233FDE0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8233FDE4: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8233FDE8: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 8233FDEC: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 8233FDF0: 48B3C181  bl 0x82e7bf70
	ctx.lr = 0x8233FDF4;
	sub_82E7BF70(ctx, base);
	// 8233FDF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8233FDF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FDFC: 48AD32F5  bl 0x82e130f0
	ctx.lr = 0x8233FE00;
	sub_82E130F0(ctx, base);
	// 8233FE00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8233FE04: 48000008  b 0x8233fe0c
	pc = 0x8233FE0C; continue 'dispatch;
	// 8233FE08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8233FE0C: 387D006C  addi r3, r29, 0x6c
	ctx.r[3].s64 = ctx.r[29].s64 + 108;
	// 8233FE10: 4BFA1F41  bl 0x822e1d50
	ctx.lr = 0x8233FE14;
	sub_822E1D50(ctx, base);
	// 8233FE14: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233FE18: 807D006C  lwz r3, 0x6c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 8233FE1C: 48AD3015  bl 0x82e12e30
	ctx.lr = 0x8233FE20;
	sub_82E12E30(ctx, base);
	// 8233FE20: 809D006C  lwz r4, 0x6c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 8233FE24: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233FE28: 48AD3009  bl 0x82e12e30
	ctx.lr = 0x8233FE2C;
	sub_82E12E30(ctx, base);
	// 8233FE2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FE30: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 8233FE34: 48E6837C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233FE38 size=120
    let mut pc: u32 = 0x8233FE38;
    'dispatch: loop {
        match pc {
            0x8233FE38 => {
    //   block [0x8233FE38..0x8233FEB0)
	// 8233FE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FE3C: 48E68331  bl 0x831a816c
	ctx.lr = 0x8233FE40;
	sub_831A8130(ctx, base);
	// 8233FE40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FE44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233FE48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233FE4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233FE50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233FE54: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8233FE58: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8233FE5C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8233FE60: 48AB2589  bl 0x82df23e8
	ctx.lr = 0x8233FE64;
	sub_82DF23E8(ctx, base);
	// 8233FE64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233FE68: 41820014  beq 0x8233fe7c
	if ctx.cr[0].eq {
	pc = 0x8233FE7C; continue 'dispatch;
	}
	// 8233FE6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FE70: 488169F1  bl 0x82b56860
	ctx.lr = 0x8233FE74;
	sub_82B56860(ctx, base);
	// 8233FE74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233FE78: 48000008  b 0x8233fe80
	pc = 0x8233FE80; continue 'dispatch;
	// 8233FE7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8233FE80: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8233FE84: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8233FE88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FE8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FE90: 4BFFFAE9  bl 0x8233f978
	ctx.lr = 0x8233FE94;
	sub_8233F978(ctx, base);
	// 8233FE94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8233FE98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FE9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FEA0: 4BF80161  bl 0x822c0000
	ctx.lr = 0x8233FEA4;
	sub_822C0000(ctx, base);
	// 8233FEA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233FEA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233FEAC: 48E68310  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233FEB0 size=128
    let mut pc: u32 = 0x8233FEB0;
    'dispatch: loop {
        match pc {
            0x8233FEB0 => {
    //   block [0x8233FEB0..0x8233FF30)
	// 8233FEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FEB4: 48E682B9  bl 0x831a816c
	ctx.lr = 0x8233FEB8;
	sub_831A8130(ctx, base);
	// 8233FEB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FEBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233FEC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233FEC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233FEC8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8233FECC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233FED0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8233FED4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8233FED8: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8233FEDC: 48AB250D  bl 0x82df23e8
	ctx.lr = 0x8233FEE0;
	sub_82DF23E8(ctx, base);
	// 8233FEE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8233FEE4: 41820018  beq 0x8233fefc
	if ctx.cr[0].eq {
	pc = 0x8233FEFC; continue 'dispatch;
	}
	// 8233FEE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FEEC: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8233FEF0: 48816909  bl 0x82b567f8
	ctx.lr = 0x8233FEF4;
	sub_82B567F8(ctx, base);
	// 8233FEF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8233FEF8: 48000008  b 0x8233ff00
	pc = 0x8233FF00; continue 'dispatch;
	// 8233FEFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8233FF00: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8233FF04: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8233FF08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FF0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FF10: 4BFFFB31  bl 0x8233fa40
	ctx.lr = 0x8233FF14;
	sub_8233FA40(ctx, base);
	// 8233FF14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8233FF18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FF1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FF20: 4BF800E1  bl 0x822c0000
	ctx.lr = 0x8233FF24;
	sub_822C0000(ctx, base);
	// 8233FF24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233FF28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233FF2C: 48E68290  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8233FF30 size=124
    let mut pc: u32 = 0x8233FF30;
    'dispatch: loop {
        match pc {
            0x8233FF30 => {
    //   block [0x8233FF30..0x8233FFAC)
	// 8233FF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FF34: 48E68239  bl 0x831a816c
	ctx.lr = 0x8233FF38;
	sub_831A8130(ctx, base);
	// 8233FF38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FF3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233FF40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8233FF44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8233FF48: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8233FF4C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8233FF50: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8233FF54: 48AB2495  bl 0x82df23e8
	ctx.lr = 0x8233FF58;
	sub_82DF23E8(ctx, base);
	// 8233FF58: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8233FF5C: 4182001C  beq 0x8233ff78
	if ctx.cr[0].eq {
	pc = 0x8233FF78; continue 'dispatch;
	}
	// 8233FF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8233FF64: 48B1971D  bl 0x82e59680
	ctx.lr = 0x8233FF68;
	sub_82E59680(ctx, base);
	// 8233FF68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8233FF6C: 396B1E74  addi r11, r11, 0x1e74
	ctx.r[11].s64 = ctx.r[11].s64 + 7796;
	// 8233FF70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8233FF74: 48000008  b 0x8233ff7c
	pc = 0x8233FF7C; continue 'dispatch;
	// 8233FF78: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8233FF7C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8233FF80: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8233FF84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FF88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FF8C: 4BFFFB7D  bl 0x8233fb08
	ctx.lr = 0x8233FF90;
	sub_8233FB08(ctx, base);
	// 8233FF90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8233FF94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8233FF98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8233FF9C: 4BF80065  bl 0x822c0000
	ctx.lr = 0x8233FFA0;
	sub_822C0000(ctx, base);
	// 8233FFA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8233FFA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8233FFA8: 48E68214  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8233FFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8233FFB0 size=172
    let mut pc: u32 = 0x8233FFB0;
    'dispatch: loop {
        match pc {
            0x8233FFB0 => {
    //   block [0x8233FFB0..0x8234005C)
	// 8233FFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8233FFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8233FFB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8233FFBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8233FFC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8233FFC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8233FFC8: 48E14639  bl 0x83154600
	ctx.lr = 0x8233FFCC;
	sub_83154600(ctx, base);
	// 8233FFCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8233FFD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8233FFD4: 4BFFFF5D  bl 0x8233ff30
	ctx.lr = 0x8233FFD8;
	sub_8233FF30(ctx, base);
	// 8233FFD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8233FFDC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8233FFE0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8233FFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8233FFE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8233FFEC: 419A0024  beq cr6, 0x82340010
	if ctx.cr[6].eq {
	pc = 0x82340010; continue 'dispatch;
	}
	// 8233FFF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8233FFF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8233FFF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8233FFFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82340000: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82340004: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82340008: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234000C: 4082FFE8  bne 0x8233fff4
	if !ctx.cr[0].eq {
	pc = 0x8233FFF4; continue 'dispatch;
	}
	// 82340010: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82340014: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82340018: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8234001C: 388A1F10  addi r4, r10, 0x1f10
	ctx.r[4].s64 = ctx.r[10].s64 + 7952;
	// 82340020: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82340024: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 82340028: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234002C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82340030: 4BFC7E59  bl 0x82307e88
	ctx.lr = 0x82340034;
	sub_82307E88(ctx, base);
	// 82340034: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82340038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234003C: 419A0008  beq cr6, 0x82340044
	if ctx.cr[6].eq {
	pc = 0x82340044; continue 'dispatch;
	}
	// 82340040: 4BF80851  bl 0x822c0890
	ctx.lr = 0x82340044;
	sub_822C0890(ctx, base);
	// 82340044: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82340048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234004C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82340050: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82340054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82340058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82340060 size=260
    let mut pc: u32 = 0x82340060;
    'dispatch: loop {
        match pc {
            0x82340060 => {
    //   block [0x82340060..0x82340164)
	// 82340060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82340064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82340068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234006C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82340070: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82340078: 897F0064  lbz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8234007C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82340080: 4182000C  beq 0x8234008c
	if ctx.cr[0].eq {
	pc = 0x8234008C; continue 'dispatch;
	}
	// 82340084: 48B196AD  bl 0x82e59730
	ctx.lr = 0x82340088;
	sub_82E59730(ctx, base);
	// 82340088: 480000C4  b 0x8234014c
	pc = 0x8234014C; continue 'dispatch;
	// 8234008C: 48E14575  bl 0x83154600
	ctx.lr = 0x82340090;
	sub_83154600(ctx, base);
	// 82340090: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82340094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82340098: 4BFD4921  bl 0x823149b8
	ctx.lr = 0x8234009C;
	sub_823149B8(ctx, base);
	// 8234009C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823400A0: 41820018  beq 0x823400b8
	if ctx.cr[0].eq {
	pc = 0x823400B8; continue 'dispatch;
	}
	// 823400A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823400A8: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 823400AC: 4BFFFF05  bl 0x8233ffb0
	ctx.lr = 0x823400B0;
	sub_8233FFB0(ctx, base);
	// 823400B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823400B4: 4BFFFFD0  b 0x82340084
	pc = 0x82340084; continue 'dispatch;
	// 823400B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 823400BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823400C0: 4BFC5AE1  bl 0x82305ba0
	ctx.lr = 0x823400C4;
	sub_82305BA0(ctx, base);
	// 823400C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823400C8: 48B196B1  bl 0x82e59778
	ctx.lr = 0x823400CC;
	sub_82E59778(ctx, base);
	// 823400CC: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823400D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823400D4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 823400D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823400DC: 4BFFFDD5  bl 0x8233feb0
	ctx.lr = 0x823400E0;
	sub_8233FEB0(ctx, base);
	// 823400E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823400E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823400E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823400EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823400F0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823400F4: 419A0024  beq cr6, 0x82340118
	if ctx.cr[6].eq {
	pc = 0x82340118; continue 'dispatch;
	}
	// 823400F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823400FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82340100: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82340104: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82340108: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234010C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82340110: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82340114: 4082FFE8  bne 0x823400fc
	if !ctx.cr[0].eq {
	pc = 0x823400FC; continue 'dispatch;
	}
	// 82340118: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234011C: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82340120: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82340124: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82340128: 388A1F10  addi r4, r10, 0x1f10
	ctx.r[4].s64 = ctx.r[10].s64 + 7952;
	// 8234012C: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 82340130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82340134: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82340138: 4BFC7D51  bl 0x82307e88
	ctx.lr = 0x8234013C;
	sub_82307E88(ctx, base);
	// 8234013C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82340140: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82340144: 419A0008  beq cr6, 0x8234014c
	if ctx.cr[6].eq {
	pc = 0x8234014C; continue 'dispatch;
	}
	// 82340148: 4BF80749  bl 0x822c0890
	ctx.lr = 0x8234014C;
	sub_822C0890(ctx, base);
	// 8234014C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82340150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82340154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82340158: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234015C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82340160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82340168 size=100
    let mut pc: u32 = 0x82340168;
    'dispatch: loop {
        match pc {
            0x82340168 => {
    //   block [0x82340168..0x823401CC)
	// 82340168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234016C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82340170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82340174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82340178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234017C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82340180: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82340184: 83DF0060  lwz r30, 0x60(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82340188: 48CC7FA1  bl 0x83008128
	ctx.lr = 0x8234018C;
	sub_83008128(ctx, base);
	// 8234018C: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82340190: 409A0024  bne cr6, 0x823401b4
	if !ctx.cr[6].eq {
	pc = 0x823401B4; continue 'dispatch;
	}
	// 82340194: 897F0064  lbz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82340198: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234019C: 40820018  bne 0x823401b4
	if !ctx.cr[0].eq {
	pc = 0x823401B4; continue 'dispatch;
	}
	// 823401A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823401A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823401A8: 997F0064  stb r11, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 823401AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823401B0: 4BFFFE01  bl 0x8233ffb0
	ctx.lr = 0x823401B4;
	sub_8233FFB0(ctx, base);
	// 823401B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823401B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823401BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823401C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823401C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823401C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823401D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823401D0 size=376
    let mut pc: u32 = 0x823401D0;
    'dispatch: loop {
        match pc {
            0x823401D0 => {
    //   block [0x823401D0..0x82340348)
	// 823401D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823401D4: 48E67F89  bl 0x831a815c
	ctx.lr = 0x823401D8;
	sub_831A8130(ctx, base);
	// 823401D8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 823401DC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 823401E0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823401E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823401E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823401EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823401F0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823401F4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823401F8: 4BFD30C9  bl 0x823132c0
	ctx.lr = 0x823401FC;
	sub_823132C0(ctx, base);
	// 823401FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82340200: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82340204: 38800090  li r4, 0x90
	ctx.r[4].s64 = 144;
	// 82340208: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8234020C: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82340210: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82340214: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 82340218: C3EB9F60  lfs f31, -0x60a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24736 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234021C: 4811AC8D  bl 0x8245aea8
	ctx.lr = 0x82340220;
	sub_8245AEA8(ctx, base);
	// 82340220: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82340224: 40810110  ble 0x82340334
	if !ctx.cr[0].gt {
	pc = 0x82340334; continue 'dispatch;
	}
	// 82340228: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8234022C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82340230: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82340234: 4BFDCC7D  bl 0x8231ceb0
	ctx.lr = 0x82340238;
	sub_8231CEB0(ctx, base);
	// 82340238: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234023C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82340240: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82340244: 409A00D4  bne cr6, 0x82340318
	if !ctx.cr[6].eq {
	pc = 0x82340318; continue 'dispatch;
	}
	// 82340248: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234024C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82340250: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82340254: 4BFFF97D  bl 0x8233fbd0
	ctx.lr = 0x82340258;
	sub_8233FBD0(ctx, base);
	// 82340258: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234025C: 48AD24B5  bl 0x82e12710
	ctx.lr = 0x82340260;
	sub_82E12710(ctx, base);
	// 82340260: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82340264: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82340268: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8234026C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82340270: 4E800421  bctrl
	ctx.lr = 0x82340274;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82340274: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82340348 size=108
    let mut pc: u32 = 0x82340348;
    'dispatch: loop {
        match pc {
            0x82340348 => {
    //   block [0x82340348..0x823403B4)
	// 82340348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234034C: 48E67E21  bl 0x831a816c
	ctx.lr = 0x82340350;
	sub_831A8130(ctx, base);
	// 82340350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340354: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82340358: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234035C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82340360: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82340364: 41820038  beq 0x8234039c
	if ctx.cr[0].eq {
	pc = 0x8234039C; continue 'dispatch;
	}
	// 82340368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234036C: 48E6961D  bl 0x831a9988
	ctx.lr = 0x82340370;
	sub_831A9988(ctx, base);
	// 82340370: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82340374: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82340378: 386B7278  addi r3, r11, 0x7278
	ctx.r[3].s64 = ctx.r[11].s64 + 29304;
	// 8234037C: 48E67D7D  bl 0x831a80f8
	ctx.lr = 0x82340380;
	sub_831A80F8(ctx, base);
	// 82340380: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82340384: 41820018  beq 0x8234039c
	if ctx.cr[0].eq {
	pc = 0x8234039C; continue 'dispatch;
	}
	// 82340388: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234038C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82340390: 4BFFFDD9  bl 0x82340168
	ctx.lr = 0x82340394;
	sub_82340168(ctx, base);
	// 82340394: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82340398: 48000014  b 0x823403ac
	pc = 0x823403AC; continue 'dispatch;
	// 8234039C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823403A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823403A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823403A8: 48E3E0E1  bl 0x8317e488
	ctx.lr = 0x823403AC;
	sub_8317E488(ctx, base);
	// 823403AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823403B0: 48E67E0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823403B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823403B8 size=500
    let mut pc: u32 = 0x823403B8;
    'dispatch: loop {
        match pc {
            0x823403B8 => {
    //   block [0x823403B8..0x823405AC)
	// 823403B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823403BC: 48E67DAD  bl 0x831a8168
	ctx.lr = 0x823403C0;
	sub_831A8130(ctx, base);
	// 823403C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823403C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823403C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823403CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823403D0: 48E14231  bl 0x83154600
	ctx.lr = 0x823403D4;
	sub_83154600(ctx, base);
	// 823403D4: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 823403D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823403DC: 4BFD45CD  bl 0x823149a8
	ctx.lr = 0x823403E0;
	sub_823149A8(ctx, base);
	// 823403E0: 817E01FC  lwz r11, 0x1fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 823403E4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823403E8: 38800090  li r4, 0x90
	ctx.r[4].s64 = 144;
	// 823403EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823403F0: 4811AAB9  bl 0x8245aea8
	ctx.lr = 0x823403F4;
	sub_8245AEA8(ctx, base);
	// 823403F4: 7F1C1800  cmpw cr6, r28, r3
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[3].s32, &mut ctx.xer);
	// 823403F8: 409900A4  ble cr6, 0x8234049c
	if !ctx.cr[6].gt {
	pc = 0x8234049C; continue 'dispatch;
	}
	// 823403FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82340400: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82340404: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82340408: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8234040C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82340410: 4BFFFA29  bl 0x8233fe38
	ctx.lr = 0x82340414;
	sub_8233FE38(ctx, base);
	// 82340414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82340418: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8234041C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82340420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82340424: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82340428: 419A0024  beq cr6, 0x8234044c
	if ctx.cr[6].eq {
	pc = 0x8234044C; continue 'dispatch;
	}
	// 8234042C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82340430: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82340434: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82340438: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234043C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82340440: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82340444: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82340448: 4082FFE8  bne 0x82340430
	if !ctx.cr[0].eq {
	pc = 0x82340430; continue 'dispatch;
	}
	// 8234044C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82340450: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82340454: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82340458: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8234045C: 388A1F10  addi r4, r10, 0x1f10
	ctx.r[4].s64 = ctx.r[10].s64 + 7952;
	// 82340460: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 82340464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82340468: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234046C: 4BFC7A1D  bl 0x82307e88
	ctx.lr = 0x82340470;
	sub_82307E88(ctx, base);
	// 82340470: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82340474: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82340478: 419A0008  beq cr6, 0x82340480
	if ctx.cr[6].eq {
	pc = 0x82340480; continue 'dispatch;
	}
	// 8234047C: 4BF80415  bl 0x822c0890
	ctx.lr = 0x82340480;
	sub_822C0890(ctx, base);
	// 82340480: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82340484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82340488: 419A0008  beq cr6, 0x82340490
	if ctx.cr[6].eq {
	pc = 0x82340490; continue 'dispatch;
	}
	// 8234048C: 4BF80405  bl 0x822c0890
	ctx.lr = 0x82340490;
	sub_822C0890(ctx, base);
	// 82340490: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82340494: 997F0064  stb r11, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 82340498: 4800010C  b 0x823405a4
	pc = 0x823405A4; continue 'dispatch;
	// 8234049C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823404A0: 4BFD2E21  bl 0x823132c0
	ctx.lr = 0x823404A4;
	sub_823132C0(ctx, base);
	// 823404A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823404A8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823404AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823404B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823404B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823404B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823404BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823404C0: 4BFFFD11  bl 0x823401d0
	ctx.lr = 0x823404C4;
	sub_823401D0(ctx, base);
	// 823404C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823404C8: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 823404CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823404D0: 419A00C4  beq cr6, 0x82340594
	if ctx.cr[6].eq {
	pc = 0x82340594; continue 'dispatch;
	}
	// 823404D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823404D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823404DC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823404E0: 4BFFF831  bl 0x8233fd10
	ctx.lr = 0x823404E4;
	sub_8233FD10(ctx, base);
	// 823404E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823404E8: 3BBF0074  addi r29, r31, 0x74
	ctx.r[29].s64 = ctx.r[31].s64 + 116;
	// 823404EC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 823404F0: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 823404F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823404F8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 823404FC: 4BF83F65  bl 0x822c4460
	ctx.lr = 0x82340500;
	sub_822C4460(ctx, base);
	// 82340500: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82340504: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82340508: 419A0008  beq cr6, 0x82340510
	if ctx.cr[6].eq {
	pc = 0x82340510; continue 'dispatch;
	}
	// 8234050C: 4BF80385  bl 0x822c0890
	ctx.lr = 0x82340510;
	sub_822C0890(ctx, base);
	// 82340510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82340514: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82340518: 4BFE1459  bl 0x82321970
	ctx.lr = 0x8234051C;
	sub_82321970(ctx, base);
	// 8234051C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82340520: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82340524: 4BFFF915  bl 0x8233fe38
	ctx.lr = 0x82340528;
	sub_8233FE38(ctx, base);
	// 82340528: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234052C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82340530: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82340534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82340538: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8234053C: 419A0024  beq cr6, 0x82340560
	if ctx.cr[6].eq {
	pc = 0x82340560; continue 'dispatch;
	}
	// 82340540: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82340544: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82340548: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234054C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82340550: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82340554: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82340558: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234055C: 4082FFE8  bne 0x82340544
	if !ctx.cr[0].eq {
	pc = 0x82340544; continue 'dispatch;
	}
	// 82340560: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82340564: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82340568: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234056C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82340570: 388A1F10  addi r4, r10, 0x1f10
	ctx.r[4].s64 = ctx.r[10].s64 + 7952;
	// 82340574: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 82340578: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234057C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82340580: 4BFC7909  bl 0x82307e88
	ctx.lr = 0x82340584;
	sub_82307E88(ctx, base);
	// 82340584: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82340588: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234058C: 419A0008  beq cr6, 0x82340594
	if ctx.cr[6].eq {
	pc = 0x82340594; continue 'dispatch;
	}
	// 82340590: 4BF80301  bl 0x822c0890
	ctx.lr = 0x82340594;
	sub_822C0890(ctx, base);
	// 82340594: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82340598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234059C: 419A0008  beq cr6, 0x823405a4
	if ctx.cr[6].eq {
	pc = 0x823405A4; continue 'dispatch;
	}
	// 823405A0: 4BF802F1  bl 0x822c0890
	ctx.lr = 0x823405A4;
	sub_822C0890(ctx, base);
	// 823405A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823405A8: 48E67C10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823405B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823405B0 size=8
    let mut pc: u32 = 0x823405B0;
    'dispatch: loop {
        match pc {
            0x823405B0 => {
    //   block [0x823405B0..0x823405B8)
	// 823405B0: 98830064  stb r4, 0x64(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[4].u8 ) };
	// 823405B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823405B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823405B8 size=104
    let mut pc: u32 = 0x823405B8;
    'dispatch: loop {
        match pc {
            0x823405B8 => {
    //   block [0x823405B8..0x82340620)
	// 823405B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823405BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823405C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823405C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823405C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823405CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823405D0: 48E14031  bl 0x83154600
	ctx.lr = 0x823405D4;
	sub_83154600(ctx, base);
	// 823405D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823405D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823405DC: 48D87505  bl 0x830c7ae0
	ctx.lr = 0x823405E0;
	sub_830C7AE0(ctx, base);
	// 823405E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823405E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823405E8: C02B9534  lfs f1, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823405EC: 4BFEE505  bl 0x8232eaf0
	ctx.lr = 0x823405F0;
	sub_8232EAF0(ctx, base);
	// 823405F0: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 823405F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823405F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823405FC: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82340600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82340604: 4E800421  bctrl
	ctx.lr = 0x82340608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82340608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234060C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82340610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82340614: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82340618: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234061C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82340620 size=76
    let mut pc: u32 = 0x82340620;
    'dispatch: loop {
        match pc {
            0x82340620 => {
    //   block [0x82340620..0x8234066C)
	// 82340620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82340624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82340628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234062C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82340630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82340638: 48E13FC9  bl 0x83154600
	ctx.lr = 0x8234063C;
	sub_83154600(ctx, base);
	// 8234063C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82340640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82340644: 48D8749D  bl 0x830c7ae0
	ctx.lr = 0x82340648;
	sub_830C7AE0(ctx, base);
	// 82340648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234064C: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82340650: 4BFDA409  bl 0x8231aa58
	ctx.lr = 0x82340654;
	sub_8231AA58(ctx, base);
	// 82340654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82340658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234065C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82340660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82340664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82340668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82340670 size=68
    let mut pc: u32 = 0x82340670;
    'dispatch: loop {
        match pc {
            0x82340670 => {
    //   block [0x82340670..0x823406B4)
	// 82340670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82340674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82340678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234067C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82340684: 48B1C2A5  bl 0x82e5c928
	ctx.lr = 0x82340688;
	sub_82E5C928(ctx, base);
	// 82340688: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234068C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82340690: 396B1F84  addi r11, r11, 0x1f84
	ctx.r[11].s64 = ctx.r[11].s64 + 8068;
	// 82340694: 995F0064  stb r10, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u8 ) };
	// 82340698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234069C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823406A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823406A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823406A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823406AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823406B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823406B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823406B8 size=192
    let mut pc: u32 = 0x823406B8;
    'dispatch: loop {
        match pc {
            0x823406B8 => {
    //   block [0x823406B8..0x82340778)
	// 823406B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823406BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823406C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823406C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823406C8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 823406CC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823406D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823406D4: 48E13F2D  bl 0x83154600
	ctx.lr = 0x823406D8;
	sub_83154600(ctx, base);
	// 823406D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823406DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823406E0: 48D87401  bl 0x830c7ae0
	ctx.lr = 0x823406E4;
	sub_830C7AE0(ctx, base);
	// 823406E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823406E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823406EC: 4BFD93FD  bl 0x82319ae8
	ctx.lr = 0x823406F0;
	sub_82319AE8(ctx, base);
	// 823406F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823406F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823406F8: 4BFD93F1  bl 0x82319ae8
	ctx.lr = 0x823406FC;
	sub_82319AE8(ctx, base);
	// 823406FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82340700: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82340704: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82340708: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8234070C: 40990014  ble cr6, 0x82340720
	if !ctx.cr[6].gt {
	pc = 0x82340720; continue 'dispatch;
	}
	// 82340710: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82340714: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82340718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234071C: 4BFD341D  bl 0x82313b38
	ctx.lr = 0x82340720;
	sub_82313B38(ctx, base);
	// 82340720: 38800043  li r4, 0x43
	ctx.r[4].s64 = 67;
	// 82340724: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82340728: 4811A6C1  bl 0x8245ade8
	ctx.lr = 0x8234072C;
	sub_8245ADE8(ctx, base);
	// 8234072C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82340730: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82340734: 48B1902D  bl 0x82e59760
	ctx.lr = 0x82340738;
	sub_82E59760(ctx, base);
	// 82340738: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8234073C: 40990020  ble cr6, 0x8234075c
	if !ctx.cr[6].gt {
	pc = 0x8234075C; continue 'dispatch;
	}
	// 82340740: 897E0064  lbz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82340744: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82340748: 4182000C  beq 0x82340754
	if ctx.cr[0].eq {
	pc = 0x82340754; continue 'dispatch;
	}
	// 8234074C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82340750: 4BFDD871  bl 0x8231dfc0
	ctx.lr = 0x82340754;
	sub_8231DFC0(ctx, base);
	// 82340754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82340758: 48B18FD9  bl 0x82e59730
	ctx.lr = 0x8234075C;
	sub_82E59730(ctx, base);
	// 8234075C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82340760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82340764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82340768: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8234076C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82340770: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82340774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82340778 size=164
    let mut pc: u32 = 0x82340778;
    'dispatch: loop {
        match pc {
            0x82340778 => {
    //   block [0x82340778..0x8234081C)
	// 82340778: C1440004  lfs f10, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8234077C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82340780: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82340784: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82340788: C1870000  lfs f12, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234078C: ECEA5828  fsubs f7, f10, f11
	ctx.f[7].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82340790: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82340794: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82340798: ED006828  fsubs f8, f0, f13
	ctx.f[8].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8234079C: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823407A0: C0C70004  lfs f6, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823407A4: ECA05828  fsubs f5, f0, f11
	ctx.f[5].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 823407A8: C0860004  lfs f4, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823407AC: ECC65028  fsubs f6, f6, f10
	ctx.f[6].f64 = (((ctx.f[6].f64 - ctx.f[10].f64) as f32) as f64);
	// 823407B0: EC845028  fsubs f4, f4, f10
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 823407B4: C14B08A4  lfs f10, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823407B8: ED2901F2  fmuls f9, f9, f7
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[7].f64) as f32) as f64);
	// 823407BC: ED0801F2  fmuls f8, f8, f7
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[7].f64) as f32) as f64);
	// 823407C0: ED26497A  fmadds f9, f6, f5, f9
	ctx.f[9].f64 = (((ctx.f[6].f64 * ctx.f[5].f64 + ctx.f[9].f64) as f32) as f64);
	// 823407C4: ED04417A  fmadds f8, f4, f5, f8
	ctx.f[8].f64 = (((ctx.f[4].f64 * ctx.f[5].f64 + ctx.f[8].f64) as f32) as f64);
	// 823407C8: ED290232  fmuls f9, f9, f8
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 823407CC: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 823407D0: 4098004C  bge cr6, 0x8234081c
	if !ctx.cr[6].lt {
		sub_8234081C(ctx, base);
		return;
	}
	// 823407D4: C1260004  lfs f9, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823407D8: ED6D5828  fsubs f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 823407DC: C1070004  lfs f8, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823407E0: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 823407E4: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823407E8: ED094028  fsubs f8, f9, f8
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 823407EC: ECE74828  fsubs f7, f7, f9
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 823407F0: C0C50004  lfs f6, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823407F4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823407F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823407FC: ED264828  fsubs f9, f6, f9
	ctx.f[9].f64 = (((ctx.f[6].f64 - ctx.f[9].f64) as f32) as f64);
	// 82340800: EDAB0232  fmuls f13, f11, f8
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[8].f64) as f32) as f64);
	// 82340804: ED670332  fmuls f11, f7, f12
	ctx.f[11].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 82340808: EDA96B3A  fmadds f13, f9, f12, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 8234080C: EC005A3A  fmadds f0, f0, f8, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64);
	// 82340810: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82340814: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82340818: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234081C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234081C size=8
    let mut pc: u32 = 0x8234081C;
    'dispatch: loop {
        match pc {
            0x8234081C => {
    //   block [0x8234081C..0x82340824)
	// 8234081C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82340820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82340828 size=124
    let mut pc: u32 = 0x82340828;
    'dispatch: loop {
        match pc {
            0x82340828 => {
    //   block [0x82340828..0x823408A4)
	// 82340828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234082C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82340830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82340834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82340838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234083C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82340840: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82340844: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82340848: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234084C: 419A0008  beq cr6, 0x82340854
	if ctx.cr[6].eq {
	pc = 0x82340854; continue 'dispatch;
	}
	// 82340850: 48AB1B89  bl 0x82df23d8
	ctx.lr = 0x82340854;
	sub_82DF23D8(ctx, base);
	// 82340854: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82340858: 57C32036  slwi r3, r30, 4
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8234085C: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82340860: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82340864: 40990008  ble cr6, 0x8234086c
	if !ctx.cr[6].gt {
	pc = 0x8234086C; continue 'dispatch;
	}
	// 82340868: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8234086C: 48AB1B55  bl 0x82df23c0
	ctx.lr = 0x82340870;
	sub_82DF23C0(ctx, base);
	// 82340870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82340874: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82340878: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 8234087C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82340880: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82340884: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82340888: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8234088C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82340890: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82340894: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82340898: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234089C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823408A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823408A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823408A8 size=144
    let mut pc: u32 = 0x823408A8;
    'dispatch: loop {
        match pc {
            0x823408A8 => {
    //   block [0x823408A8..0x82340938)
	// 823408A8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823408AC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823408B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823408B4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823408B8: 41980008  blt cr6, 0x823408c0
	if ctx.cr[6].lt {
	pc = 0x823408C0; continue 'dispatch;
	}
	// 823408BC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823408C0: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823408C4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823408C8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823408CC: 0CCB0000  twi 6, r11, 0
	// 823408D0: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 823408D4: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 823408D8: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 823408DC: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 823408E0: 7D4859D6  mullw r10, r8, r11
	ctx.r[10].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 823408E4: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823408E8: 7D693878  andc r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 & !ctx.r[7].u64;
	// 823408EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823408F0: 0CA9FFFF  twi 5, r9, -1
	// 823408F4: 409A002C  bne cr6, 0x82340920
	if !ctx.cr[6].eq {
	pc = 0x82340920; continue 'dispatch;
	}
	// 823408F8: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 823408FC: 0CCB0000  twi 6, r11, 0
	// 82340900: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 82340904: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82340908: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s64 = (ctx.r[8].s32 as i64) * (ctx.r[11].s32 as i64);
	// 8234090C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82340910: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82340914: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 82340918: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8234091C: 0CABFFFF  twi 5, r11, -1
	// 82340920: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82340924: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340928: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234092C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82340938 size=124
    let mut pc: u32 = 0x82340938;
    'dispatch: loop {
        match pc {
            0x82340938 => {
    //   block [0x82340938..0x823409B4)
	// 82340938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234093C: 48E67831  bl 0x831a816c
	ctx.lr = 0x82340940;
	sub_831A8130(ctx, base);
	// 82340940: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82340944: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340948: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234094C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82340950: 48E13CB1  bl 0x83154600
	ctx.lr = 0x82340954;
	sub_83154600(ctx, base);
	// 82340954: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82340958: 388000E1  li r4, 0xe1
	ctx.r[4].s64 = 225;
	// 8234095C: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82340960: 4811A489  bl 0x8245ade8
	ctx.lr = 0x82340964;
	sub_8245ADE8(ctx, base);
	// 82340964: 388000E2  li r4, 0xe2
	ctx.r[4].s64 = 226;
	// 82340968: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 8234096C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82340970: 4811A479  bl 0x8245ade8
	ctx.lr = 0x82340974;
	sub_8245ADE8(ctx, base);
	// 82340974: EC3F0824  fdivs f1, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 82340978: 48E6B121  bl 0x831aba98
	ctx.lr = 0x8234097C;
	sub_831ABA98(ctx, base);
	// 8234097C: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	// 82340980: 13C0E8C7  vcmpequd (lvx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340984: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82340988: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234098C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82340990: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823409B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823409B8 size=164
    let mut pc: u32 = 0x823409B8;
    'dispatch: loop {
        match pc {
            0x823409B8 => {
    //   block [0x823409B8..0x82340A5C)
	// 823409B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823409BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823409C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823409C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823409C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823409CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823409D0: 48E13C31  bl 0x83154600
	ctx.lr = 0x823409D4;
	sub_83154600(ctx, base);
	// 823409D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823409D8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823409DC: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823409E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823409E4: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 823409E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823409EC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 823409F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823409F4: 4BFC507D  bl 0x82305a70
	ctx.lr = 0x823409F8;
	sub_82305A70(ctx, base);
	// 823409F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 823409FC: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 82340A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82340A04: 48B3B345  bl 0x82e7bd48
	ctx.lr = 0x82340A08;
	sub_82E7BD48(ctx, base);
	// 82340A08: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82340A0C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82340A10: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 82340A14: 39000090  li r8, 0x90
	ctx.r[8].s64 = 144;
	// 82340A18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82340A1C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82340A20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82340A24: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82340A28: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82340A60 size=480
    let mut pc: u32 = 0x82340A60;
    'dispatch: loop {
        match pc {
            0x82340A60 => {
    //   block [0x82340A60..0x82340C40)
	// 82340A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82340A64: 48E676F9  bl 0x831a815c
	ctx.lr = 0x82340A68;
	sub_831A8130(ctx, base);
	// 82340A68: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82340A6C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82340A70: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82340A78: 48E13B89  bl 0x83154600
	ctx.lr = 0x82340A7C;
	sub_83154600(ctx, base);
	// 82340A7C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82340A80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82340A84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82340A88: 419A01A8  beq cr6, 0x82340c30
	if ctx.cr[6].eq {
	pc = 0x82340C30; continue 'dispatch;
	}
	// 82340A8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82340A90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82340A94: 48060DA5  bl 0x823a1838
	ctx.lr = 0x82340A98;
	sub_823A1838(ctx, base);
	// 82340A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82340A9C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82340AA0: 4BFC4FD1  bl 0x82305a70
	ctx.lr = 0x82340AA4;
	sub_82305A70(ctx, base);
	// 82340AA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82340AA8: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 82340AAC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82340AB0: 48B3B299  bl 0x82e7bd48
	ctx.lr = 0x82340AB4;
	sub_82E7BD48(ctx, base);
	// 82340AB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82340AB8: C01F0080  lfs f0, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82340ABC: 3B9F00E0  addi r28, r31, 0xe0
	ctx.r[28].s64 = ctx.r[31].s64 + 224;
	// 82340AC0: C1A100A8  lfs f13, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82340AC4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82340AC8: C19F0084  lfs f12, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82340ACC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82340AD0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82340AD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82340AD8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82340ADC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82340AE0: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82340AE4: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82340AE8: 48B3B261  bl 0x82e7bd48
	ctx.lr = 0x82340AEC;
	sub_82E7BD48(ctx, base);
	// 82340AEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82340AF0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82340AF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82340AF8: 3B2B9FBC  addi r25, r11, -0x6044
	ctx.r[25].s64 = ctx.r[11].s64 + -24644;
	// 82340AFC: C3CA9F78  lfs f30, -0x6088(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82340B00: 837F006C  lwz r27, 0x6c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82340B04: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82340B08: 409900E0  ble cr6, 0x82340be8
	if !ctx.cr[6].gt {
	pc = 0x82340BE8; continue 'dispatch;
	}
	// 82340B0C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82340B10: 3BBF0060  addi r29, r31, 0x60
	ctx.r[29].s64 = ctx.r[31].s64 + 96;
	// 82340B14: 3B4B9FA4  addi r26, r11, -0x605c
	ctx.r[26].s64 = ctx.r[11].s64 + -24668;
	// 82340B18: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82340B1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82340B20: 813D0010  lwz r9, 0x10(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82340B24: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82340B28: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82340B2C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82340B30: 0CC90000  twi 6, r9, 0
	// 82340B34: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82340B38: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82340B3C: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[9].s32 as i64);
	// 82340B40: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82340B44: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 82340B48: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82340B4C: 7D293878  andc r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[7].u64;
	// 82340B50: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82340B54: 0CA9FFFF  twi 5, r9, -1
	// 82340B58: 48B3B1F1  bl 0x82e7bd48
	ctx.lr = 0x82340B5C;
	sub_82E7BD48(ctx, base);
	// 82340B5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82340B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82340B64: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 82340B68: 409A0008  bne cr6, 0x82340b70
	if !ctx.cr[6].eq {
	pc = 0x82340B70; continue 'dispatch;
	}
	// 82340B6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82340B70: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82340B74: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82340B78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82340B7C: 4BF8783D  bl 0x822c83b8
	ctx.lr = 0x82340B80;
	sub_822C83B8(ctx, base);
	// 82340B80: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82340B84: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82340B88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82340B8C: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 82340B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82340B94: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 82340B98: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340B9C: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82340C40 size=216
    let mut pc: u32 = 0x82340C40;
    'dispatch: loop {
        match pc {
            0x82340C40 => {
    //   block [0x82340C40..0x82340D18)
	// 82340C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82340C44: 48E6751D  bl 0x831a8160
	ctx.lr = 0x82340C48;
	sub_831A8130(ctx, base);
	// 82340C48: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82340C4C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340C50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82340C54: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82340C58: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82340C5C: 48E139A5  bl 0x83154600
	ctx.lr = 0x82340C60;
	sub_83154600(ctx, base);
	// 82340C60: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 82340C64: 13E0D407  vcmpneb. (lvlx128) v31, v0, v26
	tmp.u32 = ctx.r[26].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340C68: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 82340C6C: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 82340C70: 389E00A0  addi r4, r30, 0xa0
	ctx.r[4].s64 = ctx.r[30].s64 + 160;
	// 82340C74: 3BFE00E0  addi r31, r30, 0xe0
	ctx.r[31].s64 = ctx.r[30].s64 + 224;
	// 82340C78: 13DBD407  vcmpneb. (lvlx128) v30, v27, v26
	tmp.u32 = ctx.r[27].u32 + ctx.r[26].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340C7C: 13BCD407  vcmpneb. (lvlx128) v29, v28, v26
	tmp.u32 = ctx.r[28].u32 + ctx.r[26].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340C80: 139DD407  vcmpneb. (lvlx128) v28, v29, v26
	tmp.u32 = ctx.r[29].u32 + ctx.r[26].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340C84: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82340D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82340D18 size=940
    let mut pc: u32 = 0x82340D18;
    'dispatch: loop {
        match pc {
            0x82340D18 => {
    //   block [0x82340D18..0x823410C4)
	// 82340D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82340D1C: 48E67441  bl 0x831a815c
	ctx.lr = 0x82340D20;
	sub_831A8130(ctx, base);
	// 82340D20: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82340D24: 48E67D4D  bl 0x831a8a70
	ctx.lr = 0x82340D28;
	sub_831A8A40(ctx, base);
	// 82340D28: 9421FDB0  stwu r1, -0x250(r1)
	ea = ctx.r[1].u32.wrapping_add(-592 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82340D2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82340D30: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82340D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82340D38: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82340D3C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82340D40: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82340D44: 48E138BD  bl 0x83154600
	ctx.lr = 0x82340D48;
	sub_83154600(ctx, base);
	// 82340D48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82340D4C: 813F006C  lwz r9, 0x6c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82340D50: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82340D54: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 82340D58: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82340D5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82340D60: C00B9F60  lfs f0, -0x60a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82340D64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82340D68: C1AA1FBC  lfs f13, 0x1fbc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82340D6C: FF800090  fmr f28, f0
	ctx.f[28].f64 = ctx.f[0].f64;
	// 82340D70: 13FF40C7  vcmpequd (lvx128) v31, v31, v8
	tmp.u32 = ctx.r[31].u32 + ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82340D74: FFA06890  fmr f29, f13
	ctx.f[29].f64 = ctx.f[13].f64;
	// 82340D78: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823410C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823410C8 size=96
    let mut pc: u32 = 0x823410C8;
    'dispatch: loop {
        match pc {
            0x823410C8 => {
    //   block [0x823410C8..0x82341128)
	// 823410C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823410CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823410D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823410D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823410D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823410DC: 48B1B84D  bl 0x82e5c928
	ctx.lr = 0x823410E0;
	sub_82E5C928(ctx, base);
	// 823410E0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823410E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823410E8: 394A1FC4  addi r10, r10, 0x1fc4
	ctx.r[10].s64 = ctx.r[10].s64 + 8132;
	// 823410EC: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 823410F0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823410F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823410F8: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823410FC: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82341100: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82341104: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82341108: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8234110C: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82341110: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82341114: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82341118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234111C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82341120: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82341124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82341128 size=104
    let mut pc: u32 = 0x82341128;
    'dispatch: loop {
        match pc {
            0x82341128 => {
    //   block [0x82341128..0x82341190)
	// 82341128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234112C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82341134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234113C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82341140: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82341144: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82341148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234114C: 419A0008  beq cr6, 0x82341154
	if ctx.cr[6].eq {
	pc = 0x82341154; continue 'dispatch;
	}
	// 82341150: 4BF7F741  bl 0x822c0890
	ctx.lr = 0x82341154;
	sub_822C0890(ctx, base);
	// 82341154: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82341158: 48AB1281  bl 0x82df23d8
	ctx.lr = 0x8234115C;
	sub_82DF23D8(ctx, base);
	// 8234115C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341160: 48B1B429  bl 0x82e5c588
	ctx.lr = 0x82341164;
	sub_82E5C588(ctx, base);
	// 82341164: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82341168: 4182000C  beq 0x82341174
	if ctx.cr[0].eq {
	pc = 0x82341174; continue 'dispatch;
	}
	// 8234116C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341170: 48AB1269  bl 0x82df23d8
	ctx.lr = 0x82341174;
	sub_82DF23D8(ctx, base);
	// 82341174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341178: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234117C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82341180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82341184: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82341188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234118C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82341190 size=156
    let mut pc: u32 = 0x82341190;
    'dispatch: loop {
        match pc {
            0x82341190 => {
    //   block [0x82341190..0x8234122C)
	// 82341190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341194: 48E66FD9  bl 0x831a816c
	ctx.lr = 0x82341198;
	sub_831A8130(ctx, base);
	// 82341198: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234119C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823411A0: 48E13461  bl 0x83154600
	ctx.lr = 0x823411A4;
	sub_83154600(ctx, base);
	// 823411A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823411A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823411AC: 388B1FE8  addi r4, r11, 0x1fe8
	ctx.r[4].s64 = ctx.r[11].s64 + 8168;
	// 823411B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823411B4: 48AB2855  bl 0x82df3a08
	ctx.lr = 0x823411B8;
	sub_82DF3A08(ctx, base);
	// 823411B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823411BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823411C0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 823411C4: 4BFC6EB5  bl 0x82308078
	ctx.lr = 0x823411C8;
	sub_82308078(ctx, base);
	// 823411C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 823411CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823411D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823411D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823411D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823411DC: 4BFC71A5  bl 0x82308380
	ctx.lr = 0x823411E0;
	sub_82308380(ctx, base);
	// 823411E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823411E4: 395F0130  addi r10, r31, 0x130
	ctx.r[10].s64 = ctx.r[31].s64 + 304;
	// 823411E8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 823411EC: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 823411F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823411F4: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 823411F8: 4BF83269  bl 0x822c4460
	ctx.lr = 0x823411FC;
	sub_822C4460(ctx, base);
	// 823411FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82341200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82341204: 419A0008  beq cr6, 0x8234120c
	if ctx.cr[6].eq {
	pc = 0x8234120C; continue 'dispatch;
	}
	// 82341208: 4BF7F689  bl 0x822c0890
	ctx.lr = 0x8234120C;
	sub_822C0890(ctx, base);
	// 8234120C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82341210: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82341214: 419A0008  beq cr6, 0x8234121c
	if ctx.cr[6].eq {
	pc = 0x8234121C; continue 'dispatch;
	}
	// 82341218: 4BF7F679  bl 0x822c0890
	ctx.lr = 0x8234121C;
	sub_822C0890(ctx, base);
	// 8234121C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82341220: 48AB2209  bl 0x82df3428
	ctx.lr = 0x82341224;
	sub_82DF3428(ctx, base);
	// 82341224: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82341228: 48E66F94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82341230 size=88
    let mut pc: u32 = 0x82341230;
    'dispatch: loop {
        match pc {
            0x82341230 => {
    //   block [0x82341230..0x82341288)
	// 82341230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234123C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82341244: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82341248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234124C: 419A0028  beq cr6, 0x82341274
	if ctx.cr[6].eq {
	pc = 0x82341274; continue 'dispatch;
	}
	// 82341250: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82341254: 48B404ED  bl 0x82e81740
	ctx.lr = 0x82341258;
	sub_82E81740(ctx, base);
	// 82341258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234125C: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82341260: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82341264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82341268: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 8234126C: 419A0008  beq cr6, 0x82341274
	if ctx.cr[6].eq {
	pc = 0x82341274; continue 'dispatch;
	}
	// 82341270: 4BF7F621  bl 0x822c0890
	ctx.lr = 0x82341274;
	sub_822C0890(ctx, base);
	// 82341274: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82341278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234127C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82341280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82341284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82341288 size=808
    let mut pc: u32 = 0x82341288;
    'dispatch: loop {
        match pc {
            0x82341288 => {
    //   block [0x82341288..0x823415B0)
	// 82341288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234128C: 48E66ED5  bl 0x831a8160
	ctx.lr = 0x82341290;
	sub_831A8130(ctx, base);
	// 82341290: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341294: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82341298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234129C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823412A0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 823412A4: 48E1335D  bl 0x83154600
	ctx.lr = 0x823412A8;
	sub_83154600(ctx, base);
	// 823412A8: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 823412AC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823412B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823412B4: 419A00B4  beq cr6, 0x82341368
	if ctx.cr[6].eq {
	pc = 0x82341368; continue 'dispatch;
	}
	// 823412B8: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 823412BC: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823412C0: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 823412C4: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 823412C8: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 823412CC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 823412D0: 13FF48C7  vcmpequd (lvx128) v31, v31, v9
	tmp.u32 = ctx.r[31].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823412D4: 37ABFFFF  addic. r29, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823412D8: 13BF50C7  vcmpequd (lvx128) v29, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823412DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823415B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823415B0 size=284
    let mut pc: u32 = 0x823415B0;
    'dispatch: loop {
        match pc {
            0x823415B0 => {
    //   block [0x823415B0..0x823416CC)
	// 823415B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823415B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823415B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823415BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823415C0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 823415C4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 823415C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823415CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823415D0: 48E13031  bl 0x83154600
	ctx.lr = 0x823415D4;
	sub_83154600(ctx, base);
	// 823415D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823415D8: 388000E2  li r4, 0xe2
	ctx.r[4].s64 = 226;
	// 823415DC: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 823415E0: 48119809  bl 0x8245ade8
	ctx.lr = 0x823415E4;
	sub_8245ADE8(ctx, base);
	// 823415E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823415E8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823415EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823415F0: 4BFC4481  bl 0x82305a70
	ctx.lr = 0x823415F4;
	sub_82305A70(ctx, base);
	// 823415F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 823415F8: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 823415FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82341600: 48B3A749  bl 0x82e7bd48
	ctx.lr = 0x82341604;
	sub_82E7BD48(ctx, base);
	// 82341604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82341608: 388000E3  li r4, 0xe3
	ctx.r[4].s64 = 227;
	// 8234160C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82341610: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82341614: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82341618: 481197D1  bl 0x8245ade8
	ctx.lr = 0x8234161C;
	sub_8245ADE8(ctx, base);
	// 8234161C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82341620: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82341624: 4BFD59BD  bl 0x82316fe0
	ctx.lr = 0x82341628;
	sub_82316FE0(ctx, base);
	// 82341628: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 8234162C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341630: 4098000C  bge cr6, 0x8234163c
	if !ctx.cr[6].lt {
	pc = 0x8234163C; continue 'dispatch;
	}
	// 82341634: 48B180FD  bl 0x82e59730
	ctx.lr = 0x82341638;
	sub_82E59730(ctx, base);
	// 82341638: 48000074  b 0x823416ac
	pc = 0x823416AC; continue 'dispatch;
	// 8234163C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82341640: 4BFFFC49  bl 0x82341288
	ctx.lr = 0x82341644;
	sub_82341288(ctx, base);
	// 82341644: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82341648: 41820010  beq 0x82341658
	if ctx.cr[0].eq {
	pc = 0x82341658; continue 'dispatch;
	}
	// 8234164C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341650: 4BFFF369  bl 0x823409b8
	ctx.lr = 0x82341654;
	sub_823409B8(ctx, base);
	// 82341654: 48000058  b 0x823416ac
	pc = 0x823416AC; continue 'dispatch;
	// 82341658: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8234165C: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 82341660: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 82341664: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82341668: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234166C: 13DF50C7  vcmpequd (lvx128) v30, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823416D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823416D0 size=360
    let mut pc: u32 = 0x823416D0;
    'dispatch: loop {
        match pc {
            0x823416D0 => {
    //   block [0x823416D0..0x82341838)
	// 823416D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823416D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823416D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823416DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823416E0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 823416E4: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82341838 size=140
    let mut pc: u32 = 0x82341838;
    'dispatch: loop {
        match pc {
            0x82341838 => {
    //   block [0x82341838..0x823418C4)
	// 82341838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234183C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82341844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234184C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82341850: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82341854: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82341858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234185C: 419A0024  beq cr6, 0x82341880
	if ctx.cr[6].eq {
	pc = 0x82341880; continue 'dispatch;
	}
	// 82341860: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82341864: 48B3FEDD  bl 0x82e81740
	ctx.lr = 0x82341868;
	sub_82E81740(ctx, base);
	// 82341868: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 8234186C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82341870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82341874: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82341878: 419A0008  beq cr6, 0x82341880
	if ctx.cr[6].eq {
	pc = 0x82341880; continue 'dispatch;
	}
	// 8234187C: 4BF7F015  bl 0x822c0890
	ctx.lr = 0x82341880;
	sub_822C0890(ctx, base);
	// 82341880: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82341884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82341888: 419A0024  beq cr6, 0x823418ac
	if ctx.cr[6].eq {
	pc = 0x823418AC; continue 'dispatch;
	}
	// 8234188C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82341890: 48B3FEB1  bl 0x82e81740
	ctx.lr = 0x82341894;
	sub_82E81740(ctx, base);
	// 82341894: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82341898: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8234189C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823418A0: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 823418A4: 419A0008  beq cr6, 0x823418ac
	if ctx.cr[6].eq {
	pc = 0x823418AC; continue 'dispatch;
	}
	// 823418A8: 4BF7EFE9  bl 0x822c0890
	ctx.lr = 0x823418AC;
	sub_822C0890(ctx, base);
	// 823418AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823418B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823418B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823418B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823418BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823418C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823418C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823418C8 size=1076
    let mut pc: u32 = 0x823418C8;
    'dispatch: loop {
        match pc {
            0x823418C8 => {
    //   block [0x823418C8..0x82341CFC)
	// 823418C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823418CC: 48E66895  bl 0x831a8160
	ctx.lr = 0x823418D0;
	sub_831A8130(ctx, base);
	// 823418D0: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 823418D4: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 823418D8: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82341D00 size=64
    let mut pc: u32 = 0x82341D00;
    'dispatch: loop {
        match pc {
            0x82341D00 => {
    //   block [0x82341D00..0x82341D40)
	// 82341D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341D04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341D08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341D0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341D10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82341D14: 48E128ED  bl 0x83154600
	ctx.lr = 0x82341D18;
	sub_83154600(ctx, base);
	// 82341D18: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82341D1C: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 82341D20: 4BFC4031  bl 0x82305d50
	ctx.lr = 0x82341D24;
	sub_82305D50(ctx, base);
	// 82341D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341D28: 4BFFFB11  bl 0x82341838
	ctx.lr = 0x82341D2C;
	sub_82341838(ctx, base);
	// 82341D2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82341D30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82341D34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82341D38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82341D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82341D40 size=200
    let mut pc: u32 = 0x82341D40;
    'dispatch: loop {
        match pc {
            0x82341D40 => {
    //   block [0x82341D40..0x82341E08)
	// 82341D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82341D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341D50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341D54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82341D58: 486CEB19  bl 0x82a10870
	ctx.lr = 0x82341D5C;
	sub_82A10870(ctx, base);
	// 82341D5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82341D60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341D64: 48B17A15  bl 0x82e59778
	ctx.lr = 0x82341D68;
	sub_82E59778(ctx, base);
	// 82341D68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82341D6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82341D70: C04B7590  lfs f2, 0x7590(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82341D74: 4BFDEE1D  bl 0x82320b90
	ctx.lr = 0x82341D78;
	sub_82320B90(ctx, base);
	// 82341D78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82341D7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82341D80: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82341D84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82341D88: 4E800421  bctrl
	ctx.lr = 0x82341D8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82341D8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82341D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341D94: 4182000C  beq 0x82341da0
	if ctx.cr[0].eq {
	pc = 0x82341DA0; continue 'dispatch;
	}
	// 82341D98: 48001801  bl 0x82343598
	ctx.lr = 0x82341D9C;
	sub_82343598(ctx, base);
	// 82341D9C: 48000054  b 0x82341df0
	pc = 0x82341DF0; continue 'dispatch;
	// 82341DA0: 48B179C9  bl 0x82e59768
	ctx.lr = 0x82341DA4;
	sub_82E59768(ctx, base);
	// 82341DA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82341DA8: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82341DAC: 48B1B0CD  bl 0x82e5ce78
	ctx.lr = 0x82341DB0;
	sub_82E5CE78(ctx, base);
	// 82341DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341DB4: 480017E5  bl 0x82343598
	ctx.lr = 0x82341DB8;
	sub_82343598(ctx, base);
	// 82341DB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82341DBC: 4BFD0E4D  bl 0x82312c08
	ctx.lr = 0x82341DC0;
	sub_82312C08(ctx, base);
	// 82341DC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82341DC4: 4182002C  beq 0x82341df0
	if ctx.cr[0].eq {
	pc = 0x82341DF0; continue 'dispatch;
	}
	// 82341DC8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82341DCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82341DD0: 808BB4EC  lwz r4, -0x4b14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19220 as u32) ) } as u64;
	// 82341DD4: 48AB1C35  bl 0x82df3a08
	ctx.lr = 0x82341DD8;
	sub_82DF3A08(ctx, base);
	// 82341DD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82341DDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82341DE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82341DE4: 4BFC3755  bl 0x82305538
	ctx.lr = 0x82341DE8;
	sub_82305538(ctx, base);
	// 82341DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82341DEC: 48AB163D  bl 0x82df3428
	ctx.lr = 0x82341DF0;
	sub_82DF3428(ctx, base);
	// 82341DF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82341DF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82341DF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82341DFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82341E00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82341E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82341E08 size=72
    let mut pc: u32 = 0x82341E08;
    'dispatch: loop {
        match pc {
            0x82341E08 => {
    //   block [0x82341E08..0x82341E50)
	// 82341E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341E10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341E14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341E18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82341E1C: 48E127E5  bl 0x83154600
	ctx.lr = 0x82341E20;
	sub_83154600(ctx, base);
	// 82341E20: 486CEA51  bl 0x82a10870
	ctx.lr = 0x82341E24;
	sub_82A10870(ctx, base);
	// 82341E24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82341E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82341E2C: 4BFD5235  bl 0x82317060
	ctx.lr = 0x82341E30;
	sub_82317060(ctx, base);
	// 82341E30: 39600060  li r11, 0x60
	ctx.r[11].s64 = 96;
	// 82341E34: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82341E50 size=196
    let mut pc: u32 = 0x82341E50;
    'dispatch: loop {
        match pc {
            0x82341E50 => {
    //   block [0x82341E50..0x82341F14)
	// 82341E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341E58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82341E5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341E60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341E64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82341E68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82341E6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82341E70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82341E74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82341E78: 4BF7EAC1  bl 0x822c0938
	ctx.lr = 0x82341E7C;
	sub_822C0938(ctx, base);
	// 82341E7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82341E80: 41820028  beq 0x82341ea8
	if ctx.cr[0].eq {
	pc = 0x82341EA8; continue 'dispatch;
	}
	// 82341E84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82341E88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82341E8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82341E90: 392B20E0  addi r9, r11, 0x20e0
	ctx.r[9].s64 = ctx.r[11].s64 + 8416;
	// 82341E94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82341E98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82341E9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82341EA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82341EA4: 48000008  b 0x82341eac
	pc = 0x82341EAC; continue 'dispatch;
	// 82341EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82341EAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82341EB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82341EB4: 409A0044  bne cr6, 0x82341ef8
	if !ctx.cr[6].eq {
	pc = 0x82341EF8; continue 'dispatch;
	}
	// 82341EB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82341EBC: 419A001C  beq cr6, 0x82341ed8
	if ctx.cr[6].eq {
	pc = 0x82341ED8; continue 'dispatch;
	}
	// 82341EC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82341EC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82341EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341ECC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82341ED0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82341ED4: 4E800421  bctrl
	ctx.lr = 0x82341ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82341ED8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82341EDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82341EE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82341EE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82341EE8: 816B9D34  lwz r11, -0x62cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25292 as u32) ) } as u64;
	// 82341EEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82341EF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82341EF4: 4BF7E10D  bl 0x822c0000
	ctx.lr = 0x82341EF8;
	sub_822C0000(ctx, base);
	// 82341EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82341EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82341F00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82341F04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82341F08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82341F0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82341F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82341F18 size=196
    let mut pc: u32 = 0x82341F18;
    'dispatch: loop {
        match pc {
            0x82341F18 => {
    //   block [0x82341F18..0x82341FDC)
	// 82341F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341F20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82341F24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341F28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341F2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82341F30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82341F34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82341F38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82341F3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82341F40: 4BF7E9F9  bl 0x822c0938
	ctx.lr = 0x82341F44;
	sub_822C0938(ctx, base);
	// 82341F44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82341F48: 41820028  beq 0x82341f70
	if ctx.cr[0].eq {
	pc = 0x82341F70; continue 'dispatch;
	}
	// 82341F4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82341F50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82341F54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82341F58: 392B20F4  addi r9, r11, 0x20f4
	ctx.r[9].s64 = ctx.r[11].s64 + 8436;
	// 82341F5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82341F60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82341F64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82341F68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82341F6C: 48000008  b 0x82341f74
	pc = 0x82341F74; continue 'dispatch;
	// 82341F70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82341F74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82341F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82341F7C: 409A0044  bne cr6, 0x82341fc0
	if !ctx.cr[6].eq {
	pc = 0x82341FC0; continue 'dispatch;
	}
	// 82341F80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82341F84: 419A001C  beq cr6, 0x82341fa0
	if ctx.cr[6].eq {
	pc = 0x82341FA0; continue 'dispatch;
	}
	// 82341F88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82341F8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82341F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82341F94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82341F98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82341F9C: 4E800421  bctrl
	ctx.lr = 0x82341FA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82341FA0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82341FA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82341FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82341FAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82341FB0: 816B9D34  lwz r11, -0x62cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25292 as u32) ) } as u64;
	// 82341FB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82341FB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82341FBC: 4BF7E045  bl 0x822c0000
	ctx.lr = 0x82341FC0;
	sub_822C0000(ctx, base);
	// 82341FC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82341FC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82341FC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82341FCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82341FD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82341FD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82341FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82341FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82341FE0 size=280
    let mut pc: u32 = 0x82341FE0;
    'dispatch: loop {
        match pc {
            0x82341FE0 => {
    //   block [0x82341FE0..0x823420F8)
	// 82341FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82341FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82341FE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82341FEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82341FF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82341FF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82341FF8: 4BFF11D1  bl 0x823331c8
	ctx.lr = 0x82341FFC;
	sub_823331C8(ctx, base);
	// 82341FFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82342000: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82342004: 388B2158  addi r4, r11, 0x2158
	ctx.r[4].s64 = ctx.r[11].s64 + 8536;
	// 82342008: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8234200C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82342010: 48AB03D9  bl 0x82df23e8
	ctx.lr = 0x82342014;
	sub_82DF23E8(ctx, base);
	// 82342014: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82342018: 4182001C  beq 0x82342034
	if ctx.cr[0].eq {
	pc = 0x82342034; continue 'dispatch;
	}
	// 8234201C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82342020: 48B1A909  bl 0x82e5c928
	ctx.lr = 0x82342024;
	sub_82E5C928(ctx, base);
	// 82342024: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82342028: 396B2108  addi r11, r11, 0x2108
	ctx.r[11].s64 = ctx.r[11].s64 + 8456;
	// 8234202C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82342030: 48000008  b 0x82342038
	pc = 0x82342038; continue 'dispatch;
	// 82342034: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82342038: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8234203C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82342040: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82342044: 4BFFFE0D  bl 0x82341e50
	ctx.lr = 0x82342048;
	sub_82341E50(ctx, base);
	// 82342048: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234204C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82342050: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82342054: 4BF7DFAD  bl 0x822c0000
	ctx.lr = 0x82342058;
	sub_822C0000(ctx, base);
	// 82342058: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8234205C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82342060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82342064: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82342068: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8234206C: 419A0024  beq cr6, 0x82342090
	if ctx.cr[6].eq {
	pc = 0x82342090; continue 'dispatch;
	}
	// 82342070: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82342074: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82342078: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234207C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82342080: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82342084: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82342088: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234208C: 4082FFE8  bne 0x82342074
	if !ctx.cr[0].eq {
	pc = 0x82342074; continue 'dispatch;
	}
	// 82342090: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82342094: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82342098: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234209C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823420A0: 389E0080  addi r4, r30, 0x80
	ctx.r[4].s64 = ctx.r[30].s64 + 128;
	// 823420A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823420A8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823420AC: 48B1C5FD  bl 0x82e5e6a8
	ctx.lr = 0x823420B0;
	sub_82E5E6A8(ctx, base);
	// 823420B0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823420B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823420B8: 419A0008  beq cr6, 0x823420c0
	if ctx.cr[6].eq {
	pc = 0x823420C0; continue 'dispatch;
	}
	// 823420BC: 4BF7E7D5  bl 0x822c0890
	ctx.lr = 0x823420C0;
	sub_822C0890(ctx, base);
	// 823420C0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823420C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823420C8: 419A0008  beq cr6, 0x823420d0
	if ctx.cr[6].eq {
	pc = 0x823420D0; continue 'dispatch;
	}
	// 823420CC: 4BF7E7C5  bl 0x822c0890
	ctx.lr = 0x823420D0;
	sub_822C0890(ctx, base);
	// 823420D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823420D4: 419A000C  beq cr6, 0x823420e0
	if ctx.cr[6].eq {
	pc = 0x823420E0; continue 'dispatch;
	}
	// 823420D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823420DC: 4BF7E7B5  bl 0x822c0890
	ctx.lr = 0x823420E0;
	sub_822C0890(ctx, base);
	// 823420E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823420E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823420E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823420EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823420F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823420F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823420F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823420F8 size=796
    let mut pc: u32 = 0x823420F8;
    'dispatch: loop {
        match pc {
            0x823420F8 => {
    //   block [0x823420F8..0x82342414)
	// 823420F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823420FC: 48E66071  bl 0x831a816c
	ctx.lr = 0x82342100;
	sub_831A8130(ctx, base);
	// 82342100: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82342104: 48E66975  bl 0x831a8a78
	ctx.lr = 0x82342108;
	sub_831A8A40(ctx, base);
	// 82342108: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234210C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82342110: 48E124F1  bl 0x83154600
	ctx.lr = 0x82342114;
	sub_83154600(ctx, base);
	// 82342114: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82342118: 486CE759  bl 0x82a10870
	ctx.lr = 0x8234211C;
	sub_82A10870(ctx, base);
	// 8234211C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82342120: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82342124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82342128: 48111521  bl 0x82453648
	ctx.lr = 0x8234212C;
	sub_82453648(ctx, base);
	// 8234212C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82342130: 4BFD0BB9  bl 0x82312ce8
	ctx.lr = 0x82342134;
	sub_82312CE8(ctx, base);
	// 82342134: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82342138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234213C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82342140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82342144: 4E800421  bctrl
	ctx.lr = 0x82342148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82342148: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234214C: 40820068  bne 0x823421b4
	if !ctx.cr[0].eq {
	pc = 0x823421B4; continue 'dispatch;
	}
	// 82342150: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82342418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82342418 size=356
    let mut pc: u32 = 0x82342418;
    'dispatch: loop {
        match pc {
            0x82342418 => {
    //   block [0x82342418..0x8234257C)
	// 82342418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234241C: 48E65D51  bl 0x831a816c
	ctx.lr = 0x82342420;
	sub_831A8130(ctx, base);
	// 82342420: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82342424: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82342428: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234242C: 48E121D5  bl 0x83154600
	ctx.lr = 0x82342430;
	sub_83154600(ctx, base);
	// 82342430: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82342434: 486CE43D  bl 0x82a10870
	ctx.lr = 0x82342438;
	sub_82A10870(ctx, base);
	// 82342438: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234243C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82342440: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82342444: 48111205  bl 0x82453648
	ctx.lr = 0x82342448;
	sub_82453648(ctx, base);
	// 82342448: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 8234244C: 807D01FC  lwz r3, 0x1fc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 82342450: 48118999  bl 0x8245ade8
	ctx.lr = 0x82342454;
	sub_8245ADE8(ctx, base);
	// 82342454: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 82342458: 807D01FC  lwz r3, 0x1fc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 8234245C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82342460: 48118989  bl 0x8245ade8
	ctx.lr = 0x82342464;
	sub_8245ADE8(ctx, base);
	// 82342464: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82342468: EC2107F2  fmuls f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 8234246C: 391E0060  addi r8, r30, 0x60
	ctx.r[8].s64 = ctx.r[30].s64 + 96;
	// 82342470: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82342474: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82342478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234247C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82342480: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82342484: 480053C5  bl 0x82347848
	ctx.lr = 0x82342488;
	sub_82347848(ctx, base);
	// 82342488: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234248C: 408200E4  bne 0x82342570
	if !ctx.cr[0].eq {
	pc = 0x82342570; continue 'dispatch;
	}
	// 82342490: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82342494: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82342498: 388B2158  addi r4, r11, 0x2158
	ctx.r[4].s64 = ctx.r[11].s64 + 8536;
	// 8234249C: 38A000AA  li r5, 0xaa
	ctx.r[5].s64 = 170;
	// 823424A0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 823424A4: 48AAFF45  bl 0x82df23e8
	ctx.lr = 0x823424A8;
	sub_82DF23E8(ctx, base);
	// 823424A8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823424AC: 4182001C  beq 0x823424c8
	if ctx.cr[0].eq {
	pc = 0x823424C8; continue 'dispatch;
	}
	// 823424B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823424B4: 48B1A475  bl 0x82e5c928
	ctx.lr = 0x823424B8;
	sub_82E5C928(ctx, base);
	// 823424B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823424BC: 396B2108  addi r11, r11, 0x2108
	ctx.r[11].s64 = ctx.r[11].s64 + 8456;
	// 823424C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823424C4: 48000008  b 0x823424cc
	pc = 0x823424CC; continue 'dispatch;
	// 823424C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823424CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823424D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823424D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823424D8: 4BFFF979  bl 0x82341e50
	ctx.lr = 0x823424DC;
	sub_82341E50(ctx, base);
	// 823424DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823424E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823424E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823424E8: 4BF7DB19  bl 0x822c0000
	ctx.lr = 0x823424EC;
	sub_822C0000(ctx, base);
	// 823424EC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823424F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823424F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823424F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 823424FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82342500: 419A0024  beq cr6, 0x82342524
	if ctx.cr[6].eq {
	pc = 0x82342524; continue 'dispatch;
	}
	// 82342504: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82342508: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234250C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82342510: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82342514: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82342518: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234251C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82342520: 4082FFE8  bne 0x82342508
	if !ctx.cr[0].eq {
	pc = 0x82342508; continue 'dispatch;
	}
	// 82342524: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82342528: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234252C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82342530: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82342534: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82342538: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8234253C: 48B1C385  bl 0x82e5e8c0
	ctx.lr = 0x82342540;
	sub_82E5E8C0(ctx, base);
	// 82342540: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82342544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82342548: 419A0008  beq cr6, 0x82342550
	if ctx.cr[6].eq {
	pc = 0x82342550; continue 'dispatch;
	}
	// 8234254C: 4BF7E345  bl 0x822c0890
	ctx.lr = 0x82342550;
	sub_822C0890(ctx, base);
	// 82342550: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82342554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82342558: 419A0008  beq cr6, 0x82342560
	if ctx.cr[6].eq {
	pc = 0x82342560; continue 'dispatch;
	}
	// 8234255C: 4BF7E335  bl 0x822c0890
	ctx.lr = 0x82342560;
	sub_822C0890(ctx, base);
	// 82342560: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82342564: 419A000C  beq cr6, 0x82342570
	if ctx.cr[6].eq {
	pc = 0x82342570; continue 'dispatch;
	}
	// 82342568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234256C: 4BF7E325  bl 0x822c0890
	ctx.lr = 0x82342570;
	sub_822C0890(ctx, base);
	// 82342570: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82342574: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82342578: 48E65C44  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82342580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82342580 size=116
    let mut pc: u32 = 0x82342580;
    'dispatch: loop {
        match pc {
            0x82342580 => {
    //   block [0x82342580..0x823425F4)
	// 82342580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82342584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82342588: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234258C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82342590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82342594: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82342598: 48000259  bl 0x823427f0
	ctx.lr = 0x8234259C;
	sub_823427F0(ctx, base);
	// 8234259C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823425A0: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 823425A4: 396B21C4  addi r11, r11, 0x21c4
	ctx.r[11].s64 = ctx.r[11].s64 + 8644;
	// 823425A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823425AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823425B0: 48B1B321  bl 0x82e5d8d0
	ctx.lr = 0x823425B4;
	sub_82E5D8D0(ctx, base);
	// 823425B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823425B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823425BC: 396B20D0  addi r11, r11, 0x20d0
	ctx.r[11].s64 = ctx.r[11].s64 + 8400;
	// 823425C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823425C4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 823425C8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823425CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823425D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823425D4: 4E800421  bctrl
	ctx.lr = 0x823425D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823425D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823425DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823425E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823425E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823425E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823425EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823425F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823425F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823425F8 size=88
    let mut pc: u32 = 0x823425F8;
    'dispatch: loop {
        match pc {
            0x823425F8 => {
    //   block [0x823425F8..0x82342650)
	// 823425F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823425FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82342600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82342604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82342608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234260C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82342610: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82342614: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82342618: 48B1B231  bl 0x82e5d848
	ctx.lr = 0x8234261C;
	sub_82E5D848(ctx, base);
	// 8234261C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82342620: 48B19F69  bl 0x82e5c588
	ctx.lr = 0x82342624;
	sub_82E5C588(ctx, base);
	// 82342624: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82342628: 4182000C  beq 0x82342634
	if ctx.cr[0].eq {
	pc = 0x82342634; continue 'dispatch;
	}
	// 8234262C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82342630: 48AAFDA9  bl 0x82df23d8
	ctx.lr = 0x82342634;
	sub_82DF23D8(ctx, base);
	// 82342634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82342638: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234263C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82342640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82342644: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82342648: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234264C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82342650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82342650 size=416
    let mut pc: u32 = 0x82342650;
    'dispatch: loop {
        match pc {
            0x82342650 => {
    //   block [0x82342650..0x823427F0)
	// 82342650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82342654: 48E65B11  bl 0x831a8164
	ctx.lr = 0x82342658;
	sub_831A8130(ctx, base);
	// 82342658: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8234265C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82342660: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82342664: 486CE20D  bl 0x82a10870
	ctx.lr = 0x82342668;
	sub_82A10870(ctx, base);
	// 82342668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234266C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82342670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82342674: 4BFD7475  bl 0x82319ae8
	ctx.lr = 0x82342678;
	sub_82319AE8(ctx, base);
	// 82342678: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234267C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82342680: 48005529  bl 0x82347ba8
	ctx.lr = 0x82342684;
	sub_82347BA8(ctx, base);
	// 82342684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82342688: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8234268C: 4BFD745D  bl 0x82319ae8
	ctx.lr = 0x82342690;
	sub_82319AE8(ctx, base);
	// 82342690: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823427F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823427F0 size=60
    let mut pc: u32 = 0x823427F0;
    'dispatch: loop {
        match pc {
            0x823427F0 => {
    //   block [0x823427F0..0x8234282C)
	// 823427F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823427F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823427F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823427FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82342800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82342804: 480039B5  bl 0x823461b8
	ctx.lr = 0x82342808;
	sub_823461B8(ctx, base);
	// 82342808: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234280C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82342810: 396B21F0  addi r11, r11, 0x21f0
	ctx.r[11].s64 = ctx.r[11].s64 + 8688;
	// 82342814: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82342818: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234281C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82342820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82342824: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82342828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82342830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82342830 size=3428
    let mut pc: u32 = 0x82342830;
    'dispatch: loop {
        match pc {
            0x82342830 => {
    //   block [0x82342830..0x82343594)
	// 82342830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82342834: 48E6592D  bl 0x831a8160
	ctx.lr = 0x82342838;
	sub_831A8130(ctx, base);
	// 82342838: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 8234283C: 48E66229  bl 0x831a8a64
	ctx.lr = 0x82342840;
	sub_831A8A40(ctx, base);
	// 82342840: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82343598 size=84
    let mut pc: u32 = 0x82343598;
    'dispatch: loop {
        match pc {
            0x82343598 => {
    //   block [0x82343598..0x823435EC)
	// 82343598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234359C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823435A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823435A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823435A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823435AC: 48D84535  bl 0x830c7ae0
	ctx.lr = 0x823435B0;
	sub_830C7AE0(ctx, base);
	// 823435B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823435B4: 486CD2BD  bl 0x82a10870
	ctx.lr = 0x823435B8;
	sub_82A10870(ctx, base);
	// 823435B8: 38800037  li r4, 0x37
	ctx.r[4].s64 = 55;
	// 823435BC: 4BFD0725  bl 0x82313ce0
	ctx.lr = 0x823435C0;
	sub_82313CE0(ctx, base);
	// 823435C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823435C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823435C8: 4182000C  beq 0x823435d4
	if ctx.cr[0].eq {
	pc = 0x823435D4; continue 'dispatch;
	}
	// 823435CC: 4BFFF085  bl 0x82342650
	ctx.lr = 0x823435D0;
	sub_82342650(ctx, base);
	// 823435D0: 48000008  b 0x823435d8
	pc = 0x823435D8; continue 'dispatch;
	// 823435D4: 4BFFF25D  bl 0x82342830
	ctx.lr = 0x823435D8;
	sub_82342830(ctx, base);
	// 823435D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823435DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823435E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823435E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823435E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823435F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823435F0 size=196
    let mut pc: u32 = 0x823435F0;
    'dispatch: loop {
        match pc {
            0x823435F0 => {
    //   block [0x823435F0..0x823436B4)
	// 823435F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823435F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823435F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823435FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82343600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343604: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234360C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82343610: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82343614: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343618: 4BF7D321  bl 0x822c0938
	ctx.lr = 0x8234361C;
	sub_822C0938(ctx, base);
	// 8234361C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82343620: 41820028  beq 0x82343648
	if ctx.cr[0].eq {
	pc = 0x82343648; continue 'dispatch;
	}
	// 82343624: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343628: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234362C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82343630: 392B22A4  addi r9, r11, 0x22a4
	ctx.r[9].s64 = ctx.r[11].s64 + 8868;
	// 82343634: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82343638: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234363C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82343640: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82343644: 48000008  b 0x8234364c
	pc = 0x8234364C; continue 'dispatch;
	// 82343648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234364C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82343654: 409A0044  bne cr6, 0x82343698
	if !ctx.cr[6].eq {
	pc = 0x82343698; continue 'dispatch;
	}
	// 82343658: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234365C: 419A001C  beq cr6, 0x82343678
	if ctx.cr[6].eq {
	pc = 0x82343678; continue 'dispatch;
	}
	// 82343660: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82343664: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82343668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234366C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82343670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82343674: 4E800421  bctrl
	ctx.lr = 0x82343678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82343678: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234367C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82343680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82343684: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82343688: 816BA004  lwz r11, -0x5ffc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24572 as u32) ) } as u64;
	// 8234368C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82343690: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82343694: 4BF7C96D  bl 0x822c0000
	ctx.lr = 0x82343698;
	sub_822C0000(ctx, base);
	// 82343698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234369C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823436A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823436A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823436A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823436AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823436B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823436B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823436B8 size=196
    let mut pc: u32 = 0x823436B8;
    'dispatch: loop {
        match pc {
            0x823436B8 => {
    //   block [0x823436B8..0x8234377C)
	// 823436B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823436BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823436C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823436C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823436C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823436CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823436D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823436D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 823436D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823436DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823436E0: 4BF7D259  bl 0x822c0938
	ctx.lr = 0x823436E4;
	sub_822C0938(ctx, base);
	// 823436E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823436E8: 41820028  beq 0x82343710
	if ctx.cr[0].eq {
	pc = 0x82343710; continue 'dispatch;
	}
	// 823436EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823436F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 823436F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823436F8: 392B22B8  addi r9, r11, 0x22b8
	ctx.r[9].s64 = ctx.r[11].s64 + 8888;
	// 823436FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82343700: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82343704: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82343708: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234370C: 48000008  b 0x82343714
	pc = 0x82343714; continue 'dispatch;
	// 82343710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82343714: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234371C: 409A0044  bne cr6, 0x82343760
	if !ctx.cr[6].eq {
	pc = 0x82343760; continue 'dispatch;
	}
	// 82343720: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82343724: 419A001C  beq cr6, 0x82343740
	if ctx.cr[6].eq {
	pc = 0x82343740; continue 'dispatch;
	}
	// 82343728: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234372C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82343730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343734: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82343738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234373C: 4E800421  bctrl
	ctx.lr = 0x82343740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82343740: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82343744: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82343748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234374C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82343750: 816BA004  lwz r11, -0x5ffc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24572 as u32) ) } as u64;
	// 82343754: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82343758: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234375C: 4BF7C8A5  bl 0x822c0000
	ctx.lr = 0x82343760;
	sub_822C0000(ctx, base);
	// 82343760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343764: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82343768: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234376C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82343770: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82343774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82343778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82343780 size=204
    let mut pc: u32 = 0x82343780;
    'dispatch: loop {
        match pc {
            0x82343780 => {
    //   block [0x82343780..0x8234384C)
	// 82343780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343784: 48E649E9  bl 0x831a816c
	ctx.lr = 0x82343788;
	sub_831A8130(ctx, base);
	// 82343788: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234378C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82343790: 48E10E71  bl 0x83154600
	ctx.lr = 0x82343794;
	sub_83154600(ctx, base);
	// 82343794: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343798: 486CD0D9  bl 0x82a10870
	ctx.lr = 0x8234379C;
	sub_82A10870(ctx, base);
	// 8234379C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823437A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823437A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823437A8: 4810FEA1  bl 0x82453648
	ctx.lr = 0x823437AC;
	sub_82453648(ctx, base);
	// 823437AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823437B0: 4BFCF539  bl 0x82312ce8
	ctx.lr = 0x823437B4;
	sub_82312CE8(ctx, base);
	// 823437B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823437B8: 4BFD4D51  bl 0x82318508
	ctx.lr = 0x823437BC;
	sub_82318508(ctx, base);
	// 823437BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823437C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823437C4: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 823437C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823437CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823437D0: C06B08A4  lfs f3, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823437D4: 480035BD  bl 0x82346d90
	ctx.lr = 0x823437D8;
	sub_82346D90(ctx, base);
	// 823437D8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 823437DC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823437E0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 823437E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823437E8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82343850 size=280
    let mut pc: u32 = 0x82343850;
    'dispatch: loop {
        match pc {
            0x82343850 => {
    //   block [0x82343850..0x82343968)
	// 82343850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82343858: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234385C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82343860: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343864: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343868: 4BFEF961  bl 0x823331c8
	ctx.lr = 0x8234386C;
	sub_823331C8(ctx, base);
	// 8234386C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343870: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82343874: 388B2318  addi r4, r11, 0x2318
	ctx.r[4].s64 = ctx.r[11].s64 + 8984;
	// 82343878: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 8234387C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82343880: 48AAEB69  bl 0x82df23e8
	ctx.lr = 0x82343884;
	sub_82DF23E8(ctx, base);
	// 82343884: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82343888: 4182001C  beq 0x823438a4
	if ctx.cr[0].eq {
	pc = 0x823438A4; continue 'dispatch;
	}
	// 8234388C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343890: 48B19099  bl 0x82e5c928
	ctx.lr = 0x82343894;
	sub_82E5C928(ctx, base);
	// 82343894: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343898: 396B22CC  addi r11, r11, 0x22cc
	ctx.r[11].s64 = ctx.r[11].s64 + 8908;
	// 8234389C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823438A0: 48000008  b 0x823438a8
	pc = 0x823438A8; continue 'dispatch;
	// 823438A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823438A8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823438AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823438B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823438B4: 4BFFFD3D  bl 0x823435f0
	ctx.lr = 0x823438B8;
	sub_823435F0(ctx, base);
	// 823438B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823438BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823438C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823438C4: 4BF7C73D  bl 0x822c0000
	ctx.lr = 0x823438C8;
	sub_822C0000(ctx, base);
	// 823438C8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823438CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823438D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823438D4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 823438D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823438DC: 419A0024  beq cr6, 0x82343900
	if ctx.cr[6].eq {
	pc = 0x82343900; continue 'dispatch;
	}
	// 823438E0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 823438E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823438E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823438EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823438F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823438F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823438F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823438FC: 4082FFE8  bne 0x823438e4
	if !ctx.cr[0].eq {
	pc = 0x823438E4; continue 'dispatch;
	}
	// 82343900: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82343904: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82343908: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234390C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82343910: 389E0080  addi r4, r30, 0x80
	ctx.r[4].s64 = ctx.r[30].s64 + 128;
	// 82343914: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82343918: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234391C: 48B1AD8D  bl 0x82e5e6a8
	ctx.lr = 0x82343920;
	sub_82E5E6A8(ctx, base);
	// 82343920: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82343924: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82343928: 419A0008  beq cr6, 0x82343930
	if ctx.cr[6].eq {
	pc = 0x82343930; continue 'dispatch;
	}
	// 8234392C: 4BF7CF65  bl 0x822c0890
	ctx.lr = 0x82343930;
	sub_822C0890(ctx, base);
	// 82343930: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82343934: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82343938: 419A0008  beq cr6, 0x82343940
	if ctx.cr[6].eq {
	pc = 0x82343940; continue 'dispatch;
	}
	// 8234393C: 4BF7CF55  bl 0x822c0890
	ctx.lr = 0x82343940;
	sub_822C0890(ctx, base);
	// 82343940: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82343944: 419A000C  beq cr6, 0x82343950
	if ctx.cr[6].eq {
	pc = 0x82343950; continue 'dispatch;
	}
	// 82343948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234394C: 4BF7CF45  bl 0x822c0890
	ctx.lr = 0x82343950;
	sub_822C0890(ctx, base);
	// 82343950: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82343954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82343958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234395C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82343960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82343964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82343968 size=556
    let mut pc: u32 = 0x82343968;
    'dispatch: loop {
        match pc {
            0x82343968 => {
    //   block [0x82343968..0x82343B94)
	// 82343968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234396C: 48E647FD  bl 0x831a8168
	ctx.lr = 0x82343970;
	sub_831A8130(ctx, base);
	// 82343970: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82343974: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343978: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234397C: 486CCEF5  bl 0x82a10870
	ctx.lr = 0x82343980;
	sub_82A10870(ctx, base);
	// 82343980: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343984: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82343988: 48B15DF1  bl 0x82e59778
	ctx.lr = 0x8234398C;
	sub_82E59778(ctx, base);
	// 8234398C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82343990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343994: C04B7590  lfs f2, 0x7590(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82343998: 4BFDD1F9  bl 0x82320b90
	ctx.lr = 0x8234399C;
	sub_82320B90(ctx, base);
	// 8234399C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823439A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823439A4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 823439A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823439AC: 4E800421  bctrl
	ctx.lr = 0x823439B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823439B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823439B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823439B8: 4182000C  beq 0x823439c4
	if ctx.cr[0].eq {
	pc = 0x823439C4; continue 'dispatch;
	}
	// 823439BC: 4BFFFBDD  bl 0x82343598
	ctx.lr = 0x823439C0;
	sub_82343598(ctx, base);
	// 823439C0: 480001C8  b 0x82343b88
	pc = 0x82343B88; continue 'dispatch;
	// 823439C4: 3B9D0080  addi r28, r29, 0x80
	ctx.r[28].s64 = ctx.r[29].s64 + 128;
	// 823439C8: 48B15DA1  bl 0x82e59768
	ctx.lr = 0x823439CC;
	sub_82E59768(ctx, base);
	// 823439CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823439D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823439D4: 48B194A5  bl 0x82e5ce78
	ctx.lr = 0x823439D8;
	sub_82E5CE78(ctx, base);
	// 823439D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823439DC: 4BFD7DD5  bl 0x8231b7b0
	ctx.lr = 0x823439E0;
	sub_8231B7B0(ctx, base);
	// 823439E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823439E4: 4BFD7B25  bl 0x8231b508
	ctx.lr = 0x823439E8;
	sub_8231B508(ctx, base);
	// 823439E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823439EC: 41820154  beq 0x82343b40
	if ctx.cr[0].eq {
	pc = 0x82343B40; continue 'dispatch;
	}
	// 823439F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823439F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823439F8: 4BFD0FC1  bl 0x823149b8
	ctx.lr = 0x823439FC;
	sub_823149B8(ctx, base);
	// 823439FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82343A00: 40820140  bne 0x82343b40
	if !ctx.cr[0].eq {
	pc = 0x82343B40; continue 'dispatch;
	}
	// 82343A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343A08: 4BFD35D9  bl 0x82316fe0
	ctx.lr = 0x82343A0C;
	sub_82316FE0(ctx, base);
	// 82343A0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343A10: C00B964C  lfs f0, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82343A14: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82343A18: 40990128  ble cr6, 0x82343b40
	if !ctx.cr[6].gt {
	pc = 0x82343B40; continue 'dispatch;
	}
	// 82343A1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82343A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82343A24: 4BFD363D  bl 0x82317060
	ctx.lr = 0x82343A28;
	sub_82317060(ctx, base);
	// 82343A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82343A2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82343A30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82343A34: 4BFC428D  bl 0x82307cc0
	ctx.lr = 0x82343A38;
	sub_82307CC0(ctx, base);
	// 82343A38: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82343A3C: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82343A40: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82343B98 size=336
    let mut pc: u32 = 0x82343B98;
    'dispatch: loop {
        match pc {
            0x82343B98 => {
    //   block [0x82343B98..0x82343CE8)
	// 82343B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343B9C: 48E645D1  bl 0x831a816c
	ctx.lr = 0x82343BA0;
	sub_831A8130(ctx, base);
	// 82343BA0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82343BA4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343BA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343BAC: 48E10A55  bl 0x83154600
	ctx.lr = 0x82343BB0;
	sub_83154600(ctx, base);
	// 82343BB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82343BB4: 486CCCBD  bl 0x82a10870
	ctx.lr = 0x82343BB8;
	sub_82A10870(ctx, base);
	// 82343BB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82343BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343BC0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82343BC4: 4810FA85  bl 0x82453648
	ctx.lr = 0x82343BC8;
	sub_82453648(ctx, base);
	// 82343BC8: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 82343BCC: 807D01FC  lwz r3, 0x1fc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 82343BD0: 48117219  bl 0x8245ade8
	ctx.lr = 0x82343BD4;
	sub_8245ADE8(ctx, base);
	// 82343BD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82343BD8: 391E0060  addi r8, r30, 0x60
	ctx.r[8].s64 = ctx.r[30].s64 + 96;
	// 82343BDC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82343BE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82343BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343BE8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82343BEC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82343BF0: 48003C59  bl 0x82347848
	ctx.lr = 0x82343BF4;
	sub_82347848(ctx, base);
	// 82343BF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82343BF8: 408200E4  bne 0x82343cdc
	if !ctx.cr[0].eq {
	pc = 0x82343CDC; continue 'dispatch;
	}
	// 82343BFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343C00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82343C04: 388B2318  addi r4, r11, 0x2318
	ctx.r[4].s64 = ctx.r[11].s64 + 8984;
	// 82343C08: 38A0009C  li r5, 0x9c
	ctx.r[5].s64 = 156;
	// 82343C0C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82343C10: 48AAE7D9  bl 0x82df23e8
	ctx.lr = 0x82343C14;
	sub_82DF23E8(ctx, base);
	// 82343C14: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82343C18: 4182001C  beq 0x82343c34
	if ctx.cr[0].eq {
	pc = 0x82343C34; continue 'dispatch;
	}
	// 82343C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343C20: 48B18D09  bl 0x82e5c928
	ctx.lr = 0x82343C24;
	sub_82E5C928(ctx, base);
	// 82343C24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343C28: 396B22CC  addi r11, r11, 0x22cc
	ctx.r[11].s64 = ctx.r[11].s64 + 8908;
	// 82343C2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343C30: 48000008  b 0x82343c38
	pc = 0x82343C38; continue 'dispatch;
	// 82343C34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82343C38: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82343C3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82343C40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82343C44: 4BFFF9AD  bl 0x823435f0
	ctx.lr = 0x82343C48;
	sub_823435F0(ctx, base);
	// 82343C48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82343C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82343C50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82343C54: 4BF7C3AD  bl 0x822c0000
	ctx.lr = 0x82343C58;
	sub_822C0000(ctx, base);
	// 82343C58: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82343C5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82343C60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82343C64: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82343C68: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82343C6C: 419A0024  beq cr6, 0x82343c90
	if ctx.cr[6].eq {
	pc = 0x82343C90; continue 'dispatch;
	}
	// 82343C70: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82343C74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82343C78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82343C7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82343C80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82343C84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82343C88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82343C8C: 4082FFE8  bne 0x82343c74
	if !ctx.cr[0].eq {
	pc = 0x82343C74; continue 'dispatch;
	}
	// 82343C90: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82343C94: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82343C98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82343C9C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82343CA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82343CA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82343CA8: 48B1AC19  bl 0x82e5e8c0
	ctx.lr = 0x82343CAC;
	sub_82E5E8C0(ctx, base);
	// 82343CAC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82343CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82343CB4: 419A0008  beq cr6, 0x82343cbc
	if ctx.cr[6].eq {
	pc = 0x82343CBC; continue 'dispatch;
	}
	// 82343CB8: 4BF7CBD9  bl 0x822c0890
	ctx.lr = 0x82343CBC;
	sub_822C0890(ctx, base);
	// 82343CBC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82343CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82343CC4: 419A0008  beq cr6, 0x82343ccc
	if ctx.cr[6].eq {
	pc = 0x82343CCC; continue 'dispatch;
	}
	// 82343CC8: 4BF7CBC9  bl 0x822c0890
	ctx.lr = 0x82343CCC;
	sub_822C0890(ctx, base);
	// 82343CCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82343CD0: 419A000C  beq cr6, 0x82343cdc
	if ctx.cr[6].eq {
	pc = 0x82343CDC; continue 'dispatch;
	}
	// 82343CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343CD8: 4BF7CBB9  bl 0x822c0890
	ctx.lr = 0x82343CDC;
	sub_822C0890(ctx, base);
	// 82343CDC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82343CE0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82343CE4: 48E644D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82343CE8 size=116
    let mut pc: u32 = 0x82343CE8;
    'dispatch: loop {
        match pc {
            0x82343CE8 => {
    //   block [0x82343CE8..0x82343D5C)
	// 82343CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343CEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82343CF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82343CF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82343CF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343CFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82343D00: 4BFFEAF1  bl 0x823427f0
	ctx.lr = 0x82343D04;
	sub_823427F0(ctx, base);
	// 82343D04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343D08: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 82343D0C: 396B2380  addi r11, r11, 0x2380
	ctx.r[11].s64 = ctx.r[11].s64 + 9088;
	// 82343D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343D14: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343D18: 48B19BB9  bl 0x82e5d8d0
	ctx.lr = 0x82343D1C;
	sub_82E5D8D0(ctx, base);
	// 82343D1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343D20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82343D24: 396B2294  addi r11, r11, 0x2294
	ctx.r[11].s64 = ctx.r[11].s64 + 8852;
	// 82343D28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343D2C: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82343D30: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82343D34: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82343D38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82343D3C: 4E800421  bctrl
	ctx.lr = 0x82343D40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82343D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343D44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82343D48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82343D4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82343D50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82343D54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82343D58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82343D60 size=200
    let mut pc: u32 = 0x82343D60;
    'dispatch: loop {
        match pc {
            0x82343D60 => {
    //   block [0x82343D60..0x82343E28)
	// 82343D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82343D68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82343D6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82343D70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82343D78: 486CCAF9  bl 0x82a10870
	ctx.lr = 0x82343D7C;
	sub_82A10870(ctx, base);
	// 82343D7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343D80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343D84: 48B159F5  bl 0x82e59778
	ctx.lr = 0x82343D88;
	sub_82E59778(ctx, base);
	// 82343D88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82343D8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343D90: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82343D94: 4BFDCDFD  bl 0x82320b90
	ctx.lr = 0x82343D98;
	sub_82320B90(ctx, base);
	// 82343D98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82343D9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343DA0: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82343DA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82343DA8: 4E800421  bctrl
	ctx.lr = 0x82343DAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82343DAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82343DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343DB4: 4182000C  beq 0x82343dc0
	if ctx.cr[0].eq {
	pc = 0x82343DC0; continue 'dispatch;
	}
	// 82343DB8: 480009A1  bl 0x82344758
	ctx.lr = 0x82343DBC;
	sub_82344758(ctx, base);
	// 82343DBC: 48000054  b 0x82343e10
	pc = 0x82343E10; continue 'dispatch;
	// 82343DC0: 48B159A9  bl 0x82e59768
	ctx.lr = 0x82343DC4;
	sub_82E59768(ctx, base);
	// 82343DC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82343DC8: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82343DCC: 48B190AD  bl 0x82e5ce78
	ctx.lr = 0x82343DD0;
	sub_82E5CE78(ctx, base);
	// 82343DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343DD4: 48000985  bl 0x82344758
	ctx.lr = 0x82343DD8;
	sub_82344758(ctx, base);
	// 82343DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343DDC: 4BFCEE2D  bl 0x82312c08
	ctx.lr = 0x82343DE0;
	sub_82312C08(ctx, base);
	// 82343DE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82343DE4: 4182002C  beq 0x82343e10
	if ctx.cr[0].eq {
	pc = 0x82343E10; continue 'dispatch;
	}
	// 82343DE8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82343DEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82343DF0: 808BB4EC  lwz r4, -0x4b14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19220 as u32) ) } as u64;
	// 82343DF4: 48AAFC15  bl 0x82df3a08
	ctx.lr = 0x82343DF8;
	sub_82DF3A08(ctx, base);
	// 82343DF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82343DFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82343E00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343E04: 4BFC1735  bl 0x82305538
	ctx.lr = 0x82343E08;
	sub_82305538(ctx, base);
	// 82343E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82343E0C: 48AAF61D  bl 0x82df3428
	ctx.lr = 0x82343E10;
	sub_82DF3428(ctx, base);
	// 82343E10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82343E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82343E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82343E1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82343E20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82343E24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82343E28 size=196
    let mut pc: u32 = 0x82343E28;
    'dispatch: loop {
        match pc {
            0x82343E28 => {
    //   block [0x82343E28..0x82343EEC)
	// 82343E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82343E30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82343E34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82343E38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343E3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343E40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82343E44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82343E48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82343E4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343E50: 4BF7CAE9  bl 0x822c0938
	ctx.lr = 0x82343E54;
	sub_822C0938(ctx, base);
	// 82343E54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82343E58: 41820028  beq 0x82343e80
	if ctx.cr[0].eq {
	pc = 0x82343E80; continue 'dispatch;
	}
	// 82343E5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343E60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82343E64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82343E68: 392B23BC  addi r9, r11, 0x23bc
	ctx.r[9].s64 = ctx.r[11].s64 + 9148;
	// 82343E6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82343E70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82343E74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82343E78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82343E7C: 48000008  b 0x82343e84
	pc = 0x82343E84; continue 'dispatch;
	// 82343E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82343E84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82343E8C: 409A0044  bne cr6, 0x82343ed0
	if !ctx.cr[6].eq {
	pc = 0x82343ED0; continue 'dispatch;
	}
	// 82343E90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82343E94: 419A001C  beq cr6, 0x82343eb0
	if ctx.cr[6].eq {
	pc = 0x82343EB0; continue 'dispatch;
	}
	// 82343E98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82343E9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82343EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343EA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82343EA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82343EAC: 4E800421  bctrl
	ctx.lr = 0x82343EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82343EB0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82343EB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82343EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82343EBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82343EC0: 816BA26C  lwz r11, -0x5d94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23956 as u32) ) } as u64;
	// 82343EC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82343EC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82343ECC: 4BF7C135  bl 0x822c0000
	ctx.lr = 0x82343ED0;
	sub_822C0000(ctx, base);
	// 82343ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343ED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82343ED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82343EDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82343EE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82343EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82343EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82343EF0 size=196
    let mut pc: u32 = 0x82343EF0;
    'dispatch: loop {
        match pc {
            0x82343EF0 => {
    //   block [0x82343EF0..0x82343FB4)
	// 82343EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82343EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82343EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82343F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343F04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343F08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82343F0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82343F10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82343F14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343F18: 4BF7CA21  bl 0x822c0938
	ctx.lr = 0x82343F1C;
	sub_822C0938(ctx, base);
	// 82343F1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82343F20: 41820028  beq 0x82343f48
	if ctx.cr[0].eq {
	pc = 0x82343F48; continue 'dispatch;
	}
	// 82343F24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343F28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82343F2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82343F30: 392B23D0  addi r9, r11, 0x23d0
	ctx.r[9].s64 = ctx.r[11].s64 + 9168;
	// 82343F34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82343F38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82343F3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82343F40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82343F44: 48000008  b 0x82343f4c
	pc = 0x82343F4C; continue 'dispatch;
	// 82343F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82343F4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82343F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82343F54: 409A0044  bne cr6, 0x82343f98
	if !ctx.cr[6].eq {
	pc = 0x82343F98; continue 'dispatch;
	}
	// 82343F58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82343F5C: 419A001C  beq cr6, 0x82343f78
	if ctx.cr[6].eq {
	pc = 0x82343F78; continue 'dispatch;
	}
	// 82343F60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82343F64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82343F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343F6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82343F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82343F74: 4E800421  bctrl
	ctx.lr = 0x82343F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82343F78: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82343F7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82343F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82343F84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82343F88: 816BA26C  lwz r11, -0x5d94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23956 as u32) ) } as u64;
	// 82343F8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82343F90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82343F94: 4BF7C06D  bl 0x822c0000
	ctx.lr = 0x82343F98;
	sub_822C0000(ctx, base);
	// 82343F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82343F9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82343FA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82343FA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82343FA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82343FAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82343FB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82343FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82343FB8 size=280
    let mut pc: u32 = 0x82343FB8;
    'dispatch: loop {
        match pc {
            0x82343FB8 => {
    //   block [0x82343FB8..0x823440D0)
	// 82343FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82343FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82343FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82343FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82343FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82343FCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82343FD0: 486CC8A1  bl 0x82a10870
	ctx.lr = 0x82343FD4;
	sub_82A10870(ctx, base);
	// 82343FD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82343FD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82343FDC: 388B2430  addi r4, r11, 0x2430
	ctx.r[4].s64 = ctx.r[11].s64 + 9264;
	// 82343FE0: 38A0004D  li r5, 0x4d
	ctx.r[5].s64 = 77;
	// 82343FE4: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82343FE8: 48AAE401  bl 0x82df23e8
	ctx.lr = 0x82343FEC;
	sub_82DF23E8(ctx, base);
	// 82343FEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82343FF0: 4182001C  beq 0x8234400c
	if ctx.cr[0].eq {
	pc = 0x8234400C; continue 'dispatch;
	}
	// 82343FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82343FF8: 48B18931  bl 0x82e5c928
	ctx.lr = 0x82343FFC;
	sub_82E5C928(ctx, base);
	// 82343FFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344000: 396B23E4  addi r11, r11, 0x23e4
	ctx.r[11].s64 = ctx.r[11].s64 + 9188;
	// 82344004: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344008: 48000008  b 0x82344010
	pc = 0x82344010; continue 'dispatch;
	// 8234400C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82344010: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82344014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82344018: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234401C: 4BFFFE0D  bl 0x82343e28
	ctx.lr = 0x82344020;
	sub_82343E28(ctx, base);
	// 82344020: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82344024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82344028: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234402C: 4BF7BFD5  bl 0x822c0000
	ctx.lr = 0x82344030;
	sub_822C0000(ctx, base);
	// 82344030: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82344034: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82344038: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234403C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82344040: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82344044: 419A0024  beq cr6, 0x82344068
	if ctx.cr[6].eq {
	pc = 0x82344068; continue 'dispatch;
	}
	// 82344048: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8234404C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82344050: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82344054: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82344058: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234405C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82344060: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82344064: 4082FFE8  bne 0x8234404c
	if !ctx.cr[0].eq {
	pc = 0x8234404C; continue 'dispatch;
	}
	// 82344068: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234406C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82344070: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82344074: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82344078: 389E0080  addi r4, r30, 0x80
	ctx.r[4].s64 = ctx.r[30].s64 + 128;
	// 8234407C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82344080: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82344084: 48B1A625  bl 0x82e5e6a8
	ctx.lr = 0x82344088;
	sub_82E5E6A8(ctx, base);
	// 82344088: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8234408C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82344090: 419A0008  beq cr6, 0x82344098
	if ctx.cr[6].eq {
	pc = 0x82344098; continue 'dispatch;
	}
	// 82344094: 4BF7C7FD  bl 0x822c0890
	ctx.lr = 0x82344098;
	sub_822C0890(ctx, base);
	// 82344098: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8234409C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823440A0: 419A0008  beq cr6, 0x823440a8
	if ctx.cr[6].eq {
	pc = 0x823440A8; continue 'dispatch;
	}
	// 823440A4: 4BF7C7ED  bl 0x822c0890
	ctx.lr = 0x823440A8;
	sub_822C0890(ctx, base);
	// 823440A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823440AC: 419A000C  beq cr6, 0x823440b8
	if ctx.cr[6].eq {
	pc = 0x823440B8; continue 'dispatch;
	}
	// 823440B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823440B4: 4BF7C7DD  bl 0x822c0890
	ctx.lr = 0x823440B8;
	sub_822C0890(ctx, base);
	// 823440B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823440BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823440C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823440C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823440C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823440CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823440D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823440D0 size=732
    let mut pc: u32 = 0x823440D0;
    'dispatch: loop {
        match pc {
            0x823440D0 => {
    //   block [0x823440D0..0x823443AC)
	// 823440D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823440D4: 48E64095  bl 0x831a8168
	ctx.lr = 0x823440D8;
	sub_831A8130(ctx, base);
	// 823440D8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 823440DC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 823440E0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 823440E4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823440E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823440EC: 48E10515  bl 0x83154600
	ctx.lr = 0x823440F0;
	sub_83154600(ctx, base);
	// 823440F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823440F4: 486CC77D  bl 0x82a10870
	ctx.lr = 0x823440F8;
	sub_82A10870(ctx, base);
	// 823440F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823440FC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82344100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82344104: 4810F545  bl 0x82453648
	ctx.lr = 0x82344108;
	sub_82453648(ctx, base);
	// 82344108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234410C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344110: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82344114: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82344118: 4E800421  bctrl
	ctx.lr = 0x8234411C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234411C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82344120: 40820068  bne 0x82344188
	if !ctx.cr[0].eq {
	pc = 0x82344188; continue 'dispatch;
	}
	// 82344124: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823443B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823443B0 size=356
    let mut pc: u32 = 0x823443B0;
    'dispatch: loop {
        match pc {
            0x823443B0 => {
    //   block [0x823443B0..0x82344514)
	// 823443B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823443B4: 48E63DB9  bl 0x831a816c
	ctx.lr = 0x823443B8;
	sub_831A8130(ctx, base);
	// 823443B8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 823443BC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823443C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823443C4: 48E1023D  bl 0x83154600
	ctx.lr = 0x823443C8;
	sub_83154600(ctx, base);
	// 823443C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823443CC: 486CC4A5  bl 0x82a10870
	ctx.lr = 0x823443D0;
	sub_82A10870(ctx, base);
	// 823443D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823443D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823443D8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 823443DC: 4810F26D  bl 0x82453648
	ctx.lr = 0x823443E0;
	sub_82453648(ctx, base);
	// 823443E0: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 823443E4: 807D01FC  lwz r3, 0x1fc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 823443E8: 48116A01  bl 0x8245ade8
	ctx.lr = 0x823443EC;
	sub_8245ADE8(ctx, base);
	// 823443EC: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 823443F0: 807D01FC  lwz r3, 0x1fc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 823443F4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823443F8: 481169F1  bl 0x8245ade8
	ctx.lr = 0x823443FC;
	sub_8245ADE8(ctx, base);
	// 823443FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82344400: EC2107F2  fmuls f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 82344404: 391E0060  addi r8, r30, 0x60
	ctx.r[8].s64 = ctx.r[30].s64 + 96;
	// 82344408: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8234440C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82344410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344414: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82344418: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8234441C: 4800342D  bl 0x82347848
	ctx.lr = 0x82344420;
	sub_82347848(ctx, base);
	// 82344420: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82344424: 408200E4  bne 0x82344508
	if !ctx.cr[0].eq {
	pc = 0x82344508; continue 'dispatch;
	}
	// 82344428: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234442C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82344430: 388B2430  addi r4, r11, 0x2430
	ctx.r[4].s64 = ctx.r[11].s64 + 9264;
	// 82344434: 38A000CE  li r5, 0xce
	ctx.r[5].s64 = 206;
	// 82344438: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8234443C: 48AADFAD  bl 0x82df23e8
	ctx.lr = 0x82344440;
	sub_82DF23E8(ctx, base);
	// 82344440: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82344444: 4182001C  beq 0x82344460
	if ctx.cr[0].eq {
	pc = 0x82344460; continue 'dispatch;
	}
	// 82344448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234444C: 48B184DD  bl 0x82e5c928
	ctx.lr = 0x82344450;
	sub_82E5C928(ctx, base);
	// 82344450: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344454: 396B23E4  addi r11, r11, 0x23e4
	ctx.r[11].s64 = ctx.r[11].s64 + 9188;
	// 82344458: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234445C: 48000008  b 0x82344464
	pc = 0x82344464; continue 'dispatch;
	// 82344460: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82344464: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82344468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234446C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82344470: 4BFFF9B9  bl 0x82343e28
	ctx.lr = 0x82344474;
	sub_82343E28(ctx, base);
	// 82344474: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82344478: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234447C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82344480: 4BF7BB81  bl 0x822c0000
	ctx.lr = 0x82344484;
	sub_822C0000(ctx, base);
	// 82344484: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82344488: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8234448C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82344490: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82344494: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82344498: 419A0024  beq cr6, 0x823444bc
	if ctx.cr[6].eq {
	pc = 0x823444BC; continue 'dispatch;
	}
	// 8234449C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 823444A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823444A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823444A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823444AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823444B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823444B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823444B8: 4082FFE8  bne 0x823444a0
	if !ctx.cr[0].eq {
	pc = 0x823444A0; continue 'dispatch;
	}
	// 823444BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823444C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823444C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823444C8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823444CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823444D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823444D4: 48B1A3ED  bl 0x82e5e8c0
	ctx.lr = 0x823444D8;
	sub_82E5E8C0(ctx, base);
	// 823444D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823444DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823444E0: 419A0008  beq cr6, 0x823444e8
	if ctx.cr[6].eq {
	pc = 0x823444E8; continue 'dispatch;
	}
	// 823444E4: 4BF7C3AD  bl 0x822c0890
	ctx.lr = 0x823444E8;
	sub_822C0890(ctx, base);
	// 823444E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823444EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823444F0: 419A0008  beq cr6, 0x823444f8
	if ctx.cr[6].eq {
	pc = 0x823444F8; continue 'dispatch;
	}
	// 823444F4: 4BF7C39D  bl 0x822c0890
	ctx.lr = 0x823444F8;
	sub_822C0890(ctx, base);
	// 823444F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823444FC: 419A000C  beq cr6, 0x82344508
	if ctx.cr[6].eq {
	pc = 0x82344508; continue 'dispatch;
	}
	// 82344500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344504: 4BF7C38D  bl 0x822c0890
	ctx.lr = 0x82344508;
	sub_822C0890(ctx, base);
	// 82344508: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8234450C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82344510: 48E63CAC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82344518 size=456
    let mut pc: u32 = 0x82344518;
    'dispatch: loop {
        match pc {
            0x82344518 => {
    //   block [0x82344518..0x823446E0)
	// 82344518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234451C: 48E63C51  bl 0x831a816c
	ctx.lr = 0x82344520;
	sub_831A8130(ctx, base);
	// 82344520: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82344524: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82344528: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234452C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82344534: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82344538: 388BEB84  addi r4, r11, -0x147c
	ctx.r[4].s64 = ctx.r[11].s64 + -5244;
	// 8234453C: 48AAF4CD  bl 0x82df3a08
	ctx.lr = 0x82344540;
	sub_82DF3A08(ctx, base);
	// 82344540: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344544: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82344548: 388BEB78  addi r4, r11, -0x1488
	ctx.r[4].s64 = ctx.r[11].s64 + -5256;
	// 8234454C: 48AAF4BD  bl 0x82df3a08
	ctx.lr = 0x82344550;
	sub_82DF3A08(ctx, base);
	// 82344550: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82344554: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82344558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234455C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82344560: 48284639  bl 0x825c8b98
	ctx.lr = 0x82344564;
	sub_825C8B98(ctx, base);
	// 82344564: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82344568: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234456C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82344570: 419A000C  beq cr6, 0x8234457c
	if ctx.cr[6].eq {
	pc = 0x8234457C; continue 'dispatch;
	}
	// 82344574: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82344578: 4BF7C319  bl 0x822c0890
	ctx.lr = 0x8234457C;
	sub_822C0890(ctx, base);
	// 8234457C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82344580: 48AAEEA9  bl 0x82df3428
	ctx.lr = 0x82344584;
	sub_82DF3428(ctx, base);
	// 82344584: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82344588: 48AAEEA1  bl 0x82df3428
	ctx.lr = 0x8234458C;
	sub_82DF3428(ctx, base);
	// 8234458C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344590: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82344594: 388B0A88  addi r4, r11, 0xa88
	ctx.r[4].s64 = ctx.r[11].s64 + 2696;
	// 82344598: 48AAF471  bl 0x82df3a08
	ctx.lr = 0x8234459C;
	sub_82DF3A08(ctx, base);
	// 8234459C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823445A0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 823445A4: 388B0A7C  addi r4, r11, 0xa7c
	ctx.r[4].s64 = ctx.r[11].s64 + 2684;
	// 823445A8: 48AAF461  bl 0x82df3a08
	ctx.lr = 0x823445AC;
	sub_82DF3A08(ctx, base);
	// 823445AC: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 823445B0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 823445B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823445B8: 48285F49  bl 0x825ca500
	ctx.lr = 0x823445BC;
	sub_825CA500(ctx, base);
	// 823445BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823445C0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 823445C4: 48AAEE65  bl 0x82df3428
	ctx.lr = 0x823445C8;
	sub_82DF3428(ctx, base);
	// 823445C8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 823445CC: 48AAEE5D  bl 0x82df3428
	ctx.lr = 0x823445D0;
	sub_82DF3428(ctx, base);
	// 823445D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823445D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823445D8: 388B24E0  addi r4, r11, 0x24e0
	ctx.r[4].s64 = ctx.r[11].s64 + 9440;
	// 823445DC: 48AAF42D  bl 0x82df3a08
	ctx.lr = 0x823445E0;
	sub_82DF3A08(ctx, base);
	// 823445E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823445E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823445E8: 388B24D0  addi r4, r11, 0x24d0
	ctx.r[4].s64 = ctx.r[11].s64 + 9424;
	// 823445EC: 48AAF41D  bl 0x82df3a08
	ctx.lr = 0x823445F0;
	sub_82DF3A08(ctx, base);
	// 823445F0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 823445F4: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 823445F8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 823445FC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82344600: 3BEBA264  addi r31, r11, -0x5d9c
	ctx.r[31].s64 = ctx.r[11].s64 + -23964;
	// 82344604: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82344608: C3E96218  lfs f31, 0x6218(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234460C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82344610: C3C808A4  lfs f30, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82344614: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82344618: C06A964C  lfs f3, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8234461C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82344620: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82344624: 48269495  bl 0x825adab8
	ctx.lr = 0x82344628;
	sub_825ADAB8(ctx, base);
	// 82344628: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234462C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82344630: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82344634: 4825D01D  bl 0x825a1650
	ctx.lr = 0x82344638;
	sub_825A1650(ctx, base);
	// 82344638: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8234463C: 48AAEDED  bl 0x82df3428
	ctx.lr = 0x82344640;
	sub_82DF3428(ctx, base);
	// 82344640: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82344644: 4BF84675  bl 0x822c8cb8
	ctx.lr = 0x82344648;
	sub_822C8CB8(ctx, base);
	// 82344648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234464C: 48AAEDDD  bl 0x82df3428
	ctx.lr = 0x82344650;
	sub_82DF3428(ctx, base);
	// 82344650: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82344654: 48AAEDD5  bl 0x82df3428
	ctx.lr = 0x82344658;
	sub_82DF3428(ctx, base);
	// 82344658: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234465C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82344660: 388B24B4  addi r4, r11, 0x24b4
	ctx.r[4].s64 = ctx.r[11].s64 + 9396;
	// 82344664: 48AAF3A5  bl 0x82df3a08
	ctx.lr = 0x82344668;
	sub_82DF3A08(ctx, base);
	// 82344668: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234466C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82344670: 388B2494  addi r4, r11, 0x2494
	ctx.r[4].s64 = ctx.r[11].s64 + 9364;
	// 82344674: 48AAF395  bl 0x82df3a08
	ctx.lr = 0x82344678;
	sub_82DF3A08(ctx, base);
	// 82344678: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234467C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82344680: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82344684: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82344688: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8234468C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82344690: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82344694: 48269425  bl 0x825adab8
	ctx.lr = 0x82344698;
	sub_825ADAB8(ctx, base);
	// 82344698: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234469C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 823446A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823446A4: 4825CFAD  bl 0x825a1650
	ctx.lr = 0x823446A8;
	sub_825A1650(ctx, base);
	// 823446A8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 823446AC: 48AAED7D  bl 0x82df3428
	ctx.lr = 0x823446B0;
	sub_82DF3428(ctx, base);
	// 823446B0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 823446B4: 4BF84605  bl 0x822c8cb8
	ctx.lr = 0x823446B8;
	sub_822C8CB8(ctx, base);
	// 823446B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823446BC: 48AAED6D  bl 0x82df3428
	ctx.lr = 0x823446C0;
	sub_82DF3428(ctx, base);
	// 823446C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823446C4: 48AAED65  bl 0x82df3428
	ctx.lr = 0x823446C8;
	sub_82DF3428(ctx, base);
	// 823446C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823446CC: 48285605  bl 0x825c9cd0
	ctx.lr = 0x823446D0;
	sub_825C9CD0(ctx, base);
	// 823446D0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 823446D4: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 823446D8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823446DC: 48E63AE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823446E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823446E0 size=116
    let mut pc: u32 = 0x823446E0;
    'dispatch: loop {
        match pc {
            0x823446E0 => {
    //   block [0x823446E0..0x82344754)
	// 823446E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823446E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823446E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823446EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823446F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823446F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823446F8: 480000F9  bl 0x823447f0
	ctx.lr = 0x823446FC;
	sub_823447F0(ctx, base);
	// 823446FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344700: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 82344704: 396B24F8  addi r11, r11, 0x24f8
	ctx.r[11].s64 = ctx.r[11].s64 + 9464;
	// 82344708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234470C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344710: 48B191C1  bl 0x82e5d8d0
	ctx.lr = 0x82344714;
	sub_82E5D8D0(ctx, base);
	// 82344714: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234471C: 396B23AC  addi r11, r11, 0x23ac
	ctx.r[11].s64 = ctx.r[11].s64 + 9132;
	// 82344720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82344724: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82344728: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8234472C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82344730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82344734: 4E800421  bctrl
	ctx.lr = 0x82344738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82344738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234473C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82344740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82344744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82344748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234474C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82344750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82344758 size=148
    let mut pc: u32 = 0x82344758;
    'dispatch: loop {
        match pc {
            0x82344758 => {
    //   block [0x82344758..0x823447EC)
	// 82344758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234475C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82344760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82344764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82344768: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234476C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82344770: 486CC101  bl 0x82a10870
	ctx.lr = 0x82344774;
	sub_82A10870(ctx, base);
	// 82344774: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82344778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234477C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82344780: 4BFD5369  bl 0x82319ae8
	ctx.lr = 0x82344784;
	sub_82319AE8(ctx, base);
	// 82344784: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82344788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234478C: 4800341D  bl 0x82347ba8
	ctx.lr = 0x82344790;
	sub_82347BA8(ctx, base);
	// 82344790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82344794: 4BFE85E5  bl 0x8232cd78
	ctx.lr = 0x82344798;
	sub_8232CD78(ctx, base);
	// 82344798: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234479C: 4BFD4CF5  bl 0x82319490
	ctx.lr = 0x823447A0;
	sub_82319490(ctx, base);
	// 823447A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823447A4: 4BFD24BD  bl 0x82316c60
	ctx.lr = 0x823447A8;
	sub_82316C60(ctx, base);
	// 823447A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823447AC: 4BFD2EED  bl 0x82317698
	ctx.lr = 0x823447B0;
	sub_82317698(ctx, base);
	// 823447B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823447B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823447B8: 4BFCF529  bl 0x82313ce0
	ctx.lr = 0x823447BC;
	sub_82313CE0(ctx, base);
	// 823447BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823447C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823447C4: 48B14FB5  bl 0x82e59778
	ctx.lr = 0x823447C8;
	sub_82E59778(ctx, base);
	// 823447C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823447CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823447D0: 48001A51  bl 0x82346220
	ctx.lr = 0x823447D4;
	sub_82346220(ctx, base);
	// 823447D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823447D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823447DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823447E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823447E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823447E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823447F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823447F0 size=60
    let mut pc: u32 = 0x823447F0;
    'dispatch: loop {
        match pc {
            0x823447F0 => {
    //   block [0x823447F0..0x8234482C)
	// 823447F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823447F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823447F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823447FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82344800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82344804: 480019B5  bl 0x823461b8
	ctx.lr = 0x82344808;
	sub_823461B8(ctx, base);
	// 82344808: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234480C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344810: 396B2524  addi r11, r11, 0x2524
	ctx.r[11].s64 = ctx.r[11].s64 + 9508;
	// 82344814: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344818: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234481C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82344820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82344824: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82344828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82344830 size=16
    let mut pc: u32 = 0x82344830;
    'dispatch: loop {
        match pc {
            0x82344830 => {
    //   block [0x82344830..0x82344840)
	// 82344830: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82344834: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82344838: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234483C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82344840 size=104
    let mut pc: u32 = 0x82344840;
    'dispatch: loop {
        match pc {
            0x82344840 => {
    //   block [0x82344840..0x823448A8)
	// 82344840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82344844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82344848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234484C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82344850: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82344854: 486CC01D  bl 0x82a10870
	ctx.lr = 0x82344858;
	sub_82A10870(ctx, base);
	// 82344858: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8234485C: 4BFCF485  bl 0x82313ce0
	ctx.lr = 0x82344860;
	sub_82313CE0(ctx, base);
	// 82344860: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82344864: 41820014  beq 0x82344878
	if ctx.cr[0].eq {
	pc = 0x82344878; continue 'dispatch;
	}
	// 82344868: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234486C: 396BA4EC  addi r11, r11, -0x5b14
	ctx.r[11].s64 = ctx.r[11].s64 + -23316;
	// 82344870: C02B0008  lfs f1, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82344874: 48000020  b 0x82344894
	pc = 0x82344894; continue 'dispatch;
	// 82344878: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234487C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82344880: 41820010  beq 0x82344890
	if ctx.cr[0].eq {
	pc = 0x82344890; continue 'dispatch;
	}
	// 82344884: 396BA4EC  addi r11, r11, -0x5b14
	ctx.r[11].s64 = ctx.r[11].s64 + -23316;
	// 82344888: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234488C: 48000008  b 0x82344894
	pc = 0x82344894; continue 'dispatch;
	// 82344890: C02BA4EC  lfs f1, -0x5b14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23316 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82344894: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82344898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234489C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823448A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823448A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823448A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823448A8 size=196
    let mut pc: u32 = 0x823448A8;
    'dispatch: loop {
        match pc {
            0x823448A8 => {
    //   block [0x823448A8..0x8234496C)
	// 823448A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823448AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823448B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823448B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823448B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823448BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823448C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823448C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 823448C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823448CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823448D0: 4BF7C069  bl 0x822c0938
	ctx.lr = 0x823448D4;
	sub_822C0938(ctx, base);
	// 823448D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823448D8: 41820028  beq 0x82344900
	if ctx.cr[0].eq {
	pc = 0x82344900; continue 'dispatch;
	}
	// 823448DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823448E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 823448E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823448E8: 392B2560  addi r9, r11, 0x2560
	ctx.r[9].s64 = ctx.r[11].s64 + 9568;
	// 823448EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823448F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823448F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823448F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823448FC: 48000008  b 0x82344904
	pc = 0x82344904; continue 'dispatch;
	// 82344900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82344904: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234490C: 409A0044  bne cr6, 0x82344950
	if !ctx.cr[6].eq {
	pc = 0x82344950; continue 'dispatch;
	}
	// 82344910: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82344914: 419A001C  beq cr6, 0x82344930
	if ctx.cr[6].eq {
	pc = 0x82344930; continue 'dispatch;
	}
	// 82344918: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234491C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82344920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344924: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82344928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234492C: 4E800421  bctrl
	ctx.lr = 0x82344930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82344930: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82344934: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82344938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234493C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82344940: 816BA508  lwz r11, -0x5af8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23288 as u32) ) } as u64;
	// 82344944: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82344948: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234494C: 4BF7B6B5  bl 0x822c0000
	ctx.lr = 0x82344950;
	sub_822C0000(ctx, base);
	// 82344950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82344954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82344958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234495C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82344960: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82344964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82344968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82344970 size=196
    let mut pc: u32 = 0x82344970;
    'dispatch: loop {
        match pc {
            0x82344970 => {
    //   block [0x82344970..0x82344A34)
	// 82344970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82344974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82344978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234497C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82344980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82344984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82344988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234498C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82344990: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82344994: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344998: 4BF7BFA1  bl 0x822c0938
	ctx.lr = 0x8234499C;
	sub_822C0938(ctx, base);
	// 8234499C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823449A0: 41820028  beq 0x823449c8
	if ctx.cr[0].eq {
	pc = 0x823449C8; continue 'dispatch;
	}
	// 823449A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823449A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 823449AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823449B0: 392B2574  addi r9, r11, 0x2574
	ctx.r[9].s64 = ctx.r[11].s64 + 9588;
	// 823449B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823449B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823449BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823449C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823449C4: 48000008  b 0x823449cc
	pc = 0x823449CC; continue 'dispatch;
	// 823449C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823449CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823449D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823449D4: 409A0044  bne cr6, 0x82344a18
	if !ctx.cr[6].eq {
	pc = 0x82344A18; continue 'dispatch;
	}
	// 823449D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823449DC: 419A001C  beq cr6, 0x823449f8
	if ctx.cr[6].eq {
	pc = 0x823449F8; continue 'dispatch;
	}
	// 823449E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823449E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823449E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823449EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823449F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823449F4: 4E800421  bctrl
	ctx.lr = 0x823449F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823449F8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 823449FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82344A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82344A04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82344A08: 816BA508  lwz r11, -0x5af8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23288 as u32) ) } as u64;
	// 82344A0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82344A10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82344A14: 4BF7B5ED  bl 0x822c0000
	ctx.lr = 0x82344A18;
	sub_822C0000(ctx, base);
	// 82344A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82344A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82344A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82344A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82344A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82344A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82344A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82344A38 size=196
    let mut pc: u32 = 0x82344A38;
    'dispatch: loop {
        match pc {
            0x82344A38 => {
    //   block [0x82344A38..0x82344AFC)
	// 82344A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82344A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82344A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82344A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82344A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82344A4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82344A50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82344A54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82344A58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82344A5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344A60: 4BF7BED9  bl 0x822c0938
	ctx.lr = 0x82344A64;
	sub_822C0938(ctx, base);
	// 82344A64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82344A68: 41820028  beq 0x82344a90
	if ctx.cr[0].eq {
	pc = 0x82344A90; continue 'dispatch;
	}
	// 82344A6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344A70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82344A74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82344A78: 392B2588  addi r9, r11, 0x2588
	ctx.r[9].s64 = ctx.r[11].s64 + 9608;
	// 82344A7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82344A80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82344A84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82344A88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82344A8C: 48000008  b 0x82344a94
	pc = 0x82344A94; continue 'dispatch;
	// 82344A90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82344A94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344A98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82344A9C: 409A0044  bne cr6, 0x82344ae0
	if !ctx.cr[6].eq {
	pc = 0x82344AE0; continue 'dispatch;
	}
	// 82344AA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82344AA4: 419A001C  beq cr6, 0x82344ac0
	if ctx.cr[6].eq {
	pc = 0x82344AC0; continue 'dispatch;
	}
	// 82344AA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82344AAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82344AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344AB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82344AB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82344ABC: 4E800421  bctrl
	ctx.lr = 0x82344AC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82344AC0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82344AC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82344AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82344ACC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82344AD0: 816BA508  lwz r11, -0x5af8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23288 as u32) ) } as u64;
	// 82344AD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82344AD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82344ADC: 4BF7B525  bl 0x822c0000
	ctx.lr = 0x82344AE0;
	sub_822C0000(ctx, base);
	// 82344AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82344AE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82344AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82344AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82344AF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82344AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82344AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82344B00 size=420
    let mut pc: u32 = 0x82344B00;
    'dispatch: loop {
        match pc {
            0x82344B00 => {
    //   block [0x82344B00..0x82344CA4)
	// 82344B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82344B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82344B08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82344B0C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82344B10: 48E63F69  bl 0x831a8a78
	ctx.lr = 0x82344B14;
	sub_831A8A40(ctx, base);
	// 82344B14: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82344B18: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82344B1C: 486CBD55  bl 0x82a10870
	ctx.lr = 0x82344B20;
	sub_82A10870(ctx, base);
	// 82344B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82344B24: 4BFD382D  bl 0x82318350
	ctx.lr = 0x82344B28;
	sub_82318350(ctx, base);
	// 82344B28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82344B2C: 41820034  beq 0x82344b60
	if ctx.cr[0].eq {
	pc = 0x82344B60; continue 'dispatch;
	}
	// 82344B30: 38800096  li r4, 0x96
	ctx.r[4].s64 = 150;
	// 82344B34: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344B38: 481162B1  bl 0x8245ade8
	ctx.lr = 0x82344B3C;
	sub_8245ADE8(ctx, base);
	// 82344B3C: 38800095  li r4, 0x95
	ctx.r[4].s64 = 149;
	// 82344B40: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344B44: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82344B48: 481162A1  bl 0x8245ade8
	ctx.lr = 0x82344B4C;
	sub_8245ADE8(ctx, base);
	// 82344B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344B50: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82344B54: 4BFCFE85  bl 0x823149d8
	ctx.lr = 0x82344B58;
	sub_823149D8(ctx, base);
	// 82344B58: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82344B5C: 4800011C  b 0x82344c78
	pc = 0x82344C78; continue 'dispatch;
	// 82344B60: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 82344B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344B68: 4BFCF179  bl 0x82313ce0
	ctx.lr = 0x82344B6C;
	sub_82313CE0(ctx, base);
	// 82344B6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82344B70: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344B74: 41820050  beq 0x82344bc4
	if ctx.cr[0].eq {
	pc = 0x82344BC4; continue 'dispatch;
	}
	// 82344B78: 388000A2  li r4, 0xa2
	ctx.r[4].s64 = 162;
	// 82344B7C: 4811626D  bl 0x8245ade8
	ctx.lr = 0x82344B80;
	sub_8245ADE8(ctx, base);
	// 82344B80: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82344B84: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 82344B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344B8C: 4BFCF155  bl 0x82313ce0
	ctx.lr = 0x82344B90;
	sub_82313CE0(ctx, base);
	// 82344B90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82344B94: 418200E4  beq 0x82344c78
	if ctx.cr[0].eq {
	pc = 0x82344C78; continue 'dispatch;
	}
	// 82344B98: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 82344B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344BA0: 4BFCF141  bl 0x82313ce0
	ctx.lr = 0x82344BA4;
	sub_82313CE0(ctx, base);
	// 82344BA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82344BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344BAC: 418200B8  beq 0x82344c64
	if ctx.cr[0].eq {
	pc = 0x82344C64; continue 'dispatch;
	}
	// 82344BB0: 4BFCE4F1  bl 0x823130a0
	ctx.lr = 0x82344BB4;
	sub_823130A0(ctx, base);
	// 82344BB4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82344BB8: 396BA4FC  addi r11, r11, -0x5b04
	ctx.r[11].s64 = ctx.r[11].s64 + -23300;
	// 82344BBC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82344BC0: 480000B0  b 0x82344c70
	pc = 0x82344C70; continue 'dispatch;
	// 82344BC4: 3880009E  li r4, 0x9e
	ctx.r[4].s64 = 158;
	// 82344BC8: 48116221  bl 0x8245ade8
	ctx.lr = 0x82344BCC;
	sub_8245ADE8(ctx, base);
	// 82344BCC: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344BD0: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82344BD4: 4199000C  bgt cr6, 0x82344be0
	if ctx.cr[6].gt {
	pc = 0x82344BE0; continue 'dispatch;
	}
	// 82344BD8: 3880009D  li r4, 0x9d
	ctx.r[4].s64 = 157;
	// 82344BDC: 4BFFFFA0  b 0x82344b7c
	pc = 0x82344B7C; continue 'dispatch;
	// 82344BE0: 388000A0  li r4, 0xa0
	ctx.r[4].s64 = 160;
	// 82344BE4: 48116205  bl 0x8245ade8
	ctx.lr = 0x82344BE8;
	sub_8245ADE8(ctx, base);
	// 82344BE8: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344BEC: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82344BF0: 3880009F  li r4, 0x9f
	ctx.r[4].s64 = 159;
	// 82344BF4: 4098FF88  bge cr6, 0x82344b7c
	if !ctx.cr[6].lt {
	pc = 0x82344B7C; continue 'dispatch;
	}
	// 82344BF8: 481161F1  bl 0x8245ade8
	ctx.lr = 0x82344BFC;
	sub_8245ADE8(ctx, base);
	// 82344BFC: 3880009D  li r4, 0x9d
	ctx.r[4].s64 = 157;
	// 82344C00: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344C04: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82344C08: 481161E1  bl 0x8245ade8
	ctx.lr = 0x82344C0C;
	sub_8245ADE8(ctx, base);
	// 82344C0C: 388000A0  li r4, 0xa0
	ctx.r[4].s64 = 160;
	// 82344C10: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344C14: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82344C18: 481161D1  bl 0x8245ade8
	ctx.lr = 0x82344C1C;
	sub_8245ADE8(ctx, base);
	// 82344C1C: 3880009E  li r4, 0x9e
	ctx.r[4].s64 = 158;
	// 82344C20: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344C24: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82344C28: EFDEE828  fsubs f30, f30, f29
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82344C2C: 481161BD  bl 0x8245ade8
	ctx.lr = 0x82344C30;
	sub_8245ADE8(ctx, base);
	// 82344C30: EC1C0828  fsubs f0, f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[1].f64) as f32) as f64);
	// 82344C34: 3880009E  li r4, 0x9e
	ctx.r[4].s64 = 158;
	// 82344C38: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344C3C: EFDE0024  fdivs f30, f30, f0
	ctx.f[30].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 82344C40: 481161A9  bl 0x8245ade8
	ctx.lr = 0x82344C44;
	sub_8245ADE8(ctx, base);
	// 82344C44: 3880009D  li r4, 0x9d
	ctx.r[4].s64 = 157;
	// 82344C48: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344C4C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82344C50: 48116199  bl 0x8245ade8
	ctx.lr = 0x82344C54;
	sub_8245ADE8(ctx, base);
	// 82344C54: EC1D07B2  fmuls f0, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[30].f64) as f32) as f64);
	// 82344C58: EC1E07F8  fmsubs f0, f30, f31, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82344C5C: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82344C60: 4BFFFF24  b 0x82344b84
	pc = 0x82344B84; continue 'dispatch;
	// 82344C64: 4BFCE43D  bl 0x823130a0
	ctx.lr = 0x82344C68;
	sub_823130A0(ctx, base);
	// 82344C68: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82344C6C: C00BA4FC  lfs f0, -0x5b04(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82344C70: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82344C74: EFE0F87A  fmadds f31, f0, f1, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64);
	// 82344C78: 388000A3  li r4, 0xa3
	ctx.r[4].s64 = 163;
	// 82344C7C: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82344C80: 48116169  bl 0x8245ade8
	ctx.lr = 0x82344C84;
	sub_8245ADE8(ctx, base);
	// 82344C84: EC2107F2  fmuls f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 82344C88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82344C8C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82344C90: 48E63E35  bl 0x831a8ac4
	ctx.lr = 0x82344C94;
	sub_831A8A8C(ctx, base);
	// 82344C94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82344C98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82344C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82344CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82344CA8 size=640
    let mut pc: u32 = 0x82344CA8;
    'dispatch: loop {
        match pc {
            0x82344CA8 => {
    //   block [0x82344CA8..0x82344F28)
	// 82344CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82344CAC: 48E634BD  bl 0x831a8168
	ctx.lr = 0x82344CB0;
	sub_831A8130(ctx, base);
	// 82344CB0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82344CB4: 48E63DC5  bl 0x831a8a78
	ctx.lr = 0x82344CB8;
	sub_831A8A40(ctx, base);
	// 82344CB8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82344CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82344CC0: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82344CC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82344CC8: 486CBBA9  bl 0x82a10870
	ctx.lr = 0x82344CCC;
	sub_82A10870(ctx, base);
	// 82344CCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82344CD0: 4BFD3681  bl 0x82318350
	ctx.lr = 0x82344CD4;
	sub_82318350(ctx, base);
	// 82344CD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82344CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82344CDC: 4810E96D  bl 0x82453648
	ctx.lr = 0x82344CE0;
	sub_82453648(ctx, base);
	// 82344CE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82344CE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82344CE8: 48B38769  bl 0x82e7d450
	ctx.lr = 0x82344CEC;
	sub_82E7D450(ctx, base);
	// 82344CEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82344CF0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82344CF4: 4BFC2F1D  bl 0x82307c10
	ctx.lr = 0x82344CF8;
	sub_82307C10(ctx, base);
	// 82344CF8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82344CFC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82344D00: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82344D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344D08: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82344D0C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82344F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82344F28 size=492
    let mut pc: u32 = 0x82344F28;
    'dispatch: loop {
        match pc {
            0x82344F28 => {
    //   block [0x82344F28..0x82345114)
	// 82344F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82344F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82344F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82344F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82344F38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82344F3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82344F40: 486CB931  bl 0x82a10870
	ctx.lr = 0x82344F44;
	sub_82A10870(ctx, base);
	// 82344F44: 4BFD209D  bl 0x82316fe0
	ctx.lr = 0x82344F48;
	sub_82316FE0(ctx, base);
	// 82344F48: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82344F4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82344F50: C00BA4E4  lfs f0, -0x5b1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82344F54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344F58: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82344F5C: 388B2610  addi r4, r11, 0x2610
	ctx.r[4].s64 = ctx.r[11].s64 + 9744;
	// 82344F60: 419800C4  blt cr6, 0x82345024
	if ctx.cr[6].lt {
	pc = 0x82345024; continue 'dispatch;
	}
	// 82344F64: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 82344F68: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82344F6C: 48AAD47D  bl 0x82df23e8
	ctx.lr = 0x82344F70;
	sub_82DF23E8(ctx, base);
	// 82344F70: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82344F74: 4182001C  beq 0x82344f90
	if ctx.cr[0].eq {
	pc = 0x82344F90; continue 'dispatch;
	}
	// 82344F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82344F7C: 48B179AD  bl 0x82e5c928
	ctx.lr = 0x82344F80;
	sub_82E5C928(ctx, base);
	// 82344F80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82344F84: 396B259C  addi r11, r11, 0x259c
	ctx.r[11].s64 = ctx.r[11].s64 + 9628;
	// 82344F88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82344F8C: 48000008  b 0x82344f94
	pc = 0x82344F94; continue 'dispatch;
	// 82344F90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82344F94: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82344F98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82344F9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82344FA0: 4BFFF909  bl 0x823448a8
	ctx.lr = 0x82344FA4;
	sub_823448A8(ctx, base);
	// 82344FA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82344FA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82344FAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82344FB0: 4BF7B051  bl 0x822c0000
	ctx.lr = 0x82344FB4;
	sub_822C0000(ctx, base);
	// 82344FB4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82344FB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82344FBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82344FC0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82344FC4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82344FC8: 419A0024  beq cr6, 0x82344fec
	if ctx.cr[6].eq {
	pc = 0x82344FEC; continue 'dispatch;
	}
	// 82344FCC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82344FD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82344FD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82344FD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82344FDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82344FE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82344FE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82344FE8: 4082FFE8  bne 0x82344fd0
	if !ctx.cr[0].eq {
	pc = 0x82344FD0; continue 'dispatch;
	}
	// 82344FEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82344FF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82344FF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82344FF8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82344FFC: 389E0080  addi r4, r30, 0x80
	ctx.r[4].s64 = ctx.r[30].s64 + 128;
	// 82345000: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82345004: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82345008: 48B196A1  bl 0x82e5e6a8
	ctx.lr = 0x8234500C;
	sub_82E5E6A8(ctx, base);
	// 8234500C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82345010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82345014: 419A0008  beq cr6, 0x8234501c
	if ctx.cr[6].eq {
	pc = 0x8234501C; continue 'dispatch;
	}
	// 82345018: 4BF7B879  bl 0x822c0890
	ctx.lr = 0x8234501C;
	sub_822C0890(ctx, base);
	// 8234501C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82345020: 480000C0  b 0x823450e0
	pc = 0x823450E0; continue 'dispatch;
	// 82345024: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82345028: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8234502C: 48AAD3BD  bl 0x82df23e8
	ctx.lr = 0x82345030;
	sub_82DF23E8(ctx, base);
	// 82345030: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82345034: 4182001C  beq 0x82345050
	if ctx.cr[0].eq {
	pc = 0x82345050; continue 'dispatch;
	}
	// 82345038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234503C: 48B178ED  bl 0x82e5c928
	ctx.lr = 0x82345040;
	sub_82E5C928(ctx, base);
	// 82345040: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345044: 396B25C4  addi r11, r11, 0x25c4
	ctx.r[11].s64 = ctx.r[11].s64 + 9668;
	// 82345048: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234504C: 48000008  b 0x82345054
	pc = 0x82345054; continue 'dispatch;
	// 82345050: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82345054: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82345058: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234505C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345060: 4BFFF911  bl 0x82344970
	ctx.lr = 0x82345064;
	sub_82344970(ctx, base);
	// 82345064: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82345068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234506C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345070: 4BF7AF91  bl 0x822c0000
	ctx.lr = 0x82345074;
	sub_822C0000(ctx, base);
	// 82345074: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82345078: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8234507C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82345080: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82345084: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82345088: 419A0024  beq cr6, 0x823450ac
	if ctx.cr[6].eq {
	pc = 0x823450AC; continue 'dispatch;
	}
	// 8234508C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82345090: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82345094: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82345098: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234509C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823450A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823450A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823450A8: 4082FFE8  bne 0x82345090
	if !ctx.cr[0].eq {
	pc = 0x82345090; continue 'dispatch;
	}
	// 823450AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823450B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823450B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823450B8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823450BC: 389E0080  addi r4, r30, 0x80
	ctx.r[4].s64 = ctx.r[30].s64 + 128;
	// 823450C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823450C4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823450C8: 48B195E1  bl 0x82e5e6a8
	ctx.lr = 0x823450CC;
	sub_82E5E6A8(ctx, base);
	// 823450CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823450D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823450D4: 419A0008  beq cr6, 0x823450dc
	if ctx.cr[6].eq {
	pc = 0x823450DC; continue 'dispatch;
	}
	// 823450D8: 4BF7B7B9  bl 0x822c0890
	ctx.lr = 0x823450DC;
	sub_822C0890(ctx, base);
	// 823450DC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823450E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823450E4: 419A0008  beq cr6, 0x823450ec
	if ctx.cr[6].eq {
	pc = 0x823450EC; continue 'dispatch;
	}
	// 823450E8: 4BF7B7A9  bl 0x822c0890
	ctx.lr = 0x823450EC;
	sub_822C0890(ctx, base);
	// 823450EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823450F0: 419A000C  beq cr6, 0x823450fc
	if ctx.cr[6].eq {
	pc = 0x823450FC; continue 'dispatch;
	}
	// 823450F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823450F8: 4BF7B799  bl 0x822c0890
	ctx.lr = 0x823450FC;
	sub_822C0890(ctx, base);
	// 823450FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82345100: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82345104: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82345108: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234510C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82345110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82345118 size=608
    let mut pc: u32 = 0x82345118;
    'dispatch: loop {
        match pc {
            0x82345118 => {
    //   block [0x82345118..0x82345378)
	// 82345118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234511C: 48E63051  bl 0x831a816c
	ctx.lr = 0x82345120;
	sub_831A8130(ctx, base);
	// 82345120: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82345124: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234512C: 486CB745  bl 0x82a10870
	ctx.lr = 0x82345130;
	sub_82A10870(ctx, base);
	// 82345130: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82345134: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82345138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234513C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345140: C00BA4F8  lfs f0, -0x5b08(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82345144: C1AACEE4  lfs f13, -0x311c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82345148: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8234514C: 48B1462D  bl 0x82e59778
	ctx.lr = 0x82345150;
	sub_82E59778(ctx, base);
	// 82345150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345154: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82345158: 4BFDBA39  bl 0x82320b90
	ctx.lr = 0x8234515C;
	sub_82320B90(ctx, base);
	// 8234515C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82345160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345164: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82345168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234516C: 4E800421  bctrl
	ctx.lr = 0x82345170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82345170: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82345174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345178: 4182000C  beq 0x82345184
	if ctx.cr[0].eq {
	pc = 0x82345184; continue 'dispatch;
	}
	// 8234517C: 4BFFF5DD  bl 0x82344758
	ctx.lr = 0x82345180;
	sub_82344758(ctx, base);
	// 82345180: 480001EC  b 0x8234536c
	pc = 0x8234536C; continue 'dispatch;
	// 82345184: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 82345188: 48B145E1  bl 0x82e59768
	ctx.lr = 0x8234518C;
	sub_82E59768(ctx, base);
	// 8234518C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82345190: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82345194: 48B17CE5  bl 0x82e5ce78
	ctx.lr = 0x82345198;
	sub_82E5CE78(ctx, base);
	// 82345198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234519C: 4BFD6615  bl 0x8231b7b0
	ctx.lr = 0x823451A0;
	sub_8231B7B0(ctx, base);
	// 823451A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823451A4: 4BFFF5B5  bl 0x82344758
	ctx.lr = 0x823451A8;
	sub_82344758(ctx, base);
	// 823451A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823451AC: 4BFD635D  bl 0x8231b508
	ctx.lr = 0x823451B0;
	sub_8231B508(ctx, base);
	// 823451B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823451B4: 41820180  beq 0x82345334
	if ctx.cr[0].eq {
	pc = 0x82345334; continue 'dispatch;
	}
	// 823451B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823451BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823451C0: 4BFCF7F9  bl 0x823149b8
	ctx.lr = 0x823451C4;
	sub_823149B8(ctx, base);
	// 823451C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823451C8: 4082016C  bne 0x82345334
	if !ctx.cr[0].eq {
	pc = 0x82345334; continue 'dispatch;
	}
	// 823451CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823451D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823451D4: 4BFC2AED  bl 0x82307cc0
	ctx.lr = 0x823451D8;
	sub_82307CC0(ctx, base);
	// 823451D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823451DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823451E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823451E4: 4BFD4AC5  bl 0x82319ca8
	ctx.lr = 0x823451E8;
	sub_82319CA8(ctx, base);
	// 823451E8: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823451EC: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823451F0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82345378 size=372
    let mut pc: u32 = 0x82345378;
    'dispatch: loop {
        match pc {
            0x82345378 => {
    //   block [0x82345378..0x823454EC)
	// 82345378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234537C: 48E62DF1  bl 0x831a816c
	ctx.lr = 0x82345380;
	sub_831A8130(ctx, base);
	// 82345380: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345384: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82345388: 48E0F279  bl 0x83154600
	ctx.lr = 0x8234538C;
	sub_83154600(ctx, base);
	// 8234538C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345390: 486CB4E1  bl 0x82a10870
	ctx.lr = 0x82345394;
	sub_82A10870(ctx, base);
	// 82345394: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82345398: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234539C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823453A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823453A4: 3BEBA4E4  addi r31, r11, -0x5b1c
	ctx.r[31].s64 = ctx.r[11].s64 + -23324;
	// 823453A8: C02BA4E4  lfs f1, -0x5b1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23324 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823453AC: 4BFFF8FD  bl 0x82344ca8
	ctx.lr = 0x823453B0;
	sub_82344CA8(ctx, base);
	// 823453B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823453B4: 4BFD1C2D  bl 0x82316fe0
	ctx.lr = 0x823453B8;
	sub_82316FE0(ctx, base);
	// 823453B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 823453BC: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823453C0: C1ABA100  lfs f13, -0x5f00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823453C4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823453C8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823453CC: 4198010C  blt cr6, 0x823454d8
	if ctx.cr[6].lt {
	pc = 0x823454D8; continue 'dispatch;
	}
	// 823453D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823453D4: 48B143A5  bl 0x82e59778
	ctx.lr = 0x823453D8;
	sub_82E59778(ctx, base);
	// 823453D8: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823453DC: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 823453E0: D1BE0060  stfs f13, 0x60(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823453E4: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823453E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823453EC: 409900F8  ble cr6, 0x823454e4
	if !ctx.cr[6].gt {
	pc = 0x823454E4; continue 'dispatch;
	}
	// 823453F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823453F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823453F8: 388B2610  addi r4, r11, 0x2610
	ctx.r[4].s64 = ctx.r[11].s64 + 9744;
	// 823453FC: 38A00117  li r5, 0x117
	ctx.r[5].s64 = 279;
	// 82345400: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82345404: 48AACFE5  bl 0x82df23e8
	ctx.lr = 0x82345408;
	sub_82DF23E8(ctx, base);
	// 82345408: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8234540C: 4182001C  beq 0x82345428
	if ctx.cr[0].eq {
	pc = 0x82345428; continue 'dispatch;
	}
	// 82345410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345414: 48B17515  bl 0x82e5c928
	ctx.lr = 0x82345418;
	sub_82E5C928(ctx, base);
	// 82345418: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234541C: 396B259C  addi r11, r11, 0x259c
	ctx.r[11].s64 = ctx.r[11].s64 + 9628;
	// 82345420: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82345424: 48000008  b 0x8234542c
	pc = 0x8234542C; continue 'dispatch;
	// 82345428: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8234542C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82345430: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82345434: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345438: 4BFFF471  bl 0x823448a8
	ctx.lr = 0x8234543C;
	sub_823448A8(ctx, base);
	// 8234543C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82345440: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82345444: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345448: 4BF7ABB9  bl 0x822c0000
	ctx.lr = 0x8234544C;
	sub_822C0000(ctx, base);
	// 8234544C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82345450: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82345454: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82345458: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8234545C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82345460: 419A0024  beq cr6, 0x82345484
	if ctx.cr[6].eq {
	pc = 0x82345484; continue 'dispatch;
	}
	// 82345464: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82345468: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234546C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82345470: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82345474: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82345478: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234547C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82345480: 4082FFE8  bne 0x82345468
	if !ctx.cr[0].eq {
	pc = 0x82345468; continue 'dispatch;
	}
	// 82345484: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82345488: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8234548C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82345490: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82345494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82345498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8234549C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823454A0: 48B19421  bl 0x82e5e8c0
	ctx.lr = 0x823454A4;
	sub_82E5E8C0(ctx, base);
	// 823454A4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823454A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823454AC: 419A0008  beq cr6, 0x823454b4
	if ctx.cr[6].eq {
	pc = 0x823454B4; continue 'dispatch;
	}
	// 823454B0: 4BF7B3E1  bl 0x822c0890
	ctx.lr = 0x823454B4;
	sub_822C0890(ctx, base);
	// 823454B4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823454B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823454BC: 419A0008  beq cr6, 0x823454c4
	if ctx.cr[6].eq {
	pc = 0x823454C4; continue 'dispatch;
	}
	// 823454C0: 4BF7B3D1  bl 0x822c0890
	ctx.lr = 0x823454C4;
	sub_822C0890(ctx, base);
	// 823454C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823454C8: 419A001C  beq cr6, 0x823454e4
	if ctx.cr[6].eq {
	pc = 0x823454E4; continue 'dispatch;
	}
	// 823454CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823454D0: 4BF7B3C1  bl 0x822c0890
	ctx.lr = 0x823454D4;
	sub_822C0890(ctx, base);
	// 823454D4: 48000010  b 0x823454e4
	pc = 0x823454E4; continue 'dispatch;
	// 823454D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823454DC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823454E0: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823454E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823454E8: 48E62CD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823454F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823454F0 size=336
    let mut pc: u32 = 0x823454F0;
    'dispatch: loop {
        match pc {
            0x823454F0 => {
    //   block [0x823454F0..0x82345640)
	// 823454F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823454F4: 48E62C79  bl 0x831a816c
	ctx.lr = 0x823454F8;
	sub_831A8130(ctx, base);
	// 823454F8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 823454FC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345500: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82345504: 48E0F0FD  bl 0x83154600
	ctx.lr = 0x82345508;
	sub_83154600(ctx, base);
	// 82345508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234550C: 486CB365  bl 0x82a10870
	ctx.lr = 0x82345510;
	sub_82A10870(ctx, base);
	// 82345510: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82345514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345518: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8234551C: 4810E12D  bl 0x82453648
	ctx.lr = 0x82345520;
	sub_82453648(ctx, base);
	// 82345520: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 82345524: 807D01FC  lwz r3, 0x1fc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(508 as u32) ) } as u64;
	// 82345528: 481158C1  bl 0x8245ade8
	ctx.lr = 0x8234552C;
	sub_8245ADE8(ctx, base);
	// 8234552C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82345530: 391E0060  addi r8, r30, 0x60
	ctx.r[8].s64 = ctx.r[30].s64 + 96;
	// 82345534: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82345538: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8234553C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345540: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82345544: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82345548: 48002301  bl 0x82347848
	ctx.lr = 0x8234554C;
	sub_82347848(ctx, base);
	// 8234554C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82345550: 408200E4  bne 0x82345634
	if !ctx.cr[0].eq {
	pc = 0x82345634; continue 'dispatch;
	}
	// 82345554: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345558: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234555C: 388B2610  addi r4, r11, 0x2610
	ctx.r[4].s64 = ctx.r[11].s64 + 9744;
	// 82345560: 38A00144  li r5, 0x144
	ctx.r[5].s64 = 324;
	// 82345564: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82345568: 48AACE81  bl 0x82df23e8
	ctx.lr = 0x8234556C;
	sub_82DF23E8(ctx, base);
	// 8234556C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82345570: 4182001C  beq 0x8234558c
	if ctx.cr[0].eq {
	pc = 0x8234558C; continue 'dispatch;
	}
	// 82345574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345578: 48B173B1  bl 0x82e5c928
	ctx.lr = 0x8234557C;
	sub_82E5C928(ctx, base);
	// 8234557C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345580: 396B25C4  addi r11, r11, 0x25c4
	ctx.r[11].s64 = ctx.r[11].s64 + 9668;
	// 82345584: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82345588: 48000008  b 0x82345590
	pc = 0x82345590; continue 'dispatch;
	// 8234558C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82345590: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82345594: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82345598: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234559C: 4BFFF3D5  bl 0x82344970
	ctx.lr = 0x823455A0;
	sub_82344970(ctx, base);
	// 823455A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823455A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823455A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823455AC: 4BF7AA55  bl 0x822c0000
	ctx.lr = 0x823455B0;
	sub_822C0000(ctx, base);
	// 823455B0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823455B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823455B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823455BC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 823455C0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823455C4: 419A0024  beq cr6, 0x823455e8
	if ctx.cr[6].eq {
	pc = 0x823455E8; continue 'dispatch;
	}
	// 823455C8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 823455CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823455D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823455D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823455D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823455DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823455E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823455E4: 4082FFE8  bne 0x823455cc
	if !ctx.cr[0].eq {
	pc = 0x823455CC; continue 'dispatch;
	}
	// 823455E8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823455EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823455F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823455F4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823455F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823455FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82345600: 48B192C1  bl 0x82e5e8c0
	ctx.lr = 0x82345604;
	sub_82E5E8C0(ctx, base);
	// 82345604: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82345608: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234560C: 419A0008  beq cr6, 0x82345614
	if ctx.cr[6].eq {
	pc = 0x82345614; continue 'dispatch;
	}
	// 82345610: 4BF7B281  bl 0x822c0890
	ctx.lr = 0x82345614;
	sub_822C0890(ctx, base);
	// 82345614: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82345618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234561C: 419A0008  beq cr6, 0x82345624
	if ctx.cr[6].eq {
	pc = 0x82345624; continue 'dispatch;
	}
	// 82345620: 4BF7B271  bl 0x822c0890
	ctx.lr = 0x82345624;
	sub_822C0890(ctx, base);
	// 82345624: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82345628: 419A000C  beq cr6, 0x82345634
	if ctx.cr[6].eq {
	pc = 0x82345634; continue 'dispatch;
	}
	// 8234562C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345630: 4BF7B261  bl 0x822c0890
	ctx.lr = 0x82345634;
	sub_822C0890(ctx, base);
	// 82345634: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82345638: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8234563C: 48E62B80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82345640 size=308
    let mut pc: u32 = 0x82345640;
    'dispatch: loop {
        match pc {
            0x82345640 => {
    //   block [0x82345640..0x82345774)
	// 82345640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82345644: 48E62B29  bl 0x831a816c
	ctx.lr = 0x82345648;
	sub_831A8130(ctx, base);
	// 82345648: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234564C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82345650: 48E0EFB1  bl 0x83154600
	ctx.lr = 0x82345654;
	sub_83154600(ctx, base);
	// 82345654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345658: 486CB219  bl 0x82a10870
	ctx.lr = 0x8234565C;
	sub_82A10870(ctx, base);
	// 8234565C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82345660: 4BFCD689  bl 0x82312ce8
	ctx.lr = 0x82345664;
	sub_82312CE8(ctx, base);
	// 82345664: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82345668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234566C: 4BFFF63D  bl 0x82344ca8
	ctx.lr = 0x82345670;
	sub_82344CA8(ctx, base);
	// 82345670: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82345674: 4BFD196D  bl 0x82316fe0
	ctx.lr = 0x82345678;
	sub_82316FE0(ctx, base);
	// 82345678: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234567C: C00BA4E4  lfs f0, -0x5b1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82345680: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82345684: 409800E8  bge cr6, 0x8234576c
	if !ctx.cr[6].lt {
	pc = 0x8234576C; continue 'dispatch;
	}
	// 82345688: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234568C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82345690: 388B2610  addi r4, r11, 0x2610
	ctx.r[4].s64 = ctx.r[11].s64 + 9744;
	// 82345694: 38A0015A  li r5, 0x15a
	ctx.r[5].s64 = 346;
	// 82345698: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8234569C: 48AACD4D  bl 0x82df23e8
	ctx.lr = 0x823456A0;
	sub_82DF23E8(ctx, base);
	// 823456A0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823456A4: 4182001C  beq 0x823456c0
	if ctx.cr[0].eq {
	pc = 0x823456C0; continue 'dispatch;
	}
	// 823456A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823456AC: 48B1727D  bl 0x82e5c928
	ctx.lr = 0x823456B0;
	sub_82E5C928(ctx, base);
	// 823456B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823456B4: 396B25C4  addi r11, r11, 0x25c4
	ctx.r[11].s64 = ctx.r[11].s64 + 9668;
	// 823456B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823456BC: 48000008  b 0x823456c4
	pc = 0x823456C4; continue 'dispatch;
	// 823456C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823456C4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823456C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823456CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823456D0: 4BFFF2A1  bl 0x82344970
	ctx.lr = 0x823456D4;
	sub_82344970(ctx, base);
	// 823456D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823456D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823456DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823456E0: 4BF7A921  bl 0x822c0000
	ctx.lr = 0x823456E4;
	sub_822C0000(ctx, base);
	// 823456E4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823456E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823456EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823456F0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 823456F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823456F8: 419A0024  beq cr6, 0x8234571c
	if ctx.cr[6].eq {
	pc = 0x8234571C; continue 'dispatch;
	}
	// 823456FC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82345700: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82345704: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82345708: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234570C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82345710: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82345714: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82345718: 4082FFE8  bne 0x82345700
	if !ctx.cr[0].eq {
	pc = 0x82345700; continue 'dispatch;
	}
	// 8234571C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82345720: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82345724: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82345728: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8234572C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82345730: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82345734: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82345738: 48B19189  bl 0x82e5e8c0
	ctx.lr = 0x8234573C;
	sub_82E5E8C0(ctx, base);
	// 8234573C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82345740: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82345744: 419A0008  beq cr6, 0x8234574c
	if ctx.cr[6].eq {
	pc = 0x8234574C; continue 'dispatch;
	}
	// 82345748: 4BF7B149  bl 0x822c0890
	ctx.lr = 0x8234574C;
	sub_822C0890(ctx, base);
	// 8234574C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82345750: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82345754: 419A0008  beq cr6, 0x8234575c
	if ctx.cr[6].eq {
	pc = 0x8234575C; continue 'dispatch;
	}
	// 82345758: 4BF7B139  bl 0x822c0890
	ctx.lr = 0x8234575C;
	sub_822C0890(ctx, base);
	// 8234575C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82345760: 419A000C  beq cr6, 0x8234576c
	if ctx.cr[6].eq {
	pc = 0x8234576C; continue 'dispatch;
	}
	// 82345764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345768: 4BF7B129  bl 0x822c0890
	ctx.lr = 0x8234576C;
	sub_822C0890(ctx, base);
	// 8234576C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82345770: 48E62A4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82345778 size=1528
    let mut pc: u32 = 0x82345778;
    'dispatch: loop {
        match pc {
            0x82345778 => {
    //   block [0x82345778..0x82345D70)
	// 82345778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234577C: 48E629E5  bl 0x831a8160
	ctx.lr = 0x82345780;
	sub_831A8130(ctx, base);
	// 82345780: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82345784: 48E632F5  bl 0x831a8a78
	ctx.lr = 0x82345788;
	sub_831A8A40(ctx, base);
	// 82345788: 9421FD20  stwu r1, -0x2e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-736 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234578C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345790: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82345794: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82345798: 388BEB84  addi r4, r11, -0x147c
	ctx.r[4].s64 = ctx.r[11].s64 + -5244;
	// 8234579C: 48AAE26D  bl 0x82df3a08
	ctx.lr = 0x823457A0;
	sub_82DF3A08(ctx, base);
	// 823457A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823457A4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 823457A8: 388BEB78  addi r4, r11, -0x1488
	ctx.r[4].s64 = ctx.r[11].s64 + -5256;
	// 823457AC: 48AAE25D  bl 0x82df3a08
	ctx.lr = 0x823457B0;
	sub_82DF3A08(ctx, base);
	// 823457B0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 823457B4: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 823457B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823457BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823457C0: 482833D9  bl 0x825c8b98
	ctx.lr = 0x823457C4;
	sub_825C8B98(ctx, base);
	// 823457C4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823457C8: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823457CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823457D0: 419A000C  beq cr6, 0x823457dc
	if ctx.cr[6].eq {
	pc = 0x823457DC; continue 'dispatch;
	}
	// 823457D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823457D8: 4BF7B0B9  bl 0x822c0890
	ctx.lr = 0x823457DC;
	sub_822C0890(ctx, base);
	// 823457DC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 823457E0: 48AADC49  bl 0x82df3428
	ctx.lr = 0x823457E4;
	sub_82DF3428(ctx, base);
	// 823457E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823457E8: 48AADC41  bl 0x82df3428
	ctx.lr = 0x823457EC;
	sub_82DF3428(ctx, base);
	// 823457EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823457F0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 823457F4: 388BEB70  addi r4, r11, -0x1490
	ctx.r[4].s64 = ctx.r[11].s64 + -5264;
	// 823457F8: 48AAE211  bl 0x82df3a08
	ctx.lr = 0x823457FC;
	sub_82DF3A08(ctx, base);
	// 823457FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345800: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345804: 388BEB64  addi r4, r11, -0x149c
	ctx.r[4].s64 = ctx.r[11].s64 + -5276;
	// 82345808: 48AAE201  bl 0x82df3a08
	ctx.lr = 0x8234580C;
	sub_82DF3A08(ctx, base);
	// 8234580C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82345810: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82345814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345818: 48284CE9  bl 0x825ca500
	ctx.lr = 0x8234581C;
	sub_825CA500(ctx, base);
	// 8234581C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82345820: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345824: 48AADC05  bl 0x82df3428
	ctx.lr = 0x82345828;
	sub_82DF3428(ctx, base);
	// 82345828: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8234582C: 48AADBFD  bl 0x82df3428
	ctx.lr = 0x82345830;
	sub_82DF3428(ctx, base);
	// 82345830: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345838: 388B2848  addi r4, r11, 0x2848
	ctx.r[4].s64 = ctx.r[11].s64 + 10312;
	// 8234583C: 48AAE1CD  bl 0x82df3a08
	ctx.lr = 0x82345840;
	sub_82DF3A08(ctx, base);
	// 82345840: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345844: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345848: 388B2838  addi r4, r11, 0x2838
	ctx.r[4].s64 = ctx.r[11].s64 + 10296;
	// 8234584C: 48AAE1BD  bl 0x82df3a08
	ctx.lr = 0x82345850;
	sub_82DF3A08(ctx, base);
	// 82345850: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82345854: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82345858: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8234585C: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82345860: 3BEBA4E4  addi r31, r11, -0x5b1c
	ctx.r[31].s64 = ctx.r[11].s64 + -23324;
	// 82345864: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82345868: C3CA964C  lfs f30, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8234586C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82345870: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82345874: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82345878: C0496218  lfs f2, 0x6218(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8234587C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82345880: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82345884: 48268235  bl 0x825adab8
	ctx.lr = 0x82345888;
	sub_825ADAB8(ctx, base);
	// 82345888: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234588C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82345890: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82345894: 4825BDBD  bl 0x825a1650
	ctx.lr = 0x82345898;
	sub_825A1650(ctx, base);
	// 82345898: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 8234589C: 48AADB8D  bl 0x82df3428
	ctx.lr = 0x823458A0;
	sub_82DF3428(ctx, base);
	// 823458A0: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 823458A4: 4BF83415  bl 0x822c8cb8
	ctx.lr = 0x823458A8;
	sub_822C8CB8(ctx, base);
	// 823458A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823458AC: 48AADB7D  bl 0x82df3428
	ctx.lr = 0x823458B0;
	sub_82DF3428(ctx, base);
	// 823458B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823458B4: 48AADB75  bl 0x82df3428
	ctx.lr = 0x823458B8;
	sub_82DF3428(ctx, base);
	// 823458B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823458BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823458C0: 388B2818  addi r4, r11, 0x2818
	ctx.r[4].s64 = ctx.r[11].s64 + 10264;
	// 823458C4: 48AAE145  bl 0x82df3a08
	ctx.lr = 0x823458C8;
	sub_82DF3A08(ctx, base);
	// 823458C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823458CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823458D0: 388B2804  addi r4, r11, 0x2804
	ctx.r[4].s64 = ctx.r[11].s64 + 10244;
	// 823458D4: 48AAE135  bl 0x82df3a08
	ctx.lr = 0x823458D8;
	sub_82DF3A08(ctx, base);
	// 823458D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823458DC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 823458E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823458E4: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 823458E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 823458EC: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 823458F0: C38B9528  lfs f28, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823458F4: C04A89AC  lfs f2, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823458F8: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 823458FC: 482681BD  bl 0x825adab8
	ctx.lr = 0x82345900;
	sub_825ADAB8(ctx, base);
	// 82345900: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82345904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82345908: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234590C: 4825BD45  bl 0x825a1650
	ctx.lr = 0x82345910;
	sub_825A1650(ctx, base);
	// 82345910: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82345914: 48AADB15  bl 0x82df3428
	ctx.lr = 0x82345918;
	sub_82DF3428(ctx, base);
	// 82345918: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8234591C: 4BF8339D  bl 0x822c8cb8
	ctx.lr = 0x82345920;
	sub_822C8CB8(ctx, base);
	// 82345920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345924: 48AADB05  bl 0x82df3428
	ctx.lr = 0x82345928;
	sub_82DF3428(ctx, base);
	// 82345928: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234592C: 48AADAFD  bl 0x82df3428
	ctx.lr = 0x82345930;
	sub_82DF3428(ctx, base);
	// 82345930: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345934: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345938: 388B27D0  addi r4, r11, 0x27d0
	ctx.r[4].s64 = ctx.r[11].s64 + 10192;
	// 8234593C: 48AAE0CD  bl 0x82df3a08
	ctx.lr = 0x82345940;
	sub_82DF3A08(ctx, base);
	// 82345940: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345948: 388B27B0  addi r4, r11, 0x27b0
	ctx.r[4].s64 = ctx.r[11].s64 + 10160;
	// 8234594C: 48AAE0BD  bl 0x82df3a08
	ctx.lr = 0x82345950;
	sub_82DF3A08(ctx, base);
	// 82345950: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82345954: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82345958: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234595C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82345960: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82345964: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 82345968: C3ABDD6C  lfs f29, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234596C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82345970: 48268149  bl 0x825adab8
	ctx.lr = 0x82345974;
	sub_825ADAB8(ctx, base);
	// 82345974: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82345978: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234597C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82345980: 4825BCD1  bl 0x825a1650
	ctx.lr = 0x82345984;
	sub_825A1650(ctx, base);
	// 82345984: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 82345988: 48AADAA1  bl 0x82df3428
	ctx.lr = 0x8234598C;
	sub_82DF3428(ctx, base);
	// 8234598C: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 82345990: 4BF83329  bl 0x822c8cb8
	ctx.lr = 0x82345994;
	sub_822C8CB8(ctx, base);
	// 82345994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345998: 48AADA91  bl 0x82df3428
	ctx.lr = 0x8234599C;
	sub_82DF3428(ctx, base);
	// 8234599C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823459A0: 48AADA89  bl 0x82df3428
	ctx.lr = 0x823459A4;
	sub_82DF3428(ctx, base);
	// 823459A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823459A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823459AC: 388B277C  addi r4, r11, 0x277c
	ctx.r[4].s64 = ctx.r[11].s64 + 10108;
	// 823459B0: 48AAE059  bl 0x82df3a08
	ctx.lr = 0x823459B4;
	sub_82DF3A08(ctx, base);
	// 823459B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823459B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823459BC: 388B275C  addi r4, r11, 0x275c
	ctx.r[4].s64 = ctx.r[11].s64 + 10076;
	// 823459C0: 48AAE049  bl 0x82df3a08
	ctx.lr = 0x823459C4;
	sub_82DF3A08(ctx, base);
	// 823459C4: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 823459C8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 823459CC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 823459D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 823459D4: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 823459D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823459DC: 482680DD  bl 0x825adab8
	ctx.lr = 0x823459E0;
	sub_825ADAB8(ctx, base);
	// 823459E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 823459E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823459E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823459EC: 4825BC65  bl 0x825a1650
	ctx.lr = 0x823459F0;
	sub_825A1650(ctx, base);
	// 823459F0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 823459F4: 48AADA35  bl 0x82df3428
	ctx.lr = 0x823459F8;
	sub_82DF3428(ctx, base);
	// 823459F8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 823459FC: 4BF832BD  bl 0x822c8cb8
	ctx.lr = 0x82345A00;
	sub_822C8CB8(ctx, base);
	// 82345A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345A04: 48AADA25  bl 0x82df3428
	ctx.lr = 0x82345A08;
	sub_82DF3428(ctx, base);
	// 82345A08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345A0C: 48AADA1D  bl 0x82df3428
	ctx.lr = 0x82345A10;
	sub_82DF3428(ctx, base);
	// 82345A10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345A14: 482842BD  bl 0x825c9cd0
	ctx.lr = 0x82345A18;
	sub_825C9CD0(ctx, base);
	// 82345A18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345A1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345A20: 3BAB0568  addi r29, r11, 0x568
	ctx.r[29].s64 = ctx.r[11].s64 + 1384;
	// 82345A24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82345A28: 48AADFE1  bl 0x82df3a08
	ctx.lr = 0x82345A2C;
	sub_82DF3A08(ctx, base);
	// 82345A2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345A30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345A34: 3B8BD964  addi r28, r11, -0x269c
	ctx.r[28].s64 = ctx.r[11].s64 + -9884;
	// 82345A38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82345A3C: 48AADFCD  bl 0x82df3a08
	ctx.lr = 0x82345A40;
	sub_82DF3A08(ctx, base);
	// 82345A40: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82345A44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82345A48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345A4C: 48284AB5  bl 0x825ca500
	ctx.lr = 0x82345A50;
	sub_825CA500(ctx, base);
	// 82345A50: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82345A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345A58: 48AAD9D1  bl 0x82df3428
	ctx.lr = 0x82345A5C;
	sub_82DF3428(ctx, base);
	// 82345A5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345A60: 48AAD9C9  bl 0x82df3428
	ctx.lr = 0x82345A64;
	sub_82DF3428(ctx, base);
	// 82345A64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345A68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345A6C: 388B2728  addi r4, r11, 0x2728
	ctx.r[4].s64 = ctx.r[11].s64 + 10024;
	// 82345A70: 48AADF99  bl 0x82df3a08
	ctx.lr = 0x82345A74;
	sub_82DF3A08(ctx, base);
	// 82345A74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345A78: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345A7C: 388B270C  addi r4, r11, 0x270c
	ctx.r[4].s64 = ctx.r[11].s64 + 9996;
	// 82345A80: 48AADF89  bl 0x82df3a08
	ctx.lr = 0x82345A84;
	sub_82DF3A08(ctx, base);
	// 82345A84: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82345A88: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82345A8C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82345A90: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82345A94: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82345A98: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82345A9C: 4826801D  bl 0x825adab8
	ctx.lr = 0x82345AA0;
	sub_825ADAB8(ctx, base);
	// 82345AA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82345AA4: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82345AA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82345AAC: 4825BBA5  bl 0x825a1650
	ctx.lr = 0x82345AB0;
	sub_825A1650(ctx, base);
	// 82345AB0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82345AB4: 48AAD975  bl 0x82df3428
	ctx.lr = 0x82345AB8;
	sub_82DF3428(ctx, base);
	// 82345AB8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82345ABC: 4BF831FD  bl 0x822c8cb8
	ctx.lr = 0x82345AC0;
	sub_822C8CB8(ctx, base);
	// 82345AC0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345AC4: 48AAD965  bl 0x82df3428
	ctx.lr = 0x82345AC8;
	sub_82DF3428(ctx, base);
	// 82345AC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345ACC: 48AAD95D  bl 0x82df3428
	ctx.lr = 0x82345AD0;
	sub_82DF3428(ctx, base);
	// 82345AD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345AD4: 482841FD  bl 0x825c9cd0
	ctx.lr = 0x82345AD8;
	sub_825C9CD0(ctx, base);
	// 82345AD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345ADC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345AE0: 388BEC94  addi r4, r11, -0x136c
	ctx.r[4].s64 = ctx.r[11].s64 + -4972;
	// 82345AE4: 48AADF25  bl 0x82df3a08
	ctx.lr = 0x82345AE8;
	sub_82DF3A08(ctx, base);
	// 82345AE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345AEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345AF0: 388BCE58  addi r4, r11, -0x31a8
	ctx.r[4].s64 = ctx.r[11].s64 + -12712;
	// 82345AF4: 48AADF15  bl 0x82df3a08
	ctx.lr = 0x82345AF8;
	sub_82DF3A08(ctx, base);
	// 82345AF8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82345AFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82345B00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345B04: 482849FD  bl 0x825ca500
	ctx.lr = 0x82345B08;
	sub_825CA500(ctx, base);
	// 82345B08: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82345B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345B10: 48AAD919  bl 0x82df3428
	ctx.lr = 0x82345B14;
	sub_82DF3428(ctx, base);
	// 82345B14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345B18: 48AAD911  bl 0x82df3428
	ctx.lr = 0x82345B1C;
	sub_82DF3428(ctx, base);
	// 82345B1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345B20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345B24: 388B26D4  addi r4, r11, 0x26d4
	ctx.r[4].s64 = ctx.r[11].s64 + 9940;
	// 82345B28: 48AADEE1  bl 0x82df3a08
	ctx.lr = 0x82345B2C;
	sub_82DF3A08(ctx, base);
	// 82345B2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345B30: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345B34: 388B26C0  addi r4, r11, 0x26c0
	ctx.r[4].s64 = ctx.r[11].s64 + 9920;
	// 82345B38: 48AADED1  bl 0x82df3a08
	ctx.lr = 0x82345B3C;
	sub_82DF3A08(ctx, base);
	// 82345B3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82345B40: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 82345B44: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82345B48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82345B4C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82345B50: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82345B54: C3CB08A8  lfs f30, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82345B58: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82345B5C: 48267F5D  bl 0x825adab8
	ctx.lr = 0x82345B60;
	sub_825ADAB8(ctx, base);
	// 82345B60: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82345B64: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82345B68: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82345B6C: 4825BAE5  bl 0x825a1650
	ctx.lr = 0x82345B70;
	sub_825A1650(ctx, base);
	// 82345B70: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 82345B74: 48AAD8B5  bl 0x82df3428
	ctx.lr = 0x82345B78;
	sub_82DF3428(ctx, base);
	// 82345B78: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82345B7C: 4BF8313D  bl 0x822c8cb8
	ctx.lr = 0x82345B80;
	sub_822C8CB8(ctx, base);
	// 82345B80: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345B84: 48AAD8A5  bl 0x82df3428
	ctx.lr = 0x82345B88;
	sub_82DF3428(ctx, base);
	// 82345B88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345B8C: 48AAD89D  bl 0x82df3428
	ctx.lr = 0x82345B90;
	sub_82DF3428(ctx, base);
	// 82345B90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345B94: 4828413D  bl 0x825c9cd0
	ctx.lr = 0x82345B98;
	sub_825C9CD0(ctx, base);
	// 82345B98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345B9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345BA0: 388BDA94  addi r4, r11, -0x256c
	ctx.r[4].s64 = ctx.r[11].s64 + -9580;
	// 82345BA4: 48AADE65  bl 0x82df3a08
	ctx.lr = 0x82345BA8;
	sub_82DF3A08(ctx, base);
	// 82345BA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345BAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345BB0: 388BDA8C  addi r4, r11, -0x2574
	ctx.r[4].s64 = ctx.r[11].s64 + -9588;
	// 82345BB4: 48AADE55  bl 0x82df3a08
	ctx.lr = 0x82345BB8;
	sub_82DF3A08(ctx, base);
	// 82345BB8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82345BBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82345BC0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82345BC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82345BC8: 48282FD1  bl 0x825c8b98
	ctx.lr = 0x82345BCC;
	sub_825C8B98(ctx, base);
	// 82345BCC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82345BD0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82345BD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82345BD8: 419A0008  beq cr6, 0x82345be0
	if ctx.cr[6].eq {
	pc = 0x82345BE0; continue 'dispatch;
	}
	// 82345BDC: 4BF7ACB5  bl 0x822c0890
	ctx.lr = 0x82345BE0;
	sub_822C0890(ctx, base);
	// 82345BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345BE4: 48AAD845  bl 0x82df3428
	ctx.lr = 0x82345BE8;
	sub_82DF3428(ctx, base);
	// 82345BE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82345BEC: 48AAD83D  bl 0x82df3428
	ctx.lr = 0x82345BF0;
	sub_82DF3428(ctx, base);
	// 82345BF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345BF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345BF8: 388B0A88  addi r4, r11, 0xa88
	ctx.r[4].s64 = ctx.r[11].s64 + 2696;
	// 82345BFC: 48AADE0D  bl 0x82df3a08
	ctx.lr = 0x82345C00;
	sub_82DF3A08(ctx, base);
	// 82345C00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345C04: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345C08: 388B0A7C  addi r4, r11, 0xa7c
	ctx.r[4].s64 = ctx.r[11].s64 + 2684;
	// 82345C0C: 48AADDFD  bl 0x82df3a08
	ctx.lr = 0x82345C10;
	sub_82DF3A08(ctx, base);
	// 82345C10: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82345C14: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82345C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345C1C: 482848E5  bl 0x825ca500
	ctx.lr = 0x82345C20;
	sub_825CA500(ctx, base);
	// 82345C20: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82345C24: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345C28: 48AAD801  bl 0x82df3428
	ctx.lr = 0x82345C2C;
	sub_82DF3428(ctx, base);
	// 82345C2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345C30: 48AAD7F9  bl 0x82df3428
	ctx.lr = 0x82345C34;
	sub_82DF3428(ctx, base);
	// 82345C34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345C38: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82345C3C: 388B26AC  addi r4, r11, 0x26ac
	ctx.r[4].s64 = ctx.r[11].s64 + 9900;
	// 82345C40: 48AADDC9  bl 0x82df3a08
	ctx.lr = 0x82345C44;
	sub_82DF3A08(ctx, base);
	// 82345C44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345C48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82345C4C: 388B2694  addi r4, r11, 0x2694
	ctx.r[4].s64 = ctx.r[11].s64 + 9876;
	// 82345C50: 48AADDB9  bl 0x82df3a08
	ctx.lr = 0x82345C54;
	sub_82DF3A08(ctx, base);
	// 82345C54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82345C58: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 82345C5C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82345C60: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82345C64: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82345C68: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82345C6C: C3AB9A8C  lfs f29, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82345C70: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82345C74: 48267E45  bl 0x825adab8
	ctx.lr = 0x82345C78;
	sub_825ADAB8(ctx, base);
	// 82345C78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82345C7C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82345C80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82345C84: 4825B9CD  bl 0x825a1650
	ctx.lr = 0x82345C88;
	sub_825A1650(ctx, base);
	// 82345C88: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 82345C8C: 48AAD79D  bl 0x82df3428
	ctx.lr = 0x82345C90;
	sub_82DF3428(ctx, base);
	// 82345C90: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 82345C94: 4BF83025  bl 0x822c8cb8
	ctx.lr = 0x82345C98;
	sub_822C8CB8(ctx, base);
	// 82345C98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82345C9C: 48AAD78D  bl 0x82df3428
	ctx.lr = 0x82345CA0;
	sub_82DF3428(ctx, base);
	// 82345CA0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82345CA4: 48AAD785  bl 0x82df3428
	ctx.lr = 0x82345CA8;
	sub_82DF3428(ctx, base);
	// 82345CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345CAC: 48284025  bl 0x825c9cd0
	ctx.lr = 0x82345CB0;
	sub_825C9CD0(ctx, base);
	// 82345CB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82345CB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345CB8: 48AADD51  bl 0x82df3a08
	ctx.lr = 0x82345CBC;
	sub_82DF3A08(ctx, base);
	// 82345CBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82345CC0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345CC4: 48AADD45  bl 0x82df3a08
	ctx.lr = 0x82345CC8;
	sub_82DF3A08(ctx, base);
	// 82345CC8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82345CCC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82345CD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345CD4: 4828482D  bl 0x825ca500
	ctx.lr = 0x82345CD8;
	sub_825CA500(ctx, base);
	// 82345CD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82345CDC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82345CE0: 48AAD749  bl 0x82df3428
	ctx.lr = 0x82345CE4;
	sub_82DF3428(ctx, base);
	// 82345CE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82345CE8: 48AAD741  bl 0x82df3428
	ctx.lr = 0x82345CEC;
	sub_82DF3428(ctx, base);
	// 82345CEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345CF0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82345CF4: 388BF3A8  addi r4, r11, -0xc58
	ctx.r[4].s64 = ctx.r[11].s64 + -3160;
	// 82345CF8: 48AADD11  bl 0x82df3a08
	ctx.lr = 0x82345CFC;
	sub_82DF3A08(ctx, base);
	// 82345CFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345D00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82345D04: 388B2674  addi r4, r11, 0x2674
	ctx.r[4].s64 = ctx.r[11].s64 + 9844;
	// 82345D08: 48AADD01  bl 0x82df3a08
	ctx.lr = 0x82345D0C;
	sub_82DF3A08(ctx, base);
	// 82345D0C: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 82345D10: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82345D14: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82345D18: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82345D1C: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 82345D20: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82345D24: 48267D95  bl 0x825adab8
	ctx.lr = 0x82345D28;
	sub_825ADAB8(ctx, base);
	// 82345D28: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82345D2C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82345D30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82345D34: 4825B91D  bl 0x825a1650
	ctx.lr = 0x82345D38;
	sub_825A1650(ctx, base);
	// 82345D38: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 82345D3C: 48AAD6ED  bl 0x82df3428
	ctx.lr = 0x82345D40;
	sub_82DF3428(ctx, base);
	// 82345D40: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 82345D44: 4BF82F75  bl 0x822c8cb8
	ctx.lr = 0x82345D48;
	sub_822C8CB8(ctx, base);
	// 82345D48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82345D4C: 48AAD6DD  bl 0x82df3428
	ctx.lr = 0x82345D50;
	sub_82DF3428(ctx, base);
	// 82345D50: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82345D54: 48AAD6D5  bl 0x82df3428
	ctx.lr = 0x82345D58;
	sub_82DF3428(ctx, base);
	// 82345D58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345D5C: 48283F75  bl 0x825c9cd0
	ctx.lr = 0x82345D60;
	sub_825C9CD0(ctx, base);
	// 82345D60: 382102E0  addi r1, r1, 0x2e0
	ctx.r[1].s64 = ctx.r[1].s64 + 736;
	// 82345D64: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82345D68: 48E62D5D  bl 0x831a8ac4
	ctx.lr = 0x82345D6C;
	sub_831A8A8C(ctx, base);
	// 82345D6C: 48E62444  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82345D70 size=116
    let mut pc: u32 = 0x82345D70;
    'dispatch: loop {
        match pc {
            0x82345D70 => {
    //   block [0x82345D70..0x82345DE4)
	// 82345D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82345D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82345D78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82345D7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82345D80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345D88: 4BFFEA69  bl 0x823447f0
	ctx.lr = 0x82345D8C;
	sub_823447F0(ctx, base);
	// 82345D8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345D90: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 82345D94: 396B2860  addi r11, r11, 0x2860
	ctx.r[11].s64 = ctx.r[11].s64 + 10336;
	// 82345D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345D9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82345DA0: 48B17B31  bl 0x82e5d8d0
	ctx.lr = 0x82345DA4;
	sub_82E5D8D0(ctx, base);
	// 82345DA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82345DA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82345DAC: 396B2550  addi r11, r11, 0x2550
	ctx.r[11].s64 = ctx.r[11].s64 + 9552;
	// 82345DB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345DB4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82345DB8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82345DBC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82345DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82345DC4: 4E800421  bctrl
	ctx.lr = 0x82345DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82345DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345DCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82345DD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82345DD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82345DD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82345DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82345DE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82345DE8 size=92
    let mut pc: u32 = 0x82345DE8;
    'dispatch: loop {
        match pc {
            0x82345DE8 => {
    //   block [0x82345DE8..0x82345E44)
	// 82345DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82345DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82345DF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82345DF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345DFC: 480002D5  bl 0x823460d0
	ctx.lr = 0x82345E00;
	sub_823460D0(ctx, base);
	// 82345E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345E04: 486CAA6D  bl 0x82a10870
	ctx.lr = 0x82345E08;
	sub_82A10870(ctx, base);
	// 82345E08: 897F0070  lbz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82345E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345E10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82345E14: 41820014  beq 0x82345e28
	if ctx.cr[0].eq {
	pc = 0x82345E28; continue 'dispatch;
	}
	// 82345E18: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82345E1C: 4BFCDEE5  bl 0x82313d00
	ctx.lr = 0x82345E20;
	sub_82313D00(ctx, base);
	// 82345E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345E24: 4BFD1875  bl 0x82317698
	ctx.lr = 0x82345E28;
	sub_82317698(ctx, base);
	// 82345E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345E2C: 4BFCD705  bl 0x82313530
	ctx.lr = 0x82345E30;
	sub_82313530(ctx, base);
	// 82345E30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82345E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82345E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82345E3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82345E40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82345E48 size=8
    let mut pc: u32 = 0x82345E48;
    'dispatch: loop {
        match pc {
            0x82345E48 => {
    //   block [0x82345E48..0x82345E50)
	// 82345E48: D023006C  stfs f1, 0x6c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82345E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82345E50 size=124
    let mut pc: u32 = 0x82345E50;
    'dispatch: loop {
        match pc {
            0x82345E50 => {
    //   block [0x82345E50..0x82345ECC)
	// 82345E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82345E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82345E58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82345E5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82345E60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345E64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345E68: 48000281  bl 0x823460e8
	ctx.lr = 0x82345E6C;
	sub_823460E8(ctx, base);
	// 82345E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345E70: 486CAA01  bl 0x82a10870
	ctx.lr = 0x82345E74;
	sub_82A10870(ctx, base);
	// 82345E74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82345E78: 4BFCDB51  bl 0x823139c8
	ctx.lr = 0x82345E7C;
	sub_823139C8(ctx, base);
	// 82345E7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82345E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345E84: 4BFD2EF5  bl 0x82318d78
	ctx.lr = 0x82345E88;
	sub_82318D78(ctx, base);
	// 82345E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345E8C: 4BFCD17D  bl 0x82313008
	ctx.lr = 0x82345E90;
	sub_82313008(ctx, base);
	// 82345E90: 987F0064  stb r3, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u8 ) };
	// 82345E94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82345E98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82345E9C: 4BFD11C5  bl 0x82317060
	ctx.lr = 0x82345EA0;
	sub_82317060(ctx, base);
	// 82345EA0: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 82345EA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82345EA8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82345ED0 size=80
    let mut pc: u32 = 0x82345ED0;
    'dispatch: loop {
        match pc {
            0x82345ED0 => {
    //   block [0x82345ED0..0x82345F20)
	// 82345ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82345ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82345ED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82345EDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345EE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345EE4: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82345EE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82345EEC: 419A0018  beq cr6, 0x82345f04
	if ctx.cr[6].eq {
	pc = 0x82345F04; continue 'dispatch;
	}
	// 82345EF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82345EF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82345EF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82345EFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82345F00: 4E800421  bctrl
	ctx.lr = 0x82345F04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82345F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345F08: 48B16681  bl 0x82e5c588
	ctx.lr = 0x82345F0C;
	sub_82E5C588(ctx, base);
	// 82345F0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82345F10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82345F14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82345F18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82345F1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82345F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82345F20 size=248
    let mut pc: u32 = 0x82345F20;
    'dispatch: loop {
        match pc {
            0x82345F20 => {
    //   block [0x82345F20..0x82346018)
	// 82345F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82345F24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82345F28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82345F2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82345F30: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82345F34: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82345F38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82345F3C: 486CA935  bl 0x82a10870
	ctx.lr = 0x82345F40;
	sub_82A10870(ctx, base);
	// 82345F40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82345F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345F48: 48B13831  bl 0x82e59778
	ctx.lr = 0x82345F4C;
	sub_82E59778(ctx, base);
	// 82345F4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82345F50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345F54: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82345F58: 4BFDAC39  bl 0x82320b90
	ctx.lr = 0x82345F5C;
	sub_82320B90(ctx, base);
	// 82345F5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82345F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345F64: 4810D6E5  bl 0x82453648
	ctx.lr = 0x82345F68;
	sub_82453648(ctx, base);
	// 82345F68: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82345F6C: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82345F70: 48114E79  bl 0x8245ade8
	ctx.lr = 0x82345F74;
	sub_8245ADE8(ctx, base);
	// 82345F74: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82345F78: C01F006C  lfs f0, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82345F7C: 391F0080  addi r8, r31, 0x80
	ctx.r[8].s64 = ctx.r[31].s64 + 128;
	// 82345F80: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82345F84: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82345F88: 88BF0064  lbz r5, 0x64(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82345F8C: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82345F90: C04B6150  lfs f2, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82345F94: 480018B5  bl 0x82347848
	ctx.lr = 0x82345F98;
	sub_82347848(ctx, base);
	// 82345F98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82345F9C: 40820010  bne 0x82345fac
	if !ctx.cr[0].eq {
	pc = 0x82345FAC; continue 'dispatch;
	}
	// 82345FA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82345FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345FA8: 4BFCEA19  bl 0x823149c0
	ctx.lr = 0x82345FAC;
	sub_823149C0(ctx, base);
	// 82345FAC: 897F0070  lbz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82345FB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82345FB4: 40820040  bne 0x82345ff4
	if !ctx.cr[0].eq {
	pc = 0x82345FF4; continue 'dispatch;
	}
	// 82345FB8: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 82345FBC: 807E01FC  lwz r3, 0x1fc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 82345FC0: 48114E29  bl 0x8245ade8
	ctx.lr = 0x82345FC4;
	sub_8245ADE8(ctx, base);
	// 82345FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345FC8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82345FCC: 4BFD1015  bl 0x82316fe0
	ctx.lr = 0x82345FD0;
	sub_82316FE0(ctx, base);
	// 82345FD0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82345FD4: 40980020  bge cr6, 0x82345ff4
	if !ctx.cr[6].lt {
	pc = 0x82345FF4; continue 'dispatch;
	}
	// 82345FD8: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82345FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345FE0: 4BFCDD19  bl 0x82313cf8
	ctx.lr = 0x82345FE4;
	sub_82313CF8(ctx, base);
	// 82345FE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82345FE8: 4BFD16B1  bl 0x82317698
	ctx.lr = 0x82345FEC;
	sub_82317698(ctx, base);
	// 82345FEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82345FF0: 997F0070  stb r11, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82345FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82345FF8: 48000081  bl 0x82346078
	ctx.lr = 0x82345FFC;
	sub_82346078(ctx, base);
	// 82345FFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82346000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82346004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82346008: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8234600C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82346010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82346014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82346018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82346018 size=92
    let mut pc: u32 = 0x82346018;
    'dispatch: loop {
        match pc {
            0x82346018 => {
    //   block [0x82346018..0x82346074)
	// 82346018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234601C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82346020: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82346024: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82346028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234602C: 48B168FD  bl 0x82e5c928
	ctx.lr = 0x82346030;
	sub_82E5C928(ctx, base);
	// 82346030: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82346034: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82346038: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8234603C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82346040: 3929288C  addi r9, r9, 0x288c
	ctx.r[9].s64 = ctx.r[9].s64 + 10380;
	// 82346044: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82346048: 911F0060  stw r8, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 8234604C: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82346050: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82346054: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82346058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234605C: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82346060: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82346064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82346068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234606C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82346070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82346078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82346078 size=84
    let mut pc: u32 = 0x82346078;
    'dispatch: loop {
        match pc {
            0x82346078 => {
    //   block [0x82346078..0x823460CC)
	// 82346078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234607C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82346080: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82346084: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82346088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234608C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82346090: 83DF0060  lwz r30, 0x60(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82346094: 48B136CD  bl 0x82e59760
	ctx.lr = 0x82346098;
	sub_82E59760(ctx, base);
	// 82346098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234609C: 48ADBE8D  bl 0x82e21f28
	ctx.lr = 0x823460A0;
	sub_82E21F28(ctx, base);
	// 823460A0: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 823460A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823460A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823460AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823460B0: 4E800421  bctrl
	ctx.lr = 0x823460B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823460B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823460B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823460BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823460C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823460C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823460C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823460D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823460D0 size=20
    let mut pc: u32 = 0x823460D0;
    'dispatch: loop {
        match pc {
            0x823460D0 => {
    //   block [0x823460D0..0x823460E4)
	// 823460D0: 80630060  lwz r3, 0x60(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 823460D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823460D8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823460DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823460E0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823460E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823460E8 size=108
    let mut pc: u32 = 0x823460E8;
    'dispatch: loop {
        match pc {
            0x823460E8 => {
    //   block [0x823460E8..0x82346154)
	// 823460E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823460EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823460F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823460F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823460F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823460FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82346100: 48E0E501  bl 0x83154600
	ctx.lr = 0x82346104;
	sub_83154600(ctx, base);
	// 82346104: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82346108: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234610C: 48D0D045  bl 0x83053150
	ctx.lr = 0x82346110;
	sub_83053150(ctx, base);
	// 82346110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82346114: 83DF0060  lwz r30, 0x60(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82346118: 48CC2011  bl 0x83008128
	ctx.lr = 0x8234611C;
	sub_83008128(ctx, base);
	// 8234611C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82346120: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82346124: 48D388F5  bl 0x8307ea18
	ctx.lr = 0x82346128;
	sub_8307EA18(ctx, base);
	// 82346128: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234612C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82346130: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82346134: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82346138: 4E800421  bctrl
	ctx.lr = 0x8234613C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234613C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82346140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82346144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82346148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234614C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82346150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82346158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82346158 size=96
    let mut pc: u32 = 0x82346158;
    'dispatch: loop {
        match pc {
            0x82346158 => {
    //   block [0x82346158..0x823461B8)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823461B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823461B8 size=104
    let mut pc: u32 = 0x823461B8;
    'dispatch: loop {
        match pc {
            0x823461B8 => {
    //   block [0x823461B8..0x82346220)
	// 823461B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823461BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823461C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823461C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823461C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823461CC: 48B1675D  bl 0x82e5c928
	ctx.lr = 0x823461D0;
	sub_82E5C928(ctx, base);
	// 823461D0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 823461D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823461D8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823461DC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 823461E0: 39000070  li r8, 0x70
	ctx.r[8].s64 = 112;
	// 823461E4: 392928B4  addi r9, r9, 0x28b4
	ctx.r[9].s64 = ctx.r[9].s64 + 10420;
	// 823461E8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823461EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823461F0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823461F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823461F8: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823461FC: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82346200: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82346204: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82346220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82346220 size=2924
    let mut pc: u32 = 0x82346220;
    'dispatch: loop {
        match pc {
            0x82346220 => {
    //   block [0x82346220..0x82346D8C)
	// 82346220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82346224: 48E61F3D  bl 0x831a8160
	ctx.lr = 0x82346228;
	sub_831A8130(ctx, base);
	// 82346228: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 8234622C: 48E62841  bl 0x831a8a6c
	ctx.lr = 0x82346230;
	sub_831A8A40(ctx, base);
	// 82346230: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82346D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82346D90 size=1296
    let mut pc: u32 = 0x82346D90;
    'dispatch: loop {
        match pc {
            0x82346D90 => {
    //   block [0x82346D90..0x823472A0)
	// 82346D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82346D94: 48E613D1  bl 0x831a8164
	ctx.lr = 0x82346D98;
	sub_831A8130(ctx, base);
	// 82346D98: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82346D9C: 48E61CD9  bl 0x831a8a74
	ctx.lr = 0x82346DA0;
	sub_831A8A40(ctx, base);
	// 82346DA0: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823472A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823472A0 size=832
    let mut pc: u32 = 0x823472A0;
    'dispatch: loop {
        match pc {
            0x823472A0 => {
    //   block [0x823472A0..0x823475E0)
	// 823472A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823472A4: 48E60EC1  bl 0x831a8164
	ctx.lr = 0x823472A8;
	sub_831A8130(ctx, base);
	// 823472A8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 823472AC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 823472B0: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823475E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823475E0 size=336
    let mut pc: u32 = 0x823475E0;
    'dispatch: loop {
        match pc {
            0x823475E0 => {
    //   block [0x823475E0..0x82347730)
	// 823475E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823475E4: 48E60B85  bl 0x831a8168
	ctx.lr = 0x823475E8;
	sub_831A8130(ctx, base);
	// 823475E8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 823475EC: 48E6148D  bl 0x831a8a78
	ctx.lr = 0x823475F0;
	sub_831A8A40(ctx, base);
	// 823475F0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823475F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823475F8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823475FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82347600: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82347604: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82347608: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 8234760C: FFE02090  fmr f31, f4
	ctx.f[31].f64 = ctx.f[4].f64;
	// 82347610: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82347614: 48E0CFED  bl 0x83154600
	ctx.lr = 0x82347618;
	sub_83154600(ctx, base);
	// 82347618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234761C: 4BFCB5ED  bl 0x82312c08
	ctx.lr = 0x82347620;
	sub_82312C08(ctx, base);
	// 82347620: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82347624: 41820020  beq 0x82347644
	if ctx.cr[0].eq {
	pc = 0x82347644; continue 'dispatch;
	}
	// 82347628: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8234762C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82347630: 4BFCC6B1  bl 0x82313ce0
	ctx.lr = 0x82347634;
	sub_82313CE0(ctx, base);
	// 82347634: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82347638: 4182000C  beq 0x82347644
	if ctx.cr[0].eq {
	pc = 0x82347644; continue 'dispatch;
	}
	// 8234763C: 3880008D  li r4, 0x8d
	ctx.r[4].s64 = 141;
	// 82347640: 48000014  b 0x82347654
	pc = 0x82347654; continue 'dispatch;
	// 82347644: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82347648: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8234764C: 40820008  bne 0x82347654
	if !ctx.cr[0].eq {
	pc = 0x82347654; continue 'dispatch;
	}
	// 82347650: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 82347654: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82347658: 48113791  bl 0x8245ade8
	ctx.lr = 0x8234765C;
	sub_8245ADE8(ctx, base);
	// 8234765C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82347660: C1AB08A4  lfs f13, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82347664: FF1D6800  fcmpu cr6, f29, f13
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[13].f64);
	// 82347668: 40990044  ble cr6, 0x823476ac
	if !ctx.cr[6].gt {
	pc = 0x823476AC; continue 'dispatch;
	}
	// 8234766C: EC1EE828  fsubs f0, f30, f29
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82347670: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82347674: 4099000C  ble cr6, 0x82347680
	if !ctx.cr[6].gt {
	pc = 0x82347680; continue 'dispatch;
	}
	// 82347678: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 8234767C: 48000008  b 0x82347684
	pc = 0x82347684; continue 'dispatch;
	// 82347680: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82347684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82347688: EFE107F2  fmuls f31, f1, f31
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 8234768C: 48B120ED  bl 0x82e59778
	ctx.lr = 0x82347690;
	sub_82E59778(ctx, base);
	// 82347690: EC1E0824  fdivs f0, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[1].f64) as f32) as f64;
	// 82347694: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82347698: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8234769C: 41980008  blt cr6, 0x823476a4
	if ctx.cr[6].lt {
	pc = 0x823476A4; continue 'dispatch;
	}
	// 823476A0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823476A4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823476A8: 48000020  b 0x823476c8
	pc = 0x823476C8; continue 'dispatch;
	// 823476AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823476B0: EFE107F2  fmuls f31, f1, f31
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 823476B4: EFDEE828  fsubs f30, f30, f29
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 823476B8: 48B120C1  bl 0x82e59778
	ctx.lr = 0x823476BC;
	sub_82E59778(ctx, base);
	// 823476BC: EC1E0824  fdivs f0, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[1].f64) as f32) as f64;
	// 823476C0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 823476C4: 4098000C  bge cr6, 0x823476d0
	if !ctx.cr[6].lt {
	pc = 0x823476D0; continue 'dispatch;
	}
	// 823476C8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823476CC: 48000008  b 0x823476d4
	pc = 0x823476D4; continue 'dispatch;
	// 823476D0: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823476D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823476D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823476DC: 4BFCF985  bl 0x82317060
	ctx.lr = 0x823476E0;
	sub_82317060(ctx, base);
	// 823476E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823476E4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 823476E8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823476EC: FF1DE000  fcmpu cr6, f29, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[28].f64);
	// 823476F0: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82347730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82347730 size=280
    let mut pc: u32 = 0x82347730;
    'dispatch: loop {
        match pc {
            0x82347730 => {
    //   block [0x82347730..0x82347848)
	// 82347730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82347734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82347738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234773C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82347740: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82347744: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82347748: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234774C: 48E0CEB5  bl 0x83154600
	ctx.lr = 0x82347750;
	sub_83154600(ctx, base);
	// 82347750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82347754: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82347758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234775C: 4810BEED  bl 0x82453648
	ctx.lr = 0x82347760;
	sub_82453648(ctx, base);
	// 82347760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82347764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82347768: 4BFC0559  bl 0x82307cc0
	ctx.lr = 0x8234776C;
	sub_82307CC0(ctx, base);
	// 8234776C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82347770: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82347774: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82347778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234777C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82347780: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82347848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82347848 size=860
    let mut pc: u32 = 0x82347848;
    'dispatch: loop {
        match pc {
            0x82347848 => {
    //   block [0x82347848..0x82347BA4)
	// 82347848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234784C: 48E60919  bl 0x831a8164
	ctx.lr = 0x82347850;
	sub_831A8130(ctx, base);
	// 82347850: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82347854: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82347858: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 8234785C: 48E633B9  bl 0x831aac14
	ctx.lr = 0x82347860;
	sub_831AA9A0(ctx, base);
	// 82347860: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82347864: D021013C  stfs f1, 0x13c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82347868: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234786C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82347870: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82347874: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82347878: 48E0CD89  bl 0x83154600
	ctx.lr = 0x8234787C;
	sub_83154600(ctx, base);
	// 8234787C: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82347880: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82347BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82347BA8 size=8872
    let mut pc: u32 = 0x82347BA8;
    'dispatch: loop {
        match pc {
            0x82347BA8 => {
    //   block [0x82347BA8..0x82349E50)
	// 82347BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82347BAC: 48E60585  bl 0x831a8130
	ctx.lr = 0x82347BB0;
	sub_831A8130(ctx, base);
	// 82347BB0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82347BB4: 48E60EC1  bl 0x831a8a74
	ctx.lr = 0x82347BB8;
	sub_831A8A40(ctx, base);
	// 82347BB8: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82349E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82349E50 size=1000
    let mut pc: u32 = 0x82349E50;
    'dispatch: loop {
        match pc {
            0x82349E50 => {
    //   block [0x82349E50..0x8234A238)
	// 82349E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82349E54: 48E5E30D  bl 0x831a8160
	ctx.lr = 0x82349E58;
	sub_831A8130(ctx, base);
	// 82349E58: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82349E5C: 48E5EC19  bl 0x831a8a74
	ctx.lr = 0x82349E60;
	sub_831A8A40(ctx, base);
	// 82349E60: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A238 size=196
    let mut pc: u32 = 0x8234A238;
    'dispatch: loop {
        match pc {
            0x8234A238 => {
    //   block [0x8234A238..0x8234A2FC)
	// 8234A238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234A240: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234A244: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234A248: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A24C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234A250: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A254: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8234A258: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234A25C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A260: 4BF766D9  bl 0x822c0938
	ctx.lr = 0x8234A264;
	sub_822C0938(ctx, base);
	// 8234A264: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A268: 41820028  beq 0x8234a290
	if ctx.cr[0].eq {
	pc = 0x8234A290; continue 'dispatch;
	}
	// 8234A26C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A270: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234A274: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8234A278: 392B29A0  addi r9, r11, 0x29a0
	ctx.r[9].s64 = ctx.r[11].s64 + 10656;
	// 8234A27C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234A280: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234A284: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234A288: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234A28C: 48000008  b 0x8234a294
	pc = 0x8234A294; continue 'dispatch;
	// 8234A290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A294: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A29C: 409A0044  bne cr6, 0x8234a2e0
	if !ctx.cr[6].eq {
	pc = 0x8234A2E0; continue 'dispatch;
	}
	// 8234A2A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234A2A4: 419A001C  beq cr6, 0x8234a2c0
	if ctx.cr[6].eq {
	pc = 0x8234A2C0; continue 'dispatch;
	}
	// 8234A2A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A2AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234A2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234A2B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A2B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234A2BC: 4E800421  bctrl
	ctx.lr = 0x8234A2C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234A2C0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234A2C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234A2C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234A2CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8234A2D0: 816BA8B8  lwz r11, -0x5748(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22344 as u32) ) } as u64;
	// 8234A2D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8234A2D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234A2DC: 4BF75D25  bl 0x822c0000
	ctx.lr = 0x8234A2E0;
	sub_822C0000(ctx, base);
	// 8234A2E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A2E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A2E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234A2EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234A2F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234A2F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234A2F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A300 size=196
    let mut pc: u32 = 0x8234A300;
    'dispatch: loop {
        match pc {
            0x8234A300 => {
    //   block [0x8234A300..0x8234A3C4)
	// 8234A300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234A308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234A30C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234A310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A314: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234A318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A31C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8234A320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234A324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A328: 4BF76611  bl 0x822c0938
	ctx.lr = 0x8234A32C;
	sub_822C0938(ctx, base);
	// 8234A32C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A330: 41820028  beq 0x8234a358
	if ctx.cr[0].eq {
	pc = 0x8234A358; continue 'dispatch;
	}
	// 8234A334: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A338: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234A33C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8234A340: 392B29B4  addi r9, r11, 0x29b4
	ctx.r[9].s64 = ctx.r[11].s64 + 10676;
	// 8234A344: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234A348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234A34C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234A350: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234A354: 48000008  b 0x8234a35c
	pc = 0x8234A35C; continue 'dispatch;
	// 8234A358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A35C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A364: 409A0044  bne cr6, 0x8234a3a8
	if !ctx.cr[6].eq {
	pc = 0x8234A3A8; continue 'dispatch;
	}
	// 8234A368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234A36C: 419A001C  beq cr6, 0x8234a388
	if ctx.cr[6].eq {
	pc = 0x8234A388; continue 'dispatch;
	}
	// 8234A370: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A374: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234A378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234A37C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A380: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234A384: 4E800421  bctrl
	ctx.lr = 0x8234A388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234A388: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234A38C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234A390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234A394: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8234A398: 816BA8B8  lwz r11, -0x5748(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22344 as u32) ) } as u64;
	// 8234A39C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8234A3A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234A3A4: 4BF75C5D  bl 0x822c0000
	ctx.lr = 0x8234A3A8;
	sub_822C0000(ctx, base);
	// 8234A3A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A3AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A3B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234A3B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234A3B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234A3BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234A3C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A3C8 size=196
    let mut pc: u32 = 0x8234A3C8;
    'dispatch: loop {
        match pc {
            0x8234A3C8 => {
    //   block [0x8234A3C8..0x8234A48C)
	// 8234A3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234A3D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234A3D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234A3D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A3DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234A3E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A3E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8234A3E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234A3EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A3F0: 4BF76549  bl 0x822c0938
	ctx.lr = 0x8234A3F4;
	sub_822C0938(ctx, base);
	// 8234A3F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A3F8: 41820028  beq 0x8234a420
	if ctx.cr[0].eq {
	pc = 0x8234A420; continue 'dispatch;
	}
	// 8234A3FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A400: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234A404: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8234A408: 392B29C8  addi r9, r11, 0x29c8
	ctx.r[9].s64 = ctx.r[11].s64 + 10696;
	// 8234A40C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234A410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234A414: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234A418: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234A41C: 48000008  b 0x8234a424
	pc = 0x8234A424; continue 'dispatch;
	// 8234A420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A424: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A42C: 409A0044  bne cr6, 0x8234a470
	if !ctx.cr[6].eq {
	pc = 0x8234A470; continue 'dispatch;
	}
	// 8234A430: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234A434: 419A001C  beq cr6, 0x8234a450
	if ctx.cr[6].eq {
	pc = 0x8234A450; continue 'dispatch;
	}
	// 8234A438: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A43C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234A440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234A444: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234A44C: 4E800421  bctrl
	ctx.lr = 0x8234A450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234A450: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234A454: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234A458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234A45C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8234A460: 816BA8B8  lwz r11, -0x5748(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22344 as u32) ) } as u64;
	// 8234A464: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8234A468: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234A46C: 4BF75B95  bl 0x822c0000
	ctx.lr = 0x8234A470;
	sub_822C0000(ctx, base);
	// 8234A470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234A47C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234A480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234A484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234A488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A490 size=196
    let mut pc: u32 = 0x8234A490;
    'dispatch: loop {
        match pc {
            0x8234A490 => {
    //   block [0x8234A490..0x8234A554)
	// 8234A490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234A498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234A49C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234A4A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A4A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234A4A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A4AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8234A4B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234A4B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A4B8: 4BF76481  bl 0x822c0938
	ctx.lr = 0x8234A4BC;
	sub_822C0938(ctx, base);
	// 8234A4BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A4C0: 41820028  beq 0x8234a4e8
	if ctx.cr[0].eq {
	pc = 0x8234A4E8; continue 'dispatch;
	}
	// 8234A4C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A4C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234A4CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8234A4D0: 392B29DC  addi r9, r11, 0x29dc
	ctx.r[9].s64 = ctx.r[11].s64 + 10716;
	// 8234A4D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234A4D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234A4DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234A4E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234A4E4: 48000008  b 0x8234a4ec
	pc = 0x8234A4EC; continue 'dispatch;
	// 8234A4E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A4EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A4F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A4F4: 409A0044  bne cr6, 0x8234a538
	if !ctx.cr[6].eq {
	pc = 0x8234A538; continue 'dispatch;
	}
	// 8234A4F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234A4FC: 419A001C  beq cr6, 0x8234a518
	if ctx.cr[6].eq {
	pc = 0x8234A518; continue 'dispatch;
	}
	// 8234A500: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A504: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234A508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234A50C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234A514: 4E800421  bctrl
	ctx.lr = 0x8234A518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234A518: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234A51C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234A520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234A524: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8234A528: 816BA8B8  lwz r11, -0x5748(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22344 as u32) ) } as u64;
	// 8234A52C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8234A530: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234A534: 4BF75ACD  bl 0x822c0000
	ctx.lr = 0x8234A538;
	sub_822C0000(ctx, base);
	// 8234A538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A53C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234A544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234A548: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234A54C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234A550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A558 size=196
    let mut pc: u32 = 0x8234A558;
    'dispatch: loop {
        match pc {
            0x8234A558 => {
    //   block [0x8234A558..0x8234A61C)
	// 8234A558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234A560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234A564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234A568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A56C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234A570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A574: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8234A578: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234A57C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A580: 4BF763B9  bl 0x822c0938
	ctx.lr = 0x8234A584;
	sub_822C0938(ctx, base);
	// 8234A584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A588: 41820028  beq 0x8234a5b0
	if ctx.cr[0].eq {
	pc = 0x8234A5B0; continue 'dispatch;
	}
	// 8234A58C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A590: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234A594: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8234A598: 392B29F0  addi r9, r11, 0x29f0
	ctx.r[9].s64 = ctx.r[11].s64 + 10736;
	// 8234A59C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234A5A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234A5A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234A5A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234A5AC: 48000008  b 0x8234a5b4
	pc = 0x8234A5B4; continue 'dispatch;
	// 8234A5B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234A5B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A5BC: 409A0044  bne cr6, 0x8234a600
	if !ctx.cr[6].eq {
	pc = 0x8234A600; continue 'dispatch;
	}
	// 8234A5C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234A5C4: 419A001C  beq cr6, 0x8234a5e0
	if ctx.cr[6].eq {
	pc = 0x8234A5E0; continue 'dispatch;
	}
	// 8234A5C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A5CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234A5D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234A5D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A5D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234A5DC: 4E800421  bctrl
	ctx.lr = 0x8234A5E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234A5E0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234A5E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234A5E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234A5EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8234A5F0: 816BA8B8  lwz r11, -0x5748(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22344 as u32) ) } as u64;
	// 8234A5F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8234A5F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234A5FC: 4BF75A05  bl 0x822c0000
	ctx.lr = 0x8234A600;
	sub_822C0000(ctx, base);
	// 8234A600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A604: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234A60C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234A610: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234A614: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234A618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234A620 size=156
    let mut pc: u32 = 0x8234A620;
    'dispatch: loop {
        match pc {
            0x8234A620 => {
    //   block [0x8234A620..0x8234A6BC)
	// 8234A620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A624: 48E5DB49  bl 0x831a816c
	ctx.lr = 0x8234A628;
	sub_831A8130(ctx, base);
	// 8234A628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A62C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234A630: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8234A634: 3BFE0094  addi r31, r30, 0x94
	ctx.r[31].s64 = ctx.r[30].s64 + 148;
	// 8234A638: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 8234A63C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A640: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8234A644: 419A0070  beq cr6, 0x8234a6b4
	if ctx.cr[6].eq {
	pc = 0x8234A6B4; continue 'dispatch;
	}
	// 8234A648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A64C: 419A0028  beq cr6, 0x8234a674
	if ctx.cr[6].eq {
	pc = 0x8234A674; continue 'dispatch;
	}
	// 8234A650: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234A654: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8234A658: 419A001C  beq cr6, 0x8234a674
	if ctx.cr[6].eq {
	pc = 0x8234A674; continue 'dispatch;
	}
	// 8234A65C: C03E009C  lfs f1, 0x9c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234A660: 48B80EC1  bl 0x82ecb520
	ctx.lr = 0x8234A664;
	sub_82ECB520(ctx, base);
	// 8234A664: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A668: C01E00A0  lfs f0, 0xa0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234A66C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234A670: D00B0188  stfs f0, 0x188(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 8234A674: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A678: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 8234A67C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8234A680: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A684: 4BF79DDD  bl 0x822c4460
	ctx.lr = 0x8234A688;
	sub_822C4460(ctx, base);
	// 8234A688: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234A68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A690: 419A0024  beq cr6, 0x8234a6b4
	if ctx.cr[6].eq {
	pc = 0x8234A6B4; continue 'dispatch;
	}
	// 8234A694: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234A698: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8234A69C: 419A0018  beq cr6, 0x8234a6b4
	if ctx.cr[6].eq {
	pc = 0x8234A6B4; continue 'dispatch;
	}
	// 8234A6A0: C00A0084  lfs f0, 0x84(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234A6A4: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8234A6A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234A6AC: C00B0188  lfs f0, 0x188(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234A6B0: D01E00A0  stfs f0, 0xa0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8234A6B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A6B8: 48E5DB04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A6C0 size=524
    let mut pc: u32 = 0x8234A6C0;
    'dispatch: loop {
        match pc {
            0x8234A6C0 => {
    //   block [0x8234A6C0..0x8234A8CC)
	// 8234A6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A6C4: 48E5DA95  bl 0x831a8158
	ctx.lr = 0x8234A6C8;
	sub_831A8130(ctx, base);
	// 8234A6C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A6CC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8234A6D0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8234A6D4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8234A6D8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8234A6DC: 486C6195  bl 0x82a10870
	ctx.lr = 0x8234A6E0;
	sub_82A10870(ctx, base);
	// 8234A6E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A6E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8234A6E8: 3BCB2A00  addi r30, r11, 0x2a00
	ctx.r[30].s64 = ctx.r[11].s64 + 10752;
	// 8234A6EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234A6F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234A6F4: 38A000C1  li r5, 0xc1
	ctx.r[5].s64 = 193;
	// 8234A6F8: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 8234A6FC: 48AA7CED  bl 0x82df23e8
	ctx.lr = 0x8234A700;
	sub_82DF23E8(ctx, base);
	// 8234A700: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8234A704: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A708: 41820014  beq 0x8234a71c
	if ctx.cr[0].eq {
	pc = 0x8234A71C; continue 'dispatch;
	}
	// 8234A70C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A710: 4880E9C9  bl 0x82b590d8
	ctx.lr = 0x8234A714;
	sub_82B590D8(ctx, base);
	// 8234A714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234A718: 48000008  b 0x8234a720
	pc = 0x8234A720; continue 'dispatch;
	// 8234A71C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 8234A720: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8234A724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A728: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234A72C: 4BFFFB0D  bl 0x8234a238
	ctx.lr = 0x8234A730;
	sub_8234A238(ctx, base);
	// 8234A730: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234A734: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A738: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234A73C: 4BF758C5  bl 0x822c0000
	ctx.lr = 0x8234A740;
	sub_822C0000(ctx, base);
	// 8234A740: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8234A744: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8234A748: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8234A74C: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 8234A750: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8234A754: 419A0024  beq cr6, 0x8234a778
	if ctx.cr[6].eq {
	pc = 0x8234A778; continue 'dispatch;
	}
	// 8234A758: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 8234A75C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234A760: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234A764: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234A768: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234A76C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234A770: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234A774: 4082FFE8  bne 0x8234a75c
	if !ctx.cr[0].eq {
	pc = 0x8234A75C; continue 'dispatch;
	}
	// 8234A778: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234A77C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8234A780: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8234A784: 38A000C2  li r5, 0xc2
	ctx.r[5].s64 = 194;
	// 8234A788: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8234A78C: 4BFBD6AD  bl 0x82307e38
	ctx.lr = 0x8234A790;
	sub_82307E38(ctx, base);
	// 8234A790: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234A794: 41820114  beq 0x8234a8a8
	if ctx.cr[0].eq {
	pc = 0x8234A8A8; continue 'dispatch;
	}
	// 8234A798: 897F0020  lbz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8234A79C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A7A0: 41820108  beq 0x8234a8a8
	if ctx.cr[0].eq {
	pc = 0x8234A8A8; continue 'dispatch;
	}
	// 8234A7A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234A7A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234A7AC: 38A000C4  li r5, 0xc4
	ctx.r[5].s64 = 196;
	// 8234A7B0: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 8234A7B4: 48AA7C35  bl 0x82df23e8
	ctx.lr = 0x8234A7B8;
	sub_82DF23E8(ctx, base);
	// 8234A7B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234A7BC: 41820014  beq 0x8234a7d0
	if ctx.cr[0].eq {
	pc = 0x8234A7D0; continue 'dispatch;
	}
	// 8234A7C0: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8234A7C4: 4880E96D  bl 0x82b59130
	ctx.lr = 0x8234A7C8;
	sub_82B59130(ctx, base);
	// 8234A7C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234A7CC: 48000008  b 0x8234a7d4
	pc = 0x8234A7D4; continue 'dispatch;
	// 8234A7D0: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 8234A7D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8234A7D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A7DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234A7E0: 4BFFFB21  bl 0x8234a300
	ctx.lr = 0x8234A7E4;
	sub_8234A300(ctx, base);
	// 8234A7E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234A7E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A7EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234A7F0: 4BF75811  bl 0x822c0000
	ctx.lr = 0x8234A7F4;
	sub_822C0000(ctx, base);
	// 8234A7F4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8234A7F8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8234A7FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8234A800: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8234A804: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8234A808: 419A0024  beq cr6, 0x8234a82c
	if ctx.cr[6].eq {
	pc = 0x8234A82C; continue 'dispatch;
	}
	// 8234A80C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8234A810: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234A814: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234A818: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234A81C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234A820: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234A824: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234A828: 4082FFE8  bne 0x8234a810
	if !ctx.cr[0].eq {
	pc = 0x8234A810; continue 'dispatch;
	}
	// 8234A82C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234A830: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8234A834: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8234A838: 38A000C5  li r5, 0xc5
	ctx.r[5].s64 = 197;
	// 8234A83C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8234A840: 4BFBD5F9  bl 0x82307e38
	ctx.lr = 0x8234A844;
	sub_82307E38(ctx, base);
	// 8234A844: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234A848: 41820050  beq 0x8234a898
	if ctx.cr[0].eq {
	pc = 0x8234A898; continue 'dispatch;
	}
	// 8234A84C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8234A850: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A854: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8234A858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234A85C: 917A0004  stw r11, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8234A860: 419A0024  beq cr6, 0x8234a884
	if ctx.cr[6].eq {
	pc = 0x8234A884; continue 'dispatch;
	}
	// 8234A864: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8234A868: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234A86C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234A870: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234A874: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234A878: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234A87C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234A880: 4082FFE8  bne 0x8234a868
	if !ctx.cr[0].eq {
	pc = 0x8234A868; continue 'dispatch;
	}
	// 8234A884: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8234A888: 419A0028  beq cr6, 0x8234a8b0
	if ctx.cr[6].eq {
	pc = 0x8234A8B0; continue 'dispatch;
	}
	// 8234A88C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234A890: 4BF76001  bl 0x822c0890
	ctx.lr = 0x8234A894;
	sub_822C0890(ctx, base);
	// 8234A894: 4800001C  b 0x8234a8b0
	pc = 0x8234A8B0; continue 'dispatch;
	// 8234A898: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8234A89C: 419A000C  beq cr6, 0x8234a8a8
	if ctx.cr[6].eq {
	pc = 0x8234A8A8; continue 'dispatch;
	}
	// 8234A8A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234A8A4: 4BF75FED  bl 0x822c0890
	ctx.lr = 0x8234A8A8;
	sub_822C0890(ctx, base);
	// 8234A8A8: 931A0000  stw r24, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 8234A8AC: 931A0004  stw r24, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 8234A8B0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8234A8B4: 419A000C  beq cr6, 0x8234a8c0
	if ctx.cr[6].eq {
	pc = 0x8234A8C0; continue 'dispatch;
	}
	// 8234A8B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8234A8BC: 4BF75FD5  bl 0x822c0890
	ctx.lr = 0x8234A8C0;
	sub_822C0890(ctx, base);
	// 8234A8C0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8234A8C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8234A8C8: 48E5D8E0  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A8D0 size=124
    let mut pc: u32 = 0x8234A8D0;
    'dispatch: loop {
        match pc {
            0x8234A8D0 => {
    //   block [0x8234A8D0..0x8234A94C)
	// 8234A8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A8D4: 48E5D899  bl 0x831a816c
	ctx.lr = 0x8234A8D8;
	sub_831A8130(ctx, base);
	// 8234A8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A8DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A8E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234A8E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234A8E8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8234A8EC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8234A8F0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8234A8F4: 48AA7AF5  bl 0x82df23e8
	ctx.lr = 0x8234A8F8;
	sub_82DF23E8(ctx, base);
	// 8234A8F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8234A8FC: 4182001C  beq 0x8234a918
	if ctx.cr[0].eq {
	pc = 0x8234A918; continue 'dispatch;
	}
	// 8234A900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234A904: 48B0ED7D  bl 0x82e59680
	ctx.lr = 0x8234A908;
	sub_82E59680(ctx, base);
	// 8234A908: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A90C: 396B2990  addi r11, r11, 0x2990
	ctx.r[11].s64 = ctx.r[11].s64 + 10640;
	// 8234A910: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A914: 48000008  b 0x8234a91c
	pc = 0x8234A91C; continue 'dispatch;
	// 8234A918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8234A91C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8234A920: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8234A924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A92C: 4BFFFA9D  bl 0x8234a3c8
	ctx.lr = 0x8234A930;
	sub_8234A3C8(ctx, base);
	// 8234A930: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234A934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A93C: 4BF756C5  bl 0x822c0000
	ctx.lr = 0x8234A940;
	sub_822C0000(ctx, base);
	// 8234A940: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234A944: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A948: 48E5D874  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A950 size=124
    let mut pc: u32 = 0x8234A950;
    'dispatch: loop {
        match pc {
            0x8234A950 => {
    //   block [0x8234A950..0x8234A9CC)
	// 8234A950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A954: 48E5D819  bl 0x831a816c
	ctx.lr = 0x8234A958;
	sub_831A8130(ctx, base);
	// 8234A958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A95C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A960: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234A964: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234A968: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8234A96C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8234A970: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8234A974: 48AA7A75  bl 0x82df23e8
	ctx.lr = 0x8234A978;
	sub_82DF23E8(ctx, base);
	// 8234A978: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8234A97C: 4182001C  beq 0x8234a998
	if ctx.cr[0].eq {
	pc = 0x8234A998; continue 'dispatch;
	}
	// 8234A980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234A984: 48B0ECFD  bl 0x82e59680
	ctx.lr = 0x8234A988;
	sub_82E59680(ctx, base);
	// 8234A988: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A98C: 396B2998  addi r11, r11, 0x2998
	ctx.r[11].s64 = ctx.r[11].s64 + 10648;
	// 8234A990: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234A994: 48000008  b 0x8234a99c
	pc = 0x8234A99C; continue 'dispatch;
	// 8234A998: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8234A99C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8234A9A0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8234A9A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A9A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A9AC: 4BFFFAE5  bl 0x8234a490
	ctx.lr = 0x8234A9B0;
	sub_8234A490(ctx, base);
	// 8234A9B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234A9B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234A9B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234A9BC: 4BF75645  bl 0x822c0000
	ctx.lr = 0x8234A9C0;
	sub_822C0000(ctx, base);
	// 8234A9C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234A9C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234A9C8: 48E5D7F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234A9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234A9D0 size=120
    let mut pc: u32 = 0x8234A9D0;
    'dispatch: loop {
        match pc {
            0x8234A9D0 => {
    //   block [0x8234A9D0..0x8234AA48)
	// 8234A9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234A9D4: 48E5D799  bl 0x831a816c
	ctx.lr = 0x8234A9D8;
	sub_831A8130(ctx, base);
	// 8234A9D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234A9DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234A9E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234A9E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234A9E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234A9EC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8234A9F0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8234A9F4: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8234A9F8: 48AA79F1  bl 0x82df23e8
	ctx.lr = 0x8234A9FC;
	sub_82DF23E8(ctx, base);
	// 8234A9FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234AA00: 41820014  beq 0x8234aa14
	if ctx.cr[0].eq {
	pc = 0x8234AA14; continue 'dispatch;
	}
	// 8234AA04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234AA08: 48807B71  bl 0x82b52578
	ctx.lr = 0x8234AA0C;
	sub_82B52578(ctx, base);
	// 8234AA0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234AA10: 48000008  b 0x8234aa18
	pc = 0x8234AA18; continue 'dispatch;
	// 8234AA14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8234AA18: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8234AA1C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8234AA20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234AA24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234AA28: 4BFFFB31  bl 0x8234a558
	ctx.lr = 0x8234AA2C;
	sub_8234A558(ctx, base);
	// 8234AA2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234AA30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234AA34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234AA38: 4BF755C9  bl 0x822c0000
	ctx.lr = 0x8234AA3C;
	sub_822C0000(ctx, base);
	// 8234AA3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234AA40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234AA44: 48E5D778  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234AA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234AA48 size=1024
    let mut pc: u32 = 0x8234AA48;
    'dispatch: loop {
        match pc {
            0x8234AA48 => {
    //   block [0x8234AA48..0x8234AE48)
	// 8234AA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234AA4C: 48E5D71D  bl 0x831a8168
	ctx.lr = 0x8234AA50;
	sub_831A8130(ctx, base);
	// 8234AA50: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8234AA54: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8234AA58: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8234AA5C: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234AA60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234AA64: 486C5E0D  bl 0x82a10870
	ctx.lr = 0x8234AA68;
	sub_82A10870(ctx, base);
	// 8234AA68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234AA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234AA70: 4BFFB679  bl 0x823460e8
	ctx.lr = 0x8234AA74;
	sub_823460E8(ctx, base);
	// 8234AA74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234AA78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234AA7C: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 8234AA80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234AA84: C3AA08A4  lfs f29, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234AA88: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8234AA8C: 4BFC8565  bl 0x82312ff0
	ctx.lr = 0x8234AA90;
	sub_82312FF0(ctx, base);
	// 8234AA90: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234AA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AA98: 388B2A98  addi r4, r11, 0x2a98
	ctx.r[4].s64 = ctx.r[11].s64 + 10904;
	// 8234AA9C: 48AA8F6D  bl 0x82df3a08
	ctx.lr = 0x8234AAA0;
	sub_82DF3A08(ctx, base);
	// 8234AAA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234AAA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8234AAA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234AAAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8234AAB0: 4BFBD421  bl 0x82307ed0
	ctx.lr = 0x8234AAB4;
	sub_82307ED0(ctx, base);
	// 8234AAB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AAB8: 48AA8971  bl 0x82df3428
	ctx.lr = 0x8234AABC;
	sub_82DF3428(ctx, base);
	// 8234AABC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234AAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234AAC4: 419A0120  beq cr6, 0x8234abe4
	if ctx.cr[6].eq {
	pc = 0x8234ABE4; continue 'dispatch;
	}
	// 8234AAC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234AACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AAD0: 388B2A88  addi r4, r11, 0x2a88
	ctx.r[4].s64 = ctx.r[11].s64 + 10888;
	// 8234AAD4: 48AA8F35  bl 0x82df3a08
	ctx.lr = 0x8234AAD8;
	sub_82DF3A08(ctx, base);
	// 8234AAD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234AADC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8234AAE0: 3D208326  lis r9, -0x7cda
	ctx.r[9].s64 = -2094661632;
	// 8234AAE4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8234AAE8: 3889A8AC  addi r4, r9, -0x5754
	ctx.r[4].s64 = ctx.r[9].s64 + -22356;
	// 8234AAEC: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234AAF0: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8234AAF4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8234AAF8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8234AAFC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234AB00: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234AB04: 482586AD  bl 0x825a31b0
	ctx.lr = 0x8234AB08;
	sub_825A31B0(ctx, base);
	// 8234AB08: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234AB0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234AB10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234AB14: 48258165  bl 0x825a2c78
	ctx.lr = 0x8234AB18;
	sub_825A2C78(ctx, base);
	// 8234AB18: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 8234AB1C: 48AA890D  bl 0x82df3428
	ctx.lr = 0x8234AB20;
	sub_82DF3428(ctx, base);
	// 8234AB20: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 8234AB24: 4BF7E195  bl 0x822c8cb8
	ctx.lr = 0x8234AB28;
	sub_822C8CB8(ctx, base);
	// 8234AB28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AB2C: 48AA88FD  bl 0x82df3428
	ctx.lr = 0x8234AB30;
	sub_82DF3428(ctx, base);
	// 8234AB30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234AB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AB38: 388B2A74  addi r4, r11, 0x2a74
	ctx.r[4].s64 = ctx.r[11].s64 + 10868;
	// 8234AB3C: 48AA8ECD  bl 0x82df3a08
	ctx.lr = 0x8234AB40;
	sub_82DF3A08(ctx, base);
	// 8234AB40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234AB44: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8234AB48: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8234AB4C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 8234AB50: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8234AB54: 388AA8B0  addi r4, r10, -0x5750
	ctx.r[4].s64 = ctx.r[10].s64 + -22352;
	// 8234AB58: C06B964C  lfs f3, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8234AB5C: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234AB60: 48258651  bl 0x825a31b0
	ctx.lr = 0x8234AB64;
	sub_825A31B0(ctx, base);
	// 8234AB64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234AB68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234AB6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234AB70: 48258109  bl 0x825a2c78
	ctx.lr = 0x8234AB74;
	sub_825A2C78(ctx, base);
	// 8234AB74: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 8234AB78: 48AA88B1  bl 0x82df3428
	ctx.lr = 0x8234AB7C;
	sub_82DF3428(ctx, base);
	// 8234AB7C: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 8234AB80: 4BF7E139  bl 0x822c8cb8
	ctx.lr = 0x8234AB84;
	sub_822C8CB8(ctx, base);
	// 8234AB84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AB88: 48AA88A1  bl 0x82df3428
	ctx.lr = 0x8234AB8C;
	sub_82DF3428(ctx, base);
	// 8234AB8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234AB90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AB94: 388B2A60  addi r4, r11, 0x2a60
	ctx.r[4].s64 = ctx.r[11].s64 + 10848;
	// 8234AB98: 48AA8E71  bl 0x82df3a08
	ctx.lr = 0x8234AB9C;
	sub_82DF3A08(ctx, base);
	// 8234AB9C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234ABA0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 8234ABA4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8234ABA8: 388BA8B4  addi r4, r11, -0x574c
	ctx.r[4].s64 = ctx.r[11].s64 + -22348;
	// 8234ABAC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8234ABB0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8234ABB4: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234ABB8: 482585F9  bl 0x825a31b0
	ctx.lr = 0x8234ABBC;
	sub_825A31B0(ctx, base);
	// 8234ABBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234ABC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234ABC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234ABC8: 482580B1  bl 0x825a2c78
	ctx.lr = 0x8234ABCC;
	sub_825A2C78(ctx, base);
	// 8234ABCC: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 8234ABD0: 48AA8859  bl 0x82df3428
	ctx.lr = 0x8234ABD4;
	sub_82DF3428(ctx, base);
	// 8234ABD4: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 8234ABD8: 4BF7E0E1  bl 0x822c8cb8
	ctx.lr = 0x8234ABDC;
	sub_822C8CB8(ctx, base);
	// 8234ABDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234ABE0: 48AA8849  bl 0x82df3428
	ctx.lr = 0x8234ABE4;
	sub_82DF3428(ctx, base);
	// 8234ABE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234ABE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234ABEC: 4BFC9FDD  bl 0x82314bc8
	ctx.lr = 0x8234ABF0;
	sub_82314BC8(ctx, base);
	// 8234ABF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234ABF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8234ABF8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8234ABFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234AC00: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234AC04: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234AC08: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC0C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234AC10: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC14: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234AC18: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC1C: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC20: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8234AC24: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8234AC28: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8234AC2C: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8234AC30: 4BFCC679  bl 0x823172a8
	ctx.lr = 0x8234AC34;
	sub_823172A8(ctx, base);
	// 8234AC34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234AC38: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234AC3C: 4BFC9F8D  bl 0x82314bc8
	ctx.lr = 0x8234AC40;
	sub_82314BC8(ctx, base);
	// 8234AC40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234AC44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234AC48: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 8234AC4C: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234AC50: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234AC54: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC58: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234AC5C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC60: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234AC64: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC68: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234AC6C: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8234AC70: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8234AC74: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8234AC78: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8234AC7C: 48B0EAFD  bl 0x82e59778
	ctx.lr = 0x8234AC80;
	sub_82E59778(ctx, base);
	// 8234AC80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234AC84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8234AC88: 4BFCD921  bl 0x823185a8
	ctx.lr = 0x8234AC8C;
	sub_823185A8(ctx, base);
	// 8234AC8C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8234AC90: 41820194  beq 0x8234ae24
	if ctx.cr[0].eq {
	pc = 0x8234AE24; continue 'dispatch;
	}
	// 8234AC94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234AC98: 4848F339  bl 0x827d9fd0
	ctx.lr = 0x8234AC9C;
	sub_827D9FD0(ctx, base);
	// 8234AC9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234ACA0: 4182007C  beq 0x8234ad1c
	if ctx.cr[0].eq {
	pc = 0x8234AD1C; continue 'dispatch;
	}
	// 8234ACA4: 48CBE315  bl 0x83008fb8
	ctx.lr = 0x8234ACA8;
	sub_83008FB8(ctx, base);
	// 8234ACA8: 907F0090  stw r3, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 8234ACAC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8234ACB0: 4BFFFC21  bl 0x8234a8d0
	ctx.lr = 0x8234ACB4;
	sub_8234A8D0(ctx, base);
	// 8234ACB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234ACB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8234ACBC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234ACC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234ACC4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234ACC8: 419A0024  beq cr6, 0x8234acec
	if ctx.cr[6].eq {
	pc = 0x8234ACEC; continue 'dispatch;
	}
	// 8234ACCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8234ACD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234ACD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234ACD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234ACDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234ACE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234ACE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234ACE8: 4082FFE8  bne 0x8234acd0
	if !ctx.cr[0].eq {
	pc = 0x8234ACD0; continue 'dispatch;
	}
	// 8234ACEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234ACF0: 80DF0090  lwz r6, 0x90(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8234ACF4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8234ACF8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8234ACFC: 388B2A00  addi r4, r11, 0x2a00
	ctx.r[4].s64 = ctx.r[11].s64 + 10752;
	// 8234AD00: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 8234AD04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234AD08: 4BFBD181  bl 0x82307e88
	ctx.lr = 0x8234AD0C;
	sub_82307E88(ctx, base);
	// 8234AD0C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8234AD10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234AD14: 419A0008  beq cr6, 0x8234ad1c
	if ctx.cr[6].eq {
	pc = 0x8234AD1C; continue 'dispatch;
	}
	// 8234AD18: 4BF75B79  bl 0x822c0890
	ctx.lr = 0x8234AD1C;
	sub_822C0890(ctx, base);
	// 8234AD1C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8234AD20: 80BF0090  lwz r5, 0x90(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8234AD24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234AD28: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8234AD2C: 4BFFF995  bl 0x8234a6c0
	ctx.lr = 0x8234AD30;
	sub_8234A6C0(ctx, base);
	// 8234AD30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234AD34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234AD38: 4BFFF8E9  bl 0x8234a620
	ctx.lr = 0x8234AD3C;
	sub_8234A620(ctx, base);
	// 8234AD3C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8234AD40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234AD44: 419A0008  beq cr6, 0x8234ad4c
	if ctx.cr[6].eq {
	pc = 0x8234AD4C; continue 'dispatch;
	}
	// 8234AD48: 4BF75B49  bl 0x822c0890
	ctx.lr = 0x8234AD4C;
	sub_822C0890(ctx, base);
	// 8234AD4C: 83BF0094  lwz r29, 0x94(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 8234AD50: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8234AD54: 419A00D0  beq cr6, 0x8234ae24
	if ctx.cr[6].eq {
	pc = 0x8234AE24; continue 'dispatch;
	}
	// 8234AD58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234AD5C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234AD60: 4BFBAD11  bl 0x82305a70
	ctx.lr = 0x8234AD64;
	sub_82305A70(ctx, base);
	// 8234AD64: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234AD68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8234AD6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8234AD70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234AD74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8234AD78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234AD7C: 4E800421  bctrl
	ctx.lr = 0x8234AD80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234AD80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234AD84: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234AD88: 3BBF0070  addi r29, r31, 0x70
	ctx.r[29].s64 = ctx.r[31].s64 + 112;
	// 8234AD8C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8234AD90: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234AE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234AE48 size=1856
    let mut pc: u32 = 0x8234AE48;
    'dispatch: loop {
        match pc {
            0x8234AE48 => {
    //   block [0x8234AE48..0x8234B588)
	// 8234AE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234AE4C: 48E5D311  bl 0x831a815c
	ctx.lr = 0x8234AE50;
	sub_831A8130(ctx, base);
	// 8234AE50: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 8234AE54: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8234AE58: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8234AE5C: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234B588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234B588 size=224
    let mut pc: u32 = 0x8234B588;
    'dispatch: loop {
        match pc {
            0x8234B588 => {
    //   block [0x8234B588..0x8234B668)
	// 8234B588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234B58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234B590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234B594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234B598: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234B59C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234B5A0: 486C52D1  bl 0x82a10870
	ctx.lr = 0x8234B5A4;
	sub_82A10870(ctx, base);
	// 8234B5A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234B5A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234B5AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8234B5B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234B5B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234B5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234B5BC: 4BFFF065  bl 0x8234a620
	ctx.lr = 0x8234B5C0;
	sub_8234A620(ctx, base);
	// 8234B5C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234B5C4: 4BFC8D75  bl 0x82314338
	ctx.lr = 0x8234B5C8;
	sub_82314338(ctx, base);
	// 8234B5C8: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8234B5CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234B5D0: 419A0078  beq cr6, 0x8234b648
	if ctx.cr[6].eq {
	pc = 0x8234B648; continue 'dispatch;
	}
	// 8234B5D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8234B5D8: 4BFFF379  bl 0x8234a950
	ctx.lr = 0x8234B5DC;
	sub_8234A950(ctx, base);
	// 8234B5DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234B5E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8234B5E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234B5E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234B5EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234B5F0: 419A0024  beq cr6, 0x8234b614
	if ctx.cr[6].eq {
	pc = 0x8234B614; continue 'dispatch;
	}
	// 8234B5F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8234B5F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234B5FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234B600: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234B604: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234B608: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234B60C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234B610: 4082FFE8  bne 0x8234b5f8
	if !ctx.cr[0].eq {
	pc = 0x8234B5F8; continue 'dispatch;
	}
	// 8234B614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234B618: 80DF0090  lwz r6, 0x90(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8234B61C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234B620: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8234B624: 388A2A00  addi r4, r10, 0x2a00
	ctx.r[4].s64 = ctx.r[10].s64 + 10752;
	// 8234B628: 38A000B0  li r5, 0xb0
	ctx.r[5].s64 = 176;
	// 8234B62C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234B630: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234B634: 4BFBC855  bl 0x82307e88
	ctx.lr = 0x8234B638;
	sub_82307E88(ctx, base);
	// 8234B638: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8234B63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234B640: 419A0008  beq cr6, 0x8234b648
	if ctx.cr[6].eq {
	pc = 0x8234B648; continue 'dispatch;
	}
	// 8234B644: 4BF7524D  bl 0x822c0890
	ctx.lr = 0x8234B648;
	sub_822C0890(ctx, base);
	// 8234B648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234B64C: 4BFFAA85  bl 0x823460d0
	ctx.lr = 0x8234B650;
	sub_823460D0(ctx, base);
	// 8234B650: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8234B654: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234B658: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234B65C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234B660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234B664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234B668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234B668 size=60
    let mut pc: u32 = 0x8234B668;
    'dispatch: loop {
        match pc {
            0x8234B668 => {
    //   block [0x8234B668..0x8234B6A4)
	// 8234B668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234B66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234B670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234B674: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234B678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234B67C: 48D7C465  bl 0x830c7ae0
	ctx.lr = 0x8234B680;
	sub_830C7AE0(ctx, base);
	// 8234B680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234B684: 486C51ED  bl 0x82a10870
	ctx.lr = 0x8234B688;
	sub_82A10870(ctx, base);
	// 8234B688: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234B68C: 4BFBA4D5  bl 0x82305b60
	ctx.lr = 0x8234B690;
	sub_82305B60(ctx, base);
	// 8234B690: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234B694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234B698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234B69C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234B6A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234B6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234B6A8 size=860
    let mut pc: u32 = 0x8234B6A8;
    'dispatch: loop {
        match pc {
            0x8234B6A8 => {
    //   block [0x8234B6A8..0x8234BA04)
	// 8234B6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234B6AC: 48E5CABD  bl 0x831a8168
	ctx.lr = 0x8234B6B0;
	sub_831A8130(ctx, base);
	// 8234B6B0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8234B6B4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8234B6B8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234BA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234BA08 size=60
    let mut pc: u32 = 0x8234BA08;
    'dispatch: loop {
        match pc {
            0x8234BA08 => {
    //   block [0x8234BA08..0x8234BA44)
	// 8234BA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234BA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234BA10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234BA14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234BA18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234BA1C: 4BFFA79D  bl 0x823461b8
	ctx.lr = 0x8234BA20;
	sub_823461B8(ctx, base);
	// 8234BA20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234BA24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234BA28: 396B2B18  addi r11, r11, 0x2b18
	ctx.r[11].s64 = ctx.r[11].s64 + 11032;
	// 8234BA2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234BA30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234BA34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234BA38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234BA3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234BA40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234BA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234BA48 size=256
    let mut pc: u32 = 0x8234BA48;
    'dispatch: loop {
        match pc {
            0x8234BA48 => {
    //   block [0x8234BA48..0x8234BB48)
	// 8234BA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234BA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234BA50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234BA54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234BA58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234BA5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234BA60: 48D7C081  bl 0x830c7ae0
	ctx.lr = 0x8234BA64;
	sub_830C7AE0(ctx, base);
	// 8234BA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234BA68: 486C4E09  bl 0x82a10870
	ctx.lr = 0x8234BA6C;
	sub_82A10870(ctx, base);
	// 8234BA6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234BA70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234BA74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234BA78: 4BFCBE41  bl 0x823178b8
	ctx.lr = 0x8234BA7C;
	sub_823178B8(ctx, base);
	// 8234BA7C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8234BA80: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234BA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234BA88: 419A000C  beq cr6, 0x8234ba94
	if ctx.cr[6].eq {
	pc = 0x8234BA94; continue 'dispatch;
	}
	// 8234BA8C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8234BA90: 4BF74E01  bl 0x822c0890
	ctx.lr = 0x8234BA94;
	sub_822C0890(ctx, base);
	// 8234BA94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234BA98: 48AC6C79  bl 0x82e12710
	ctx.lr = 0x8234BA9C;
	sub_82E12710(ctx, base);
	// 8234BA9C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234BAA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234BAA4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8234BAA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234BAAC: 4E800421  bctrl
	ctx.lr = 0x8234BAB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234BAB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234BAB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234BAB8: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234BABC: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234BAC0: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234BAC4: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234BAC8: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234BACC: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8234BAD0: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8234BAD4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8234BAD8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234BADC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8234BAE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234BAE4: 4E800421  bctrl
	ctx.lr = 0x8234BAE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234BAE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234BAEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8234BAF0: 48B31319  bl 0x82e7ce08
	ctx.lr = 0x8234BAF4;
	sub_82E7CE08(ctx, base);
	// 8234BAF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234BAF8: 38C0002D  li r6, 0x2d
	ctx.r[6].s64 = 45;
	// 8234BAFC: 38AB2AB0  addi r5, r11, 0x2ab0
	ctx.r[5].s64 = ctx.r[11].s64 + 10928;
	// 8234BB00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8234BB04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234BB08: 4BFB9F61  bl 0x82305a68
	ctx.lr = 0x8234BB0C;
	sub_82305A68(ctx, base);
	// 8234BB0C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8234BB10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234BB14: 4BFB9F9D  bl 0x82305ab0
	ctx.lr = 0x8234BB18;
	sub_82305AB0(ctx, base);
	// 8234BB18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8234BB1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234BB20: 4BFBA041  bl 0x82305b60
	ctx.lr = 0x8234BB24;
	sub_82305B60(ctx, base);
	// 8234BB24: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8234BB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234BB2C: 4BFC81BD  bl 0x82313ce8
	ctx.lr = 0x8234BB30;
	sub_82313CE8(ctx, base);
	// 8234BB30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8234BB34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234BB38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234BB3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234BB40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234BB44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234BB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234BB48 size=80
    let mut pc: u32 = 0x8234BB48;
    'dispatch: loop {
        match pc {
            0x8234BB48 => {
    //   block [0x8234BB48..0x8234BB98)
	// 8234BB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234BB4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234BB50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234BB54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234BB58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234BB5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234BB60: 486C4D11  bl 0x82a10870
	ctx.lr = 0x8234BB64;
	sub_82A10870(ctx, base);
	// 8234BB64: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 8234BB68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234BB6C: 4BFC8195  bl 0x82313d00
	ctx.lr = 0x8234BB70;
	sub_82313D00(ctx, base);
	// 8234BB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234BB74: 4BFCBB25  bl 0x82317698
	ctx.lr = 0x8234BB78;
	sub_82317698(ctx, base);
	// 8234BB78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234BB7C: 4BFFA555  bl 0x823460d0
	ctx.lr = 0x8234BB80;
	sub_823460D0(ctx, base);
	// 8234BB80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234BB84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234BB88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234BB8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234BB90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234BB94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234BB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234BB98 size=1552
    let mut pc: u32 = 0x8234BB98;
    'dispatch: loop {
        match pc {
            0x8234BB98 => {
    //   block [0x8234BB98..0x8234C1A8)
	// 8234BB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234BB9C: 48E5C5D1  bl 0x831a816c
	ctx.lr = 0x8234BBA0;
	sub_831A8130(ctx, base);
	// 8234BBA0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8234BBA4: 48E5CED1  bl 0x831a8a74
	ctx.lr = 0x8234BBA8;
	sub_831A8A40(ctx, base);
	// 8234BBA8: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234C1A8 size=68
    let mut pc: u32 = 0x8234C1A8;
    'dispatch: loop {
        match pc {
            0x8234C1A8 => {
    //   block [0x8234C1A8..0x8234C1EC)
	// 8234C1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C1AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C1B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C1B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C1B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C1BC: 48B1076D  bl 0x82e5c928
	ctx.lr = 0x8234C1C0;
	sub_82E5C928(ctx, base);
	// 8234C1C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C1C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8234C1C8: 396B2BA8  addi r11, r11, 0x2ba8
	ctx.r[11].s64 = ctx.r[11].s64 + 11176;
	// 8234C1CC: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8234C1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C1D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234C1D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234C1DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234C1E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234C1E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234C1E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234C1F0 size=404
    let mut pc: u32 = 0x8234C1F0;
    'dispatch: loop {
        match pc {
            0x8234C1F0 => {
    //   block [0x8234C1F0..0x8234C384)
	// 8234C1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C1F4: 48E5BF79  bl 0x831a816c
	ctx.lr = 0x8234C1F8;
	sub_831A8130(ctx, base);
	// 8234C1F8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8234C1FC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8234C200: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C208: 486C4669  bl 0x82a10870
	ctx.lr = 0x8234C20C;
	sub_82A10870(ctx, base);
	// 8234C20C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C210: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234C214: 388B2BFC  addi r4, r11, 0x2bfc
	ctx.r[4].s64 = ctx.r[11].s64 + 11260;
	// 8234C218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234C21C: 48AA77ED  bl 0x82df3a08
	ctx.lr = 0x8234C220;
	sub_82DF3A08(ctx, base);
	// 8234C220: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234C224: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234C228: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8234C22C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8234C230: 4BFBBCA1  bl 0x82307ed0
	ctx.lr = 0x8234C234;
	sub_82307ED0(ctx, base);
	// 8234C234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234C238: 48AA71F1  bl 0x82df3428
	ctx.lr = 0x8234C23C;
	sub_82DF3428(ctx, base);
	// 8234C23C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234C240: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 8234C244: 4BFC7AB5  bl 0x82313cf8
	ctx.lr = 0x8234C248;
	sub_82313CF8(ctx, base);
	// 8234C248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234C24C: 4BFCB44D  bl 0x82317698
	ctx.lr = 0x8234C250;
	sub_82317698(ctx, base);
	// 8234C250: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234C254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234C258: 419A0104  beq cr6, 0x8234c35c
	if ctx.cr[6].eq {
	pc = 0x8234C35C; continue 'dispatch;
	}
	// 8234C25C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234C264: 388B2BF0  addi r4, r11, 0x2bf0
	ctx.r[4].s64 = ctx.r[11].s64 + 11248;
	// 8234C268: 48AA77A1  bl 0x82df3a08
	ctx.lr = 0x8234C26C;
	sub_82DF3A08(ctx, base);
	// 8234C26C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234C274: 388B2BE0  addi r4, r11, 0x2be0
	ctx.r[4].s64 = ctx.r[11].s64 + 11232;
	// 8234C278: 48AA7791  bl 0x82df3a08
	ctx.lr = 0x8234C27C;
	sub_82DF3A08(ctx, base);
	// 8234C27C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234C280: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8234C284: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8234C288: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234C28C: 3BCBAAE0  addi r30, r11, -0x5520
	ctx.r[30].s64 = ctx.r[11].s64 + -21792;
	// 8234C290: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8234C294: C3E99A8C  lfs f31, -0x6574(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234C298: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8234C29C: C3C808A4  lfs f30, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8234C2A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8234C2A4: C06A08A8  lfs f3, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8234C2A8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8234C2AC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8234C2B0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234C2B4: 48256FF5  bl 0x825a32a8
	ctx.lr = 0x8234C2B8;
	sub_825A32A8(ctx, base);
	// 8234C2B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234C2BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234C2C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234C2C4: 482569B5  bl 0x825a2c78
	ctx.lr = 0x8234C2C8;
	sub_825A2C78(ctx, base);
	// 8234C2C8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8234C2CC: 48AA715D  bl 0x82df3428
	ctx.lr = 0x8234C2D0;
	sub_82DF3428(ctx, base);
	// 8234C2D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8234C2D4: 4BF7C9E5  bl 0x822c8cb8
	ctx.lr = 0x8234C2D8;
	sub_822C8CB8(ctx, base);
	// 8234C2D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234C2DC: 48AA714D  bl 0x82df3428
	ctx.lr = 0x8234C2E0;
	sub_82DF3428(ctx, base);
	// 8234C2E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234C2E4: 48AA7145  bl 0x82df3428
	ctx.lr = 0x8234C2E8;
	sub_82DF3428(ctx, base);
	// 8234C2E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C2EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234C2F0: 388BEAD4  addi r4, r11, -0x152c
	ctx.r[4].s64 = ctx.r[11].s64 + -5420;
	// 8234C2F4: 48AA7715  bl 0x82df3a08
	ctx.lr = 0x8234C2F8;
	sub_82DF3A08(ctx, base);
	// 8234C2F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C2FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234C300: 388B2BCC  addi r4, r11, 0x2bcc
	ctx.r[4].s64 = ctx.r[11].s64 + 11212;
	// 8234C304: 48AA7705  bl 0x82df3a08
	ctx.lr = 0x8234C308;
	sub_82DF3A08(ctx, base);
	// 8234C308: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C30C: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 8234C310: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8234C314: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234C318: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8234C31C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234C320: C06B964C  lfs f3, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8234C324: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234C328: 48256F81  bl 0x825a32a8
	ctx.lr = 0x8234C32C;
	sub_825A32A8(ctx, base);
	// 8234C32C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234C330: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8234C334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234C338: 48256941  bl 0x825a2c78
	ctx.lr = 0x8234C33C;
	sub_825A2C78(ctx, base);
	// 8234C33C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8234C340: 48AA70E9  bl 0x82df3428
	ctx.lr = 0x8234C344;
	sub_82DF3428(ctx, base);
	// 8234C344: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8234C348: 4BF7C971  bl 0x822c8cb8
	ctx.lr = 0x8234C34C;
	sub_822C8CB8(ctx, base);
	// 8234C34C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234C350: 48AA70D9  bl 0x82df3428
	ctx.lr = 0x8234C354;
	sub_82DF3428(ctx, base);
	// 8234C354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234C358: 48AA70D1  bl 0x82df3428
	ctx.lr = 0x8234C35C;
	sub_82DF3428(ctx, base);
	// 8234C35C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C360: 4BFF9D89  bl 0x823460e8
	ctx.lr = 0x8234C364;
	sub_823460E8(ctx, base);
	// 8234C364: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8234C368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234C36C: 419A0008  beq cr6, 0x8234c374
	if ctx.cr[6].eq {
	pc = 0x8234C374; continue 'dispatch;
	}
	// 8234C370: 4BF74521  bl 0x822c0890
	ctx.lr = 0x8234C374;
	sub_822C0890(ctx, base);
	// 8234C374: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8234C378: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8234C37C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8234C380: 48E5BE3C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234C388 size=292
    let mut pc: u32 = 0x8234C388;
    'dispatch: loop {
        match pc {
            0x8234C388 => {
    //   block [0x8234C388..0x8234C4AC)
	// 8234C388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C38C: 48E5BDE1  bl 0x831a816c
	ctx.lr = 0x8234C390;
	sub_831A8130(ctx, base);
	// 8234C390: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C394: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234C398: 486C44D9  bl 0x82a10870
	ctx.lr = 0x8234C39C;
	sub_82A10870(ctx, base);
	// 8234C39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C3A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234C3A4: 48B0D3D5  bl 0x82e59778
	ctx.lr = 0x8234C3A8;
	sub_82E59778(ctx, base);
	// 8234C3A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234C3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C3B0: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8234C3B4: 4BFD47DD  bl 0x82320b90
	ctx.lr = 0x8234C3B8;
	sub_82320B90(ctx, base);
	// 8234C3B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234C3BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8234C3C0: 4BFCD8E9  bl 0x82319ca8
	ctx.lr = 0x8234C3C4;
	sub_82319CA8(ctx, base);
	// 8234C3C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234C3C8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8234C3CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234C3D0: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234C3D4: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C3D8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234C3DC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234C3E0: FD400050  fneg f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C3E4: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234C3E8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C3EC: C00A89AC  lfs f0, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234C3F0: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C3F4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8234C3F8: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234C3FC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8234C400: D1410068  stfs f10, 0x68(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8234C404: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8234C408: 48B0D371  bl 0x82e59778
	ctx.lr = 0x8234C40C;
	sub_82E59778(ctx, base);
	// 8234C40C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8234C410: D0210054  stfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8234C414: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8234C418: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 8234C41C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8234C420: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C424: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234C428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234C4B0 size=68
    let mut pc: u32 = 0x8234C4B0;
    'dispatch: loop {
        match pc {
            0x8234C4B0 => {
    //   block [0x8234C4B0..0x8234C4F4)
	// 8234C4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C4B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C4BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C4C4: 48B10465  bl 0x82e5c928
	ctx.lr = 0x8234C4C8;
	sub_82E5C928(ctx, base);
	// 8234C4C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C4CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8234C4D0: 396B2C70  addi r11, r11, 0x2c70
	ctx.r[11].s64 = ctx.r[11].s64 + 11376;
	// 8234C4D4: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8234C4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C4DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234C4E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234C4E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234C4E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234C4EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234C4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234C4F8 size=4
    let mut pc: u32 = 0x8234C4F8;
    'dispatch: loop {
        match pc {
            0x8234C4F8 => {
    //   block [0x8234C4F8..0x8234C4FC)
	// 8234C4F8: 48D7B5E8  b 0x830c7ae0
	sub_830C7AE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234C500 size=208
    let mut pc: u32 = 0x8234C500;
    'dispatch: loop {
        match pc {
            0x8234C500 => {
    //   block [0x8234C500..0x8234C5D0)
	// 8234C500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234C50C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C510: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C518: 486C4359  bl 0x82a10870
	ctx.lr = 0x8234C51C;
	sub_82A10870(ctx, base);
	// 8234C51C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234C520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C524: 48B0D255  bl 0x82e59778
	ctx.lr = 0x8234C528;
	sub_82E59778(ctx, base);
	// 8234C528: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234C52C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234C530: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8234C534: 4BFD465D  bl 0x82320b90
	ctx.lr = 0x8234C538;
	sub_82320B90(ctx, base);
	// 8234C538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234C53C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8234C540: 4BFCD769  bl 0x82319ca8
	ctx.lr = 0x8234C544;
	sub_82319CA8(ctx, base);
	// 8234C544: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234C548: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8234C54C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8234C550: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8234C554: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8234C558: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234C55C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C560: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234C564: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C568: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234C56C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C570: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234C574: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C578: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C57C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234C580: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8234C584: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8234C588: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8234C58C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234C590: C00989AC  lfs f0, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234C594: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8234C598: 13C04407  vcmpneb. (lvlx128) v30, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234C5D0 size=60
    let mut pc: u32 = 0x8234C5D0;
    'dispatch: loop {
        match pc {
            0x8234C5D0 => {
    //   block [0x8234C5D0..0x8234C60C)
	// 8234C5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C5D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C5D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C5DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C5E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C5E4: 4BFF9BD5  bl 0x823461b8
	ctx.lr = 0x8234C5E8;
	sub_823461B8(ctx, base);
	// 8234C5E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C5F0: 396B2C98  addi r11, r11, 0x2c98
	ctx.r[11].s64 = ctx.r[11].s64 + 11416;
	// 8234C5F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234C5F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234C5FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234C600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234C604: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234C608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234C610 size=80
    let mut pc: u32 = 0x8234C610;
    'dispatch: loop {
        match pc {
            0x8234C610 => {
    //   block [0x8234C610..0x8234C660)
	// 8234C610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C61C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C620: 48E07FE1  bl 0x83154600
	ctx.lr = 0x8234C624;
	sub_83154600(ctx, base);
	// 8234C624: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234C628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234C62C: 4BFCABBD  bl 0x823171e8
	ctx.lr = 0x8234C630;
	sub_823171E8(ctx, base);
	// 8234C630: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8234C634: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234C638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234C63C: 419A000C  beq cr6, 0x8234c648
	if ctx.cr[6].eq {
	pc = 0x8234C648; continue 'dispatch;
	}
	// 8234C640: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8234C644: 4BF7424D  bl 0x822c0890
	ctx.lr = 0x8234C648;
	sub_822C0890(ctx, base);
	// 8234C648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C64C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234C650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234C654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234C658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234C65C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234C660 size=64
    let mut pc: u32 = 0x8234C660;
    'dispatch: loop {
        match pc {
            0x8234C660 => {
    //   block [0x8234C660..0x8234C6A0)
	// 8234C660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C668: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C66C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C674: 48B0D0DD  bl 0x82e59750
	ctx.lr = 0x8234C678;
	sub_82E59750(ctx, base);
	// 8234C678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234C67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C680: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8234C684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234C688: 4E800421  bctrl
	ctx.lr = 0x8234C68C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234C68C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234C690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234C694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234C698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234C69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234C6A0 size=60
    let mut pc: u32 = 0x8234C6A0;
    'dispatch: loop {
        match pc {
            0x8234C6A0 => {
    //   block [0x8234C6A0..0x8234C6DC)
	// 8234C6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C6A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C6AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C6B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C6B4: 48B10275  bl 0x82e5c928
	ctx.lr = 0x8234C6B8;
	sub_82E5C928(ctx, base);
	// 8234C6B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C6BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C6C0: 396B2CC4  addi r11, r11, 0x2cc4
	ctx.r[11].s64 = ctx.r[11].s64 + 11460;
	// 8234C6C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234C6C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234C6CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234C6D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234C6D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234C6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234C6E0 size=588
    let mut pc: u32 = 0x8234C6E0;
    'dispatch: loop {
        match pc {
            0x8234C6E0 => {
    //   block [0x8234C6E0..0x8234C92C)
	// 8234C6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C6E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234C6EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C6F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8234C6F4: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234C930 size=60
    let mut pc: u32 = 0x8234C930;
    'dispatch: loop {
        match pc {
            0x8234C930 => {
    //   block [0x8234C930..0x8234C96C)
	// 8234C930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234C938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234C93C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C944: 48B0FFE5  bl 0x82e5c928
	ctx.lr = 0x8234C948;
	sub_82E5C928(ctx, base);
	// 8234C948: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234C94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C950: 396B2CF0  addi r11, r11, 0x2cf0
	ctx.r[11].s64 = ctx.r[11].s64 + 11504;
	// 8234C954: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234C958: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234C95C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234C960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234C964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234C968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234C970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234C970 size=528
    let mut pc: u32 = 0x8234C970;
    'dispatch: loop {
        match pc {
            0x8234C970 => {
    //   block [0x8234C970..0x8234CB80)
	// 8234C970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234C974: 48E5B7F9  bl 0x831a816c
	ctx.lr = 0x8234C978;
	sub_831A8130(ctx, base);
	// 8234C978: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8234C97C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234C980: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8234C984: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234C988: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8234C98C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8234C990: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 8234C994: 48AA5265  bl 0x82df1bf8
	ctx.lr = 0x8234C998;
	sub_82DF1BF8(ctx, base);
	// 8234C998: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8234C99C: 487FA8A5  bl 0x82b47240
	ctx.lr = 0x8234C9A0;
	sub_82B47240(ctx, base);
	// 8234C9A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C9A4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8234C9A8: 48AA52E9  bl 0x82df1c90
	ctx.lr = 0x8234C9AC;
	sub_82DF1C90(ctx, base);
	// 8234C9AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234C9B0: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234C9B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234C9B8: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234C9BC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234C9C0: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8234C9C4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8234C9C8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234C9CC: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8234C9D0: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8234C9D4: 48E07C2D  bl 0x83154600
	ctx.lr = 0x8234C9D8;
	sub_83154600(ctx, base);
	// 8234C9D8: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8234C9DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234C9E0: 4BFC7301  bl 0x82313ce0
	ctx.lr = 0x8234C9E4;
	sub_82313CE0(ctx, base);
	// 8234C9E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234C9E8: 40820018  bne 0x8234ca00
	if !ctx.cr[0].eq {
	pc = 0x8234CA00; continue 'dispatch;
	}
	// 8234C9EC: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 8234C9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234C9F4: 4BFC72ED  bl 0x82313ce0
	ctx.lr = 0x8234C9F8;
	sub_82313CE0(ctx, base);
	// 8234C9F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234C9FC: 41820044  beq 0x8234ca40
	if ctx.cr[0].eq {
	pc = 0x8234CA40; continue 'dispatch;
	}
	// 8234CA00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8234CA04: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8234CA08: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8234CA0C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234CB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234CB80 size=72
    let mut pc: u32 = 0x8234CB80;
    'dispatch: loop {
        match pc {
            0x8234CB80 => {
    //   block [0x8234CB80..0x8234CBC8)
	// 8234CB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234CB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234CB88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234CB8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234CB90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234CB94: 48B0FD95  bl 0x82e5c928
	ctx.lr = 0x8234CB98;
	sub_82E5C928(ctx, base);
	// 8234CB98: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234CB9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234CBA0: 394A2D1C  addi r10, r10, 0x2d1c
	ctx.r[10].s64 = ctx.r[10].s64 + 11548;
	// 8234CBA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234CBA8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8234CBAC: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8234CBB0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8234CBB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234CBB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234CBBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234CBC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234CBC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234CBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234CBC8 size=28
    let mut pc: u32 = 0x8234CBC8;
    'dispatch: loop {
        match pc {
            0x8234CBC8 => {
    //   block [0x8234CBC8..0x8234CBE4)
	// 8234CBC8: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234CBCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234CBD0: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 8234CBD4: 394B0060  addi r10, r11, 0x60
	ctx.r[10].s64 = ctx.r[11].s64 + 96;
	// 8234CBD8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 8234CBDC: 912B0060  stw r9, 0x60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 8234CBE0: 4BF77880  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234CBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234CBE8 size=1136
    let mut pc: u32 = 0x8234CBE8;
    'dispatch: loop {
        match pc {
            0x8234CBE8 => {
    //   block [0x8234CBE8..0x8234D058)
	// 8234CBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234CBEC: 48E5B57D  bl 0x831a8168
	ctx.lr = 0x8234CBF0;
	sub_831A8130(ctx, base);
	// 8234CBF0: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8234CBF4: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8234CBF8: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8234CBFC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234D058 size=60
    let mut pc: u32 = 0x8234D058;
    'dispatch: loop {
        match pc {
            0x8234D058 => {
    //   block [0x8234D058..0x8234D094)
	// 8234D058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D05C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D064: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D06C: 48B0F8BD  bl 0x82e5c928
	ctx.lr = 0x8234D070;
	sub_82E5C928(ctx, base);
	// 8234D070: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234D074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D078: 396B2D74  addi r11, r11, 0x2d74
	ctx.r[11].s64 = ctx.r[11].s64 + 11636;
	// 8234D07C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234D080: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234D084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234D088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234D08C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234D090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234D098 size=240
    let mut pc: u32 = 0x8234D098;
    'dispatch: loop {
        match pc {
            0x8234D098 => {
    //   block [0x8234D098..0x8234D188)
	// 8234D098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D0A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D0A4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D0A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8234D0AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D0B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8234D0B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234D0B8: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 8234D0BC: 48AA4B3D  bl 0x82df1bf8
	ctx.lr = 0x8234D0C0;
	sub_82DF1BF8(ctx, base);
	// 8234D0C0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8234D0C4: 487FA17D  bl 0x82b47240
	ctx.lr = 0x8234D0C8;
	sub_82B47240(ctx, base);
	// 8234D0C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234D0CC: 48AA4BC5  bl 0x82df1c90
	ctx.lr = 0x8234D0D0;
	sub_82DF1C90(ctx, base);
	// 8234D0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D0D4: 48E0752D  bl 0x83154600
	ctx.lr = 0x8234D0D8;
	sub_83154600(ctx, base);
	// 8234D0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D0DC: 4BFC5C1D  bl 0x82312cf8
	ctx.lr = 0x8234D0E0;
	sub_82312CF8(ctx, base);
	// 8234D0E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234D0E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234D0E8: 41820078  beq 0x8234d160
	if ctx.cr[0].eq {
	pc = 0x8234D160; continue 'dispatch;
	}
	// 8234D0EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8234D0F0: 4BFCA0F9  bl 0x823171e8
	ctx.lr = 0x8234D0F4;
	sub_823171E8(ctx, base);
	// 8234D0F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8234D0F8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234D0FC: 4BF82FB5  bl 0x822d00b0
	ctx.lr = 0x8234D100;
	sub_822D00B0(ctx, base);
	// 8234D100: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8234D104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234D108: 419A0008  beq cr6, 0x8234d110
	if ctx.cr[6].eq {
	pc = 0x8234D110; continue 'dispatch;
	}
	// 8234D10C: 4BF73785  bl 0x822c0890
	ctx.lr = 0x8234D110;
	sub_822C0890(ctx, base);
	// 8234D110: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234D114: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8234D118: 4BFBABA9  bl 0x82307cc0
	ctx.lr = 0x8234D11C;
	sub_82307CC0(ctx, base);
	// 8234D11C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8234D120: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234D124: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8234D128: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8234D12C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234D188 size=592
    let mut pc: u32 = 0x8234D188;
    'dispatch: loop {
        match pc {
            0x8234D188 => {
    //   block [0x8234D188..0x8234D3D8)
	// 8234D188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D18C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234D194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D198: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8234D19C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8234D1A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D1A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234D1A8: 48E07459  bl 0x83154600
	ctx.lr = 0x8234D1AC;
	sub_83154600(ctx, base);
	// 8234D1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D1B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234D1B4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8234D1B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234D1BC: 4E800421  bctrl
	ctx.lr = 0x8234D1C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234D1C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234D1C4: 408201F4  bne 0x8234d3b8
	if !ctx.cr[0].eq {
	pc = 0x8234D3B8; continue 'dispatch;
	}
	// 8234D1C8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8234D1CC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8234D1D0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8234D1D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234D1D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234D1DC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234D3D8 size=16
    let mut pc: u32 = 0x8234D3D8;
    'dispatch: loop {
        match pc {
            0x8234D3D8 => {
    //   block [0x8234D3D8..0x8234D3E8)
	// 8234D3D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8234D3DC: 9883007D  stb r4, 0x7d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(125 as u32), ctx.r[4].u8 ) };
	// 8234D3E0: 9963007C  stb r11, 0x7c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 8234D3E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234D3E8 size=72
    let mut pc: u32 = 0x8234D3E8;
    'dispatch: loop {
        match pc {
            0x8234D3E8 => {
    //   block [0x8234D3E8..0x8234D430)
	// 8234D3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234D3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D400: 48E07201  bl 0x83154600
	ctx.lr = 0x8234D404;
	sub_83154600(ctx, base);
	// 8234D404: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234D408: 4BFC5ED1  bl 0x823132d8
	ctx.lr = 0x8234D40C;
	sub_823132D8(ctx, base);
	// 8234D40C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234D410: 809F0070  lwz r4, 0x70(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8234D414: 4BFCD645  bl 0x8231aa58
	ctx.lr = 0x8234D418;
	sub_8231AA58(ctx, base);
	// 8234D418: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234D41C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234D420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234D424: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234D428: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234D42C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234D430 size=600
    let mut pc: u32 = 0x8234D430;
    'dispatch: loop {
        match pc {
            0x8234D430 => {
    //   block [0x8234D430..0x8234D688)
	// 8234D430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234D43C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D440: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 8234D444: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8234D448: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8234D44C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D450: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D454: 48E071AD  bl 0x83154600
	ctx.lr = 0x8234D458;
	sub_83154600(ctx, base);
	// 8234D458: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234D45C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234D460: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8234D464: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234D468: 4E800421  bctrl
	ctx.lr = 0x8234D46C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234D46C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234D470: 40820010  bne 0x8234d480
	if !ctx.cr[0].eq {
	pc = 0x8234D480; continue 'dispatch;
	}
	// 8234D474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D478: 48B0C2B9  bl 0x82e59730
	ctx.lr = 0x8234D47C;
	sub_82E59730(ctx, base);
	// 8234D47C: 480001E8  b 0x8234d664
	pc = 0x8234D664; continue 'dispatch;
	// 8234D480: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234D484: C01F0064  lfs f0, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D488: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8234D48C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8234D490: 41980018  blt cr6, 0x8234d4a8
	if ctx.cr[6].lt {
	pc = 0x8234D4A8; continue 'dispatch;
	}
	// 8234D494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D498: 48B0C2C9  bl 0x82e59760
	ctx.lr = 0x8234D49C;
	sub_82E59760(ctx, base);
	// 8234D49C: C01F0064  lfs f0, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D4A0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8234D4A4: 4199FFD0  bgt cr6, 0x8234d474
	if ctx.cr[6].gt {
	pc = 0x8234D474; continue 'dispatch;
	}
	// 8234D4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D4AC: 48B0C2B5  bl 0x82e59760
	ctx.lr = 0x8234D4B0;
	sub_82E59760(ctx, base);
	// 8234D4B0: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D4B4: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 8234D4B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234D4BC: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234D4C0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8234D4C4: 40990058  ble cr6, 0x8234d51c
	if !ctx.cr[6].gt {
	pc = 0x8234D51C; continue 'dispatch;
	}
	// 8234D4C8: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 8234D4CC: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 8234D4D0: C01F006C  lfs f0, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D4D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234D4D8: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234D4DC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8234D4E0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8234D4E4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8234D4E8: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 8234D4EC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8234D4F0: 4BFCC7B9  bl 0x82319ca8
	ctx.lr = 0x8234D4F4;
	sub_82319CA8(ctx, base);
	// 8234D4F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8234D4F8: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 8234D4FC: 4BF82BB5  bl 0x822d00b0
	ctx.lr = 0x8234D500;
	sub_822D00B0(ctx, base);
	// 8234D500: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 8234D504: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234D508: 41820024  beq 0x8234d52c
	if ctx.cr[0].eq {
	pc = 0x8234D52C; continue 'dispatch;
	}
	// 8234D50C: 897F007D  lbz r11, 0x7d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(125 as u32) ) } as u64;
	// 8234D510: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234D514: 40820050  bne 0x8234d564
	if !ctx.cr[0].eq {
	pc = 0x8234D564; continue 'dispatch;
	}
	// 8234D518: 4800003C  b 0x8234d554
	pc = 0x8234D554; continue 'dispatch;
	// 8234D51C: FF00F000  fcmpu cr6, f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8234D520: 4098FFAC  bge cr6, 0x8234d4cc
	if !ctx.cr[6].lt {
	pc = 0x8234D4CC; continue 'dispatch;
	}
	// 8234D524: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 8234D528: 4BFFFFA8  b 0x8234d4d0
	pc = 0x8234D4D0; continue 'dispatch;
	// 8234D52C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8234D530: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8234D534: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8234D538: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234D53C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234D688 size=84
    let mut pc: u32 = 0x8234D688;
    'dispatch: loop {
        match pc {
            0x8234D688 => {
    //   block [0x8234D688..0x8234D6DC)
	// 8234D688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D694: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D69C: 48B0F28D  bl 0x82e5c928
	ctx.lr = 0x8234D6A0;
	sub_82E5C928(ctx, base);
	// 8234D6A0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234D6A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234D6A8: 394A2E10  addi r10, r10, 0x2e10
	ctx.r[10].s64 = ctx.r[10].s64 + 11792;
	// 8234D6AC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8234D6B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8234D6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D6B8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8234D6BC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8234D6C0: 997F007C  stb r11, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 8234D6C4: 993F007D  stb r9, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[9].u8 ) };
	// 8234D6C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234D6CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234D6D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234D6D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234D6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234D6E0 size=224
    let mut pc: u32 = 0x8234D6E0;
    'dispatch: loop {
        match pc {
            0x8234D6E0 => {
    //   block [0x8234D6E0..0x8234D7C0)
	// 8234D6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D6E4: 48E5AA89  bl 0x831a816c
	ctx.lr = 0x8234D6E8;
	sub_831A8130(ctx, base);
	// 8234D6E8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8234D6EC: 48E5B38D  bl 0x831a8a78
	ctx.lr = 0x8234D6F0;
	sub_831A8A40(ctx, base);
	// 8234D6F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D6F8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234D6FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8234D700: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 8234D704: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 8234D708: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 8234D70C: 48E06EF5  bl 0x83154600
	ctx.lr = 0x8234D710;
	sub_83154600(ctx, base);
	// 8234D710: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234D714: 4BFC54F5  bl 0x82312c08
	ctx.lr = 0x8234D718;
	sub_82312C08(ctx, base);
	// 8234D718: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234D71C: 41820044  beq 0x8234d760
	if ctx.cr[0].eq {
	pc = 0x8234D760; continue 'dispatch;
	}
	// 8234D720: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234D724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234D728: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8234D72C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234D730: 4E800421  bctrl
	ctx.lr = 0x8234D734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234D734: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234D738: 40820028  bne 0x8234d760
	if !ctx.cr[0].eq {
	pc = 0x8234D760; continue 'dispatch;
	}
	// 8234D73C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234D740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234D744: 808BB390  lwz r4, -0x4c70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19568 as u32) ) } as u64;
	// 8234D748: 48AA62C1  bl 0x82df3a08
	ctx.lr = 0x8234D74C;
	sub_82DF3A08(ctx, base);
	// 8234D74C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234D750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234D754: 4BFB7E3D  bl 0x82305590
	ctx.lr = 0x8234D758;
	sub_82305590(ctx, base);
	// 8234D758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234D75C: 48AA5CCD  bl 0x82df3428
	ctx.lr = 0x8234D760;
	sub_82DF3428(ctx, base);
	// 8234D760: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234D764: 397F0074  addi r11, r31, 0x74
	ctx.r[11].s64 = ctx.r[31].s64 + 116;
	// 8234D768: D3DF0064  stfs f30, 0x64(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8234D76C: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 8234D770: D3BF0068  stfs f29, 0x68(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8234D774: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234D778: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8234D77C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8234D780: 4BF76CE1  bl 0x822c4460
	ctx.lr = 0x8234D784;
	sub_822C4460(ctx, base);
	// 8234D784: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8234D788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234D78C: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8234D790: 4BFC72A1  bl 0x82314a30
	ctx.lr = 0x8234D794;
	sub_82314A30(ctx, base);
	// 8234D794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234D798: C03F0064  lfs f1, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234D79C: 4BFE134D  bl 0x8232eae8
	ctx.lr = 0x8234D7A0;
	sub_8232EAE8(ctx, base);
	// 8234D7A0: 907F0070  stw r3, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 8234D7A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234D7A8: 4BFC9839  bl 0x82316fe0
	ctx.lr = 0x8234D7AC;
	sub_82316FE0(ctx, base);
	// 8234D7AC: D03F006C  stfs f1, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8234D7B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8234D7B4: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8234D7B8: 48E5B30D  bl 0x831a8ac4
	ctx.lr = 0x8234D7BC;
	sub_831A8A8C(ctx, base);
	// 8234D7BC: 48E5AA00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234D7C0 size=228
    let mut pc: u32 = 0x8234D7C0;
    'dispatch: loop {
        match pc {
            0x8234D7C0 => {
    //   block [0x8234D7C0..0x8234D8A4)
	// 8234D7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D7C4: 48E5A9A9  bl 0x831a816c
	ctx.lr = 0x8234D7C8;
	sub_831A8130(ctx, base);
	// 8234D7C8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8234D7CC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D7D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234D7D4: 48E06E2D  bl 0x83154600
	ctx.lr = 0x8234D7D8;
	sub_83154600(ctx, base);
	// 8234D7D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D7DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234D7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234D7E4: 4BFB828D  bl 0x82305a70
	ctx.lr = 0x8234D7E8;
	sub_82305A70(ctx, base);
	// 8234D7E8: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 8234D7EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D7F0: 4BFC5781  bl 0x82312f70
	ctx.lr = 0x8234D7F4;
	sub_82312F70(ctx, base);
	// 8234D7F4: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D7F8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 8234D7FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D800: 40980010  bge cr6, 0x8234d810
	if !ctx.cr[6].lt {
	pc = 0x8234D810; continue 'dispatch;
	}
	// 8234D804: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8234D808: 4BFC71B9  bl 0x823149c0
	ctx.lr = 0x8234D80C;
	sub_823149C0(ctx, base);
	// 8234D80C: 4800008C  b 0x8234d898
	pc = 0x8234D898; continue 'dispatch;
	// 8234D810: 4BFC53F9  bl 0x82312c08
	ctx.lr = 0x8234D814;
	sub_82312C08(ctx, base);
	// 8234D814: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234D818: 41820074  beq 0x8234d88c
	if ctx.cr[0].eq {
	pc = 0x8234D88C; continue 'dispatch;
	}
	// 8234D81C: 38800044  li r4, 0x44
	ctx.r[4].s64 = 68;
	// 8234D820: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 8234D824: 4810D5C5  bl 0x8245ade8
	ctx.lr = 0x8234D828;
	sub_8245ADE8(ctx, base);
	// 8234D828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D82C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234D830: 4BFC5D11  bl 0x82313540
	ctx.lr = 0x8234D834;
	sub_82313540(ctx, base);
	// 8234D834: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8234D838: 40980054  bge cr6, 0x8234d88c
	if !ctx.cr[6].lt {
	pc = 0x8234D88C; continue 'dispatch;
	}
	// 8234D83C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234D840: C1BE0060  lfs f13, 0x60(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234D844: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D848: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8234D84C: 4099002C  ble cr6, 0x8234d878
	if !ctx.cr[6].gt {
	pc = 0x8234D878; continue 'dispatch;
	}
	// 8234D850: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8234D854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D858: 4BFC7169  bl 0x823149c0
	ctx.lr = 0x8234D85C;
	sub_823149C0(ctx, base);
	// 8234D85C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234D860: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8234D864: 38AB2E38  addi r5, r11, 0x2e38
	ctx.r[5].s64 = ctx.r[11].s64 + 11832;
	// 8234D868: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 8234D86C: 38C00031  li r6, 0x31
	ctx.r[6].s64 = 49;
	// 8234D870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D874: 4BFC62C5  bl 0x82313b38
	ctx.lr = 0x8234D878;
	sub_82313B38(ctx, base);
	// 8234D878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234D87C: 48B0BEFD  bl 0x82e59778
	ctx.lr = 0x8234D880;
	sub_82E59778(ctx, base);
	// 8234D880: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D884: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8234D888: 4800000C  b 0x8234d894
	pc = 0x8234D894; continue 'dispatch;
	// 8234D88C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234D890: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234D894: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234D898: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8234D89C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8234D8A0: 48E5A91C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234D8A8 size=64
    let mut pc: u32 = 0x8234D8A8;
    'dispatch: loop {
        match pc {
            0x8234D8A8 => {
    //   block [0x8234D8A8..0x8234D8E8)
	// 8234D8A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D8AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D8B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D8B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D8B8: 48E06D49  bl 0x83154600
	ctx.lr = 0x8234D8BC;
	sub_83154600(ctx, base);
	// 8234D8BC: 38800021  li r4, 0x21
	ctx.r[4].s64 = 33;
	// 8234D8C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D8C4: 4BFC6425  bl 0x82313ce8
	ctx.lr = 0x8234D8C8;
	sub_82313CE8(ctx, base);
	// 8234D8C8: 38800023  li r4, 0x23
	ctx.r[4].s64 = 35;
	// 8234D8CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D8D0: 4BFC6429  bl 0x82313cf8
	ctx.lr = 0x8234D8D4;
	sub_82313CF8(ctx, base);
	// 8234D8D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234D8D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234D8DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234D8E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234D8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234D8E8 size=64
    let mut pc: u32 = 0x8234D8E8;
    'dispatch: loop {
        match pc {
            0x8234D8E8 => {
    //   block [0x8234D8E8..0x8234D928)
	// 8234D8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234D8F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234D8F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D8F8: 48E06D09  bl 0x83154600
	ctx.lr = 0x8234D8FC;
	sub_83154600(ctx, base);
	// 8234D8FC: 38800021  li r4, 0x21
	ctx.r[4].s64 = 33;
	// 8234D900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D904: 4BFC63ED  bl 0x82313cf0
	ctx.lr = 0x8234D908;
	sub_82313CF0(ctx, base);
	// 8234D908: 38800023  li r4, 0x23
	ctx.r[4].s64 = 35;
	// 8234D90C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234D910: 4BFC63F1  bl 0x82313d00
	ctx.lr = 0x8234D914;
	sub_82313D00(ctx, base);
	// 8234D914: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234D918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234D91C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234D920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234D924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234D928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234D928 size=380
    let mut pc: u32 = 0x8234D928;
    'dispatch: loop {
        match pc {
            0x8234D928 => {
    //   block [0x8234D928..0x8234DAA4)
	// 8234D928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234D92C: 48E5A839  bl 0x831a8164
	ctx.lr = 0x8234D930;
	sub_831A8130(ctx, base);
	// 8234D930: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234D934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234D938: 48E06CC9  bl 0x83154600
	ctx.lr = 0x8234D93C;
	sub_83154600(ctx, base);
	// 8234D93C: 83BF0060  lwz r29, 0x60(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234D940: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8234D944: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8234D948: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234D94C: 3BDF0060  addi r30, r31, 0x60
	ctx.r[30].s64 = ctx.r[31].s64 + 96;
	// 8234D950: 4BF82761  bl 0x822d00b0
	ctx.lr = 0x8234D954;
	sub_822D00B0(ctx, base);
	// 8234D954: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8234D958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234D95C: 4BFB8115  bl 0x82305a70
	ctx.lr = 0x8234D960;
	sub_82305A70(ctx, base);
	// 8234D960: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8234D964: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8234D968: 4BFCC181  bl 0x82319ae8
	ctx.lr = 0x8234D96C;
	sub_82319AE8(ctx, base);
	// 8234D96C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234DAA8 size=132
    let mut pc: u32 = 0x8234DAA8;
    'dispatch: loop {
        match pc {
            0x8234DAA8 => {
    //   block [0x8234DAA8..0x8234DB2C)
	// 8234DAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DAAC: 48E5A6BD  bl 0x831a8168
	ctx.lr = 0x8234DAB0;
	sub_831A8130(ctx, base);
	// 8234DAB0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8234DAB4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DAB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DABC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234DAC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8234DAC4: 48E06B3D  bl 0x83154600
	ctx.lr = 0x8234DAC8;
	sub_83154600(ctx, base);
	// 8234DAC8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234DACC: 3BDF0060  addi r30, r31, 0x60
	ctx.r[30].s64 = ctx.r[31].s64 + 96;
	// 8234DAD0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8234DAD4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8234DAD8: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 8234DADC: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8234DAE0: 4BF76981  bl 0x822c4460
	ctx.lr = 0x8234DAE4;
	sub_822C4460(ctx, base);
	// 8234DAE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8234DAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234DAEC: 83BF0060  lwz r29, 0x60(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234DAF0: 4BFB7F81  bl 0x82305a70
	ctx.lr = 0x8234DAF4;
	sub_82305A70(ctx, base);
	// 8234DAF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234DAF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234DAFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234DB00: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8234DB04: 4BF829C5  bl 0x822d04c8
	ctx.lr = 0x8234DB08;
	sub_822D04C8(ctx, base);
	// 8234DB08: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234DB0C: 4BF82425  bl 0x822cff30
	ctx.lr = 0x8234DB10;
	sub_822CFF30(ctx, base);
	// 8234DB10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234DB14: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234DB18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234DB1C: 4BFCB02D  bl 0x82318b48
	ctx.lr = 0x8234DB20;
	sub_82318B48(ctx, base);
	// 8234DB20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8234DB24: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8234DB28: 48E5A690  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234DB30 size=68
    let mut pc: u32 = 0x8234DB30;
    'dispatch: loop {
        match pc {
            0x8234DB30 => {
    //   block [0x8234DB30..0x8234DB74)
	// 8234DB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234DB38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234DB3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DB40: 48E06AC1  bl 0x83154600
	ctx.lr = 0x8234DB44;
	sub_83154600(ctx, base);
	// 8234DB44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DB48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234DB4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234DB50: 4BFC9F01  bl 0x82317a50
	ctx.lr = 0x8234DB54;
	sub_82317A50(ctx, base);
	// 8234DB54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234DB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DB5C: 4BFC9A3D  bl 0x82317598
	ctx.lr = 0x8234DB60;
	sub_82317598(ctx, base);
	// 8234DB60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234DB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234DB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234DB6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234DB70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8234DB78 size=8
    let mut pc: u32 = 0x8234DB78;
    'dispatch: loop {
        match pc {
            0x8234DB78 => {
    //   block [0x8234DB78..0x8234DB80)
	// 8234DB78: D0230060  stfs f1, 0x60(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234DB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234DB80 size=60
    let mut pc: u32 = 0x8234DB80;
    'dispatch: loop {
        match pc {
            0x8234DB80 => {
    //   block [0x8234DB80..0x8234DBBC)
	// 8234DB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234DB88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234DB8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DB90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DB94: 48E06A6D  bl 0x83154600
	ctx.lr = 0x8234DB98;
	sub_83154600(ctx, base);
	// 8234DB98: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 8234DB9C: 4BFC615D  bl 0x82313cf8
	ctx.lr = 0x8234DBA0;
	sub_82313CF8(ctx, base);
	// 8234DBA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234DBA4: 997F0064  stb r11, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 8234DBA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234DBAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234DBB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234DBB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234DBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234DBC0 size=92
    let mut pc: u32 = 0x8234DBC0;
    'dispatch: loop {
        match pc {
            0x8234DBC0 => {
    //   block [0x8234DBC0..0x8234DC1C)
	// 8234DBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234DBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234DBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DBD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DBD4: 48E06A2D  bl 0x83154600
	ctx.lr = 0x8234DBD8;
	sub_83154600(ctx, base);
	// 8234DBD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234DBDC: C1BF0060  lfs f13, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234DBE0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DBE4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8234DBE8: 41980020  blt cr6, 0x8234dc08
	if ctx.cr[6].lt {
	pc = 0x8234DC08; continue 'dispatch;
	}
	// 8234DBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DBF0: 48B0BB71  bl 0x82e59760
	ctx.lr = 0x8234DBF4;
	sub_82E59760(ctx, base);
	// 8234DBF4: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DBF8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8234DBFC: 4099000C  ble cr6, 0x8234dc08
	if !ctx.cr[6].gt {
	pc = 0x8234DC08; continue 'dispatch;
	}
	// 8234DC00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DC04: 48B0BB2D  bl 0x82e59730
	ctx.lr = 0x8234DC08;
	sub_82E59730(ctx, base);
	// 8234DC08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234DC0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234DC10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234DC14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234DC18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234DC20 size=72
    let mut pc: u32 = 0x8234DC20;
    'dispatch: loop {
        match pc {
            0x8234DC20 => {
    //   block [0x8234DC20..0x8234DC68)
	// 8234DC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234DC28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234DC2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DC30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DC34: 48E069CD  bl 0x83154600
	ctx.lr = 0x8234DC38;
	sub_83154600(ctx, base);
	// 8234DC38: 897F0064  lbz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8234DC3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234DC40: 4182000C  beq 0x8234dc4c
	if ctx.cr[0].eq {
	pc = 0x8234DC4C; continue 'dispatch;
	}
	// 8234DC44: 4BFC7D85  bl 0x823159c8
	ctx.lr = 0x8234DC48;
	sub_823159C8(ctx, base);
	// 8234DC48: 4800000C  b 0x8234dc54
	pc = 0x8234DC54; continue 'dispatch;
	// 8234DC4C: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 8234DC50: 4BFC60B1  bl 0x82313d00
	ctx.lr = 0x8234DC54;
	sub_82313D00(ctx, base);
	// 8234DC54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234DC58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234DC5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234DC60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234DC64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234DC68 size=64
    let mut pc: u32 = 0x8234DC68;
    'dispatch: loop {
        match pc {
            0x8234DC68 => {
    //   block [0x8234DC68..0x8234DCA8)
	// 8234DC68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DC6C: 48E5A501  bl 0x831a816c
	ctx.lr = 0x8234DC70;
	sub_831A8130(ctx, base);
	// 8234DC70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DC78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8234DC7C: 48E06985  bl 0x83154600
	ctx.lr = 0x8234DC80;
	sub_83154600(ctx, base);
	// 8234DC80: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 8234DC84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234DC88: 4BFC6079  bl 0x82313d00
	ctx.lr = 0x8234DC8C;
	sub_82313D00(ctx, base);
	// 8234DC8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8234DC90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234DC94: 997F0064  stb r11, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 8234DC98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234DC9C: 4BFC7D25  bl 0x823159c0
	ctx.lr = 0x8234DCA0;
	sub_823159C0(ctx, base);
	// 8234DCA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234DCA4: 48E5A518  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234DCA8 size=72
    let mut pc: u32 = 0x8234DCA8;
    'dispatch: loop {
        match pc {
            0x8234DCA8 => {
    //   block [0x8234DCA8..0x8234DCF0)
	// 8234DCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234DCB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234DCB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DCB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DCBC: 48B0EC6D  bl 0x82e5c928
	ctx.lr = 0x8234DCC0;
	sub_82E5C928(ctx, base);
	// 8234DCC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234DCC4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234DCC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DCCC: 394A2F1C  addi r10, r10, 0x2f1c
	ctx.r[10].s64 = ctx.r[10].s64 + 12060;
	// 8234DCD0: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DCD4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8234DCD8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234DCDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234DCE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234DCE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234DCE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234DCEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234DCF0 size=160
    let mut pc: u32 = 0x8234DCF0;
    'dispatch: loop {
        match pc {
            0x8234DCF0 => {
    //   block [0x8234DCF0..0x8234DD90)
	// 8234DCF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DCF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234DCF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234DCFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234DD00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DD04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234DD08: 48E068F9  bl 0x83154600
	ctx.lr = 0x8234DD0C;
	sub_83154600(ctx, base);
	// 8234DD0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DD10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8234DD14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234DD18: 4BFCBDD1  bl 0x82319ae8
	ctx.lr = 0x8234DD1C;
	sub_82319AE8(ctx, base);
	// 8234DD1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8234DD20: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234DD24: C00B89AC  lfs f0, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DD28: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8234DD2C: 40990028  ble cr6, 0x8234dd54
	if !ctx.cr[6].gt {
	pc = 0x8234DD54; continue 'dispatch;
	}
	// 8234DD30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234DD34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234DD38: 388B2F40  addi r4, r11, 0x2f40
	ctx.r[4].s64 = ctx.r[11].s64 + 12096;
	// 8234DD3C: 48AA5CCD  bl 0x82df3a08
	ctx.lr = 0x8234DD40;
	sub_82DF3A08(ctx, base);
	// 8234DD40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234DD44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DD48: 4BFB7F99  bl 0x82305ce0
	ctx.lr = 0x8234DD4C;
	sub_82305CE0(ctx, base);
	// 8234DD4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234DD50: 48AA56D9  bl 0x82df3428
	ctx.lr = 0x8234DD54;
	sub_82DF3428(ctx, base);
	// 8234DD54: 389E0060  addi r4, r30, 0x60
	ctx.r[4].s64 = ctx.r[30].s64 + 96;
	// 8234DD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DD5C: 4BFB7FDD  bl 0x82305d38
	ctx.lr = 0x8234DD60;
	sub_82305D38(ctx, base);
	// 8234DD60: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 8234DD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DD68: 4BFC5F99  bl 0x82313d00
	ctx.lr = 0x8234DD6C;
	sub_82313D00(ctx, base);
	// 8234DD6C: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 8234DD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DD74: 4BFC5F7D  bl 0x82313cf0
	ctx.lr = 0x8234DD78;
	sub_82313CF0(ctx, base);
	// 8234DD78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8234DD7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234DD80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234DD84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234DD88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234DD8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234DD90 size=104
    let mut pc: u32 = 0x8234DD90;
    'dispatch: loop {
        match pc {
            0x8234DD90 => {
    //   block [0x8234DD90..0x8234DDF8)
	// 8234DD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DD94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234DD98: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 8234DD9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DDA0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234DDA4: 48E0685D  bl 0x83154600
	ctx.lr = 0x8234DDA8;
	sub_83154600(ctx, base);
	// 8234DDA8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234DDAC: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8234DDB0: C00BADA8  lfs f0, -0x5258(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21080 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DDB4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8234DDB8: C1AAADA4  lfs f13, -0x525c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21084 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234DDBC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8234DDC0: 40980008  bge cr6, 0x8234ddc8
	if !ctx.cr[6].lt {
	pc = 0x8234DDC8; continue 'dispatch;
	}
	// 8234DDC4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 8234DDC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234DDCC: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8234DDD0: C18B08A4  lfs f12, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234DDD4: FD80602E  fsel f12, f0, f0, f12
	ctx.f[12].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 8234DDD8: C00AADA0  lfs f0, -0x5260(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DDDC: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 8234DDE0: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8234DDE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234DDE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234DDEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234DDF0: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234DDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234DDF8 size=268
    let mut pc: u32 = 0x8234DDF8;
    'dispatch: loop {
        match pc {
            0x8234DDF8 => {
    //   block [0x8234DDF8..0x8234DF04)
	// 8234DDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DDFC: 48E5A369  bl 0x831a8164
	ctx.lr = 0x8234DE00;
	sub_831A8130(ctx, base);
	// 8234DE00: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8234DE04: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DE08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234DE0C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8234DE10: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8234DE14: 48E067ED  bl 0x83154600
	ctx.lr = 0x8234DE18;
	sub_83154600(ctx, base);
	// 8234DE18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234DE1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8234DE20: C00B0B54  lfs f0, 0xb54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2900 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DE24: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8234DE28: 4BFCA1F1  bl 0x82318018
	ctx.lr = 0x8234DE2C;
	sub_82318018(ctx, base);
	// 8234DE2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234DE30: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234DF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234DF08 size=876
    let mut pc: u32 = 0x8234DF08;
    'dispatch: loop {
        match pc {
            0x8234DF08 => {
    //   block [0x8234DF08..0x8234E274)
	// 8234DF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234DF0C: 48E5A25D  bl 0x831a8168
	ctx.lr = 0x8234DF10;
	sub_831A8130(ctx, base);
	// 8234DF10: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 8234DF14: 48E5AB65  bl 0x831a8a78
	ctx.lr = 0x8234DF18;
	sub_831A8A40(ctx, base);
	// 8234DF18: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234DF1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234DF20: 48E066E1  bl 0x83154600
	ctx.lr = 0x8234DF24;
	sub_83154600(ctx, base);
	// 8234DF24: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 8234DF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234DF2C: 4BFC5DCD  bl 0x82313cf8
	ctx.lr = 0x8234DF30;
	sub_82313CF8(ctx, base);
	// 8234DF30: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8234DF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DF38: 4BFC5DA9  bl 0x82313ce0
	ctx.lr = 0x8234DF3C;
	sub_82313CE0(ctx, base);
	// 8234DF3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234DF40: 4082001C  bne 0x8234df5c
	if !ctx.cr[0].eq {
	pc = 0x8234DF5C; continue 'dispatch;
	}
	// 8234DF44: 388000E0  li r4, 0xe0
	ctx.r[4].s64 = 224;
	// 8234DF48: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 8234DF4C: 4810CE55  bl 0x8245ada0
	ctx.lr = 0x8234DF50;
	sub_8245ADA0(ctx, base);
	// 8234DF50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234DF54: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8234DF58: 41820008  beq 0x8234df60
	if ctx.cr[0].eq {
	pc = 0x8234DF60; continue 'dispatch;
	}
	// 8234DF5C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8234DF60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234DF64: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234DF68: 4BFC9AE9  bl 0x82317a50
	ctx.lr = 0x8234DF6C;
	sub_82317A50(ctx, base);
	// 8234DF6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234DF70: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8234DF74: 48B2F4DD  bl 0x82e7d450
	ctx.lr = 0x8234DF78;
	sub_82E7D450(ctx, base);
	// 8234DF78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234DF7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234DF80: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8234DF84: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234DF88: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234DF8C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234DF90: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234DF94: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234DF98: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234DF9C: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234DFA0: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8234DFA4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8234DFA8: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8234DFAC: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8234DFB0: D161008C  stfs f11, 0x8c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8234DFB4: 4BFB7ABD  bl 0x82305a70
	ctx.lr = 0x8234DFB8;
	sub_82305A70(ctx, base);
	// 8234DFB8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8234DFBC: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 8234DFC0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8234DFC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234DFC8: 4BFFFE31  bl 0x8234ddf8
	ctx.lr = 0x8234DFCC;
	sub_8234DDF8(ctx, base);
	// 8234DFCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234DFD0: 4BFC9011  bl 0x82316fe0
	ctx.lr = 0x8234DFD4;
	sub_82316FE0(ctx, base);
	// 8234DFD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234DFD8: 57CA063F  clrlwi. r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8234DFDC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234DFE0: C38B08A4  lfs f28, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8234DFE4: 41820018  beq 0x8234dffc
	if ctx.cr[0].eq {
	pc = 0x8234DFFC; continue 'dispatch;
	}
	// 8234DFE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234DFEC: 396B08A8  addi r11, r11, 0x8a8
	ctx.r[11].s64 = ctx.r[11].s64 + 2216;
	// 8234DFF0: C3AB0000  lfs f29, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234DFF4: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 8234DFF8: 48000060  b 0x8234e058
	pc = 0x8234E058; continue 'dispatch;
	// 8234DFFC: 3880006A  li r4, 0x6a
	ctx.r[4].s64 = 106;
	// 8234E000: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 8234E004: 4810CDE5  bl 0x8245ade8
	ctx.lr = 0x8234E008;
	sub_8245ADE8(ctx, base);
	// 8234E008: 3880006B  li r4, 0x6b
	ctx.r[4].s64 = 107;
	// 8234E00C: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 8234E010: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8234E014: 4810CDD5  bl 0x8245ade8
	ctx.lr = 0x8234E018;
	sub_8245ADE8(ctx, base);
	// 8234E018: 3880006A  li r4, 0x6a
	ctx.r[4].s64 = 106;
	// 8234E01C: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 8234E020: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 8234E024: EFFFF028  fsubs f31, f31, f30
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 8234E028: 4810CDC1  bl 0x8245ade8
	ctx.lr = 0x8234E02C;
	sub_8245ADE8(ctx, base);
	// 8234E02C: EC1D0828  fsubs f0, f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[1].f64) as f32) as f64);
	// 8234E030: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234E034: 396B08A8  addi r11, r11, 0x8a8
	ctx.r[11].s64 = ctx.r[11].s64 + 2216;
	// 8234E038: C3AB0000  lfs f29, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234E03C: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 8234E040: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8234E044: 4199FFB0  bgt cr6, 0x8234dff4
	if ctx.cr[6].gt {
	pc = 0x8234DFF4; continue 'dispatch;
	}
	// 8234E048: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 8234E04C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 8234E050: 40980008  bge cr6, 0x8234e058
	if !ctx.cr[6].lt {
	pc = 0x8234E058; continue 'dispatch;
	}
	// 8234E054: FFE0E090  fmr f31, f28
	ctx.f[31].f64 = ctx.f[28].f64;
	// 8234E058: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234E05C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234E060: 4BFCBA89  bl 0x82319ae8
	ctx.lr = 0x8234E064;
	sub_82319AE8(ctx, base);
	// 8234E064: EC1DF828  fsubs f0, f29, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[31].f64) as f32) as f64);
	// 8234E068: C1A100A4  lfs f13, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234E06C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234E070: 38C00066  li r6, 0x66
	ctx.r[6].s64 = 102;
	// 8234E074: 38AB2F60  addi r5, r11, 0x2f60
	ctx.r[5].s64 = ctx.r[11].s64 + 12128;
	// 8234E078: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8234E07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234E080: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8234E084: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8234E088: 4BFC5AB1  bl 0x82313b38
	ctx.lr = 0x8234E08C;
	sub_82313B38(ctx, base);
	// 8234E08C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234E090: 4BFC9D29  bl 0x82317db8
	ctx.lr = 0x8234E094;
	sub_82317DB8(ctx, base);
	// 8234E094: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234E098: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234E09C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234E0A0: 4BFC99B1  bl 0x82317a50
	ctx.lr = 0x8234E0A4;
	sub_82317A50(ctx, base);
	// 8234E0A4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234E278 size=1176
    let mut pc: u32 = 0x8234E278;
    'dispatch: loop {
        match pc {
            0x8234E278 => {
    //   block [0x8234E278..0x8234E710)
	// 8234E278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E27C: 48E59EF1  bl 0x831a816c
	ctx.lr = 0x8234E280;
	sub_831A8130(ctx, base);
	// 8234E280: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8234E284: 48E5A7ED  bl 0x831a8a70
	ctx.lr = 0x8234E288;
	sub_831A8A40(ctx, base);
	// 8234E288: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8234E710 size=16
    let mut pc: u32 = 0x8234E710;
    'dispatch: loop {
        match pc {
            0x8234E710 => {
    //   block [0x8234E710..0x8234E720)
	// 8234E710: D0230060  stfs f1, 0x60(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234E714: 90A30064  stw r5, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 8234E718: 90C30068  stw r6, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[6].u32 ) };
	// 8234E71C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234E720 size=40
    let mut pc: u32 = 0x8234E720;
    'dispatch: loop {
        match pc {
            0x8234E720 => {
    //   block [0x8234E720..0x8234E748)
	// 8234E720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E728: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E72C: 48E05ED5  bl 0x83154600
	ctx.lr = 0x8234E730;
	sub_83154600(ctx, base);
	// 8234E730: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8234E734: 4BFC55C5  bl 0x82313cf8
	ctx.lr = 0x8234E738;
	sub_82313CF8(ctx, base);
	// 8234E738: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234E73C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234E740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234E744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234E748 size=184
    let mut pc: u32 = 0x8234E748;
    'dispatch: loop {
        match pc {
            0x8234E748 => {
    //   block [0x8234E748..0x8234E800)
	// 8234E748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234E754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234E758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E75C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234E760: 48E05EA1  bl 0x83154600
	ctx.lr = 0x8234E764;
	sub_83154600(ctx, base);
	// 8234E764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234E768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234E76C: 48B0AFF5  bl 0x82e59760
	ctx.lr = 0x8234E770;
	sub_82E59760(ctx, base);
	// 8234E770: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234E774: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234E778: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8234E77C: 40990018  ble cr6, 0x8234e794
	if !ctx.cr[6].gt {
	pc = 0x8234E794; continue 'dispatch;
	}
	// 8234E780: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8234E784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234E788: 4BFC5579  bl 0x82313d00
	ctx.lr = 0x8234E78C;
	sub_82313D00(ctx, base);
	// 8234E78C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234E790: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 8234E794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234E798: C1BF0060  lfs f13, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234E79C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234E7A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8234E7A4: 41980018  blt cr6, 0x8234e7bc
	if ctx.cr[6].lt {
	pc = 0x8234E7BC; continue 'dispatch;
	}
	// 8234E7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234E7AC: 48B0AFB5  bl 0x82e59760
	ctx.lr = 0x8234E7B0;
	sub_82E59760(ctx, base);
	// 8234E7B0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234E7B4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8234E7B8: 41990028  bgt cr6, 0x8234e7e0
	if ctx.cr[6].gt {
	pc = 0x8234E7E0; continue 'dispatch;
	}
	// 8234E7BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234E7C0: 4BFC4449  bl 0x82312c08
	ctx.lr = 0x8234E7C4;
	sub_82312C08(ctx, base);
	// 8234E7C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234E7C8: 41820020  beq 0x8234e7e8
	if ctx.cr[0].eq {
	pc = 0x8234E7E8; continue 'dispatch;
	}
	// 8234E7CC: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8234E7D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234E7D4: 4BFC550D  bl 0x82313ce0
	ctx.lr = 0x8234E7D8;
	sub_82313CE0(ctx, base);
	// 8234E7D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234E7DC: 4182000C  beq 0x8234e7e8
	if ctx.cr[0].eq {
	pc = 0x8234E7E8; continue 'dispatch;
	}
	// 8234E7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234E7E4: 48B0AF4D  bl 0x82e59730
	ctx.lr = 0x8234E7E8;
	sub_82E59730(ctx, base);
	// 8234E7E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234E7EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234E7F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234E7F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234E7F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234E7FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234E800 size=128
    let mut pc: u32 = 0x8234E800;
    'dispatch: loop {
        match pc {
            0x8234E800 => {
    //   block [0x8234E800..0x8234E880)
	// 8234E800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234E80C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234E810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234E818: 48E05DE9  bl 0x83154600
	ctx.lr = 0x8234E81C;
	sub_83154600(ctx, base);
	// 8234E81C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8234E820: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234E824: 4BFC54DD  bl 0x82313d00
	ctx.lr = 0x8234E828;
	sub_82313D00(ctx, base);
	// 8234E828: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8234E82C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234E830: 41820010  beq 0x8234e840
	if ctx.cr[0].eq {
	pc = 0x8234E840; continue 'dispatch;
	}
	// 8234E834: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8234E838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234E83C: 4BFC54C5  bl 0x82313d00
	ctx.lr = 0x8234E840;
	sub_82313D00(ctx, base);
	// 8234E840: 897F006D  lbz r11, 0x6d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(109 as u32) ) } as u64;
	// 8234E844: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234E848: 41820010  beq 0x8234e858
	if ctx.cr[0].eq {
	pc = 0x8234E858; continue 'dispatch;
	}
	// 8234E84C: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8234E850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234E854: 4BFC54AD  bl 0x82313d00
	ctx.lr = 0x8234E858;
	sub_82313D00(ctx, base);
	// 8234E858: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234E85C: 80BF0068  lwz r5, 0x68(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8234E860: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8234E864: 4BFCC2E5  bl 0x8231ab48
	ctx.lr = 0x8234E868;
	sub_8231AB48(ctx, base);
	// 8234E868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234E86C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234E870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234E874: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234E878: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234E87C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234E880 size=60
    let mut pc: u32 = 0x8234E880;
    'dispatch: loop {
        match pc {
            0x8234E880 => {
    //   block [0x8234E880..0x8234E8BC)
	// 8234E880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E888: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234E88C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234E894: 48E05D6D  bl 0x83154600
	ctx.lr = 0x8234E898;
	sub_83154600(ctx, base);
	// 8234E898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8234E89C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8234E8A0: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 8234E8A4: 4BFC5455  bl 0x82313cf8
	ctx.lr = 0x8234E8A8;
	sub_82313CF8(ctx, base);
	// 8234E8A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234E8AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234E8B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234E8B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234E8B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234E8C0 size=60
    let mut pc: u32 = 0x8234E8C0;
    'dispatch: loop {
        match pc {
            0x8234E8C0 => {
    //   block [0x8234E8C0..0x8234E8FC)
	// 8234E8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E8C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234E8CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E8D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234E8D4: 48E05D2D  bl 0x83154600
	ctx.lr = 0x8234E8D8;
	sub_83154600(ctx, base);
	// 8234E8D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8234E8DC: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8234E8E0: 997F006D  stb r11, 0x6d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(109 as u32), ctx.r[11].u8 ) };
	// 8234E8E4: 4BFC5415  bl 0x82313cf8
	ctx.lr = 0x8234E8E8;
	sub_82313CF8(ctx, base);
	// 8234E8E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234E8EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234E8F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234E8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234E8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234E900 size=84
    let mut pc: u32 = 0x8234E900;
    'dispatch: loop {
        match pc {
            0x8234E900 => {
    //   block [0x8234E900..0x8234E954)
	// 8234E900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234E90C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234E914: 48B0E015  bl 0x82e5c928
	ctx.lr = 0x8234E918;
	sub_82E5C928(ctx, base);
	// 8234E918: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234E91C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8234E920: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234E924: 39292FD0  addi r9, r9, 0x2fd0
	ctx.r[9].s64 = ctx.r[9].s64 + 12240;
	// 8234E928: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 8234E92C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234E930: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234E934: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234E938: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234E93C: 997F006D  stb r11, 0x6d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(109 as u32), ctx.r[11].u8 ) };
	// 8234E940: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234E944: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234E948: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234E94C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234E950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234E958 size=88
    let mut pc: u32 = 0x8234E958;
    'dispatch: loop {
        match pc {
            0x8234E958 => {
    //   block [0x8234E958..0x8234E9B0)
	// 8234E958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E95C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E960: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234E964: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E968: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234E96C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234E970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234E974: 419A0028  beq cr6, 0x8234e99c
	if ctx.cr[6].eq {
	pc = 0x8234E99C; continue 'dispatch;
	}
	// 8234E978: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234E97C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234E980: 808BADF8  lwz r4, -0x5208(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21000 as u32) ) } as u64;
	// 8234E984: 48AA5085  bl 0x82df3a08
	ctx.lr = 0x8234E988;
	sub_82DF3A08(ctx, base);
	// 8234E988: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234E98C: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8234E990: 48AC3F21  bl 0x82e128b0
	ctx.lr = 0x8234E994;
	sub_82E128B0(ctx, base);
	// 8234E994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234E998: 48AA4A91  bl 0x82df3428
	ctx.lr = 0x8234E99C;
	sub_82DF3428(ctx, base);
	// 8234E99C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234E9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234E9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234E9A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234E9AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234E9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234E9B0 size=196
    let mut pc: u32 = 0x8234E9B0;
    'dispatch: loop {
        match pc {
            0x8234E9B0 => {
    //   block [0x8234E9B0..0x8234EA74)
	// 8234E9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234E9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234E9B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234E9BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234E9C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234E9C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234E9C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234E9CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8234E9D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234E9D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234E9D8: 4BF71F61  bl 0x822c0938
	ctx.lr = 0x8234E9DC;
	sub_822C0938(ctx, base);
	// 8234E9DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234E9E0: 41820028  beq 0x8234ea08
	if ctx.cr[0].eq {
	pc = 0x8234EA08; continue 'dispatch;
	}
	// 8234E9E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234E9E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234E9EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8234E9F0: 392B3020  addi r9, r11, 0x3020
	ctx.r[9].s64 = ctx.r[11].s64 + 12320;
	// 8234E9F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234E9F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234E9FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234EA00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234EA04: 48000008  b 0x8234ea0c
	pc = 0x8234EA0C; continue 'dispatch;
	// 8234EA08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234EA0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234EA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234EA14: 409A0044  bne cr6, 0x8234ea58
	if !ctx.cr[6].eq {
	pc = 0x8234EA58; continue 'dispatch;
	}
	// 8234EA18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234EA1C: 419A001C  beq cr6, 0x8234ea38
	if ctx.cr[6].eq {
	pc = 0x8234EA38; continue 'dispatch;
	}
	// 8234EA20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234EA24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234EA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234EA2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234EA30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234EA34: 4E800421  bctrl
	ctx.lr = 0x8234EA38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234EA38: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234EA3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234EA40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234EA44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8234EA48: 816BADFC  lwz r11, -0x5204(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20996 as u32) ) } as u64;
	// 8234EA4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8234EA50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234EA54: 4BF715AD  bl 0x822c0000
	ctx.lr = 0x8234EA58;
	sub_822C0000(ctx, base);
	// 8234EA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234EA5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234EA60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234EA64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234EA68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234EA6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234EA70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234EA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234EA78 size=832
    let mut pc: u32 = 0x8234EA78;
    'dispatch: loop {
        match pc {
            0x8234EA78 => {
    //   block [0x8234EA78..0x8234EDB8)
	// 8234EA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234EA7C: 48E596E9  bl 0x831a8164
	ctx.lr = 0x8234EA80;
	sub_831A8130(ctx, base);
	// 8234EA80: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 8234EA84: 48E59FF5  bl 0x831a8a78
	ctx.lr = 0x8234EA88;
	sub_831A8A40(ctx, base);
	// 8234EA88: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234EA8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234EA90: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8234EA94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234EA98: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8234EA9C: 48E05B65  bl 0x83154600
	ctx.lr = 0x8234EAA0;
	sub_83154600(ctx, base);
	// 8234EAA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234EAA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234EAA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234EAAC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8234EAB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234EAB4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234EAB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8234EABC: C3AA08A8  lfs f29, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234EAC0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234EAC4: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8234EAC8: D3A10068  stfs f29, 0x68(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8234EACC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8234EAD0: 48B2D279  bl 0x82e7bd48
	ctx.lr = 0x8234EAD4;
	sub_82E7BD48(ctx, base);
	// 8234EAD4: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8234EAD8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8234EADC: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234EAE0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8234EAE4: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234EAE8: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234EAEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234EAF0: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234EAF4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234EAF8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234EAFC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8234EB00: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8234EB04: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8234EB08: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8234EB0C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234EDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234EDB8 size=112
    let mut pc: u32 = 0x8234EDB8;
    'dispatch: loop {
        match pc {
            0x8234EDB8 => {
    //   block [0x8234EDB8..0x8234EE28)
	// 8234EDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234EDBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234EDC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234EDC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234EDC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234EDCC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8234EDD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234EDD4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8234EDD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234EDDC: 4BFFFBD5  bl 0x8234e9b0
	ctx.lr = 0x8234EDE0;
	sub_8234E9B0(ctx, base);
	// 8234EDE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8234EDE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234EDE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234EDEC: 4BF71215  bl 0x822c0000
	ctx.lr = 0x8234EDF0;
	sub_822C0000(ctx, base);
	// 8234EDF0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8234EDF4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8234EDF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234EDFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8234EE00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234EE04: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234EE08: 419A0008  beq cr6, 0x8234ee10
	if ctx.cr[6].eq {
	pc = 0x8234EE10; continue 'dispatch;
	}
	// 8234EE0C: 4BF71A85  bl 0x822c0890
	ctx.lr = 0x8234EE10;
	sub_822C0890(ctx, base);
	// 8234EE10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234EE14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234EE18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234EE1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234EE20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234EE24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234EE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234EE28 size=236
    let mut pc: u32 = 0x8234EE28;
    'dispatch: loop {
        match pc {
            0x8234EE28 => {
    //   block [0x8234EE28..0x8234EF14)
	// 8234EE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234EE2C: 48E59341  bl 0x831a816c
	ctx.lr = 0x8234EE30;
	sub_831A8130(ctx, base);
	// 8234EE30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234EE34: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234EE38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234EE3C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 8234EE40: 3BDF0060  addi r30, r31, 0x60
	ctx.r[30].s64 = ctx.r[31].s64 + 96;
	// 8234EE44: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8234EE48: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8234EE4C: 4BF75615  bl 0x822c4460
	ctx.lr = 0x8234EE50;
	sub_822C4460(ctx, base);
	// 8234EE50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234EE54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234EE58: 388B3040  addi r4, r11, 0x3040
	ctx.r[4].s64 = ctx.r[11].s64 + 12352;
	// 8234EE5C: 38A00047  li r5, 0x47
	ctx.r[5].s64 = 71;
	// 8234EE60: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8234EE64: 48AA3585  bl 0x82df23e8
	ctx.lr = 0x8234EE68;
	sub_82DF23E8(ctx, base);
	// 8234EE68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234EE6C: 41820024  beq 0x8234ee90
	if ctx.cr[0].eq {
	pc = 0x8234EE90; continue 'dispatch;
	}
	// 8234EE70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234EE74: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8234EE78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8234EE7C: 396B3034  addi r11, r11, 0x3034
	ctx.r[11].s64 = ctx.r[11].s64 + 12340;
	// 8234EE80: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234EE84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234EE88: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234EE8C: 48000008  b 0x8234ee94
	pc = 0x8234EE94; continue 'dispatch;
	// 8234EE90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8234EE94: 3BBF0068  addi r29, r31, 0x68
	ctx.r[29].s64 = ctx.r[31].s64 + 104;
	// 8234EE98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234EE9C: 4BFFFF1D  bl 0x8234edb8
	ctx.lr = 0x8234EEA0;
	sub_8234EDB8(ctx, base);
	// 8234EEA0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234EEA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234EEA8: 808BADF8  lwz r4, -0x5208(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21000 as u32) ) } as u64;
	// 8234EEAC: 48AA4B5D  bl 0x82df3a08
	ctx.lr = 0x8234EEB0;
	sub_82DF3A08(ctx, base);
	// 8234EEB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8234EEB4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234EEB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234EEBC: 48AC3865  bl 0x82e12720
	ctx.lr = 0x8234EEC0;
	sub_82E12720(ctx, base);
	// 8234EEC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234EEC4: 48AA4565  bl 0x82df3428
	ctx.lr = 0x8234EEC8;
	sub_82DF3428(ctx, base);
	// 8234EEC8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234EECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234EED0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8234EED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234EED8: 4E800421  bctrl
	ctx.lr = 0x8234EEDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234EEDC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8234EEE0: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 8234EEE4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234EEE8: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234EEEC: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234EEF0: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8234EEF4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234EEF8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8234EEFC: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8234EF00: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8234EF04: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234EF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234EF18 size=44
    let mut pc: u32 = 0x8234EF18;
    'dispatch: loop {
        match pc {
            0x8234EF18 => {
    //   block [0x8234EF18..0x8234EF44)
	// 8234EF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234EF1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234EF20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234EF24: 48E056DD  bl 0x83154600
	ctx.lr = 0x8234EF28;
	sub_83154600(ctx, base);
	// 8234EF28: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8234EF2C: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 8234EF30: 4BFC6681  bl 0x823155b0
	ctx.lr = 0x8234EF34;
	sub_823155B0(ctx, base);
	// 8234EF34: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234EF38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234EF3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234EF40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234EF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234EF48 size=384
    let mut pc: u32 = 0x8234EF48;
    'dispatch: loop {
        match pc {
            0x8234EF48 => {
    //   block [0x8234EF48..0x8234F0C8)
	// 8234EF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234EF4C: 48E59221  bl 0x831a816c
	ctx.lr = 0x8234EF50;
	sub_831A8130(ctx, base);
	// 8234EF50: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8234EF54: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234EF58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234EF5C: 48E056A5  bl 0x83154600
	ctx.lr = 0x8234EF60;
	sub_83154600(ctx, base);
	// 8234EF60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234EF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234EF68: 48B0A811  bl 0x82e59778
	ctx.lr = 0x8234EF6C;
	sub_82E59778(ctx, base);
	// 8234EF6C: C3FF0070  lfs f31, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234EF70: FF1F0800  fcmpu cr6, f31, f1
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 8234EF74: 41980008  blt cr6, 0x8234ef7c
	if ctx.cr[6].lt {
	pc = 0x8234EF7C; continue 'dispatch;
	}
	// 8234EF78: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234EF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234EF80: 48B0A7E1  bl 0x82e59760
	ctx.lr = 0x8234EF84;
	sub_82E59760(ctx, base);
	// 8234EF84: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234EF88: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8234EF8C: 48E59E3D  bl 0x831a8dc8
	ctx.lr = 0x8234EF90;
	sub_831A8DC8(ctx, base);
	// 8234EF90: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8234EF94: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8234EF98: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 8234EF9C: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8234EFA0: 39200060  li r9, 0x60
	ctx.r[9].s64 = 96;
	// 8234EFA4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8234EFA8: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 8234EFAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8234EFB0: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234EFB4: 13C05407  vcmpneb. (lvlx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234F0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234F0C8 size=444
    let mut pc: u32 = 0x8234F0C8;
    'dispatch: loop {
        match pc {
            0x8234F0C8 => {
    //   block [0x8234F0C8..0x8234F284)
	// 8234F0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234F0CC: 48E59099  bl 0x831a8164
	ctx.lr = 0x8234F0D0;
	sub_831A8130(ctx, base);
	// 8234F0D0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8234F0D4: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234F0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234F0DC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8234F0E0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8234F0E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8234F0E8: 48E05519  bl 0x83154600
	ctx.lr = 0x8234F0EC;
	sub_83154600(ctx, base);
	// 8234F0EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F0F0: 38C00053  li r6, 0x53
	ctx.r[6].s64 = 83;
	// 8234F0F4: 38AB30B8  addi r5, r11, 0x30b8
	ctx.r[5].s64 = ctx.r[11].s64 + 12472;
	// 8234F0F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8234F0FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234F100: 4BFB6969  bl 0x82305a68
	ctx.lr = 0x8234F104;
	sub_82305A68(ctx, base);
	// 8234F104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234F108: 4BFC4341  bl 0x82313448
	ctx.lr = 0x8234F10C;
	sub_82313448(ctx, base);
	// 8234F10C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234F114: C00B9528  lfs f0, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234F118: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 8234F11C: 4098001C  bge cr6, 0x8234f138
	if !ctx.cr[6].lt {
	pc = 0x8234F138; continue 'dispatch;
	}
	// 8234F120: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8234F124: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 8234F128: 4BFC6489  bl 0x823155b0
	ctx.lr = 0x8234F12C;
	sub_823155B0(ctx, base);
	// 8234F12C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234F130: 48B0A601  bl 0x82e59730
	ctx.lr = 0x8234F134;
	sub_82E59730(ctx, base);
	// 8234F134: 48000144  b 0x8234f278
	pc = 0x8234F278; continue 'dispatch;
	// 8234F138: D3FF0070  stfs f31, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8234F13C: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 8234F140: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234F144: 13C0D8C7  vcmpequd (lvx128) v30, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234F288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234F288 size=196
    let mut pc: u32 = 0x8234F288;
    'dispatch: loop {
        match pc {
            0x8234F288 => {
    //   block [0x8234F288..0x8234F34C)
	// 8234F288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234F28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234F290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234F294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234F298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234F29C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8234F2A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234F2A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8234F2A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8234F2AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234F2B0: 4BF71689  bl 0x822c0938
	ctx.lr = 0x8234F2B4;
	sub_822C0938(ctx, base);
	// 8234F2B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234F2B8: 41820028  beq 0x8234f2e0
	if ctx.cr[0].eq {
	pc = 0x8234F2E0; continue 'dispatch;
	}
	// 8234F2BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F2C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8234F2C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8234F2C8: 392B3134  addi r9, r11, 0x3134
	ctx.r[9].s64 = ctx.r[11].s64 + 12596;
	// 8234F2CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8234F2D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8234F2D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8234F2D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8234F2DC: 48000008  b 0x8234f2e4
	pc = 0x8234F2E4; continue 'dispatch;
	// 8234F2E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8234F2E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234F2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234F2EC: 409A0044  bne cr6, 0x8234f330
	if !ctx.cr[6].eq {
	pc = 0x8234F330; continue 'dispatch;
	}
	// 8234F2F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8234F2F4: 419A001C  beq cr6, 0x8234f310
	if ctx.cr[6].eq {
	pc = 0x8234F310; continue 'dispatch;
	}
	// 8234F2F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234F2FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234F300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234F304: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234F308: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234F30C: 4E800421  bctrl
	ctx.lr = 0x8234F310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234F310: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234F314: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234F318: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F31C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8234F320: 816BAEDC  lwz r11, -0x5124(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20772 as u32) ) } as u64;
	// 8234F324: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8234F328: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8234F32C: 4BF70CD5  bl 0x822c0000
	ctx.lr = 0x8234F330;
	sub_822C0000(ctx, base);
	// 8234F330: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234F334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234F338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234F33C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234F340: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234F344: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234F348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234F350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234F350 size=120
    let mut pc: u32 = 0x8234F350;
    'dispatch: loop {
        match pc {
            0x8234F350 => {
    //   block [0x8234F350..0x8234F3C8)
	// 8234F350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234F354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234F358: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234F35C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234F360: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234F364: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F368: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234F36C: 396B315C  addi r11, r11, 0x315c
	ctx.r[11].s64 = ctx.r[11].s64 + 12636;
	// 8234F370: 394A3148  addi r10, r10, 0x3148
	ctx.r[10].s64 = ctx.r[10].s64 + 12616;
	// 8234F374: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8234F378: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8234F37C: 807F00DC  lwz r3, 0xdc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 8234F380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234F384: 419A0008  beq cr6, 0x8234f38c
	if ctx.cr[6].eq {
	pc = 0x8234F38C; continue 'dispatch;
	}
	// 8234F388: 4BF71509  bl 0x822c0890
	ctx.lr = 0x8234F38C;
	sub_822C0890(ctx, base);
	// 8234F38C: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8234F390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234F394: 419A0008  beq cr6, 0x8234f39c
	if ctx.cr[6].eq {
	pc = 0x8234F39C; continue 'dispatch;
	}
	// 8234F398: 4BF714F9  bl 0x822c0890
	ctx.lr = 0x8234F39C;
	sub_822C0890(ctx, base);
	// 8234F39C: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 8234F3A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234F3A4: 419A0008  beq cr6, 0x8234f3ac
	if ctx.cr[6].eq {
	pc = 0x8234F3AC; continue 'dispatch;
	}
	// 8234F3A8: 4BF714E9  bl 0x822c0890
	ctx.lr = 0x8234F3AC;
	sub_822C0890(ctx, base);
	// 8234F3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234F3B0: 481C1DE9  bl 0x82511198
	ctx.lr = 0x8234F3B4;
	sub_82511198(ctx, base);
	// 8234F3B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8234F3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234F3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234F3C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234F3C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234F3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8234F3C8 size=8
    let mut pc: u32 = 0x8234F3C8;
    'dispatch: loop {
        match pc {
            0x8234F3C8 => {
    //   block [0x8234F3C8..0x8234F3D0)
	// 8234F3C8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8234F3CC: 48000004  b 0x8234f3d0
	sub_8234F3D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234F3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8234F3D0 size=76
    let mut pc: u32 = 0x8234F3D0;
    'dispatch: loop {
        match pc {
            0x8234F3D0 => {
    //   block [0x8234F3D0..0x8234F41C)
	// 8234F3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234F3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234F3D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234F3DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234F3E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234F3E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234F3E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8234F3EC: 4BFFFF65  bl 0x8234f350
	ctx.lr = 0x8234F3F0;
	sub_8234F350(ctx, base);
	// 8234F3F0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234F3F4: 4182000C  beq 0x8234f400
	if ctx.cr[0].eq {
	pc = 0x8234F400; continue 'dispatch;
	}
	// 8234F3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234F3FC: 48AA2FDD  bl 0x82df23d8
	ctx.lr = 0x8234F400;
	sub_82DF23D8(ctx, base);
	// 8234F400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234F404: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8234F408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8234F40C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8234F410: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8234F414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8234F418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234F420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234F420 size=140
    let mut pc: u32 = 0x8234F420;
    'dispatch: loop {
        match pc {
            0x8234F420 => {
    //   block [0x8234F420..0x8234F4AC)
	// 8234F420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234F424: 48E58D45  bl 0x831a8168
	ctx.lr = 0x8234F428;
	sub_831A8130(ctx, base);
	// 8234F428: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234F42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234F430: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8234F434: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8234F438: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8234F43C: 481C2EF5  bl 0x82512330
	ctx.lr = 0x8234F440;
	sub_82512330(ctx, base);
	// 8234F440: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234F444: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 8234F448: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234F44C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8234F450: 390000F0  li r8, 0xf0
	ctx.r[8].s64 = 240;
	// 8234F454: 394A31B4  addi r10, r10, 0x31b4
	ctx.r[10].s64 = ctx.r[10].s64 + 12724;
	// 8234F458: 3929319C  addi r9, r9, 0x319c
	ctx.r[9].s64 = ctx.r[9].s64 + 12700;
	// 8234F45C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234F460: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8234F464: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8234F468: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 8234F46C: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234F4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234F4B0 size=1488
    let mut pc: u32 = 0x8234F4B0;
    'dispatch: loop {
        match pc {
            0x8234F4B0 => {
    //   block [0x8234F4B0..0x8234FA80)
	// 8234F4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234F4B4: 48E58CA5  bl 0x831a8158
	ctx.lr = 0x8234F4B8;
	sub_831A8130(ctx, base);
	// 8234F4B8: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 8234F4BC: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 8234F4C0: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8234F4C4: 9421FC80  stwu r1, -0x380(r1)
	ea = ctx.r[1].u32.wrapping_add(-896 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234F4C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234F4CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8234F4D0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8234F4D4: 481BFE9D  bl 0x8250f370
	ctx.lr = 0x8234F4D8;
	sub_8250F370(ctx, base);
	// 8234F4D8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8234F4DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F4E0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8234F4E4: 48AA4525  bl 0x82df3a08
	ctx.lr = 0x8234F4E8;
	sub_82DF3A08(ctx, base);
	// 8234F4E8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8234F4EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234F4F4: 481B928D  bl 0x82508780
	ctx.lr = 0x8234F4F8;
	sub_82508780(ctx, base);
	// 8234F4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F4FC: 48AA3F2D  bl 0x82df3428
	ctx.lr = 0x8234F500;
	sub_82DF3428(ctx, base);
	// 8234F500: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8234F504: 389D0028  addi r4, r29, 0x28
	ctx.r[4].s64 = ctx.r[29].s64 + 40;
	// 8234F508: 409A0008  bne cr6, 0x8234f510
	if !ctx.cr[6].eq {
	pc = 0x8234F510; continue 'dispatch;
	}
	// 8234F50C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8234F510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234F514: 481B928D  bl 0x825087a0
	ctx.lr = 0x8234F518;
	sub_825087A0(ctx, base);
	// 8234F518: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234F51C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234F520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F524: 388A32F4  addi r4, r10, 0x32f4
	ctx.r[4].s64 = ctx.r[10].s64 + 13044;
	// 8234F528: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234F52C: D3FD00E8  stfs f31, 0xe8(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8234F530: 48AA44D9  bl 0x82df3a08
	ctx.lr = 0x8234F534;
	sub_82DF3A08(ctx, base);
	// 8234F534: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8234F538: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234F53C: 481BFF8D  bl 0x8250f4c8
	ctx.lr = 0x8234F540;
	sub_8250F4C8(ctx, base);
	// 8234F540: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234F544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234F548: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8234F54C: 409A0008  bne cr6, 0x8234f554
	if !ctx.cr[6].eq {
	pc = 0x8234F554; continue 'dispatch;
	}
	// 8234F550: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8234F554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234F558: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8234F55C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8234F560: 481BAF81  bl 0x8250a4e0
	ctx.lr = 0x8234F564;
	sub_8250A4E0(ctx, base);
	// 8234F564: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234F568: 48AA2729  bl 0x82df1c90
	ctx.lr = 0x8234F56C;
	sub_82DF1C90(ctx, base);
	// 8234F56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F570: 48AA3EB9  bl 0x82df3428
	ctx.lr = 0x8234F574;
	sub_82DF3428(ctx, base);
	// 8234F574: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8234F578: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8234F57C: 3BCB2728  addi r30, r11, 0x2728
	ctx.r[30].s64 = ctx.r[11].s64 + 10024;
	// 8234F580: 3BEAAEC0  addi r31, r10, -0x5140
	ctx.r[31].s64 = ctx.r[10].s64 + -20800;
	// 8234F584: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234F58C: 419A02B4  beq cr6, 0x8234f840
	if ctx.cr[6].eq {
	pc = 0x8234F840; continue 'dispatch;
	}
	// 8234F590: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F598: 388B32E4  addi r4, r11, 0x32e4
	ctx.r[4].s64 = ctx.r[11].s64 + 13028;
	// 8234F59C: 48AA446D  bl 0x82df3a08
	ctx.lr = 0x8234F5A0;
	sub_82DF3A08(ctx, base);
	// 8234F5A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F5A4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8234F5A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234F5AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234F5B0: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 8234F5B4: C3CB964C  lfs f30, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8234F5B8: C3AADD6C  lfs f29, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234F5BC: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234F5C0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8234F5C4: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F5C8: 48253BE9  bl 0x825a31b0
	ctx.lr = 0x8234F5CC;
	sub_825A31B0(ctx, base);
	// 8234F5CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F5D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F5D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F5D8: 482536A1  bl 0x825a2c78
	ctx.lr = 0x8234F5DC;
	sub_825A2C78(ctx, base);
	// 8234F5DC: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 8234F5E0: 48AA3E49  bl 0x82df3428
	ctx.lr = 0x8234F5E4;
	sub_82DF3428(ctx, base);
	// 8234F5E4: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 8234F5E8: 4BF796D1  bl 0x822c8cb8
	ctx.lr = 0x8234F5EC;
	sub_822C8CB8(ctx, base);
	// 8234F5EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F5F0: 48AA3E39  bl 0x82df3428
	ctx.lr = 0x8234F5F4;
	sub_82DF3428(ctx, base);
	// 8234F5F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F5FC: 388B32D0  addi r4, r11, 0x32d0
	ctx.r[4].s64 = ctx.r[11].s64 + 13008;
	// 8234F600: 48AA4409  bl 0x82df3a08
	ctx.lr = 0x8234F604;
	sub_82DF3A08(ctx, base);
	// 8234F604: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 8234F608: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 8234F60C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234F610: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8234F614: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234F618: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F61C: 48253B95  bl 0x825a31b0
	ctx.lr = 0x8234F620;
	sub_825A31B0(ctx, base);
	// 8234F620: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F624: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F628: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F62C: 4825364D  bl 0x825a2c78
	ctx.lr = 0x8234F630;
	sub_825A2C78(ctx, base);
	// 8234F630: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 8234F634: 48AA3DF5  bl 0x82df3428
	ctx.lr = 0x8234F638;
	sub_82DF3428(ctx, base);
	// 8234F638: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 8234F63C: 4BF7967D  bl 0x822c8cb8
	ctx.lr = 0x8234F640;
	sub_822C8CB8(ctx, base);
	// 8234F640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F644: 48AA3DE5  bl 0x82df3428
	ctx.lr = 0x8234F648;
	sub_82DF3428(ctx, base);
	// 8234F648: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F64C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F650: 388B32C0  addi r4, r11, 0x32c0
	ctx.r[4].s64 = ctx.r[11].s64 + 12992;
	// 8234F654: 48AA43B5  bl 0x82df3a08
	ctx.lr = 0x8234F658;
	sub_82DF3A08(ctx, base);
	// 8234F658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8234F65C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8234F660: 38C003E8  li r6, 0x3e8
	ctx.r[6].s64 = 1000;
	// 8234F664: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8234F668: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 8234F66C: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F670: 48253D39  bl 0x825a33a8
	ctx.lr = 0x8234F674;
	sub_825A33A8(ctx, base);
	// 8234F674: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F678: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F67C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F680: 48253691  bl 0x825a2d10
	ctx.lr = 0x8234F684;
	sub_825A2D10(ctx, base);
	// 8234F684: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 8234F688: 48AA3DA1  bl 0x82df3428
	ctx.lr = 0x8234F68C;
	sub_82DF3428(ctx, base);
	// 8234F68C: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 8234F690: 4BF79629  bl 0x822c8cb8
	ctx.lr = 0x8234F694;
	sub_822C8CB8(ctx, base);
	// 8234F694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F698: 48AA3D91  bl 0x82df3428
	ctx.lr = 0x8234F69C;
	sub_82DF3428(ctx, base);
	// 8234F69C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F6A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F6A4: 388B32B0  addi r4, r11, 0x32b0
	ctx.r[4].s64 = ctx.r[11].s64 + 12976;
	// 8234F6A8: 48AA4361  bl 0x82df3a08
	ctx.lr = 0x8234F6AC;
	sub_82DF3A08(ctx, base);
	// 8234F6AC: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 8234F6B0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8234F6B4: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234F6B8: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8234F6BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234F6C0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F6C4: 48253AED  bl 0x825a31b0
	ctx.lr = 0x8234F6C8;
	sub_825A31B0(ctx, base);
	// 8234F6C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F6CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F6D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F6D4: 482535A5  bl 0x825a2c78
	ctx.lr = 0x8234F6D8;
	sub_825A2C78(ctx, base);
	// 8234F6D8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8234F6DC: 48AA3D4D  bl 0x82df3428
	ctx.lr = 0x8234F6E0;
	sub_82DF3428(ctx, base);
	// 8234F6E0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 8234F6E4: 4BF795D5  bl 0x822c8cb8
	ctx.lr = 0x8234F6E8;
	sub_822C8CB8(ctx, base);
	// 8234F6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F6EC: 48AA3D3D  bl 0x82df3428
	ctx.lr = 0x8234F6F0;
	sub_82DF3428(ctx, base);
	// 8234F6F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F6F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F6F8: 388B329C  addi r4, r11, 0x329c
	ctx.r[4].s64 = ctx.r[11].s64 + 12956;
	// 8234F6FC: 48AA430D  bl 0x82df3a08
	ctx.lr = 0x8234F700;
	sub_82DF3A08(ctx, base);
	// 8234F700: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8234F704: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8234F708: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234F70C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8234F710: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234F714: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F718: 48253A99  bl 0x825a31b0
	ctx.lr = 0x8234F71C;
	sub_825A31B0(ctx, base);
	// 8234F71C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F720: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F724: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F728: 48253551  bl 0x825a2c78
	ctx.lr = 0x8234F72C;
	sub_825A2C78(ctx, base);
	// 8234F72C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 8234F730: 48AA3CF9  bl 0x82df3428
	ctx.lr = 0x8234F734;
	sub_82DF3428(ctx, base);
	// 8234F734: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 8234F738: 4BF79581  bl 0x822c8cb8
	ctx.lr = 0x8234F73C;
	sub_822C8CB8(ctx, base);
	// 8234F73C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F740: 48AA3CE9  bl 0x82df3428
	ctx.lr = 0x8234F744;
	sub_82DF3428(ctx, base);
	// 8234F744: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F74C: 388B3284  addi r4, r11, 0x3284
	ctx.r[4].s64 = ctx.r[11].s64 + 12932;
	// 8234F750: 48AA42B9  bl 0x82df3a08
	ctx.lr = 0x8234F754;
	sub_82DF3A08(ctx, base);
	// 8234F754: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 8234F758: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 8234F75C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234F760: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8234F764: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234F768: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F76C: 48253A45  bl 0x825a31b0
	ctx.lr = 0x8234F770;
	sub_825A31B0(ctx, base);
	// 8234F770: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F774: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F778: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F77C: 482534FD  bl 0x825a2c78
	ctx.lr = 0x8234F780;
	sub_825A2C78(ctx, base);
	// 8234F780: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 8234F784: 48AA3CA5  bl 0x82df3428
	ctx.lr = 0x8234F788;
	sub_82DF3428(ctx, base);
	// 8234F788: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 8234F78C: 4BF7952D  bl 0x822c8cb8
	ctx.lr = 0x8234F790;
	sub_822C8CB8(ctx, base);
	// 8234F790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F794: 48AA3C95  bl 0x82df3428
	ctx.lr = 0x8234F798;
	sub_82DF3428(ctx, base);
	// 8234F798: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F79C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F7A0: 388B3268  addi r4, r11, 0x3268
	ctx.r[4].s64 = ctx.r[11].s64 + 12904;
	// 8234F7A4: 48AA4265  bl 0x82df3a08
	ctx.lr = 0x8234F7A8;
	sub_82DF3A08(ctx, base);
	// 8234F7A8: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 8234F7AC: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 8234F7B0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234F7B4: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8234F7B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8234F7BC: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F7C0: 482539F1  bl 0x825a31b0
	ctx.lr = 0x8234F7C4;
	sub_825A31B0(ctx, base);
	// 8234F7C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F7C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F7CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F7D0: 482534A9  bl 0x825a2c78
	ctx.lr = 0x8234F7D4;
	sub_825A2C78(ctx, base);
	// 8234F7D4: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 8234F7D8: 48AA3C51  bl 0x82df3428
	ctx.lr = 0x8234F7DC;
	sub_82DF3428(ctx, base);
	// 8234F7DC: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 8234F7E0: 4BF794D9  bl 0x822c8cb8
	ctx.lr = 0x8234F7E4;
	sub_822C8CB8(ctx, base);
	// 8234F7E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F7E8: 48AA3C41  bl 0x82df3428
	ctx.lr = 0x8234F7EC;
	sub_82DF3428(ctx, base);
	// 8234F7EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F7F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F7F4: 388B3250  addi r4, r11, 0x3250
	ctx.r[4].s64 = ctx.r[11].s64 + 12880;
	// 8234F7F8: 48AA4211  bl 0x82df3a08
	ctx.lr = 0x8234F7FC;
	sub_82DF3A08(ctx, base);
	// 8234F7FC: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 8234F800: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 8234F804: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8234F808: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8234F80C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8234F810: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234F814: 4825399D  bl 0x825a31b0
	ctx.lr = 0x8234F818;
	sub_825A31B0(ctx, base);
	// 8234F818: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8234F81C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234F820: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8234F824: 48253455  bl 0x825a2c78
	ctx.lr = 0x8234F828;
	sub_825A2C78(ctx, base);
	// 8234F828: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 8234F82C: 48AA3BFD  bl 0x82df3428
	ctx.lr = 0x8234F830;
	sub_82DF3428(ctx, base);
	// 8234F830: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 8234F834: 4BF79485  bl 0x822c8cb8
	ctx.lr = 0x8234F838;
	sub_822C8CB8(ctx, base);
	// 8234F838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234F83C: 48AA3BED  bl 0x82df3428
	ctx.lr = 0x8234F840;
	sub_82DF3428(ctx, base);
	// 8234F840: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 8234F844: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 8234F848: 81492730  lwz r10, 0x2730(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10032 as u32) ) } as u64;
	// 8234F84C: 554B07FF  clrlwi. r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8234F850: 4082003C  bne 0x8234f88c
	if !ctx.cr[0].eq {
	pc = 0x8234F88C; continue 'dispatch;
	}
	// 8234F854: E8DE0002  lwa r6, 0(r30)
	ctx.r[6].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 8234F858: 3D008212  lis r8, -0x7dee
	ctx.r[8].s64 = -2112749568;
	// 8234F85C: F8C10060  std r6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u64 ) };
	// 8234F860: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8234F864: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 8234F868: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 8234F86C: C008DFAC  lfs f0, -0x2054(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234F870: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8234F874: C1A79524  lfs f13, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234F878: 614B0001  ori r11, r10, 1
	ctx.r[11].u64 = ctx.r[10].u64 | 1;
	// 8234F87C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8234F880: 91692730  stw r11, 0x2730(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(10032 as u32), ctx.r[11].u32 ) };
	// 8234F884: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8234F888: D019272C  stfs f0, 0x272c(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(10028 as u32), tmp.u32 ) };
	// 8234F88C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234F890: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8234F894: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234F898: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8234F89C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8234F8A0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8234F8A4: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8234F8A8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8234F8AC: 481C286D  bl 0x82512118
	ctx.lr = 0x8234F8B0;
	sub_82512118(ctx, base);
	// 8234F8B0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234F8B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234F8B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8234F8BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234F8C0: 4E800421  bctrl
	ctx.lr = 0x8234F8C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234F8C4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8234F8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234F8CC: 419A0008  beq cr6, 0x8234f8d4
	if ctx.cr[6].eq {
	pc = 0x8234F8D4; continue 'dispatch;
	}
	// 8234F8D0: 4BF70FC1  bl 0x822c0890
	ctx.lr = 0x8234F8D4;
	sub_822C0890(ctx, base);
	// 8234F8D4: 817D00E4  lwz r11, 0xe4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 8234F8D8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234F8DC: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 8234F8E0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8234F8E4: 41980008  blt cr6, 0x8234f8ec
	if ctx.cr[6].lt {
	pc = 0x8234F8EC; continue 'dispatch;
	}
	// 8234F8E8: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 8234F8EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8234F8F0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8234F8F4: 40990168  ble cr6, 0x8234fa5c
	if !ctx.cr[6].gt {
	pc = 0x8234FA5C; continue 'dispatch;
	}
	// 8234F8F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234F8FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234F900: 3B6B31F0  addi r27, r11, 0x31f0
	ctx.r[27].s64 = ctx.r[11].s64 + 12784;
	// 8234F904: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8234F908: 7F8B07B4  extsw r11, r28
	ctx.r[11].s64 = ctx.r[28].s32 as i64;
	// 8234F90C: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8234F910: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8234F914: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8234F918: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 8234F91C: C80100B0  lfd f0, 0xb0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 8234F920: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8234F924: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8234F928: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8234F92C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8234F930: C019272C  lfs f0, 0x272c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(10028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234F934: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8234F938: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8234F93C: 48B2D305  bl 0x82e7cc40
	ctx.lr = 0x8234F940;
	sub_82E7CC40(ctx, base);
	// 8234F940: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234F944: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 8234F948: 48B2C551  bl 0x82e7be98
	ctx.lr = 0x8234F94C;
	sub_82E7BE98(ctx, base);
	// 8234F94C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8234F950: 388102E0  addi r4, r1, 0x2e0
	ctx.r[4].s64 = ctx.r[1].s64 + 736;
	// 8234F954: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8234F958: 48B2C3F1  bl 0x82e7bd48
	ctx.lr = 0x8234F95C;
	sub_82E7BD48(ctx, base);
	// 8234F95C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8234F960: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234F964: 38A00068  li r5, 0x68
	ctx.r[5].s64 = 104;
	// 8234F968: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 8234F96C: 48AA2A7D  bl 0x82df23e8
	ctx.lr = 0x8234F970;
	sub_82DF23E8(ctx, base);
	// 8234F970: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8234F974: 41820010  beq 0x8234f984
	if ctx.cr[0].eq {
	pc = 0x8234F984; continue 'dispatch;
	}
	// 8234F978: 48297049  bl 0x825e69c0
	ctx.lr = 0x8234F97C;
	sub_825E69C0(ctx, base);
	// 8234F97C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234F980: 48000008  b 0x8234f988
	pc = 0x8234F988; continue 'dispatch;
	// 8234F984: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8234F988: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8234F98C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234F990: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234F994: 4BFFF8F5  bl 0x8234f288
	ctx.lr = 0x8234F998;
	sub_8234F288(ctx, base);
	// 8234F998: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234F99C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234F9A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8234F9A4: 4BF7065D  bl 0x822c0000
	ctx.lr = 0x8234F9A8;
	sub_822C0000(ctx, base);
	// 8234F9A8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8234F9AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8234F9B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8234F9B4: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8234F9B8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8234F9BC: 419A0024  beq cr6, 0x8234f9e0
	if ctx.cr[6].eq {
	pc = 0x8234F9E0; continue 'dispatch;
	}
	// 8234F9C0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8234F9C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8234F9C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234F9CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8234F9D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8234F9D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8234F9D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8234F9DC: 4082FFE8  bne 0x8234f9c4
	if !ctx.cr[0].eq {
	pc = 0x8234F9C4; continue 'dispatch;
	}
	// 8234F9E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8234F9E4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8234F9E8: 481BFAE1  bl 0x8250f4c8
	ctx.lr = 0x8234F9EC;
	sub_8250F4C8(ctx, base);
	// 8234F9EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234F9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234F9F4: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 8234F9F8: 409A0008  bne cr6, 0x8234fa00
	if !ctx.cr[6].eq {
	pc = 0x8234FA00; continue 'dispatch;
	}
	// 8234F9FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8234FA00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8234FA04: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8234FA08: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 8234FA0C: 481BFB0D  bl 0x8250f518
	ctx.lr = 0x8234FA10;
	sub_8250F518(ctx, base);
	// 8234FA10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8234FA14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8234FA18: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 8234FA1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234FA20: 481BDAE9  bl 0x8250d508
	ctx.lr = 0x8234FA24;
	sub_8250D508(ctx, base);
	// 8234FA24: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8234FA28: 48AA2269  bl 0x82df1c90
	ctx.lr = 0x8234FA2C;
	sub_82DF1C90(ctx, base);
	// 8234FA2C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8234FA30: 48AA2261  bl 0x82df1c90
	ctx.lr = 0x8234FA34;
	sub_82DF1C90(ctx, base);
	// 8234FA34: 817D00E4  lwz r11, 0xe4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 8234FA38: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8234FA3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8234FA40: 917D00E4  stw r11, 0xe4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8234FA44: 419A000C  beq cr6, 0x8234fa50
	if ctx.cr[6].eq {
	pc = 0x8234FA50; continue 'dispatch;
	}
	// 8234FA48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234FA4C: 4BF70E45  bl 0x822c0890
	ctx.lr = 0x8234FA50;
	sub_822C0890(ctx, base);
	// 8234FA50: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8234FA54: 7F1CD000  cmpw cr6, r28, r26
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[26].s32, &mut ctx.xer);
	// 8234FA58: 4198FEB0  blt cr6, 0x8234f908
	if ctx.cr[6].lt {
	pc = 0x8234F908; continue 'dispatch;
	}
	// 8234FA5C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8234FA60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234FA64: 419A0008  beq cr6, 0x8234fa6c
	if ctx.cr[6].eq {
	pc = 0x8234FA6C; continue 'dispatch;
	}
	// 8234FA68: 4BF70E29  bl 0x822c0890
	ctx.lr = 0x8234FA6C;
	sub_822C0890(ctx, base);
	// 8234FA6C: 38210380  addi r1, r1, 0x380
	ctx.r[1].s64 = ctx.r[1].s64 + 896;
	// 8234FA70: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 8234FA74: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8234FA78: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8234FA7C: 48E5872C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234FA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234FA80 size=788
    let mut pc: u32 = 0x8234FA80;
    'dispatch: loop {
        match pc {
            0x8234FA80 => {
    //   block [0x8234FA80..0x8234FD94)
	// 8234FA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234FA84: 48E586D5  bl 0x831a8158
	ctx.lr = 0x8234FA88;
	sub_831A8130(ctx, base);
	// 8234FA88: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 8234FA8C: 48E58FED  bl 0x831a8a78
	ctx.lr = 0x8234FA90;
	sub_831A8A40(ctx, base);
	// 8234FA90: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234FA94: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8234FA98: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8234FA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234FAA0: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 8234FAA4: 816A2738  lwz r11, 0x2738(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10040 as u32) ) } as u64;
	// 8234FAA8: C3C908A8  lfs f30, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8234FAAC: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8234FAB0: 40820044  bne 0x8234faf4
	if !ctx.cr[0].eq {
	pc = 0x8234FAF4; continue 'dispatch;
	}
	// 8234FAB4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8234FAB8: 3D008212  lis r8, -0x7dee
	ctx.r[8].s64 = -2112749568;
	// 8234FABC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 8234FAC0: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 8234FAC4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8234FAC8: C8093308  lfd f0, 0x3308(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(13064 as u32) ) };
	// 8234FACC: ED60002C  fsqrts f11, f0
	ctx.f[11].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 8234FAD0: C008DFAC  lfs f0, -0x2054(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234FAD4: C1A79524  lfs f13, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234FAD8: 916A2738  stw r11, 0x2738(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(10040 as u32), ctx.r[11].u32 ) };
	// 8234FADC: C1869450  lfs f12, -0x6bb0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234FAE0: ED6BF02A  fadds f11, f11, f30
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 8234FAE4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8234FAE8: EDABF33A  fmadds f13, f11, f12, f30
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[30].f64) as f32) as f64);
	// 8234FAEC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8234FAF0: D0192734  stfs f0, 0x2734(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(10036 as u32), tmp.u32 ) };
	// 8234FAF4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234FAF8: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234FAFC: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234FB00: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8234FB04: 3BABAED4  addi r29, r11, -0x512c
	ctx.r[29].s64 = ctx.r[11].s64 + -20780;
	// 8234FB08: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8234FB0C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8234FB10: C01DFFF4  lfs f0, -0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234FB14: C1BDFFF8  lfs f13, -8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8234FB18: D17F00EC  stfs f11, 0xec(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8234FB1C: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8234FB20: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8234FB24: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8234FB28: EC2B0332  fmuls f1, f11, f12
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 8234FB2C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8234FB30: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8234FB34: 48E5BF65  bl 0x831aba98
	ctx.lr = 0x8234FB38;
	sub_831ABA98(ctx, base);
	// 8234FB38: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8234FB3C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 8234FB40: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8234FB44: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8234FB48: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 8234FB4C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8234FB50: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8234FB54: 41980008  blt cr6, 0x8234fb5c
	if ctx.cr[6].lt {
	pc = 0x8234FB5C; continue 'dispatch;
	}
	// 8234FB58: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 8234FB5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234FB60: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8234FB64: 481C25B5  bl 0x82512118
	ctx.lr = 0x8234FB68;
	sub_82512118(ctx, base);
	// 8234FB68: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234FB6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234FB70: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8234FB74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8234FB78: 4E800421  bctrl
	ctx.lr = 0x8234FB7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8234FB7C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 8234FB80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8234FB84: 419A0008  beq cr6, 0x8234fb8c
	if ctx.cr[6].eq {
	pc = 0x8234FB8C; continue 'dispatch;
	}
	// 8234FB88: 4BF70D09  bl 0x822c0890
	ctx.lr = 0x8234FB8C;
	sub_822C0890(ctx, base);
	// 8234FB8C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8234FB90: 409901E0  ble cr6, 0x8234fd70
	if !ctx.cr[6].gt {
	pc = 0x8234FD70; continue 'dispatch;
	}
	// 8234FB94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234FB98: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8234FB9C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8234FBA0: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 8234FBA4: 3B6B31F0  addi r27, r11, 0x31f0
	ctx.r[27].s64 = ctx.r[11].s64 + 12784;
	// 8234FBA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234FBAC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8234FBB0: 481BF781  bl 0x8250f330
	ctx.lr = 0x8234FBB4;
	sub_8250F330(ctx, base);
	// 8234FBB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234FBB8: 48199C99  bl 0x824e9850
	ctx.lr = 0x8234FBBC;
	sub_824E9850(ctx, base);
	// 8234FBBC: C01DFFFC  lfs f0, -4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234FBC0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8234FBC4: EFA10032  fmuls f29, f1, f0
	ctx.f[29].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8234FBC8: 48AA20C9  bl 0x82df1c90
	ctx.lr = 0x8234FBCC;
	sub_82DF1C90(ctx, base);
	// 8234FBCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234FBD0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234FBD4: 481BF75D  bl 0x8250f330
	ctx.lr = 0x8234FBD8;
	sub_8250F330(ctx, base);
	// 8234FBD8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234FBDC: 48199C75  bl 0x824e9850
	ctx.lr = 0x8234FBE0;
	sub_824E9850(ctx, base);
	// 8234FBE0: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234FBE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8234FBE8: EF810032  fmuls f28, f1, f0
	ctx.f[28].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8234FBEC: 48AA20A5  bl 0x82df1c90
	ctx.lr = 0x8234FBF0;
	sub_82DF1C90(ctx, base);
	// 8234FBF0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8234FBF4: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8234FBF8: D3810088  stfs f28, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8234FBFC: D3A10084  stfs f29, 0x84(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8234FC00: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 8234FC04: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8234FC08: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8234FC0C: D3C10064  stfs f30, 0x64(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8234FC10: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8234FC14: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234FC18: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234FD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8234FD98 size=208
    let mut pc: u32 = 0x8234FD98;
    'dispatch: loop {
        match pc {
            0x8234FD98 => {
    //   block [0x8234FD98..0x8234FE68)
	// 8234FD98: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8234FD9C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234FDA0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 8234FDA4: 13C020C7  vcmpequd (lvx128) v30, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234FDA8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 8234FDAC: 13A348C7  vcmpequd (lvx128) v29, v3, v9
	tmp.u32 = ctx.r[3].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234FE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234FE68 size=156
    let mut pc: u32 = 0x8234FE68;
    'dispatch: loop {
        match pc {
            0x8234FE68 => {
    //   block [0x8234FE68..0x8234FF04)
	// 8234FE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234FE6C: 48E582F9  bl 0x831a8164
	ctx.lr = 0x8234FE70;
	sub_831A8130(ctx, base);
	// 8234FE70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234FE74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234FE78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8234FE7C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8234FE80: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8234FE84: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8234FE88: 481C24A9  bl 0x82512330
	ctx.lr = 0x8234FE8C;
	sub_82512330(ctx, base);
	// 8234FE8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234FE90: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 8234FE94: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234FE98: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8234FE9C: 394A332C  addi r10, r10, 0x332c
	ctx.r[10].s64 = ctx.r[10].s64 + 13100;
	// 8234FEA0: 39293314  addi r9, r9, 0x3314
	ctx.r[9].s64 = ctx.r[9].s64 + 13076;
	// 8234FEA4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8234FEA8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8234FEAC: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8234FEB0: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 8234FEB4: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8234FEB8: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8234FF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8234FF08 size=720
    let mut pc: u32 = 0x8234FF08;
    'dispatch: loop {
        match pc {
            0x8234FF08 => {
    //   block [0x8234FF08..0x823501D8)
	// 8234FF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8234FF0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8234FF10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8234FF14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8234FF18: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 8234FF1C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8234FF20: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8234FF24: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8234FF28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8234FF2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8234FF30: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8234FF34: 481BF43D  bl 0x8250f370
	ctx.lr = 0x8234FF38;
	sub_8250F370(ctx, base);
	// 8234FF38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8234FF3C: 3D408328  lis r10, -0x7cd8
	ctx.r[10].s64 = -2094530560;
	// 8234FF40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234FF44: C3AB08A4  lfs f29, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8234FF48: D3BF00E8  stfs f29, 0xe8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8234FF4C: D3BF00EC  stfs f29, 0xec(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8234FF50: 808AE250  lwz r4, -0x1db0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8234FF54: 48AA3AB5  bl 0x82df3a08
	ctx.lr = 0x8234FF58;
	sub_82DF3A08(ctx, base);
	// 8234FF58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8234FF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234FF60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8234FF64: 481B881D  bl 0x82508780
	ctx.lr = 0x8234FF68;
	sub_82508780(ctx, base);
	// 8234FF68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234FF6C: 48AA34BD  bl 0x82df3428
	ctx.lr = 0x8234FF70;
	sub_82DF3428(ctx, base);
	// 8234FF70: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8234FF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8234FF78: 481B8829  bl 0x825087a0
	ctx.lr = 0x8234FF7C;
	sub_825087A0(ctx, base);
	// 8234FF7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234FF80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234FF84: 388B3398  addi r4, r11, 0x3398
	ctx.r[4].s64 = ctx.r[11].s64 + 13208;
	// 8234FF88: 48AA3A81  bl 0x82df3a08
	ctx.lr = 0x8234FF8C;
	sub_82DF3A08(ctx, base);
	// 8234FF8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8234FF90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8234FF94: 481BF535  bl 0x8250f4c8
	ctx.lr = 0x8234FF98;
	sub_8250F4C8(ctx, base);
	// 8234FF98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8234FF9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234FFA0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8234FFA4: 409A0008  bne cr6, 0x8234ffac
	if !ctx.cr[6].eq {
	pc = 0x8234FFAC; continue 'dispatch;
	}
	// 8234FFA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8234FFAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8234FFB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8234FFB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8234FFB8: 481BA529  bl 0x8250a4e0
	ctx.lr = 0x8234FFBC;
	sub_8250A4E0(ctx, base);
	// 8234FFBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8234FFC0: 48AA1CD1  bl 0x82df1c90
	ctx.lr = 0x8234FFC4;
	sub_82DF1C90(ctx, base);
	// 8234FFC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234FFC8: 48AA3461  bl 0x82df3428
	ctx.lr = 0x8234FFCC;
	sub_82DF3428(ctx, base);
	// 8234FFCC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8234FFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8234FFD4: 419A01D0  beq cr6, 0x823501a4
	if ctx.cr[6].eq {
	pc = 0x823501A4; continue 'dispatch;
	}
	// 8234FFD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8234FFDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8234FFE0: 388B3390  addi r4, r11, 0x3390
	ctx.r[4].s64 = ctx.r[11].s64 + 13200;
	// 8234FFE4: 48AA3A25  bl 0x82df3a08
	ctx.lr = 0x8234FFE8;
	sub_82DF3A08(ctx, base);
	// 8234FFE8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8234FFEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8234FFF0: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8234FFF4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 8234FFF8: 3BEBAF70  addi r31, r11, -0x5090
	ctx.r[31].s64 = ctx.r[11].s64 + -20624;
	// 8234FFFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82350000: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82350004: C3CA964C  lfs f30, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82350008: C3E9DD6C  lfs f31, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8235000C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82350010: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82350014: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82350018: 48253199  bl 0x825a31b0
	ctx.lr = 0x8235001C;
	sub_825A31B0(ctx, base);
	// 8235001C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82350020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82350028: 48252C51  bl 0x825a2c78
	ctx.lr = 0x8235002C;
	sub_825A2C78(ctx, base);
	// 8235002C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82350030: 48AA33F9  bl 0x82df3428
	ctx.lr = 0x82350034;
	sub_82DF3428(ctx, base);
	// 82350034: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82350038: 4BF78C81  bl 0x822c8cb8
	ctx.lr = 0x8235003C;
	sub_822C8CB8(ctx, base);
	// 8235003C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350040: 48AA33E9  bl 0x82df3428
	ctx.lr = 0x82350044;
	sub_82DF3428(ctx, base);
	// 82350044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82350048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8235004C: 388B3380  addi r4, r11, 0x3380
	ctx.r[4].s64 = ctx.r[11].s64 + 13184;
	// 82350050: 48AA39B9  bl 0x82df3a08
	ctx.lr = 0x82350054;
	sub_82DF3A08(ctx, base);
	// 82350054: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82350058: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 8235005C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82350060: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82350064: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82350068: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8235006C: 48253145  bl 0x825a31b0
	ctx.lr = 0x82350070;
	sub_825A31B0(ctx, base);
	// 82350070: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82350074: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8235007C: 48252BFD  bl 0x825a2c78
	ctx.lr = 0x82350080;
	sub_825A2C78(ctx, base);
	// 82350080: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82350084: 48AA33A5  bl 0x82df3428
	ctx.lr = 0x82350088;
	sub_82DF3428(ctx, base);
	// 82350088: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 8235008C: 4BF78C2D  bl 0x822c8cb8
	ctx.lr = 0x82350090;
	sub_822C8CB8(ctx, base);
	// 82350090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350094: 48AA3395  bl 0x82df3428
	ctx.lr = 0x82350098;
	sub_82DF3428(ctx, base);
	// 82350098: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8235009C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823500A0: 388B3250  addi r4, r11, 0x3250
	ctx.r[4].s64 = ctx.r[11].s64 + 12880;
	// 823500A4: 48AA3965  bl 0x82df3a08
	ctx.lr = 0x823500A8;
	sub_82DF3A08(ctx, base);
	// 823500A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823500AC: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 823500B0: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 823500B4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 823500B8: C3EB08A8  lfs f31, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823500BC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 823500C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823500C4: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823500C8: 482530E9  bl 0x825a31b0
	ctx.lr = 0x823500CC;
	sub_825A31B0(ctx, base);
	// 823500CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 823500D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823500D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823500D8: 48252BA1  bl 0x825a2c78
	ctx.lr = 0x823500DC;
	sub_825A2C78(ctx, base);
	// 823500DC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 823500E0: 48AA3349  bl 0x82df3428
	ctx.lr = 0x823500E4;
	sub_82DF3428(ctx, base);
	// 823500E4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 823500E8: 4BF78BD1  bl 0x822c8cb8
	ctx.lr = 0x823500EC;
	sub_822C8CB8(ctx, base);
	// 823500EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823500F0: 48AA3339  bl 0x82df3428
	ctx.lr = 0x823500F4;
	sub_82DF3428(ctx, base);
	// 823500F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823500F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823500FC: 388B3374  addi r4, r11, 0x3374
	ctx.r[4].s64 = ctx.r[11].s64 + 13172;
	// 82350100: 48AA3909  bl 0x82df3a08
	ctx.lr = 0x82350104;
	sub_82DF3A08(ctx, base);
	// 82350104: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82350108: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8235010C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82350110: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82350114: C3CB95A0  lfs f30, -0x6a60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82350118: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8235011C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82350120: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82350124: 4825308D  bl 0x825a31b0
	ctx.lr = 0x82350128;
	sub_825A31B0(ctx, base);
	// 82350128: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8235012C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82350134: 48252B45  bl 0x825a2c78
	ctx.lr = 0x82350138;
	sub_825A2C78(ctx, base);
	// 82350138: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 8235013C: 48AA32ED  bl 0x82df3428
	ctx.lr = 0x82350140;
	sub_82DF3428(ctx, base);
	// 82350140: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82350144: 4BF78B75  bl 0x822c8cb8
	ctx.lr = 0x82350148;
	sub_822C8CB8(ctx, base);
	// 82350148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8235014C: 48AA32DD  bl 0x82df3428
	ctx.lr = 0x82350150;
	sub_82DF3428(ctx, base);
	// 82350150: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82350154: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350158: 388B3368  addi r4, r11, 0x3368
	ctx.r[4].s64 = ctx.r[11].s64 + 13160;
	// 8235015C: 48AA38AD  bl 0x82df3a08
	ctx.lr = 0x82350160;
	sub_82DF3A08(ctx, base);
	// 82350160: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82350164: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82350168: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8235016C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82350170: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82350174: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82350178: 48253039  bl 0x825a31b0
	ctx.lr = 0x8235017C;
	sub_825A31B0(ctx, base);
	// 8235017C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82350180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350188: 48252AF1  bl 0x825a2c78
	ctx.lr = 0x8235018C;
	sub_825A2C78(ctx, base);
	// 8235018C: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82350190: 48AA3299  bl 0x82df3428
	ctx.lr = 0x82350194;
	sub_82DF3428(ctx, base);
	// 82350194: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 82350198: 4BF78B21  bl 0x822c8cb8
	ctx.lr = 0x8235019C;
	sub_822C8CB8(ctx, base);
	// 8235019C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823501A0: 48AA3289  bl 0x82df3428
	ctx.lr = 0x823501A4;
	sub_82DF3428(ctx, base);
	// 823501A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 823501A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823501AC: 419A0008  beq cr6, 0x823501b4
	if ctx.cr[6].eq {
	pc = 0x823501B4; continue 'dispatch;
	}
	// 823501B0: 4BF706E1  bl 0x822c0890
	ctx.lr = 0x823501B4;
	sub_822C0890(ctx, base);
	// 823501B4: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 823501B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823501BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823501C0: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 823501C4: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823501C8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 823501CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823501D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823501D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823501D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823501D8 size=972
    let mut pc: u32 = 0x823501D8;
    'dispatch: loop {
        match pc {
            0x823501D8 => {
    //   block [0x823501D8..0x823505A4)
	// 823501D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823501DC: 48E57F75  bl 0x831a8150
	ctx.lr = 0x823501E0;
	sub_831A8130(ctx, base);
	// 823501E0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 823501E4: 48E58889  bl 0x831a8a6c
	ctx.lr = 0x823501E8;
	sub_831A8A40(ctx, base);
	// 823501E8: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823505A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823505A8 size=68
    let mut pc: u32 = 0x823505A8;
    'dispatch: loop {
        match pc {
            0x823505A8 => {
    //   block [0x823505A8..0x823505EC)
	// 823505A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823505AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823505B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823505B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823505B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823505BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823505C0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823505C4: 396B3414  addi r11, r11, 0x3414
	ctx.r[11].s64 = ctx.r[11].s64 + 13332;
	// 823505C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823505CC: 41820008  beq 0x823505d4
	if ctx.cr[0].eq {
	pc = 0x823505D4; continue 'dispatch;
	}
	// 823505D0: 4BF6FC99  bl 0x822c0268
	ctx.lr = 0x823505D4;
	sub_822C0268(ctx, base);
	// 823505D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823505D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823505DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823505E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823505E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823505E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823505F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823505F0 size=12
    let mut pc: u32 = 0x823505F0;
    'dispatch: loop {
        match pc {
            0x823505F0 => {
    //   block [0x823505F0..0x823505FC)
	// 823505F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823505F4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823505F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82350600 size=28
    let mut pc: u32 = 0x82350600;
    'dispatch: loop {
        match pc {
            0x82350600 => {
    //   block [0x82350600..0x8235061C)
	// 82350600: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82350604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82350608: 394A3438  addi r10, r10, 0x3438
	ctx.r[10].s64 = ctx.r[10].s64 + 13368;
	// 8235060C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82350610: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82350614: 99630020  stb r11, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82350618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82350620 size=140
    let mut pc: u32 = 0x82350620;
    'dispatch: loop {
        match pc {
            0x82350620 => {
    //   block [0x82350620..0x823506AC)
	// 82350620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350628: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 8235062C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350630: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82350634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82350638: 419A0014  beq cr6, 0x8235064c
	if ctx.cr[6].eq {
	pc = 0x8235064C; continue 'dispatch;
	}
	// 8235063C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82350640: 409A000C  bne cr6, 0x8235064c
	if !ctx.cr[6].eq {
	pc = 0x8235064C; continue 'dispatch;
	}
	// 82350644: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82350648: 48000050  b 0x82350698
	pc = 0x82350698; continue 'dispatch;
	// 8235064C: 89630020  lbz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82350650: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82350654: 41820040  beq 0x82350694
	if ctx.cr[0].eq {
	pc = 0x82350694; continue 'dispatch;
	}
	// 82350658: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 8235065C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82350660: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82350664: 13E558C7  vcmpequd (lvx128) v31, v5, v11
	tmp.u32 = ctx.r[5].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82350668: 13C358C7  vcmpequd (lvx128) v30, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823506B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823506B0 size=24
    let mut pc: u32 = 0x823506B0;
    'dispatch: loop {
        match pc {
            0x823506B0 => {
    //   block [0x823506B0..0x823506C8)
	// 823506B0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 823506B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823506B8: 99430020  stb r10, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 823506BC: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823506C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823506C8 size=68
    let mut pc: u32 = 0x823506C8;
    'dispatch: loop {
        match pc {
            0x823506C8 => {
    //   block [0x823506C8..0x8235070C)
	// 823506C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823506CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823506D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823506D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823506D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823506DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823506E0: 48AA3329  bl 0x82df3a08
	ctx.lr = 0x823506E4;
	sub_82DF3A08(ctx, base);
	// 823506E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823506E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823506EC: 4BFB12AD  bl 0x82301998
	ctx.lr = 0x823506F0;
	sub_82301998(ctx, base);
	// 823506F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823506F4: 48AA2D35  bl 0x82df3428
	ctx.lr = 0x823506F8;
	sub_82DF3428(ctx, base);
	// 823506F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823506FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82350704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82350710 size=12
    let mut pc: u32 = 0x82350710;
    'dispatch: loop {
        match pc {
            0x82350710 => {
    //   block [0x82350710..0x8235071C)
	// 82350710: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82350714: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 82350718: 4BFC1530  b 0x82311c48
	sub_82311C48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82350720 size=28
    let mut pc: u32 = 0x82350720;
    'dispatch: loop {
        match pc {
            0x82350720 => {
    //   block [0x82350720..0x8235073C)
	// 82350720: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82350724: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82350728: 41980050  blt cr6, 0x82350778
	if ctx.cr[6].lt {
		sub_82350778(ctx, base);
		return;
	}
	// 8235072C: 419A0038  beq cr6, 0x82350764
	if ctx.cr[6].eq {
		sub_82350764(ctx, base);
		return;
	}
	// 82350730: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82350734: 4198001C  blt cr6, 0x82350750
	if ctx.cr[6].lt {
		sub_82350750(ctx, base);
		return;
	}
	// 82350738: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8235073C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8235073C size=20
    let mut pc: u32 = 0x8235073C;
    'dispatch: loop {
        match pc {
            0x8235073C => {
    //   block [0x8235073C..0x82350750)
	// 8235073C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350740: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82350744: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82350748: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8235074C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82350750 size=20
    let mut pc: u32 = 0x82350750;
    'dispatch: loop {
        match pc {
            0x82350750 => {
    //   block [0x82350750..0x82350764)
	// 82350750: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350754: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82350758: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8235075C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82350760: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350764(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82350764 size=20
    let mut pc: u32 = 0x82350764;
    'dispatch: loop {
        match pc {
            0x82350764 => {
    //   block [0x82350764..0x82350778)
	// 82350764: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350768: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8235076C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82350770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82350774: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82350778 size=20
    let mut pc: u32 = 0x82350778;
    'dispatch: loop {
        match pc {
            0x82350778 => {
    //   block [0x82350778..0x8235078C)
	// 82350778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8235077C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82350780: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82350784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82350788: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8235078C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8235078C size=4
    let mut pc: u32 = 0x8235078C;
    'dispatch: loop {
        match pc {
            0x8235078C => {
    //   block [0x8235078C..0x82350790)
	// 8235078C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350790 size=116
    let mut pc: u32 = 0x82350790;
    'dispatch: loop {
        match pc {
            0x82350790 => {
    //   block [0x82350790..0x82350804)
	// 82350790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8235079C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823507A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823507A4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 823507A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823507AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823507B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823507B4: 808BB528  lwz r4, -0x4ad8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19160 as u32) ) } as u64;
	// 823507B8: 48AA3251  bl 0x82df3a08
	ctx.lr = 0x823507BC;
	sub_82DF3A08(ctx, base);
	// 823507BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823507C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823507C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823507C8: 4BFB3DB1  bl 0x82304578
	ctx.lr = 0x823507CC;
	sub_82304578(ctx, base);
	// 823507CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823507D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823507D4: 48AA2C55  bl 0x82df3428
	ctx.lr = 0x823507D8;
	sub_82DF3428(ctx, base);
	// 823507D8: 38DF0024  addi r6, r31, 0x24
	ctx.r[6].s64 = ctx.r[31].s64 + 36;
	// 823507DC: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 823507E0: 88BF0020  lbz r5, 0x20(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823507E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823507E8: 48035CE1  bl 0x823864c8
	ctx.lr = 0x823507EC;
	sub_823864C8(ctx, base);
	// 823507EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823507F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823507F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823507F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823507FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350808 size=76
    let mut pc: u32 = 0x82350808;
    'dispatch: loop {
        match pc {
            0x82350808 => {
    //   block [0x82350808..0x82350854)
	// 82350808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8235080C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350814: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350818: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8235081C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82350820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350824: 808BB528  lwz r4, -0x4ad8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19160 as u32) ) } as u64;
	// 82350828: 48AA31E1  bl 0x82df3a08
	ctx.lr = 0x8235082C;
	sub_82DF3A08(ctx, base);
	// 8235082C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350834: 4BFB363D  bl 0x82303e70
	ctx.lr = 0x82350838;
	sub_82303E70(ctx, base);
	// 82350838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8235083C: 48AA2BED  bl 0x82df3428
	ctx.lr = 0x82350840;
	sub_82DF3428(ctx, base);
	// 82350840: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82350844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8235084C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350858 size=96
    let mut pc: u32 = 0x82350858;
    'dispatch: loop {
        match pc {
            0x82350858 => {
    //   block [0x82350858..0x823508B8)
	// 82350858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8235085C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350860: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82350864: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8235086C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82350870: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82350874: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350878: 83DF0320  lwz r30, 0x320(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(800 as u32) ) } as u64;
	// 8235087C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82350880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82350884: 4E800421  bctrl
	ctx.lr = 0x82350888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82350888: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8235088C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82350890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350894: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82350898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8235089C: 4E800421  bctrl
	ctx.lr = 0x823508A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823508A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823508A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823508A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823508AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823508B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823508B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823508B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823508B8 size=12
    let mut pc: u32 = 0x823508B8;
    'dispatch: loop {
        match pc {
            0x823508B8 => {
    //   block [0x823508B8..0x823508C4)
	// 823508B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823508BC: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 823508C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823508C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823508C8 size=120
    let mut pc: u32 = 0x823508C8;
    'dispatch: loop {
        match pc {
            0x823508C8 => {
    //   block [0x823508C8..0x82350940)
	// 823508C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823508CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823508D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823508D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823508D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823508DC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 823508E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823508E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823508E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823508EC: 808BB3CC  lwz r4, -0x4c34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19508 as u32) ) } as u64;
	// 823508F0: 48AA3119  bl 0x82df3a08
	ctx.lr = 0x823508F4;
	sub_82DF3A08(ctx, base);
	// 823508F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823508F8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 823508FC: 4BFB0ED5  bl 0x823017d0
	ctx.lr = 0x82350900;
	sub_823017D0(ctx, base);
	// 82350900: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82350904: 48AA2A05  bl 0x82df3308
	ctx.lr = 0x82350908;
	sub_82DF3308(ctx, base);
	// 82350908: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8235090C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350910: 48AA2B19  bl 0x82df3428
	ctx.lr = 0x82350914;
	sub_82DF3428(ctx, base);
	// 82350914: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8235091C: 40820008  bne 0x82350924
	if !ctx.cr[0].eq {
	pc = 0x82350924; continue 'dispatch;
	}
	// 82350920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82350924: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82350928: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8235092C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350930: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82350934: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82350938: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8235093C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350940 size=116
    let mut pc: u32 = 0x82350940;
    'dispatch: loop {
        match pc {
            0x82350940 => {
    //   block [0x82350940..0x823509B4)
	// 82350940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8235094C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350950: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350954: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82350958: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8235095C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82350960: 409A000C  bne cr6, 0x8235096c
	if !ctx.cr[6].eq {
	pc = 0x8235096C; continue 'dispatch;
	}
	// 82350964: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350968: 48000030  b 0x82350998
	pc = 0x82350998; continue 'dispatch;
	// 8235096C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82350970: 419A0024  beq cr6, 0x82350994
	if ctx.cr[6].eq {
	pc = 0x82350994; continue 'dispatch;
	}
	// 82350974: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82350978: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8235097C: 388B19B8  addi r4, r11, 0x19b8
	ctx.r[4].s64 = ctx.r[11].s64 + 6584;
	// 82350980: 48E57779  bl 0x831a80f8
	ctx.lr = 0x82350984;
	sub_831A80F8(ctx, base);
	// 82350984: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350988: 4182000C  beq 0x82350994
	if ctx.cr[0].eq {
	pc = 0x82350994; continue 'dispatch;
	}
	// 8235098C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82350990: 4800000C  b 0x8235099c
	pc = 0x8235099C; continue 'dispatch;
	// 82350994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82350998: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8235099C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823509A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823509A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823509A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823509AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823509B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823509B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823509B8 size=136
    let mut pc: u32 = 0x823509B8;
    'dispatch: loop {
        match pc {
            0x823509B8 => {
    //   block [0x823509B8..0x82350A40)
	// 823509B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823509BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823509C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823509C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823509C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823509CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823509D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823509D4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823509D8: 409A0020  bne cr6, 0x823509f8
	if !ctx.cr[6].eq {
	pc = 0x823509F8; continue 'dispatch;
	}
	// 823509DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823509E0: 419A0048  beq cr6, 0x82350a28
	if ctx.cr[6].eq {
	pc = 0x82350A28; continue 'dispatch;
	}
	// 823509E4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 823509E8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 823509EC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 823509F0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 823509F4: 48000034  b 0x82350a28
	pc = 0x82350A28; continue 'dispatch;
	// 823509F8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 823509FC: 419A002C  beq cr6, 0x82350a28
	if ctx.cr[6].eq {
	pc = 0x82350A28; continue 'dispatch;
	}
	// 82350A00: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82350A04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350A08: 388B1A10  addi r4, r11, 0x1a10
	ctx.r[4].s64 = ctx.r[11].s64 + 6672;
	// 82350A0C: 48E576ED  bl 0x831a80f8
	ctx.lr = 0x82350A10;
	sub_831A80F8(ctx, base);
	// 82350A10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350A14: 4182000C  beq 0x82350a20
	if ctx.cr[0].eq {
	pc = 0x82350A20; continue 'dispatch;
	}
	// 82350A18: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82350A1C: 4800000C  b 0x82350a28
	pc = 0x82350A28; continue 'dispatch;
	// 82350A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82350A24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82350A28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82350A2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350A30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82350A34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82350A38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350A3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82350A40 size=484
    let mut pc: u32 = 0x82350A40;
    'dispatch: loop {
        match pc {
            0x82350A40 => {
    //   block [0x82350A40..0x82350C24)
	// 82350A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350A48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350A4C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350A50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82350A54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82350A58: 48C60061  bl 0x82fb0ab8
	ctx.lr = 0x82350A5C;
	sub_82FB0AB8(ctx, base);
	// 82350A5C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82350A60: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82350A64: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82350A68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82350A6C: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82350A70: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82350A74: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82350A78: C1A8964C  lfs f13, -0x69b4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82350A7C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82350A80: C1870A90  lfs f12, 0xa90(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2704 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82350A84: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 82350A88: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82350A8C: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82350A90: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82350A94: C1669534  lfs f11, -0x6acc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82350A98: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82350A9C: C1095110  lfs f8, 0x5110(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20752 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82350AA0: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82350AA4: C0E89450  lfs f7, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82350AA8: C0C7ACFC  lfs f6, -0x5304(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82350AAC: 394A5100  addi r10, r10, 0x5100
	ctx.r[10].s64 = ctx.r[10].s64 + 20736;
	// 82350AB0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82350AB4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82350AB8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82350C28 size=24
    let mut pc: u32 = 0x82350C28;
    'dispatch: loop {
        match pc {
            0x82350C28 => {
    //   block [0x82350C28..0x82350C40)
	// 82350C28: 80E40060  lwz r7, 0x60(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 82350C2C: 38C40050  addi r6, r4, 0x50
	ctx.r[6].s64 = ctx.r[4].s64 + 80;
	// 82350C30: 80A4001C  lwz r5, 0x1c(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82350C34: 80840018  lwz r4, 0x18(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82350C38: 806300C4  lwz r3, 0xc4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350C3C: 48026AB4  b 0x823776f0
	sub_823776F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350C40 size=116
    let mut pc: u32 = 0x82350C40;
    'dispatch: loop {
        match pc {
            0x82350C40 => {
    //   block [0x82350C40..0x82350CB4)
	// 82350C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350C48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350C4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350C50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82350C54: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 82350C58: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350C5C: 4BFC3085  bl 0x82313ce0
	ctx.lr = 0x82350C60;
	sub_82313CE0(ctx, base);
	// 82350C60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350C64: 4082003C  bne 0x82350ca0
	if !ctx.cr[0].eq {
	pc = 0x82350CA0; continue 'dispatch;
	}
	// 82350C68: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82350C6C: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350C70: 4BFC3D49  bl 0x823149b8
	ctx.lr = 0x82350C74;
	sub_823149B8(ctx, base);
	// 82350C74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350C78: 41820028  beq 0x82350ca0
	if ctx.cr[0].eq {
	pc = 0x82350CA0; continue 'dispatch;
	}
	// 82350C7C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82350C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350C84: 808BB3D0  lwz r4, -0x4c30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 82350C88: 48AA2D81  bl 0x82df3a08
	ctx.lr = 0x82350C8C;
	sub_82DF3A08(ctx, base);
	// 82350C8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350C94: 4BFB13C5  bl 0x82302058
	ctx.lr = 0x82350C98;
	sub_82302058(ctx, base);
	// 82350C98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350C9C: 48AA278D  bl 0x82df3428
	ctx.lr = 0x82350CA0;
	sub_82DF3428(ctx, base);
	// 82350CA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82350CA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350CA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82350CAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350CB8 size=96
    let mut pc: u32 = 0x82350CB8;
    'dispatch: loop {
        match pc {
            0x82350CB8 => {
    //   block [0x82350CB8..0x82350D18)
	// 82350CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350CC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350CC4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350CC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82350CCC: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82350CD0: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350CD4: 4BFC3CE5  bl 0x823149b8
	ctx.lr = 0x82350CD8;
	sub_823149B8(ctx, base);
	// 82350CD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350CDC: 41820028  beq 0x82350d04
	if ctx.cr[0].eq {
	pc = 0x82350D04; continue 'dispatch;
	}
	// 82350CE0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82350CE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350CE8: 808BB3DC  lwz r4, -0x4c24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19492 as u32) ) } as u64;
	// 82350CEC: 48AA2D1D  bl 0x82df3a08
	ctx.lr = 0x82350CF0;
	sub_82DF3A08(ctx, base);
	// 82350CF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350CF8: 4BFB1361  bl 0x82302058
	ctx.lr = 0x82350CFC;
	sub_82302058(ctx, base);
	// 82350CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350D00: 48AA2729  bl 0x82df3428
	ctx.lr = 0x82350D04;
	sub_82DF3428(ctx, base);
	// 82350D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82350D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82350D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82350D18 size=144
    let mut pc: u32 = 0x82350D18;
    'dispatch: loop {
        match pc {
            0x82350D18 => {
    //   block [0x82350D18..0x82350DA8)
	// 82350D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350D1C: 48E57445  bl 0x831a8160
	ctx.lr = 0x82350D20;
	sub_831A8130(ctx, base);
	// 82350D20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350D24: 806300C4  lwz r3, 0xc4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350D28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82350D2C: 4801CC5D  bl 0x8236d988
	ctx.lr = 0x82350D30;
	sub_8236D988(ctx, base);
	// 82350D30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82350D34: 4082000C  bne 0x82350d40
	if !ctx.cr[0].eq {
	pc = 0x82350D40; continue 'dispatch;
	}
	// 82350D38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82350D3C: 48000064  b 0x82350da0
	pc = 0x82350DA0; continue 'dispatch;
	// 82350D40: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350D48: 839E0020  lwz r28, 0x20(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82350D4C: 837E001C  lwz r27, 0x1c(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82350D50: 835E0018  lwz r26, 0x18(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82350D54: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82350D58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82350D5C: 4E800421  bctrl
	ctx.lr = 0x82350D60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82350D60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82350D64: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 82350D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350D6C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82350D70: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82350D74: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82350D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82350D7C: 4E800421  bctrl
	ctx.lr = 0x82350D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82350D80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82350D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350D88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82350D8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82350D90: 4E800421  bctrl
	ctx.lr = 0x82350D94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82350D94: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82350D98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82350D9C: D02B0000  stfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82350DA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82350DA4: 48E5740C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350DA8 size=96
    let mut pc: u32 = 0x82350DA8;
    'dispatch: loop {
        match pc {
            0x82350DA8 => {
    //   block [0x82350DA8..0x82350E08)
	// 82350DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350DB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350DB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350DB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82350DBC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82350DC0: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350DC4: 4BFC3BF5  bl 0x823149b8
	ctx.lr = 0x82350DC8;
	sub_823149B8(ctx, base);
	// 82350DC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350DCC: 41820028  beq 0x82350df4
	if ctx.cr[0].eq {
	pc = 0x82350DF4; continue 'dispatch;
	}
	// 82350DD0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82350DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350DD8: 808BB450  lwz r4, -0x4bb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19376 as u32) ) } as u64;
	// 82350DDC: 48AA2C2D  bl 0x82df3a08
	ctx.lr = 0x82350DE0;
	sub_82DF3A08(ctx, base);
	// 82350DE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82350DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82350DE8: 4BFB1271  bl 0x82302058
	ctx.lr = 0x82350DEC;
	sub_82302058(ctx, base);
	// 82350DEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350DF0: 48AA2639  bl 0x82df3428
	ctx.lr = 0x82350DF4;
	sub_82DF3428(ctx, base);
	// 82350DF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82350DF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350DFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82350E00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82350E08 size=140
    let mut pc: u32 = 0x82350E08;
    'dispatch: loop {
        match pc {
            0x82350E08 => {
    //   block [0x82350E08..0x82350E94)
	// 82350E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350E0C: 48E57361  bl 0x831a816c
	ctx.lr = 0x82350E10;
	sub_831A8130(ctx, base);
	// 82350E10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350E14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82350E18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82350E1C: 807E00C4  lwz r3, 0xc4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350E20: 4BFC7531  bl 0x82318350
	ctx.lr = 0x82350E24;
	sub_82318350(ctx, base);
	// 82350E24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350E28: 40820064  bne 0x82350e8c
	if !ctx.cr[0].eq {
	pc = 0x82350E8C; continue 'dispatch;
	}
	// 82350E2C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82350E30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82350E34: 808BB470  lwz r4, -0x4b90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19344 as u32) ) } as u64;
	// 82350E38: 48AA2BD1  bl 0x82df3a08
	ctx.lr = 0x82350E3C;
	sub_82DF3A08(ctx, base);
	// 82350E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82350E40: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82350E44: 4BFB098D  bl 0x823017d0
	ctx.lr = 0x82350E48;
	sub_823017D0(ctx, base);
	// 82350E48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82350E4C: 48AA2455  bl 0x82df32a0
	ctx.lr = 0x82350E50;
	sub_82DF32A0(ctx, base);
	// 82350E50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82350E54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82350E58: 48AA25D1  bl 0x82df3428
	ctx.lr = 0x82350E5C;
	sub_82DF3428(ctx, base);
	// 82350E5C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350E60: 4182002C  beq 0x82350e8c
	if ctx.cr[0].eq {
	pc = 0x82350E8C; continue 'dispatch;
	}
	// 82350E64: 38DF0040  addi r6, r31, 0x40
	ctx.r[6].s64 = ctx.r[31].s64 + 64;
	// 82350E68: C0BF0060  lfs f5, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82350E6C: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 82350E70: C09F005C  lfs f4, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82350E74: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82350E78: C07F0058  lfs f3, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82350E7C: 807E00C4  lwz r3, 0xc4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350E80: C05F0054  lfs f2, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82350E84: C03F0050  lfs f1, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82350E88: 4801FE69  bl 0x82370cf0
	ctx.lr = 0x82350E8C;
	sub_82370CF0(ctx, base);
	// 82350E8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82350E90: 48E5732C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82350E98 size=132
    let mut pc: u32 = 0x82350E98;
    'dispatch: loop {
        match pc {
            0x82350E98 => {
    //   block [0x82350E98..0x82350F1C)
	// 82350E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350E9C: 48E572D1  bl 0x831a816c
	ctx.lr = 0x82350EA0;
	sub_831A8130(ctx, base);
	// 82350EA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350EA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82350EA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82350EAC: 807E00C4  lwz r3, 0xc4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350EB0: 4BFC74A1  bl 0x82318350
	ctx.lr = 0x82350EB4;
	sub_82318350(ctx, base);
	// 82350EB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350EB8: 4082005C  bne 0x82350f14
	if !ctx.cr[0].eq {
	pc = 0x82350F14; continue 'dispatch;
	}
	// 82350EBC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82350EC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350EC4: 808BB474  lwz r4, -0x4b8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19340 as u32) ) } as u64;
	// 82350EC8: 48AA2B41  bl 0x82df3a08
	ctx.lr = 0x82350ECC;
	sub_82DF3A08(ctx, base);
	// 82350ECC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82350ED0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82350ED4: 4BFB08FD  bl 0x823017d0
	ctx.lr = 0x82350ED8;
	sub_823017D0(ctx, base);
	// 82350ED8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82350EDC: 48AA23C5  bl 0x82df32a0
	ctx.lr = 0x82350EE0;
	sub_82DF32A0(ctx, base);
	// 82350EE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82350EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82350EE8: 48AA2541  bl 0x82df3428
	ctx.lr = 0x82350EEC;
	sub_82DF3428(ctx, base);
	// 82350EEC: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82350EF0: 41820024  beq 0x82350f14
	if ctx.cr[0].eq {
	pc = 0x82350F14; continue 'dispatch;
	}
	// 82350EF4: 38FF0050  addi r7, r31, 0x50
	ctx.r[7].s64 = ctx.r[31].s64 + 80;
	// 82350EF8: 893F0064  lbz r9, 0x64(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82350EFC: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 82350F00: C05F0060  lfs f2, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82350F04: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82350F08: C03F0040  lfs f1, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82350F0C: 807E00C4  lwz r3, 0xc4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350F10: 4801FF29  bl 0x82370e38
	ctx.lr = 0x82350F14;
	sub_82370E38(ctx, base);
	// 82350F14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82350F18: 48E572A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82350F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82350F20 size=52
    let mut pc: u32 = 0x82350F20;
    'dispatch: loop {
        match pc {
            0x82350F20 => {
    //   block [0x82350F20..0x82350F54)
	// 82350F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82350F24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82350F28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82350F2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82350F30: 806300C4  lwz r3, 0xc4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82350F34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82350F38: 4BFC1DC1  bl 0x82312cf8
	ctx.lr = 0x82350F3C;
	sub_82312CF8(ctx, base);
	// 82350F3C: 987F0018  stb r3, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u8 ) };
	// 82350F40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82350F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82350F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82350F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82350F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


